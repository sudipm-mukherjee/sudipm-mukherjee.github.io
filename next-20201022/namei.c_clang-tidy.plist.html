<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/fs/ext4/namei.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/*\n *  linux/fs/ext4/namei.c\n *\n * Copyright (C) 1992, 1993, 1994, 1995\n * Remy Card (card@masi.ibp.fr)\n * Laboratoire MASI - Institut Blaise Pascal\n * Universite Pierre et Marie Curie (Paris VI)\n *\n *  from\n *\n *  linux/fs/minix/namei.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n *\n *  Big-endian to little-endian byte-swapping/bitmaps by\n *        David S. Miller (davem@caip.rutgers.edu), 1995\n *  Directory entry file type support and forward compatibility hooks\n *\tfor B-tree directories by Theodore Ts'o (tytso@mit.edu), 1998\n *  Hash Tree Directory indexing (c)\n *\tDaniel Phillips, 2001\n *  Hash Tree Directory indexing porting\n *\tChristopher Li, 2002\n *  Hash Tree Directory indexing cleanup\n *\tTheodore Ts'o, 2002\n */\n\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/time.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/iversion.h>\n#include <linux/unicode.h>\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#include \"xattr.h\"\n#include \"acl.h\"\n\n#include <trace/events/ext4.h>\n/*\n * define how far ahead to read directories while searching them.\n */\n#define NAMEI_RA_CHUNKS  2\n#define NAMEI_RA_BLOCKS  4\n#define NAMEI_RA_SIZE\t     (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)\n\nstatic struct buffer_head *ext4_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\text4_lblk_t *block)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif (unlikely(EXT4_SB(inode->i_sb)->s_max_dir_size_kb &&\n\t\t     ((inode->i_size >> 10) >=\n\t\t      EXT4_SB(inode->i_sb)->s_max_dir_size_kb)))\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\n\tbh = ext4_bread(handle, inode, *block, EXT4_GET_BLOCKS_CREATE);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tinode->i_size += inode->i_sb->s_blocksize;\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\tbrelse(bh);\n\t\text4_std_error(inode->i_sb, err);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn bh;\n}\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\n\n/*\n * Hints to ext4_read_dirblock regarding whether we expect a directory\n * block being read to be an index block, or a block containing\n * directory entries (and if the latter, whether it was found via a\n * logical block in an htree index block).  This is used to control\n * what sort of sanity checkinig ext4_read_dirblock() will do on the\n * directory block read from the storage device.  EITHER will means\n * the caller doesn't know what kind of directory block will be read,\n * so no specific verification will be done.\n */\ntypedef enum {\n\tEITHER, INDEX, DIRENT, DIRENT_HTREE\n} dirblock_type_t;\n\n#define ext4_read_dirblock(inode, block, type) \\\n\t__ext4_read_dirblock((inode), (block), (type), __func__, __LINE__)\n\nstatic struct buffer_head *__ext4_read_dirblock(struct inode *inode,\n\t\t\t\t\t\text4_lblk_t block,\n\t\t\t\t\t\tdirblock_type_t type,\n\t\t\t\t\t\tconst char *func,\n\t\t\t\t\t\tunsigned int line)\n{\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry *dirent;\n\tint is_dx_block = 0;\n\n\tif (ext4_simulate_fail(inode->i_sb, EXT4_SIM_DIRBLOCK_EIO))\n\t\tbh = ERR_PTR(-EIO);\n\telse\n\t\tbh = ext4_bread(NULL, inode, block, 0);\n\tif (IS_ERR(bh)) {\n\t\t__ext4_warning(inode->i_sb, func, line,\n\t\t\t       \"inode #%lu: lblock %lu: comm %s: \"\n\t\t\t       \"error %ld reading directory block\",\n\t\t\t       inode->i_ino, (unsigned long)block,\n\t\t\t       current->comm, PTR_ERR(bh));\n\n\t\treturn bh;\n\t}\n\tif (!bh && (type == INDEX || type == DIRENT_HTREE)) {\n\t\text4_error_inode(inode, func, line, block,\n\t\t\t\t \"Directory hole found for htree %s block\",\n\t\t\t\t (type == INDEX) ? \"index\" : \"leaf\");\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\tif (!bh)\n\t\treturn NULL;\n\tdirent = (struct ext4_dir_entry *) bh->b_data;\n\t/* Determine whether or not we have an index block */\n\tif (is_dx(inode)) {\n\t\tif (block == 0)\n\t\t\tis_dx_block = 1;\n\t\telse if (ext4_rec_len_from_disk(dirent->rec_len,\n\t\t\t\t\t\tinode->i_sb->s_blocksize) ==\n\t\t\t inode->i_sb->s_blocksize)\n\t\t\tis_dx_block = 1;\n\t}\n\tif (!is_dx_block && type == INDEX) {\n\t\text4_error_inode(inode, func, line, block,\n\t\t       \"directory leaf block found instead of index block\");\n\t\tbrelse(bh);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\tif (!ext4_has_metadata_csum(inode->i_sb) ||\n\t    buffer_verified(bh))\n\t\treturn bh;\n\n\t/*\n\t * An empty leaf block can get mistaken for a index block; for\n\t * this reason, we can only check the index checksum when the\n\t * caller is sure it should be an index block.\n\t */\n\tif (is_dx_block && type == INDEX) {\n\t\tif (ext4_dx_csum_verify(inode, dirent) &&\n\t\t    !ext4_simulate_fail(inode->i_sb, EXT4_SIM_DIRBLOCK_CRC))\n\t\t\tset_buffer_verified(bh);\n\t\telse {\n\t\t\text4_error_inode_err(inode, func, line, block,\n\t\t\t\t\t     EFSBADCRC,\n\t\t\t\t\t     \"Directory index failed checksum\");\n\t\t\tbrelse(bh);\n\t\t\treturn ERR_PTR(-EFSBADCRC);\n\t\t}\n\t}\n\tif (!is_dx_block) {\n\t\tif (ext4_dirblock_csum_verify(inode, bh) &&\n\t\t    !ext4_simulate_fail(inode->i_sb, EXT4_SIM_DIRBLOCK_CRC))\n\t\t\tset_buffer_verified(bh);\n\t\telse {\n\t\t\text4_error_inode_err(inode, func, line, block,\n\t\t\t\t\t     EFSBADCRC,\n\t\t\t\t\t     \"Directory block failed checksum\");\n\t\t\tbrelse(bh);\n\t\t\treturn ERR_PTR(-EFSBADCRC);\n\t\t}\n\t}\n\treturn bh;\n}\n\n#ifndef assert\n#define assert(test) J_ASSERT(test)\n#endif\n\n#ifdef DX_DEBUG\n#define dxtrace(command) command\n#else\n#define dxtrace(command)\n#endif\n\nstruct fake_dirent\n{\n\t__le32 inode;\n\t__le16 rec_len;\n\tu8 name_len;\n\tu8 file_type;\n};\n\nstruct dx_countlimit\n{\n\t__le16 limit;\n\t__le16 count;\n};\n\nstruct dx_entry\n{\n\t__le32 hash;\n\t__le32 block;\n};\n\n/*\n * dx_root_info is laid out so that if it should somehow get overlaid by a\n * dirent the two low bits of the hash version will be zero.  Therefore, the\n * hash version mod 4 should never be 0.  Sincerely, the paranoia department.\n */\n\nstruct dx_root\n{\n\tstruct fake_dirent dot;\n\tchar dot_name[4];\n\tstruct fake_dirent dotdot;\n\tchar dotdot_name[4];\n\tstruct dx_root_info\n\t{\n\t\t__le32 reserved_zero;\n\t\tu8 hash_version;\n\t\tu8 info_length; /* 8 */\n\t\tu8 indirect_levels;\n\t\tu8 unused_flags;\n\t}\n\tinfo;\n\tstruct dx_entry\tentries[];\n};\n\nstruct dx_node\n{\n\tstruct fake_dirent fake;\n\tstruct dx_entry\tentries[];\n};\n\n\nstruct dx_frame\n{\n\tstruct buffer_head *bh;\n\tstruct dx_entry *entries;\n\tstruct dx_entry *at;\n};\n\nstruct dx_map_entry\n{\n\tu32 hash;\n\tu16 offs;\n\tu16 size;\n};\n\n/*\n * This goes at the end of each htree block.\n */\nstruct dx_tail {\n\tu32 dt_reserved;\n\t__le32 dt_checksum;\t/* crc32c(uuid+inum+dirblock) */\n};\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\nstatic unsigned dx_root_limit(struct inode *dir, unsigned infosize);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(struct ext4_filename *fname,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_release(struct dx_frame *frames);\nstatic int dx_make_map(struct inode *dir, struct ext4_dir_entry_2 *de,\n\t\t       unsigned blocksize, struct dx_hash_info *hinfo,\n\t\t       struct dx_map_entry map[]);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count, unsigned blocksize);\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tstruct ext4_filename *fname,\n\t\tstruct ext4_dir_entry_2 **res_dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct ext4_filename *fname,\n\t\t\t     struct inode *dir, struct inode *inode);\n\n/* checksumming functions */\nvoid ext4_initialize_dirent_tail(struct buffer_head *bh,\n\t\t\t\t unsigned int blocksize)\n{\n\tstruct ext4_dir_entry_tail *t = EXT4_DIRENT_TAIL(bh->b_data, blocksize);\n\n\tmemset(t, 0, sizeof(struct ext4_dir_entry_tail));\n\tt->det_rec_len = ext4_rec_len_to_disk(\n\t\t\tsizeof(struct ext4_dir_entry_tail), blocksize);\n\tt->det_reserved_ft = EXT4_FT_DIR_CSUM;\n}\n\n/* Walk through a dirent block to find a checksum \"dirent\" at the tail */\nstatic struct ext4_dir_entry_tail *get_dirent_tail(struct inode *inode,\n\t\t\t\t\t\t   struct buffer_head *bh)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n#ifdef PARANOID\n\tstruct ext4_dir_entry *d, *top;\n\n\td = (struct ext4_dir_entry *)bh->b_data;\n\ttop = (struct ext4_dir_entry *)(bh->b_data +\n\t\t(EXT4_BLOCK_SIZE(inode->i_sb) -\n\t\t sizeof(struct ext4_dir_entry_tail)));\n\twhile (d < top && d->rec_len)\n\t\td = (struct ext4_dir_entry *)(((void *)d) +\n\t\t    le16_to_cpu(d->rec_len));\n\n\tif (d != top)\n\t\treturn NULL;\n\n\tt = (struct ext4_dir_entry_tail *)d;\n#else\n\tt = EXT4_DIRENT_TAIL(bh->b_data, EXT4_BLOCK_SIZE(inode->i_sb));\n#endif\n\n\tif (t->det_reserved_zero1 ||\n\t    le16_to_cpu(t->det_rec_len) != sizeof(struct ext4_dir_entry_tail) ||\n\t    t->det_reserved_zero2 ||\n\t    t->det_reserved_ft != EXT4_FT_DIR_CSUM)\n\t\treturn NULL;\n\n\treturn t;\n}\n\nstatic __le32 ext4_dirblock_csum(struct inode *inode, void *dirent, int size)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__u32 csum;\n\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)dirent, size);\n\treturn cpu_to_le32(csum);\n}\n\n#define warn_no_space_for_csum(inode)\t\t\t\t\t\\\n\t__warn_no_space_for_csum((inode), __func__, __LINE__)\n\nstatic void __warn_no_space_for_csum(struct inode *inode, const char *func,\n\t\t\t\t     unsigned int line)\n{\n\t__ext4_warning_inode(inode, func, line,\n\t\t\"No space for directory leaf checksum. Please run e2fsck -D.\");\n}\n\nint ext4_dirblock_csum_verify(struct inode *inode, struct buffer_head *bh)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tt = get_dirent_tail(inode, bh);\n\tif (!t) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn 0;\n\t}\n\n\tif (t->det_checksum != ext4_dirblock_csum(inode, bh->b_data,\n\t\t\t\t\t\t  (char *)t - bh->b_data))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void ext4_dirblock_csum_set(struct inode *inode,\n\t\t\t\t struct buffer_head *bh)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tt = get_dirent_tail(inode, bh);\n\tif (!t) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn;\n\t}\n\n\tt->det_checksum = ext4_dirblock_csum(inode, bh->b_data,\n\t\t\t\t\t     (char *)t - bh->b_data);\n}\n\nint ext4_handle_dirty_dirblock(handle_t *handle,\n\t\t\t       struct inode *inode,\n\t\t\t       struct buffer_head *bh)\n{\n\text4_dirblock_csum_set(inode, bh);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}\n\nstatic struct dx_countlimit *get_dx_countlimit(struct inode *inode,\n\t\t\t\t\t       struct ext4_dir_entry *dirent,\n\t\t\t\t\t       int *offset)\n{\n\tstruct ext4_dir_entry *dp;\n\tstruct dx_root_info *root;\n\tint count_offset;\n\n\tif (le16_to_cpu(dirent->rec_len) == EXT4_BLOCK_SIZE(inode->i_sb))\n\t\tcount_offset = 8;\n\telse if (le16_to_cpu(dirent->rec_len) == 12) {\n\t\tdp = (struct ext4_dir_entry *)(((void *)dirent) + 12);\n\t\tif (le16_to_cpu(dp->rec_len) !=\n\t\t    EXT4_BLOCK_SIZE(inode->i_sb) - 12)\n\t\t\treturn NULL;\n\t\troot = (struct dx_root_info *)(((void *)dp + 12));\n\t\tif (root->reserved_zero ||\n\t\t    root->info_length != sizeof(struct dx_root_info))\n\t\t\treturn NULL;\n\t\tcount_offset = 32;\n\t} else\n\t\treturn NULL;\n\n\tif (offset)\n\t\t*offset = count_offset;\n\treturn (struct dx_countlimit *)(((void *)dirent) + count_offset);\n}\n\nstatic __le32 ext4_dx_csum(struct inode *inode, struct ext4_dir_entry *dirent,\n\t\t\t   int count_offset, int count, struct dx_tail *t)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__u32 csum;\n\tint size;\n\t__u32 dummy_csum = 0;\n\tint offset = offsetof(struct dx_tail, dt_checksum);\n\n\tsize = count_offset + (count * sizeof(struct dx_entry));\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)dirent, size);\n\tcsum = ext4_chksum(sbi, csum, (__u8 *)t, offset);\n\tcsum = ext4_chksum(sbi, csum, (__u8 *)&dummy_csum, sizeof(dummy_csum));\n\n\treturn cpu_to_le32(csum);\n}\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent)\n{\n\tstruct dx_countlimit *c;\n\tstruct dx_tail *t;\n\tint count_offset, limit, count;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tc = get_dx_countlimit(inode, dirent, &count_offset);\n\tif (!c) {\n\t\tEXT4_ERROR_INODE(inode, \"dir seems corrupt?  Run e2fsck -D.\");\n\t\treturn 0;\n\t}\n\tlimit = le16_to_cpu(c->limit);\n\tcount = le16_to_cpu(c->count);\n\tif (count_offset + (limit * sizeof(struct dx_entry)) >\n\t    EXT4_BLOCK_SIZE(inode->i_sb) - sizeof(struct dx_tail)) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn 0;\n\t}\n\tt = (struct dx_tail *)(((struct dx_entry *)c) + limit);\n\n\tif (t->dt_checksum != ext4_dx_csum(inode, dirent, count_offset,\n\t\t\t\t\t    count, t))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic void ext4_dx_csum_set(struct inode *inode, struct ext4_dir_entry *dirent)\n{\n\tstruct dx_countlimit *c;\n\tstruct dx_tail *t;\n\tint count_offset, limit, count;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tc = get_dx_countlimit(inode, dirent, &count_offset);\n\tif (!c) {\n\t\tEXT4_ERROR_INODE(inode, \"dir seems corrupt?  Run e2fsck -D.\");\n\t\treturn;\n\t}\n\tlimit = le16_to_cpu(c->limit);\n\tcount = le16_to_cpu(c->count);\n\tif (count_offset + (limit * sizeof(struct dx_entry)) >\n\t    EXT4_BLOCK_SIZE(inode->i_sb) - sizeof(struct dx_tail)) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn;\n\t}\n\tt = (struct dx_tail *)(((struct dx_entry *)c) + limit);\n\n\tt->dt_checksum = ext4_dx_csum(inode, dirent, count_offset, count, t);\n}\n\nstatic inline int ext4_handle_dirty_dx_node(handle_t *handle,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\text4_dx_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}\n\n/*\n * p is at least 6 bytes before the end of page\n */\nstatic inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}\n\n/*\n * Future: use high four bits of block for coalesce-on-delete flags\n * Mask them off for now.\n */\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x0fffffff;\n}\n\nstatic inline void dx_set_block(struct dx_entry *entry, ext4_lblk_t value)\n{\n\tentry->block = cpu_to_le32(value);\n}\n\nstatic inline unsigned dx_get_hash(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}\n\nstatic inline void dx_set_hash(struct dx_entry *entry, unsigned value)\n{\n\tentry->hash = cpu_to_le32(value);\n}\n\nstatic inline unsigned dx_get_count(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}\n\nstatic inline unsigned dx_get_limit(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->limit);\n}\n\nstatic inline void dx_set_count(struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->count = cpu_to_le16(value);\n}\n\nstatic inline void dx_set_limit(struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->limit = cpu_to_le16(value);\n}\n\nstatic inline unsigned dx_root_limit(struct inode *dir, unsigned infosize)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT4_DIR_REC_LEN(1) -\n\t\tEXT4_DIR_REC_LEN(2) - infosize;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}\n\nstatic inline unsigned dx_node_limit(struct inode *dir)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT4_DIR_REC_LEN(0);\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}\n\n/*\n * Debug\n */\n#ifdef DX_DEBUG\nstatic void dx_show_index(char * label, struct dx_entry *entries)\n{\n\tint i, n = dx_get_count (entries);\n\tprintk(KERN_DEBUG \"%s index\", label);\n\tfor (i = 0; i < n; i++) {\n\t\tprintk(KERN_CONT \" %x->%lu\",\n\t\t       i ? dx_get_hash(entries + i) : 0,\n\t\t       (unsigned long)dx_get_block(entries + i));\n\t}\n\tprintk(KERN_CONT \"\\n\");\n}\n\nstruct stats\n{\n\tunsigned names;\n\tunsigned space;\n\tunsigned bcount;\n};\n\nstatic struct stats dx_show_leaf(struct inode *dir,\n\t\t\t\tstruct dx_hash_info *hinfo,\n\t\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\t\tint size, int show_names)\n{\n\tunsigned names = 0, space = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\tprintk(\"names: \");\n\twhile ((char *) de < base + size)\n\t{\n\t\tif (de->inode)\n\t\t{\n\t\t\tif (show_names)\n\t\t\t{\n#ifdef CONFIG_FS_ENCRYPTION\n\t\t\t\tint len;\n\t\t\t\tchar *name;\n\t\t\t\tstruct fscrypt_str fname_crypto_str =\n\t\t\t\t\tFSTR_INIT(NULL, 0);\n\t\t\t\tint res = 0;\n\n\t\t\t\tname  = de->name;\n\t\t\t\tlen = de->name_len;\n\t\t\t\tif (IS_ENCRYPTED(dir))\n\t\t\t\t\tres = fscrypt_get_encryption_info(dir);\n\t\t\t\tif (res) {\n\t\t\t\t\tprintk(KERN_WARNING \"Error setting up\"\n\t\t\t\t\t       \" fname crypto: %d\\n\", res);\n\t\t\t\t}\n\t\t\t\tif (!fscrypt_has_encryption_key(dir)) {\n\t\t\t\t\t/* Directory is not encrypted */\n\t\t\t\t\text4fs_dirhash(dir, de->name,\n\t\t\t\t\t\tde->name_len, &h);\n\t\t\t\t\tprintk(\"%*.s:(U)%x.%u \", len,\n\t\t\t\t\t       name, h.hash,\n\t\t\t\t\t       (unsigned) ((char *) de\n\t\t\t\t\t\t\t   - base));\n\t\t\t\t} else {\n\t\t\t\t\tstruct fscrypt_str de_name =\n\t\t\t\t\t\tFSTR_INIT(name, len);\n\n\t\t\t\t\t/* Directory is encrypted */\n\t\t\t\t\tres = fscrypt_fname_alloc_buffer(\n\t\t\t\t\t\tlen, &fname_crypto_str);\n\t\t\t\t\tif (res)\n\t\t\t\t\t\tprintk(KERN_WARNING \"Error \"\n\t\t\t\t\t\t\t\"allocating crypto \"\n\t\t\t\t\t\t\t\"buffer--skipping \"\n\t\t\t\t\t\t\t\"crypto\\n\");\n\t\t\t\t\tres = fscrypt_fname_disk_to_usr(dir,\n\t\t\t\t\t\t0, 0, &de_name,\n\t\t\t\t\t\t&fname_crypto_str);\n\t\t\t\t\tif (res) {\n\t\t\t\t\t\tprintk(KERN_WARNING \"Error \"\n\t\t\t\t\t\t\t\"converting filename \"\n\t\t\t\t\t\t\t\"from disk to usr\"\n\t\t\t\t\t\t\t\"\\n\");\n\t\t\t\t\t\tname = \"??\";\n\t\t\t\t\t\tlen = 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tname = fname_crypto_str.name;\n\t\t\t\t\t\tlen = fname_crypto_str.len;\n\t\t\t\t\t}\n\t\t\t\t\text4fs_dirhash(dir, de->name,\n\t\t\t\t\t\t       de->name_len, &h);\n\t\t\t\t\tprintk(\"%*.s:(E)%x.%u \", len, name,\n\t\t\t\t\t       h.hash, (unsigned) ((char *) de\n\t\t\t\t\t\t\t\t   - base));\n\t\t\t\t\tfscrypt_fname_free_buffer(\n\t\t\t\t\t\t\t&fname_crypto_str);\n\t\t\t\t}\n#else\n\t\t\t\tint len = de->name_len;\n\t\t\t\tchar *name = de->name;\n\t\t\t\text4fs_dirhash(dir, de->name, de->name_len, &h);\n\t\t\t\tprintk(\"%*.s:%x.%u \", len, name, h.hash,\n\t\t\t\t       (unsigned) ((char *) de - base));\n#endif\n\t\t\t}\n\t\t\tspace += EXT4_DIR_REC_LEN(de->name_len);\n\t\t\tnames++;\n\t\t}\n\t\tde = ext4_next_entry(de, size);\n\t}\n\tprintk(KERN_CONT \"(%i)\\n\", names);\n\treturn (struct stats) { names, space, 1 };\n}\n\nstruct stats dx_show_entries(struct dx_hash_info *hinfo, struct inode *dir,\n\t\t\t     struct dx_entry *entries, int levels)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count = dx_get_count(entries), names = 0, space = 0, i;\n\tunsigned bcount = 0;\n\tstruct buffer_head *bh;\n\tprintk(\"%i indexed blocks...\\n\", count);\n\tfor (i = 0; i < count; i++, entries++)\n\t{\n\t\text4_lblk_t block = dx_get_block(entries);\n\t\text4_lblk_t hash  = i ? dx_get_hash(entries): 0;\n\t\tu32 range = i < count - 1? (dx_get_hash(entries + 1) - hash): ~hash;\n\t\tstruct stats stats;\n\t\tprintk(\"%s%3u:%03u hash %8x/%8x \",levels?\"\":\"   \", i, block, hash, range);\n\t\tbh = ext4_bread(NULL,dir, block, 0);\n\t\tif (!bh || IS_ERR(bh))\n\t\t\tcontinue;\n\t\tstats = levels?\n\t\t   dx_show_entries(hinfo, dir, ((struct dx_node *) bh->b_data)->entries, levels - 1):\n\t\t   dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *)\n\t\t\tbh->b_data, blocksize, 0);\n\t\tnames += stats.names;\n\t\tspace += stats.space;\n\t\tbcount += stats.bcount;\n\t\tbrelse(bh);\n\t}\n\tif (bcount)\n\t\tprintk(KERN_DEBUG \"%snames %u, fullness %u (%u%%)\\n\",\n\t\t       levels ? \"\" : \"   \", names, space/bcount,\n\t\t       (space/bcount)*100/blocksize);\n\treturn (struct stats) { names, space, bcount};\n}\n#endif /* DX_DEBUG */\n\n/*\n * Probe for a directory leaf block to search.\n *\n * dx_probe can return ERR_BAD_DX_DIR, which means there was a format\n * error in the directory index, and the caller should fall back to\n * searching the directory normally.  The callers of dx_probe **MUST**\n * check for this error code, and make sure it never gets reflected\n * back to userspace.\n */\nstatic struct dx_frame *\ndx_probe(struct ext4_filename *fname, struct inode *dir,\n\t struct dx_hash_info *hinfo, struct dx_frame *frame_in)\n{\n\tunsigned count, indirect;\n\tstruct dx_entry *at, *entries, *p, *q, *m;\n\tstruct dx_root *root;\n\tstruct dx_frame *frame = frame_in;\n\tstruct dx_frame *ret_err = ERR_PTR(ERR_BAD_DX_DIR);\n\tu32 hash;\n\n\tmemset(frame_in, 0, EXT4_HTREE_LEVEL * sizeof(frame_in[0]));\n\tframe->bh = ext4_read_dirblock(dir, 0, INDEX);\n\tif (IS_ERR(frame->bh))\n\t\treturn (struct dx_frame *) frame->bh;\n\n\troot = (struct dx_root *) frame->bh->b_data;\n\tif (root->info.hash_version != DX_HASH_TEA &&\n\t    root->info.hash_version != DX_HASH_HALF_MD4 &&\n\t    root->info.hash_version != DX_HASH_LEGACY) {\n\t\text4_warning_inode(dir, \"Unrecognised inode hash code %u\",\n\t\t\t\t   root->info.hash_version);\n\t\tgoto fail;\n\t}\n\tif (fname)\n\t\thinfo = &fname->hinfo;\n\thinfo->hash_version = root->info.hash_version;\n\tif (hinfo->hash_version <= DX_HASH_TEA)\n\t\thinfo->hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo->seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\tif (fname && fname_name(fname))\n\t\text4fs_dirhash(dir, fname_name(fname), fname_len(fname), hinfo);\n\thash = hinfo->hash;\n\n\tif (root->info.unused_flags & 1) {\n\t\text4_warning_inode(dir, \"Unimplemented hash flags: %#06x\",\n\t\t\t\t   root->info.unused_flags);\n\t\tgoto fail;\n\t}\n\n\tindirect = root->info.indirect_levels;\n\tif (indirect >= ext4_dir_htree_level(dir->i_sb)) {\n\t\text4_warning(dir->i_sb,\n\t\t\t     \"Directory (ino: %lu) htree depth %#06x exceed\"\n\t\t\t     \"supported value\", dir->i_ino,\n\t\t\t     ext4_dir_htree_level(dir->i_sb));\n\t\tif (ext4_dir_htree_level(dir->i_sb) < EXT4_HTREE_LEVEL) {\n\t\t\text4_warning(dir->i_sb, \"Enable large directory \"\n\t\t\t\t\t\t\"feature to access it\");\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tentries = (struct dx_entry *)(((char *)&root->info) +\n\t\t\t\t      root->info.info_length);\n\n\tif (dx_get_limit(entries) != dx_root_limit(dir,\n\t\t\t\t\t\t   root->info.info_length)) {\n\t\text4_warning_inode(dir, \"dx entry: limit %u != root limit %u\",\n\t\t\t\t   dx_get_limit(entries),\n\t\t\t\t   dx_root_limit(dir, root->info.info_length));\n\t\tgoto fail;\n\t}\n\n\tdxtrace(printk(\"Look up %x\", hash));\n\twhile (1) {\n\t\tcount = dx_get_count(entries);\n\t\tif (!count || count > dx_get_limit(entries)) {\n\t\t\text4_warning_inode(dir,\n\t\t\t\t\t   \"dx entry: count %u beyond limit %u\",\n\t\t\t\t\t   count, dx_get_limit(entries));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tp = entries + 1;\n\t\tq = entries + count - 1;\n\t\twhile (p <= q) {\n\t\t\tm = p + (q - p) / 2;\n\t\t\tdxtrace(printk(KERN_CONT \".\"));\n\t\t\tif (dx_get_hash(m) > hash)\n\t\t\t\tq = m - 1;\n\t\t\telse\n\t\t\t\tp = m + 1;\n\t\t}\n\n\t\tif (0) { // linear search cross check\n\t\t\tunsigned n = count - 1;\n\t\t\tat = entries;\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tdxtrace(printk(KERN_CONT \",\"));\n\t\t\t\tif (dx_get_hash(++at) > hash)\n\t\t\t\t{\n\t\t\t\t\tat--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (at == p - 1);\n\t\t}\n\n\t\tat = p - 1;\n\t\tdxtrace(printk(KERN_CONT \" %x->%u\\n\",\n\t\t\t       at == entries ? 0 : dx_get_hash(at),\n\t\t\t       dx_get_block(at)));\n\t\tframe->entries = entries;\n\t\tframe->at = at;\n\t\tif (!indirect--)\n\t\t\treturn frame;\n\t\tframe++;\n\t\tframe->bh = ext4_read_dirblock(dir, dx_get_block(at), INDEX);\n\t\tif (IS_ERR(frame->bh)) {\n\t\t\tret_err = (struct dx_frame *) frame->bh;\n\t\t\tframe->bh = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t\tentries = ((struct dx_node *) frame->bh->b_data)->entries;\n\n\t\tif (dx_get_limit(entries) != dx_node_limit(dir)) {\n\t\t\text4_warning_inode(dir,\n\t\t\t\t\"dx entry: limit %u != node limit %u\",\n\t\t\t\tdx_get_limit(entries), dx_node_limit(dir));\n\t\t\tgoto fail;\n\t\t}\n\t}\nfail:\n\twhile (frame >= frame_in) {\n\t\tbrelse(frame->bh);\n\t\tframe--;\n\t}\n\n\tif (ret_err == ERR_PTR(ERR_BAD_DX_DIR))\n\t\text4_warning_inode(dir,\n\t\t\t\"Corrupt directory, running e2fsck is recommended\");\n\treturn ret_err;\n}\n\nstatic void dx_release(struct dx_frame *frames)\n{\n\tstruct dx_root_info *info;\n\tint i;\n\tunsigned int indirect_levels;\n\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tinfo = &((struct dx_root *)frames[0].bh->b_data)->info;\n\t/* save local copy, \"info\" may be freed after brelse() */\n\tindirect_levels = info->indirect_levels;\n\tfor (i = 0; i <= indirect_levels; i++) {\n\t\tif (frames[i].bh == NULL)\n\t\t\tbreak;\n\t\tbrelse(frames[i].bh);\n\t\tframes[i].bh = NULL;\n\t}\n}\n\n/*\n * This function increments the frame pointer to search the next leaf\n * block, and reads in the necessary intervening nodes if the search\n * should be necessary.  Whether or not the search is necessary is\n * controlled by the hash parameter.  If the hash value is even, then\n * the search is only continued if the next block starts with that\n * hash value.  This is used if we are searching for a specific file.\n *\n * If the hash value is HASH_NB_ALWAYS, then always go to the next block.\n *\n * This function returns 1 if the caller should continue to search,\n * or 0 if it should not.  If there is an error reading one of the\n * index blocks, it will a negative error code.\n *\n * If start_hash is non-null, it will be filled in with the starting\n * hash of the next page.\n */\nstatic int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash)\n{\n\tstruct dx_frame *p;\n\tstruct buffer_head *bh;\n\tint num_frames = 0;\n\t__u32 bhash;\n\n\tp = frame;\n\t/*\n\t * Find the next leaf page by incrementing the frame pointer.\n\t * If we run out of entries in the interior node, loop around and\n\t * increment pointer in the parent node.  When we break out of\n\t * this loop, num_frames indicates the number of interior\n\t * nodes need to be read.\n\t */\n\twhile (1) {\n\t\tif (++(p->at) < p->entries + dx_get_count(p->entries))\n\t\t\tbreak;\n\t\tif (p == frames)\n\t\t\treturn 0;\n\t\tnum_frames++;\n\t\tp--;\n\t}\n\n\t/*\n\t * If the hash is 1, then continue only if the next page has a\n\t * continuation hash of any value.  This is used for readdir\n\t * handling.  Otherwise, check to see if the hash matches the\n\t * desired contiuation hash.  If it doesn't, return since\n\t * there's no point to read in the successive index pages.\n\t */\n\tbhash = dx_get_hash(p->at);\n\tif (start_hash)\n\t\t*start_hash = bhash;\n\tif ((hash & 1) == 0) {\n\t\tif ((bhash & ~1) != hash)\n\t\t\treturn 0;\n\t}\n\t/*\n\t * If the hash is HASH_NB_ALWAYS, we always go to the next\n\t * block so no check is necessary\n\t */\n\twhile (num_frames--) {\n\t\tbh = ext4_read_dirblock(dir, dx_get_block(p->at), INDEX);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\tp++;\n\t\tbrelse(p->bh);\n\t\tp->bh = bh;\n\t\tp->at = p->entries = ((struct dx_node *) bh->b_data)->entries;\n\t}\n\treturn 1;\n}\n\n\n/*\n * This function fills a red-black tree with information from a\n * directory block.  It returns the number directory entries loaded\n * into the tree.  If there is an error it is returned in err.\n */\nstatic int htree_dirblock_to_tree(struct file *dir_file,\n\t\t\t\t  struct inode *dir, ext4_lblk_t block,\n\t\t\t\t  struct dx_hash_info *hinfo,\n\t\t\t\t  __u32 start_hash, __u32 start_minor_hash)\n{\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de, *top;\n\tint err = 0, count = 0;\n\tstruct fscrypt_str fname_crypto_str = FSTR_INIT(NULL, 0), tmp_str;\n\n\tdxtrace(printk(KERN_INFO \"In htree dirblock_to_tree: block %lu\\n\",\n\t\t\t\t\t\t\t(unsigned long)block));\n\tbh = ext4_read_dirblock(dir, block, DIRENT_HTREE);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\ttop = (struct ext4_dir_entry_2 *) ((char *) de +\n\t\t\t\t\t   dir->i_sb->s_blocksize -\n\t\t\t\t\t   EXT4_DIR_REC_LEN(0));\n\t/* Check if the directory is encrypted */\n\tif (IS_ENCRYPTED(dir)) {\n\t\terr = fscrypt_get_encryption_info(dir);\n\t\tif (err < 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn err;\n\t\t}\n\t\terr = fscrypt_fname_alloc_buffer(EXT4_NAME_LEN,\n\t\t\t\t\t\t &fname_crypto_str);\n\t\tif (err < 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tfor (; de < top; de = ext4_next_entry(de, dir->i_sb->s_blocksize)) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\tbh->b_data, bh->b_size,\n\t\t\t\t(block<<EXT4_BLOCK_SIZE_BITS(dir->i_sb))\n\t\t\t\t\t + ((char *)de - bh->b_data))) {\n\t\t\t/* silently ignore the rest of the block */\n\t\t\tbreak;\n\t\t}\n\t\text4fs_dirhash(dir, de->name, de->name_len, hinfo);\n\t\tif ((hinfo->hash < start_hash) ||\n\t\t    ((hinfo->hash == start_hash) &&\n\t\t     (hinfo->minor_hash < start_minor_hash)))\n\t\t\tcontinue;\n\t\tif (de->inode == 0)\n\t\t\tcontinue;\n\t\tif (!IS_ENCRYPTED(dir)) {\n\t\t\ttmp_str.name = de->name;\n\t\t\ttmp_str.len = de->name_len;\n\t\t\terr = ext4_htree_store_dirent(dir_file,\n\t\t\t\t   hinfo->hash, hinfo->minor_hash, de,\n\t\t\t\t   &tmp_str);\n\t\t} else {\n\t\t\tint save_len = fname_crypto_str.len;\n\t\t\tstruct fscrypt_str de_name = FSTR_INIT(de->name,\n\t\t\t\t\t\t\t\tde->name_len);\n\n\t\t\t/* Directory is encrypted */\n\t\t\terr = fscrypt_fname_disk_to_usr(dir, hinfo->hash,\n\t\t\t\t\thinfo->minor_hash, &de_name,\n\t\t\t\t\t&fname_crypto_str);\n\t\t\tif (err) {\n\t\t\t\tcount = err;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\terr = ext4_htree_store_dirent(dir_file,\n\t\t\t\t   hinfo->hash, hinfo->minor_hash, de,\n\t\t\t\t\t&fname_crypto_str);\n\t\t\tfname_crypto_str.len = save_len;\n\t\t}\n\t\tif (err != 0) {\n\t\t\tcount = err;\n\t\t\tgoto errout;\n\t\t}\n\t\tcount++;\n\t}\nerrout:\n\tbrelse(bh);\n\tfscrypt_fname_free_buffer(&fname_crypto_str);\n\treturn count;\n}\n\n\n/*\n * This function fills a red-black tree with information from a\n * directory.  We start scanning the directory in hash order, starting\n * at start_hash and start_minor_hash.\n *\n * This function returns the number of entries inserted into the tree,\n * or a negative error code.\n */\nint ext4_htree_fill_tree(struct file *dir_file, __u32 start_hash,\n\t\t\t __u32 start_minor_hash, __u32 *next_hash)\n{\n\tstruct dx_hash_info hinfo;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct dx_frame frames[EXT4_HTREE_LEVEL], *frame;\n\tstruct inode *dir;\n\text4_lblk_t block;\n\tint count = 0;\n\tint ret, err;\n\t__u32 hashval;\n\tstruct fscrypt_str tmp_str;\n\n\tdxtrace(printk(KERN_DEBUG \"In htree_fill_tree, start hash: %x:%x\\n\",\n\t\t       start_hash, start_minor_hash));\n\tdir = file_inode(dir_file);\n\tif (!(ext4_test_inode_flag(dir, EXT4_INODE_INDEX))) {\n\t\thinfo.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;\n\t\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\t\thinfo.hash_version +=\n\t\t\t\tEXT4_SB(dir->i_sb)->s_hash_unsigned;\n\t\thinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\t\tif (ext4_has_inline_data(dir)) {\n\t\t\tint has_inline_data = 1;\n\t\t\tcount = ext4_inlinedir_to_tree(dir_file, dir, 0,\n\t\t\t\t\t\t       &hinfo, start_hash,\n\t\t\t\t\t\t       start_minor_hash,\n\t\t\t\t\t\t       &has_inline_data);\n\t\t\tif (has_inline_data) {\n\t\t\t\t*next_hash = ~0;\n\t\t\t\treturn count;\n\t\t\t}\n\t\t}\n\t\tcount = htree_dirblock_to_tree(dir_file, dir, 0, &hinfo,\n\t\t\t\t\t       start_hash, start_minor_hash);\n\t\t*next_hash = ~0;\n\t\treturn count;\n\t}\n\thinfo.hash = start_hash;\n\thinfo.minor_hash = 0;\n\tframe = dx_probe(NULL, dir, &hinfo, frames);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\n\t/* Add '.' and '..' from the htree header */\n\tif (!start_hash && !start_minor_hash) {\n\t\tde = (struct ext4_dir_entry_2 *) frames[0].bh->b_data;\n\t\ttmp_str.name = de->name;\n\t\ttmp_str.len = de->name_len;\n\t\terr = ext4_htree_store_dirent(dir_file, 0, 0,\n\t\t\t\t\t      de, &tmp_str);\n\t\tif (err != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\tif (start_hash < 2 || (start_hash ==2 && start_minor_hash==0)) {\n\t\tde = (struct ext4_dir_entry_2 *) frames[0].bh->b_data;\n\t\tde = ext4_next_entry(de, dir->i_sb->s_blocksize);\n\t\ttmp_str.name = de->name;\n\t\ttmp_str.len = de->name_len;\n\t\terr = ext4_htree_store_dirent(dir_file, 2, 0,\n\t\t\t\t\t      de, &tmp_str);\n\t\tif (err != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\n\twhile (1) {\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tgoto errout;\n\t\t}\n\t\tcond_resched();\n\t\tblock = dx_get_block(frame->at);\n\t\tret = htree_dirblock_to_tree(dir_file, dir, block, &hinfo,\n\t\t\t\t\t     start_hash, start_minor_hash);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\tcount += ret;\n\t\thashval = ~0;\n\t\tret = ext4_htree_next_block(dir, HASH_NB_ALWAYS,\n\t\t\t\t\t    frame, frames, &hashval);\n\t\t*next_hash = hashval;\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\t/*\n\t\t * Stop if:  (a) there are no more entries, or\n\t\t * (b) we have inserted at least one entry and the\n\t\t * next hash value is not a continuation\n\t\t */\n\t\tif ((ret == 0) ||\n\t\t    (count && ((hashval & 1) == 0)))\n\t\t\tbreak;\n\t}\n\tdx_release(frames);\n\tdxtrace(printk(KERN_DEBUG \"Fill tree: returned %d entries, \"\n\t\t       \"next hash: %x\\n\", count, *next_hash));\n\treturn count;\nerrout:\n\tdx_release(frames);\n\treturn (err);\n}\n\nstatic inline int search_dirblock(struct buffer_head *bh,\n\t\t\t\t  struct inode *dir,\n\t\t\t\t  struct ext4_filename *fname,\n\t\t\t\t  unsigned int offset,\n\t\t\t\t  struct ext4_dir_entry_2 **res_dir)\n{\n\treturn ext4_search_dir(bh, bh->b_data, dir->i_sb->s_blocksize, dir,\n\t\t\t       fname, offset, res_dir);\n}\n\n/*\n * Directory block splitting, compacting\n */\n\n/*\n * Create map of hash values, offsets, and sizes, stored at end of block.\n * Returns number of entries mapped.\n */\nstatic int dx_make_map(struct inode *dir, struct ext4_dir_entry_2 *de,\n\t\t       unsigned blocksize, struct dx_hash_info *hinfo,\n\t\t       struct dx_map_entry *map_tail)\n{\n\tint count = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\twhile ((char *) de < base + blocksize) {\n\t\tif (de->name_len && de->inode) {\n\t\t\text4fs_dirhash(dir, de->name, de->name_len, &h);\n\t\t\tmap_tail--;\n\t\t\tmap_tail->hash = h.hash;\n\t\t\tmap_tail->offs = ((char *) de - base)>>2;\n\t\t\tmap_tail->size = le16_to_cpu(de->rec_len);\n\t\t\tcount++;\n\t\t\tcond_resched();\n\t\t}\n\t\t/* XXX: do we need to check rec_len == 0 case? -Chris */\n\t\tde = ext4_next_entry(de, blocksize);\n\t}\n\treturn count;\n}\n\n/* Sort map by hash value */\nstatic void dx_sort_map (struct dx_map_entry *map, unsigned count)\n{\n\tstruct dx_map_entry *p, *q, *top = map + count - 1;\n\tint more;\n\t/* Combsort until bubble sort doesn't suck */\n\twhile (count > 2) {\n\t\tcount = count*10/13;\n\t\tif (count - 9 < 2) /* 9, 10 -> 11 */\n\t\t\tcount = 11;\n\t\tfor (p = top, q = p - count; q >= map; p--, q--)\n\t\t\tif (p->hash < q->hash)\n\t\t\t\tswap(*p, *q);\n\t}\n\t/* Garden variety bubble sort */\n\tdo {\n\t\tmore = 0;\n\t\tq = top;\n\t\twhile (q-- > map) {\n\t\t\tif (q[1].hash >= q[0].hash)\n\t\t\t\tcontinue;\n\t\t\tswap(*(q+1), *q);\n\t\t\tmore = 1;\n\t\t}\n\t} while(more);\n}\n\nstatic void dx_insert_block(struct dx_frame *frame, u32 hash, ext4_lblk_t block)\n{\n\tstruct dx_entry *entries = frame->entries;\n\tstruct dx_entry *old = frame->at, *new = old + 1;\n\tint count = dx_get_count(entries);\n\n\tassert(count < dx_get_limit(entries));\n\tassert(old < entries + count);\n\tmemmove(new + 1, new, (char *)(entries + count) - (char *)(new));\n\tdx_set_hash(new, hash);\n\tdx_set_block(new, block);\n\tdx_set_count(entries, count + 1);\n}\n\n#ifdef CONFIG_UNICODE\n/*\n * Test whether a case-insensitive directory entry matches the filename\n * being searched for.  If quick is set, assume the name being looked up\n * is already in the casefolded form.\n *\n * Returns: 0 if the directory entry matches, more than 0 if it\n * doesn't match or less than zero on error.\n */\nint ext4_ci_compare(const struct inode *parent, const struct qstr *name,\n\t\t    const struct qstr *entry, bool quick)\n{\n\tconst struct ext4_sb_info *sbi = EXT4_SB(parent->i_sb);\n\tconst struct unicode_map *um = sbi->s_encoding;\n\tint ret;\n\n\tif (quick)\n\t\tret = utf8_strncasecmp_folded(um, name, entry);\n\telse\n\t\tret = utf8_strncasecmp(um, name, entry);\n\n\tif (ret < 0) {\n\t\t/* Handle invalid character sequence as either an error\n\t\t * or as an opaque byte sequence.\n\t\t */\n\t\tif (ext4_has_strict_mode(sbi))\n\t\t\treturn -EINVAL;\n\n\t\tif (name->len != entry->len)\n\t\t\treturn 1;\n\n\t\treturn !!memcmp(name->name, entry->name, name->len);\n\t}\n\n\treturn ret;\n}\n\nvoid ext4_fname_setup_ci_filename(struct inode *dir, const struct qstr *iname,\n\t\t\t\t  struct fscrypt_str *cf_name)\n{\n\tint len;\n\n\tif (!IS_CASEFOLDED(dir) || !EXT4_SB(dir->i_sb)->s_encoding) {\n\t\tcf_name->name = NULL;\n\t\treturn;\n\t}\n\n\tcf_name->name = kmalloc(EXT4_NAME_LEN, GFP_NOFS);\n\tif (!cf_name->name)\n\t\treturn;\n\n\tlen = utf8_casefold(EXT4_SB(dir->i_sb)->s_encoding,\n\t\t\t    iname, cf_name->name,\n\t\t\t    EXT4_NAME_LEN);\n\tif (len <= 0) {\n\t\tkfree(cf_name->name);\n\t\tcf_name->name = NULL;\n\t\treturn;\n\t}\n\tcf_name->len = (unsigned) len;\n\n}\n#endif\n\n/*\n * Test whether a directory entry matches the filename being searched for.\n *\n * Return: %true if the directory entry matches, otherwise %false.\n */\nstatic inline bool ext4_match(const struct inode *parent,\n\t\t\t      const struct ext4_filename *fname,\n\t\t\t      const struct ext4_dir_entry_2 *de)\n{\n\tstruct fscrypt_name f;\n#ifdef CONFIG_UNICODE\n\tconst struct qstr entry = {.name = de->name, .len = de->name_len};\n#endif\n\n\tif (!de->inode)\n\t\treturn false;\n\n\tf.usr_fname = fname->usr_fname;\n\tf.disk_name = fname->disk_name;\n#ifdef CONFIG_FS_ENCRYPTION\n\tf.crypto_buf = fname->crypto_buf;\n#endif\n\n#ifdef CONFIG_UNICODE\n\tif (EXT4_SB(parent->i_sb)->s_encoding && IS_CASEFOLDED(parent)) {\n\t\tif (fname->cf_name.name) {\n\t\t\tstruct qstr cf = {.name = fname->cf_name.name,\n\t\t\t\t\t  .len = fname->cf_name.len};\n\t\t\treturn !ext4_ci_compare(parent, &cf, &entry, true);\n\t\t}\n\t\treturn !ext4_ci_compare(parent, fname->usr_fname, &entry,\n\t\t\t\t\tfalse);\n\t}\n#endif\n\n\treturn fscrypt_match_name(&f, de->name, de->name_len);\n}\n\n/*\n * Returns 0 if not found, -1 on failure, and 1 on success\n */\nint ext4_search_dir(struct buffer_head *bh, char *search_buf, int buf_size,\n\t\t    struct inode *dir, struct ext4_filename *fname,\n\t\t    unsigned int offset, struct ext4_dir_entry_2 **res_dir)\n{\n\tstruct ext4_dir_entry_2 * de;\n\tchar * dlimit;\n\tint de_len;\n\n\tde = (struct ext4_dir_entry_2 *)search_buf;\n\tdlimit = search_buf + buf_size;\n\twhile ((char *) de < dlimit) {\n\t\t/* this code is executed quadratically often */\n\t\t/* do minimal checking `by hand' */\n\t\tif ((char *) de + de->name_len <= dlimit &&\n\t\t    ext4_match(dir, fname, de)) {\n\t\t\t/* found a match - just to be sure, do\n\t\t\t * a full check */\n\t\t\tif (ext4_check_dir_entry(dir, NULL, de, bh, search_buf,\n\t\t\t\t\t\t buf_size, offset))\n\t\t\t\treturn -1;\n\t\t\t*res_dir = de;\n\t\t\treturn 1;\n\t\t}\n\t\t/* prevent looping on a bad block */\n\t\tde_len = ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\tdir->i_sb->s_blocksize);\n\t\tif (de_len <= 0)\n\t\t\treturn -1;\n\t\toffset += de_len;\n\t\tde = (struct ext4_dir_entry_2 *) ((char *) de + de_len);\n\t}\n\treturn 0;\n}\n\nstatic int is_dx_internal_node(struct inode *dir, ext4_lblk_t block,\n\t\t\t       struct ext4_dir_entry *de)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tif (!is_dx(dir))\n\t\treturn 0;\n\tif (block == 0)\n\t\treturn 1;\n\tif (de->inode == 0 &&\n\t    ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize) ==\n\t\t\tsb->s_blocksize)\n\t\treturn 1;\n\treturn 0;\n}\n\n/*\n *\t__ext4_find_entry()\n *\n * finds an entry in the specified directory with the wanted name. It\n * returns the cache buffer in which the entry was found, and the entry\n * itself (as a parameter - res_dir). It does NOT read the inode of the\n * entry - you'll have to do that yourself if you want to.\n *\n * The returned buffer_head has ->b_count elevated.  The caller is expected\n * to brelse() it when appropriate.\n */\nstatic struct buffer_head *__ext4_find_entry(struct inode *dir,\n\t\t\t\t\t     struct ext4_filename *fname,\n\t\t\t\t\t     struct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\t     int *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block;\n\tconst u8 *name = fname->usr_fname->name;\n\tsize_t ra_max = 0;\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tsize_t ra_ptr = 0;\t/* Current index into readahead\n\t\t\t\t   buffer */\n\text4_lblk_t  nblocks;\n\tint i, namelen, retval;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = fname->usr_fname->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, fname, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\tgoto cleanup_and_exit;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tret = ext4_dx_find_entry(dir, fname, res_dir);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (!IS_ERR(ret) || PTR_ERR(ret) != ERR_BAD_DX_DIR)\n\t\t\tgoto cleanup_and_exit;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t\tret = NULL;\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (!nblocks) {\n\t\tret = NULL;\n\t\tgoto cleanup_and_exit;\n\t}\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tcond_resched();\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tif (block < start)\n\t\t\t\tra_max = start - block;\n\t\t\telse\n\t\t\t\tra_max = nblocks - block;\n\t\t\tra_max = min(ra_max, ARRAY_SIZE(bh_use));\n\t\t\tretval = ext4_bread_batch(dir, block, ra_max,\n\t\t\t\t\t\t  false /* wait */, bh_use);\n\t\t\tif (retval) {\n\t\t\t\tret = ERR_PTR(retval);\n\t\t\t\tra_max = 0;\n\t\t\t\tgoto cleanup_and_exit;\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tEXT4_ERROR_INODE_ERR(dir, EIO,\n\t\t\t\t\t     \"reading directory lblock %lu\",\n\t\t\t\t\t     (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tret = ERR_PTR(-EIO);\n\t\t\tgoto cleanup_and_exit;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirblock_csum_verify(dir, bh)) {\n\t\t\tEXT4_ERROR_INODE_ERR(dir, EFSBADCRC,\n\t\t\t\t\t     \"checksumming directory \"\n\t\t\t\t\t     \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tret = ERR_PTR(-EFSBADCRC);\n\t\t\tgoto cleanup_and_exit;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, fname,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}\n\nstatic struct buffer_head *ext4_find_entry(struct inode *dir,\n\t\t\t\t\t   const struct qstr *d_name,\n\t\t\t\t\t   struct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\t   int *inlined)\n{\n\tint err;\n\tstruct ext4_filename fname;\n\tstruct buffer_head *bh;\n\n\terr = ext4_fname_setup_filename(dir, d_name, 1, &fname);\n\tif (err == -ENOENT)\n\t\treturn NULL;\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tbh = __ext4_find_entry(dir, &fname, res_dir, inlined);\n\n\text4_fname_free_filename(&fname);\n\treturn bh;\n}\n\nstatic struct buffer_head *ext4_lookup_entry(struct inode *dir,\n\t\t\t\t\t     struct dentry *dentry,\n\t\t\t\t\t     struct ext4_dir_entry_2 **res_dir)\n{\n\tint err;\n\tstruct ext4_filename fname;\n\tstruct buffer_head *bh;\n\n\terr = ext4_fname_prepare_lookup(dir, dentry, &fname);\n\tif (err == -ENOENT)\n\t\treturn NULL;\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tbh = __ext4_find_entry(dir, &fname, res_dir, NULL);\n\n\text4_fname_free_filename(&fname);\n\treturn bh;\n}\n\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\t\tstruct ext4_filename *fname,\n\t\t\tstruct ext4_dir_entry_2 **res_dir)\n{\n\tstruct super_block * sb = dir->i_sb;\n\tstruct dx_frame frames[EXT4_HTREE_LEVEL], *frame;\n\tstruct buffer_head *bh;\n\text4_lblk_t block;\n\tint retval;\n\n#ifdef CONFIG_FS_ENCRYPTION\n\t*res_dir = NULL;\n#endif\n\tframe = dx_probe(fname, dir, NULL, frames);\n\tif (IS_ERR(frame))\n\t\treturn (struct buffer_head *) frame;\n\tdo {\n\t\tblock = dx_get_block(frame->at);\n\t\tbh = ext4_read_dirblock(dir, block, DIRENT_HTREE);\n\t\tif (IS_ERR(bh))\n\t\t\tgoto errout;\n\n\t\tretval = search_dirblock(bh, dir, fname,\n\t\t\t\t\t block << EXT4_BLOCK_SIZE_BITS(sb),\n\t\t\t\t\t res_dir);\n\t\tif (retval == 1)\n\t\t\tgoto success;\n\t\tbrelse(bh);\n\t\tif (retval == -1) {\n\t\t\tbh = ERR_PTR(ERR_BAD_DX_DIR);\n\t\t\tgoto errout;\n\t\t}\n\n\t\t/* Check to see if we should continue to search */\n\t\tretval = ext4_htree_next_block(dir, fname->hinfo.hash, frame,\n\t\t\t\t\t       frames, NULL);\n\t\tif (retval < 0) {\n\t\t\text4_warning_inode(dir,\n\t\t\t\t\"error %d reading directory index block\",\n\t\t\t\tretval);\n\t\t\tbh = ERR_PTR(retval);\n\t\t\tgoto errout;\n\t\t}\n\t} while (retval == 1);\n\n\tbh = NULL;\nerrout:\n\tdxtrace(printk(KERN_DEBUG \"%s not found\\n\", fname->usr_fname->name));\nsuccess:\n\tdx_release(frames);\n\treturn bh;\n}\n\nstatic struct dentry *ext4_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct buffer_head *bh;\n\n\tif (dentry->d_name.len > EXT4_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbh = ext4_lookup_entry(dir, dentry, &de);\n\tif (IS_ERR(bh))\n\t\treturn ERR_CAST(bh);\n\tinode = NULL;\n\tif (bh) {\n\t\t__u32 ino = le32_to_cpu(de->inode);\n\t\tbrelse(bh);\n\t\tif (!ext4_valid_inum(dir->i_sb, ino)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"bad inode number: %u\", ino);\n\t\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t\t}\n\t\tif (unlikely(ino == dir->i_ino)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"'%pd' linked to parent dir\",\n\t\t\t\t\t dentry);\n\t\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t\t}\n\t\tinode = ext4_iget(dir->i_sb, ino, EXT4_IGET_NORMAL);\n\t\tif (inode == ERR_PTR(-ESTALE)) {\n\t\t\tEXT4_ERROR_INODE(dir,\n\t\t\t\t\t \"deleted inode referenced: %u\",\n\t\t\t\t\t ino);\n\t\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t\t}\n\t\tif (!IS_ERR(inode) && IS_ENCRYPTED(dir) &&\n\t\t    (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)) &&\n\t\t    !fscrypt_has_permitted_context(dir, inode)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"Inconsistent encryption contexts: %lu/%lu\",\n\t\t\t\t     dir->i_ino, inode->i_ino);\n\t\t\tiput(inode);\n\t\t\treturn ERR_PTR(-EPERM);\n\t\t}\n\t}\n\n#ifdef CONFIG_UNICODE\n\tif (!inode && IS_CASEFOLDED(dir)) {\n\t\t/* Eventually we want to call d_add_ci(dentry, NULL)\n\t\t * for negative dentries in the encoding case as\n\t\t * well.  For now, prevent the negative dentry\n\t\t * from being cached.\n\t\t */\n\t\treturn NULL;\n\t}\n#endif\n\treturn d_splice_alias(inode, dentry);\n}\n\n\nstruct dentry *ext4_get_parent(struct dentry *child)\n{\n\t__u32 ino;\n\tstatic const struct qstr dotdot = QSTR_INIT(\"..\", 2);\n\tstruct ext4_dir_entry_2 * de;\n\tstruct buffer_head *bh;\n\n\tbh = ext4_find_entry(d_inode(child), &dotdot, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn ERR_CAST(bh);\n\tif (!bh)\n\t\treturn ERR_PTR(-ENOENT);\n\tino = le32_to_cpu(de->inode);\n\tbrelse(bh);\n\n\tif (!ext4_valid_inum(child->d_sb, ino)) {\n\t\tEXT4_ERROR_INODE(d_inode(child),\n\t\t\t\t \"bad parent inode number: %u\", ino);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\n\treturn d_obtain_alias(ext4_iget(child->d_sb, ino, EXT4_IGET_NORMAL));\n}\n\n/*\n * Move count entries from end of map between two memory locations.\n * Returns pointer to last entry moved.\n */\nstatic struct ext4_dir_entry_2 *\ndx_move_dirents(char *from, char *to, struct dx_map_entry *map, int count,\n\t\tunsigned blocksize)\n{\n\tunsigned rec_len = 0;\n\n\twhile (count--) {\n\t\tstruct ext4_dir_entry_2 *de = (struct ext4_dir_entry_2 *)\n\t\t\t\t\t\t(from + (map->offs<<2));\n\t\trec_len = EXT4_DIR_REC_LEN(de->name_len);\n\t\tmemcpy (to, de, rec_len);\n\t\t((struct ext4_dir_entry_2 *) to)->rec_len =\n\t\t\t\text4_rec_len_to_disk(rec_len, blocksize);\n\t\tde->inode = 0;\n\t\tmap++;\n\t\tto += rec_len;\n\t}\n\treturn (struct ext4_dir_entry_2 *) (to - rec_len);\n}\n\n/*\n * Compact each dir entry in the range to the minimal rec_len.\n * Returns pointer to last entry in range.\n */\nstatic struct ext4_dir_entry_2* dx_pack_dirents(char *base, unsigned blocksize)\n{\n\tstruct ext4_dir_entry_2 *next, *to, *prev, *de = (struct ext4_dir_entry_2 *) base;\n\tunsigned rec_len = 0;\n\n\tprev = to = de;\n\twhile ((char*)de < base + blocksize) {\n\t\tnext = ext4_next_entry(de, blocksize);\n\t\tif (de->inode && de->name_len) {\n\t\t\trec_len = EXT4_DIR_REC_LEN(de->name_len);\n\t\t\tif (de > to)\n\t\t\t\tmemmove(to, de, rec_len);\n\t\t\tto->rec_len = ext4_rec_len_to_disk(rec_len, blocksize);\n\t\t\tprev = to;\n\t\t\tto = (struct ext4_dir_entry_2 *) (((char *) to) + rec_len);\n\t\t}\n\t\tde = next;\n\t}\n\treturn prev;\n}\n\n/*\n * Split a full leaf block to make room for a new dir entry.\n * Allocate a new block, and move entries so that they are approx. equally full.\n * Returns pointer to de in block into which the new entry will be inserted.\n */\nstatic struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Ensure that neither split block is over half full */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/*\n\t * map index at which we will split\n\t *\n\t * If the sum of active entries didn't exceed half the block size, just\n\t * split it in half by count; each resulting block will have at least\n\t * half the space free.\n\t */\n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}\n\nint ext4_find_dest_de(struct inode *dir, struct inode *inode,\n\t\t      struct buffer_head *bh,\n\t\t      void *buf, int buf_size,\n\t\t      struct ext4_filename *fname,\n\t\t      struct ext4_dir_entry_2 **dest_de)\n{\n\tstruct ext4_dir_entry_2 *de;\n\tunsigned short reclen = EXT4_DIR_REC_LEN(fname_len(fname));\n\tint nlen, rlen;\n\tunsigned int offset = 0;\n\tchar *top;\n\n\tde = (struct ext4_dir_entry_2 *)buf;\n\ttop = buf + buf_size - reclen;\n\twhile ((char *) de <= top) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t buf, buf_size, offset))\n\t\t\treturn -EFSCORRUPTED;\n\t\tif (ext4_match(dir, fname, de))\n\t\t\treturn -EEXIST;\n\t\tnlen = EXT4_DIR_REC_LEN(de->name_len);\n\t\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\t\tif ((de->inode ? rlen - nlen : rlen) >= reclen)\n\t\t\tbreak;\n\t\tde = (struct ext4_dir_entry_2 *)((char *)de + rlen);\n\t\toffset += rlen;\n\t}\n\tif ((char *) de > top)\n\t\treturn -ENOSPC;\n\n\t*dest_de = de;\n\treturn 0;\n}\n\nvoid ext4_insert_dentry(struct inode *inode,\n\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\tint buf_size,\n\t\t\tstruct ext4_filename *fname)\n{\n\n\tint nlen, rlen;\n\n\tnlen = EXT4_DIR_REC_LEN(de->name_len);\n\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\tif (de->inode) {\n\t\tstruct ext4_dir_entry_2 *de1 =\n\t\t\t(struct ext4_dir_entry_2 *)((char *)de + nlen);\n\t\tde1->rec_len = ext4_rec_len_to_disk(rlen - nlen, buf_size);\n\t\tde->rec_len = ext4_rec_len_to_disk(nlen, buf_size);\n\t\tde = de1;\n\t}\n\tde->file_type = EXT4_FT_UNKNOWN;\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text4_set_de_type(inode->i_sb, de, inode->i_mode);\n\tde->name_len = fname_len(fname);\n\tmemcpy(de->name, fname_name(fname), fname_len(fname));\n}\n\n/*\n * Add a new entry into a directory (leaf) block.  If de is non-NULL,\n * it points to a directory entry which is guaranteed to be large\n * enough for new directory entry.  If de is NULL, then\n * add_dirent_to_buf will attempt search the directory block for\n * space.  It will return -ENOSPC if no space is available, and -EIO\n * and -EEXIST if directory entry already exists.\n */\nstatic int add_dirent_to_buf(handle_t *handle, struct ext4_filename *fname,\n\t\t\t     struct inode *dir,\n\t\t\t     struct inode *inode, struct ext4_dir_entry_2 *de,\n\t\t\t     struct buffer_head *bh)\n{\n\tunsigned int\tblocksize = dir->i_sb->s_blocksize;\n\tint\t\tcsum_size = 0;\n\tint\t\terr, err2;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tif (!de) {\n\t\terr = ext4_find_dest_de(dir, inode, bh, bh->b_data,\n\t\t\t\t\tblocksize - csum_size, fname, &de);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err) {\n\t\text4_std_error(dir->i_sb, err);\n\t\treturn err;\n\t}\n\n\t/* By now the buffer is marked for journaling */\n\text4_insert_dentry(inode, de, blocksize, fname);\n\n\t/*\n\t * XXX shouldn't update any times until successful\n\t * completion of syscall, but too many callers depend\n\t * on this.\n\t *\n\t * XXX similarly, too many callers depend on\n\t * ext4_new_inode() setting the times, but error\n\t * recovery deletes the inode, so the worst that can\n\t * happen is that the times are slightly out of date\n\t * and/or different from the directory change time.\n\t */\n\tdir->i_mtime = dir->i_ctime = current_time(dir);\n\text4_update_dx_flag(dir);\n\tinode_inc_iversion(dir);\n\terr2 = ext4_mark_inode_dirty(handle, dir);\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh);\n\tif (err)\n\t\text4_std_error(dir->i_sb, err);\n\treturn err ? err : err2;\n}\n\n/*\n * This converts a one block unindexed directory to a 3 block indexed\n * directory, and adds the dentry to the indexed directory.\n */\nstatic int make_indexed_dir(handle_t *handle, struct ext4_filename *fname,\n\t\t\t    struct inode *dir,\n\t\t\t    struct inode *inode, struct buffer_head *bh)\n{\n\tstruct buffer_head *bh2;\n\tstruct dx_root\t*root;\n\tstruct dx_frame\tframes[EXT4_HTREE_LEVEL], *frame;\n\tstruct dx_entry *entries;\n\tstruct ext4_dir_entry_2\t*de, *de2;\n\tchar\t\t*data2, *top;\n\tunsigned\tlen;\n\tint\t\tretval;\n\tunsigned\tblocksize;\n\text4_lblk_t  block;\n\tstruct fake_dirent *fde;\n\tint csum_size = 0;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tblocksize =  dir->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index: inode %lu\\n\", dir->i_ino));\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\tretval = ext4_journal_get_write_access(handle, bh);\n\tif (retval) {\n\t\text4_std_error(dir->i_sb, retval);\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\n\t/* The 0th block becomes the root, move the dirents out */\n\tfde = &root->dotdot;\n\tde = (struct ext4_dir_entry_2 *)((char *)fde +\n\t\text4_rec_len_from_disk(fde->rec_len, blocksize));\n\tif ((char *) de >= (((char *) root) + blocksize)) {\n\t\tEXT4_ERROR_INODE(dir, \"invalid rec_len for '..'\");\n\t\tbrelse(bh);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tlen = ((char *) root) + (blocksize - csum_size) - (char *) de;\n\n\t/* Allocate new block for the 0th block's dirents */\n\tbh2 = ext4_append(handle, dir, &block);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(bh);\n\t\treturn PTR_ERR(bh2);\n\t}\n\text4_set_inode_flag(dir, EXT4_INODE_INDEX);\n\tdata2 = bh2->b_data;\n\n\tmemcpy(data2, de, len);\n\tde = (struct ext4_dir_entry_2 *) data2;\n\ttop = data2 + len;\n\twhile ((char *)(de2 = ext4_next_entry(de, blocksize)) < top)\n\t\tde = de2;\n\tde->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de, blocksize);\n\n\tif (csum_size)\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\n\t/* Initialize the root; the dot dirents already exist */\n\tde = (struct ext4_dir_entry_2 *) (&root->dotdot);\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - EXT4_DIR_REC_LEN(2),\n\t\t\t\t\t   blocksize);\n\tmemset (&root->info, 0, sizeof(root->info));\n\troot->info.info_length = sizeof(root->info);\n\troot->info.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;\n\tentries = root->entries;\n\tdx_set_block(entries, 1);\n\tdx_set_count(entries, 1);\n\tdx_set_limit(entries, dx_root_limit(dir, sizeof(root->info)));\n\n\t/* Initialize as for dx_probe */\n\tfname->hinfo.hash_version = root->info.hash_version;\n\tif (fname->hinfo.hash_version <= DX_HASH_TEA)\n\t\tfname->hinfo.hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\tfname->hinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\text4fs_dirhash(dir, fname_name(fname), fname_len(fname), &fname->hinfo);\n\n\tmemset(frames, 0, sizeof(frames));\n\tframe = frames;\n\tframe->entries = entries;\n\tframe->at = entries;\n\tframe->bh = bh;\n\n\tretval = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (retval)\n\t\tgoto out_frames;\t\n\tretval = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (retval)\n\t\tgoto out_frames;\t\n\n\tde = do_split(handle,dir, &bh2, frame, &fname->hinfo);\n\tif (IS_ERR(de)) {\n\t\tretval = PTR_ERR(de);\n\t\tgoto out_frames;\n\t}\n\n\tretval = add_dirent_to_buf(handle, fname, dir, inode, de, bh2);\nout_frames:\n\t/*\n\t * Even if the block split failed, we have to properly write\n\t * out all the changes we did so far. Otherwise we can end up\n\t * with corrupted filesystem.\n\t */\n\tif (retval)\n\t\text4_mark_inode_dirty(handle, dir);\n\tdx_release(frames);\n\tbrelse(bh2);\n\treturn retval;\n}\n\n/*\n *\text4_add_entry()\n *\n * adds a file entry to the specified directory, using the same\n * semantics as ext4_find_entry(). It returns NULL if it failed.\n *\n * NOTE!! The inode part of 'de' is left at 0 - which means you\n * may not sleep between calling this and putting something into\n * the entry, as someone else might have used it while you slept.\n */\nstatic int ext4_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t  struct inode *inode)\n{\n\tstruct inode *dir = d_inode(dentry->d_parent);\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct super_block *sb;\n#ifdef CONFIG_UNICODE\n\tstruct ext4_sb_info *sbi;\n#endif\n\tstruct ext4_filename fname;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\text4_lblk_t block, blocks;\n\tint\tcsum_size = 0;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_UNICODE\n\tsbi = EXT4_SB(sb);\n\tif (ext4_has_strict_mode(sbi) && IS_CASEFOLDED(dir) &&\n\t    sbi->s_encoding && utf8_validate(sbi->s_encoding, &dentry->d_name))\n\t\treturn -EINVAL;\n#endif\n\n\tretval = ext4_fname_setup_filename(dir, &dentry->d_name, 0, &fname);\n\tif (retval)\n\t\treturn retval;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tretval = ext4_try_add_inline_entry(handle, &fname, dir, inode);\n\t\tif (retval < 0)\n\t\t\tgoto out;\n\t\tif (retval == 1) {\n\t\t\tretval = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (is_dx(dir)) {\n\t\tretval = ext4_dx_add_entry(handle, &fname, dir, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\tgoto out;\n\t\t/* Can we just ignore htree data? */\n\t\tif (ext4_has_metadata_csum(sb)) {\n\t\t\tEXT4_ERROR_INODE(dir,\n\t\t\t\t\"Directory has corrupted htree index.\");\n\t\t\tretval = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t\text4_clear_inode_flag(dir, EXT4_INODE_INDEX);\n\t\tdx_fallback++;\n\t\tretval = ext4_mark_inode_dirty(handle, dir);\n\t\tif (unlikely(retval))\n\t\t\tgoto out;\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\t\tif (bh == NULL) {\n\t\t\tbh = ext4_bread(handle, dir, block,\n\t\t\t\t\tEXT4_GET_BLOCKS_CREATE);\n\t\t\tgoto add_to_new_block;\n\t\t}\n\t\tif (IS_ERR(bh)) {\n\t\t\tretval = PTR_ERR(bh);\n\t\t\tbh = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tretval = add_dirent_to_buf(handle, &fname, dir, inode,\n\t\t\t\t\t   NULL, bh);\n\t\tif (retval != -ENOSPC)\n\t\t\tgoto out;\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    ext4_has_feature_dir_index(sb)) {\n\t\t\tretval = make_indexed_dir(handle, &fname, dir,\n\t\t\t\t\t\t  inode, bh);\n\t\t\tbh = NULL; /* make_indexed_dir releases bh */\n\t\t\tgoto out;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\tbh = ext4_append(handle, dir, &block);\nadd_to_new_block:\n\tif (IS_ERR(bh)) {\n\t\tretval = PTR_ERR(bh);\n\t\tbh = NULL;\n\t\tgoto out;\n\t}\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - csum_size, blocksize);\n\n\tif (csum_size)\n\t\text4_initialize_dirent_tail(bh, blocksize);\n\n\tretval = add_dirent_to_buf(handle, &fname, dir, inode, de, bh);\nout:\n\text4_fname_free_filename(&fname);\n\tbrelse(bh);\n\tif (retval == 0)\n\t\text4_set_inode_state(inode, EXT4_STATE_NEWENTRY);\n\treturn retval;\n}\n\n/*\n * Returns 0 for success, or a negative error value\n */\nstatic int ext4_dx_add_entry(handle_t *handle, struct ext4_filename *fname,\n\t\t\t     struct inode *dir, struct inode *inode)\n{\n\tstruct dx_frame frames[EXT4_HTREE_LEVEL], *frame;\n\tstruct dx_entry *entries, *at;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ext4_dir_entry_2 *de;\n\tint restart;\n\tint err;\n\nagain:\n\trestart = 0;\n\tframe = dx_probe(fname, dir, NULL, frames);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\tentries = frame->entries;\n\tat = frame->at;\n\tbh = ext4_read_dirblock(dir, dx_get_block(frame->at), DIRENT_HTREE);\n\tif (IS_ERR(bh)) {\n\t\terr = PTR_ERR(bh);\n\t\tbh = NULL;\n\t\tgoto cleanup;\n\t}\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\terr = add_dirent_to_buf(handle, fname, dir, inode, NULL, bh);\n\tif (err != -ENOSPC)\n\t\tgoto cleanup;\n\n\terr = 0;\n\t/* Block full, should compress but for now just split */\n\tdxtrace(printk(KERN_DEBUG \"using %u of %u node entries\\n\",\n\t\t       dx_get_count(entries), dx_get_limit(entries)));\n\t/* Need to split index? */\n\tif (dx_get_count(entries) == dx_get_limit(entries)) {\n\t\text4_lblk_t newblock;\n\t\tint levels = frame - frames + 1;\n\t\tunsigned int icount;\n\t\tint add_level = 1;\n\t\tstruct dx_entry *entries2;\n\t\tstruct dx_node *node2;\n\t\tstruct buffer_head *bh2;\n\n\t\twhile (frame > frames) {\n\t\t\tif (dx_get_count((frame - 1)->entries) <\n\t\t\t    dx_get_limit((frame - 1)->entries)) {\n\t\t\t\tadd_level = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tframe--; /* split higher index block */\n\t\t\tat = frame->at;\n\t\t\tentries = frame->entries;\n\t\t\trestart = 1;\n\t\t}\n\t\tif (add_level && levels == ext4_dir_htree_level(sb)) {\n\t\t\text4_warning(sb, \"Directory (ino: %lu) index full, \"\n\t\t\t\t\t \"reach max htree level :%d\",\n\t\t\t\t\t dir->i_ino, levels);\n\t\t\tif (ext4_dir_htree_level(sb) < EXT4_HTREE_LEVEL) {\n\t\t\t\text4_warning(sb, \"Large directory feature is \"\n\t\t\t\t\t\t \"not enabled on this \"\n\t\t\t\t\t\t \"filesystem\");\n\t\t\t}\n\t\t\terr = -ENOSPC;\n\t\t\tgoto cleanup;\n\t\t}\n\t\ticount = dx_get_count(entries);\n\t\tbh2 = ext4_append(handle, dir, &newblock);\n\t\tif (IS_ERR(bh2)) {\n\t\t\terr = PTR_ERR(bh2);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tnode2 = (struct dx_node *)(bh2->b_data);\n\t\tentries2 = node2->entries;\n\t\tmemset(&node2->fake, 0, sizeof(struct fake_dirent));\n\t\tnode2->fake.rec_len = ext4_rec_len_to_disk(sb->s_blocksize,\n\t\t\t\t\t\t\t   sb->s_blocksize);\n\t\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, frame->bh);\n\t\tif (err)\n\t\t\tgoto journal_error;\n\t\tif (!add_level) {\n\t\t\tunsigned icount1 = icount/2, icount2 = icount - icount1;\n\t\t\tunsigned hash2 = dx_get_hash(entries + icount1);\n\t\t\tdxtrace(printk(KERN_DEBUG \"Split index %i/%i\\n\",\n\t\t\t\t       icount1, icount2));\n\n\t\t\tBUFFER_TRACE(frame->bh, \"get_write_access\"); /* index root */\n\t\t\terr = ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t     (frame - 1)->bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\n\t\t\tmemcpy((char *) entries2, (char *) (entries + icount1),\n\t\t\t       icount2 * sizeof(struct dx_entry));\n\t\t\tdx_set_count(entries, icount1);\n\t\t\tdx_set_count(entries2, icount2);\n\t\t\tdx_set_limit(entries2, dx_node_limit(dir));\n\n\t\t\t/* Which index block gets the new entry? */\n\t\t\tif (at - entries >= icount1) {\n\t\t\t\tframe->at = at = at - entries - icount1 + entries2;\n\t\t\t\tframe->entries = entries = entries2;\n\t\t\t\tswap(frame->bh, bh2);\n\t\t\t}\n\t\t\tdx_insert_block((frame - 1), hash2, newblock);\n\t\t\tdxtrace(dx_show_index(\"node\", frame->entries));\n\t\t\tdxtrace(dx_show_index(\"node\",\n\t\t\t       ((struct dx_node *) bh2->b_data)->entries));\n\t\t\terr = ext4_handle_dirty_dx_node(handle, dir, bh2);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t\tbrelse (bh2);\n\t\t\terr = ext4_handle_dirty_dx_node(handle, dir,\n\t\t\t\t\t\t   (frame - 1)->bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t\tif (restart) {\n\t\t\t\terr = ext4_handle_dirty_dx_node(handle, dir,\n\t\t\t\t\t\t\t   frame->bh);\n\t\t\t\tgoto journal_error;\n\t\t\t}\n\t\t} else {\n\t\t\tstruct dx_root *dxroot;\n\t\t\tmemcpy((char *) entries2, (char *) entries,\n\t\t\t       icount * sizeof(struct dx_entry));\n\t\t\tdx_set_limit(entries2, dx_node_limit(dir));\n\n\t\t\t/* Set up root */\n\t\t\tdx_set_count(entries, 1);\n\t\t\tdx_set_block(entries + 0, newblock);\n\t\t\tdxroot = (struct dx_root *)frames[0].bh->b_data;\n\t\t\tdxroot->info.indirect_levels += 1;\n\t\t\tdxtrace(printk(KERN_DEBUG\n\t\t\t\t       \"Creating %d level index...\\n\",\n\t\t\t\t       dxroot->info.indirect_levels));\n\t\t\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t\terr = ext4_handle_dirty_dx_node(handle, dir, bh2);\n\t\t\tbrelse(bh2);\n\t\t\trestart = 1;\n\t\t\tgoto journal_error;\n\t\t}\n\t}\n\tde = do_split(handle, dir, &bh, frame, &fname->hinfo);\n\tif (IS_ERR(de)) {\n\t\terr = PTR_ERR(de);\n\t\tgoto cleanup;\n\t}\n\terr = add_dirent_to_buf(handle, fname, dir, inode, de, bh);\n\tgoto cleanup;\n\njournal_error:\n\text4_std_error(dir->i_sb, err); /* this is a no-op if err == 0 */\ncleanup:\n\tbrelse(bh);\n\tdx_release(frames);\n\t/* @restart is true means htree-path has been changed, we need to\n\t * repeat dx_probe() to find out valid htree-path\n\t */\n\tif (restart && err == 0)\n\t\tgoto again;\n\treturn err;\n}\n\n/*\n * ext4_generic_delete_entry deletes a directory entry by merging it\n * with the previous entry\n */\nint ext4_generic_delete_entry(struct inode *dir,\n\t\t\t      struct ext4_dir_entry_2 *de_del,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *entry_buf,\n\t\t\t      int buf_size,\n\t\t\t      int csum_size)\n{\n\tstruct ext4_dir_entry_2 *de, *pde;\n\tunsigned int blocksize = dir->i_sb->s_blocksize;\n\tint i;\n\n\ti = 0;\n\tpde = NULL;\n\tde = (struct ext4_dir_entry_2 *)entry_buf;\n\twhile (i < buf_size - csum_size) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t entry_buf, buf_size, i))\n\t\t\treturn -EFSCORRUPTED;\n\t\tif (de == de_del)  {\n\t\t\tif (pde)\n\t\t\t\tpde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\t\text4_rec_len_from_disk(pde->rec_len,\n\t\t\t\t\t\t\t       blocksize) +\n\t\t\t\t\text4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t\t       blocksize),\n\t\t\t\t\tblocksize);\n\t\t\telse\n\t\t\t\tde->inode = 0;\n\t\t\tinode_inc_iversion(dir);\n\t\t\treturn 0;\n\t\t}\n\t\ti += ext4_rec_len_from_disk(de->rec_len, blocksize);\n\t\tpde = de;\n\t\tde = ext4_next_entry(de, blocksize);\n\t}\n\treturn -ENOENT;\n}\n\nstatic int ext4_delete_entry(handle_t *handle,\n\t\t\t     struct inode *dir,\n\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t     struct buffer_head *bh)\n{\n\tint err, csum_size = 0;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\terr = ext4_delete_inline_entry(handle, dir, de_del, bh,\n\t\t\t\t\t       &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = ext4_generic_delete_entry(dir, de_del, bh, bh->b_data,\n\t\t\t\t\tdir->i_sb->s_blocksize, csum_size);\n\tif (err)\n\t\tgoto out;\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tif (err != -ENOENT)\n\t\text4_std_error(dir->i_sb, err);\n\treturn err;\n}\n\n/*\n * Set directory link count to 1 if nlinks > EXT4_LINK_MAX, or if nlinks == 2\n * since this indicates that nlinks count was previously 1 to avoid overflowing\n * the 16-bit i_links_count field on disk.  Directories with i_nlink == 1 mean\n * that subdirectory link counts are not being maintained accurately.\n *\n * The caller has already checked for i_nlink overflow in case the DIR_LINK\n * feature is not enabled and returned -EMLINK.  The is_dx() check is a proxy\n * for checking S_ISDIR(inode) (since the INODE_INDEX feature will not be set\n * on regular files) and to avoid creating huge/slow non-HTREE directories.\n */\nstatic void ext4_inc_count(struct inode *inode)\n{\n\tinc_nlink(inode);\n\tif (is_dx(inode) &&\n\t    (inode->i_nlink > EXT4_LINK_MAX || inode->i_nlink == 2))\n\t\tset_nlink(inode, 1);\n}\n\n/*\n * If a directory had nlink == 1, then we should let it be 1. This indicates\n * directory has >EXT4_LINK_MAX subdirs.\n */\nstatic void ext4_dec_count(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) || inode->i_nlink > 2)\n\t\tdrop_nlink(inode);\n}\n\n\n/*\n * Add non-directory inode to a directory. On success, the inode reference is\n * consumed by dentry is instantiation. This is also indicated by clearing of\n * *inodep pointer. On failure, the caller is responsible for dropping the\n * inode reference in the safe context.\n */\nstatic int ext4_add_nondir(handle_t *handle,\n\t\tstruct dentry *dentry, struct inode **inodep)\n{\n\tstruct inode *dir = d_inode(dentry->d_parent);\n\tstruct inode *inode = *inodep;\n\tint err = ext4_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\terr = ext4_mark_inode_dirty(handle, inode);\n\t\tif (IS_DIRSYNC(dir))\n\t\t\text4_handle_sync(handle);\n\t\td_instantiate_new(dentry, inode);\n\t\t*inodep = NULL;\n\t\treturn err;\n\t}\n\tdrop_nlink(inode);\n\text4_orphan_add(handle, inode);\n\tunlock_new_inode(inode);\n\treturn err;\n}\n\n/*\n * By the time this is called, we already have created\n * the directory cache entry for the new file, but it\n * is so far negative - it has no inode.\n *\n * If the create succeeds, we fill in the inode information\n * with d_instantiate().\n */\nstatic int ext4_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t       bool excl)\n{\n\thandle_t *handle;\n\tstruct inode *inode, *inode_save;\n\tint err, credits, retries = 0;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tcredits = (EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t   EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3);\nretry:\n\tinode = ext4_new_inode_start_handle(dir, mode, &dentry->d_name, 0,\n\t\t\t\t\t    NULL, EXT4_HT_DIR, credits);\n\thandle = ext4_journal_current_handle();\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinode->i_op = &ext4_file_inode_operations;\n\t\tinode->i_fop = &ext4_file_operations;\n\t\text4_set_aops(inode);\n\t\tinode_save = inode;\n\t\tihold(inode_save);\n\t\terr = ext4_add_nondir(handle, dentry, &inode);\n\t\text4_fc_track_create(inode_save, dentry);\n\t\tiput(inode_save);\n\t}\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tif (!IS_ERR_OR_NULL(inode))\n\t\tiput(inode);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}\n\nstatic int ext4_mknod(struct inode *dir, struct dentry *dentry,\n\t\t      umode_t mode, dev_t rdev)\n{\n\thandle_t *handle;\n\tstruct inode *inode, *inode_save;\n\tint err, credits, retries = 0;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tcredits = (EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t   EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3);\nretry:\n\tinode = ext4_new_inode_start_handle(dir, mode, &dentry->d_name, 0,\n\t\t\t\t\t    NULL, EXT4_HT_DIR, credits);\n\thandle = ext4_journal_current_handle();\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n\t\tinode->i_op = &ext4_special_inode_operations;\n\t\tinode_save = inode;\n\t\tihold(inode_save);\n\t\terr = ext4_add_nondir(handle, dentry, &inode);\n\t\tif (!err)\n\t\t\text4_fc_track_create(inode_save, dentry);\n\t\tiput(inode_save);\n\t}\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tif (!IS_ERR_OR_NULL(inode))\n\t\tiput(inode);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}\n\nstatic int ext4_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, retries = 0;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\nretry:\n\tinode = ext4_new_inode_start_handle(dir, mode,\n\t\t\t\t\t    NULL, 0, NULL,\n\t\t\t\t\t    EXT4_HT_DIR,\n\t\t\tEXT4_MAXQUOTAS_INIT_BLOCKS(dir->i_sb) +\n\t\t\t  4 + EXT4_XATTR_TRANS_BLOCKS);\n\thandle = ext4_journal_current_handle();\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinode->i_op = &ext4_file_inode_operations;\n\t\tinode->i_fop = &ext4_file_operations;\n\t\text4_set_aops(inode);\n\t\td_tmpfile(dentry, inode);\n\t\terr = ext4_orphan_add(handle, inode);\n\t\tif (err)\n\t\t\tgoto err_unlock_inode;\n\t\tmark_inode_dirty(inode);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\nerr_unlock_inode:\n\text4_journal_stop(handle);\n\tunlock_new_inode(inode);\n\treturn err;\n}\n\nstruct ext4_dir_entry_2 *ext4_init_dot_dotdot(struct inode *inode,\n\t\t\t  struct ext4_dir_entry_2 *de,\n\t\t\t  int blocksize, int csum_size,\n\t\t\t  unsigned int parent_ino, int dotdot_real_len)\n{\n\tde->inode = cpu_to_le32(inode->i_ino);\n\tde->name_len = 1;\n\tde->rec_len = ext4_rec_len_to_disk(EXT4_DIR_REC_LEN(de->name_len),\n\t\t\t\t\t   blocksize);\n\tstrcpy(de->name, \".\");\n\text4_set_de_type(inode->i_sb, de, S_IFDIR);\n\n\tde = ext4_next_entry(de, blocksize);\n\tde->inode = cpu_to_le32(parent_ino);\n\tde->name_len = 2;\n\tif (!dotdot_real_len)\n\t\tde->rec_len = ext4_rec_len_to_disk(blocksize -\n\t\t\t\t\t(csum_size + EXT4_DIR_REC_LEN(1)),\n\t\t\t\t\tblocksize);\n\telse\n\t\tde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\tEXT4_DIR_REC_LEN(de->name_len), blocksize);\n\tstrcpy(de->name, \"..\");\n\text4_set_de_type(inode->i_sb, de, S_IFDIR);\n\n\treturn ext4_next_entry(de, blocksize);\n}\n\nint ext4_init_new_dir(handle_t *handle, struct inode *dir,\n\t\t\t     struct inode *inode)\n{\n\tstruct buffer_head *dir_block = NULL;\n\tstruct ext4_dir_entry_2 *de;\n\text4_lblk_t block = 0;\n\tunsigned int blocksize = dir->i_sb->s_blocksize;\n\tint csum_size = 0;\n\tint err;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)) {\n\t\terr = ext4_try_create_inline_dir(handle, dir, inode);\n\t\tif (err < 0 && err != -ENOSPC)\n\t\t\tgoto out;\n\t\tif (!err)\n\t\t\tgoto out;\n\t}\n\n\tinode->i_size = 0;\n\tdir_block = ext4_append(handle, inode, &block);\n\tif (IS_ERR(dir_block))\n\t\treturn PTR_ERR(dir_block);\n\tde = (struct ext4_dir_entry_2 *)dir_block->b_data;\n\text4_init_dot_dotdot(inode, de, blocksize, csum_size, dir->i_ino, 0);\n\tset_nlink(inode, 2);\n\tif (csum_size)\n\t\text4_initialize_dirent_tail(dir_block, blocksize);\n\n\tBUFFER_TRACE(dir_block, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirblock(handle, inode, dir_block);\n\tif (err)\n\t\tgoto out;\n\tset_buffer_verified(dir_block);\nout:\n\tbrelse(dir_block);\n\treturn err;\n}\n\nstatic int ext4_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, err2 = 0, credits, retries = 0;\n\n\tif (EXT4_DIR_LINK_MAX(dir))\n\t\treturn -EMLINK;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tcredits = (EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t   EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3);\nretry:\n\tinode = ext4_new_inode_start_handle(dir, S_IFDIR | mode,\n\t\t\t\t\t    &dentry->d_name,\n\t\t\t\t\t    0, NULL, EXT4_HT_DIR, credits);\n\thandle = ext4_journal_current_handle();\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_stop;\n\n\tinode->i_op = &ext4_dir_inode_operations;\n\tinode->i_fop = &ext4_dir_operations;\n\terr = ext4_init_new_dir(handle, dir, inode);\n\tif (err)\n\t\tgoto out_clear_inode;\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (!err)\n\t\terr = ext4_add_entry(handle, dentry, inode);\n\tif (err) {\nout_clear_inode:\n\t\tclear_nlink(inode);\n\t\text4_orphan_add(handle, inode);\n\t\tunlock_new_inode(inode);\n\t\terr2 = ext4_mark_inode_dirty(handle, inode);\n\t\tif (unlikely(err2))\n\t\t\terr = err2;\n\t\text4_journal_stop(handle);\n\t\tiput(inode);\n\t\tgoto out_retry;\n\t}\n\text4_fc_track_create(inode, dentry);\n\text4_inc_count(dir);\n\n\text4_update_dx_flag(dir);\n\terr = ext4_mark_inode_dirty(handle, dir);\n\tif (err)\n\t\tgoto out_clear_inode;\n\td_instantiate_new(dentry, inode);\n\tif (IS_DIRSYNC(dir))\n\t\text4_handle_sync(handle);\n\nout_stop:\n\tif (handle)\n\t\text4_journal_stop(handle);\nout_retry:\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}\n\n/*\n * routine to check that the specified directory is empty (for rmdir)\n */\nbool ext4_empty_dir(struct inode *inode)\n{\n\tunsigned int offset;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct super_block *sb;\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline_data = 1;\n\t\tint ret;\n\n\t\tret = empty_inline_dir(inode, &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn ret;\n\t}\n\n\tsb = inode->i_sb;\n\tif (inode->i_size < EXT4_DIR_REC_LEN(1) + EXT4_DIR_REC_LEN(2)) {\n\t\tEXT4_ERROR_INODE(inode, \"invalid size\");\n\t\treturn true;\n\t}\n\t/* The first directory block must not be a hole,\n\t * so treat it as DIRENT_HTREE\n\t */\n\tbh = ext4_read_dirblock(inode, 0, DIRENT_HTREE);\n\tif (IS_ERR(bh))\n\t\treturn true;\n\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tif (ext4_check_dir_entry(inode, NULL, de, bh, bh->b_data, bh->b_size,\n\t\t\t\t 0) ||\n\t    le32_to_cpu(de->inode) != inode->i_ino || strcmp(\".\", de->name)) {\n\t\text4_warning_inode(inode, \"directory missing '.'\");\n\t\tbrelse(bh);\n\t\treturn true;\n\t}\n\toffset = ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize);\n\tde = ext4_next_entry(de, sb->s_blocksize);\n\tif (ext4_check_dir_entry(inode, NULL, de, bh, bh->b_data, bh->b_size,\n\t\t\t\t offset) ||\n\t    le32_to_cpu(de->inode) == 0 || strcmp(\"..\", de->name)) {\n\t\text4_warning_inode(inode, \"directory missing '..'\");\n\t\tbrelse(bh);\n\t\treturn true;\n\t}\n\toffset += ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize);\n\twhile (offset < inode->i_size) {\n\t\tif (!(offset & (sb->s_blocksize - 1))) {\n\t\t\tunsigned int lblock;\n\t\t\tbrelse(bh);\n\t\t\tlblock = offset >> EXT4_BLOCK_SIZE_BITS(sb);\n\t\t\tbh = ext4_read_dirblock(inode, lblock, EITHER);\n\t\t\tif (bh == NULL) {\n\t\t\t\toffset += sb->s_blocksize;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (IS_ERR(bh))\n\t\t\t\treturn true;\n\t\t}\n\t\tde = (struct ext4_dir_entry_2 *) (bh->b_data +\n\t\t\t\t\t(offset & (sb->s_blocksize - 1)));\n\t\tif (ext4_check_dir_entry(inode, NULL, de, bh,\n\t\t\t\t\t bh->b_data, bh->b_size, offset)) {\n\t\t\toffset = (offset | (sb->s_blocksize - 1)) + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tbrelse(bh);\n\t\t\treturn false;\n\t\t}\n\t\toffset += ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize);\n\t}\n\tbrelse(bh);\n\treturn true;\n}\n\n/*\n * ext4_orphan_add() links an unlinked or truncated inode into a list of\n * such inodes, starting at the superblock, in case we crash before the\n * file is closed/deleted, or in case the inode truncate spans multiple\n * transactions and the last transaction is not recovered after a crash.\n *\n * At filesystem recovery time, we walk this list deleting unlinked\n * inodes and truncating linked inodes in ext4_orphan_cleanup().\n *\n * Orphan list manipulation functions must be called under i_mutex unless\n * we are just creating the inode or deleting it.\n */\nint ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !inode_is_locked(inode));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del_init(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t} else\n\t\tbrelse(iloc.bh);\n\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}\n\n/*\n * ext4_orphan_del() removes an unlinked or truncated inode from the list\n * of such inodes stored on disk, because it is finally being cleaned up.\n */\nint ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !inode_is_locked(inode));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}\n\nstatic int ext4_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint retval;\n\tstruct inode *inode;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\thandle_t *handle = NULL;\n\n\tif (unlikely(ext4_forced_shutdown(EXT4_SB(dir->i_sb))))\n\t\treturn -EIO;\n\n\t/* Initialize quotas before so that eventual writes go in\n\t * separate transaction */\n\tretval = dquot_initialize(dir);\n\tif (retval)\n\t\treturn retval;\n\tretval = dquot_initialize(d_inode(dentry));\n\tif (retval)\n\t\treturn retval;\n\n\tretval = -ENOENT;\n\tbh = ext4_find_entry(dir, &dentry->d_name, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tif (!bh)\n\t\tgoto end_rmdir;\n\n\tinode = d_inode(dentry);\n\n\tretval = -EFSCORRUPTED;\n\tif (le32_to_cpu(de->inode) != inode->i_ino)\n\t\tgoto end_rmdir;\n\n\tretval = -ENOTEMPTY;\n\tif (!ext4_empty_dir(inode))\n\t\tgoto end_rmdir;\n\n\thandle = ext4_journal_start(dir, EXT4_HT_DIR,\n\t\t\t\t    EXT4_DATA_TRANS_BLOCKS(dir->i_sb));\n\tif (IS_ERR(handle)) {\n\t\tretval = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tgoto end_rmdir;\n\t}\n\n\tif (IS_DIRSYNC(dir))\n\t\text4_handle_sync(handle);\n\n\tretval = ext4_delete_entry(handle, dir, de, bh);\n\tif (retval)\n\t\tgoto end_rmdir;\n\tif (!EXT4_DIR_LINK_EMPTY(inode))\n\t\text4_warning_inode(inode,\n\t\t\t     \"empty directory '%.*s' has too many links (%u)\",\n\t\t\t     dentry->d_name.len, dentry->d_name.name,\n\t\t\t     inode->i_nlink);\n\tinode_inc_iversion(inode);\n\tclear_nlink(inode);\n\t/* There's no need to set i_disksize: the fact that i_nlink is\n\t * zero will ensure that the right thing happens during any\n\t * recovery. */\n\tinode->i_size = 0;\n\text4_orphan_add(handle, inode);\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = current_time(inode);\n\tretval = ext4_mark_inode_dirty(handle, inode);\n\tif (retval)\n\t\tgoto end_rmdir;\n\text4_dec_count(dir);\n\text4_update_dx_flag(dir);\n\text4_fc_track_unlink(inode, dentry);\n\tretval = ext4_mark_inode_dirty(handle, dir);\n\n#ifdef CONFIG_UNICODE\n\t/* VFS negative dentries are incompatible with Encoding and\n\t * Case-insensitiveness. Eventually we'll want avoid\n\t * invalidating the dentries here, alongside with returning the\n\t * negative dentries at ext4_lookup(), when it is better\n\t * supported by the VFS for the CI case.\n\t */\n\tif (IS_CASEFOLDED(dir))\n\t\td_invalidate(dentry);\n#endif\n\nend_rmdir:\n\tbrelse(bh);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\treturn retval;\n}\n\nint __ext4_unlink(struct inode *dir, const struct qstr *d_name,\n\t\t  struct inode *inode)\n{\n\tint retval = -ENOENT;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\thandle_t *handle = NULL;\n\tint skip_remove_dentry = 0;\n\n\tbh = ext4_find_entry(dir, d_name, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\n\tif (!bh)\n\t\treturn -ENOENT;\n\n\tif (le32_to_cpu(de->inode) != inode->i_ino) {\n\t\t/*\n\t\t * It's okay if we find dont find dentry which matches\n\t\t * the inode. That's because it might have gotten\n\t\t * renamed to a different inode number\n\t\t */\n\t\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\t\tskip_remove_dentry = 1;\n\t\telse\n\t\t\tgoto out_bh;\n\t}\n\n\thandle = ext4_journal_start(dir, EXT4_HT_DIR,\n\t\t\t\t    EXT4_DATA_TRANS_BLOCKS(dir->i_sb));\n\tif (IS_ERR(handle)) {\n\t\tretval = PTR_ERR(handle);\n\t\tgoto out_bh;\n\t}\n\n\tif (IS_DIRSYNC(dir))\n\t\text4_handle_sync(handle);\n\n\tif (!skip_remove_dentry) {\n\t\tretval = ext4_delete_entry(handle, dir, de, bh);\n\t\tif (retval)\n\t\t\tgoto out_handle;\n\t\tdir->i_ctime = dir->i_mtime = current_time(dir);\n\t\text4_update_dx_flag(dir);\n\t\tretval = ext4_mark_inode_dirty(handle, dir);\n\t\tif (retval)\n\t\t\tgoto out_handle;\n\t} else {\n\t\tretval = 0;\n\t}\n\tif (inode->i_nlink == 0)\n\t\text4_warning_inode(inode, \"Deleting file '%.*s' with no links\",\n\t\t\t\t   d_name->len, d_name->name);\n\telse\n\t\tdrop_nlink(inode);\n\tif (!inode->i_nlink)\n\t\text4_orphan_add(handle, inode);\n\tinode->i_ctime = current_time(inode);\n\tretval = ext4_mark_inode_dirty(handle, inode);\n\nout_handle:\n\text4_journal_stop(handle);\nout_bh:\n\tbrelse(bh);\n\treturn retval;\n}\n\nstatic int ext4_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint retval;\n\n\tif (unlikely(ext4_forced_shutdown(EXT4_SB(dir->i_sb))))\n\t\treturn -EIO;\n\n\ttrace_ext4_unlink_enter(dir, dentry);\n\t/*\n\t * Initialize quotas before so that eventual writes go\n\t * in separate transaction\n\t */\n\tretval = dquot_initialize(dir);\n\tif (retval)\n\t\tgoto out_trace;\n\tretval = dquot_initialize(d_inode(dentry));\n\tif (retval)\n\t\tgoto out_trace;\n\n\tretval = __ext4_unlink(dir, &dentry->d_name, d_inode(dentry));\n\tif (!retval)\n\t\text4_fc_track_unlink(d_inode(dentry), dentry);\n#ifdef CONFIG_UNICODE\n\t/* VFS negative dentries are incompatible with Encoding and\n\t * Case-insensitiveness. Eventually we'll want avoid\n\t * invalidating the dentries here, alongside with returning the\n\t * negative dentries at ext4_lookup(), when it is  better\n\t * supported by the VFS for the CI case.\n\t */\n\tif (IS_CASEFOLDED(dir))\n\t\td_invalidate(dentry);\n#endif\n\nout_trace:\n\ttrace_ext4_unlink_exit(dentry, retval);\n\treturn retval;\n}\n\nstatic int ext4_symlink(struct inode *dir,\n\t\t\tstruct dentry *dentry, const char *symname)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, len = strlen(symname);\n\tint credits;\n\tstruct fscrypt_str disk_link;\n\n\tif (unlikely(ext4_forced_shutdown(EXT4_SB(dir->i_sb))))\n\t\treturn -EIO;\n\n\terr = fscrypt_prepare_symlink(dir, symname, len, dir->i_sb->s_blocksize,\n\t\t\t\t      &disk_link);\n\tif (err)\n\t\treturn err;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tif ((disk_link.len > EXT4_N_BLOCKS * 4)) {\n\t\t/*\n\t\t * For non-fast symlinks, we just allocate inode and put it on\n\t\t * orphan list in the first transaction => we need bitmap,\n\t\t * group descriptor, sb, inode block, quota blocks, and\n\t\t * possibly selinux xattr blocks.\n\t\t */\n\t\tcredits = 4 + EXT4_MAXQUOTAS_INIT_BLOCKS(dir->i_sb) +\n\t\t\t  EXT4_XATTR_TRANS_BLOCKS;\n\t} else {\n\t\t/*\n\t\t * Fast symlink. We have to add entry to directory\n\t\t * (EXT4_DATA_TRANS_BLOCKS + EXT4_INDEX_EXTRA_TRANS_BLOCKS),\n\t\t * allocate new inode (bitmap, group descriptor, inode block,\n\t\t * quota blocks, sb is already counted in previous macros).\n\t\t */\n\t\tcredits = EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t  EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3;\n\t}\n\n\tinode = ext4_new_inode_start_handle(dir, S_IFLNK|S_IRWXUGO,\n\t\t\t\t\t    &dentry->d_name, 0, NULL,\n\t\t\t\t\t    EXT4_HT_DIR, credits);\n\thandle = ext4_journal_current_handle();\n\tif (IS_ERR(inode)) {\n\t\tif (handle)\n\t\t\text4_journal_stop(handle);\n\t\treturn PTR_ERR(inode);\n\t}\n\n\tif (IS_ENCRYPTED(inode)) {\n\t\terr = fscrypt_encrypt_symlink(inode, symname, len, &disk_link);\n\t\tif (err)\n\t\t\tgoto err_drop_inode;\n\t\tinode->i_op = &ext4_encrypted_symlink_inode_operations;\n\t}\n\n\tif ((disk_link.len > EXT4_N_BLOCKS * 4)) {\n\t\tif (!IS_ENCRYPTED(inode))\n\t\t\tinode->i_op = &ext4_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\text4_set_aops(inode);\n\t\t/*\n\t\t * We cannot call page_symlink() with transaction started\n\t\t * because it calls into ext4_write_begin() which can wait\n\t\t * for transaction commit if we are running out of space\n\t\t * and thus we deadlock. So we have to stop transaction now\n\t\t * and restart it when symlink contents is written.\n\t\t * \n\t\t * To keep fs consistent in case of crash, we have to put inode\n\t\t * to orphan list in the mean time.\n\t\t */\n\t\tdrop_nlink(inode);\n\t\terr = ext4_orphan_add(handle, inode);\n\t\tif (handle)\n\t\t\text4_journal_stop(handle);\n\t\thandle = NULL;\n\t\tif (err)\n\t\t\tgoto err_drop_inode;\n\t\terr = __page_symlink(inode, disk_link.name, disk_link.len, 1);\n\t\tif (err)\n\t\t\tgoto err_drop_inode;\n\t\t/*\n\t\t * Now inode is being linked into dir (EXT4_DATA_TRANS_BLOCKS\n\t\t * + EXT4_INDEX_EXTRA_TRANS_BLOCKS), inode is also modified\n\t\t */\n\t\thandle = ext4_journal_start(dir, EXT4_HT_DIR,\n\t\t\t\tEXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\tEXT4_INDEX_EXTRA_TRANS_BLOCKS + 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\thandle = NULL;\n\t\t\tgoto err_drop_inode;\n\t\t}\n\t\tset_nlink(inode, 1);\n\t\terr = ext4_orphan_del(handle, inode);\n\t\tif (err)\n\t\t\tgoto err_drop_inode;\n\t} else {\n\t\t/* clear the extent format for fast symlink */\n\t\text4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\tif (!IS_ENCRYPTED(inode)) {\n\t\t\tinode->i_op = &ext4_fast_symlink_inode_operations;\n\t\t\tinode->i_link = (char *)&EXT4_I(inode)->i_data;\n\t\t}\n\t\tmemcpy((char *)&EXT4_I(inode)->i_data, disk_link.name,\n\t\t       disk_link.len);\n\t\tinode->i_size = disk_link.len - 1;\n\t}\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\terr = ext4_add_nondir(handle, dentry, &inode);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tif (inode)\n\t\tiput(inode);\n\tgoto out_free_encrypted_link;\n\nerr_drop_inode:\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\nout_free_encrypted_link:\n\tif (disk_link.name != (unsigned char *)symname)\n\t\tkfree(disk_link.name);\n\treturn err;\n}\n\nint __ext4_link(struct inode *dir, struct inode *inode, struct dentry *dentry)\n{\n\thandle_t *handle;\n\tint err, retries = 0;\nretry:\n\thandle = ext4_journal_start(dir, EXT4_HT_DIR,\n\t\t(EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t EXT4_INDEX_EXTRA_TRANS_BLOCKS) + 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(dir))\n\t\text4_handle_sync(handle);\n\n\tinode->i_ctime = current_time(inode);\n\text4_inc_count(inode);\n\tihold(inode);\n\n\terr = ext4_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\text4_fc_track_link(inode, dentry);\n\t\terr = ext4_mark_inode_dirty(handle, inode);\n\t\t/* this can happen only for tmpfile being\n\t\t * linked the first time\n\t\t */\n\t\tif (inode->i_nlink == 1)\n\t\t\text4_orphan_del(handle, inode);\n\t\td_instantiate(dentry, inode);\n\t} else {\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t}\n\text4_journal_stop(handle);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}\n\nstatic int ext4_link(struct dentry *old_dentry,\n\t\t     struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(old_dentry);\n\tint err;\n\n\tif (inode->i_nlink >= EXT4_LINK_MAX)\n\t\treturn -EMLINK;\n\n\terr = fscrypt_prepare_link(old_dentry, dir, dentry);\n\tif (err)\n\t\treturn err;\n\n\tif ((ext4_test_inode_flag(dir, EXT4_INODE_PROJINHERIT)) &&\n\t    (!projid_eq(EXT4_I(dir)->i_projid,\n\t\t\tEXT4_I(old_dentry->d_inode)->i_projid)))\n\t\treturn -EXDEV;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\treturn __ext4_link(dir, inode, dentry);\n}\n\n/*\n * Try to find buffer head where contains the parent block.\n * It should be the inode block if it is inlined or the 1st block\n * if it is a normal dir.\n */\nstatic struct buffer_head *ext4_get_first_dir_block(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tint *retval,\n\t\t\t\t\tstruct ext4_dir_entry_2 **parent_de,\n\t\t\t\t\tint *inlined)\n{\n\tstruct buffer_head *bh;\n\n\tif (!ext4_has_inline_data(inode)) {\n\t\t/* The first directory block must not be a hole, so\n\t\t * treat it as DIRENT_HTREE\n\t\t */\n\t\tbh = ext4_read_dirblock(inode, 0, DIRENT_HTREE);\n\t\tif (IS_ERR(bh)) {\n\t\t\t*retval = PTR_ERR(bh);\n\t\t\treturn NULL;\n\t\t}\n\t\t*parent_de = ext4_next_entry(\n\t\t\t\t\t(struct ext4_dir_entry_2 *)bh->b_data,\n\t\t\t\t\tinode->i_sb->s_blocksize);\n\t\treturn bh;\n\t}\n\n\t*inlined = 1;\n\treturn ext4_get_first_inline_block(inode, parent_de, retval);\n}\n\nstruct ext4_renament {\n\tstruct inode *dir;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tbool is_dir;\n\tint dir_nlink_delta;\n\n\t/* entry for \"dentry\" */\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\tint inlined;\n\n\t/* entry for \"..\" in inode if it's a directory */\n\tstruct buffer_head *dir_bh;\n\tstruct ext4_dir_entry_2 *parent_de;\n\tint dir_inlined;\n};\n\nstatic int ext4_rename_dir_prepare(handle_t *handle, struct ext4_renament *ent)\n{\n\tint retval;\n\n\tent->dir_bh = ext4_get_first_dir_block(handle, ent->inode,\n\t\t\t\t\t      &retval, &ent->parent_de,\n\t\t\t\t\t      &ent->dir_inlined);\n\tif (!ent->dir_bh)\n\t\treturn retval;\n\tif (le32_to_cpu(ent->parent_de->inode) != ent->dir->i_ino)\n\t\treturn -EFSCORRUPTED;\n\tBUFFER_TRACE(ent->dir_bh, \"get_write_access\");\n\treturn ext4_journal_get_write_access(handle, ent->dir_bh);\n}\n\nstatic int ext4_rename_dir_finish(handle_t *handle, struct ext4_renament *ent,\n\t\t\t\t  unsigned dir_ino)\n{\n\tint retval;\n\n\tent->parent_de->inode = cpu_to_le32(dir_ino);\n\tBUFFER_TRACE(ent->dir_bh, \"call ext4_handle_dirty_metadata\");\n\tif (!ent->dir_inlined) {\n\t\tif (is_dx(ent->inode)) {\n\t\t\tretval = ext4_handle_dirty_dx_node(handle,\n\t\t\t\t\t\t\t   ent->inode,\n\t\t\t\t\t\t\t   ent->dir_bh);\n\t\t} else {\n\t\t\tretval = ext4_handle_dirty_dirblock(handle, ent->inode,\n\t\t\t\t\t\t\t    ent->dir_bh);\n\t\t}\n\t} else {\n\t\tretval = ext4_mark_inode_dirty(handle, ent->inode);\n\t}\n\tif (retval) {\n\t\text4_std_error(ent->dir->i_sb, retval);\n\t\treturn retval;\n\t}\n\treturn 0;\n}\n\nstatic int ext4_setent(handle_t *handle, struct ext4_renament *ent,\n\t\t       unsigned ino, unsigned file_type)\n{\n\tint retval, retval2;\n\n\tBUFFER_TRACE(ent->bh, \"get write access\");\n\tretval = ext4_journal_get_write_access(handle, ent->bh);\n\tif (retval)\n\t\treturn retval;\n\tent->de->inode = cpu_to_le32(ino);\n\tif (ext4_has_feature_filetype(ent->dir->i_sb))\n\t\tent->de->file_type = file_type;\n\tinode_inc_iversion(ent->dir);\n\tent->dir->i_ctime = ent->dir->i_mtime =\n\t\tcurrent_time(ent->dir);\n\tretval = ext4_mark_inode_dirty(handle, ent->dir);\n\tBUFFER_TRACE(ent->bh, \"call ext4_handle_dirty_metadata\");\n\tif (!ent->inlined) {\n\t\tretval2 = ext4_handle_dirty_dirblock(handle, ent->dir, ent->bh);\n\t\tif (unlikely(retval2)) {\n\t\t\text4_std_error(ent->dir->i_sb, retval2);\n\t\t\treturn retval2;\n\t\t}\n\t}\n\tbrelse(ent->bh);\n\tent->bh = NULL;\n\n\treturn retval;\n}\n\nstatic int ext4_find_delete_entry(handle_t *handle, struct inode *dir,\n\t\t\t\t  const struct qstr *d_name)\n{\n\tint retval = -ENOENT;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\n\tbh = ext4_find_entry(dir, d_name, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tif (bh) {\n\t\tretval = ext4_delete_entry(handle, dir, de, bh);\n\t\tbrelse(bh);\n\t}\n\treturn retval;\n}\n\nstatic void ext4_rename_delete(handle_t *handle, struct ext4_renament *ent,\n\t\t\t       int force_reread)\n{\n\tint retval;\n\t/*\n\t * ent->de could have moved from under us during htree split, so make\n\t * sure that we are deleting the right entry.  We might also be pointing\n\t * to a stale entry in the unused part of ent->bh so just checking inum\n\t * and the name isn't enough.\n\t */\n\tif (le32_to_cpu(ent->de->inode) != ent->inode->i_ino ||\n\t    ent->de->name_len != ent->dentry->d_name.len ||\n\t    strncmp(ent->de->name, ent->dentry->d_name.name,\n\t\t    ent->de->name_len) ||\n\t    force_reread) {\n\t\tretval = ext4_find_delete_entry(handle, ent->dir,\n\t\t\t\t\t\t&ent->dentry->d_name);\n\t} else {\n\t\tretval = ext4_delete_entry(handle, ent->dir, ent->de, ent->bh);\n\t\tif (retval == -ENOENT) {\n\t\t\tretval = ext4_find_delete_entry(handle, ent->dir,\n\t\t\t\t\t\t\t&ent->dentry->d_name);\n\t\t}\n\t}\n\n\tif (retval) {\n\t\text4_warning_inode(ent->dir,\n\t\t\t\t   \"Deleting old file: nlink %d, error=%d\",\n\t\t\t\t   ent->dir->i_nlink, retval);\n\t}\n}\n\nstatic void ext4_update_dir_count(handle_t *handle, struct ext4_renament *ent)\n{\n\tif (ent->dir_nlink_delta) {\n\t\tif (ent->dir_nlink_delta == -1)\n\t\t\text4_dec_count(ent->dir);\n\t\telse\n\t\t\text4_inc_count(ent->dir);\n\t\text4_mark_inode_dirty(handle, ent->dir);\n\t}\n}\n\nstatic struct inode *ext4_whiteout_for_rename(struct ext4_renament *ent,\n\t\t\t\t\t      int credits, handle_t **h)\n{\n\tstruct inode *wh;\n\thandle_t *handle;\n\tint retries = 0;\n\n\t/*\n\t * for inode block, sb block, group summaries,\n\t * and inode bitmap\n\t */\n\tcredits += (EXT4_MAXQUOTAS_TRANS_BLOCKS(ent->dir->i_sb) +\n\t\t    EXT4_XATTR_TRANS_BLOCKS + 4);\nretry:\n\twh = ext4_new_inode_start_handle(ent->dir, S_IFCHR | WHITEOUT_MODE,\n\t\t\t\t\t &ent->dentry->d_name, 0, NULL,\n\t\t\t\t\t EXT4_HT_DIR, credits);\n\n\thandle = ext4_journal_current_handle();\n\tif (IS_ERR(wh)) {\n\t\tif (handle)\n\t\t\text4_journal_stop(handle);\n\t\tif (PTR_ERR(wh) == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(ent->dir->i_sb, &retries))\n\t\t\tgoto retry;\n\t} else {\n\t\t*h = handle;\n\t\tinit_special_inode(wh, wh->i_mode, WHITEOUT_DEV);\n\t\twh->i_op = &ext4_special_inode_operations;\n\t}\n\treturn wh;\n}\n\n/*\n * Anybody can rename anything with this: the permission checks are left to the\n * higher-level routines.\n *\n * n.b.  old_{dentry,inode) refers to the source dentry/inode\n * while new_{dentry,inode) refers to the destination dentry/inode\n * This comes from rename(const char *oldpath, const char *newpath)\n */\nstatic int ext4_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t       struct inode *new_dir, struct dentry *new_dentry,\n\t\t       unsigned int flags)\n{\n\thandle_t *handle = NULL;\n\tstruct ext4_renament old = {\n\t\t.dir = old_dir,\n\t\t.dentry = old_dentry,\n\t\t.inode = d_inode(old_dentry),\n\t};\n\tstruct ext4_renament new = {\n\t\t.dir = new_dir,\n\t\t.dentry = new_dentry,\n\t\t.inode = d_inode(new_dentry),\n\t};\n\tint force_reread;\n\tint retval;\n\tstruct inode *whiteout = NULL;\n\tint credits;\n\tu8 old_file_type;\n\n\tif (new.inode && new.inode->i_nlink == 0) {\n\t\tEXT4_ERROR_INODE(new.inode,\n\t\t\t\t \"target of rename is already freed\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif ((ext4_test_inode_flag(new_dir, EXT4_INODE_PROJINHERIT)) &&\n\t    (!projid_eq(EXT4_I(new_dir)->i_projid,\n\t\t\tEXT4_I(old_dentry->d_inode)->i_projid)))\n\t\treturn -EXDEV;\n\n\tretval = dquot_initialize(old.dir);\n\tif (retval)\n\t\treturn retval;\n\tretval = dquot_initialize(new.dir);\n\tif (retval)\n\t\treturn retval;\n\n\t/* Initialize quotas before so that eventual writes go\n\t * in separate transaction */\n\tif (new.inode) {\n\t\tretval = dquot_initialize(new.inode);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\told.bh = ext4_find_entry(old.dir, &old.dentry->d_name, &old.de, NULL);\n\tif (IS_ERR(old.bh))\n\t\treturn PTR_ERR(old.bh);\n\t/*\n\t *  Check for inode number is _not_ due to possible IO errors.\n\t *  We might rmdir the source, keep it as pwd of some process\n\t *  and merrily kill the link to whatever was created under the\n\t *  same name. Goodbye sticky bit ;-<\n\t */\n\tretval = -ENOENT;\n\tif (!old.bh || le32_to_cpu(old.de->inode) != old.inode->i_ino)\n\t\tgoto end_rename;\n\n\tnew.bh = ext4_find_entry(new.dir, &new.dentry->d_name,\n\t\t\t\t &new.de, &new.inlined);\n\tif (IS_ERR(new.bh)) {\n\t\tretval = PTR_ERR(new.bh);\n\t\tnew.bh = NULL;\n\t\tgoto end_rename;\n\t}\n\tif (new.bh) {\n\t\tif (!new.inode) {\n\t\t\tbrelse(new.bh);\n\t\t\tnew.bh = NULL;\n\t\t}\n\t}\n\tif (new.inode && !test_opt(new.dir->i_sb, NO_AUTO_DA_ALLOC))\n\t\text4_alloc_da_blocks(old.inode);\n\n\tcredits = (2 * EXT4_DATA_TRANS_BLOCKS(old.dir->i_sb) +\n\t\t   EXT4_INDEX_EXTRA_TRANS_BLOCKS + 2);\n\tif (!(flags & RENAME_WHITEOUT)) {\n\t\thandle = ext4_journal_start(old.dir, EXT4_HT_DIR, credits);\n\t\tif (IS_ERR(handle)) {\n\t\t\tretval = PTR_ERR(handle);\n\t\t\thandle = NULL;\n\t\t\tgoto end_rename;\n\t\t}\n\t} else {\n\t\twhiteout = ext4_whiteout_for_rename(&old, credits, &handle);\n\t\tif (IS_ERR(whiteout)) {\n\t\t\tretval = PTR_ERR(whiteout);\n\t\t\twhiteout = NULL;\n\t\t\tgoto end_rename;\n\t\t}\n\t}\n\n\tif (IS_DIRSYNC(old.dir) || IS_DIRSYNC(new.dir))\n\t\text4_handle_sync(handle);\n\n\tif (S_ISDIR(old.inode->i_mode)) {\n\t\tif (new.inode) {\n\t\t\tretval = -ENOTEMPTY;\n\t\t\tif (!ext4_empty_dir(new.inode))\n\t\t\t\tgoto end_rename;\n\t\t} else {\n\t\t\tretval = -EMLINK;\n\t\t\tif (new.dir != old.dir && EXT4_DIR_LINK_MAX(new.dir))\n\t\t\t\tgoto end_rename;\n\t\t}\n\t\tretval = ext4_rename_dir_prepare(handle, &old);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\t/*\n\t * If we're renaming a file within an inline_data dir and adding or\n\t * setting the new dirent causes a conversion from inline_data to\n\t * extents/blockmap, we need to force the dirent delete code to\n\t * re-read the directory, or else we end up trying to delete a dirent\n\t * from what is now the extent tree root (or a block map).\n\t */\n\tforce_reread = (new.dir->i_ino == old.dir->i_ino &&\n\t\t\text4_test_inode_flag(new.dir, EXT4_INODE_INLINE_DATA));\n\n\told_file_type = old.de->file_type;\n\tif (whiteout) {\n\t\t/*\n\t\t * Do this before adding a new entry, so the old entry is sure\n\t\t * to be still pointing to the valid old entry.\n\t\t */\n\t\tretval = ext4_setent(handle, &old, whiteout->i_ino,\n\t\t\t\t     EXT4_FT_CHRDEV);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t\tretval = ext4_mark_inode_dirty(handle, whiteout);\n\t\tif (unlikely(retval))\n\t\t\tgoto end_rename;\n\t}\n\tif (!new.bh) {\n\t\tretval = ext4_add_entry(handle, new.dentry, old.inode);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t} else {\n\t\tretval = ext4_setent(handle, &new,\n\t\t\t\t     old.inode->i_ino, old_file_type);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\tif (force_reread)\n\t\tforce_reread = !ext4_test_inode_flag(new.dir,\n\t\t\t\t\t\t     EXT4_INODE_INLINE_DATA);\n\n\t/*\n\t * Like most other Unix systems, set the ctime for inodes on a\n\t * rename.\n\t */\n\told.inode->i_ctime = current_time(old.inode);\n\tretval = ext4_mark_inode_dirty(handle, old.inode);\n\tif (unlikely(retval))\n\t\tgoto end_rename;\n\n\tif (!whiteout) {\n\t\t/*\n\t\t * ok, that's it\n\t\t */\n\t\text4_rename_delete(handle, &old, force_reread);\n\t}\n\n\tif (new.inode) {\n\t\text4_dec_count(new.inode);\n\t\tnew.inode->i_ctime = current_time(new.inode);\n\t}\n\told.dir->i_ctime = old.dir->i_mtime = current_time(old.dir);\n\text4_update_dx_flag(old.dir);\n\tif (old.dir_bh) {\n\t\tretval = ext4_rename_dir_finish(handle, &old, new.dir->i_ino);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\n\t\text4_dec_count(old.dir);\n\t\tif (new.inode) {\n\t\t\t/* checked ext4_empty_dir above, can't have another\n\t\t\t * parent, ext4_dec_count() won't work for many-linked\n\t\t\t * dirs */\n\t\t\tclear_nlink(new.inode);\n\t\t} else {\n\t\t\text4_inc_count(new.dir);\n\t\t\text4_update_dx_flag(new.dir);\n\t\t\tretval = ext4_mark_inode_dirty(handle, new.dir);\n\t\t\tif (unlikely(retval))\n\t\t\t\tgoto end_rename;\n\t\t}\n\t}\n\tretval = ext4_mark_inode_dirty(handle, old.dir);\n\tif (unlikely(retval))\n\t\tgoto end_rename;\n\n\tif (S_ISDIR(old.inode->i_mode)) {\n\t\t/*\n\t\t * We disable fast commits here that's because the\n\t\t * replay code is not yet capable of changing dot dot\n\t\t * dirents in directories.\n\t\t */\n\t\text4_fc_mark_ineligible(old.inode->i_sb,\n\t\t\tEXT4_FC_REASON_RENAME_DIR);\n\t} else {\n\t\tif (new.inode)\n\t\t\text4_fc_track_unlink(new.inode, new.dentry);\n\t\text4_fc_track_link(old.inode, new.dentry);\n\t\text4_fc_track_unlink(old.inode, old.dentry);\n\t}\n\n\tif (new.inode) {\n\t\tretval = ext4_mark_inode_dirty(handle, new.inode);\n\t\tif (unlikely(retval))\n\t\t\tgoto end_rename;\n\t\tif (!new.inode->i_nlink)\n\t\t\text4_orphan_add(handle, new.inode);\n\t}\n\tretval = 0;\n\nend_rename:\n\tbrelse(old.dir_bh);\n\tbrelse(old.bh);\n\tbrelse(new.bh);\n\tif (whiteout) {\n\t\tif (retval)\n\t\t\tdrop_nlink(whiteout);\n\t\tunlock_new_inode(whiteout);\n\t\tiput(whiteout);\n\t}\n\tif (handle)\n\t\text4_journal_stop(handle);\n\treturn retval;\n}\n\nstatic int ext4_cross_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir, struct dentry *new_dentry)\n{\n\thandle_t *handle = NULL;\n\tstruct ext4_renament old = {\n\t\t.dir = old_dir,\n\t\t.dentry = old_dentry,\n\t\t.inode = d_inode(old_dentry),\n\t};\n\tstruct ext4_renament new = {\n\t\t.dir = new_dir,\n\t\t.dentry = new_dentry,\n\t\t.inode = d_inode(new_dentry),\n\t};\n\tu8 new_file_type;\n\tint retval;\n\tstruct timespec64 ctime;\n\n\tif ((ext4_test_inode_flag(new_dir, EXT4_INODE_PROJINHERIT) &&\n\t     !projid_eq(EXT4_I(new_dir)->i_projid,\n\t\t\tEXT4_I(old_dentry->d_inode)->i_projid)) ||\n\t    (ext4_test_inode_flag(old_dir, EXT4_INODE_PROJINHERIT) &&\n\t     !projid_eq(EXT4_I(old_dir)->i_projid,\n\t\t\tEXT4_I(new_dentry->d_inode)->i_projid)))\n\t\treturn -EXDEV;\n\n\tretval = dquot_initialize(old.dir);\n\tif (retval)\n\t\treturn retval;\n\tretval = dquot_initialize(new.dir);\n\tif (retval)\n\t\treturn retval;\n\n\told.bh = ext4_find_entry(old.dir, &old.dentry->d_name,\n\t\t\t\t &old.de, &old.inlined);\n\tif (IS_ERR(old.bh))\n\t\treturn PTR_ERR(old.bh);\n\t/*\n\t *  Check for inode number is _not_ due to possible IO errors.\n\t *  We might rmdir the source, keep it as pwd of some process\n\t *  and merrily kill the link to whatever was created under the\n\t *  same name. Goodbye sticky bit ;-<\n\t */\n\tretval = -ENOENT;\n\tif (!old.bh || le32_to_cpu(old.de->inode) != old.inode->i_ino)\n\t\tgoto end_rename;\n\n\tnew.bh = ext4_find_entry(new.dir, &new.dentry->d_name,\n\t\t\t\t &new.de, &new.inlined);\n\tif (IS_ERR(new.bh)) {\n\t\tretval = PTR_ERR(new.bh);\n\t\tnew.bh = NULL;\n\t\tgoto end_rename;\n\t}\n\n\t/* RENAME_EXCHANGE case: old *and* new must both exist */\n\tif (!new.bh || le32_to_cpu(new.de->inode) != new.inode->i_ino)\n\t\tgoto end_rename;\n\n\thandle = ext4_journal_start(old.dir, EXT4_HT_DIR,\n\t\t(2 * EXT4_DATA_TRANS_BLOCKS(old.dir->i_sb) +\n\t\t 2 * EXT4_INDEX_EXTRA_TRANS_BLOCKS + 2));\n\tif (IS_ERR(handle)) {\n\t\tretval = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tgoto end_rename;\n\t}\n\n\tif (IS_DIRSYNC(old.dir) || IS_DIRSYNC(new.dir))\n\t\text4_handle_sync(handle);\n\n\tif (S_ISDIR(old.inode->i_mode)) {\n\t\told.is_dir = true;\n\t\tretval = ext4_rename_dir_prepare(handle, &old);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\tif (S_ISDIR(new.inode->i_mode)) {\n\t\tnew.is_dir = true;\n\t\tretval = ext4_rename_dir_prepare(handle, &new);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\n\t/*\n\t * Other than the special case of overwriting a directory, parents'\n\t * nlink only needs to be modified if this is a cross directory rename.\n\t */\n\tif (old.dir != new.dir && old.is_dir != new.is_dir) {\n\t\told.dir_nlink_delta = old.is_dir ? -1 : 1;\n\t\tnew.dir_nlink_delta = -old.dir_nlink_delta;\n\t\tretval = -EMLINK;\n\t\tif ((old.dir_nlink_delta > 0 && EXT4_DIR_LINK_MAX(old.dir)) ||\n\t\t    (new.dir_nlink_delta > 0 && EXT4_DIR_LINK_MAX(new.dir)))\n\t\t\tgoto end_rename;\n\t}\n\n\tnew_file_type = new.de->file_type;\n\tretval = ext4_setent(handle, &new, old.inode->i_ino, old.de->file_type);\n\tif (retval)\n\t\tgoto end_rename;\n\n\tretval = ext4_setent(handle, &old, new.inode->i_ino, new_file_type);\n\tif (retval)\n\t\tgoto end_rename;\n\n\t/*\n\t * Like most other Unix systems, set the ctime for inodes on a\n\t * rename.\n\t */\n\tctime = current_time(old.inode);\n\told.inode->i_ctime = ctime;\n\tnew.inode->i_ctime = ctime;\n\tretval = ext4_mark_inode_dirty(handle, old.inode);\n\tif (unlikely(retval))\n\t\tgoto end_rename;\n\tretval = ext4_mark_inode_dirty(handle, new.inode);\n\tif (unlikely(retval))\n\t\tgoto end_rename;\n\text4_fc_mark_ineligible(new.inode->i_sb,\n\t\t\t\tEXT4_FC_REASON_CROSS_RENAME);\n\tif (old.dir_bh) {\n\t\tretval = ext4_rename_dir_finish(handle, &old, new.dir->i_ino);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\tif (new.dir_bh) {\n\t\tretval = ext4_rename_dir_finish(handle, &new, old.dir->i_ino);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\text4_update_dir_count(handle, &old);\n\text4_update_dir_count(handle, &new);\n\tretval = 0;\n\nend_rename:\n\tbrelse(old.dir_bh);\n\tbrelse(new.dir_bh);\n\tbrelse(old.bh);\n\tbrelse(new.bh);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\treturn retval;\n}\n\nstatic int ext4_rename2(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry,\n\t\t\tunsigned int flags)\n{\n\tint err;\n\n\tif (unlikely(ext4_forced_shutdown(EXT4_SB(old_dir->i_sb))))\n\t\treturn -EIO;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\treturn -EINVAL;\n\n\terr = fscrypt_prepare_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t     flags);\n\tif (err)\n\t\treturn err;\n\n\tif (flags & RENAME_EXCHANGE) {\n\t\treturn ext4_cross_rename(old_dir, old_dentry,\n\t\t\t\t\t new_dir, new_dentry);\n\t}\n\n\treturn ext4_rename(old_dir, old_dentry, new_dir, new_dentry, flags);\n}\n\n/*\n * directories can handle most operations...\n */\nconst struct inode_operations ext4_dir_inode_operations = {\n\t.create\t\t= ext4_create,\n\t.lookup\t\t= ext4_lookup,\n\t.link\t\t= ext4_link,\n\t.unlink\t\t= ext4_unlink,\n\t.symlink\t= ext4_symlink,\n\t.mkdir\t\t= ext4_mkdir,\n\t.rmdir\t\t= ext4_rmdir,\n\t.mknod\t\t= ext4_mknod,\n\t.tmpfile\t= ext4_tmpfile,\n\t.rename\t\t= ext4_rename2,\n\t.setattr\t= ext4_setattr,\n\t.getattr\t= ext4_getattr,\n\t.listxattr\t= ext4_listxattr,\n\t.get_acl\t= ext4_get_acl,\n\t.set_acl\t= ext4_set_acl,\n\t.fiemap         = ext4_fiemap,\n};\n\nconst struct inode_operations ext4_special_inode_operations = {\n\t.setattr\t= ext4_setattr,\n\t.getattr\t= ext4_getattr,\n\t.listxattr\t= ext4_listxattr,\n\t.get_acl\t= ext4_get_acl,\n\t.set_acl\t= ext4_set_acl,\n};\n"}, "1": {"id": 1, "path": "/src/include/linux/byteorder/generic.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_BYTEORDER_GENERIC_H\n#define _LINUX_BYTEORDER_GENERIC_H\n\n/*\n * linux/byteorder/generic.h\n * Generic Byte-reordering support\n *\n * The \"... p\" macros, like le64_to_cpup, can be used with pointers\n * to unaligned data, but there will be a performance penalty on \n * some architectures.  Use get_unaligned for unaligned data.\n *\n * Francois-Rene Rideau <fare@tunes.org> 19970707\n *    gathered all the good ideas from all asm-foo/byteorder.h into one file,\n *    cleaned them up.\n *    I hope it is compliant with non-GCC compilers.\n *    I decided to put __BYTEORDER_HAS_U64__ in byteorder.h,\n *    because I wasn't sure it would be ok to put it in types.h\n *    Upgraded it to 2.1.43\n * Francois-Rene Rideau <fare@tunes.org> 19971012\n *    Upgraded it to 2.1.57\n *    to please Linus T., replaced huge #ifdef's between little/big endian\n *    by nestedly #include'd files.\n * Francois-Rene Rideau <fare@tunes.org> 19971205\n *    Made it to 2.1.71; now a facelift:\n *    Put files under include/linux/byteorder/\n *    Split swab from generic support.\n *\n * TODO:\n *   = Regular kernel maintainers could also replace all these manual\n *    byteswap macros that remain, disseminated among drivers,\n *    after some grep or the sources...\n *   = Linus might want to rename all these macros and files to fit his taste,\n *    to fit his personal naming scheme.\n *   = it seems that a few drivers would also appreciate\n *    nybble swapping support...\n *   = every architecture could add their byteswap macro in asm/byteorder.h\n *    see how some architectures already do (i386, alpha, ppc, etc)\n *   = cpu_to_beXX and beXX_to_cpu might some day need to be well\n *    distinguished throughout the kernel. This is not the case currently,\n *    since little endian, big endian, and pdp endian machines needn't it.\n *    But this might be the case for, say, a port of Linux to 20/21 bit\n *    architectures (and F21 Linux addict around?).\n */\n\n/*\n * The following macros are to be defined by <asm/byteorder.h>:\n *\n * Conversion of long and short int between network and host format\n *\tntohl(__u32 x)\n *\tntohs(__u16 x)\n *\thtonl(__u32 x)\n *\thtons(__u16 x)\n * It seems that some programs (which? where? or perhaps a standard? POSIX?)\n * might like the above to be functions, not macros (why?).\n * if that's true, then detect them, and take measures.\n * Anyway, the measure is: define only ___ntohl as a macro instead,\n * and in a separate file, have\n * unsigned long inline ntohl(x){return ___ntohl(x);}\n *\n * The same for constant arguments\n *\t__constant_ntohl(__u32 x)\n *\t__constant_ntohs(__u16 x)\n *\t__constant_htonl(__u32 x)\n *\t__constant_htons(__u16 x)\n *\n * Conversion of XX-bit integers (16- 32- or 64-)\n * between native CPU format and little/big endian format\n * 64-bit stuff only defined for proper architectures\n *\tcpu_to_[bl]eXX(__uXX x)\n *\t[bl]eXX_to_cpu(__uXX x)\n *\n * The same, but takes a pointer to the value to convert\n *\tcpu_to_[bl]eXXp(__uXX x)\n *\t[bl]eXX_to_cpup(__uXX x)\n *\n * The same, but change in situ\n *\tcpu_to_[bl]eXXs(__uXX x)\n *\t[bl]eXX_to_cpus(__uXX x)\n *\n * See asm-foo/byteorder.h for examples of how to provide\n * architecture-optimized versions\n *\n */\n\n#define cpu_to_le64 __cpu_to_le64\n#define le64_to_cpu __le64_to_cpu\n#define cpu_to_le32 __cpu_to_le32\n#define le32_to_cpu __le32_to_cpu\n#define cpu_to_le16 __cpu_to_le16\n#define le16_to_cpu __le16_to_cpu\n#define cpu_to_be64 __cpu_to_be64\n#define be64_to_cpu __be64_to_cpu\n#define cpu_to_be32 __cpu_to_be32\n#define be32_to_cpu __be32_to_cpu\n#define cpu_to_be16 __cpu_to_be16\n#define be16_to_cpu __be16_to_cpu\n#define cpu_to_le64p __cpu_to_le64p\n#define le64_to_cpup __le64_to_cpup\n#define cpu_to_le32p __cpu_to_le32p\n#define le32_to_cpup __le32_to_cpup\n#define cpu_to_le16p __cpu_to_le16p\n#define le16_to_cpup __le16_to_cpup\n#define cpu_to_be64p __cpu_to_be64p\n#define be64_to_cpup __be64_to_cpup\n#define cpu_to_be32p __cpu_to_be32p\n#define be32_to_cpup __be32_to_cpup\n#define cpu_to_be16p __cpu_to_be16p\n#define be16_to_cpup __be16_to_cpup\n#define cpu_to_le64s __cpu_to_le64s\n#define le64_to_cpus __le64_to_cpus\n#define cpu_to_le32s __cpu_to_le32s\n#define le32_to_cpus __le32_to_cpus\n#define cpu_to_le16s __cpu_to_le16s\n#define le16_to_cpus __le16_to_cpus\n#define cpu_to_be64s __cpu_to_be64s\n#define be64_to_cpus __be64_to_cpus\n#define cpu_to_be32s __cpu_to_be32s\n#define be32_to_cpus __be32_to_cpus\n#define cpu_to_be16s __cpu_to_be16s\n#define be16_to_cpus __be16_to_cpus\n\n/*\n * They have to be macros in order to do the constant folding\n * correctly - if the argument passed into a inline function\n * it is no longer constant according to gcc..\n */\n\n#undef ntohl\n#undef ntohs\n#undef htonl\n#undef htons\n\n#define ___htonl(x) __cpu_to_be32(x)\n#define ___htons(x) __cpu_to_be16(x)\n#define ___ntohl(x) __be32_to_cpu(x)\n#define ___ntohs(x) __be16_to_cpu(x)\n\n#define htonl(x) ___htonl(x)\n#define ntohl(x) ___ntohl(x)\n#define htons(x) ___htons(x)\n#define ntohs(x) ___ntohs(x)\n\nstatic inline void le16_add_cpu(__le16 *var, u16 val)\n{\n\t*var = cpu_to_le16(le16_to_cpu(*var) + val);\n}\n\nstatic inline void le32_add_cpu(__le32 *var, u32 val)\n{\n\t*var = cpu_to_le32(le32_to_cpu(*var) + val);\n}\n\nstatic inline void le64_add_cpu(__le64 *var, u64 val)\n{\n\t*var = cpu_to_le64(le64_to_cpu(*var) + val);\n}\n\n/* XXX: this stuff can be optimized */\nstatic inline void le32_to_cpu_array(u32 *buf, unsigned int words)\n{\n\twhile (words--) {\n\t\t__le32_to_cpus(buf);\n\t\tbuf++;\n\t}\n}\n\nstatic inline void cpu_to_le32_array(u32 *buf, unsigned int words)\n{\n\twhile (words--) {\n\t\t__cpu_to_le32s(buf);\n\t\tbuf++;\n\t}\n}\n\nstatic inline void be16_add_cpu(__be16 *var, u16 val)\n{\n\t*var = cpu_to_be16(be16_to_cpu(*var) + val);\n}\n\nstatic inline void be32_add_cpu(__be32 *var, u32 val)\n{\n\t*var = cpu_to_be32(be32_to_cpu(*var) + val);\n}\n\nstatic inline void be64_add_cpu(__be64 *var, u64 val)\n{\n\t*var = cpu_to_be64(be64_to_cpu(*var) + val);\n}\n\nstatic inline void cpu_to_be32_array(__be32 *dst, const u32 *src, size_t len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdst[i] = cpu_to_be32(src[i]);\n}\n\nstatic inline void be32_to_cpu_array(u32 *dst, const __be32 *src, size_t len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdst[i] = be32_to_cpu(src[i]);\n}\n\n#endif /* _LINUX_BYTEORDER_GENERIC_H */\n"}, "2": {"id": 2, "path": "/src/include/uapi/linux/byteorder/little_endian.h", "content": "/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n#ifndef _UAPI_LINUX_BYTEORDER_LITTLE_ENDIAN_H\n#define _UAPI_LINUX_BYTEORDER_LITTLE_ENDIAN_H\n\n#ifndef __LITTLE_ENDIAN\n#define __LITTLE_ENDIAN 1234\n#endif\n#ifndef __LITTLE_ENDIAN_BITFIELD\n#define __LITTLE_ENDIAN_BITFIELD\n#endif\n\n#include <linux/types.h>\n#include <linux/swab.h>\n\n#define __constant_htonl(x) ((__force __be32)___constant_swab32((x)))\n#define __constant_ntohl(x) ___constant_swab32((__force __be32)(x))\n#define __constant_htons(x) ((__force __be16)___constant_swab16((x)))\n#define __constant_ntohs(x) ___constant_swab16((__force __be16)(x))\n#define __constant_cpu_to_le64(x) ((__force __le64)(__u64)(x))\n#define __constant_le64_to_cpu(x) ((__force __u64)(__le64)(x))\n#define __constant_cpu_to_le32(x) ((__force __le32)(__u32)(x))\n#define __constant_le32_to_cpu(x) ((__force __u32)(__le32)(x))\n#define __constant_cpu_to_le16(x) ((__force __le16)(__u16)(x))\n#define __constant_le16_to_cpu(x) ((__force __u16)(__le16)(x))\n#define __constant_cpu_to_be64(x) ((__force __be64)___constant_swab64((x)))\n#define __constant_be64_to_cpu(x) ___constant_swab64((__force __u64)(__be64)(x))\n#define __constant_cpu_to_be32(x) ((__force __be32)___constant_swab32((x)))\n#define __constant_be32_to_cpu(x) ___constant_swab32((__force __u32)(__be32)(x))\n#define __constant_cpu_to_be16(x) ((__force __be16)___constant_swab16((x)))\n#define __constant_be16_to_cpu(x) ___constant_swab16((__force __u16)(__be16)(x))\n#define __cpu_to_le64(x) ((__force __le64)(__u64)(x))\n#define __le64_to_cpu(x) ((__force __u64)(__le64)(x))\n#define __cpu_to_le32(x) ((__force __le32)(__u32)(x))\n#define __le32_to_cpu(x) ((__force __u32)(__le32)(x))\n#define __cpu_to_le16(x) ((__force __le16)(__u16)(x))\n#define __le16_to_cpu(x) ((__force __u16)(__le16)(x))\n#define __cpu_to_be64(x) ((__force __be64)__swab64((x)))\n#define __be64_to_cpu(x) __swab64((__force __u64)(__be64)(x))\n#define __cpu_to_be32(x) ((__force __be32)__swab32((x)))\n#define __be32_to_cpu(x) __swab32((__force __u32)(__be32)(x))\n#define __cpu_to_be16(x) ((__force __be16)__swab16((x)))\n#define __be16_to_cpu(x) __swab16((__force __u16)(__be16)(x))\n\nstatic __always_inline __le64 __cpu_to_le64p(const __u64 *p)\n{\n\treturn (__force __le64)*p;\n}\nstatic __always_inline __u64 __le64_to_cpup(const __le64 *p)\n{\n\treturn (__force __u64)*p;\n}\nstatic __always_inline __le32 __cpu_to_le32p(const __u32 *p)\n{\n\treturn (__force __le32)*p;\n}\nstatic __always_inline __u32 __le32_to_cpup(const __le32 *p)\n{\n\treturn (__force __u32)*p;\n}\nstatic __always_inline __le16 __cpu_to_le16p(const __u16 *p)\n{\n\treturn (__force __le16)*p;\n}\nstatic __always_inline __u16 __le16_to_cpup(const __le16 *p)\n{\n\treturn (__force __u16)*p;\n}\nstatic __always_inline __be64 __cpu_to_be64p(const __u64 *p)\n{\n\treturn (__force __be64)__swab64p(p);\n}\nstatic __always_inline __u64 __be64_to_cpup(const __be64 *p)\n{\n\treturn __swab64p((__u64 *)p);\n}\nstatic __always_inline __be32 __cpu_to_be32p(const __u32 *p)\n{\n\treturn (__force __be32)__swab32p(p);\n}\nstatic __always_inline __u32 __be32_to_cpup(const __be32 *p)\n{\n\treturn __swab32p((__u32 *)p);\n}\nstatic __always_inline __be16 __cpu_to_be16p(const __u16 *p)\n{\n\treturn (__force __be16)__swab16p(p);\n}\nstatic __always_inline __u16 __be16_to_cpup(const __be16 *p)\n{\n\treturn __swab16p((__u16 *)p);\n}\n#define __cpu_to_le64s(x) do { (void)(x); } while (0)\n#define __le64_to_cpus(x) do { (void)(x); } while (0)\n#define __cpu_to_le32s(x) do { (void)(x); } while (0)\n#define __le32_to_cpus(x) do { (void)(x); } while (0)\n#define __cpu_to_le16s(x) do { (void)(x); } while (0)\n#define __le16_to_cpus(x) do { (void)(x); } while (0)\n#define __cpu_to_be64s(x) __swab64s((x))\n#define __be64_to_cpus(x) __swab64s((x))\n#define __cpu_to_be32s(x) __swab32s((x))\n#define __be32_to_cpus(x) __swab32s((x))\n#define __cpu_to_be16s(x) __swab16s((x))\n#define __be16_to_cpus(x) __swab16s((x))\n\n\n#endif /* _UAPI_LINUX_BYTEORDER_LITTLE_ENDIAN_H */\n"}, "3": {"id": 3, "path": "/src/fs/ext4/ext4_jbd2.h", "content": "// SPDX-License-Identifier: GPL-2.0+\n/*\n * ext4_jbd2.h\n *\n * Written by Stephen C. Tweedie <sct@redhat.com>, 1999\n *\n * Copyright 1998--1999 Red Hat corp --- All Rights Reserved\n *\n * Ext4-specific journaling extensions.\n */\n\n#ifndef _EXT4_JBD2_H\n#define _EXT4_JBD2_H\n\n#include <linux/fs.h>\n#include <linux/jbd2.h>\n#include \"ext4.h\"\n\n#define EXT4_JOURNAL(inode)\t(EXT4_SB((inode)->i_sb)->s_journal)\n\n/* Define the number of blocks we need to account to a transaction to\n * modify one block of data.\n *\n * We may have to touch one inode, one bitmap buffer, up to three\n * indirection blocks, the group and superblock summaries, and the data\n * block to complete the transaction.\n *\n * For extents-enabled fs we may have to allocate and modify up to\n * 5 levels of tree, data block (for each of these we need bitmap + group\n * summaries), root which is stored in the inode, sb\n */\n\n#define EXT4_SINGLEDATA_TRANS_BLOCKS(sb)\t\t\t\t\\\n\t(ext4_has_feature_extents(sb) ? 20U : 8U)\n\n/* Extended attribute operations touch at most two data buffers,\n * two bitmap buffers, and two group summaries, in addition to the inode\n * and the superblock, which are already accounted for. */\n\n#define EXT4_XATTR_TRANS_BLOCKS\t\t6U\n\n/* Define the minimum size for a transaction which modifies data.  This\n * needs to take into account the fact that we may end up modifying two\n * quota files too (one for the group, one for the user quota).  The\n * superblock only gets updated once, of course, so don't bother\n * counting that again for the quota updates. */\n\n#define EXT4_DATA_TRANS_BLOCKS(sb)\t(EXT4_SINGLEDATA_TRANS_BLOCKS(sb) + \\\n\t\t\t\t\t EXT4_XATTR_TRANS_BLOCKS - 2 + \\\n\t\t\t\t\t EXT4_MAXQUOTAS_TRANS_BLOCKS(sb))\n\n/*\n * Define the number of metadata blocks we need to account to modify data.\n *\n * This include super block, inode block, quota blocks and xattr blocks\n */\n#define EXT4_META_TRANS_BLOCKS(sb)\t(EXT4_XATTR_TRANS_BLOCKS + \\\n\t\t\t\t\tEXT4_MAXQUOTAS_TRANS_BLOCKS(sb))\n\n/* Define an arbitrary limit for the amount of data we will anticipate\n * writing to any given transaction.  For unbounded transactions such as\n * write(2) and truncate(2) we can write more than this, but we always\n * start off at the maximum transaction size and grow the transaction\n * optimistically as we go. */\n\n#define EXT4_MAX_TRANS_DATA\t\t64U\n\n/* We break up a large truncate or write transaction once the handle's\n * buffer credits gets this low, we need either to extend the\n * transaction or to start a new one.  Reserve enough space here for\n * inode, bitmap, superblock, group and indirection updates for at least\n * one block, plus two quota updates.  Quota allocations are not\n * needed. */\n\n#define EXT4_RESERVE_TRANS_BLOCKS\t12U\n\n/*\n * Number of credits needed if we need to insert an entry into a\n * directory.  For each new index block, we need 4 blocks (old index\n * block, new index block, bitmap block, bg summary).  For normal\n * htree directories there are 2 levels; if the largedir feature\n * enabled it's 3 levels.\n */\n#define EXT4_INDEX_EXTRA_TRANS_BLOCKS\t12U\n\n#ifdef CONFIG_QUOTA\n/* Amount of blocks needed for quota update - we know that the structure was\n * allocated so we need to update only data block */\n#define EXT4_QUOTA_TRANS_BLOCKS(sb) ((test_opt(sb, QUOTA) ||\\\n\t\text4_has_feature_quota(sb)) ? 1 : 0)\n/* Amount of blocks needed for quota insert/delete - we do some block writes\n * but inode, sb and group updates are done only once */\n#define EXT4_QUOTA_INIT_BLOCKS(sb) ((test_opt(sb, QUOTA) ||\\\n\t\text4_has_feature_quota(sb)) ?\\\n\t\t(DQUOT_INIT_ALLOC*(EXT4_SINGLEDATA_TRANS_BLOCKS(sb)-3)\\\n\t\t +3+DQUOT_INIT_REWRITE) : 0)\n\n#define EXT4_QUOTA_DEL_BLOCKS(sb) ((test_opt(sb, QUOTA) ||\\\n\t\text4_has_feature_quota(sb)) ?\\\n\t\t(DQUOT_DEL_ALLOC*(EXT4_SINGLEDATA_TRANS_BLOCKS(sb)-3)\\\n\t\t +3+DQUOT_DEL_REWRITE) : 0)\n#else\n#define EXT4_QUOTA_TRANS_BLOCKS(sb) 0\n#define EXT4_QUOTA_INIT_BLOCKS(sb) 0\n#define EXT4_QUOTA_DEL_BLOCKS(sb) 0\n#endif\n#define EXT4_MAXQUOTAS_TRANS_BLOCKS(sb) (EXT4_MAXQUOTAS*EXT4_QUOTA_TRANS_BLOCKS(sb))\n#define EXT4_MAXQUOTAS_INIT_BLOCKS(sb) (EXT4_MAXQUOTAS*EXT4_QUOTA_INIT_BLOCKS(sb))\n#define EXT4_MAXQUOTAS_DEL_BLOCKS(sb) (EXT4_MAXQUOTAS*EXT4_QUOTA_DEL_BLOCKS(sb))\n\n/*\n * Ext4 handle operation types -- for logging purposes\n */\n#define EXT4_HT_MISC             0\n#define EXT4_HT_INODE            1\n#define EXT4_HT_WRITE_PAGE       2\n#define EXT4_HT_MAP_BLOCKS       3\n#define EXT4_HT_DIR              4\n#define EXT4_HT_TRUNCATE         5\n#define EXT4_HT_QUOTA            6\n#define EXT4_HT_RESIZE           7\n#define EXT4_HT_MIGRATE          8\n#define EXT4_HT_MOVE_EXTENTS     9\n#define EXT4_HT_XATTR           10\n#define EXT4_HT_EXT_CONVERT     11\n#define EXT4_HT_MAX             12\n\n/**\n *   struct ext4_journal_cb_entry - Base structure for callback information.\n *\n *   This struct is a 'seed' structure for a using with your own callback\n *   structs. If you are using callbacks you must allocate one of these\n *   or another struct of your own definition which has this struct\n *   as it's first element and pass it to ext4_journal_callback_add().\n */\nstruct ext4_journal_cb_entry {\n\t/* list information for other callbacks attached to the same handle */\n\tstruct list_head jce_list;\n\n\t/*  Function to call with this callback structure */\n\tvoid (*jce_func)(struct super_block *sb,\n\t\t\t struct ext4_journal_cb_entry *jce, int error);\n\n\t/* user data goes here */\n};\n\n/**\n * ext4_journal_callback_add: add a function to call after transaction commit\n * @handle: active journal transaction handle to register callback on\n * @func: callback function to call after the transaction has committed:\n *        @sb: superblock of current filesystem for transaction\n *        @jce: returned journal callback data\n *        @rc: journal state at commit (0 = transaction committed properly)\n * @jce: journal callback data (internal and function private data struct)\n *\n * The registered function will be called in the context of the journal thread\n * after the transaction for which the handle was created has completed.\n *\n * No locks are held when the callback function is called, so it is safe to\n * call blocking functions from within the callback, but the callback should\n * not block or run for too long, or the filesystem will be blocked waiting for\n * the next transaction to commit. No journaling functions can be used, or\n * there is a risk of deadlock.\n *\n * There is no guaranteed calling order of multiple registered callbacks on\n * the same transaction.\n */\nstatic inline void _ext4_journal_callback_add(handle_t *handle,\n\t\t\tstruct ext4_journal_cb_entry *jce)\n{\n\t/* Add the jce to transaction's private list */\n\tlist_add_tail(&jce->jce_list, &handle->h_transaction->t_private_list);\n}\n\nstatic inline void ext4_journal_callback_add(handle_t *handle,\n\t\t\tvoid (*func)(struct super_block *sb,\n\t\t\t\t     struct ext4_journal_cb_entry *jce,\n\t\t\t\t     int rc),\n\t\t\tstruct ext4_journal_cb_entry *jce)\n{\n\tstruct ext4_sb_info *sbi =\n\t\t\tEXT4_SB(handle->h_transaction->t_journal->j_private);\n\n\t/* Add the jce to transaction's private list */\n\tjce->jce_func = func;\n\tspin_lock(&sbi->s_md_lock);\n\t_ext4_journal_callback_add(handle, jce);\n\tspin_unlock(&sbi->s_md_lock);\n}\n\n\n/**\n * ext4_journal_callback_del: delete a registered callback\n * @handle: active journal transaction handle on which callback was registered\n * @jce: registered journal callback entry to unregister\n * Return true if object was successfully removed\n */\nstatic inline bool ext4_journal_callback_try_del(handle_t *handle,\n\t\t\t\t\t     struct ext4_journal_cb_entry *jce)\n{\n\tbool deleted;\n\tstruct ext4_sb_info *sbi =\n\t\t\tEXT4_SB(handle->h_transaction->t_journal->j_private);\n\n\tspin_lock(&sbi->s_md_lock);\n\tdeleted = !list_empty(&jce->jce_list);\n\tlist_del_init(&jce->jce_list);\n\tspin_unlock(&sbi->s_md_lock);\n\treturn deleted;\n}\n\nint\next4_mark_iloc_dirty(handle_t *handle,\n\t\t     struct inode *inode,\n\t\t     struct ext4_iloc *iloc);\n\n/*\n * On success, We end up with an outstanding reference count against\n * iloc->bh.  This _must_ be cleaned up later.\n */\n\nint ext4_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_iloc *iloc);\n\n#define ext4_mark_inode_dirty(__h, __i)\t\t\t\t\t\\\n\t\t__ext4_mark_inode_dirty((__h), (__i), __func__, __LINE__)\nint __ext4_mark_inode_dirty(handle_t *handle, struct inode *inode,\n\t\t\t\tconst char *func, unsigned int line);\n\nint ext4_expand_extra_isize(struct inode *inode,\n\t\t\t    unsigned int new_extra_isize,\n\t\t\t    struct ext4_iloc *iloc);\n/*\n * Wrapper functions with which ext4 calls into JBD.\n */\nint __ext4_journal_get_write_access(const char *where, unsigned int line,\n\t\t\t\t    handle_t *handle, struct buffer_head *bh);\n\nint __ext4_forget(const char *where, unsigned int line, handle_t *handle,\n\t\t  int is_metadata, struct inode *inode,\n\t\t  struct buffer_head *bh, ext4_fsblk_t blocknr);\n\nint __ext4_journal_get_create_access(const char *where, unsigned int line,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\nint __ext4_handle_dirty_metadata(const char *where, unsigned int line,\n\t\t\t\t handle_t *handle, struct inode *inode,\n\t\t\t\t struct buffer_head *bh);\n\nint __ext4_handle_dirty_super(const char *where, unsigned int line,\n\t\t\t      handle_t *handle, struct super_block *sb);\n\n#define ext4_journal_get_write_access(handle, bh) \\\n\t__ext4_journal_get_write_access(__func__, __LINE__, (handle), (bh))\n#define ext4_forget(handle, is_metadata, inode, bh, block_nr) \\\n\t__ext4_forget(__func__, __LINE__, (handle), (is_metadata), (inode), \\\n\t\t      (bh), (block_nr))\n#define ext4_journal_get_create_access(handle, bh) \\\n\t__ext4_journal_get_create_access(__func__, __LINE__, (handle), (bh))\n#define ext4_handle_dirty_metadata(handle, inode, bh) \\\n\t__ext4_handle_dirty_metadata(__func__, __LINE__, (handle), (inode), \\\n\t\t\t\t     (bh))\n#define ext4_handle_dirty_super(handle, sb) \\\n\t__ext4_handle_dirty_super(__func__, __LINE__, (handle), (sb))\n\nhandle_t *__ext4_journal_start_sb(struct super_block *sb, unsigned int line,\n\t\t\t\t  int type, int blocks, int rsv_blocks,\n\t\t\t\t  int revoke_creds);\nint __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle);\n\n#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)\n\n/* Note:  Do not use this for NULL handles.  This is only to determine if\n * a properly allocated handle is using a journal or not. */\nstatic inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}\n\nstatic inline int ext4_handle_is_aborted(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn is_handle_aborted(handle);\n\treturn 0;\n}\n\nstatic inline int ext4_free_metadata_revoke_credits(struct super_block *sb,\n\t\t\t\t\t\t    int blocks)\n{\n\t/* Freeing each metadata block can result in freeing one cluster */\n\treturn blocks * EXT4_SB(sb)->s_cluster_ratio;\n}\n\nstatic inline int ext4_trans_default_revoke_credits(struct super_block *sb)\n{\n\treturn ext4_free_metadata_revoke_credits(sb, 8);\n}\n\n#define ext4_journal_start_sb(sb, type, nblocks)\t\t\t\\\n\t__ext4_journal_start_sb((sb), __LINE__, (type), (nblocks), 0,\t\\\n\t\t\t\text4_trans_default_revoke_credits(sb))\n\n#define ext4_journal_start(inode, type, nblocks)\t\t\t\\\n\t__ext4_journal_start((inode), __LINE__, (type), (nblocks), 0,\t\\\n\t\t\t     ext4_trans_default_revoke_credits((inode)->i_sb))\n\n#define ext4_journal_start_with_reserve(inode, type, blocks, rsv_blocks)\\\n\t__ext4_journal_start((inode), __LINE__, (type), (blocks), (rsv_blocks),\\\n\t\t\t     ext4_trans_default_revoke_credits((inode)->i_sb))\n\n#define ext4_journal_start_with_revoke(inode, type, blocks, revoke_creds) \\\n\t__ext4_journal_start((inode), __LINE__, (type), (blocks), 0,\t\\\n\t\t\t     (revoke_creds))\n\nstatic inline handle_t *__ext4_journal_start(struct inode *inode,\n\t\t\t\t\t     unsigned int line, int type,\n\t\t\t\t\t     int blocks, int rsv_blocks,\n\t\t\t\t\t     int revoke_creds)\n{\n\treturn __ext4_journal_start_sb(inode->i_sb, line, type, blocks,\n\t\t\t\t       rsv_blocks, revoke_creds);\n}\n\n#define ext4_journal_stop(handle) \\\n\t__ext4_journal_stop(__func__, __LINE__, (handle))\n\n#define ext4_journal_start_reserved(handle, type) \\\n\t__ext4_journal_start_reserved((handle), __LINE__, (type))\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type);\n\nstatic inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}\n\nstatic inline int ext4_journal_extend(handle_t *handle, int nblocks, int revoke)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_extend(handle, nblocks, revoke);\n\treturn 0;\n}\n\nstatic inline int ext4_journal_restart(handle_t *handle, int nblocks,\n\t\t\t\t       int revoke)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2__journal_restart(handle, nblocks, revoke, GFP_NOFS);\n\treturn 0;\n}\n\nint __ext4_journal_ensure_credits(handle_t *handle, int check_cred,\n\t\t\t\t  int extend_cred, int revoke_cred);\n\n\n/*\n * Ensure @handle has at least @check_creds credits available. If not,\n * transaction will be extended or restarted to contain at least @extend_cred\n * credits. Before restarting transaction @fn is executed to allow for cleanup\n * before the transaction is restarted.\n *\n * The return value is < 0 in case of error, 0 in case the handle has enough\n * credits or transaction extension succeeded, 1 in case transaction had to be\n * restarted.\n */\n#define ext4_journal_ensure_credits_fn(handle, check_cred, extend_cred,\t\\\n\t\t\t\t       revoke_cred, fn) \\\n({\t\t\t\t\t\t\t\t\t\\\n\t__label__ __ensure_end;\t\t\t\t\t\t\\\n\tint err = __ext4_journal_ensure_credits((handle), (check_cred),\t\\\n\t\t\t\t\t(extend_cred), (revoke_cred));\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (err <= 0)\t\t\t\t\t\t\t\\\n\t\tgoto __ensure_end;\t\t\t\t\t\\\n\terr = (fn);\t\t\t\t\t\t\t\\\n\tif (err < 0)\t\t\t\t\t\t\t\\\n\t\tgoto __ensure_end;\t\t\t\t\t\\\n\terr = ext4_journal_restart((handle), (extend_cred), (revoke_cred)); \\\n\tif (err == 0)\t\t\t\t\t\t\t\\\n\t\terr = 1;\t\t\t\t\t\t\\\n__ensure_end:\t\t\t\t\t\t\t\t\\\n\terr;\t\t\t\t\t\t\t\t\\\n})\n\n/*\n * Ensure given handle has at least requested amount of credits available,\n * possibly restarting transaction if needed. We also make sure the transaction\n * has space for at least ext4_trans_default_revoke_credits(sb) revoke records\n * as freeing one or two blocks is very common pattern and requesting this is\n * very cheap.\n */\nstatic inline int ext4_journal_ensure_credits(handle_t *handle, int credits,\n\t\t\t\t\t      int revoke_creds)\n{\n\treturn ext4_journal_ensure_credits_fn(handle, credits, credits,\n\t\t\t\trevoke_creds, 0);\n}\n\nstatic inline int ext4_journal_blocks_per_page(struct inode *inode)\n{\n\tif (EXT4_JOURNAL(inode) != NULL)\n\t\treturn jbd2_journal_blocks_per_page(inode);\n\treturn 0;\n}\n\nstatic inline int ext4_journal_force_commit(journal_t *journal)\n{\n\tif (journal)\n\t\treturn jbd2_journal_force_commit(journal);\n\treturn 0;\n}\n\nstatic inline int ext4_jbd2_inode_add_write(handle_t *handle,\n\t\tstruct inode *inode, loff_t start_byte, loff_t length)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_inode_ranged_write(handle,\n\t\t\t\tEXT4_I(inode)->jinode, start_byte, length);\n\treturn 0;\n}\n\nstatic inline int ext4_jbd2_inode_add_wait(handle_t *handle,\n\t\tstruct inode *inode, loff_t start_byte, loff_t length)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_inode_ranged_wait(handle,\n\t\t\t\tEXT4_I(inode)->jinode, start_byte, length);\n\treturn 0;\n}\n\nstatic inline void ext4_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int datasync)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (ext4_handle_valid(handle) && !is_handle_aborted(handle)) {\n\t\tei->i_sync_tid = handle->h_transaction->t_tid;\n\t\tif (datasync)\n\t\t\tei->i_datasync_tid = handle->h_transaction->t_tid;\n\t}\n}\n\n/* super.c */\nint ext4_force_commit(struct super_block *sb);\n\n/*\n * Ext4 inode journal modes\n */\n#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */\n#define EXT4_INODE_ORDERED_DATA_MODE\t0x02 /* ordered data mode */\n#define EXT4_INODE_WRITEBACK_DATA_MODE\t0x04 /* writeback data mode */\n\nint ext4_inode_journal_mode(struct inode *inode);\n\nstatic inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}\n\nstatic inline int ext4_should_order_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_ORDERED_DATA_MODE;\n}\n\nstatic inline int ext4_should_writeback_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_WRITEBACK_DATA_MODE;\n}\n\nstatic inline int ext4_free_data_revoke_credits(struct inode *inode, int blocks)\n{\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\treturn 0;\n\tif (!ext4_should_journal_data(inode))\n\t\treturn 0;\n\t/*\n\t * Data blocks in one extent are contiguous, just account for partial\n\t * clusters at extent boundaries\n\t */\n\treturn blocks + 2*(EXT4_SB(inode->i_sb)->s_cluster_ratio - 1);\n}\n\n/*\n * This function controls whether or not we should try to go down the\n * dioread_nolock code paths, which makes it safe to avoid taking\n * i_mutex for direct I/O reads.  This only works for extent-based\n * files, and it doesn't work if data journaling is enabled, since the\n * dioread_nolock code uses b_private to pass information back to the\n * I/O completion handler, and this conflicts with the jbd's use of\n * b_private.\n */\nstatic inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\t/* temporary fix to prevent generic/422 test failures */\n\tif (!test_opt(inode->i_sb, DELALLOC))\n\t\treturn 0;\n\treturn 1;\n}\n\n#endif\t/* _EXT4_JBD2_H */\n"}, "4": {"id": 4, "path": "/src/fs/ext4/ext4.h", "content": "// SPDX-License-Identifier: GPL-2.0\n/*\n *  ext4.h\n *\n * Copyright (C) 1992, 1993, 1994, 1995\n * Remy Card (card@masi.ibp.fr)\n * Laboratoire MASI - Institut Blaise Pascal\n * Universite Pierre et Marie Curie (Paris VI)\n *\n *  from\n *\n *  linux/include/linux/minix_fs.h\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n#ifndef _EXT4_H\n#define _EXT4_H\n\n#include <linux/types.h>\n#include <linux/blkdev.h>\n#include <linux/magic.h>\n#include <linux/jbd2.h>\n#include <linux/quota.h>\n#include <linux/rwsem.h>\n#include <linux/rbtree.h>\n#include <linux/seqlock.h>\n#include <linux/mutex.h>\n#include <linux/timer.h>\n#include <linux/wait.h>\n#include <linux/sched/signal.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <crypto/hash.h>\n#include <linux/falloc.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/fiemap.h>\n#ifdef __KERNEL__\n#include <linux/compat.h>\n#endif\n\n#include <linux/fscrypt.h>\n#include <linux/fsverity.h>\n\n#include <linux/compiler.h>\n\n/*\n * The fourth extended filesystem constants/structures\n */\n\n/*\n * with AGGRESSIVE_CHECK allocator runs consistency checks over\n * structures. these checks slow things down a lot\n */\n#define AGGRESSIVE_CHECK__\n\n/*\n * with DOUBLE_CHECK defined mballoc creates persistent in-core\n * bitmaps, maintains and uses them to check for double allocations\n */\n#define DOUBLE_CHECK__\n\n/*\n * Define EXT4FS_DEBUG to produce debug messages\n */\n#undef EXT4FS_DEBUG\n\n/*\n * Debug code\n */\n#ifdef EXT4FS_DEBUG\n#define ext4_debug(f, a...)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"EXT4-fs DEBUG (%s, %d): %s:\",\t\\\n\t\t\t__FILE__, __LINE__, __func__);\t\t\t\\\n\t\tprintk(KERN_DEBUG f, ## a);\t\t\t\t\\\n\t} while (0)\n#else\n#define ext4_debug(fmt, ...)\tno_printk(fmt, ##__VA_ARGS__)\n#endif\n\n /*\n  * Turn on EXT_DEBUG to enable ext4_ext_show_path/leaf/move in extents.c\n  */\n#define EXT_DEBUG__\n\n/*\n * Dynamic printk for controlled extents debugging.\n */\n#ifdef CONFIG_EXT4_DEBUG\n#define ext_debug(ino, fmt, ...)\t\t\t\t\t\\\n\tpr_debug(\"[%s/%d] EXT4-fs (%s): ino %lu: (%s, %d): %s:\" fmt,\t\\\n\t\t current->comm, task_pid_nr(current),\t\t\t\\\n\t\t ino->i_sb->s_id, ino->i_ino, __FILE__, __LINE__,\t\\\n\t\t __func__, ##__VA_ARGS__)\n#else\n#define ext_debug(ino, fmt, ...)\tno_printk(fmt, ##__VA_ARGS__)\n#endif\n\n/* data type for block offset of block group */\ntypedef int ext4_grpblk_t;\n\n/* data type for filesystem-wide blocks number */\ntypedef unsigned long long ext4_fsblk_t;\n\n/* data type for file logical block number */\ntypedef __u32 ext4_lblk_t;\n\n/* data type for block group number */\ntypedef unsigned int ext4_group_t;\n\nenum SHIFT_DIRECTION {\n\tSHIFT_LEFT = 0,\n\tSHIFT_RIGHT,\n};\n\n/*\n * Flags used in mballoc's allocation_context flags field.\n *\n * Also used to show what's going on for debugging purposes when the\n * flag field is exported via the traceport interface\n */\n\n/* prefer goal again. length */\n#define EXT4_MB_HINT_MERGE\t\t0x0001\n/* blocks already reserved */\n#define EXT4_MB_HINT_RESERVED\t\t0x0002\n/* metadata is being allocated */\n#define EXT4_MB_HINT_METADATA\t\t0x0004\n/* first blocks in the file */\n#define EXT4_MB_HINT_FIRST\t\t0x0008\n/* search for the best chunk */\n#define EXT4_MB_HINT_BEST\t\t0x0010\n/* data is being allocated */\n#define EXT4_MB_HINT_DATA\t\t0x0020\n/* don't preallocate (for tails) */\n#define EXT4_MB_HINT_NOPREALLOC\t\t0x0040\n/* allocate for locality group */\n#define EXT4_MB_HINT_GROUP_ALLOC\t0x0080\n/* allocate goal blocks or none */\n#define EXT4_MB_HINT_GOAL_ONLY\t\t0x0100\n/* goal is meaningful */\n#define EXT4_MB_HINT_TRY_GOAL\t\t0x0200\n/* blocks already pre-reserved by delayed allocation */\n#define EXT4_MB_DELALLOC_RESERVED\t0x0400\n/* We are doing stream allocation */\n#define EXT4_MB_STREAM_ALLOC\t\t0x0800\n/* Use reserved root blocks if needed */\n#define EXT4_MB_USE_ROOT_BLOCKS\t\t0x1000\n/* Use blocks from reserved pool */\n#define EXT4_MB_USE_RESERVED\t\t0x2000\n/* Do strict check for free blocks while retrying block allocation */\n#define EXT4_MB_STRICT_CHECK\t\t0x4000\n\nstruct ext4_allocation_request {\n\t/* target inode for block we're allocating */\n\tstruct inode *inode;\n\t/* how many blocks we want to allocate */\n\tunsigned int len;\n\t/* logical block in target inode */\n\text4_lblk_t logical;\n\t/* the closest logical allocated block to the left */\n\text4_lblk_t lleft;\n\t/* the closest logical allocated block to the right */\n\text4_lblk_t lright;\n\t/* phys. target (a hint) */\n\text4_fsblk_t goal;\n\t/* phys. block for the closest logical allocated block to the left */\n\text4_fsblk_t pleft;\n\t/* phys. block for the closest logical allocated block to the right */\n\text4_fsblk_t pright;\n\t/* flags. see above EXT4_MB_HINT_* */\n\tunsigned int flags;\n};\n\n/*\n * Logical to physical block mapping, used by ext4_map_blocks()\n *\n * This structure is used to pass requests into ext4_map_blocks() as\n * well as to store the information returned by ext4_map_blocks().  It\n * takes less room on the stack than a struct buffer_head.\n */\n#define EXT4_MAP_NEW\t\tBIT(BH_New)\n#define EXT4_MAP_MAPPED\t\tBIT(BH_Mapped)\n#define EXT4_MAP_UNWRITTEN\tBIT(BH_Unwritten)\n#define EXT4_MAP_BOUNDARY\tBIT(BH_Boundary)\n#define EXT4_MAP_FLAGS\t\t(EXT4_MAP_NEW | EXT4_MAP_MAPPED |\\\n\t\t\t\t EXT4_MAP_UNWRITTEN | EXT4_MAP_BOUNDARY)\n\nstruct ext4_map_blocks {\n\text4_fsblk_t m_pblk;\n\text4_lblk_t m_lblk;\n\tunsigned int m_len;\n\tunsigned int m_flags;\n};\n\n/*\n * Block validity checking, system zone rbtree.\n */\nstruct ext4_system_blocks {\n\tstruct rb_root root;\n\tstruct rcu_head rcu;\n};\n\n/*\n * Flags for ext4_io_end->flags\n */\n#define\tEXT4_IO_END_UNWRITTEN\t0x0001\n\nstruct ext4_io_end_vec {\n\tstruct list_head list;\t\t/* list of io_end_vec */\n\tloff_t offset;\t\t\t/* offset in the file */\n\tssize_t size;\t\t\t/* size of the extent */\n};\n\n/*\n * For converting unwritten extents on a work queue. 'handle' is used for\n * buffered writeback.\n */\ntypedef struct ext4_io_end {\n\tstruct list_head\tlist;\t\t/* per-file finished IO list */\n\thandle_t\t\t*handle;\t/* handle reserved for extent\n\t\t\t\t\t\t * conversion */\n\tstruct inode\t\t*inode;\t\t/* file being written to */\n\tstruct bio\t\t*bio;\t\t/* Linked list of completed\n\t\t\t\t\t\t * bios covering the extent */\n\tunsigned int\t\tflag;\t\t/* unwritten or not */\n\tatomic_t\t\tcount;\t\t/* reference counter */\n\tstruct list_head\tlist_vec;\t/* list of ext4_io_end_vec */\n} ext4_io_end_t;\n\nstruct ext4_io_submit {\n\tstruct writeback_control *io_wbc;\n\tstruct bio\t\t*io_bio;\n\text4_io_end_t\t\t*io_end;\n\tsector_t\t\tio_next_block;\n};\n\n/*\n * Special inodes numbers\n */\n#define\tEXT4_BAD_INO\t\t 1\t/* Bad blocks inode */\n#define EXT4_ROOT_INO\t\t 2\t/* Root inode */\n#define EXT4_USR_QUOTA_INO\t 3\t/* User quota inode */\n#define EXT4_GRP_QUOTA_INO\t 4\t/* Group quota inode */\n#define EXT4_BOOT_LOADER_INO\t 5\t/* Boot loader inode */\n#define EXT4_UNDEL_DIR_INO\t 6\t/* Undelete directory inode */\n#define EXT4_RESIZE_INO\t\t 7\t/* Reserved group descriptors inode */\n#define EXT4_JOURNAL_INO\t 8\t/* Journal inode */\n\n/* First non-reserved inode for old ext4 filesystems */\n#define EXT4_GOOD_OLD_FIRST_INO\t11\n\n/*\n * Maximal count of links to a file\n */\n#define EXT4_LINK_MAX\t\t65000\n\n/*\n * Macro-instructions used to manage several block sizes\n */\n#define EXT4_MIN_BLOCK_SIZE\t\t1024\n#define\tEXT4_MAX_BLOCK_SIZE\t\t65536\n#define EXT4_MIN_BLOCK_LOG_SIZE\t\t10\n#define EXT4_MAX_BLOCK_LOG_SIZE\t\t16\n#define EXT4_MAX_CLUSTER_LOG_SIZE\t30\n#ifdef __KERNEL__\n# define EXT4_BLOCK_SIZE(s)\t\t((s)->s_blocksize)\n#else\n# define EXT4_BLOCK_SIZE(s)\t\t(EXT4_MIN_BLOCK_SIZE << (s)->s_log_block_size)\n#endif\n#define\tEXT4_ADDR_PER_BLOCK(s)\t\t(EXT4_BLOCK_SIZE(s) / sizeof(__u32))\n#define EXT4_CLUSTER_SIZE(s)\t\t(EXT4_BLOCK_SIZE(s) << \\\n\t\t\t\t\t EXT4_SB(s)->s_cluster_bits)\n#ifdef __KERNEL__\n# define EXT4_BLOCK_SIZE_BITS(s)\t((s)->s_blocksize_bits)\n# define EXT4_CLUSTER_BITS(s)\t\t(EXT4_SB(s)->s_cluster_bits)\n#else\n# define EXT4_BLOCK_SIZE_BITS(s)\t((s)->s_log_block_size + 10)\n#endif\n#ifdef __KERNEL__\n#define\tEXT4_ADDR_PER_BLOCK_BITS(s)\t(EXT4_SB(s)->s_addr_per_block_bits)\n#define EXT4_INODE_SIZE(s)\t\t(EXT4_SB(s)->s_inode_size)\n#define EXT4_FIRST_INO(s)\t\t(EXT4_SB(s)->s_first_ino)\n#else\n#define EXT4_INODE_SIZE(s)\t(((s)->s_rev_level == EXT4_GOOD_OLD_REV) ? \\\n\t\t\t\t EXT4_GOOD_OLD_INODE_SIZE : \\\n\t\t\t\t (s)->s_inode_size)\n#define EXT4_FIRST_INO(s)\t(((s)->s_rev_level == EXT4_GOOD_OLD_REV) ? \\\n\t\t\t\t EXT4_GOOD_OLD_FIRST_INO : \\\n\t\t\t\t (s)->s_first_ino)\n#endif\n#define EXT4_BLOCK_ALIGN(size, blkbits)\t\tALIGN((size), (1 << (blkbits)))\n#define EXT4_MAX_BLOCKS(size, offset, blkbits) \\\n\t((EXT4_BLOCK_ALIGN(size + offset, blkbits) >> blkbits) - (offset >> \\\n\t\t\t\t\t\t\t\t  blkbits))\n\n/* Translate a block number to a cluster number */\n#define EXT4_B2C(sbi, blk)\t((blk) >> (sbi)->s_cluster_bits)\n/* Translate a cluster number to a block number */\n#define EXT4_C2B(sbi, cluster)\t((cluster) << (sbi)->s_cluster_bits)\n/* Translate # of blks to # of clusters */\n#define EXT4_NUM_B2C(sbi, blks)\t(((blks) + (sbi)->s_cluster_ratio - 1) >> \\\n\t\t\t\t (sbi)->s_cluster_bits)\n/* Mask out the low bits to get the starting block of the cluster */\n#define EXT4_PBLK_CMASK(s, pblk) ((pblk) &\t\t\t\t\\\n\t\t\t\t  ~((ext4_fsblk_t) (s)->s_cluster_ratio - 1))\n#define EXT4_LBLK_CMASK(s, lblk) ((lblk) &\t\t\t\t\\\n\t\t\t\t  ~((ext4_lblk_t) (s)->s_cluster_ratio - 1))\n/* Fill in the low bits to get the last block of the cluster */\n#define EXT4_LBLK_CFILL(sbi, lblk) ((lblk) |\t\t\t\t\\\n\t\t\t\t    ((ext4_lblk_t) (sbi)->s_cluster_ratio - 1))\n/* Get the cluster offset */\n#define EXT4_PBLK_COFF(s, pblk) ((pblk) &\t\t\t\t\\\n\t\t\t\t ((ext4_fsblk_t) (s)->s_cluster_ratio - 1))\n#define EXT4_LBLK_COFF(s, lblk) ((lblk) &\t\t\t\t\\\n\t\t\t\t ((ext4_lblk_t) (s)->s_cluster_ratio - 1))\n\n/*\n * Structure of a blocks group descriptor\n */\nstruct ext4_group_desc\n{\n\t__le32\tbg_block_bitmap_lo;\t/* Blocks bitmap block */\n\t__le32\tbg_inode_bitmap_lo;\t/* Inodes bitmap block */\n\t__le32\tbg_inode_table_lo;\t/* Inodes table block */\n\t__le16\tbg_free_blocks_count_lo;/* Free blocks count */\n\t__le16\tbg_free_inodes_count_lo;/* Free inodes count */\n\t__le16\tbg_used_dirs_count_lo;\t/* Directories count */\n\t__le16\tbg_flags;\t\t/* EXT4_BG_flags (INODE_UNINIT, etc) */\n\t__le32  bg_exclude_bitmap_lo;   /* Exclude bitmap for snapshots */\n\t__le16  bg_block_bitmap_csum_lo;/* crc32c(s_uuid+grp_num+bbitmap) LE */\n\t__le16  bg_inode_bitmap_csum_lo;/* crc32c(s_uuid+grp_num+ibitmap) LE */\n\t__le16  bg_itable_unused_lo;\t/* Unused inodes count */\n\t__le16  bg_checksum;\t\t/* crc16(sb_uuid+group+desc) */\n\t__le32\tbg_block_bitmap_hi;\t/* Blocks bitmap block MSB */\n\t__le32\tbg_inode_bitmap_hi;\t/* Inodes bitmap block MSB */\n\t__le32\tbg_inode_table_hi;\t/* Inodes table block MSB */\n\t__le16\tbg_free_blocks_count_hi;/* Free blocks count MSB */\n\t__le16\tbg_free_inodes_count_hi;/* Free inodes count MSB */\n\t__le16\tbg_used_dirs_count_hi;\t/* Directories count MSB */\n\t__le16  bg_itable_unused_hi;    /* Unused inodes count MSB */\n\t__le32  bg_exclude_bitmap_hi;   /* Exclude bitmap block MSB */\n\t__le16  bg_block_bitmap_csum_hi;/* crc32c(s_uuid+grp_num+bbitmap) BE */\n\t__le16  bg_inode_bitmap_csum_hi;/* crc32c(s_uuid+grp_num+ibitmap) BE */\n\t__u32   bg_reserved;\n};\n\n#define EXT4_BG_INODE_BITMAP_CSUM_HI_END\t\\\n\t(offsetof(struct ext4_group_desc, bg_inode_bitmap_csum_hi) + \\\n\t sizeof(__le16))\n#define EXT4_BG_BLOCK_BITMAP_CSUM_HI_END\t\\\n\t(offsetof(struct ext4_group_desc, bg_block_bitmap_csum_hi) + \\\n\t sizeof(__le16))\n\n/*\n * Structure of a flex block group info\n */\n\nstruct flex_groups {\n\tatomic64_t\tfree_clusters;\n\tatomic_t\tfree_inodes;\n\tatomic_t\tused_dirs;\n};\n\n#define EXT4_BG_INODE_UNINIT\t0x0001 /* Inode table/bitmap not in use */\n#define EXT4_BG_BLOCK_UNINIT\t0x0002 /* Block bitmap not in use */\n#define EXT4_BG_INODE_ZEROED\t0x0004 /* On-disk itable initialized to zero */\n\n/*\n * Macro-instructions used to manage group descriptors\n */\n#define EXT4_MIN_DESC_SIZE\t\t32\n#define EXT4_MIN_DESC_SIZE_64BIT\t64\n#define\tEXT4_MAX_DESC_SIZE\t\tEXT4_MIN_BLOCK_SIZE\n#define EXT4_DESC_SIZE(s)\t\t(EXT4_SB(s)->s_desc_size)\n#ifdef __KERNEL__\n# define EXT4_BLOCKS_PER_GROUP(s)\t(EXT4_SB(s)->s_blocks_per_group)\n# define EXT4_CLUSTERS_PER_GROUP(s)\t(EXT4_SB(s)->s_clusters_per_group)\n# define EXT4_DESC_PER_BLOCK(s)\t\t(EXT4_SB(s)->s_desc_per_block)\n# define EXT4_INODES_PER_GROUP(s)\t(EXT4_SB(s)->s_inodes_per_group)\n# define EXT4_DESC_PER_BLOCK_BITS(s)\t(EXT4_SB(s)->s_desc_per_block_bits)\n#else\n# define EXT4_BLOCKS_PER_GROUP(s)\t((s)->s_blocks_per_group)\n# define EXT4_DESC_PER_BLOCK(s)\t\t(EXT4_BLOCK_SIZE(s) / EXT4_DESC_SIZE(s))\n# define EXT4_INODES_PER_GROUP(s)\t((s)->s_inodes_per_group)\n#endif\n\n/*\n * Constants relative to the data blocks\n */\n#define\tEXT4_NDIR_BLOCKS\t\t12\n#define\tEXT4_IND_BLOCK\t\t\tEXT4_NDIR_BLOCKS\n#define\tEXT4_DIND_BLOCK\t\t\t(EXT4_IND_BLOCK + 1)\n#define\tEXT4_TIND_BLOCK\t\t\t(EXT4_DIND_BLOCK + 1)\n#define\tEXT4_N_BLOCKS\t\t\t(EXT4_TIND_BLOCK + 1)\n\n/*\n * Inode flags\n */\n#define\tEXT4_SECRM_FL\t\t\t0x00000001 /* Secure deletion */\n#define\tEXT4_UNRM_FL\t\t\t0x00000002 /* Undelete */\n#define\tEXT4_COMPR_FL\t\t\t0x00000004 /* Compress file */\n#define EXT4_SYNC_FL\t\t\t0x00000008 /* Synchronous updates */\n#define EXT4_IMMUTABLE_FL\t\t0x00000010 /* Immutable file */\n#define EXT4_APPEND_FL\t\t\t0x00000020 /* writes to file may only append */\n#define EXT4_NODUMP_FL\t\t\t0x00000040 /* do not dump file */\n#define EXT4_NOATIME_FL\t\t\t0x00000080 /* do not update atime */\n/* Reserved for compression usage... */\n#define EXT4_DIRTY_FL\t\t\t0x00000100\n#define EXT4_COMPRBLK_FL\t\t0x00000200 /* One or more compressed clusters */\n#define EXT4_NOCOMPR_FL\t\t\t0x00000400 /* Don't compress */\n\t/* nb: was previously EXT2_ECOMPR_FL */\n#define EXT4_ENCRYPT_FL\t\t\t0x00000800 /* encrypted file */\n/* End compression flags --- maybe not all used */\n#define EXT4_INDEX_FL\t\t\t0x00001000 /* hash-indexed directory */\n#define EXT4_IMAGIC_FL\t\t\t0x00002000 /* AFS directory */\n#define EXT4_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */\n#define EXT4_NOTAIL_FL\t\t\t0x00008000 /* file tail should not be merged */\n#define EXT4_DIRSYNC_FL\t\t\t0x00010000 /* dirsync behaviour (directories only) */\n#define EXT4_TOPDIR_FL\t\t\t0x00020000 /* Top of directory hierarchies*/\n#define EXT4_HUGE_FILE_FL               0x00040000 /* Set to each huge file */\n#define EXT4_EXTENTS_FL\t\t\t0x00080000 /* Inode uses extents */\n#define EXT4_VERITY_FL\t\t\t0x00100000 /* Verity protected inode */\n#define EXT4_EA_INODE_FL\t        0x00200000 /* Inode used for large EA */\n/* 0x00400000 was formerly EXT4_EOFBLOCKS_FL */\n\n#define EXT4_DAX_FL\t\t\t0x02000000 /* Inode is DAX */\n\n#define EXT4_INLINE_DATA_FL\t\t0x10000000 /* Inode has inline data. */\n#define EXT4_PROJINHERIT_FL\t\t0x20000000 /* Create with parents projid */\n#define EXT4_CASEFOLD_FL\t\t0x40000000 /* Casefolded directory */\n#define EXT4_RESERVED_FL\t\t0x80000000 /* reserved for ext4 lib */\n\n/* User modifiable flags */\n#define EXT4_FL_USER_MODIFIABLE\t\t(EXT4_SECRM_FL | \\\n\t\t\t\t\t EXT4_UNRM_FL | \\\n\t\t\t\t\t EXT4_COMPR_FL | \\\n\t\t\t\t\t EXT4_SYNC_FL | \\\n\t\t\t\t\t EXT4_IMMUTABLE_FL | \\\n\t\t\t\t\t EXT4_APPEND_FL | \\\n\t\t\t\t\t EXT4_NODUMP_FL | \\\n\t\t\t\t\t EXT4_NOATIME_FL | \\\n\t\t\t\t\t EXT4_JOURNAL_DATA_FL | \\\n\t\t\t\t\t EXT4_NOTAIL_FL | \\\n\t\t\t\t\t EXT4_DIRSYNC_FL | \\\n\t\t\t\t\t EXT4_TOPDIR_FL | \\\n\t\t\t\t\t EXT4_EXTENTS_FL | \\\n\t\t\t\t\t 0x00400000 /* EXT4_EOFBLOCKS_FL */ | \\\n\t\t\t\t\t EXT4_DAX_FL | \\\n\t\t\t\t\t EXT4_PROJINHERIT_FL | \\\n\t\t\t\t\t EXT4_CASEFOLD_FL)\n\n/* User visible flags */\n#define EXT4_FL_USER_VISIBLE\t\t(EXT4_FL_USER_MODIFIABLE | \\\n\t\t\t\t\t EXT4_DIRTY_FL | \\\n\t\t\t\t\t EXT4_COMPRBLK_FL | \\\n\t\t\t\t\t EXT4_NOCOMPR_FL | \\\n\t\t\t\t\t EXT4_ENCRYPT_FL | \\\n\t\t\t\t\t EXT4_INDEX_FL | \\\n\t\t\t\t\t EXT4_VERITY_FL | \\\n\t\t\t\t\t EXT4_INLINE_DATA_FL)\n\n/* Flags we can manipulate with through FS_IOC_FSSETXATTR */\n#define EXT4_FL_XFLAG_VISIBLE\t\t(EXT4_SYNC_FL | \\\n\t\t\t\t\t EXT4_IMMUTABLE_FL | \\\n\t\t\t\t\t EXT4_APPEND_FL | \\\n\t\t\t\t\t EXT4_NODUMP_FL | \\\n\t\t\t\t\t EXT4_NOATIME_FL | \\\n\t\t\t\t\t EXT4_PROJINHERIT_FL | \\\n\t\t\t\t\t EXT4_DAX_FL)\n\n/* Flags that should be inherited by new inodes from their parent. */\n#define EXT4_FL_INHERITED (EXT4_SECRM_FL | EXT4_UNRM_FL | EXT4_COMPR_FL |\\\n\t\t\t   EXT4_SYNC_FL | EXT4_NODUMP_FL | EXT4_NOATIME_FL |\\\n\t\t\t   EXT4_NOCOMPR_FL | EXT4_JOURNAL_DATA_FL |\\\n\t\t\t   EXT4_NOTAIL_FL | EXT4_DIRSYNC_FL |\\\n\t\t\t   EXT4_PROJINHERIT_FL | EXT4_CASEFOLD_FL |\\\n\t\t\t   EXT4_DAX_FL)\n\n/* Flags that are appropriate for regular files (all but dir-specific ones). */\n#define EXT4_REG_FLMASK (~(EXT4_DIRSYNC_FL | EXT4_TOPDIR_FL | EXT4_CASEFOLD_FL |\\\n\t\t\t   EXT4_PROJINHERIT_FL))\n\n/* Flags that are appropriate for non-directories/regular files. */\n#define EXT4_OTHER_FLMASK (EXT4_NODUMP_FL | EXT4_NOATIME_FL)\n\n/* The only flags that should be swapped */\n#define EXT4_FL_SHOULD_SWAP (EXT4_HUGE_FILE_FL | EXT4_EXTENTS_FL)\n\n/* Flags which are mutually exclusive to DAX */\n#define EXT4_DAX_MUT_EXCL (EXT4_VERITY_FL | EXT4_ENCRYPT_FL |\\\n\t\t\t   EXT4_JOURNAL_DATA_FL | EXT4_INLINE_DATA_FL)\n\n/* Mask out flags that are inappropriate for the given type of inode. */\nstatic inline __u32 ext4_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT4_REG_FLMASK;\n\telse\n\t\treturn flags & EXT4_OTHER_FLMASK;\n}\n\n/*\n * Inode flags used for atomic set/get\n */\nenum {\n\tEXT4_INODE_SECRM\t= 0,\t/* Secure deletion */\n\tEXT4_INODE_UNRM\t\t= 1,\t/* Undelete */\n\tEXT4_INODE_COMPR\t= 2,\t/* Compress file */\n\tEXT4_INODE_SYNC\t\t= 3,\t/* Synchronous updates */\n\tEXT4_INODE_IMMUTABLE\t= 4,\t/* Immutable file */\n\tEXT4_INODE_APPEND\t= 5,\t/* writes to file may only append */\n\tEXT4_INODE_NODUMP\t= 6,\t/* do not dump file */\n\tEXT4_INODE_NOATIME\t= 7,\t/* do not update atime */\n/* Reserved for compression usage... */\n\tEXT4_INODE_DIRTY\t= 8,\n\tEXT4_INODE_COMPRBLK\t= 9,\t/* One or more compressed clusters */\n\tEXT4_INODE_NOCOMPR\t= 10,\t/* Don't compress */\n\tEXT4_INODE_ENCRYPT\t= 11,\t/* Encrypted file */\n/* End compression flags --- maybe not all used */\n\tEXT4_INODE_INDEX\t= 12,\t/* hash-indexed directory */\n\tEXT4_INODE_IMAGIC\t= 13,\t/* AFS directory */\n\tEXT4_INODE_JOURNAL_DATA\t= 14,\t/* file data should be journaled */\n\tEXT4_INODE_NOTAIL\t= 15,\t/* file tail should not be merged */\n\tEXT4_INODE_DIRSYNC\t= 16,\t/* dirsync behaviour (directories only) */\n\tEXT4_INODE_TOPDIR\t= 17,\t/* Top of directory hierarchies*/\n\tEXT4_INODE_HUGE_FILE\t= 18,\t/* Set to each huge file */\n\tEXT4_INODE_EXTENTS\t= 19,\t/* Inode uses extents */\n\tEXT4_INODE_VERITY\t= 20,\t/* Verity protected inode */\n\tEXT4_INODE_EA_INODE\t= 21,\t/* Inode used for large EA */\n/* 22 was formerly EXT4_INODE_EOFBLOCKS */\n\tEXT4_INODE_DAX\t\t= 25,\t/* Inode is DAX */\n\tEXT4_INODE_INLINE_DATA\t= 28,\t/* Data in inode. */\n\tEXT4_INODE_PROJINHERIT\t= 29,\t/* Create with parents projid */\n\tEXT4_INODE_CASEFOLD\t= 30,\t/* Casefolded directory */\n\tEXT4_INODE_RESERVED\t= 31,\t/* reserved for ext4 lib */\n};\n\n/*\n * Since it's pretty easy to mix up bit numbers and hex values, we use a\n * build-time check to make sure that EXT4_XXX_FL is consistent with respect to\n * EXT4_INODE_XXX. If all is well, the macros will be dropped, so, it won't cost\n * any extra space in the compiled kernel image, otherwise, the build will fail.\n * It's important that these values are the same, since we are using\n * EXT4_INODE_XXX to test for flag values, but EXT4_XXX_FL must be consistent\n * with the values of FS_XXX_FL defined in include/linux/fs.h and the on-disk\n * values found in ext2, ext3 and ext4 filesystems, and of course the values\n * defined in e2fsprogs.\n *\n * It's not paranoia if the Murphy's Law really *is* out to get you.  :-)\n */\n#define TEST_FLAG_VALUE(FLAG) (EXT4_##FLAG##_FL == (1 << EXT4_INODE_##FLAG))\n#define CHECK_FLAG_VALUE(FLAG) BUILD_BUG_ON(!TEST_FLAG_VALUE(FLAG))\n\nstatic inline void ext4_check_flag_values(void)\n{\n\tCHECK_FLAG_VALUE(SECRM);\n\tCHECK_FLAG_VALUE(UNRM);\n\tCHECK_FLAG_VALUE(COMPR);\n\tCHECK_FLAG_VALUE(SYNC);\n\tCHECK_FLAG_VALUE(IMMUTABLE);\n\tCHECK_FLAG_VALUE(APPEND);\n\tCHECK_FLAG_VALUE(NODUMP);\n\tCHECK_FLAG_VALUE(NOATIME);\n\tCHECK_FLAG_VALUE(DIRTY);\n\tCHECK_FLAG_VALUE(COMPRBLK);\n\tCHECK_FLAG_VALUE(NOCOMPR);\n\tCHECK_FLAG_VALUE(ENCRYPT);\n\tCHECK_FLAG_VALUE(INDEX);\n\tCHECK_FLAG_VALUE(IMAGIC);\n\tCHECK_FLAG_VALUE(JOURNAL_DATA);\n\tCHECK_FLAG_VALUE(NOTAIL);\n\tCHECK_FLAG_VALUE(DIRSYNC);\n\tCHECK_FLAG_VALUE(TOPDIR);\n\tCHECK_FLAG_VALUE(HUGE_FILE);\n\tCHECK_FLAG_VALUE(EXTENTS);\n\tCHECK_FLAG_VALUE(VERITY);\n\tCHECK_FLAG_VALUE(EA_INODE);\n\tCHECK_FLAG_VALUE(INLINE_DATA);\n\tCHECK_FLAG_VALUE(PROJINHERIT);\n\tCHECK_FLAG_VALUE(CASEFOLD);\n\tCHECK_FLAG_VALUE(RESERVED);\n}\n\n/* Used to pass group descriptor data when online resize is done */\nstruct ext4_new_group_input {\n\t__u32 group;\t\t/* Group number for this data */\n\t__u64 block_bitmap;\t/* Absolute block number of block bitmap */\n\t__u64 inode_bitmap;\t/* Absolute block number of inode bitmap */\n\t__u64 inode_table;\t/* Absolute block number of inode table start */\n\t__u32 blocks_count;\t/* Total number of blocks in this group */\n\t__u16 reserved_blocks;\t/* Number of reserved blocks in this group */\n\t__u16 unused;\n};\n\n#if defined(__KERNEL__) && defined(CONFIG_COMPAT)\nstruct compat_ext4_new_group_input {\n\tu32 group;\n\tcompat_u64 block_bitmap;\n\tcompat_u64 inode_bitmap;\n\tcompat_u64 inode_table;\n\tu32 blocks_count;\n\tu16 reserved_blocks;\n\tu16 unused;\n};\n#endif\n\n/* The struct ext4_new_group_input in kernel space, with free_blocks_count */\nstruct ext4_new_group_data {\n\t__u32 group;\n\t__u64 block_bitmap;\n\t__u64 inode_bitmap;\n\t__u64 inode_table;\n\t__u32 blocks_count;\n\t__u16 reserved_blocks;\n\t__u16 mdata_blocks;\n\t__u32 free_clusters_count;\n};\n\n/* Indexes used to index group tables in ext4_new_group_data */\nenum {\n\tBLOCK_BITMAP = 0,\t/* block bitmap */\n\tINODE_BITMAP,\t\t/* inode bitmap */\n\tINODE_TABLE,\t\t/* inode tables */\n\tGROUP_TABLE_COUNT,\n};\n\n/*\n * Flags used by ext4_map_blocks()\n */\n\t/* Allocate any needed blocks and/or convert an unwritten\n\t   extent to be an initialized ext4 */\n#define EXT4_GET_BLOCKS_CREATE\t\t\t0x0001\n\t/* Request the creation of an unwritten extent */\n#define EXT4_GET_BLOCKS_UNWRIT_EXT\t\t0x0002\n#define EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT\t(EXT4_GET_BLOCKS_UNWRIT_EXT|\\\n\t\t\t\t\t\t EXT4_GET_BLOCKS_CREATE)\n\t/* Caller is from the delayed allocation writeout path\n\t * finally doing the actual allocation of delayed blocks */\n#define EXT4_GET_BLOCKS_DELALLOC_RESERVE\t0x0004\n\t/* caller is from the direct IO path, request to creation of an\n\tunwritten extents if not allocated, split the unwritten\n\textent if blocks has been preallocated already*/\n#define EXT4_GET_BLOCKS_PRE_IO\t\t\t0x0008\n#define EXT4_GET_BLOCKS_CONVERT\t\t\t0x0010\n#define EXT4_GET_BLOCKS_IO_CREATE_EXT\t\t(EXT4_GET_BLOCKS_PRE_IO|\\\n\t\t\t\t\t EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT)\n\t/* Convert extent to initialized after IO complete */\n#define EXT4_GET_BLOCKS_IO_CONVERT_EXT\t\t(EXT4_GET_BLOCKS_CONVERT|\\\n\t\t\t\t\t EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT)\n\t/* Eventual metadata allocation (due to growing extent tree)\n\t * should not fail, so try to use reserved blocks for that.*/\n#define EXT4_GET_BLOCKS_METADATA_NOFAIL\t\t0x0020\n\t/* Don't normalize allocation size (used for fallocate) */\n#define EXT4_GET_BLOCKS_NO_NORMALIZE\t\t0x0040\n\t/* Convert written extents to unwritten */\n#define EXT4_GET_BLOCKS_CONVERT_UNWRITTEN\t0x0100\n\t/* Write zeros to newly created written extents */\n#define EXT4_GET_BLOCKS_ZERO\t\t\t0x0200\n#define EXT4_GET_BLOCKS_CREATE_ZERO\t\t(EXT4_GET_BLOCKS_CREATE |\\\n\t\t\t\t\tEXT4_GET_BLOCKS_ZERO)\n\t/* Caller will submit data before dropping transaction handle. This\n\t * allows jbd2 to avoid submitting data before commit. */\n#define EXT4_GET_BLOCKS_IO_SUBMIT\t\t0x0400\n\n/*\n * The bit position of these flags must not overlap with any of the\n * EXT4_GET_BLOCKS_*.  They are used by ext4_find_extent(),\n * read_extent_tree_block(), ext4_split_extent_at(),\n * ext4_ext_insert_extent(), and ext4_ext_create_new_leaf().\n * EXT4_EX_NOCACHE is used to indicate that the we shouldn't be\n * caching the extents when reading from the extent tree while a\n * truncate or punch hole operation is in progress.\n */\n#define EXT4_EX_NOCACHE\t\t\t\t0x40000000\n#define EXT4_EX_FORCE_CACHE\t\t\t0x20000000\n#define EXT4_EX_NOFAIL\t\t\t\t0x10000000\n\n/*\n * Flags used by ext4_free_blocks\n */\n#define EXT4_FREE_BLOCKS_METADATA\t\t0x0001\n#define EXT4_FREE_BLOCKS_FORGET\t\t\t0x0002\n#define EXT4_FREE_BLOCKS_VALIDATED\t\t0x0004\n#define EXT4_FREE_BLOCKS_NO_QUOT_UPDATE\t\t0x0008\n#define EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER\t0x0010\n#define EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER\t0x0020\n#define EXT4_FREE_BLOCKS_RERESERVE_CLUSTER      0x0040\n\n/*\n * ioctl commands\n */\n#define\tEXT4_IOC_GETVERSION\t\t_IOR('f', 3, long)\n#define\tEXT4_IOC_SETVERSION\t\t_IOW('f', 4, long)\n#define\tEXT4_IOC_GETVERSION_OLD\t\tFS_IOC_GETVERSION\n#define\tEXT4_IOC_SETVERSION_OLD\t\tFS_IOC_SETVERSION\n#define EXT4_IOC_GETRSVSZ\t\t_IOR('f', 5, long)\n#define EXT4_IOC_SETRSVSZ\t\t_IOW('f', 6, long)\n#define EXT4_IOC_GROUP_EXTEND\t\t_IOW('f', 7, unsigned long)\n#define EXT4_IOC_GROUP_ADD\t\t_IOW('f', 8, struct ext4_new_group_input)\n#define EXT4_IOC_MIGRATE\t\t_IO('f', 9)\n /* note ioctl 10 reserved for an early version of the FIEMAP ioctl */\n /* note ioctl 11 reserved for filesystem-independent FIEMAP ioctl */\n#define EXT4_IOC_ALLOC_DA_BLKS\t\t_IO('f', 12)\n#define EXT4_IOC_MOVE_EXT\t\t_IOWR('f', 15, struct move_extent)\n#define EXT4_IOC_RESIZE_FS\t\t_IOW('f', 16, __u64)\n#define EXT4_IOC_SWAP_BOOT\t\t_IO('f', 17)\n#define EXT4_IOC_PRECACHE_EXTENTS\t_IO('f', 18)\n/* ioctl codes 19--39 are reserved for fscrypt */\n#define EXT4_IOC_CLEAR_ES_CACHE\t\t_IO('f', 40)\n#define EXT4_IOC_GETSTATE\t\t_IOW('f', 41, __u32)\n#define EXT4_IOC_GET_ES_CACHE\t\t_IOWR('f', 42, struct fiemap)\n\n#define EXT4_IOC_SHUTDOWN _IOR ('X', 125, __u32)\n\n/*\n * Flags for going down operation\n */\n#define EXT4_GOING_FLAGS_DEFAULT\t\t0x0\t/* going down */\n#define EXT4_GOING_FLAGS_LOGFLUSH\t\t0x1\t/* flush log but not data */\n#define EXT4_GOING_FLAGS_NOLOGFLUSH\t\t0x2\t/* don't flush log nor data */\n\n/*\n * Flags returned by EXT4_IOC_GETSTATE\n *\n * We only expose to userspace a subset of the state flags in\n * i_state_flags\n */\n#define EXT4_STATE_FLAG_EXT_PRECACHED\t0x00000001\n#define EXT4_STATE_FLAG_NEW\t\t0x00000002\n#define EXT4_STATE_FLAG_NEWENTRY\t0x00000004\n#define EXT4_STATE_FLAG_DA_ALLOC_CLOSE\t0x00000008\n\n#if defined(__KERNEL__) && defined(CONFIG_COMPAT)\n/*\n * ioctl commands in 32 bit emulation\n */\n#define EXT4_IOC32_GETVERSION\t\t_IOR('f', 3, int)\n#define EXT4_IOC32_SETVERSION\t\t_IOW('f', 4, int)\n#define EXT4_IOC32_GETRSVSZ\t\t_IOR('f', 5, int)\n#define EXT4_IOC32_SETRSVSZ\t\t_IOW('f', 6, int)\n#define EXT4_IOC32_GROUP_EXTEND\t\t_IOW('f', 7, unsigned int)\n#define EXT4_IOC32_GROUP_ADD\t\t_IOW('f', 8, struct compat_ext4_new_group_input)\n#define EXT4_IOC32_GETVERSION_OLD\tFS_IOC32_GETVERSION\n#define EXT4_IOC32_SETVERSION_OLD\tFS_IOC32_SETVERSION\n#endif\n\n/*\n * Returned by EXT4_IOC_GET_ES_CACHE as an additional possible flag.\n * It indicates that the entry in extent status cache is for a hole.\n */\n#define EXT4_FIEMAP_EXTENT_HOLE\t\t0x08000000\n\n/* Max physical block we can address w/o extents */\n#define EXT4_MAX_BLOCK_FILE_PHYS\t0xFFFFFFFF\n\n/* Max logical block we can support */\n#define EXT4_MAX_LOGICAL_BLOCK\t\t0xFFFFFFFE\n\n/*\n * Structure of an inode on the disk\n */\nstruct ext4_inode {\n\t__le16\ti_mode;\t\t/* File mode */\n\t__le16\ti_uid;\t\t/* Low 16 bits of Owner Uid */\n\t__le32\ti_size_lo;\t/* Size in bytes */\n\t__le32\ti_atime;\t/* Access time */\n\t__le32\ti_ctime;\t/* Inode Change time */\n\t__le32\ti_mtime;\t/* Modification time */\n\t__le32\ti_dtime;\t/* Deletion Time */\n\t__le16\ti_gid;\t\t/* Low 16 bits of Group Id */\n\t__le16\ti_links_count;\t/* Links count */\n\t__le32\ti_blocks_lo;\t/* Blocks count */\n\t__le32\ti_flags;\t/* File flags */\n\tunion {\n\t\tstruct {\n\t\t\t__le32  l_i_version;\n\t\t} linux1;\n\t\tstruct {\n\t\t\t__u32  h_i_translator;\n\t\t} hurd1;\n\t\tstruct {\n\t\t\t__u32  m_i_reserved1;\n\t\t} masix1;\n\t} osd1;\t\t\t\t/* OS dependent 1 */\n\t__le32\ti_block[EXT4_N_BLOCKS];/* Pointers to blocks */\n\t__le32\ti_generation;\t/* File version (for NFS) */\n\t__le32\ti_file_acl_lo;\t/* File ACL */\n\t__le32\ti_size_high;\n\t__le32\ti_obso_faddr;\t/* Obsoleted fragment address */\n\tunion {\n\t\tstruct {\n\t\t\t__le16\tl_i_blocks_high; /* were l_i_reserved1 */\n\t\t\t__le16\tl_i_file_acl_high;\n\t\t\t__le16\tl_i_uid_high;\t/* these 2 fields */\n\t\t\t__le16\tl_i_gid_high;\t/* were reserved2[0] */\n\t\t\t__le16\tl_i_checksum_lo;/* crc32c(uuid+inum+inode) LE */\n\t\t\t__le16\tl_i_reserved;\n\t\t} linux2;\n\t\tstruct {\n\t\t\t__le16\th_i_reserved1;\t/* Obsoleted fragment number/size which are removed in ext4 */\n\t\t\t__u16\th_i_mode_high;\n\t\t\t__u16\th_i_uid_high;\n\t\t\t__u16\th_i_gid_high;\n\t\t\t__u32\th_i_author;\n\t\t} hurd2;\n\t\tstruct {\n\t\t\t__le16\th_i_reserved1;\t/* Obsoleted fragment number/size which are removed in ext4 */\n\t\t\t__le16\tm_i_file_acl_high;\n\t\t\t__u32\tm_i_reserved2[2];\n\t\t} masix2;\n\t} osd2;\t\t\t\t/* OS dependent 2 */\n\t__le16\ti_extra_isize;\n\t__le16\ti_checksum_hi;\t/* crc32c(uuid+inum+inode) BE */\n\t__le32  i_ctime_extra;  /* extra Change time      (nsec << 2 | epoch) */\n\t__le32  i_mtime_extra;  /* extra Modification time(nsec << 2 | epoch) */\n\t__le32  i_atime_extra;  /* extra Access time      (nsec << 2 | epoch) */\n\t__le32  i_crtime;       /* File Creation time */\n\t__le32  i_crtime_extra; /* extra FileCreationtime (nsec << 2 | epoch) */\n\t__le32  i_version_hi;\t/* high 32 bits for 64-bit version */\n\t__le32\ti_projid;\t/* Project ID */\n};\n\nstruct move_extent {\n\t__u32 reserved;\t\t/* should be zero */\n\t__u32 donor_fd;\t\t/* donor file descriptor */\n\t__u64 orig_start;\t/* logical start offset in block for orig */\n\t__u64 donor_start;\t/* logical start offset in block for donor */\n\t__u64 len;\t\t/* block length to be moved */\n\t__u64 moved_len;\t/* moved block length */\n};\n\n#define EXT4_EPOCH_BITS 2\n#define EXT4_EPOCH_MASK ((1 << EXT4_EPOCH_BITS) - 1)\n#define EXT4_NSEC_MASK  (~0UL << EXT4_EPOCH_BITS)\n\n/*\n * Extended fields will fit into an inode if the filesystem was formatted\n * with large inodes (-I 256 or larger) and there are not currently any EAs\n * consuming all of the available space. For new inodes we always reserve\n * enough space for the kernel's known extended fields, but for inodes\n * created with an old kernel this might not have been the case. None of\n * the extended inode fields is critical for correct filesystem operation.\n * This macro checks if a certain field fits in the inode. Note that\n * inode-size = GOOD_OLD_INODE_SIZE + i_extra_isize\n */\n#define EXT4_FITS_IN_INODE(ext4_inode, einode, field)\t\\\n\t((offsetof(typeof(*ext4_inode), field) +\t\\\n\t  sizeof((ext4_inode)->field))\t\t\t\\\n\t<= (EXT4_GOOD_OLD_INODE_SIZE +\t\t\t\\\n\t    (einode)->i_extra_isize))\t\t\t\\\n\n/*\n * We use an encoding that preserves the times for extra epoch \"00\":\n *\n * extra  msb of                         adjust for signed\n * epoch  32-bit                         32-bit tv_sec to\n * bits   time    decoded 64-bit tv_sec  64-bit tv_sec      valid time range\n * 0 0    1    -0x80000000..-0x00000001  0x000000000 1901-12-13..1969-12-31\n * 0 0    0    0x000000000..0x07fffffff  0x000000000 1970-01-01..2038-01-19\n * 0 1    1    0x080000000..0x0ffffffff  0x100000000 2038-01-19..2106-02-07\n * 0 1    0    0x100000000..0x17fffffff  0x100000000 2106-02-07..2174-02-25\n * 1 0    1    0x180000000..0x1ffffffff  0x200000000 2174-02-25..2242-03-16\n * 1 0    0    0x200000000..0x27fffffff  0x200000000 2242-03-16..2310-04-04\n * 1 1    1    0x280000000..0x2ffffffff  0x300000000 2310-04-04..2378-04-22\n * 1 1    0    0x300000000..0x37fffffff  0x300000000 2378-04-22..2446-05-10\n *\n * Note that previous versions of the kernel on 64-bit systems would\n * incorrectly use extra epoch bits 1,1 for dates between 1901 and\n * 1970.  e2fsck will correct this, assuming that it is run on the\n * affected filesystem before 2242.\n */\n\nstatic inline __le32 ext4_encode_extra_time(struct timespec64 *time)\n{\n\tu32 extra =((time->tv_sec - (s32)time->tv_sec) >> 32) & EXT4_EPOCH_MASK;\n\treturn cpu_to_le32(extra | (time->tv_nsec << EXT4_EPOCH_BITS));\n}\n\nstatic inline void ext4_decode_extra_time(struct timespec64 *time,\n\t\t\t\t\t  __le32 extra)\n{\n\tif (unlikely(extra & cpu_to_le32(EXT4_EPOCH_MASK)))\n\t\ttime->tv_sec += (u64)(le32_to_cpu(extra) & EXT4_EPOCH_MASK) << 32;\n\ttime->tv_nsec = (le32_to_cpu(extra) & EXT4_NSEC_MASK) >> EXT4_EPOCH_BITS;\n}\n\n#define EXT4_INODE_SET_XTIME(xtime, inode, raw_inode)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tif (EXT4_FITS_IN_INODE(raw_inode, EXT4_I(inode), xtime ## _extra))     {\\\n\t\t(raw_inode)->xtime = cpu_to_le32((inode)->xtime.tv_sec);\t\\\n\t\t(raw_inode)->xtime ## _extra =\t\t\t\t\t\\\n\t\t\t\text4_encode_extra_time(&(inode)->xtime);\t\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\telse\t\\\n\t\t(raw_inode)->xtime = cpu_to_le32(clamp_t(int32_t, (inode)->xtime.tv_sec, S32_MIN, S32_MAX));\t\\\n} while (0)\n\n#define EXT4_EINODE_SET_XTIME(xtime, einode, raw_inode)\t\t\t       \\\ndo {\t\t\t\t\t\t\t\t\t       \\\n\tif (EXT4_FITS_IN_INODE(raw_inode, einode, xtime))\t\t       \\\n\t\t(raw_inode)->xtime = cpu_to_le32((einode)->xtime.tv_sec);      \\\n\tif (EXT4_FITS_IN_INODE(raw_inode, einode, xtime ## _extra))\t       \\\n\t\t(raw_inode)->xtime ## _extra =\t\t\t\t       \\\n\t\t\t\text4_encode_extra_time(&(einode)->xtime);      \\\n} while (0)\n\n#define EXT4_INODE_GET_XTIME(xtime, inode, raw_inode)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\t(inode)->xtime.tv_sec = (signed)le32_to_cpu((raw_inode)->xtime);\t\\\n\tif (EXT4_FITS_IN_INODE(raw_inode, EXT4_I(inode), xtime ## _extra)) {\t\\\n\t\text4_decode_extra_time(&(inode)->xtime,\t\t\t\t\\\n\t\t\t\t       raw_inode->xtime ## _extra);\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\t\\\n\t\t(inode)->xtime.tv_nsec = 0;\t\t\t\t\t\\\n} while (0)\n\n\n#define EXT4_EINODE_GET_XTIME(xtime, einode, raw_inode)\t\t\t       \\\ndo {\t\t\t\t\t\t\t\t\t       \\\n\tif (EXT4_FITS_IN_INODE(raw_inode, einode, xtime))\t\t       \\\n\t\t(einode)->xtime.tv_sec = \t\t\t\t       \\\n\t\t\t(signed)le32_to_cpu((raw_inode)->xtime);\t       \\\n\telse\t\t\t\t\t\t\t\t       \\\n\t\t(einode)->xtime.tv_sec = 0;\t\t\t\t       \\\n\tif (EXT4_FITS_IN_INODE(raw_inode, einode, xtime ## _extra))\t       \\\n\t\text4_decode_extra_time(&(einode)->xtime,\t\t       \\\n\t\t\t\t       raw_inode->xtime ## _extra);\t       \\\n\telse\t\t\t\t\t\t\t\t       \\\n\t\t(einode)->xtime.tv_nsec = 0;\t\t\t\t       \\\n} while (0)\n\n#define i_disk_version osd1.linux1.l_i_version\n\n#if defined(__KERNEL__) || defined(__linux__)\n#define i_reserved1\tosd1.linux1.l_i_reserved1\n#define i_file_acl_high\tosd2.linux2.l_i_file_acl_high\n#define i_blocks_high\tosd2.linux2.l_i_blocks_high\n#define i_uid_low\ti_uid\n#define i_gid_low\ti_gid\n#define i_uid_high\tosd2.linux2.l_i_uid_high\n#define i_gid_high\tosd2.linux2.l_i_gid_high\n#define i_checksum_lo\tosd2.linux2.l_i_checksum_lo\n\n#elif defined(__GNU__)\n\n#define i_translator\tosd1.hurd1.h_i_translator\n#define i_uid_high\tosd2.hurd2.h_i_uid_high\n#define i_gid_high\tosd2.hurd2.h_i_gid_high\n#define i_author\tosd2.hurd2.h_i_author\n\n#elif defined(__masix__)\n\n#define i_reserved1\tosd1.masix1.m_i_reserved1\n#define i_file_acl_high\tosd2.masix2.m_i_file_acl_high\n#define i_reserved2\tosd2.masix2.m_i_reserved2\n\n#endif /* defined(__KERNEL__) || defined(__linux__) */\n\n#include \"extents_status.h\"\n#include \"fast_commit.h\"\n\n/*\n * Lock subclasses for i_data_sem in the ext4_inode_info structure.\n *\n * These are needed to avoid lockdep false positives when we need to\n * allocate blocks to the quota inode during ext4_map_blocks(), while\n * holding i_data_sem for a normal (non-quota) inode.  Since we don't\n * do quota tracking for the quota inode, this avoids deadlock (as\n * well as infinite recursion, since it isn't turtles all the way\n * down...)\n *\n *  I_DATA_SEM_NORMAL - Used for most inodes\n *  I_DATA_SEM_OTHER  - Used by move_inode.c for the second normal inode\n *\t\t\t  where the second inode has larger inode number\n *\t\t\t  than the first\n *  I_DATA_SEM_QUOTA  - Used for quota inodes only\n */\nenum {\n\tI_DATA_SEM_NORMAL = 0,\n\tI_DATA_SEM_OTHER,\n\tI_DATA_SEM_QUOTA,\n};\n\n\n/*\n * fourth extended file system inode data in memory\n */\nstruct ext4_inode_info {\n\t__le32\ti_data[15];\t/* unconverted */\n\t__u32\ti_dtime;\n\text4_fsblk_t\ti_file_acl;\n\n\t/*\n\t * i_block_group is the number of the block group which contains\n\t * this file's inode.  Constant across the lifetime of the inode,\n\t * it is used for making block allocation decisions - we try to\n\t * place a file's data blocks near its inode block, and new inodes\n\t * near to their parent directory's inode.\n\t */\n\text4_group_t\ti_block_group;\n\text4_lblk_t\ti_dir_start_lookup;\n#if (BITS_PER_LONG < 64)\n\tunsigned long\ti_state_flags;\t\t/* Dynamic state flags */\n#endif\n\tunsigned long\ti_flags;\n\n\t/*\n\t * Extended attributes can be read independently of the main file\n\t * data. Taking i_mutex even when reading would cause contention\n\t * between readers of EAs and writers of regular file data, so\n\t * instead we synchronize on xattr_sem when reading or changing\n\t * EAs.\n\t */\n\tstruct rw_semaphore xattr_sem;\n\n\tstruct list_head i_orphan;\t/* unlinked but open inodes */\n\n\t/* Fast commit related info */\n\n\tstruct list_head i_fc_list;\t/*\n\t\t\t\t\t * inodes that need fast commit\n\t\t\t\t\t * protected by sbi->s_fc_lock.\n\t\t\t\t\t */\n\n\t/* Start of lblk range that needs to be committed in this fast commit */\n\text4_lblk_t i_fc_lblk_start;\n\n\t/* End of lblk range that needs to be committed in this fast commit */\n\text4_lblk_t i_fc_lblk_len;\n\n\t/* Number of ongoing updates on this inode */\n\tatomic_t  i_fc_updates;\n\n\t/* Fast commit wait queue for this inode */\n\twait_queue_head_t i_fc_wait;\n\n\t/* Protect concurrent accesses on i_fc_lblk_start, i_fc_lblk_len */\n\tstruct mutex i_fc_lock;\n\n\t/*\n\t * i_disksize keeps track of what the inode size is ON DISK, not\n\t * in memory.  During truncate, i_size is set to the new size by\n\t * the VFS prior to calling ext4_truncate(), but the filesystem won't\n\t * set i_disksize to 0 until the truncate is actually under way.\n\t *\n\t * The intent is that i_disksize always represents the blocks which\n\t * are used by this file.  This allows recovery to restart truncate\n\t * on orphans if we crash during truncate.  We actually write i_disksize\n\t * into the on-disk inode when writing inodes out, instead of i_size.\n\t *\n\t * The only time when i_disksize and i_size may be different is when\n\t * a truncate is in progress.  The only things which change i_disksize\n\t * are ext4_get_block (growth) and ext4_truncate (shrinkth).\n\t */\n\tloff_t\ti_disksize;\n\n\t/*\n\t * i_data_sem is for serialising ext4_truncate() against\n\t * ext4_getblock().  In the 2.4 ext2 design, great chunks of inode's\n\t * data tree are chopped off during truncate. We can't do that in\n\t * ext4 because whenever we perform intermediate commits during\n\t * truncate, the inode and all the metadata blocks *must* be in a\n\t * consistent state which allows truncation of the orphans to restart\n\t * during recovery.  Hence we must fix the get_block-vs-truncate race\n\t * by other means, so we have i_data_sem.\n\t */\n\tstruct rw_semaphore i_data_sem;\n\t/*\n\t * i_mmap_sem is for serializing page faults with truncate / punch hole\n\t * operations. We have to make sure that new page cannot be faulted in\n\t * a section of the inode that is being punched. We cannot easily use\n\t * i_data_sem for this since we need protection for the whole punch\n\t * operation and i_data_sem ranks below transaction start so we have\n\t * to occasionally drop it.\n\t */\n\tstruct rw_semaphore i_mmap_sem;\n\tstruct inode vfs_inode;\n\tstruct jbd2_inode *jinode;\n\n\tspinlock_t i_raw_lock;\t/* protects updates to the raw inode */\n\n\t/*\n\t * File creation time. Its function is same as that of\n\t * struct timespec64 i_{a,c,m}time in the generic inode.\n\t */\n\tstruct timespec64 i_crtime;\n\n\t/* mballoc */\n\tatomic_t i_prealloc_active;\n\tstruct list_head i_prealloc_list;\n\tspinlock_t i_prealloc_lock;\n\n\t/* extents status tree */\n\tstruct ext4_es_tree i_es_tree;\n\trwlock_t i_es_lock;\n\tstruct list_head i_es_list;\n\tunsigned int i_es_all_nr;\t/* protected by i_es_lock */\n\tunsigned int i_es_shk_nr;\t/* protected by i_es_lock */\n\text4_lblk_t i_es_shrink_lblk;\t/* Offset where we start searching for\n\t\t\t\t\t   extents to shrink. Protected by\n\t\t\t\t\t   i_es_lock  */\n\n\t/* ialloc */\n\text4_group_t\ti_last_alloc_group;\n\n\t/* allocation reservation info for delalloc */\n\t/* In case of bigalloc, this refer to clusters rather than blocks */\n\tunsigned int i_reserved_data_blocks;\n\n\t/* pending cluster reservations for bigalloc file systems */\n\tstruct ext4_pending_tree i_pending_tree;\n\n\t/* on-disk additional length */\n\t__u16 i_extra_isize;\n\n\t/* Indicate the inline data space. */\n\tu16 i_inline_off;\n\tu16 i_inline_size;\n\n#ifdef CONFIG_QUOTA\n\t/* quota space reservation, managed internally by quota code */\n\tqsize_t i_reserved_quota;\n#endif\n\n\t/* Lock protecting lists below */\n\tspinlock_t i_completed_io_lock;\n\t/*\n\t * Completed IOs that need unwritten extents handling and have\n\t * transaction reserved\n\t */\n\tstruct list_head i_rsv_conversion_list;\n\tstruct work_struct i_rsv_conversion_work;\n\tatomic_t i_unwritten; /* Nr. of inflight conversions pending */\n\n\tspinlock_t i_block_reservation_lock;\n\n\t/*\n\t * Transactions that contain inode's metadata needed to complete\n\t * fsync and fdatasync, respectively.\n\t */\n\ttid_t i_sync_tid;\n\ttid_t i_datasync_tid;\n\n#ifdef CONFIG_QUOTA\n\tstruct dquot *i_dquot[MAXQUOTAS];\n#endif\n\n\t/* Precomputed uuid+inum+igen checksum for seeding inode checksums */\n\t__u32 i_csum_seed;\n\n\tkprojid_t i_projid;\n};\n\n/*\n * File system states\n */\n#define\tEXT4_VALID_FS\t\t\t0x0001\t/* Unmounted cleanly */\n#define\tEXT4_ERROR_FS\t\t\t0x0002\t/* Errors detected */\n#define\tEXT4_ORPHAN_FS\t\t\t0x0004\t/* Orphans being recovered */\n#define EXT4_FC_INELIGIBLE\t\t0x0008\t/* Fast commit ineligible */\n#define EXT4_FC_COMMITTING\t\t0x0010\t/* File system underoing a fast\n\t\t\t\t\t\t * commit.\n\t\t\t\t\t\t */\n#define EXT4_FC_REPLAY\t\t\t0x0020\t/* Fast commit replay ongoing */\n\n/*\n * Misc. filesystem flags\n */\n#define EXT2_FLAGS_SIGNED_HASH\t\t0x0001  /* Signed dirhash in use */\n#define EXT2_FLAGS_UNSIGNED_HASH\t0x0002  /* Unsigned dirhash in use */\n#define EXT2_FLAGS_TEST_FILESYS\t\t0x0004\t/* to test development code */\n\n/*\n * Mount flags set via mount options or defaults\n */\n#define EXT4_MOUNT_NO_MBCACHE\t\t0x00001 /* Do not use mbcache */\n#define EXT4_MOUNT_GRPID\t\t0x00004\t/* Create files with directory's group */\n#define EXT4_MOUNT_DEBUG\t\t0x00008\t/* Some debugging messages */\n#define EXT4_MOUNT_ERRORS_CONT\t\t0x00010\t/* Continue on errors */\n#define EXT4_MOUNT_ERRORS_RO\t\t0x00020\t/* Remount fs ro on errors */\n#define EXT4_MOUNT_ERRORS_PANIC\t\t0x00040\t/* Panic on errors */\n#define EXT4_MOUNT_ERRORS_MASK\t\t0x00070\n#define EXT4_MOUNT_MINIX_DF\t\t0x00080\t/* Mimics the Minix statfs */\n#define EXT4_MOUNT_NOLOAD\t\t0x00100\t/* Don't use existing journal*/\n#ifdef CONFIG_FS_DAX\n#define EXT4_MOUNT_DAX_ALWAYS\t\t0x00200\t/* Direct Access */\n#else\n#define EXT4_MOUNT_DAX_ALWAYS\t\t0\n#endif\n#define EXT4_MOUNT_DATA_FLAGS\t\t0x00C00\t/* Mode for data writes: */\n#define EXT4_MOUNT_JOURNAL_DATA\t\t0x00400\t/* Write data to journal */\n#define EXT4_MOUNT_ORDERED_DATA\t\t0x00800\t/* Flush data before commit */\n#define EXT4_MOUNT_WRITEBACK_DATA\t0x00C00\t/* No data ordering */\n#define EXT4_MOUNT_UPDATE_JOURNAL\t0x01000\t/* Update the journal format */\n#define EXT4_MOUNT_NO_UID32\t\t0x02000  /* Disable 32-bit UIDs */\n#define EXT4_MOUNT_XATTR_USER\t\t0x04000\t/* Extended user attributes */\n#define EXT4_MOUNT_POSIX_ACL\t\t0x08000\t/* POSIX Access Control Lists */\n#define EXT4_MOUNT_NO_AUTO_DA_ALLOC\t0x10000\t/* No auto delalloc mapping */\n#define EXT4_MOUNT_BARRIER\t\t0x20000 /* Use block barriers */\n#define EXT4_MOUNT_QUOTA\t\t0x40000 /* Some quota option set */\n#define EXT4_MOUNT_USRQUOTA\t\t0x80000 /* \"old\" user quota,\n\t\t\t\t\t\t * enable enforcement for hidden\n\t\t\t\t\t\t * quota files */\n#define EXT4_MOUNT_GRPQUOTA\t\t0x100000 /* \"old\" group quota, enable\n\t\t\t\t\t\t  * enforcement for hidden quota\n\t\t\t\t\t\t  * files */\n#define EXT4_MOUNT_PRJQUOTA\t\t0x200000 /* Enable project quota\n\t\t\t\t\t\t  * enforcement */\n#define EXT4_MOUNT_DIOREAD_NOLOCK\t0x400000 /* Enable support for dio read nolocking */\n#define EXT4_MOUNT_JOURNAL_CHECKSUM\t0x800000 /* Journal checksums */\n#define EXT4_MOUNT_JOURNAL_ASYNC_COMMIT\t0x1000000 /* Journal Async Commit */\n#define EXT4_MOUNT_WARN_ON_ERROR\t0x2000000 /* Trigger WARN_ON on error */\n#define EXT4_MOUNT_PREFETCH_BLOCK_BITMAPS 0x4000000\n#define EXT4_MOUNT_DELALLOC\t\t0x8000000 /* Delalloc support */\n#define EXT4_MOUNT_DATA_ERR_ABORT\t0x10000000 /* Abort on file data write */\n#define EXT4_MOUNT_BLOCK_VALIDITY\t0x20000000 /* Block validity checking */\n#define EXT4_MOUNT_DISCARD\t\t0x40000000 /* Issue DISCARD requests */\n#define EXT4_MOUNT_INIT_INODE_TABLE\t0x80000000 /* Initialize uninitialized itables */\n\n/*\n * Mount flags set either automatically (could not be set by mount option)\n * based on per file system feature or property or in special cases such as\n * distinguishing between explicit mount option definition and default.\n */\n#define EXT4_MOUNT2_EXPLICIT_DELALLOC\t0x00000001 /* User explicitly\n\t\t\t\t\t\t      specified delalloc */\n#define EXT4_MOUNT2_STD_GROUP_SIZE\t0x00000002 /* We have standard group\n\t\t\t\t\t\t      size of blocksize * 8\n\t\t\t\t\t\t      blocks */\n#define EXT4_MOUNT2_HURD_COMPAT\t\t0x00000004 /* Support HURD-castrated\n\t\t\t\t\t\t      file systems */\n#define EXT4_MOUNT2_DAX_NEVER\t\t0x00000008 /* Do not allow Direct Access */\n#define EXT4_MOUNT2_DAX_INODE\t\t0x00000010 /* For printing options only */\n\n#define EXT4_MOUNT2_EXPLICIT_JOURNAL_CHECKSUM\t0x00000008 /* User explicitly\n\t\t\t\t\t\tspecified journal checksum */\n\n#define EXT4_MOUNT2_JOURNAL_FAST_COMMIT\t0x00000010 /* Journal fast commit */\n\n#define clear_opt(sb, opt)\t\tEXT4_SB(sb)->s_mount_opt &= \\\n\t\t\t\t\t\t~EXT4_MOUNT_##opt\n#define set_opt(sb, opt)\t\tEXT4_SB(sb)->s_mount_opt |= \\\n\t\t\t\t\t\tEXT4_MOUNT_##opt\n#define test_opt(sb, opt)\t\t(EXT4_SB(sb)->s_mount_opt & \\\n\t\t\t\t\t EXT4_MOUNT_##opt)\n\n#define clear_opt2(sb, opt)\t\tEXT4_SB(sb)->s_mount_opt2 &= \\\n\t\t\t\t\t\t~EXT4_MOUNT2_##opt\n#define set_opt2(sb, opt)\t\tEXT4_SB(sb)->s_mount_opt2 |= \\\n\t\t\t\t\t\tEXT4_MOUNT2_##opt\n#define test_opt2(sb, opt)\t\t(EXT4_SB(sb)->s_mount_opt2 & \\\n\t\t\t\t\t EXT4_MOUNT2_##opt)\n\n#define ext4_test_and_set_bit\t\t__test_and_set_bit_le\n#define ext4_set_bit\t\t\t__set_bit_le\n#define ext4_set_bit_atomic\t\text2_set_bit_atomic\n#define ext4_test_and_clear_bit\t\t__test_and_clear_bit_le\n#define ext4_clear_bit\t\t\t__clear_bit_le\n#define ext4_clear_bit_atomic\t\text2_clear_bit_atomic\n#define ext4_test_bit\t\t\ttest_bit_le\n#define ext4_find_next_zero_bit\t\tfind_next_zero_bit_le\n#define ext4_find_next_bit\t\tfind_next_bit_le\n\nextern void ext4_set_bits(void *bm, int cur, int len);\n\n/*\n * Maximal mount counts between two filesystem checks\n */\n#define EXT4_DFL_MAX_MNT_COUNT\t\t20\t/* Allow 20 mounts */\n#define EXT4_DFL_CHECKINTERVAL\t\t0\t/* Don't use interval check */\n\n/*\n * Behaviour when detecting errors\n */\n#define EXT4_ERRORS_CONTINUE\t\t1\t/* Continue execution */\n#define EXT4_ERRORS_RO\t\t\t2\t/* Remount fs read-only */\n#define EXT4_ERRORS_PANIC\t\t3\t/* Panic */\n#define EXT4_ERRORS_DEFAULT\t\tEXT4_ERRORS_CONTINUE\n\n/* Metadata checksum algorithm codes */\n#define EXT4_CRC32C_CHKSUM\t\t1\n\n/*\n * Structure of the super block\n */\nstruct ext4_super_block {\n/*00*/\t__le32\ts_inodes_count;\t\t/* Inodes count */\n\t__le32\ts_blocks_count_lo;\t/* Blocks count */\n\t__le32\ts_r_blocks_count_lo;\t/* Reserved blocks count */\n\t__le32\ts_free_blocks_count_lo;\t/* Free blocks count */\n/*10*/\t__le32\ts_free_inodes_count;\t/* Free inodes count */\n\t__le32\ts_first_data_block;\t/* First Data Block */\n\t__le32\ts_log_block_size;\t/* Block size */\n\t__le32\ts_log_cluster_size;\t/* Allocation cluster size */\n/*20*/\t__le32\ts_blocks_per_group;\t/* # Blocks per group */\n\t__le32\ts_clusters_per_group;\t/* # Clusters per group */\n\t__le32\ts_inodes_per_group;\t/* # Inodes per group */\n\t__le32\ts_mtime;\t\t/* Mount time */\n/*30*/\t__le32\ts_wtime;\t\t/* Write time */\n\t__le16\ts_mnt_count;\t\t/* Mount count */\n\t__le16\ts_max_mnt_count;\t/* Maximal mount count */\n\t__le16\ts_magic;\t\t/* Magic signature */\n\t__le16\ts_state;\t\t/* File system state */\n\t__le16\ts_errors;\t\t/* Behaviour when detecting errors */\n\t__le16\ts_minor_rev_level;\t/* minor revision level */\n/*40*/\t__le32\ts_lastcheck;\t\t/* time of last check */\n\t__le32\ts_checkinterval;\t/* max. time between checks */\n\t__le32\ts_creator_os;\t\t/* OS */\n\t__le32\ts_rev_level;\t\t/* Revision level */\n/*50*/\t__le16\ts_def_resuid;\t\t/* Default uid for reserved blocks */\n\t__le16\ts_def_resgid;\t\t/* Default gid for reserved blocks */\n\t/*\n\t * These fields are for EXT4_DYNAMIC_REV superblocks only.\n\t *\n\t * Note: the difference between the compatible feature set and\n\t * the incompatible feature set is that if there is a bit set\n\t * in the incompatible feature set that the kernel doesn't\n\t * know about, it should refuse to mount the filesystem.\n\t *\n\t * e2fsck's requirements are more strict; if it doesn't know\n\t * about a feature in either the compatible or incompatible\n\t * feature set, it must abort and not try to meddle with\n\t * things it doesn't understand...\n\t */\n\t__le32\ts_first_ino;\t\t/* First non-reserved inode */\n\t__le16  s_inode_size;\t\t/* size of inode structure */\n\t__le16\ts_block_group_nr;\t/* block group # of this superblock */\n\t__le32\ts_feature_compat;\t/* compatible feature set */\n/*60*/\t__le32\ts_feature_incompat;\t/* incompatible feature set */\n\t__le32\ts_feature_ro_compat;\t/* readonly-compatible feature set */\n/*68*/\t__u8\ts_uuid[16];\t\t/* 128-bit uuid for volume */\n/*78*/\tchar\ts_volume_name[16];\t/* volume name */\n/*88*/\tchar\ts_last_mounted[64] __nonstring;\t/* directory where last mounted */\n/*C8*/\t__le32\ts_algorithm_usage_bitmap; /* For compression */\n\t/*\n\t * Performance hints.  Directory preallocation should only\n\t * happen if the EXT4_FEATURE_COMPAT_DIR_PREALLOC flag is on.\n\t */\n\t__u8\ts_prealloc_blocks;\t/* Nr of blocks to try to preallocate*/\n\t__u8\ts_prealloc_dir_blocks;\t/* Nr to preallocate for dirs */\n\t__le16\ts_reserved_gdt_blocks;\t/* Per group desc for online growth */\n\t/*\n\t * Journaling support valid if EXT4_FEATURE_COMPAT_HAS_JOURNAL set.\n\t */\n/*D0*/\t__u8\ts_journal_uuid[16];\t/* uuid of journal superblock */\n/*E0*/\t__le32\ts_journal_inum;\t\t/* inode number of journal file */\n\t__le32\ts_journal_dev;\t\t/* device number of journal file */\n\t__le32\ts_last_orphan;\t\t/* start of list of inodes to delete */\n\t__le32\ts_hash_seed[4];\t\t/* HTREE hash seed */\n\t__u8\ts_def_hash_version;\t/* Default hash version to use */\n\t__u8\ts_jnl_backup_type;\n\t__le16  s_desc_size;\t\t/* size of group descriptor */\n/*100*/\t__le32\ts_default_mount_opts;\n\t__le32\ts_first_meta_bg;\t/* First metablock block group */\n\t__le32\ts_mkfs_time;\t\t/* When the filesystem was created */\n\t__le32\ts_jnl_blocks[17];\t/* Backup of the journal inode */\n\t/* 64bit support valid if EXT4_FEATURE_COMPAT_64BIT */\n/*150*/\t__le32\ts_blocks_count_hi;\t/* Blocks count */\n\t__le32\ts_r_blocks_count_hi;\t/* Reserved blocks count */\n\t__le32\ts_free_blocks_count_hi;\t/* Free blocks count */\n\t__le16\ts_min_extra_isize;\t/* All inodes have at least # bytes */\n\t__le16\ts_want_extra_isize; \t/* New inodes should reserve # bytes */\n\t__le32\ts_flags;\t\t/* Miscellaneous flags */\n\t__le16  s_raid_stride;\t\t/* RAID stride */\n\t__le16  s_mmp_update_interval;  /* # seconds to wait in MMP checking */\n\t__le64  s_mmp_block;            /* Block for multi-mount protection */\n\t__le32  s_raid_stripe_width;    /* blocks on all data disks (N*stride)*/\n\t__u8\ts_log_groups_per_flex;  /* FLEX_BG group size */\n\t__u8\ts_checksum_type;\t/* metadata checksum algorithm used */\n\t__u8\ts_encryption_level;\t/* versioning level for encryption */\n\t__u8\ts_reserved_pad;\t\t/* Padding to next 32bits */\n\t__le64\ts_kbytes_written;\t/* nr of lifetime kilobytes written */\n\t__le32\ts_snapshot_inum;\t/* Inode number of active snapshot */\n\t__le32\ts_snapshot_id;\t\t/* sequential ID of active snapshot */\n\t__le64\ts_snapshot_r_blocks_count; /* reserved blocks for active\n\t\t\t\t\t      snapshot's future use */\n\t__le32\ts_snapshot_list;\t/* inode number of the head of the\n\t\t\t\t\t   on-disk snapshot list */\n#define EXT4_S_ERR_START offsetof(struct ext4_super_block, s_error_count)\n\t__le32\ts_error_count;\t\t/* number of fs errors */\n\t__le32\ts_first_error_time;\t/* first time an error happened */\n\t__le32\ts_first_error_ino;\t/* inode involved in first error */\n\t__le64\ts_first_error_block;\t/* block involved of first error */\n\t__u8\ts_first_error_func[32] __nonstring;\t/* function where the error happened */\n\t__le32\ts_first_error_line;\t/* line number where error happened */\n\t__le32\ts_last_error_time;\t/* most recent time of an error */\n\t__le32\ts_last_error_ino;\t/* inode involved in last error */\n\t__le32\ts_last_error_line;\t/* line number where error happened */\n\t__le64\ts_last_error_block;\t/* block involved of last error */\n\t__u8\ts_last_error_func[32] __nonstring;\t/* function where the error happened */\n#define EXT4_S_ERR_END offsetof(struct ext4_super_block, s_mount_opts)\n\t__u8\ts_mount_opts[64];\n\t__le32\ts_usr_quota_inum;\t/* inode for tracking user quota */\n\t__le32\ts_grp_quota_inum;\t/* inode for tracking group quota */\n\t__le32\ts_overhead_clusters;\t/* overhead blocks/clusters in fs */\n\t__le32\ts_backup_bgs[2];\t/* groups with sparse_super2 SBs */\n\t__u8\ts_encrypt_algos[4];\t/* Encryption algorithms in use  */\n\t__u8\ts_encrypt_pw_salt[16];\t/* Salt used for string2key algorithm */\n\t__le32\ts_lpf_ino;\t\t/* Location of the lost+found inode */\n\t__le32\ts_prj_quota_inum;\t/* inode for tracking project quota */\n\t__le32\ts_checksum_seed;\t/* crc32c(uuid) if csum_seed set */\n\t__u8\ts_wtime_hi;\n\t__u8\ts_mtime_hi;\n\t__u8\ts_mkfs_time_hi;\n\t__u8\ts_lastcheck_hi;\n\t__u8\ts_first_error_time_hi;\n\t__u8\ts_last_error_time_hi;\n\t__u8\ts_first_error_errcode;\n\t__u8    s_last_error_errcode;\n\t__le16  s_encoding;\t\t/* Filename charset encoding */\n\t__le16  s_encoding_flags;\t/* Filename charset encoding flags */\n\t__le32\ts_reserved[95];\t\t/* Padding to the end of the block */\n\t__le32\ts_checksum;\t\t/* crc32c(superblock) */\n};\n\n#define EXT4_S_ERR_LEN (EXT4_S_ERR_END - EXT4_S_ERR_START)\n\n#ifdef __KERNEL__\n\n/*\n * run-time mount flags\n */\n#define EXT4_MF_MNTDIR_SAMPLED\t\t0x0001\n#define EXT4_MF_FS_ABORTED\t\t0x0002\t/* Fatal error detected */\n\n#ifdef CONFIG_FS_ENCRYPTION\n#define DUMMY_ENCRYPTION_ENABLED(sbi) ((sbi)->s_dummy_enc_policy.policy != NULL)\n#else\n#define DUMMY_ENCRYPTION_ENABLED(sbi) (0)\n#endif\n\n/* Number of quota types we support */\n#define EXT4_MAXQUOTAS 3\n\n#define EXT4_ENC_UTF8_12_1\t1\n\n/*\n * Flags for ext4_sb_info.s_encoding_flags.\n */\n#define EXT4_ENC_STRICT_MODE_FL\t(1 << 0)\n\n#define ext4_has_strict_mode(sbi) \\\n\t(sbi->s_encoding_flags & EXT4_ENC_STRICT_MODE_FL)\n\n/*\n * fourth extended-fs super-block data in memory\n */\nstruct ext4_sb_info {\n\tunsigned long s_desc_size;\t/* Size of a group descriptor in bytes */\n\tunsigned long s_inodes_per_block;/* Number of inodes per block */\n\tunsigned long s_blocks_per_group;/* Number of blocks in a group */\n\tunsigned long s_clusters_per_group; /* Number of clusters in a group */\n\tunsigned long s_inodes_per_group;/* Number of inodes in a group */\n\tunsigned long s_itb_per_group;\t/* Number of inode table blocks per group */\n\tunsigned long s_gdb_count;\t/* Number of group descriptor blocks */\n\tunsigned long s_desc_per_block;\t/* Number of group descriptors per block */\n\text4_group_t s_groups_count;\t/* Number of groups in the fs */\n\text4_group_t s_blockfile_groups;/* Groups acceptable for non-extent files */\n\tunsigned long s_overhead;  /* # of fs overhead clusters */\n\tunsigned int s_cluster_ratio;\t/* Number of blocks per cluster */\n\tunsigned int s_cluster_bits;\t/* log2 of s_cluster_ratio */\n\tloff_t s_bitmap_maxbytes;\t/* max bytes for bitmap files */\n\tstruct buffer_head * s_sbh;\t/* Buffer containing the super block */\n\tstruct ext4_super_block *s_es;\t/* Pointer to the super block in the buffer */\n\tstruct buffer_head * __rcu *s_group_desc;\n\tunsigned int s_mount_opt;\n\tunsigned int s_mount_opt2;\n\tunsigned int s_mount_flags;\n\tunsigned int s_def_mount_opt;\n\text4_fsblk_t s_sb_block;\n\tatomic64_t s_resv_clusters;\n\tkuid_t s_resuid;\n\tkgid_t s_resgid;\n\tunsigned short s_mount_state;\n\tunsigned short s_pad;\n\tint s_addr_per_block_bits;\n\tint s_desc_per_block_bits;\n\tint s_inode_size;\n\tint s_first_ino;\n\tunsigned int s_inode_readahead_blks;\n\tunsigned int s_inode_goal;\n\tu32 s_hash_seed[4];\n\tint s_def_hash_version;\n\tint s_hash_unsigned;\t/* 3 if hash should be signed, 0 if not */\n\tstruct percpu_counter s_freeclusters_counter;\n\tstruct percpu_counter s_freeinodes_counter;\n\tstruct percpu_counter s_dirs_counter;\n\tstruct percpu_counter s_dirtyclusters_counter;\n\tstruct blockgroup_lock *s_blockgroup_lock;\n\tstruct proc_dir_entry *s_proc;\n\tstruct kobject s_kobj;\n\tstruct completion s_kobj_unregister;\n\tstruct super_block *s_sb;\n#ifdef CONFIG_UNICODE\n\tstruct unicode_map *s_encoding;\n\t__u16 s_encoding_flags;\n#endif\n\n\t/* Journaling */\n\tstruct journal_s *s_journal;\n\tstruct list_head s_orphan;\n\tstruct mutex s_orphan_lock;\n\tunsigned long s_ext4_flags;\t\t/* Ext4 superblock flags */\n\tunsigned long s_commit_interval;\n\tu32 s_max_batch_time;\n\tu32 s_min_batch_time;\n\tstruct block_device *s_journal_bdev;\n#ifdef CONFIG_QUOTA\n\t/* Names of quota files with journalled quota */\n\tchar __rcu *s_qf_names[EXT4_MAXQUOTAS];\n\tint s_jquota_fmt;\t\t\t/* Format of quota to use */\n#endif\n\tunsigned int s_want_extra_isize; /* New inodes should reserve # bytes */\n\tstruct ext4_system_blocks __rcu *s_system_blks;\n\n#ifdef EXTENTS_STATS\n\t/* ext4 extents stats */\n\tunsigned long s_ext_min;\n\tunsigned long s_ext_max;\n\tunsigned long s_depth_max;\n\tspinlock_t s_ext_stats_lock;\n\tunsigned long s_ext_blocks;\n\tunsigned long s_ext_extents;\n#endif\n\n\t/* for buddy allocator */\n\tstruct ext4_group_info ** __rcu *s_group_info;\n\tstruct inode *s_buddy_cache;\n\tspinlock_t s_md_lock;\n\tunsigned short *s_mb_offsets;\n\tunsigned int *s_mb_maxs;\n\tunsigned int s_group_info_size;\n\tunsigned int s_mb_free_pending;\n\tstruct list_head s_freed_data_list;\t/* List of blocks to be freed\n\t\t\t\t\t\t   after commit completed */\n\n\t/* tunables */\n\tunsigned long s_stripe;\n\tunsigned int s_mb_stream_request;\n\tunsigned int s_mb_max_to_scan;\n\tunsigned int s_mb_min_to_scan;\n\tunsigned int s_mb_stats;\n\tunsigned int s_mb_order2_reqs;\n\tunsigned int s_mb_group_prealloc;\n\tunsigned int s_mb_max_inode_prealloc;\n\tunsigned int s_max_dir_size_kb;\n\t/* where last allocation was done - for stream allocation */\n\tunsigned long s_mb_last_group;\n\tunsigned long s_mb_last_start;\n\tunsigned int s_mb_prefetch;\n\tunsigned int s_mb_prefetch_limit;\n\n\t/* stats for buddy allocator */\n\tatomic_t s_bal_reqs;\t/* number of reqs with len > 1 */\n\tatomic_t s_bal_success;\t/* we found long enough chunks */\n\tatomic_t s_bal_allocated;\t/* in blocks */\n\tatomic_t s_bal_ex_scanned;\t/* total extents scanned */\n\tatomic_t s_bal_goals;\t/* goal hits */\n\tatomic_t s_bal_breaks;\t/* too long searches */\n\tatomic_t s_bal_2orders;\t/* 2^order hits */\n\tspinlock_t s_bal_lock;\n\tunsigned long s_mb_buddies_generated;\n\tunsigned long long s_mb_generation_time;\n\tatomic_t s_mb_lost_chunks;\n\tatomic_t s_mb_preallocated;\n\tatomic_t s_mb_discarded;\n\tatomic_t s_lock_busy;\n\n\t/* locality groups */\n\tstruct ext4_locality_group __percpu *s_locality_groups;\n\n\t/* for write statistics */\n\tunsigned long s_sectors_written_start;\n\tu64 s_kbytes_written;\n\n\t/* the size of zero-out chunk */\n\tunsigned int s_extent_max_zeroout_kb;\n\n\tunsigned int s_log_groups_per_flex;\n\tstruct flex_groups * __rcu *s_flex_groups;\n\text4_group_t s_flex_groups_allocated;\n\n\t/* workqueue for reserved extent conversions (buffered io) */\n\tstruct workqueue_struct *rsv_conversion_wq;\n\n\t/* timer for periodic error stats printing */\n\tstruct timer_list s_err_report;\n\n\t/* Lazy inode table initialization info */\n\tstruct ext4_li_request *s_li_request;\n\t/* Wait multiplier for lazy initialization thread */\n\tunsigned int s_li_wait_mult;\n\n\t/* Kernel thread for multiple mount protection */\n\tstruct task_struct *s_mmp_tsk;\n\n\t/* record the last minlen when FITRIM is called. */\n\tatomic_t s_last_trim_minblks;\n\n\t/* Reference to checksum algorithm driver via cryptoapi */\n\tstruct crypto_shash *s_chksum_driver;\n\n\t/* Precomputed FS UUID checksum for seeding other checksums */\n\t__u32 s_csum_seed;\n\n\t/* Reclaim extents from extent status tree */\n\tstruct shrinker s_es_shrinker;\n\tstruct list_head s_es_list;\t/* List of inodes with reclaimable extents */\n\tlong s_es_nr_inode;\n\tstruct ext4_es_stats s_es_stats;\n\tstruct mb_cache *s_ea_block_cache;\n\tstruct mb_cache *s_ea_inode_cache;\n\tspinlock_t s_es_lock ____cacheline_aligned_in_smp;\n\n\t/* Ratelimit ext4 messages. */\n\tstruct ratelimit_state s_err_ratelimit_state;\n\tstruct ratelimit_state s_warning_ratelimit_state;\n\tstruct ratelimit_state s_msg_ratelimit_state;\n\tatomic_t s_warning_count;\n\tatomic_t s_msg_count;\n\n\t/* Encryption policy for '-o test_dummy_encryption' */\n\tstruct fscrypt_dummy_policy s_dummy_enc_policy;\n\n\t/*\n\t * Barrier between writepages ops and changing any inode's JOURNAL_DATA\n\t * or EXTENTS flag.\n\t */\n\tstruct percpu_rw_semaphore s_writepages_rwsem;\n\tstruct dax_device *s_daxdev;\n#ifdef CONFIG_EXT4_DEBUG\n\tunsigned long s_simulate_fail;\n#endif\n\t/* Record the errseq of the backing block device */\n\terrseq_t s_bdev_wb_err;\n\tspinlock_t s_bdev_wb_lock;\n\n\t/* Ext4 fast commit stuff */\n\tatomic_t s_fc_subtid;\n\tatomic_t s_fc_ineligible_updates;\n\t/*\n\t * After commit starts, the main queue gets locked, and the further\n\t * updates get added in the staging queue.\n\t */\n#define FC_Q_MAIN\t0\n#define FC_Q_STAGING\t1\n\tstruct list_head s_fc_q[2];\t/* Inodes staged for fast commit\n\t\t\t\t\t * that have data changes in them.\n\t\t\t\t\t */\n\tstruct list_head s_fc_dentry_q[2];\t/* directory entry updates */\n\tunsigned int s_fc_bytes;\n\t/*\n\t * Main fast commit lock. This lock protects accesses to the\n\t * following fields:\n\t * ei->i_fc_list, s_fc_dentry_q, s_fc_q, s_fc_bytes, s_fc_bh.\n\t */\n\tspinlock_t s_fc_lock;\n\tstruct buffer_head *s_fc_bh;\n\tstruct ext4_fc_stats s_fc_stats;\n\tu64 s_fc_avg_commit_time;\n#ifdef CONFIG_EXT4_DEBUG\n\tint s_fc_debug_max_replay;\n#endif\n\tstruct ext4_fc_replay_state s_fc_replay_state;\n};\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}\n\nstatic inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT4_ROOT_INO ||\n\t\t(ino >= EXT4_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count));\n}\n\n/*\n * Returns: sbi->field[index]\n * Used to access an array element from the following sbi fields which require\n * rcu protection to avoid dereferencing an invalid pointer due to reassignment\n * - s_group_desc\n * - s_group_info\n * - s_flex_group\n */\n#define sbi_array_rcu_deref(sbi, field, index)\t\t\t\t   \\\n({\t\t\t\t\t\t\t\t\t   \\\n\ttypeof(*((sbi)->field)) _v;\t\t\t\t\t   \\\n\trcu_read_lock();\t\t\t\t\t\t   \\\n\t_v = ((typeof(_v)*)rcu_dereference((sbi)->field))[index];\t   \\\n\trcu_read_unlock();\t\t\t\t\t\t   \\\n\t_v;\t\t\t\t\t\t\t\t   \\\n})\n\n/*\n * Simulate_fail codes\n */\n#define EXT4_SIM_BBITMAP_EIO\t1\n#define EXT4_SIM_BBITMAP_CRC\t2\n#define EXT4_SIM_IBITMAP_EIO\t3\n#define EXT4_SIM_IBITMAP_CRC\t4\n#define EXT4_SIM_INODE_EIO\t5\n#define EXT4_SIM_INODE_CRC\t6\n#define EXT4_SIM_DIRBLOCK_EIO\t7\n#define EXT4_SIM_DIRBLOCK_CRC\t8\n\nstatic inline bool ext4_simulate_fail(struct super_block *sb,\n\t\t\t\t     unsigned long code)\n{\n#ifdef CONFIG_EXT4_DEBUG\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (unlikely(sbi->s_simulate_fail == code)) {\n\t\tsbi->s_simulate_fail = 0;\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic inline void ext4_simulate_fail_bh(struct super_block *sb,\n\t\t\t\t\t struct buffer_head *bh,\n\t\t\t\t\t unsigned long code)\n{\n\tif (!IS_ERR(bh) && ext4_simulate_fail(sb, code))\n\t\tclear_buffer_uptodate(bh);\n}\n\n/*\n * Error number codes for s_{first,last}_error_errno\n *\n * Linux errno numbers are architecture specific, so we need to translate\n * them into something which is architecture independent.   We don't define\n * codes for all errno's; just the ones which are most likely to be the cause\n * of an ext4_error() call.\n */\n#define EXT4_ERR_UNKNOWN\t 1\n#define EXT4_ERR_EIO\t\t 2\n#define EXT4_ERR_ENOMEM\t\t 3\n#define EXT4_ERR_EFSBADCRC\t 4\n#define EXT4_ERR_EFSCORRUPTED\t 5\n#define EXT4_ERR_ENOSPC\t\t 6\n#define EXT4_ERR_ENOKEY\t\t 7\n#define EXT4_ERR_EROFS\t\t 8\n#define EXT4_ERR_EFBIG\t\t 9\n#define EXT4_ERR_EEXIST\t\t10\n#define EXT4_ERR_ERANGE\t\t11\n#define EXT4_ERR_EOVERFLOW\t12\n#define EXT4_ERR_EBUSY\t\t13\n#define EXT4_ERR_ENOTDIR\t14\n#define EXT4_ERR_ENOTEMPTY\t15\n#define EXT4_ERR_ESHUTDOWN\t16\n#define EXT4_ERR_EFAULT\t\t17\n\n/*\n * Inode dynamic state flags\n */\nenum {\n\tEXT4_STATE_JDATA,\t\t/* journaled data exists */\n\tEXT4_STATE_NEW,\t\t\t/* inode is newly created */\n\tEXT4_STATE_XATTR,\t\t/* has in-inode xattrs */\n\tEXT4_STATE_NO_EXPAND,\t\t/* No space for expansion */\n\tEXT4_STATE_DA_ALLOC_CLOSE,\t/* Alloc DA blks on close */\n\tEXT4_STATE_EXT_MIGRATE,\t\t/* Inode is migrating */\n\tEXT4_STATE_NEWENTRY,\t\t/* File just added to dir */\n\tEXT4_STATE_MAY_INLINE_DATA,\t/* may have in-inode data */\n\tEXT4_STATE_EXT_PRECACHED,\t/* extents have been precached */\n\tEXT4_STATE_LUSTRE_EA_INODE,\t/* Lustre-style ea_inode */\n\tEXT4_STATE_VERITY_IN_PROGRESS,\t/* building fs-verity Merkle tree */\n\tEXT4_STATE_FC_COMMITTING,\t/* Fast commit ongoing */\n};\n\n#define EXT4_INODE_BIT_FNS(name, field, offset)\t\t\t\t\\\nstatic inline int ext4_test_inode_##name(struct inode *inode, int bit)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn test_bit(bit + (offset), &EXT4_I(inode)->i_##field);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void ext4_set_inode_##name(struct inode *inode, int bit)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tset_bit(bit + (offset), &EXT4_I(inode)->i_##field);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void ext4_clear_inode_##name(struct inode *inode, int bit) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tclear_bit(bit + (offset), &EXT4_I(inode)->i_##field);\t\t\\\n}\n\n/* Add these declarations here only so that these functions can be\n * found by name.  Otherwise, they are very hard to locate. */\nstatic inline int ext4_test_inode_flag(struct inode *inode, int bit);\nstatic inline void ext4_set_inode_flag(struct inode *inode, int bit);\nstatic inline void ext4_clear_inode_flag(struct inode *inode, int bit);\nEXT4_INODE_BIT_FNS(flag, flags, 0)\n\n/* Add these declarations here only so that these functions can be\n * found by name.  Otherwise, they are very hard to locate. */\nstatic inline int ext4_test_inode_state(struct inode *inode, int bit);\nstatic inline void ext4_set_inode_state(struct inode *inode, int bit);\nstatic inline void ext4_clear_inode_state(struct inode *inode, int bit);\n#if (BITS_PER_LONG < 64)\nEXT4_INODE_BIT_FNS(state, state_flags, 0)\n\nstatic inline void ext4_clear_state_flags(struct ext4_inode_info *ei)\n{\n\t(ei)->i_state_flags = 0;\n}\n#else\nEXT4_INODE_BIT_FNS(state, flags, 32)\n\nstatic inline void ext4_clear_state_flags(struct ext4_inode_info *ei)\n{\n\t/* We depend on the fact that callers will set i_flags */\n}\n#endif\n#else\n/* Assume that user mode programs are passing in an ext4fs superblock, not\n * a kernel struct super_block.  This will allow us to call the feature-test\n * macros from user land. */\n#define EXT4_SB(sb)\t(sb)\n#endif\n\nstatic inline bool ext4_verity_in_progress(struct inode *inode)\n{\n\treturn IS_ENABLED(CONFIG_FS_VERITY) &&\n\t       ext4_test_inode_state(inode, EXT4_STATE_VERITY_IN_PROGRESS);\n}\n\n#define NEXT_ORPHAN(inode) EXT4_I(inode)->i_dtime\n\n/*\n * Codes for operating systems\n */\n#define EXT4_OS_LINUX\t\t0\n#define EXT4_OS_HURD\t\t1\n#define EXT4_OS_MASIX\t\t2\n#define EXT4_OS_FREEBSD\t\t3\n#define EXT4_OS_LITES\t\t4\n\n/*\n * Revision levels\n */\n#define EXT4_GOOD_OLD_REV\t0\t/* The good old (original) format */\n#define EXT4_DYNAMIC_REV\t1\t/* V2 format w/ dynamic inode sizes */\n\n#define EXT4_CURRENT_REV\tEXT4_GOOD_OLD_REV\n#define EXT4_MAX_SUPP_REV\tEXT4_DYNAMIC_REV\n\n#define EXT4_GOOD_OLD_INODE_SIZE 128\n\n#define EXT4_EXTRA_TIMESTAMP_MAX\t(((s64)1 << 34) - 1  + S32_MIN)\n#define EXT4_NON_EXTRA_TIMESTAMP_MAX\tS32_MAX\n#define EXT4_TIMESTAMP_MIN\t\tS32_MIN\n\n/*\n * Feature set definitions\n */\n\n#define EXT4_FEATURE_COMPAT_DIR_PREALLOC\t0x0001\n#define EXT4_FEATURE_COMPAT_IMAGIC_INODES\t0x0002\n#define EXT4_FEATURE_COMPAT_HAS_JOURNAL\t\t0x0004\n#define EXT4_FEATURE_COMPAT_EXT_ATTR\t\t0x0008\n#define EXT4_FEATURE_COMPAT_RESIZE_INODE\t0x0010\n#define EXT4_FEATURE_COMPAT_DIR_INDEX\t\t0x0020\n#define EXT4_FEATURE_COMPAT_SPARSE_SUPER2\t0x0200\n#define EXT4_FEATURE_COMPAT_FAST_COMMIT\t\t0x0400\n#define EXT4_FEATURE_COMPAT_STABLE_INODES\t0x0800\n\n#define EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER\t0x0001\n#define EXT4_FEATURE_RO_COMPAT_LARGE_FILE\t0x0002\n#define EXT4_FEATURE_RO_COMPAT_BTREE_DIR\t0x0004\n#define EXT4_FEATURE_RO_COMPAT_HUGE_FILE        0x0008\n#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010\n#define EXT4_FEATURE_RO_COMPAT_DIR_NLINK\t0x0020\n#define EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE\t0x0040\n#define EXT4_FEATURE_RO_COMPAT_QUOTA\t\t0x0100\n#define EXT4_FEATURE_RO_COMPAT_BIGALLOC\t\t0x0200\n/*\n * METADATA_CSUM also enables group descriptor checksums (GDT_CSUM).  When\n * METADATA_CSUM is set, group descriptor checksums use the same algorithm as\n * all other data structures' checksums.  However, the METADATA_CSUM and\n * GDT_CSUM bits are mutually exclusive.\n */\n#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400\n#define EXT4_FEATURE_RO_COMPAT_READONLY\t\t0x1000\n#define EXT4_FEATURE_RO_COMPAT_PROJECT\t\t0x2000\n#define EXT4_FEATURE_RO_COMPAT_VERITY\t\t0x8000\n\n#define EXT4_FEATURE_INCOMPAT_COMPRESSION\t0x0001\n#define EXT4_FEATURE_INCOMPAT_FILETYPE\t\t0x0002\n#define EXT4_FEATURE_INCOMPAT_RECOVER\t\t0x0004 /* Needs recovery */\n#define EXT4_FEATURE_INCOMPAT_JOURNAL_DEV\t0x0008 /* Journal device */\n#define EXT4_FEATURE_INCOMPAT_META_BG\t\t0x0010\n#define EXT4_FEATURE_INCOMPAT_EXTENTS\t\t0x0040 /* extents support */\n#define EXT4_FEATURE_INCOMPAT_64BIT\t\t0x0080\n#define EXT4_FEATURE_INCOMPAT_MMP               0x0100\n#define EXT4_FEATURE_INCOMPAT_FLEX_BG\t\t0x0200\n#define EXT4_FEATURE_INCOMPAT_EA_INODE\t\t0x0400 /* EA in inode */\n#define EXT4_FEATURE_INCOMPAT_DIRDATA\t\t0x1000 /* data in dirent */\n#define EXT4_FEATURE_INCOMPAT_CSUM_SEED\t\t0x2000\n#define EXT4_FEATURE_INCOMPAT_LARGEDIR\t\t0x4000 /* >2GB or 3-lvl htree */\n#define EXT4_FEATURE_INCOMPAT_INLINE_DATA\t0x8000 /* data in inode */\n#define EXT4_FEATURE_INCOMPAT_ENCRYPT\t\t0x10000\n#define EXT4_FEATURE_INCOMPAT_CASEFOLD\t\t0x20000\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\n\n#define EXT4_FEATURE_COMPAT_FUNCS(name, flagname) \\\nstatic inline bool ext4_has_feature_##name(struct super_block *sb) \\\n{ \\\n\treturn ((EXT4_SB(sb)->s_es->s_feature_compat & \\\n\t\tcpu_to_le32(EXT4_FEATURE_COMPAT_##flagname)) != 0); \\\n} \\\nstatic inline void ext4_set_feature_##name(struct super_block *sb) \\\n{ \\\n\text4_update_dynamic_rev(sb); \\\n\tEXT4_SB(sb)->s_es->s_feature_compat |= \\\n\t\tcpu_to_le32(EXT4_FEATURE_COMPAT_##flagname); \\\n} \\\nstatic inline void ext4_clear_feature_##name(struct super_block *sb) \\\n{ \\\n\tEXT4_SB(sb)->s_es->s_feature_compat &= \\\n\t\t~cpu_to_le32(EXT4_FEATURE_COMPAT_##flagname); \\\n}\n\n#define EXT4_FEATURE_RO_COMPAT_FUNCS(name, flagname) \\\nstatic inline bool ext4_has_feature_##name(struct super_block *sb) \\\n{ \\\n\treturn ((EXT4_SB(sb)->s_es->s_feature_ro_compat & \\\n\t\tcpu_to_le32(EXT4_FEATURE_RO_COMPAT_##flagname)) != 0); \\\n} \\\nstatic inline void ext4_set_feature_##name(struct super_block *sb) \\\n{ \\\n\text4_update_dynamic_rev(sb); \\\n\tEXT4_SB(sb)->s_es->s_feature_ro_compat |= \\\n\t\tcpu_to_le32(EXT4_FEATURE_RO_COMPAT_##flagname); \\\n} \\\nstatic inline void ext4_clear_feature_##name(struct super_block *sb) \\\n{ \\\n\tEXT4_SB(sb)->s_es->s_feature_ro_compat &= \\\n\t\t~cpu_to_le32(EXT4_FEATURE_RO_COMPAT_##flagname); \\\n}\n\n#define EXT4_FEATURE_INCOMPAT_FUNCS(name, flagname) \\\nstatic inline bool ext4_has_feature_##name(struct super_block *sb) \\\n{ \\\n\treturn ((EXT4_SB(sb)->s_es->s_feature_incompat & \\\n\t\tcpu_to_le32(EXT4_FEATURE_INCOMPAT_##flagname)) != 0); \\\n} \\\nstatic inline void ext4_set_feature_##name(struct super_block *sb) \\\n{ \\\n\text4_update_dynamic_rev(sb); \\\n\tEXT4_SB(sb)->s_es->s_feature_incompat |= \\\n\t\tcpu_to_le32(EXT4_FEATURE_INCOMPAT_##flagname); \\\n} \\\nstatic inline void ext4_clear_feature_##name(struct super_block *sb) \\\n{ \\\n\tEXT4_SB(sb)->s_es->s_feature_incompat &= \\\n\t\t~cpu_to_le32(EXT4_FEATURE_INCOMPAT_##flagname); \\\n}\n\nEXT4_FEATURE_COMPAT_FUNCS(dir_prealloc,\t\tDIR_PREALLOC)\nEXT4_FEATURE_COMPAT_FUNCS(imagic_inodes,\tIMAGIC_INODES)\nEXT4_FEATURE_COMPAT_FUNCS(journal,\t\tHAS_JOURNAL)\nEXT4_FEATURE_COMPAT_FUNCS(xattr,\t\tEXT_ATTR)\nEXT4_FEATURE_COMPAT_FUNCS(resize_inode,\t\tRESIZE_INODE)\nEXT4_FEATURE_COMPAT_FUNCS(dir_index,\t\tDIR_INDEX)\nEXT4_FEATURE_COMPAT_FUNCS(sparse_super2,\tSPARSE_SUPER2)\nEXT4_FEATURE_COMPAT_FUNCS(fast_commit,\t\tFAST_COMMIT)\nEXT4_FEATURE_COMPAT_FUNCS(stable_inodes,\tSTABLE_INODES)\n\nEXT4_FEATURE_RO_COMPAT_FUNCS(sparse_super,\tSPARSE_SUPER)\nEXT4_FEATURE_RO_COMPAT_FUNCS(large_file,\tLARGE_FILE)\nEXT4_FEATURE_RO_COMPAT_FUNCS(btree_dir,\t\tBTREE_DIR)\nEXT4_FEATURE_RO_COMPAT_FUNCS(huge_file,\t\tHUGE_FILE)\nEXT4_FEATURE_RO_COMPAT_FUNCS(gdt_csum,\t\tGDT_CSUM)\nEXT4_FEATURE_RO_COMPAT_FUNCS(dir_nlink,\t\tDIR_NLINK)\nEXT4_FEATURE_RO_COMPAT_FUNCS(extra_isize,\tEXTRA_ISIZE)\nEXT4_FEATURE_RO_COMPAT_FUNCS(quota,\t\tQUOTA)\nEXT4_FEATURE_RO_COMPAT_FUNCS(bigalloc,\t\tBIGALLOC)\nEXT4_FEATURE_RO_COMPAT_FUNCS(metadata_csum,\tMETADATA_CSUM)\nEXT4_FEATURE_RO_COMPAT_FUNCS(readonly,\t\tREADONLY)\nEXT4_FEATURE_RO_COMPAT_FUNCS(project,\t\tPROJECT)\nEXT4_FEATURE_RO_COMPAT_FUNCS(verity,\t\tVERITY)\n\nEXT4_FEATURE_INCOMPAT_FUNCS(compression,\tCOMPRESSION)\nEXT4_FEATURE_INCOMPAT_FUNCS(filetype,\t\tFILETYPE)\nEXT4_FEATURE_INCOMPAT_FUNCS(journal_needs_recovery,\tRECOVER)\nEXT4_FEATURE_INCOMPAT_FUNCS(journal_dev,\tJOURNAL_DEV)\nEXT4_FEATURE_INCOMPAT_FUNCS(meta_bg,\t\tMETA_BG)\nEXT4_FEATURE_INCOMPAT_FUNCS(extents,\t\tEXTENTS)\nEXT4_FEATURE_INCOMPAT_FUNCS(64bit,\t\t64BIT)\nEXT4_FEATURE_INCOMPAT_FUNCS(mmp,\t\tMMP)\nEXT4_FEATURE_INCOMPAT_FUNCS(flex_bg,\t\tFLEX_BG)\nEXT4_FEATURE_INCOMPAT_FUNCS(ea_inode,\t\tEA_INODE)\nEXT4_FEATURE_INCOMPAT_FUNCS(dirdata,\t\tDIRDATA)\nEXT4_FEATURE_INCOMPAT_FUNCS(csum_seed,\t\tCSUM_SEED)\nEXT4_FEATURE_INCOMPAT_FUNCS(largedir,\t\tLARGEDIR)\nEXT4_FEATURE_INCOMPAT_FUNCS(inline_data,\tINLINE_DATA)\nEXT4_FEATURE_INCOMPAT_FUNCS(encrypt,\t\tENCRYPT)\nEXT4_FEATURE_INCOMPAT_FUNCS(casefold,\t\tCASEFOLD)\n\n#define EXT2_FEATURE_COMPAT_SUPP\tEXT4_FEATURE_COMPAT_EXT_ATTR\n#define EXT2_FEATURE_INCOMPAT_SUPP\t(EXT4_FEATURE_INCOMPAT_FILETYPE| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_META_BG)\n#define EXT2_FEATURE_RO_COMPAT_SUPP\t(EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_LARGE_FILE| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_BTREE_DIR)\n\n#define EXT3_FEATURE_COMPAT_SUPP\tEXT4_FEATURE_COMPAT_EXT_ATTR\n#define EXT3_FEATURE_INCOMPAT_SUPP\t(EXT4_FEATURE_INCOMPAT_FILETYPE| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_RECOVER| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_META_BG)\n#define EXT3_FEATURE_RO_COMPAT_SUPP\t(EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_LARGE_FILE| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_BTREE_DIR)\n\n#define EXT4_FEATURE_COMPAT_SUPP\tEXT4_FEATURE_COMPAT_EXT_ATTR\n#define EXT4_FEATURE_INCOMPAT_SUPP\t(EXT4_FEATURE_INCOMPAT_FILETYPE| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_RECOVER| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_META_BG| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_EXTENTS| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_64BIT| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_FLEX_BG| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_EA_INODE| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_MMP | \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_INLINE_DATA | \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_ENCRYPT | \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_CASEFOLD | \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_CSUM_SEED | \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_LARGEDIR)\n#define EXT4_FEATURE_RO_COMPAT_SUPP\t(EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_LARGE_FILE| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_GDT_CSUM| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_DIR_NLINK | \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE | \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_BTREE_DIR |\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_HUGE_FILE |\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_BIGALLOC |\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_METADATA_CSUM|\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_QUOTA |\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_PROJECT |\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_VERITY)\n\n#define EXTN_FEATURE_FUNCS(ver) \\\nstatic inline bool ext4_has_unknown_ext##ver##_compat_features(struct super_block *sb) \\\n{ \\\n\treturn ((EXT4_SB(sb)->s_es->s_feature_compat & \\\n\t\tcpu_to_le32(~EXT##ver##_FEATURE_COMPAT_SUPP)) != 0); \\\n} \\\nstatic inline bool ext4_has_unknown_ext##ver##_ro_compat_features(struct super_block *sb) \\\n{ \\\n\treturn ((EXT4_SB(sb)->s_es->s_feature_ro_compat & \\\n\t\tcpu_to_le32(~EXT##ver##_FEATURE_RO_COMPAT_SUPP)) != 0); \\\n} \\\nstatic inline bool ext4_has_unknown_ext##ver##_incompat_features(struct super_block *sb) \\\n{ \\\n\treturn ((EXT4_SB(sb)->s_es->s_feature_incompat & \\\n\t\tcpu_to_le32(~EXT##ver##_FEATURE_INCOMPAT_SUPP)) != 0); \\\n}\n\nEXTN_FEATURE_FUNCS(2)\nEXTN_FEATURE_FUNCS(3)\nEXTN_FEATURE_FUNCS(4)\n\nstatic inline bool ext4_has_compat_features(struct super_block *sb)\n{\n\treturn (EXT4_SB(sb)->s_es->s_feature_compat != 0);\n}\nstatic inline bool ext4_has_ro_compat_features(struct super_block *sb)\n{\n\treturn (EXT4_SB(sb)->s_es->s_feature_ro_compat != 0);\n}\nstatic inline bool ext4_has_incompat_features(struct super_block *sb)\n{\n\treturn (EXT4_SB(sb)->s_es->s_feature_incompat != 0);\n}\n\n/*\n * Superblock flags\n */\n#define EXT4_FLAGS_RESIZING\t0\n#define EXT4_FLAGS_SHUTDOWN\t1\n#define EXT4_FLAGS_BDEV_IS_DAX\t2\n\nstatic inline int ext4_forced_shutdown(struct ext4_sb_info *sbi)\n{\n\treturn test_bit(EXT4_FLAGS_SHUTDOWN, &sbi->s_ext4_flags);\n}\n\n\n/*\n * Default values for user and/or group using reserved blocks\n */\n#define\tEXT4_DEF_RESUID\t\t0\n#define\tEXT4_DEF_RESGID\t\t0\n\n/*\n * Default project ID\n */\n#define\tEXT4_DEF_PROJID\t\t0\n\n#define EXT4_DEF_INODE_READAHEAD_BLKS\t32\n\n/*\n * Default mount options\n */\n#define EXT4_DEFM_DEBUG\t\t0x0001\n#define EXT4_DEFM_BSDGROUPS\t0x0002\n#define EXT4_DEFM_XATTR_USER\t0x0004\n#define EXT4_DEFM_ACL\t\t0x0008\n#define EXT4_DEFM_UID16\t\t0x0010\n#define EXT4_DEFM_JMODE\t\t0x0060\n#define EXT4_DEFM_JMODE_DATA\t0x0020\n#define EXT4_DEFM_JMODE_ORDERED\t0x0040\n#define EXT4_DEFM_JMODE_WBACK\t0x0060\n#define EXT4_DEFM_NOBARRIER\t0x0100\n#define EXT4_DEFM_BLOCK_VALIDITY 0x0200\n#define EXT4_DEFM_DISCARD\t0x0400\n#define EXT4_DEFM_NODELALLOC\t0x0800\n\n/*\n * Default journal batch times\n */\n#define EXT4_DEF_MIN_BATCH_TIME\t0\n#define EXT4_DEF_MAX_BATCH_TIME\t15000 /* 15ms */\n\n/*\n * Minimum number of groups in a flexgroup before we separate out\n * directories into the first block group of a flexgroup\n */\n#define EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME\t4\n\n/*\n * Structure of a directory entry\n */\n#define EXT4_NAME_LEN 255\n\nstruct ext4_dir_entry {\n\t__le32\tinode;\t\t\t/* Inode number */\n\t__le16\trec_len;\t\t/* Directory entry length */\n\t__le16\tname_len;\t\t/* Name length */\n\tchar\tname[EXT4_NAME_LEN];\t/* File name */\n};\n\n/*\n * The new version of the directory entry.  Since EXT4 structures are\n * stored in intel byte order, and the name_len field could never be\n * bigger than 255 chars, it's safe to reclaim the extra byte for the\n * file_type field.\n */\nstruct ext4_dir_entry_2 {\n\t__le32\tinode;\t\t\t/* Inode number */\n\t__le16\trec_len;\t\t/* Directory entry length */\n\t__u8\tname_len;\t\t/* Name length */\n\t__u8\tfile_type;\t\t/* See file type macros EXT4_FT_* below */\n\tchar\tname[EXT4_NAME_LEN];\t/* File name */\n};\n\n/*\n * This is a bogus directory entry at the end of each leaf block that\n * records checksums.\n */\nstruct ext4_dir_entry_tail {\n\t__le32\tdet_reserved_zero1;\t/* Pretend to be unused */\n\t__le16\tdet_rec_len;\t\t/* 12 */\n\t__u8\tdet_reserved_zero2;\t/* Zero name length */\n\t__u8\tdet_reserved_ft;\t/* 0xDE, fake file type */\n\t__le32\tdet_checksum;\t\t/* crc32c(uuid+inum+dirblock) */\n};\n\n#define EXT4_DIRENT_TAIL(block, blocksize) \\\n\t((struct ext4_dir_entry_tail *)(((void *)(block)) + \\\n\t\t\t\t\t((blocksize) - \\\n\t\t\t\t\t sizeof(struct ext4_dir_entry_tail))))\n\n/*\n * Ext4 directory file types.  Only the low 3 bits are used.  The\n * other bits are reserved for now.\n */\n#define EXT4_FT_UNKNOWN\t\t0\n#define EXT4_FT_REG_FILE\t1\n#define EXT4_FT_DIR\t\t2\n#define EXT4_FT_CHRDEV\t\t3\n#define EXT4_FT_BLKDEV\t\t4\n#define EXT4_FT_FIFO\t\t5\n#define EXT4_FT_SOCK\t\t6\n#define EXT4_FT_SYMLINK\t\t7\n\n#define EXT4_FT_MAX\t\t8\n\n#define EXT4_FT_DIR_CSUM\t0xDE\n\n/*\n * EXT4_DIR_PAD defines the directory entries boundaries\n *\n * NOTE: It must be a multiple of 4\n */\n#define EXT4_DIR_PAD\t\t\t4\n#define EXT4_DIR_ROUND\t\t\t(EXT4_DIR_PAD - 1)\n#define EXT4_DIR_REC_LEN(name_len)\t(((name_len) + 8 + EXT4_DIR_ROUND) & \\\n\t\t\t\t\t ~EXT4_DIR_ROUND)\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\n/*\n * If we ever get support for fs block sizes > page_size, we'll need\n * to remove the #if statements in the next two functions...\n */\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}\n\nstatic inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tif ((len > blocksize) || (blocksize > (1 << 18)) || (len & 3))\n\t\tBUG();\n#if (PAGE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}\n\n/*\n * Hash Tree Directory indexing\n * (c) Daniel Phillips, 2001\n */\n\n#define is_dx(dir) (ext4_has_feature_dir_index((dir)->i_sb) && \\\n\t\t    ext4_test_inode_flag((dir), EXT4_INODE_INDEX))\n#define EXT4_DIR_LINK_MAX(dir) unlikely((dir)->i_nlink >= EXT4_LINK_MAX && \\\n\t\t    !(ext4_has_feature_dir_nlink((dir)->i_sb) && is_dx(dir)))\n#define EXT4_DIR_LINK_EMPTY(dir) ((dir)->i_nlink == 2 || (dir)->i_nlink == 1)\n\n/* Legal values for the dx_root hash_version field: */\n\n#define DX_HASH_LEGACY\t\t\t0\n#define DX_HASH_HALF_MD4\t\t1\n#define DX_HASH_TEA\t\t\t2\n#define DX_HASH_LEGACY_UNSIGNED\t\t3\n#define DX_HASH_HALF_MD4_UNSIGNED\t4\n#define DX_HASH_TEA_UNSIGNED\t\t5\n\nstatic inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\t*(u32 *)desc.ctx = crc;\n\n\tBUG_ON(crypto_shash_update(&desc.shash, address, length));\n\n\treturn *(u32 *)desc.ctx;\n}\n\n#ifdef __KERNEL__\n\n/* hash info structure used by the directory hash */\nstruct dx_hash_info\n{\n\tu32\t\thash;\n\tu32\t\tminor_hash;\n\tint\t\thash_version;\n\tu32\t\t*seed;\n};\n\n\n/* 32 and 64 bit signed EOF for dx directories */\n#define EXT4_HTREE_EOF_32BIT   ((1UL  << (32 - 1)) - 1)\n#define EXT4_HTREE_EOF_64BIT   ((1ULL << (64 - 1)) - 1)\n\n\n/*\n * Control parameters used by ext4_htree_next_block\n */\n#define HASH_NB_ALWAYS\t\t1\n\nstruct ext4_filename {\n\tconst struct qstr *usr_fname;\n\tstruct fscrypt_str disk_name;\n\tstruct dx_hash_info hinfo;\n#ifdef CONFIG_FS_ENCRYPTION\n\tstruct fscrypt_str crypto_buf;\n#endif\n#ifdef CONFIG_UNICODE\n\tstruct fscrypt_str cf_name;\n#endif\n};\n\n#define fname_name(p) ((p)->disk_name.name)\n#define fname_len(p)  ((p)->disk_name.len)\n\n/*\n * Describe an inode's exact location on disk and in memory\n */\nstruct ext4_iloc\n{\n\tstruct buffer_head *bh;\n\tunsigned long offset;\n\text4_group_t block_group;\n};\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}\n\nstatic inline bool ext4_is_quota_file(struct inode *inode)\n{\n\treturn IS_NOQUOTA(inode) &&\n\t       !(EXT4_I(inode)->i_flags & EXT4_EA_INODE_FL);\n}\n\n/*\n * This structure is stuffed into the struct file's private_data field\n * for directories.  It is where we put information so that we can do\n * readdir operations in hash tree order.\n */\nstruct dir_private_info {\n\tstruct rb_root\troot;\n\tstruct rb_node\t*curr_node;\n\tstruct fname\t*extra_fname;\n\tloff_t\t\tlast_pos;\n\t__u32\t\tcurr_hash;\n\t__u32\t\tcurr_minor_hash;\n\t__u32\t\tnext_hash;\n};\n\n/* calculate the first block number of the group */\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}\n\n/*\n * Special error return code only used by dx_probe() and its callers.\n */\n#define ERR_BAD_DX_DIR\t(-(MAX_ERRNO - 1))\n\n/* htree levels for ext4 */\n#define\tEXT4_HTREE_LEVEL_COMPAT\t2\n#define\tEXT4_HTREE_LEVEL\t3\n\nstatic inline int ext4_dir_htree_level(struct super_block *sb)\n{\n\treturn ext4_has_feature_largedir(sb) ?\n\t\tEXT4_HTREE_LEVEL : EXT4_HTREE_LEVEL_COMPAT;\n}\n\n/*\n * Timeout and state flag for lazy initialization inode thread.\n */\n#define EXT4_DEF_LI_WAIT_MULT\t\t\t10\n#define EXT4_DEF_LI_MAX_START_DELAY\t\t5\n#define EXT4_LAZYINIT_QUIT\t\t\t0x0001\n#define EXT4_LAZYINIT_RUNNING\t\t\t0x0002\n\n/*\n * Lazy inode table initialization info\n */\nstruct ext4_lazy_init {\n\tunsigned long\t\tli_state;\n\tstruct list_head\tli_request_list;\n\tstruct mutex\t\tli_list_mtx;\n};\n\nenum ext4_li_mode {\n\tEXT4_LI_MODE_PREFETCH_BBITMAP,\n\tEXT4_LI_MODE_ITABLE,\n};\n\nstruct ext4_li_request {\n\tstruct super_block\t*lr_super;\n\tenum ext4_li_mode\tlr_mode;\n\text4_group_t\t\tlr_first_not_zeroed;\n\text4_group_t\t\tlr_next_group;\n\tstruct list_head\tlr_request;\n\tunsigned long\t\tlr_next_sched;\n\tunsigned long\t\tlr_timeout;\n};\n\nstruct ext4_features {\n\tstruct kobject f_kobj;\n\tstruct completion f_kobj_unregister;\n};\n\n/*\n * This structure will be used for multiple mount protection. It will be\n * written into the block number saved in the s_mmp_block field in the\n * superblock. Programs that check MMP should assume that if\n * SEQ_FSCK (or any unknown code above SEQ_MAX) is present then it is NOT safe\n * to use the filesystem, regardless of how old the timestamp is.\n */\n#define EXT4_MMP_MAGIC     0x004D4D50U /* ASCII for MMP */\n#define EXT4_MMP_SEQ_CLEAN 0xFF4D4D50U /* mmp_seq value for clean unmount */\n#define EXT4_MMP_SEQ_FSCK  0xE24D4D50U /* mmp_seq value when being fscked */\n#define EXT4_MMP_SEQ_MAX   0xE24D4D4FU /* maximum valid mmp_seq value */\n\nstruct mmp_struct {\n\t__le32\tmmp_magic;\t\t/* Magic number for MMP */\n\t__le32\tmmp_seq;\t\t/* Sequence no. updated periodically */\n\n\t/*\n\t * mmp_time, mmp_nodename & mmp_bdevname are only used for information\n\t * purposes and do not affect the correctness of the algorithm\n\t */\n\t__le64\tmmp_time;\t\t/* Time last updated */\n\tchar\tmmp_nodename[64];\t/* Node which last updated MMP block */\n\tchar\tmmp_bdevname[32];\t/* Bdev which last updated MMP block */\n\n\t/*\n\t * mmp_check_interval is used to verify if the MMP block has been\n\t * updated on the block device. The value is updated based on the\n\t * maximum time to write the MMP block during an update cycle.\n\t */\n\t__le16\tmmp_check_interval;\n\n\t__le16\tmmp_pad1;\n\t__le32\tmmp_pad2[226];\n\t__le32\tmmp_checksum;\t\t/* crc32c(uuid+mmp_block) */\n};\n\n/* arguments passed to the mmp thread */\nstruct mmpd_data {\n\tstruct buffer_head *bh; /* bh from initial read_mmp_block() */\n\tstruct super_block *sb;  /* super block of the fs */\n};\n\n/*\n * Check interval multiplier\n * The MMP block is written every update interval and initially checked every\n * update interval x the multiplier (the value is then adapted based on the\n * write latency). The reason is that writes can be delayed under load and we\n * don't want readers to incorrectly assume that the filesystem is no longer\n * in use.\n */\n#define EXT4_MMP_CHECK_MULT\t\t2UL\n\n/*\n * Minimum interval for MMP checking in seconds.\n */\n#define EXT4_MMP_MIN_CHECK_INTERVAL\t5UL\n\n/*\n * Maximum interval for MMP checking in seconds.\n */\n#define EXT4_MMP_MAX_CHECK_INTERVAL\t300UL\n\n/*\n * Function prototypes\n */\n\n/*\n * Ok, these declarations are also in <linux/kernel.h> but none of the\n * ext4 source programs needs to include it so they are duplicated here.\n */\n# define NORET_TYPE\t/**/\n# define ATTRIB_NORET\t__attribute__((noreturn))\n# define NORET_AND\tnoreturn,\n\n/* bitmap.c */\nextern unsigned int ext4_count_free(char *bitmap, unsigned numchars);\nvoid ext4_inode_bitmap_csum_set(struct super_block *sb, ext4_group_t group,\n\t\t\t\tstruct ext4_group_desc *gdp,\n\t\t\t\tstruct buffer_head *bh, int sz);\nint ext4_inode_bitmap_csum_verify(struct super_block *sb, ext4_group_t group,\n\t\t\t\t  struct ext4_group_desc *gdp,\n\t\t\t\t  struct buffer_head *bh, int sz);\nvoid ext4_block_bitmap_csum_set(struct super_block *sb, ext4_group_t group,\n\t\t\t\tstruct ext4_group_desc *gdp,\n\t\t\t\tstruct buffer_head *bh);\nint ext4_block_bitmap_csum_verify(struct super_block *sb, ext4_group_t group,\n\t\t\t\t  struct ext4_group_desc *gdp,\n\t\t\t\t  struct buffer_head *bh);\n\n/* balloc.c */\nextern void ext4_get_group_no_and_offset(struct super_block *sb,\n\t\t\t\t\t ext4_fsblk_t blocknr,\n\t\t\t\t\t ext4_group_t *blockgrpp,\n\t\t\t\t\t ext4_grpblk_t *offsetp);\nextern ext4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t\t  ext4_fsblk_t block);\n\nextern unsigned int ext4_block_group(struct super_block *sb,\n\t\t\text4_fsblk_t blocknr);\nextern ext4_grpblk_t ext4_block_group_offset(struct super_block *sb,\n\t\t\text4_fsblk_t blocknr);\nextern int ext4_bg_has_super(struct super_block *sb, ext4_group_t group);\nextern unsigned long ext4_bg_num_gdb(struct super_block *sb,\n\t\t\text4_group_t group);\nextern ext4_fsblk_t ext4_new_meta_blocks(handle_t *handle, struct inode *inode,\n\t\t\t\t\t ext4_fsblk_t goal,\n\t\t\t\t\t unsigned int flags,\n\t\t\t\t\t unsigned long *count,\n\t\t\t\t\t int *errp);\nextern int ext4_claim_free_clusters(struct ext4_sb_info *sbi,\n\t\t\t\t    s64 nclusters, unsigned int flags);\nextern ext4_fsblk_t ext4_count_free_clusters(struct super_block *);\nextern void ext4_check_blocks_bitmap(struct super_block *);\nextern struct ext4_group_desc * ext4_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);\nextern int ext4_should_retry_alloc(struct super_block *sb, int *retries);\n\nextern struct buffer_head *ext4_read_block_bitmap_nowait(struct super_block *sb,\n\t\t\t\t\t\text4_group_t block_group,\n\t\t\t\t\t\tbool ignore_locked);\nextern int ext4_wait_block_bitmap(struct super_block *sb,\n\t\t\t\t  ext4_group_t block_group,\n\t\t\t\t  struct buffer_head *bh);\nextern struct buffer_head *ext4_read_block_bitmap(struct super_block *sb,\n\t\t\t\t\t\t  ext4_group_t block_group);\nextern unsigned ext4_free_clusters_after_init(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t block_group,\n\t\t\t\t\t      struct ext4_group_desc *gdp);\next4_fsblk_t ext4_inode_to_goal_block(struct inode *);\n\n#ifdef CONFIG_UNICODE\nextern void ext4_fname_setup_ci_filename(struct inode *dir,\n\t\t\t\t\t const struct qstr *iname,\n\t\t\t\t\t struct fscrypt_str *fname);\n#endif\n\n#ifdef CONFIG_FS_ENCRYPTION\nstatic inline void ext4_fname_from_fscrypt_name(struct ext4_filename *dst,\n\t\t\t\t\t\tconst struct fscrypt_name *src)\n{\n\tmemset(dst, 0, sizeof(*dst));\n\n\tdst->usr_fname = src->usr_fname;\n\tdst->disk_name = src->disk_name;\n\tdst->hinfo.hash = src->hash;\n\tdst->hinfo.minor_hash = src->minor_hash;\n\tdst->crypto_buf = src->crypto_buf;\n}\n\nstatic inline int ext4_fname_setup_filename(struct inode *dir,\n\t\t\t\t\t    const struct qstr *iname,\n\t\t\t\t\t    int lookup,\n\t\t\t\t\t    struct ext4_filename *fname)\n{\n\tstruct fscrypt_name name;\n\tint err;\n\n\terr = fscrypt_setup_filename(dir, iname, lookup, &name);\n\tif (err)\n\t\treturn err;\n\n\text4_fname_from_fscrypt_name(fname, &name);\n\n#ifdef CONFIG_UNICODE\n\text4_fname_setup_ci_filename(dir, iname, &fname->cf_name);\n#endif\n\treturn 0;\n}\n\nstatic inline int ext4_fname_prepare_lookup(struct inode *dir,\n\t\t\t\t\t    struct dentry *dentry,\n\t\t\t\t\t    struct ext4_filename *fname)\n{\n\tstruct fscrypt_name name;\n\tint err;\n\n\terr = fscrypt_prepare_lookup(dir, dentry, &name);\n\tif (err)\n\t\treturn err;\n\n\text4_fname_from_fscrypt_name(fname, &name);\n\n#ifdef CONFIG_UNICODE\n\text4_fname_setup_ci_filename(dir, &dentry->d_name, &fname->cf_name);\n#endif\n\treturn 0;\n}\n\nstatic inline void ext4_fname_free_filename(struct ext4_filename *fname)\n{\n\tstruct fscrypt_name name;\n\n\tname.crypto_buf = fname->crypto_buf;\n\tfscrypt_free_filename(&name);\n\n\tfname->crypto_buf.name = NULL;\n\tfname->usr_fname = NULL;\n\tfname->disk_name.name = NULL;\n\n#ifdef CONFIG_UNICODE\n\tkfree(fname->cf_name.name);\n\tfname->cf_name.name = NULL;\n#endif\n}\n#else /* !CONFIG_FS_ENCRYPTION */\nstatic inline int ext4_fname_setup_filename(struct inode *dir,\n\t\t\t\t\t    const struct qstr *iname,\n\t\t\t\t\t    int lookup,\n\t\t\t\t\t    struct ext4_filename *fname)\n{\n\tfname->usr_fname = iname;\n\tfname->disk_name.name = (unsigned char *) iname->name;\n\tfname->disk_name.len = iname->len;\n\n#ifdef CONFIG_UNICODE\n\text4_fname_setup_ci_filename(dir, iname, &fname->cf_name);\n#endif\n\n\treturn 0;\n}\n\nstatic inline int ext4_fname_prepare_lookup(struct inode *dir,\n\t\t\t\t\t    struct dentry *dentry,\n\t\t\t\t\t    struct ext4_filename *fname)\n{\n\treturn ext4_fname_setup_filename(dir, &dentry->d_name, 1, fname);\n}\n\nstatic inline void ext4_fname_free_filename(struct ext4_filename *fname)\n{\n#ifdef CONFIG_UNICODE\n\tkfree(fname->cf_name.name);\n\tfname->cf_name.name = NULL;\n#endif\n}\n#endif /* !CONFIG_FS_ENCRYPTION */\n\n/* dir.c */\nextern int __ext4_check_dir_entry(const char *, unsigned int, struct inode *,\n\t\t\t\t  struct file *,\n\t\t\t\t  struct ext4_dir_entry_2 *,\n\t\t\t\t  struct buffer_head *, char *, int,\n\t\t\t\t  unsigned int);\n#define ext4_check_dir_entry(dir, filp, de, bh, buf, size, offset)\t\\\n\tunlikely(__ext4_check_dir_entry(__func__, __LINE__, (dir), (filp), \\\n\t\t\t\t\t(de), (bh), (buf), (size), (offset)))\nextern int ext4_htree_store_dirent(struct file *dir_file, __u32 hash,\n\t\t\t\t__u32 minor_hash,\n\t\t\t\tstruct ext4_dir_entry_2 *dirent,\n\t\t\t\tstruct fscrypt_str *ent_name);\nextern void ext4_htree_free_dir_info(struct dir_private_info *p);\nextern int ext4_find_dest_de(struct inode *dir, struct inode *inode,\n\t\t\t     struct buffer_head *bh,\n\t\t\t     void *buf, int buf_size,\n\t\t\t     struct ext4_filename *fname,\n\t\t\t     struct ext4_dir_entry_2 **dest_de);\nvoid ext4_insert_dentry(struct inode *inode,\n\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\tint buf_size,\n\t\t\tstruct ext4_filename *fname);\nstatic inline void ext4_update_dx_flag(struct inode *inode)\n{\n\tif (!ext4_has_feature_dir_index(inode->i_sb)) {\n\t\t/* ext4_iget() should have caught this... */\n\t\tWARN_ON_ONCE(ext4_has_feature_metadata_csum(inode->i_sb));\n\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n\t}\n}\nstatic const unsigned char ext4_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};\n\nstatic inline  unsigned char get_dtype(struct super_block *sb, int filetype)\n{\n\tif (!ext4_has_feature_filetype(sb) || filetype >= EXT4_FT_MAX)\n\t\treturn DT_UNKNOWN;\n\n\treturn ext4_filetype_table[filetype];\n}\nextern int ext4_check_all_de(struct inode *dir, struct buffer_head *bh,\n\t\t\t     void *buf, int buf_size);\n\n/* fsync.c */\nextern int ext4_sync_file(struct file *, loff_t, loff_t, int);\n\n/* hash.c */\nextern int ext4fs_dirhash(const struct inode *dir, const char *name, int len,\n\t\t\t  struct dx_hash_info *hinfo);\n\n/* ialloc.c */\nextern int ext4_mark_inode_used(struct super_block *sb, int ino);\nextern struct inode *__ext4_new_inode(handle_t *, struct inode *, umode_t,\n\t\t\t\t      const struct qstr *qstr, __u32 goal,\n\t\t\t\t      uid_t *owner, __u32 i_flags,\n\t\t\t\t      int handle_type, unsigned int line_no,\n\t\t\t\t      int nblocks);\n\n#define ext4_new_inode(handle, dir, mode, qstr, goal, owner, i_flags) \\\n\t__ext4_new_inode((handle), (dir), (mode), (qstr), (goal), (owner), \\\n\t\t\t i_flags, 0, 0, 0)\n#define ext4_new_inode_start_handle(dir, mode, qstr, goal, owner, \\\n\t\t\t\t    type, nblocks)\t\t    \\\n\t__ext4_new_inode(NULL, (dir), (mode), (qstr), (goal), (owner), \\\n\t\t\t 0, (type), __LINE__, (nblocks))\n\n\nextern void ext4_free_inode(handle_t *, struct inode *);\nextern struct inode * ext4_orphan_get(struct super_block *, unsigned long);\nextern unsigned long ext4_count_free_inodes(struct super_block *);\nextern unsigned long ext4_count_dirs(struct super_block *);\nextern void ext4_check_inodes_bitmap(struct super_block *);\nextern void ext4_mark_bitmap_end(int start_bit, int end_bit, char *bitmap);\nextern int ext4_init_inode_table(struct super_block *sb,\n\t\t\t\t ext4_group_t group, int barrier);\nextern void ext4_end_bitmap_read(struct buffer_head *bh, int uptodate);\n\n/* fast_commit.c */\nint ext4_fc_info_show(struct seq_file *seq, void *v);\nvoid ext4_fc_init(struct super_block *sb, journal_t *journal);\nvoid ext4_fc_init_inode(struct inode *inode);\nvoid ext4_fc_track_range(struct inode *inode, ext4_lblk_t start,\n\t\t\t ext4_lblk_t end);\nvoid ext4_fc_track_unlink(struct inode *inode, struct dentry *dentry);\nvoid ext4_fc_track_link(struct inode *inode, struct dentry *dentry);\nvoid ext4_fc_track_create(struct inode *inode, struct dentry *dentry);\nvoid ext4_fc_track_inode(struct inode *inode);\nvoid ext4_fc_mark_ineligible(struct super_block *sb, int reason);\nvoid ext4_fc_start_ineligible(struct super_block *sb, int reason);\nvoid ext4_fc_stop_ineligible(struct super_block *sb);\nvoid ext4_fc_start_update(struct inode *inode);\nvoid ext4_fc_stop_update(struct inode *inode);\nvoid ext4_fc_del(struct inode *inode);\nbool ext4_fc_replay_check_excluded(struct super_block *sb, ext4_fsblk_t block);\nvoid ext4_fc_replay_cleanup(struct super_block *sb);\nint ext4_fc_commit(journal_t *journal, tid_t commit_tid);\nint __init ext4_fc_init_dentry_cache(void);\n\n/* mballoc.c */\nextern const struct seq_operations ext4_mb_seq_groups_ops;\nextern long ext4_mb_stats;\nextern long ext4_mb_max_to_scan;\nextern int ext4_mb_init(struct super_block *);\nextern int ext4_mb_release(struct super_block *);\nextern ext4_fsblk_t ext4_mb_new_blocks(handle_t *,\n\t\t\t\tstruct ext4_allocation_request *, int *);\nextern int ext4_mb_reserve_blocks(struct super_block *, int);\nextern void ext4_discard_preallocations(struct inode *, unsigned int);\nextern int __init ext4_init_mballoc(void);\nextern void ext4_exit_mballoc(void);\nextern ext4_group_t ext4_mb_prefetch(struct super_block *sb,\n\t\t\t\t     ext4_group_t group,\n\t\t\t\t     unsigned int nr, int *cnt);\nextern void ext4_mb_prefetch_fini(struct super_block *sb, ext4_group_t group,\n\t\t\t\t  unsigned int nr);\n\nextern void ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t\t     struct buffer_head *bh, ext4_fsblk_t block,\n\t\t\t     unsigned long count, int flags);\nextern int ext4_mb_alloc_groupinfo(struct super_block *sb,\n\t\t\t\t   ext4_group_t ngroups);\nextern int ext4_mb_add_groupinfo(struct super_block *sb,\n\t\text4_group_t i, struct ext4_group_desc *desc);\nextern int ext4_group_add_blocks(handle_t *handle, struct super_block *sb,\n\t\t\t\text4_fsblk_t block, unsigned long count);\nextern int ext4_trim_fs(struct super_block *, struct fstrim_range *);\nextern void ext4_process_freed_data(struct super_block *sb, tid_t commit_tid);\nextern void ext4_mb_mark_bb(struct super_block *sb, ext4_fsblk_t block,\n\t\t       int len, int state);\n\n/* inode.c */\nvoid ext4_inode_csum_set(struct inode *inode, struct ext4_inode *raw,\n\t\t\t struct ext4_inode_info *ei);\nint ext4_inode_is_fast_symlink(struct inode *inode);\nstruct buffer_head *ext4_getblk(handle_t *, struct inode *, ext4_lblk_t, int);\nstruct buffer_head *ext4_bread(handle_t *, struct inode *, ext4_lblk_t, int);\nint ext4_bread_batch(struct inode *inode, ext4_lblk_t block, int bh_count,\n\t\t     bool wait, struct buffer_head **bhs);\nint ext4_get_block_unwritten(struct inode *inode, sector_t iblock,\n\t\t\t     struct buffer_head *bh_result, int create);\nint ext4_get_block(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\nint ext4_da_get_block_prep(struct inode *inode, sector_t iblock,\n\t\t\t   struct buffer_head *bh, int create);\nint ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle,\n\t\t\t\t     struct buffer_head *bh));\nint do_journal_get_write_access(handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n#define FALL_BACK_TO_NONDELALLOC 1\n#define CONVERT_INLINE_DATA\t 2\n\ntypedef enum {\n\tEXT4_IGET_NORMAL =\t0,\n\tEXT4_IGET_SPECIAL =\t0x0001, /* OK to iget a system inode */\n\tEXT4_IGET_HANDLE = \t0x0002\t/* Inode # is from a handle */\n} ext4_iget_flags;\n\nextern struct inode *__ext4_iget(struct super_block *sb, unsigned long ino,\n\t\t\t\t ext4_iget_flags flags, const char *function,\n\t\t\t\t unsigned int line);\n\n#define ext4_iget(sb, ino, flags) \\\n\t__ext4_iget((sb), (ino), (flags), __func__, __LINE__)\n\nextern int  ext4_write_inode(struct inode *, struct writeback_control *);\nextern int  ext4_setattr(struct dentry *, struct iattr *);\nextern int  ext4_getattr(const struct path *, struct kstat *, u32, unsigned int);\nextern void ext4_evict_inode(struct inode *);\nextern void ext4_clear_inode(struct inode *);\nextern int  ext4_file_getattr(const struct path *, struct kstat *, u32, unsigned int);\nextern int  ext4_sync_inode(handle_t *, struct inode *);\nextern void ext4_dirty_inode(struct inode *, int);\nextern int ext4_change_inode_journal_flag(struct inode *, int);\nextern int ext4_get_inode_loc(struct inode *, struct ext4_iloc *);\nextern int ext4_get_fc_inode_loc(struct super_block *sb, unsigned long ino,\n\t\t\t  struct ext4_iloc *iloc);\nextern int ext4_inode_attach_jinode(struct inode *inode);\nextern int ext4_can_truncate(struct inode *inode);\nextern int ext4_truncate(struct inode *);\nextern int ext4_break_layouts(struct inode *);\nextern int ext4_punch_hole(struct inode *inode, loff_t offset, loff_t length);\nextern void ext4_set_inode_flags(struct inode *, bool init);\nextern int ext4_alloc_da_blocks(struct inode *inode);\nextern void ext4_set_aops(struct inode *inode);\nextern int ext4_writepage_trans_blocks(struct inode *);\nextern int ext4_chunk_trans_blocks(struct inode *, int nrblocks);\nextern int ext4_zero_partial_blocks(handle_t *handle, struct inode *inode,\n\t\t\t     loff_t lstart, loff_t lend);\nextern vm_fault_t ext4_page_mkwrite(struct vm_fault *vmf);\nextern vm_fault_t ext4_filemap_fault(struct vm_fault *vmf);\nextern qsize_t *ext4_get_reserved_space(struct inode *inode);\nextern int ext4_get_projid(struct inode *inode, kprojid_t *projid);\nextern void ext4_da_release_space(struct inode *inode, int to_free);\nextern void ext4_da_update_reserve_space(struct inode *inode,\n\t\t\t\t\tint used, int quota_claim);\nextern int ext4_issue_zeroout(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_fsblk_t pblk, ext4_lblk_t len);\n\n/* indirect.c */\nextern int ext4_ind_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_map_blocks *map, int flags);\nextern int ext4_ind_trans_blocks(struct inode *inode, int nrblocks);\nextern void ext4_ind_truncate(handle_t *, struct inode *inode);\nextern int ext4_ind_remove_space(handle_t *handle, struct inode *inode,\n\t\t\t\t ext4_lblk_t start, ext4_lblk_t end);\n\n/* ioctl.c */\nextern long ext4_ioctl(struct file *, unsigned int, unsigned long);\nextern long ext4_compat_ioctl(struct file *, unsigned int, unsigned long);\nextern void ext4_reset_inode_seed(struct inode *inode);\n\n/* migrate.c */\nextern int ext4_ext_migrate(struct inode *);\nextern int ext4_ind_migrate(struct inode *inode);\n\n/* namei.c */\nextern int ext4_init_new_dir(handle_t *handle, struct inode *dir,\n\t\t\t     struct inode *inode);\nextern int ext4_dirblock_csum_verify(struct inode *inode,\n\t\t\t\t     struct buffer_head *bh);\nextern int ext4_orphan_add(handle_t *, struct inode *);\nextern int ext4_orphan_del(handle_t *, struct inode *);\nextern int ext4_htree_fill_tree(struct file *dir_file, __u32 start_hash,\n\t\t\t\t__u32 start_minor_hash, __u32 *next_hash);\nextern int ext4_search_dir(struct buffer_head *bh,\n\t\t\t   char *search_buf,\n\t\t\t   int buf_size,\n\t\t\t   struct inode *dir,\n\t\t\t   struct ext4_filename *fname,\n\t\t\t   unsigned int offset,\n\t\t\t   struct ext4_dir_entry_2 **res_dir);\nextern int ext4_generic_delete_entry(struct inode *dir,\n\t\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     void *entry_buf,\n\t\t\t\t     int buf_size,\n\t\t\t\t     int csum_size);\nextern bool ext4_empty_dir(struct inode *inode);\n\n/* resize.c */\nextern void ext4_kvfree_array_rcu(void *to_free);\nextern int ext4_group_add(struct super_block *sb,\n\t\t\t\tstruct ext4_new_group_data *input);\nextern int ext4_group_extend(struct super_block *sb,\n\t\t\t\tstruct ext4_super_block *es,\n\t\t\t\text4_fsblk_t n_blocks_count);\nextern int ext4_resize_fs(struct super_block *sb, ext4_fsblk_t n_blocks_count);\n\n/* super.c */\nextern struct buffer_head *ext4_sb_bread(struct super_block *sb,\n\t\t\t\t\t sector_t block, int op_flags);\nextern struct buffer_head *ext4_sb_bread_unmovable(struct super_block *sb,\n\t\t\t\t\t\t   sector_t block);\nextern void ext4_read_bh_nowait(struct buffer_head *bh, int op_flags,\n\t\t\t\tbh_end_io_t *end_io);\nextern int ext4_read_bh(struct buffer_head *bh, int op_flags,\n\t\t\tbh_end_io_t *end_io);\nextern int ext4_read_bh_lock(struct buffer_head *bh, int op_flags, bool wait);\nextern void ext4_sb_breadahead_unmovable(struct super_block *sb, sector_t block);\nextern int ext4_seq_options_show(struct seq_file *seq, void *offset);\nextern int ext4_calculate_overhead(struct super_block *sb);\nextern void ext4_superblock_csum_set(struct super_block *sb);\nextern int ext4_alloc_flex_bg_array(struct super_block *sb,\n\t\t\t\t    ext4_group_t ngroup);\nextern const char *ext4_decode_error(struct super_block *sb, int errno,\n\t\t\t\t     char nbuf[16]);\nextern void ext4_mark_group_bitmap_corrupted(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     unsigned int flags);\n\nextern __printf(6, 7)\nvoid __ext4_error(struct super_block *, const char *, unsigned int, int, __u64,\n\t\t  const char *, ...);\nextern __printf(6, 7)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int,\n\t\t\text4_fsblk_t, int, const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(5, 6)\nvoid __ext4_abort(struct super_block *, const char *, unsigned int, int,\n\t\t  const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning_inode(const struct inode *inode, const char *function,\n\t\t\t  unsigned int line, const char *fmt, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#define EXT4_ERROR_INODE(inode, fmt, a...) \\\n\text4_error_inode((inode), __func__, __LINE__, 0, (fmt), ## a)\n\n#define EXT4_ERROR_INODE_ERR(inode, err, fmt, a...)\t\t\t\\\n\t__ext4_error_inode((inode), __func__, __LINE__, 0, (err), (fmt), ## a)\n\n#define ext4_error_inode_block(inode, block, err, fmt, a...)\t\t\\\n\t__ext4_error_inode((inode), __func__, __LINE__, (block), (err),\t\\\n\t\t\t   (fmt), ## a)\n\n#define EXT4_ERROR_FILE(file, block, fmt, a...)\t\t\t\t\\\n\text4_error_file((file), __func__, __LINE__, (block), (fmt), ## a)\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, 0, fmt, ##__VA_ARGS__)\n#define ext4_error_inode_err(inode, func, line, block, err, fmt, ...)\t\\\n\t__ext4_error_inode((inode), (func), (line), (block), \t\t\\\n\t\t\t   (err), (fmt), ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error((sb), __func__, __LINE__, 0, 0, (fmt), ##__VA_ARGS__)\n#define ext4_error_err(sb, err, fmt, ...)\t\t\t\t\\\n\t__ext4_error((sb), __func__, __LINE__, (err), 0, (fmt), ##__VA_ARGS__)\n#define ext4_abort(sb, err, fmt, ...)\t\t\t\t\t\\\n\t__ext4_abort((sb), __func__, __LINE__, (err), (fmt), ##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning_inode(inode, fmt, ...)\t\t\t\t\\\n\t__ext4_warning_inode(inode, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, 0, \" \");\t\t\\\n} while (0)\n#define ext4_error_inode_err(inode, func, line, block, err, fmt, ...)\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, err, \" \");\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, 0, 0, \" \");\t\t\t\t\\\n} while (0)\n#define ext4_error_err(sb, err, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, err, 0, \" \");\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, err, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, err, \" \");\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning_inode(inode, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning_inode(inode, \"\", 0, \" \");\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(ext4_has_feature_metadata_csum(sb) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn ext4_has_feature_metadata_csum(sb) &&\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn ext4_has_feature_gdt_csum(sb) || ext4_has_metadata_csum(sb);\n}\n\n#define ext4_read_incompat_64bit_val(es, name) \\\n\t(((es)->s_feature_incompat & cpu_to_le32(EXT4_FEATURE_INCOMPAT_64BIT) \\\n\t\t? (ext4_fsblk_t)le32_to_cpu(es->name##_hi) << 32 : 0) | \\\n\t\tle32_to_cpu(es->name##_lo))\n\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ext4_read_incompat_64bit_val(es, s_blocks_count);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ext4_read_incompat_64bit_val(es, s_r_blocks_count);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ext4_read_incompat_64bit_val(es, s_free_blocks_count);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct super_block *sb,\n\t\t\t\tstruct ext4_inode *raw_inode)\n{\n\tif (ext4_has_feature_largedir(sb) ||\n\t    S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\n\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info **grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t grp_info = sbi_array_rcu_deref(EXT4_SB(sb), s_group_info, indexv);\n\t return grp_info[indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !inode_is_locked(inode));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tWRITE_ONCE(EXT4_I(inode)->i_disksize, newsize);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nint ext4_update_disksize_before_punch(struct inode *inode, loff_t offset,\n\t\t\t\t      loff_t len);\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n#ifdef AGGRESSIVE_CHECK\n\tunsigned long\tbb_check_counter;\n#endif\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT\t\t\\\n\t(1 << EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT)\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT\t\t\\\n\t(1 << EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT)\n#define EXT4_GROUP_INFO_BBITMAP_READ_BIT\t4\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_TEST_AND_SET_READ(grp)\t\\\n\t(test_and_set_bit(EXT4_GROUP_INFO_BBITMAP_READ_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}\n\n/*\n * Returns true if the filesystem is busy enough that attempts to\n * access the block group locks has run into contention.\n */\nstatic inline int ext4_fs_is_busy(struct ext4_sb_info *sbi)\n{\n\treturn (atomic_read(&sbi->s_lock_busy) > EXT4_CONTENTION_THRESHOLD);\n}\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}\n\n/*\n * Block validity checking\n */\n#define ext4_check_indirect_blockref(inode, bh)\t\t\t\t\\\n\text4_check_blockref(__func__, __LINE__, inode,\t\t\t\\\n\t\t\t    (__le32 *)(bh)->b_data,\t\t\t\\\n\t\t\t    EXT4_ADDR_PER_BLOCK((inode)->i_sb))\n\n#define ext4_ind_check_inode(inode)\t\t\t\t\t\\\n\text4_check_blockref(__func__, __LINE__, inode,\t\t\t\\\n\t\t\t    EXT4_I(inode)->i_data,\t\t\t\\\n\t\t\t    EXT4_NDIR_BLOCKS)\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext4_dir_operations;\n\n#ifdef CONFIG_UNICODE\nextern const struct dentry_operations ext4_dentry_ops;\n#endif\n\n/* file.c */\nextern const struct inode_operations ext4_file_inode_operations;\nextern const struct file_operations ext4_file_operations;\nextern loff_t ext4_llseek(struct file *file, loff_t offset, int origin);\n\n/* inline.c */\nextern int ext4_get_max_inline_size(struct inode *inode);\nextern int ext4_find_inline_data_nolock(struct inode *inode);\nextern int ext4_init_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t unsigned int len);\nextern int ext4_destroy_inline_data(handle_t *handle, struct inode *inode);\n\nextern int ext4_readpage_inline(struct inode *inode, struct page *page);\nextern int ext4_try_to_write_inline_data(struct address_space *mapping,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t loff_t pos, unsigned len,\n\t\t\t\t\t unsigned flags,\n\t\t\t\t\t struct page **pagep);\nextern int ext4_write_inline_data_end(struct inode *inode,\n\t\t\t\t      loff_t pos, unsigned len,\n\t\t\t\t      unsigned copied,\n\t\t\t\t      struct page *page);\nextern struct buffer_head *\next4_journalled_write_inline_data(struct inode *inode,\n\t\t\t\t  unsigned len,\n\t\t\t\t  struct page *page);\nextern int ext4_da_write_inline_data_begin(struct address_space *mapping,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   loff_t pos, unsigned len,\n\t\t\t\t\t   unsigned flags,\n\t\t\t\t\t   struct page **pagep,\n\t\t\t\t\t   void **fsdata);\nextern int ext4_da_write_inline_data_end(struct inode *inode, loff_t pos,\n\t\t\t\t\t unsigned len, unsigned copied,\n\t\t\t\t\t struct page *page);\nextern int ext4_try_add_inline_entry(handle_t *handle,\n\t\t\t\t     struct ext4_filename *fname,\n\t\t\t\t     struct inode *dir, struct inode *inode);\nextern int ext4_try_create_inline_dir(handle_t *handle,\n\t\t\t\t      struct inode *parent,\n\t\t\t\t      struct inode *inode);\nextern int ext4_read_inline_dir(struct file *filp,\n\t\t\t\tstruct dir_context *ctx,\n\t\t\t\tint *has_inline_data);\nextern int ext4_inlinedir_to_tree(struct file *dir_file,\n\t\t\t\t  struct inode *dir, ext4_lblk_t block,\n\t\t\t\t  struct dx_hash_info *hinfo,\n\t\t\t\t  __u32 start_hash, __u32 start_minor_hash,\n\t\t\t\t  int *has_inline_data);\nextern struct buffer_head *ext4_find_inline_entry(struct inode *dir,\n\t\t\t\t\tstruct ext4_filename *fname,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *has_inline_data);\nextern int ext4_delete_inline_entry(handle_t *handle,\n\t\t\t\t    struct inode *dir,\n\t\t\t\t    struct ext4_dir_entry_2 *de_del,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    int *has_inline_data);\nextern bool empty_inline_dir(struct inode *dir, int *has_inline_data);\nextern struct buffer_head *ext4_get_first_inline_block(struct inode *inode,\n\t\t\t\t\tstruct ext4_dir_entry_2 **parent_de,\n\t\t\t\t\tint *retval);\nextern int ext4_inline_data_fiemap(struct inode *inode,\n\t\t\t\t   struct fiemap_extent_info *fieinfo,\n\t\t\t\t   int *has_inline, __u64 start, __u64 len);\n\nstruct iomap;\nextern int ext4_inline_data_iomap(struct inode *inode, struct iomap *iomap);\n\nextern int ext4_inline_data_truncate(struct inode *inode, int *has_inline);\n\nextern int ext4_convert_inline_data(struct inode *inode);\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}\n\n/* namei.c */\nextern const struct inode_operations ext4_dir_inode_operations;\nextern const struct inode_operations ext4_special_inode_operations;\nextern struct dentry *ext4_get_parent(struct dentry *child);\nextern struct ext4_dir_entry_2 *ext4_init_dot_dotdot(struct inode *inode,\n\t\t\t\t struct ext4_dir_entry_2 *de,\n\t\t\t\t int blocksize, int csum_size,\n\t\t\t\t unsigned int parent_ino, int dotdot_real_len);\nextern void ext4_initialize_dirent_tail(struct buffer_head *bh,\n\t\t\t\t\tunsigned int blocksize);\nextern int ext4_handle_dirty_dirblock(handle_t *handle, struct inode *inode,\n\t\t\t\t      struct buffer_head *bh);\nextern int ext4_ci_compare(const struct inode *parent,\n\t\t\t   const struct qstr *fname,\n\t\t\t   const struct qstr *entry, bool quick);\nextern int __ext4_unlink(struct inode *dir, const struct qstr *d_name,\n\t\t\t struct inode *inode);\nextern int __ext4_link(struct inode *dir, struct inode *inode,\n\t\t       struct dentry *dentry);\n\n#define S_SHIFT 12\nstatic const unsigned char ext4_type_by_mode[(S_IFMT >> S_SHIFT) + 1] = {\n\t[S_IFREG >> S_SHIFT]\t= EXT4_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= EXT4_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= EXT4_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= EXT4_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= EXT4_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= EXT4_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= EXT4_FT_SYMLINK,\n};\n\nstatic inline void ext4_set_de_type(struct super_block *sb,\n\t\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\t\tumode_t mode) {\n\tif (ext4_has_feature_filetype(sb))\n\t\tde->file_type = ext4_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}\n\n/* readpages.c */\nextern int ext4_mpage_readpages(struct inode *inode,\n\t\tstruct readahead_control *rac, struct page *page);\nextern int __init ext4_init_post_read_processing(void);\nextern void ext4_exit_post_read_processing(void);\n\n/* symlink.c */\nextern const struct inode_operations ext4_encrypted_symlink_inode_operations;\nextern const struct inode_operations ext4_symlink_inode_operations;\nextern const struct inode_operations ext4_fast_symlink_inode_operations;\n\n/* sysfs.c */\nextern int ext4_register_sysfs(struct super_block *sb);\nextern void ext4_unregister_sysfs(struct super_block *sb);\nextern int __init ext4_init_sysfs(void);\nextern void ext4_exit_sysfs(void);\n\n/* block_validity */\nextern void ext4_release_system_zone(struct super_block *sb);\nextern int ext4_setup_system_zone(struct super_block *sb);\nextern int __init ext4_init_system_zone(void);\nextern void ext4_exit_system_zone(void);\nextern int ext4_inode_block_valid(struct inode *inode,\n\t\t\t\t  ext4_fsblk_t start_blk,\n\t\t\t\t  unsigned int count);\nextern int ext4_check_blockref(const char *, unsigned int,\n\t\t\t       struct inode *, __le32 *, unsigned int);\n\n/* extents.c */\nstruct ext4_ext_path;\nstruct ext4_extent;\n\n/*\n * Maximum number of logical blocks in a file; ext4_extent's ee_block is\n * __le32.\n */\n#define EXT_MAX_BLOCKS\t0xffffffff\n\nextern void ext4_ext_tree_init(handle_t *handle, struct inode *inode);\nextern int ext4_ext_index_trans_blocks(struct inode *inode, int extents);\nextern int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\t       struct ext4_map_blocks *map, int flags);\nextern int ext4_ext_truncate(handle_t *, struct inode *);\nextern int ext4_ext_remove_space(struct inode *inode, ext4_lblk_t start,\n\t\t\t\t ext4_lblk_t end);\nextern void ext4_ext_init(struct super_block *);\nextern void ext4_ext_release(struct super_block *);\nextern long ext4_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\t  loff_t len);\nextern int ext4_convert_unwritten_extents(handle_t *handle, struct inode *inode,\n\t\t\t\t\t  loff_t offset, ssize_t len);\nextern int ext4_convert_unwritten_io_end_vec(handle_t *handle,\n\t\t\t\t\t     ext4_io_end_t *io_end);\nextern int ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\t   struct ext4_map_blocks *map, int flags);\nextern int ext4_ext_calc_credits_for_single_extent(struct inode *inode,\n\t\t\t\t\t\t   int num,\n\t\t\t\t\t\t   struct ext4_ext_path *path);\nextern int ext4_ext_insert_extent(handle_t *, struct inode *,\n\t\t\t\t  struct ext4_ext_path **,\n\t\t\t\t  struct ext4_extent *, int);\nextern struct ext4_ext_path *ext4_find_extent(struct inode *, ext4_lblk_t,\n\t\t\t\t\t      struct ext4_ext_path **,\n\t\t\t\t\t      int flags);\nextern void ext4_ext_drop_refs(struct ext4_ext_path *);\nextern int ext4_ext_check_inode(struct inode *inode);\nextern ext4_lblk_t ext4_ext_next_allocated_block(struct ext4_ext_path *path);\nextern int ext4_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t\t__u64 start, __u64 len);\nextern int ext4_get_es_cache(struct inode *inode,\n\t\t\t     struct fiemap_extent_info *fieinfo,\n\t\t\t     __u64 start, __u64 len);\nextern int ext4_ext_precache(struct inode *inode);\nextern int ext4_swap_extents(handle_t *handle, struct inode *inode1,\n\t\t\t\tstruct inode *inode2, ext4_lblk_t lblk1,\n\t\t\t     ext4_lblk_t lblk2,  ext4_lblk_t count,\n\t\t\t     int mark_unwritten,int *err);\nextern int ext4_clu_mapped(struct inode *inode, ext4_lblk_t lclu);\nextern int ext4_datasem_ensure_credits(handle_t *handle, struct inode *inode,\n\t\t\t\t       int check_cred, int restart_cred,\n\t\t\t\t       int revoke_cred);\nextern void ext4_ext_replay_shrink_inode(struct inode *inode, ext4_lblk_t end);\nextern int ext4_ext_replay_set_iblocks(struct inode *inode);\nextern int ext4_ext_replay_update_ex(struct inode *inode, ext4_lblk_t start,\n\t\tint len, int unwritten, ext4_fsblk_t pblk);\nextern int ext4_ext_clear_bb(struct inode *inode);\n\n\n/* move_extent.c */\nextern void ext4_double_down_write_data_sem(struct inode *first,\n\t\t\t\t\t    struct inode *second);\nextern void ext4_double_up_write_data_sem(struct inode *orig_inode,\n\t\t\t\t\t  struct inode *donor_inode);\nextern int ext4_move_extents(struct file *o_filp, struct file *d_filp,\n\t\t\t     __u64 start_orig, __u64 start_donor,\n\t\t\t     __u64 len, __u64 *moved_len);\n\n/* page-io.c */\nextern int __init ext4_init_pageio(void);\nextern void ext4_exit_pageio(void);\nextern ext4_io_end_t *ext4_init_io_end(struct inode *inode, gfp_t flags);\nextern ext4_io_end_t *ext4_get_io_end(ext4_io_end_t *io_end);\nextern int ext4_put_io_end(ext4_io_end_t *io_end);\nextern void ext4_put_io_end_defer(ext4_io_end_t *io_end);\nextern void ext4_io_submit_init(struct ext4_io_submit *io,\n\t\t\t\tstruct writeback_control *wbc);\nextern void ext4_end_io_rsv_work(struct work_struct *work);\nextern void ext4_io_submit(struct ext4_io_submit *io);\nextern int ext4_bio_write_page(struct ext4_io_submit *io,\n\t\t\t       struct page *page,\n\t\t\t       int len,\n\t\t\t       struct writeback_control *wbc,\n\t\t\t       bool keep_towrite);\nextern struct ext4_io_end_vec *ext4_alloc_io_end_vec(ext4_io_end_t *io_end);\nextern struct ext4_io_end_vec *ext4_last_io_end_vec(ext4_io_end_t *io_end);\n\n/* mmp.c */\nextern int ext4_multi_mount_protect(struct super_block *, ext4_fsblk_t);\n\n/* verity.c */\nextern const struct fsverity_operations ext4_verityops;\n\n/*\n * Add new method to test whether block and inode bitmaps are properly\n * initialized. With uninit_bg reading the block from disk is not enough\n * to mark the bitmap uptodate. We need to also zero-out the bitmap\n */\n#define BH_BITMAP_UPTODATE BH_JBDPrivateStart\n\nstatic inline int bitmap_uptodate(struct buffer_head *bh)\n{\n\treturn (buffer_uptodate(bh) &&\n\t\t\ttest_bit(BH_BITMAP_UPTODATE, &(bh)->b_state));\n}\nstatic inline void set_bitmap_uptodate(struct buffer_head *bh)\n{\n\tset_bit(BH_BITMAP_UPTODATE, &(bh)->b_state);\n}\n\n#define in_range(b, first, len)\t((b) >= (first) && (b) <= (first) + (len) - 1)\n\n/* For ioend & aio unwritten conversion wait queues */\n#define EXT4_WQ_HASH_SZ\t\t37\n#define ext4_ioend_wq(v)   (&ext4__ioend_wq[((unsigned long)(v)) %\\\n\t\t\t\t\t    EXT4_WQ_HASH_SZ])\nextern wait_queue_head_t ext4__ioend_wq[EXT4_WQ_HASH_SZ];\n\nextern int ext4_resize_begin(struct super_block *sb);\nextern void ext4_resize_end(struct super_block *sb);\n\nstatic inline void ext4_set_io_unwritten_flag(struct inode *inode,\n\t\t\t\t\t      struct ext4_io_end *io_end)\n{\n\tif (!(io_end->flag & EXT4_IO_END_UNWRITTEN)) {\n\t\tio_end->flag |= EXT4_IO_END_UNWRITTEN;\n\t\tatomic_inc(&EXT4_I(inode)->i_unwritten);\n\t}\n}\n\nstatic inline void ext4_clear_io_unwritten_flag(ext4_io_end_t *io_end)\n{\n\tstruct inode *inode = io_end->inode;\n\n\tif (io_end->flag & EXT4_IO_END_UNWRITTEN) {\n\t\tio_end->flag &= ~EXT4_IO_END_UNWRITTEN;\n\t\t/* Wake up anyone waiting on unwritten extent conversion */\n\t\tif (atomic_dec_and_test(&EXT4_I(inode)->i_unwritten))\n\t\t\twake_up_all(ext4_ioend_wq(inode));\n\t}\n}\n\nextern const struct iomap_ops ext4_iomap_ops;\nextern const struct iomap_ops ext4_iomap_overwrite_ops;\nextern const struct iomap_ops ext4_iomap_report_ops;\n\nstatic inline int ext4_buffer_uptodate(struct buffer_head *bh)\n{\n\t/*\n\t * If the buffer has the write error flag, we have failed\n\t * to write out data in the block.  In this  case, we don't\n\t * have to read the block because we may read the old data\n\t * successfully.\n\t */\n\tif (!buffer_uptodate(bh) && buffer_write_io_error(bh))\n\t\tset_buffer_uptodate(bh);\n\treturn buffer_uptodate(bh);\n}\n\n#endif\t/* __KERNEL__ */\n\n#define EFSBADCRC\tEBADMSG\t\t/* Bad CRC detected */\n#define EFSCORRUPTED\tEUCLEAN\t\t/* Filesystem is corrupted */\n\n#endif\t/* _EXT4_H */\n"}, "5": {"id": 5, "path": "/src/include/linux/fs.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_FS_H\n#define _LINUX_FS_H\n\n#include <linux/linkage.h>\n#include <linux/wait_bit.h>\n#include <linux/kdev_t.h>\n#include <linux/dcache.h>\n#include <linux/path.h>\n#include <linux/stat.h>\n#include <linux/cache.h>\n#include <linux/list.h>\n#include <linux/list_lru.h>\n#include <linux/llist.h>\n#include <linux/radix-tree.h>\n#include <linux/xarray.h>\n#include <linux/rbtree.h>\n#include <linux/init.h>\n#include <linux/pid.h>\n#include <linux/bug.h>\n#include <linux/mutex.h>\n#include <linux/rwsem.h>\n#include <linux/mm_types.h>\n#include <linux/capability.h>\n#include <linux/semaphore.h>\n#include <linux/fcntl.h>\n#include <linux/rculist_bl.h>\n#include <linux/atomic.h>\n#include <linux/shrinker.h>\n#include <linux/migrate_mode.h>\n#include <linux/uidgid.h>\n#include <linux/lockdep.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/workqueue.h>\n#include <linux/delayed_call.h>\n#include <linux/uuid.h>\n#include <linux/errseq.h>\n#include <linux/ioprio.h>\n#include <linux/fs_types.h>\n#include <linux/build_bug.h>\n#include <linux/stddef.h>\n\n#include <asm/byteorder.h>\n#include <uapi/linux/fs.h>\n\nstruct backing_dev_info;\nstruct bdi_writeback;\nstruct bio;\nstruct export_operations;\nstruct fiemap_extent_info;\nstruct hd_geometry;\nstruct iovec;\nstruct kiocb;\nstruct kobject;\nstruct pipe_inode_info;\nstruct poll_table_struct;\nstruct kstatfs;\nstruct vm_area_struct;\nstruct vfsmount;\nstruct cred;\nstruct swap_info_struct;\nstruct seq_file;\nstruct workqueue_struct;\nstruct iov_iter;\nstruct fscrypt_info;\nstruct fscrypt_operations;\nstruct fsverity_info;\nstruct fsverity_operations;\nstruct fs_context;\nstruct fs_parameter_spec;\n\nextern void __init inode_init(void);\nextern void __init inode_init_early(void);\nextern void __init files_init(void);\nextern void __init files_maxfiles_init(void);\n\nextern struct files_stat_struct files_stat;\nextern unsigned long get_max_files(void);\nextern unsigned int sysctl_nr_open;\nextern struct inodes_stat_t inodes_stat;\nextern int leases_enable, lease_break_time;\nextern int sysctl_protected_symlinks;\nextern int sysctl_protected_hardlinks;\nextern int sysctl_protected_fifos;\nextern int sysctl_protected_regular;\n\ntypedef __kernel_rwf_t rwf_t;\n\nstruct buffer_head;\ntypedef int (get_block_t)(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh_result, int create);\ntypedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,\n\t\t\tssize_t bytes, void *private);\n\n#define MAY_EXEC\t\t0x00000001\n#define MAY_WRITE\t\t0x00000002\n#define MAY_READ\t\t0x00000004\n#define MAY_APPEND\t\t0x00000008\n#define MAY_ACCESS\t\t0x00000010\n#define MAY_OPEN\t\t0x00000020\n#define MAY_CHDIR\t\t0x00000040\n/* called from RCU mode, don't block */\n#define MAY_NOT_BLOCK\t\t0x00000080\n\n/*\n * flags in file.f_mode.  Note that FMODE_READ and FMODE_WRITE must correspond\n * to O_WRONLY and O_RDWR via the strange trick in do_dentry_open()\n */\n\n/* file is open for reading */\n#define FMODE_READ\t\t((__force fmode_t)0x1)\n/* file is open for writing */\n#define FMODE_WRITE\t\t((__force fmode_t)0x2)\n/* file is seekable */\n#define FMODE_LSEEK\t\t((__force fmode_t)0x4)\n/* file can be accessed using pread */\n#define FMODE_PREAD\t\t((__force fmode_t)0x8)\n/* file can be accessed using pwrite */\n#define FMODE_PWRITE\t\t((__force fmode_t)0x10)\n/* File is opened for execution with sys_execve / sys_uselib */\n#define FMODE_EXEC\t\t((__force fmode_t)0x20)\n/* File is opened with O_NDELAY (only set for block devices) */\n#define FMODE_NDELAY\t\t((__force fmode_t)0x40)\n/* File is opened with O_EXCL (only set for block devices) */\n#define FMODE_EXCL\t\t((__force fmode_t)0x80)\n/* File is opened using open(.., 3, ..) and is writeable only for ioctls\n   (specialy hack for floppy.c) */\n#define FMODE_WRITE_IOCTL\t((__force fmode_t)0x100)\n/* 32bit hashes as llseek() offset (for directories) */\n#define FMODE_32BITHASH         ((__force fmode_t)0x200)\n/* 64bit hashes as llseek() offset (for directories) */\n#define FMODE_64BITHASH         ((__force fmode_t)0x400)\n\n/*\n * Don't update ctime and mtime.\n *\n * Currently a special hack for the XFS open_by_handle ioctl, but we'll\n * hopefully graduate it to a proper O_CMTIME flag supported by open(2) soon.\n */\n#define FMODE_NOCMTIME\t\t((__force fmode_t)0x800)\n\n/* Expect random access pattern */\n#define FMODE_RANDOM\t\t((__force fmode_t)0x1000)\n\n/* File is huge (eg. /dev/kmem): treat loff_t as unsigned */\n#define FMODE_UNSIGNED_OFFSET\t((__force fmode_t)0x2000)\n\n/* File is opened with O_PATH; almost nothing can be done with it */\n#define FMODE_PATH\t\t((__force fmode_t)0x4000)\n\n/* File needs atomic accesses to f_pos */\n#define FMODE_ATOMIC_POS\t((__force fmode_t)0x8000)\n/* Write access to underlying fs */\n#define FMODE_WRITER\t\t((__force fmode_t)0x10000)\n/* Has read method(s) */\n#define FMODE_CAN_READ          ((__force fmode_t)0x20000)\n/* Has write method(s) */\n#define FMODE_CAN_WRITE         ((__force fmode_t)0x40000)\n\n#define FMODE_OPENED\t\t((__force fmode_t)0x80000)\n#define FMODE_CREATED\t\t((__force fmode_t)0x100000)\n\n/* File is stream-like */\n#define FMODE_STREAM\t\t((__force fmode_t)0x200000)\n\n/* File was opened by fanotify and shouldn't generate fanotify events */\n#define FMODE_NONOTIFY\t\t((__force fmode_t)0x4000000)\n\n/* File is capable of returning -EAGAIN if I/O will block */\n#define FMODE_NOWAIT\t\t((__force fmode_t)0x8000000)\n\n/* File represents mount that needs unmounting */\n#define FMODE_NEED_UNMOUNT\t((__force fmode_t)0x10000000)\n\n/* File does not contribute to nr_files count */\n#define FMODE_NOACCOUNT\t\t((__force fmode_t)0x20000000)\n\n/* File supports async buffered reads */\n#define FMODE_BUF_RASYNC\t((__force fmode_t)0x40000000)\n\n/*\n * Attribute flags.  These should be or-ed together to figure out what\n * has been changed!\n */\n#define ATTR_MODE\t(1 << 0)\n#define ATTR_UID\t(1 << 1)\n#define ATTR_GID\t(1 << 2)\n#define ATTR_SIZE\t(1 << 3)\n#define ATTR_ATIME\t(1 << 4)\n#define ATTR_MTIME\t(1 << 5)\n#define ATTR_CTIME\t(1 << 6)\n#define ATTR_ATIME_SET\t(1 << 7)\n#define ATTR_MTIME_SET\t(1 << 8)\n#define ATTR_FORCE\t(1 << 9) /* Not a change, but a change it */\n#define ATTR_KILL_SUID\t(1 << 11)\n#define ATTR_KILL_SGID\t(1 << 12)\n#define ATTR_FILE\t(1 << 13)\n#define ATTR_KILL_PRIV\t(1 << 14)\n#define ATTR_OPEN\t(1 << 15) /* Truncating from open(O_TRUNC) */\n#define ATTR_TIMES_SET\t(1 << 16)\n#define ATTR_TOUCH\t(1 << 17)\n\n/*\n * Whiteout is represented by a char device.  The following constants define the\n * mode and device number to use.\n */\n#define WHITEOUT_MODE 0\n#define WHITEOUT_DEV 0\n\n/*\n * This is the Inode Attributes structure, used for notify_change().  It\n * uses the above definitions as flags, to know which values have changed.\n * Also, in this manner, a Filesystem can look at only the values it cares\n * about.  Basically, these are the attributes that the VFS layer can\n * request to change from the FS layer.\n *\n * Derek Atkins <warlord@MIT.EDU> 94-10-20\n */\nstruct iattr {\n\tunsigned int\tia_valid;\n\tumode_t\t\tia_mode;\n\tkuid_t\t\tia_uid;\n\tkgid_t\t\tia_gid;\n\tloff_t\t\tia_size;\n\tstruct timespec64 ia_atime;\n\tstruct timespec64 ia_mtime;\n\tstruct timespec64 ia_ctime;\n\n\t/*\n\t * Not an attribute, but an auxiliary info for filesystems wanting to\n\t * implement an ftruncate() like method.  NOTE: filesystem should\n\t * check for (ia_valid & ATTR_FILE), and not for (ia_file != NULL).\n\t */\n\tstruct file\t*ia_file;\n};\n\n/*\n * Includes for diskquotas.\n */\n#include <linux/quota.h>\n\n/*\n * Maximum number of layers of fs stack.  Needs to be limited to\n * prevent kernel stack overflow\n */\n#define FILESYSTEM_MAX_STACK_DEPTH 2\n\n/** \n * enum positive_aop_returns - aop return codes with specific semantics\n *\n * @AOP_WRITEPAGE_ACTIVATE: Informs the caller that page writeback has\n * \t\t\t    completed, that the page is still locked, and\n * \t\t\t    should be considered active.  The VM uses this hint\n * \t\t\t    to return the page to the active list -- it won't\n * \t\t\t    be a candidate for writeback again in the near\n * \t\t\t    future.  Other callers must be careful to unlock\n * \t\t\t    the page if they get this return.  Returned by\n * \t\t\t    writepage(); \n *\n * @AOP_TRUNCATED_PAGE: The AOP method that was handed a locked page has\n *  \t\t\tunlocked it and the page might have been truncated.\n *  \t\t\tThe caller should back up to acquiring a new page and\n *  \t\t\ttrying again.  The aop will be taking reasonable\n *  \t\t\tprecautions not to livelock.  If the caller held a page\n *  \t\t\treference, it should drop it before retrying.  Returned\n *  \t\t\tby readpage().\n *\n * address_space_operation functions return these large constants to indicate\n * special semantics to the caller.  These are much larger than the bytes in a\n * page to allow for functions that return the number of bytes operated on in a\n * given page.\n */\n\nenum positive_aop_returns {\n\tAOP_WRITEPAGE_ACTIVATE\t= 0x80000,\n\tAOP_TRUNCATED_PAGE\t= 0x80001,\n};\n\n#define AOP_FLAG_CONT_EXPAND\t\t0x0001 /* called from cont_expand */\n#define AOP_FLAG_NOFS\t\t\t0x0002 /* used by filesystem to direct\n\t\t\t\t\t\t* helper code (eg buffer layer)\n\t\t\t\t\t\t* to clear GFP_FS from alloc */\n\n/*\n * oh the beauties of C type declarations.\n */\nstruct page;\nstruct address_space;\nstruct writeback_control;\nstruct readahead_control;\n\n/*\n * Write life time hint values.\n * Stored in struct inode as u8.\n */\nenum rw_hint {\n\tWRITE_LIFE_NOT_SET\t= 0,\n\tWRITE_LIFE_NONE\t\t= RWH_WRITE_LIFE_NONE,\n\tWRITE_LIFE_SHORT\t= RWH_WRITE_LIFE_SHORT,\n\tWRITE_LIFE_MEDIUM\t= RWH_WRITE_LIFE_MEDIUM,\n\tWRITE_LIFE_LONG\t\t= RWH_WRITE_LIFE_LONG,\n\tWRITE_LIFE_EXTREME\t= RWH_WRITE_LIFE_EXTREME,\n};\n\n/* Match RWF_* bits to IOCB bits */\n#define IOCB_HIPRI\t\t(__force int) RWF_HIPRI\n#define IOCB_DSYNC\t\t(__force int) RWF_DSYNC\n#define IOCB_SYNC\t\t(__force int) RWF_SYNC\n#define IOCB_NOWAIT\t\t(__force int) RWF_NOWAIT\n#define IOCB_APPEND\t\t(__force int) RWF_APPEND\n\n/* non-RWF related bits - start at 16 */\n#define IOCB_EVENTFD\t\t(1 << 16)\n#define IOCB_DIRECT\t\t(1 << 17)\n#define IOCB_WRITE\t\t(1 << 18)\n/* iocb->ki_waitq is valid */\n#define IOCB_WAITQ\t\t(1 << 19)\n#define IOCB_NOIO\t\t(1 << 20)\n\nstruct kiocb {\n\tstruct file\t\t*ki_filp;\n\n\t/* The 'ki_filp' pointer is shared in a union for aio */\n\trandomized_struct_fields_start\n\n\tloff_t\t\t\tki_pos;\n\tvoid (*ki_complete)(struct kiocb *iocb, long ret, long ret2);\n\tvoid\t\t\t*private;\n\tint\t\t\tki_flags;\n\tu16\t\t\tki_hint;\n\tu16\t\t\tki_ioprio; /* See linux/ioprio.h */\n\tunion {\n\t\tunsigned int\t\tki_cookie; /* for ->iopoll */\n\t\tstruct wait_page_queue\t*ki_waitq; /* for async buffered IO */\n\t};\n\n\trandomized_struct_fields_end\n};\n\nstatic inline bool is_sync_kiocb(struct kiocb *kiocb)\n{\n\treturn kiocb->ki_complete == NULL;\n}\n\n/*\n * \"descriptor\" for what we're up to with a read.\n * This allows us to use the same read code yet\n * have multiple different users of the data that\n * we read from a file.\n *\n * The simplest case just copies the data to user\n * mode.\n */\ntypedef struct {\n\tsize_t written;\n\tsize_t count;\n\tunion {\n\t\tchar __user *buf;\n\t\tvoid *data;\n\t} arg;\n\tint error;\n} read_descriptor_t;\n\ntypedef int (*read_actor_t)(read_descriptor_t *, struct page *,\n\t\tunsigned long, unsigned long);\n\nstruct address_space_operations {\n\tint (*writepage)(struct page *page, struct writeback_control *wbc);\n\tint (*readpage)(struct file *, struct page *);\n\n\t/* Write back some dirty pages from this mapping. */\n\tint (*writepages)(struct address_space *, struct writeback_control *);\n\n\t/* Set a page dirty.  Return true if this dirtied it */\n\tint (*set_page_dirty)(struct page *page);\n\n\t/*\n\t * Reads in the requested pages. Unlike ->readpage(), this is\n\t * PURELY used for read-ahead!.\n\t */\n\tint (*readpages)(struct file *filp, struct address_space *mapping,\n\t\t\tstruct list_head *pages, unsigned nr_pages);\n\tvoid (*readahead)(struct readahead_control *);\n\n\tint (*write_begin)(struct file *, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\t\tstruct page **pagep, void **fsdata);\n\tint (*write_end)(struct file *, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\t\tstruct page *page, void *fsdata);\n\n\t/* Unfortunately this kludge is needed for FIBMAP. Don't use it */\n\tsector_t (*bmap)(struct address_space *, sector_t);\n\tvoid (*invalidatepage) (struct page *, unsigned int, unsigned int);\n\tint (*releasepage) (struct page *, gfp_t);\n\tvoid (*freepage)(struct page *);\n\tssize_t (*direct_IO)(struct kiocb *, struct iov_iter *iter);\n\t/*\n\t * migrate the contents of a page to the specified target. If\n\t * migrate_mode is MIGRATE_ASYNC, it must not block.\n\t */\n\tint (*migratepage) (struct address_space *,\n\t\t\tstruct page *, struct page *, enum migrate_mode);\n\tbool (*isolate_page)(struct page *, isolate_mode_t);\n\tvoid (*putback_page)(struct page *);\n\tint (*launder_page) (struct page *);\n\tint (*is_partially_uptodate) (struct page *, unsigned long,\n\t\t\t\t\tunsigned long);\n\tvoid (*is_dirty_writeback) (struct page *, bool *, bool *);\n\tint (*error_remove_page)(struct address_space *, struct page *);\n\n\t/* swapfile support */\n\tint (*swap_activate)(struct swap_info_struct *sis, struct file *file,\n\t\t\t\tsector_t *span);\n\tvoid (*swap_deactivate)(struct file *file);\n};\n\nextern const struct address_space_operations empty_aops;\n\n/*\n * pagecache_write_begin/pagecache_write_end must be used by general code\n * to write into the pagecache.\n */\nint pagecache_write_begin(struct file *, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\t\tstruct page **pagep, void **fsdata);\n\nint pagecache_write_end(struct file *, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\t\tstruct page *page, void *fsdata);\n\n/**\n * struct address_space - Contents of a cacheable, mappable object.\n * @host: Owner, either the inode or the block_device.\n * @i_pages: Cached pages.\n * @gfp_mask: Memory allocation flags to use for allocating pages.\n * @i_mmap_writable: Number of VM_SHARED mappings.\n * @nr_thps: Number of THPs in the pagecache (non-shmem only).\n * @i_mmap: Tree of private and shared mappings.\n * @i_mmap_rwsem: Protects @i_mmap and @i_mmap_writable.\n * @nrpages: Number of page entries, protected by the i_pages lock.\n * @nrexceptional: Shadow or DAX entries, protected by the i_pages lock.\n * @writeback_index: Writeback starts here.\n * @a_ops: Methods.\n * @flags: Error bits and flags (AS_*).\n * @wb_err: The most recent error which has occurred.\n * @private_lock: For use by the owner of the address_space.\n * @private_list: For use by the owner of the address_space.\n * @private_data: For use by the owner of the address_space.\n */\nstruct address_space {\n\tstruct inode\t\t*host;\n\tstruct xarray\t\ti_pages;\n\tgfp_t\t\t\tgfp_mask;\n\tatomic_t\t\ti_mmap_writable;\n#ifdef CONFIG_READ_ONLY_THP_FOR_FS\n\t/* number of thp, only for non-shmem files */\n\tatomic_t\t\tnr_thps;\n#endif\n\tstruct rb_root_cached\ti_mmap;\n\tstruct rw_semaphore\ti_mmap_rwsem;\n\tunsigned long\t\tnrpages;\n\tunsigned long\t\tnrexceptional;\n\tpgoff_t\t\t\twriteback_index;\n\tconst struct address_space_operations *a_ops;\n\tunsigned long\t\tflags;\n\terrseq_t\t\twb_err;\n\tspinlock_t\t\tprivate_lock;\n\tstruct list_head\tprivate_list;\n\tvoid\t\t\t*private_data;\n} __attribute__((aligned(sizeof(long)))) __randomize_layout;\n\t/*\n\t * On most architectures that alignment is already the case; but\n\t * must be enforced here for CRIS, to let the least significant bit\n\t * of struct page's \"mapping\" pointer be used for PAGE_MAPPING_ANON.\n\t */\n\n/* XArray tags, for tagging dirty and writeback pages in the pagecache. */\n#define PAGECACHE_TAG_DIRTY\tXA_MARK_0\n#define PAGECACHE_TAG_WRITEBACK\tXA_MARK_1\n#define PAGECACHE_TAG_TOWRITE\tXA_MARK_2\n\n/*\n * Returns true if any of the pages in the mapping are marked with the tag.\n */\nstatic inline bool mapping_tagged(struct address_space *mapping, xa_mark_t tag)\n{\n\treturn xa_marked(&mapping->i_pages, tag);\n}\n\nstatic inline void i_mmap_lock_write(struct address_space *mapping)\n{\n\tdown_write(&mapping->i_mmap_rwsem);\n}\n\nstatic inline int i_mmap_trylock_write(struct address_space *mapping)\n{\n\treturn down_write_trylock(&mapping->i_mmap_rwsem);\n}\n\nstatic inline void i_mmap_unlock_write(struct address_space *mapping)\n{\n\tup_write(&mapping->i_mmap_rwsem);\n}\n\nstatic inline void i_mmap_lock_read(struct address_space *mapping)\n{\n\tdown_read(&mapping->i_mmap_rwsem);\n}\n\nstatic inline void i_mmap_unlock_read(struct address_space *mapping)\n{\n\tup_read(&mapping->i_mmap_rwsem);\n}\n\nstatic inline void i_mmap_assert_locked(struct address_space *mapping)\n{\n\tlockdep_assert_held(&mapping->i_mmap_rwsem);\n}\n\nstatic inline void i_mmap_assert_write_locked(struct address_space *mapping)\n{\n\tlockdep_assert_held_write(&mapping->i_mmap_rwsem);\n}\n\n/*\n * Might pages of this file be mapped into userspace?\n */\nstatic inline int mapping_mapped(struct address_space *mapping)\n{\n\treturn\t!RB_EMPTY_ROOT(&mapping->i_mmap.rb_root);\n}\n\n/*\n * Might pages of this file have been modified in userspace?\n * Note that i_mmap_writable counts all VM_SHARED vmas: do_mmap\n * marks vma as VM_SHARED if it is shared, and the file was opened for\n * writing i.e. vma may be mprotected writable even if now readonly.\n *\n * If i_mmap_writable is negative, no new writable mappings are allowed. You\n * can only deny writable mappings, if none exists right now.\n */\nstatic inline int mapping_writably_mapped(struct address_space *mapping)\n{\n\treturn atomic_read(&mapping->i_mmap_writable) > 0;\n}\n\nstatic inline int mapping_map_writable(struct address_space *mapping)\n{\n\treturn atomic_inc_unless_negative(&mapping->i_mmap_writable) ?\n\t\t0 : -EPERM;\n}\n\nstatic inline void mapping_unmap_writable(struct address_space *mapping)\n{\n\tatomic_dec(&mapping->i_mmap_writable);\n}\n\nstatic inline int mapping_deny_writable(struct address_space *mapping)\n{\n\treturn atomic_dec_unless_positive(&mapping->i_mmap_writable) ?\n\t\t0 : -EBUSY;\n}\n\nstatic inline void mapping_allow_writable(struct address_space *mapping)\n{\n\tatomic_inc(&mapping->i_mmap_writable);\n}\n\n/*\n * Use sequence counter to get consistent i_size on 32-bit processors.\n */\n#if BITS_PER_LONG==32 && defined(CONFIG_SMP)\n#include <linux/seqlock.h>\n#define __NEED_I_SIZE_ORDERED\n#define i_size_ordered_init(inode) seqcount_init(&inode->i_size_seqcount)\n#else\n#define i_size_ordered_init(inode) do { } while (0)\n#endif\n\nstruct posix_acl;\n#define ACL_NOT_CACHED ((void *)(-1))\n#define ACL_DONT_CACHE ((void *)(-3))\n\nstatic inline struct posix_acl *\nuncached_acl_sentinel(struct task_struct *task)\n{\n\treturn (void *)task + 1;\n}\n\nstatic inline bool\nis_uncached_acl(struct posix_acl *acl)\n{\n\treturn (long)acl & 1;\n}\n\n#define IOP_FASTPERM\t0x0001\n#define IOP_LOOKUP\t0x0002\n#define IOP_NOFOLLOW\t0x0004\n#define IOP_XATTR\t0x0008\n#define IOP_DEFAULT_READLINK\t0x0010\n\nstruct fsnotify_mark_connector;\n\n/*\n * Keep mostly read-only and often accessed (especially for\n * the RCU path lookup and 'stat' data) fields at the beginning\n * of the 'struct inode'\n */\nstruct inode {\n\tumode_t\t\t\ti_mode;\n\tunsigned short\t\ti_opflags;\n\tkuid_t\t\t\ti_uid;\n\tkgid_t\t\t\ti_gid;\n\tunsigned int\t\ti_flags;\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tstruct posix_acl\t*i_acl;\n\tstruct posix_acl\t*i_default_acl;\n#endif\n\n\tconst struct inode_operations\t*i_op;\n\tstruct super_block\t*i_sb;\n\tstruct address_space\t*i_mapping;\n\n#ifdef CONFIG_SECURITY\n\tvoid\t\t\t*i_security;\n#endif\n\n\t/* Stat data, not accessed from path walking */\n\tunsigned long\t\ti_ino;\n\t/*\n\t * Filesystems may only read i_nlink directly.  They shall use the\n\t * following functions for modification:\n\t *\n\t *    (set|clear|inc|drop)_nlink\n\t *    inode_(inc|dec)_link_count\n\t */\n\tunion {\n\t\tconst unsigned int i_nlink;\n\t\tunsigned int __i_nlink;\n\t};\n\tdev_t\t\t\ti_rdev;\n\tloff_t\t\t\ti_size;\n\tstruct timespec64\ti_atime;\n\tstruct timespec64\ti_mtime;\n\tstruct timespec64\ti_ctime;\n\tspinlock_t\t\ti_lock;\t/* i_blocks, i_bytes, maybe i_size */\n\tunsigned short          i_bytes;\n\tu8\t\t\ti_blkbits;\n\tu8\t\t\ti_write_hint;\n\tblkcnt_t\t\ti_blocks;\n\n#ifdef __NEED_I_SIZE_ORDERED\n\tseqcount_t\t\ti_size_seqcount;\n#endif\n\n\t/* Misc */\n\tunsigned long\t\ti_state;\n\tstruct rw_semaphore\ti_rwsem;\n\n\tunsigned long\t\tdirtied_when;\t/* jiffies of first dirtying */\n\tunsigned long\t\tdirtied_time_when;\n\n\tstruct hlist_node\ti_hash;\n\tstruct list_head\ti_io_list;\t/* backing dev IO list */\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tstruct bdi_writeback\t*i_wb;\t\t/* the associated cgroup wb */\n\n\t/* foreign inode detection, see wbc_detach_inode() */\n\tint\t\t\ti_wb_frn_winner;\n\tu16\t\t\ti_wb_frn_avg_time;\n\tu16\t\t\ti_wb_frn_history;\n#endif\n\tstruct list_head\ti_lru;\t\t/* inode LRU list */\n\tstruct list_head\ti_sb_list;\n\tstruct list_head\ti_wb_list;\t/* backing dev writeback list */\n\tunion {\n\t\tstruct hlist_head\ti_dentry;\n\t\tstruct rcu_head\t\ti_rcu;\n\t};\n\tatomic64_t\t\ti_version;\n\tatomic64_t\t\ti_sequence; /* see futex */\n\tatomic_t\t\ti_count;\n\tatomic_t\t\ti_dio_count;\n\tatomic_t\t\ti_writecount;\n#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)\n\tatomic_t\t\ti_readcount; /* struct files open RO */\n#endif\n\tunion {\n\t\tconst struct file_operations\t*i_fop;\t/* former ->i_op->default_file_ops */\n\t\tvoid (*free_inode)(struct inode *);\n\t};\n\tstruct file_lock_context\t*i_flctx;\n\tstruct address_space\ti_data;\n\tstruct list_head\ti_devices;\n\tunion {\n\t\tstruct pipe_inode_info\t*i_pipe;\n\t\tstruct block_device\t*i_bdev;\n\t\tstruct cdev\t\t*i_cdev;\n\t\tchar\t\t\t*i_link;\n\t\tunsigned\t\ti_dir_seq;\n\t};\n\n\t__u32\t\t\ti_generation;\n\n#ifdef CONFIG_FSNOTIFY\n\t__u32\t\t\ti_fsnotify_mask; /* all events this inode cares about */\n\tstruct fsnotify_mark_connector __rcu\t*i_fsnotify_marks;\n#endif\n\n#ifdef CONFIG_FS_ENCRYPTION\n\tstruct fscrypt_info\t*i_crypt_info;\n#endif\n\n#ifdef CONFIG_FS_VERITY\n\tstruct fsverity_info\t*i_verity_info;\n#endif\n\n\tvoid\t\t\t*i_private; /* fs or device private pointer */\n} __randomize_layout;\n\nstruct timespec64 timestamp_truncate(struct timespec64 t, struct inode *inode);\n\nstatic inline unsigned int i_blocksize(const struct inode *node)\n{\n\treturn (1 << node->i_blkbits);\n}\n\nstatic inline int inode_unhashed(struct inode *inode)\n{\n\treturn hlist_unhashed(&inode->i_hash);\n}\n\n/*\n * __mark_inode_dirty expects inodes to be hashed.  Since we don't\n * want special inodes in the fileset inode space, we make them\n * appear hashed, but do not put on any lists.  hlist_del()\n * will work fine and require no locking.\n */\nstatic inline void inode_fake_hash(struct inode *inode)\n{\n\thlist_add_fake(&inode->i_hash);\n}\n\n/*\n * inode->i_mutex nesting subclasses for the lock validator:\n *\n * 0: the object of the current VFS operation\n * 1: parent\n * 2: child/target\n * 3: xattr\n * 4: second non-directory\n * 5: second parent (when locking independent directories in rename)\n *\n * I_MUTEX_NONDIR2 is for certain operations (such as rename) which lock two\n * non-directories at once.\n *\n * The locking order between these classes is\n * parent[2] -> child -> grandchild -> normal -> xattr -> second non-directory\n */\nenum inode_i_mutex_lock_class\n{\n\tI_MUTEX_NORMAL,\n\tI_MUTEX_PARENT,\n\tI_MUTEX_CHILD,\n\tI_MUTEX_XATTR,\n\tI_MUTEX_NONDIR2,\n\tI_MUTEX_PARENT2,\n};\n\nstatic inline void inode_lock(struct inode *inode)\n{\n\tdown_write(&inode->i_rwsem);\n}\n\nstatic inline void inode_unlock(struct inode *inode)\n{\n\tup_write(&inode->i_rwsem);\n}\n\nstatic inline void inode_lock_shared(struct inode *inode)\n{\n\tdown_read(&inode->i_rwsem);\n}\n\nstatic inline void inode_unlock_shared(struct inode *inode)\n{\n\tup_read(&inode->i_rwsem);\n}\n\nstatic inline int inode_trylock(struct inode *inode)\n{\n\treturn down_write_trylock(&inode->i_rwsem);\n}\n\nstatic inline int inode_trylock_shared(struct inode *inode)\n{\n\treturn down_read_trylock(&inode->i_rwsem);\n}\n\nstatic inline int inode_is_locked(struct inode *inode)\n{\n\treturn rwsem_is_locked(&inode->i_rwsem);\n}\n\nstatic inline void inode_lock_nested(struct inode *inode, unsigned subclass)\n{\n\tdown_write_nested(&inode->i_rwsem, subclass);\n}\n\nstatic inline void inode_lock_shared_nested(struct inode *inode, unsigned subclass)\n{\n\tdown_read_nested(&inode->i_rwsem, subclass);\n}\n\nvoid lock_two_nondirectories(struct inode *, struct inode*);\nvoid unlock_two_nondirectories(struct inode *, struct inode*);\n\n/*\n * NOTE: in a 32bit arch with a preemptable kernel and\n * an UP compile the i_size_read/write must be atomic\n * with respect to the local cpu (unlike with preempt disabled),\n * but they don't need to be atomic with respect to other cpus like in\n * true SMP (so they need either to either locally disable irq around\n * the read or for example on x86 they can be still implemented as a\n * cmpxchg8b without the need of the lock prefix). For SMP compiles\n * and 64bit archs it makes no difference if preempt is enabled or not.\n */\nstatic inline loff_t i_size_read(const struct inode *inode)\n{\n#if BITS_PER_LONG==32 && defined(CONFIG_SMP)\n\tloff_t i_size;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&inode->i_size_seqcount);\n\t\ti_size = inode->i_size;\n\t} while (read_seqcount_retry(&inode->i_size_seqcount, seq));\n\treturn i_size;\n#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPTION)\n\tloff_t i_size;\n\n\tpreempt_disable();\n\ti_size = inode->i_size;\n\tpreempt_enable();\n\treturn i_size;\n#else\n\treturn inode->i_size;\n#endif\n}\n\n/*\n * NOTE: unlike i_size_read(), i_size_write() does need locking around it\n * (normally i_mutex), otherwise on 32bit/SMP an update of i_size_seqcount\n * can be lost, resulting in subsequent i_size_read() calls spinning forever.\n */\nstatic inline void i_size_write(struct inode *inode, loff_t i_size)\n{\n#if BITS_PER_LONG==32 && defined(CONFIG_SMP)\n\tpreempt_disable();\n\twrite_seqcount_begin(&inode->i_size_seqcount);\n\tinode->i_size = i_size;\n\twrite_seqcount_end(&inode->i_size_seqcount);\n\tpreempt_enable();\n#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPTION)\n\tpreempt_disable();\n\tinode->i_size = i_size;\n\tpreempt_enable();\n#else\n\tinode->i_size = i_size;\n#endif\n}\n\nstatic inline unsigned iminor(const struct inode *inode)\n{\n\treturn MINOR(inode->i_rdev);\n}\n\nstatic inline unsigned imajor(const struct inode *inode)\n{\n\treturn MAJOR(inode->i_rdev);\n}\n\nstruct fown_struct {\n\trwlock_t lock;          /* protects pid, uid, euid fields */\n\tstruct pid *pid;\t/* pid or -pgrp where SIGIO should be sent */\n\tenum pid_type pid_type;\t/* Kind of process group SIGIO should be sent to */\n\tkuid_t uid, euid;\t/* uid/euid of process setting the owner */\n\tint signum;\t\t/* posix.1b rt signal to be delivered on IO */\n};\n\n/*\n * Track a single file's readahead state\n */\nstruct file_ra_state {\n\tpgoff_t start;\t\t\t/* where readahead started */\n\tunsigned int size;\t\t/* # of readahead pages */\n\tunsigned int async_size;\t/* do asynchronous readahead when\n\t\t\t\t\t   there are only # of pages ahead */\n\n\tunsigned int ra_pages;\t\t/* Maximum readahead window */\n\tunsigned int mmap_miss;\t\t/* Cache miss stat for mmap accesses */\n\tloff_t prev_pos;\t\t/* Cache last read() position */\n};\n\n/*\n * Check if @index falls in the readahead windows.\n */\nstatic inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)\n{\n\treturn (index >= ra->start &&\n\t\tindex <  ra->start + ra->size);\n}\n\nstruct file {\n\tunion {\n\t\tstruct llist_node\tfu_llist;\n\t\tstruct rcu_head \tfu_rcuhead;\n\t} f_u;\n\tstruct path\t\tf_path;\n\tstruct inode\t\t*f_inode;\t/* cached value */\n\tconst struct file_operations\t*f_op;\n\n\t/*\n\t * Protects f_ep_links, f_flags.\n\t * Must not be taken from IRQ context.\n\t */\n\tspinlock_t\t\tf_lock;\n\tenum rw_hint\t\tf_write_hint;\n\tatomic_long_t\t\tf_count;\n\tunsigned int \t\tf_flags;\n\tfmode_t\t\t\tf_mode;\n\tstruct mutex\t\tf_pos_lock;\n\tloff_t\t\t\tf_pos;\n\tstruct fown_struct\tf_owner;\n\tconst struct cred\t*f_cred;\n\tstruct file_ra_state\tf_ra;\n\n\tu64\t\t\tf_version;\n#ifdef CONFIG_SECURITY\n\tvoid\t\t\t*f_security;\n#endif\n\t/* needed for tty driver, and maybe others */\n\tvoid\t\t\t*private_data;\n\n#ifdef CONFIG_EPOLL\n\t/* Used by fs/eventpoll.c to link all the hooks to this file */\n\tstruct list_head\tf_ep_links;\n\tstruct list_head\tf_tfile_llink;\n#endif /* #ifdef CONFIG_EPOLL */\n\tstruct address_space\t*f_mapping;\n\terrseq_t\t\tf_wb_err;\n\terrseq_t\t\tf_sb_err; /* for syncfs */\n} __randomize_layout\n  __attribute__((aligned(4)));\t/* lest something weird decides that 2 is OK */\n\nstruct file_handle {\n\t__u32 handle_bytes;\n\tint handle_type;\n\t/* file identifier */\n\tunsigned char f_handle[];\n};\n\nstatic inline struct file *get_file(struct file *f)\n{\n\tatomic_long_inc(&f->f_count);\n\treturn f;\n}\n#define get_file_rcu_many(x, cnt)\t\\\n\tatomic_long_add_unless(&(x)->f_count, (cnt), 0)\n#define get_file_rcu(x) get_file_rcu_many((x), 1)\n#define file_count(x)\tatomic_long_read(&(x)->f_count)\n\n#define\tMAX_NON_LFS\t((1UL<<31) - 1)\n\n/* Page cache limit. The filesystems should put that into their s_maxbytes \n   limits, otherwise bad things can happen in VM. */ \n#if BITS_PER_LONG==32\n#define MAX_LFS_FILESIZE\t((loff_t)ULONG_MAX << PAGE_SHIFT)\n#elif BITS_PER_LONG==64\n#define MAX_LFS_FILESIZE \t((loff_t)LLONG_MAX)\n#endif\n\n#define FL_POSIX\t1\n#define FL_FLOCK\t2\n#define FL_DELEG\t4\t/* NFSv4 delegation */\n#define FL_ACCESS\t8\t/* not trying to lock, just looking */\n#define FL_EXISTS\t16\t/* when unlocking, test for existence */\n#define FL_LEASE\t32\t/* lease held on this file */\n#define FL_CLOSE\t64\t/* unlock on close */\n#define FL_SLEEP\t128\t/* A blocking lock */\n#define FL_DOWNGRADE_PENDING\t256 /* Lease is being downgraded */\n#define FL_UNLOCK_PENDING\t512 /* Lease is being broken */\n#define FL_OFDLCK\t1024\t/* lock is \"owned\" by struct file */\n#define FL_LAYOUT\t2048\t/* outstanding pNFS layout */\n\n#define FL_CLOSE_POSIX (FL_POSIX | FL_CLOSE)\n\n/*\n * Special return value from posix_lock_file() and vfs_lock_file() for\n * asynchronous locking.\n */\n#define FILE_LOCK_DEFERRED 1\n\n/* legacy typedef, should eventually be removed */\ntypedef void *fl_owner_t;\n\nstruct file_lock;\n\nstruct file_lock_operations {\n\tvoid (*fl_copy_lock)(struct file_lock *, struct file_lock *);\n\tvoid (*fl_release_private)(struct file_lock *);\n};\n\nstruct lock_manager_operations {\n\tfl_owner_t (*lm_get_owner)(fl_owner_t);\n\tvoid (*lm_put_owner)(fl_owner_t);\n\tvoid (*lm_notify)(struct file_lock *);\t/* unblock callback */\n\tint (*lm_grant)(struct file_lock *, int);\n\tbool (*lm_break)(struct file_lock *);\n\tint (*lm_change)(struct file_lock *, int, struct list_head *);\n\tvoid (*lm_setup)(struct file_lock *, void **);\n\tbool (*lm_breaker_owns_lease)(struct file_lock *);\n};\n\nstruct lock_manager {\n\tstruct list_head list;\n\t/*\n\t * NFSv4 and up also want opens blocked during the grace period;\n\t * NLM doesn't care:\n\t */\n\tbool block_opens;\n};\n\nstruct net;\nvoid locks_start_grace(struct net *, struct lock_manager *);\nvoid locks_end_grace(struct lock_manager *);\nbool locks_in_grace(struct net *);\nbool opens_in_grace(struct net *);\n\n/* that will die - we need it for nfs_lock_info */\n#include <linux/nfs_fs_i.h>\n\n/*\n * struct file_lock represents a generic \"file lock\". It's used to represent\n * POSIX byte range locks, BSD (flock) locks, and leases. It's important to\n * note that the same struct is used to represent both a request for a lock and\n * the lock itself, but the same object is never used for both.\n *\n * FIXME: should we create a separate \"struct lock_request\" to help distinguish\n * these two uses?\n *\n * The varous i_flctx lists are ordered by:\n *\n * 1) lock owner\n * 2) lock range start\n * 3) lock range end\n *\n * Obviously, the last two criteria only matter for POSIX locks.\n */\nstruct file_lock {\n\tstruct file_lock *fl_blocker;\t/* The lock, that is blocking us */\n\tstruct list_head fl_list;\t/* link into file_lock_context */\n\tstruct hlist_node fl_link;\t/* node in global lists */\n\tstruct list_head fl_blocked_requests;\t/* list of requests with\n\t\t\t\t\t\t * ->fl_blocker pointing here\n\t\t\t\t\t\t */\n\tstruct list_head fl_blocked_member;\t/* node in\n\t\t\t\t\t\t * ->fl_blocker->fl_blocked_requests\n\t\t\t\t\t\t */\n\tfl_owner_t fl_owner;\n\tunsigned int fl_flags;\n\tunsigned char fl_type;\n\tunsigned int fl_pid;\n\tint fl_link_cpu;\t\t/* what cpu's list is this on? */\n\twait_queue_head_t fl_wait;\n\tstruct file *fl_file;\n\tloff_t fl_start;\n\tloff_t fl_end;\n\n\tstruct fasync_struct *\tfl_fasync; /* for lease break notifications */\n\t/* for lease breaks: */\n\tunsigned long fl_break_time;\n\tunsigned long fl_downgrade_time;\n\n\tconst struct file_lock_operations *fl_ops;\t/* Callbacks for filesystems */\n\tconst struct lock_manager_operations *fl_lmops;\t/* Callbacks for lockmanagers */\n\tunion {\n\t\tstruct nfs_lock_info\tnfs_fl;\n\t\tstruct nfs4_lock_info\tnfs4_fl;\n\t\tstruct {\n\t\t\tstruct list_head link;\t/* link in AFS vnode's pending_locks list */\n\t\t\tint state;\t\t/* state of grant or error if -ve */\n\t\t\tunsigned int\tdebug_id;\n\t\t} afs;\n\t} fl_u;\n} __randomize_layout;\n\nstruct file_lock_context {\n\tspinlock_t\t\tflc_lock;\n\tstruct list_head\tflc_flock;\n\tstruct list_head\tflc_posix;\n\tstruct list_head\tflc_lease;\n};\n\n/* The following constant reflects the upper bound of the file/locking space */\n#ifndef OFFSET_MAX\n#define INT_LIMIT(x)\t(~((x)1 << (sizeof(x)*8 - 1)))\n#define OFFSET_MAX\tINT_LIMIT(loff_t)\n#define OFFT_OFFSET_MAX\tINT_LIMIT(off_t)\n#endif\n\nextern void send_sigio(struct fown_struct *fown, int fd, int band);\n\n#define locks_inode(f) file_inode(f)\n\n#ifdef CONFIG_FILE_LOCKING\nextern int fcntl_getlk(struct file *, unsigned int, struct flock *);\nextern int fcntl_setlk(unsigned int, struct file *, unsigned int,\n\t\t\tstruct flock *);\n\n#if BITS_PER_LONG == 32\nextern int fcntl_getlk64(struct file *, unsigned int, struct flock64 *);\nextern int fcntl_setlk64(unsigned int, struct file *, unsigned int,\n\t\t\tstruct flock64 *);\n#endif\n\nextern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);\nextern int fcntl_getlease(struct file *filp);\n\n/* fs/locks.c */\nvoid locks_free_lock_context(struct inode *inode);\nvoid locks_free_lock(struct file_lock *fl);\nextern void locks_init_lock(struct file_lock *);\nextern struct file_lock * locks_alloc_lock(void);\nextern void locks_copy_lock(struct file_lock *, struct file_lock *);\nextern void locks_copy_conflock(struct file_lock *, struct file_lock *);\nextern void locks_remove_posix(struct file *, fl_owner_t);\nextern void locks_remove_file(struct file *);\nextern void locks_release_private(struct file_lock *);\nextern void posix_test_lock(struct file *, struct file_lock *);\nextern int posix_lock_file(struct file *, struct file_lock *, struct file_lock *);\nextern int locks_delete_block(struct file_lock *);\nextern int vfs_test_lock(struct file *, struct file_lock *);\nextern int vfs_lock_file(struct file *, unsigned int, struct file_lock *, struct file_lock *);\nextern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);\nextern int locks_lock_inode_wait(struct inode *inode, struct file_lock *fl);\nextern int __break_lease(struct inode *inode, unsigned int flags, unsigned int type);\nextern void lease_get_mtime(struct inode *, struct timespec64 *time);\nextern int generic_setlease(struct file *, long, struct file_lock **, void **priv);\nextern int vfs_setlease(struct file *, long, struct file_lock **, void **);\nextern int lease_modify(struct file_lock *, int, struct list_head *);\n\nstruct notifier_block;\nextern int lease_register_notifier(struct notifier_block *);\nextern void lease_unregister_notifier(struct notifier_block *);\n\nstruct files_struct;\nextern void show_fd_locks(struct seq_file *f,\n\t\t\t struct file *filp, struct files_struct *files);\n#else /* !CONFIG_FILE_LOCKING */\nstatic inline int fcntl_getlk(struct file *file, unsigned int cmd,\n\t\t\t      struct flock __user *user)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int fcntl_setlk(unsigned int fd, struct file *file,\n\t\t\t      unsigned int cmd, struct flock __user *user)\n{\n\treturn -EACCES;\n}\n\n#if BITS_PER_LONG == 32\nstatic inline int fcntl_getlk64(struct file *file, unsigned int cmd,\n\t\t\t\tstruct flock64 __user *user)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int fcntl_setlk64(unsigned int fd, struct file *file,\n\t\t\t\tunsigned int cmd, struct flock64 __user *user)\n{\n\treturn -EACCES;\n}\n#endif\nstatic inline int fcntl_setlease(unsigned int fd, struct file *filp, long arg)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int fcntl_getlease(struct file *filp)\n{\n\treturn F_UNLCK;\n}\n\nstatic inline void\nlocks_free_lock_context(struct inode *inode)\n{\n}\n\nstatic inline void locks_init_lock(struct file_lock *fl)\n{\n\treturn;\n}\n\nstatic inline void locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\treturn;\n}\n\nstatic inline void locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\treturn;\n}\n\nstatic inline void locks_remove_posix(struct file *filp, fl_owner_t owner)\n{\n\treturn;\n}\n\nstatic inline void locks_remove_file(struct file *filp)\n{\n\treturn;\n}\n\nstatic inline void posix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\treturn;\n}\n\nstatic inline int posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\t\t  struct file_lock *conflock)\n{\n\treturn -ENOLCK;\n}\n\nstatic inline int locks_delete_block(struct file_lock *waiter)\n{\n\treturn -ENOENT;\n}\n\nstatic inline int vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\treturn 0;\n}\n\nstatic inline int vfs_lock_file(struct file *filp, unsigned int cmd,\n\t\t\t\tstruct file_lock *fl, struct file_lock *conf)\n{\n\treturn -ENOLCK;\n}\n\nstatic inline int vfs_cancel_lock(struct file *filp, struct file_lock *fl)\n{\n\treturn 0;\n}\n\nstatic inline int locks_lock_inode_wait(struct inode *inode, struct file_lock *fl)\n{\n\treturn -ENOLCK;\n}\n\nstatic inline int __break_lease(struct inode *inode, unsigned int mode, unsigned int type)\n{\n\treturn 0;\n}\n\nstatic inline void lease_get_mtime(struct inode *inode,\n\t\t\t\t   struct timespec64 *time)\n{\n\treturn;\n}\n\nstatic inline int generic_setlease(struct file *filp, long arg,\n\t\t\t\t    struct file_lock **flp, void **priv)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int vfs_setlease(struct file *filp, long arg,\n\t\t\t       struct file_lock **lease, void **priv)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int lease_modify(struct file_lock *fl, int arg,\n\t\t\t       struct list_head *dispose)\n{\n\treturn -EINVAL;\n}\n\nstruct files_struct;\nstatic inline void show_fd_locks(struct seq_file *f,\n\t\t\tstruct file *filp, struct files_struct *files) {}\n#endif /* !CONFIG_FILE_LOCKING */\n\nstatic inline struct inode *file_inode(const struct file *f)\n{\n\treturn f->f_inode;\n}\n\nstatic inline struct dentry *file_dentry(const struct file *file)\n{\n\treturn d_real(file->f_path.dentry, file_inode(file));\n}\n\nstatic inline int locks_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\treturn locks_lock_inode_wait(locks_inode(filp), fl);\n}\n\nstruct fasync_struct {\n\trwlock_t\t\tfa_lock;\n\tint\t\t\tmagic;\n\tint\t\t\tfa_fd;\n\tstruct fasync_struct\t*fa_next; /* singly linked list */\n\tstruct file\t\t*fa_file;\n\tstruct rcu_head\t\tfa_rcu;\n};\n\n#define FASYNC_MAGIC 0x4601\n\n/* SMP safe fasync helpers: */\nextern int fasync_helper(int, struct file *, int, struct fasync_struct **);\nextern struct fasync_struct *fasync_insert_entry(int, struct file *, struct fasync_struct **, struct fasync_struct *);\nextern int fasync_remove_entry(struct file *, struct fasync_struct **);\nextern struct fasync_struct *fasync_alloc(void);\nextern void fasync_free(struct fasync_struct *);\n\n/* can be called from interrupts */\nextern void kill_fasync(struct fasync_struct **, int, int);\n\nextern void __f_setown(struct file *filp, struct pid *, enum pid_type, int force);\nextern int f_setown(struct file *filp, unsigned long arg, int force);\nextern void f_delown(struct file *filp);\nextern pid_t f_getown(struct file *filp);\nextern int send_sigurg(struct fown_struct *fown);\n\n/*\n * sb->s_flags.  Note that these mirror the equivalent MS_* flags where\n * represented in both.\n */\n#define SB_RDONLY\t 1\t/* Mount read-only */\n#define SB_NOSUID\t 2\t/* Ignore suid and sgid bits */\n#define SB_NODEV\t 4\t/* Disallow access to device special files */\n#define SB_NOEXEC\t 8\t/* Disallow program execution */\n#define SB_SYNCHRONOUS\t16\t/* Writes are synced at once */\n#define SB_MANDLOCK\t64\t/* Allow mandatory locks on an FS */\n#define SB_DIRSYNC\t128\t/* Directory modifications are synchronous */\n#define SB_NOATIME\t1024\t/* Do not update access times. */\n#define SB_NODIRATIME\t2048\t/* Do not update directory access times */\n#define SB_SILENT\t32768\n#define SB_POSIXACL\t(1<<16)\t/* VFS does not apply the umask */\n#define SB_INLINECRYPT\t(1<<17)\t/* Use blk-crypto for encrypted files */\n#define SB_KERNMOUNT\t(1<<22) /* this is a kern_mount call */\n#define SB_I_VERSION\t(1<<23) /* Update inode I_version field */\n#define SB_LAZYTIME\t(1<<25) /* Update the on-disk [acm]times lazily */\n\n/* These sb flags are internal to the kernel */\n#define SB_SUBMOUNT     (1<<26)\n#define SB_FORCE    \t(1<<27)\n#define SB_NOSEC\t(1<<28)\n#define SB_BORN\t\t(1<<29)\n#define SB_ACTIVE\t(1<<30)\n#define SB_NOUSER\t(1<<31)\n\n/* These flags relate to encoding and casefolding */\n#define SB_ENC_STRICT_MODE_FL\t(1 << 0)\n\n#define sb_has_strict_encoding(sb) \\\n\t(sb->s_encoding_flags & SB_ENC_STRICT_MODE_FL)\n\n/*\n *\tUmount options\n */\n\n#define MNT_FORCE\t0x00000001\t/* Attempt to forcibily umount */\n#define MNT_DETACH\t0x00000002\t/* Just detach from the tree */\n#define MNT_EXPIRE\t0x00000004\t/* Mark for expiry */\n#define UMOUNT_NOFOLLOW\t0x00000008\t/* Don't follow symlink on umount */\n#define UMOUNT_UNUSED\t0x80000000\t/* Flag guaranteed to be unused */\n\n/* sb->s_iflags */\n#define SB_I_CGROUPWB\t0x00000001\t/* cgroup-aware writeback enabled */\n#define SB_I_NOEXEC\t0x00000002\t/* Ignore executables on this fs */\n#define SB_I_NODEV\t0x00000004\t/* Ignore devices on this fs */\n#define SB_I_STABLE_WRITES 0x00000008\t/* don't modify blks until WB is done */\n\n/* sb->s_iflags to limit user namespace mounts */\n#define SB_I_USERNS_VISIBLE\t\t0x00000010 /* fstype already mounted */\n#define SB_I_IMA_UNVERIFIABLE_SIGNATURE\t0x00000020\n#define SB_I_UNTRUSTED_MOUNTER\t\t0x00000040\n\n#define SB_I_SKIP_SYNC\t0x00000100\t/* Skip superblock at global sync */\n\n/* Possible states of 'frozen' field */\nenum {\n\tSB_UNFROZEN = 0,\t\t/* FS is unfrozen */\n\tSB_FREEZE_WRITE\t= 1,\t\t/* Writes, dir ops, ioctls frozen */\n\tSB_FREEZE_PAGEFAULT = 2,\t/* Page faults stopped as well */\n\tSB_FREEZE_FS = 3,\t\t/* For internal FS use (e.g. to stop\n\t\t\t\t\t * internal threads if needed) */\n\tSB_FREEZE_COMPLETE = 4,\t\t/* ->freeze_fs finished successfully */\n};\n\n#define SB_FREEZE_LEVELS (SB_FREEZE_COMPLETE - 1)\n\nstruct sb_writers {\n\tint\t\t\t\tfrozen;\t\t/* Is sb frozen? */\n\twait_queue_head_t\t\twait_unfrozen;\t/* for get_super_thawed() */\n\tstruct percpu_rw_semaphore\trw_sem[SB_FREEZE_LEVELS];\n};\n\nstruct super_block {\n\tstruct list_head\ts_list;\t\t/* Keep this first */\n\tdev_t\t\t\ts_dev;\t\t/* search index; _not_ kdev_t */\n\tunsigned char\t\ts_blocksize_bits;\n\tunsigned long\t\ts_blocksize;\n\tloff_t\t\t\ts_maxbytes;\t/* Max file size */\n\tstruct file_system_type\t*s_type;\n\tconst struct super_operations\t*s_op;\n\tconst struct dquot_operations\t*dq_op;\n\tconst struct quotactl_ops\t*s_qcop;\n\tconst struct export_operations *s_export_op;\n\tunsigned long\t\ts_flags;\n\tunsigned long\t\ts_iflags;\t/* internal SB_I_* flags */\n\tunsigned long\t\ts_magic;\n\tstruct dentry\t\t*s_root;\n\tstruct rw_semaphore\ts_umount;\n\tint\t\t\ts_count;\n\tatomic_t\t\ts_active;\n#ifdef CONFIG_SECURITY\n\tvoid                    *s_security;\n#endif\n\tconst struct xattr_handler **s_xattr;\n#ifdef CONFIG_FS_ENCRYPTION\n\tconst struct fscrypt_operations\t*s_cop;\n\tstruct key\t\t*s_master_keys; /* master crypto keys in use */\n#endif\n#ifdef CONFIG_FS_VERITY\n\tconst struct fsverity_operations *s_vop;\n#endif\n#ifdef CONFIG_UNICODE\n\tstruct unicode_map *s_encoding;\n\t__u16 s_encoding_flags;\n#endif\n\tstruct hlist_bl_head\ts_roots;\t/* alternate root dentries for NFS */\n\tstruct list_head\ts_mounts;\t/* list of mounts; _not_ for fs use */\n\tstruct block_device\t*s_bdev;\n\tstruct backing_dev_info *s_bdi;\n\tstruct mtd_info\t\t*s_mtd;\n\tstruct hlist_node\ts_instances;\n\tunsigned int\t\ts_quota_types;\t/* Bitmask of supported quota types */\n\tstruct quota_info\ts_dquot;\t/* Diskquota specific options */\n\n\tstruct sb_writers\ts_writers;\n\n\t/*\n\t * Keep s_fs_info, s_time_gran, s_fsnotify_mask, and\n\t * s_fsnotify_marks together for cache efficiency. They are frequently\n\t * accessed and rarely modified.\n\t */\n\tvoid\t\t\t*s_fs_info;\t/* Filesystem private info */\n\n\t/* Granularity of c/m/atime in ns (cannot be worse than a second) */\n\tu32\t\t\ts_time_gran;\n\t/* Time limits for c/m/atime in seconds */\n\ttime64_t\t\t   s_time_min;\n\ttime64_t\t\t   s_time_max;\n#ifdef CONFIG_FSNOTIFY\n\t__u32\t\t\ts_fsnotify_mask;\n\tstruct fsnotify_mark_connector __rcu\t*s_fsnotify_marks;\n#endif\n\n\tchar\t\t\ts_id[32];\t/* Informational name */\n\tuuid_t\t\t\ts_uuid;\t\t/* UUID */\n\n\tunsigned int\t\ts_max_links;\n\tfmode_t\t\t\ts_mode;\n\n\t/*\n\t * The next field is for VFS *only*. No filesystems have any business\n\t * even looking at it. You had been warned.\n\t */\n\tstruct mutex s_vfs_rename_mutex;\t/* Kludge */\n\n\t/*\n\t * Filesystem subtype.  If non-empty the filesystem type field\n\t * in /proc/mounts will be \"type.subtype\"\n\t */\n\tconst char *s_subtype;\n\n\tconst struct dentry_operations *s_d_op; /* default d_op for dentries */\n\n\t/*\n\t * Saved pool identifier for cleancache (-1 means none)\n\t */\n\tint cleancache_poolid;\n\n\tstruct shrinker s_shrink;\t/* per-sb shrinker handle */\n\n\t/* Number of inodes with nlink == 0 but still referenced */\n\tatomic_long_t s_remove_count;\n\n\t/* Pending fsnotify inode refs */\n\tatomic_long_t s_fsnotify_inode_refs;\n\n\t/* Being remounted read-only */\n\tint s_readonly_remount;\n\n\t/* per-sb errseq_t for reporting writeback errors via syncfs */\n\terrseq_t s_wb_err;\n\n\t/* AIO completions deferred from interrupt context */\n\tstruct workqueue_struct *s_dio_done_wq;\n\tstruct hlist_head s_pins;\n\n\t/*\n\t * Owning user namespace and default context in which to\n\t * interpret filesystem uids, gids, quotas, device nodes,\n\t * xattrs and security labels.\n\t */\n\tstruct user_namespace *s_user_ns;\n\n\t/*\n\t * The list_lru structure is essentially just a pointer to a table\n\t * of per-node lru lists, each of which has its own spinlock.\n\t * There is no need to put them into separate cachelines.\n\t */\n\tstruct list_lru\t\ts_dentry_lru;\n\tstruct list_lru\t\ts_inode_lru;\n\tstruct rcu_head\t\trcu;\n\tstruct work_struct\tdestroy_work;\n\n\tstruct mutex\t\ts_sync_lock;\t/* sync serialisation lock */\n\n\t/*\n\t * Indicates how deep in a filesystem stack this SB is\n\t */\n\tint s_stack_depth;\n\n\t/* s_inode_list_lock protects s_inodes */\n\tspinlock_t\t\ts_inode_list_lock ____cacheline_aligned_in_smp;\n\tstruct list_head\ts_inodes;\t/* all inodes */\n\n\tspinlock_t\t\ts_inode_wblist_lock;\n\tstruct list_head\ts_inodes_wb;\t/* writeback inodes */\n} __randomize_layout;\n\n/* Helper functions so that in most cases filesystems will\n * not need to deal directly with kuid_t and kgid_t and can\n * instead deal with the raw numeric values that are stored\n * in the filesystem.\n */\nstatic inline uid_t i_uid_read(const struct inode *inode)\n{\n\treturn from_kuid(inode->i_sb->s_user_ns, inode->i_uid);\n}\n\nstatic inline gid_t i_gid_read(const struct inode *inode)\n{\n\treturn from_kgid(inode->i_sb->s_user_ns, inode->i_gid);\n}\n\nstatic inline void i_uid_write(struct inode *inode, uid_t uid)\n{\n\tinode->i_uid = make_kuid(inode->i_sb->s_user_ns, uid);\n}\n\nstatic inline void i_gid_write(struct inode *inode, gid_t gid)\n{\n\tinode->i_gid = make_kgid(inode->i_sb->s_user_ns, gid);\n}\n\nextern struct timespec64 current_time(struct inode *inode);\n\n/*\n * Snapshotting support.\n */\n\nvoid __sb_end_write(struct super_block *sb, int level);\nint __sb_start_write(struct super_block *sb, int level, bool wait);\n\n#define __sb_writers_acquired(sb, lev)\t\\\n\tpercpu_rwsem_acquire(&(sb)->s_writers.rw_sem[(lev)-1], 1, _THIS_IP_)\n#define __sb_writers_release(sb, lev)\t\\\n\tpercpu_rwsem_release(&(sb)->s_writers.rw_sem[(lev)-1], 1, _THIS_IP_)\n\n/**\n * sb_end_write - drop write access to a superblock\n * @sb: the super we wrote to\n *\n * Decrement number of writers to the filesystem. Wake up possible waiters\n * wanting to freeze the filesystem.\n */\nstatic inline void sb_end_write(struct super_block *sb)\n{\n\t__sb_end_write(sb, SB_FREEZE_WRITE);\n}\n\n/**\n * sb_end_pagefault - drop write access to a superblock from a page fault\n * @sb: the super we wrote to\n *\n * Decrement number of processes handling write page fault to the filesystem.\n * Wake up possible waiters wanting to freeze the filesystem.\n */\nstatic inline void sb_end_pagefault(struct super_block *sb)\n{\n\t__sb_end_write(sb, SB_FREEZE_PAGEFAULT);\n}\n\n/**\n * sb_end_intwrite - drop write access to a superblock for internal fs purposes\n * @sb: the super we wrote to\n *\n * Decrement fs-internal number of writers to the filesystem.  Wake up possible\n * waiters wanting to freeze the filesystem.\n */\nstatic inline void sb_end_intwrite(struct super_block *sb)\n{\n\t__sb_end_write(sb, SB_FREEZE_FS);\n}\n\n/**\n * sb_start_write - get write access to a superblock\n * @sb: the super we write to\n *\n * When a process wants to write data or metadata to a file system (i.e. dirty\n * a page or an inode), it should embed the operation in a sb_start_write() -\n * sb_end_write() pair to get exclusion against file system freezing. This\n * function increments number of writers preventing freezing. If the file\n * system is already frozen, the function waits until the file system is\n * thawed.\n *\n * Since freeze protection behaves as a lock, users have to preserve\n * ordering of freeze protection and other filesystem locks. Generally,\n * freeze protection should be the outermost lock. In particular, we have:\n *\n * sb_start_write\n *   -> i_mutex\t\t\t(write path, truncate, directory ops, ...)\n *   -> s_umount\t\t(freeze_super, thaw_super)\n */\nstatic inline void sb_start_write(struct super_block *sb)\n{\n\t__sb_start_write(sb, SB_FREEZE_WRITE, true);\n}\n\nstatic inline int sb_start_write_trylock(struct super_block *sb)\n{\n\treturn __sb_start_write(sb, SB_FREEZE_WRITE, false);\n}\n\n/**\n * sb_start_pagefault - get write access to a superblock from a page fault\n * @sb: the super we write to\n *\n * When a process starts handling write page fault, it should embed the\n * operation into sb_start_pagefault() - sb_end_pagefault() pair to get\n * exclusion against file system freezing. This is needed since the page fault\n * is going to dirty a page. This function increments number of running page\n * faults preventing freezing. If the file system is already frozen, the\n * function waits until the file system is thawed.\n *\n * Since page fault freeze protection behaves as a lock, users have to preserve\n * ordering of freeze protection and other filesystem locks. It is advised to\n * put sb_start_pagefault() close to mmap_lock in lock ordering. Page fault\n * handling code implies lock dependency:\n *\n * mmap_lock\n *   -> sb_start_pagefault\n */\nstatic inline void sb_start_pagefault(struct super_block *sb)\n{\n\t__sb_start_write(sb, SB_FREEZE_PAGEFAULT, true);\n}\n\n/*\n * sb_start_intwrite - get write access to a superblock for internal fs purposes\n * @sb: the super we write to\n *\n * This is the third level of protection against filesystem freezing. It is\n * free for use by a filesystem. The only requirement is that it must rank\n * below sb_start_pagefault.\n *\n * For example filesystem can call sb_start_intwrite() when starting a\n * transaction which somewhat eases handling of freezing for internal sources\n * of filesystem changes (internal fs threads, discarding preallocation on file\n * close, etc.).\n */\nstatic inline void sb_start_intwrite(struct super_block *sb)\n{\n\t__sb_start_write(sb, SB_FREEZE_FS, true);\n}\n\nstatic inline int sb_start_intwrite_trylock(struct super_block *sb)\n{\n\treturn __sb_start_write(sb, SB_FREEZE_FS, false);\n}\n\n\nextern bool inode_owner_or_capable(const struct inode *inode);\n\n/*\n * VFS helper functions..\n */\nextern int vfs_create(struct inode *, struct dentry *, umode_t, bool);\nextern int vfs_mkdir(struct inode *, struct dentry *, umode_t);\nextern int vfs_mknod(struct inode *, struct dentry *, umode_t, dev_t);\nextern int vfs_symlink(struct inode *, struct dentry *, const char *);\nextern int vfs_link(struct dentry *, struct inode *, struct dentry *, struct inode **);\nextern int vfs_rmdir(struct inode *, struct dentry *);\nextern int vfs_unlink(struct inode *, struct dentry *, struct inode **);\nextern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *, struct inode **, unsigned int);\n\nstatic inline int vfs_whiteout(struct inode *dir, struct dentry *dentry)\n{\n\treturn vfs_mknod(dir, dentry, S_IFCHR | WHITEOUT_MODE, WHITEOUT_DEV);\n}\n\nextern struct dentry *vfs_tmpfile(struct dentry *dentry, umode_t mode,\n\t\t\t\t  int open_flag);\n\nint vfs_mkobj(struct dentry *, umode_t,\n\t\tint (*f)(struct dentry *, umode_t, void *),\n\t\tvoid *);\n\nint vfs_fchown(struct file *file, uid_t user, gid_t group);\nint vfs_fchmod(struct file *file, umode_t mode);\nint vfs_utimes(const struct path *path, struct timespec64 *times);\n\nextern long vfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg);\n\n#ifdef CONFIG_COMPAT\nextern long compat_ptr_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\tunsigned long arg);\n#else\n#define compat_ptr_ioctl NULL\n#endif\n\n/*\n * VFS file helper functions.\n */\nextern void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode);\nextern bool may_open_dev(const struct path *path);\n\n/*\n * This is the \"filldir\" function type, used by readdir() to let\n * the kernel specify what kind of dirent layout it wants to have.\n * This allows the kernel to read directories into kernel space or\n * to have different dirent layouts depending on the binary type.\n */\nstruct dir_context;\ntypedef int (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64,\n\t\t\t unsigned);\n\nstruct dir_context {\n\tfilldir_t actor;\n\tloff_t pos;\n};\n\n/*\n * These flags let !MMU mmap() govern direct device mapping vs immediate\n * copying more easily for MAP_PRIVATE, especially for ROM filesystems.\n *\n * NOMMU_MAP_COPY:\tCopy can be mapped (MAP_PRIVATE)\n * NOMMU_MAP_DIRECT:\tCan be mapped directly (MAP_SHARED)\n * NOMMU_MAP_READ:\tCan be mapped for reading\n * NOMMU_MAP_WRITE:\tCan be mapped for writing\n * NOMMU_MAP_EXEC:\tCan be mapped for execution\n */\n#define NOMMU_MAP_COPY\t\t0x00000001\n#define NOMMU_MAP_DIRECT\t0x00000008\n#define NOMMU_MAP_READ\t\tVM_MAYREAD\n#define NOMMU_MAP_WRITE\t\tVM_MAYWRITE\n#define NOMMU_MAP_EXEC\t\tVM_MAYEXEC\n\n#define NOMMU_VMFLAGS \\\n\t(NOMMU_MAP_READ | NOMMU_MAP_WRITE | NOMMU_MAP_EXEC)\n\n/*\n * These flags control the behavior of the remap_file_range function pointer.\n * If it is called with len == 0 that means \"remap to end of source file\".\n * See Documentation/filesystems/vfs.rst for more details about this call.\n *\n * REMAP_FILE_DEDUP: only remap if contents identical (i.e. deduplicate)\n * REMAP_FILE_CAN_SHORTEN: caller can handle a shortened request\n */\n#define REMAP_FILE_DEDUP\t\t(1 << 0)\n#define REMAP_FILE_CAN_SHORTEN\t\t(1 << 1)\n\n/*\n * These flags signal that the caller is ok with altering various aspects of\n * the behavior of the remap operation.  The changes must be made by the\n * implementation; the vfs remap helper functions can take advantage of them.\n * Flags in this category exist to preserve the quirky behavior of the hoisted\n * btrfs clone/dedupe ioctls.\n */\n#define REMAP_FILE_ADVISORY\t\t(REMAP_FILE_CAN_SHORTEN)\n\nstruct iov_iter;\n\nstruct file_operations {\n\tstruct module *owner;\n\tloff_t (*llseek) (struct file *, loff_t, int);\n\tssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\n\tssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\n\tssize_t (*read_iter) (struct kiocb *, struct iov_iter *);\n\tssize_t (*write_iter) (struct kiocb *, struct iov_iter *);\n\tint (*iopoll)(struct kiocb *kiocb, bool spin);\n\tint (*iterate) (struct file *, struct dir_context *);\n\tint (*iterate_shared) (struct file *, struct dir_context *);\n\t__poll_t (*poll) (struct file *, struct poll_table_struct *);\n\tlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\n\tlong (*compat_ioctl) (struct file *, unsigned int, unsigned long);\n\tint (*mmap) (struct file *, struct vm_area_struct *);\n\tunsigned long mmap_supported_flags;\n\tint (*open) (struct inode *, struct file *);\n\tint (*flush) (struct file *, fl_owner_t id);\n\tint (*release) (struct inode *, struct file *);\n\tint (*fsync) (struct file *, loff_t, loff_t, int datasync);\n\tint (*fasync) (int, struct file *, int);\n\tint (*lock) (struct file *, int, struct file_lock *);\n\tssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);\n\tunsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);\n\tint (*check_flags)(int);\n\tint (*flock) (struct file *, int, struct file_lock *);\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);\n\tssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);\n\tint (*setlease)(struct file *, long, struct file_lock **, void **);\n\tlong (*fallocate)(struct file *file, int mode, loff_t offset,\n\t\t\t  loff_t len);\n\tvoid (*show_fdinfo)(struct seq_file *m, struct file *f);\n#ifndef CONFIG_MMU\n\tunsigned (*mmap_capabilities)(struct file *);\n#endif\n\tssize_t (*copy_file_range)(struct file *, loff_t, struct file *,\n\t\t\tloff_t, size_t, unsigned int);\n\tloff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,\n\t\t\t\t   struct file *file_out, loff_t pos_out,\n\t\t\t\t   loff_t len, unsigned int remap_flags);\n\tint (*fadvise)(struct file *, loff_t, loff_t, int);\n} __randomize_layout;\n\nstruct inode_operations {\n\tstruct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);\n\tconst char * (*get_link) (struct dentry *, struct inode *, struct delayed_call *);\n\tint (*permission) (struct inode *, int);\n\tstruct posix_acl * (*get_acl)(struct inode *, int);\n\n\tint (*readlink) (struct dentry *, char __user *,int);\n\n\tint (*create) (struct inode *,struct dentry *, umode_t, bool);\n\tint (*link) (struct dentry *,struct inode *,struct dentry *);\n\tint (*unlink) (struct inode *,struct dentry *);\n\tint (*symlink) (struct inode *,struct dentry *,const char *);\n\tint (*mkdir) (struct inode *,struct dentry *,umode_t);\n\tint (*rmdir) (struct inode *,struct dentry *);\n\tint (*mknod) (struct inode *,struct dentry *,umode_t,dev_t);\n\tint (*rename) (struct inode *, struct dentry *,\n\t\t\tstruct inode *, struct dentry *, unsigned int);\n\tint (*setattr) (struct dentry *, struct iattr *);\n\tint (*getattr) (const struct path *, struct kstat *, u32, unsigned int);\n\tssize_t (*listxattr) (struct dentry *, char *, size_t);\n\tint (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,\n\t\t      u64 len);\n\tint (*update_time)(struct inode *, struct timespec64 *, int);\n\tint (*atomic_open)(struct inode *, struct dentry *,\n\t\t\t   struct file *, unsigned open_flag,\n\t\t\t   umode_t create_mode);\n\tint (*tmpfile) (struct inode *, struct dentry *, umode_t);\n\tint (*set_acl)(struct inode *, struct posix_acl *, int);\n} ____cacheline_aligned;\n\nstatic inline ssize_t call_read_iter(struct file *file, struct kiocb *kio,\n\t\t\t\t     struct iov_iter *iter)\n{\n\treturn file->f_op->read_iter(kio, iter);\n}\n\nstatic inline ssize_t call_write_iter(struct file *file, struct kiocb *kio,\n\t\t\t\t      struct iov_iter *iter)\n{\n\treturn file->f_op->write_iter(kio, iter);\n}\n\nstatic inline int call_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\treturn file->f_op->mmap(file, vma);\n}\n\nextern ssize_t vfs_read(struct file *, char __user *, size_t, loff_t *);\nextern ssize_t vfs_write(struct file *, const char __user *, size_t, loff_t *);\nextern ssize_t vfs_copy_file_range(struct file *, loff_t , struct file *,\n\t\t\t\t   loff_t, size_t, unsigned int);\nextern ssize_t generic_copy_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\t       struct file *file_out, loff_t pos_out,\n\t\t\t\t       size_t len, unsigned int flags);\nextern int generic_remap_file_range_prep(struct file *file_in, loff_t pos_in,\n\t\t\t\t\t struct file *file_out, loff_t pos_out,\n\t\t\t\t\t loff_t *count,\n\t\t\t\t\t unsigned int remap_flags);\nextern loff_t do_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\t  struct file *file_out, loff_t pos_out,\n\t\t\t\t  loff_t len, unsigned int remap_flags);\nextern loff_t vfs_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\t   struct file *file_out, loff_t pos_out,\n\t\t\t\t   loff_t len, unsigned int remap_flags);\nextern int vfs_dedupe_file_range(struct file *file,\n\t\t\t\t struct file_dedupe_range *same);\nextern loff_t vfs_dedupe_file_range_one(struct file *src_file, loff_t src_pos,\n\t\t\t\t\tstruct file *dst_file, loff_t dst_pos,\n\t\t\t\t\tloff_t len, unsigned int remap_flags);\n\n\nstruct super_operations {\n   \tstruct inode *(*alloc_inode)(struct super_block *sb);\n\tvoid (*destroy_inode)(struct inode *);\n\tvoid (*free_inode)(struct inode *);\n\n   \tvoid (*dirty_inode) (struct inode *, int flags);\n\tint (*write_inode) (struct inode *, struct writeback_control *wbc);\n\tint (*drop_inode) (struct inode *);\n\tvoid (*evict_inode) (struct inode *);\n\tvoid (*put_super) (struct super_block *);\n\tint (*sync_fs)(struct super_block *sb, int wait);\n\tint (*freeze_super) (struct super_block *);\n\tint (*freeze_fs) (struct super_block *);\n\tint (*thaw_super) (struct super_block *);\n\tint (*unfreeze_fs) (struct super_block *);\n\tint (*statfs) (struct dentry *, struct kstatfs *);\n\tint (*remount_fs) (struct super_block *, int *, char *);\n\tvoid (*umount_begin) (struct super_block *);\n\n\tint (*show_options)(struct seq_file *, struct dentry *);\n\tint (*show_devname)(struct seq_file *, struct dentry *);\n\tint (*show_path)(struct seq_file *, struct dentry *);\n\tint (*show_stats)(struct seq_file *, struct dentry *);\n#ifdef CONFIG_QUOTA\n\tssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);\n\tssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);\n\tstruct dquot **(*get_dquots)(struct inode *);\n#endif\n\tint (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);\n\tlong (*nr_cached_objects)(struct super_block *,\n\t\t\t\t  struct shrink_control *);\n\tlong (*free_cached_objects)(struct super_block *,\n\t\t\t\t    struct shrink_control *);\n};\n\n/*\n * Inode flags - they have no relation to superblock flags now\n */\n#define S_SYNC\t\t(1 << 0)  /* Writes are synced at once */\n#define S_NOATIME\t(1 << 1)  /* Do not update access times */\n#define S_APPEND\t(1 << 2)  /* Append-only file */\n#define S_IMMUTABLE\t(1 << 3)  /* Immutable file */\n#define S_DEAD\t\t(1 << 4)  /* removed, but still open directory */\n#define S_NOQUOTA\t(1 << 5)  /* Inode is not counted to quota */\n#define S_DIRSYNC\t(1 << 6)  /* Directory modifications are synchronous */\n#define S_NOCMTIME\t(1 << 7)  /* Do not update file c/mtime */\n#define S_SWAPFILE\t(1 << 8)  /* Do not truncate: swapon got its bmaps */\n#define S_PRIVATE\t(1 << 9)  /* Inode is fs-internal */\n#define S_IMA\t\t(1 << 10) /* Inode has an associated IMA struct */\n#define S_AUTOMOUNT\t(1 << 11) /* Automount/referral quasi-directory */\n#define S_NOSEC\t\t(1 << 12) /* no suid or xattr security attributes */\n#ifdef CONFIG_FS_DAX\n#define S_DAX\t\t(1 << 13) /* Direct Access, avoiding the page cache */\n#else\n#define S_DAX\t\t0\t  /* Make all the DAX code disappear */\n#endif\n#define S_ENCRYPTED\t(1 << 14) /* Encrypted file (using fs/crypto/) */\n#define S_CASEFOLD\t(1 << 15) /* Casefolded file */\n#define S_VERITY\t(1 << 16) /* Verity file (using fs/verity/) */\n\n/*\n * Note that nosuid etc flags are inode-specific: setting some file-system\n * flags just means all the inodes inherit those flags by default. It might be\n * possible to override it selectively if you really wanted to with some\n * ioctl() that is not currently implemented.\n *\n * Exception: SB_RDONLY is always applied to the entire file system.\n *\n * Unfortunately, it is possible to change a filesystems flags with it mounted\n * with files in use.  This means that all of the inodes will not have their\n * i_flags updated.  Hence, i_flags no longer inherit the superblock mount\n * flags, so these have to be checked separately. -- rmk@arm.uk.linux.org\n */\n#define __IS_FLG(inode, flg)\t((inode)->i_sb->s_flags & (flg))\n\nstatic inline bool sb_rdonly(const struct super_block *sb) { return sb->s_flags & SB_RDONLY; }\n#define IS_RDONLY(inode)\tsb_rdonly((inode)->i_sb)\n#define IS_SYNC(inode)\t\t(__IS_FLG(inode, SB_SYNCHRONOUS) || \\\n\t\t\t\t\t((inode)->i_flags & S_SYNC))\n#define IS_DIRSYNC(inode)\t(__IS_FLG(inode, SB_SYNCHRONOUS|SB_DIRSYNC) || \\\n\t\t\t\t\t((inode)->i_flags & (S_SYNC|S_DIRSYNC)))\n#define IS_MANDLOCK(inode)\t__IS_FLG(inode, SB_MANDLOCK)\n#define IS_NOATIME(inode)\t__IS_FLG(inode, SB_RDONLY|SB_NOATIME)\n#define IS_I_VERSION(inode)\t__IS_FLG(inode, SB_I_VERSION)\n\n#define IS_NOQUOTA(inode)\t((inode)->i_flags & S_NOQUOTA)\n#define IS_APPEND(inode)\t((inode)->i_flags & S_APPEND)\n#define IS_IMMUTABLE(inode)\t((inode)->i_flags & S_IMMUTABLE)\n#define IS_POSIXACL(inode)\t__IS_FLG(inode, SB_POSIXACL)\n\n#define IS_DEADDIR(inode)\t((inode)->i_flags & S_DEAD)\n#define IS_NOCMTIME(inode)\t((inode)->i_flags & S_NOCMTIME)\n#define IS_SWAPFILE(inode)\t((inode)->i_flags & S_SWAPFILE)\n#define IS_PRIVATE(inode)\t((inode)->i_flags & S_PRIVATE)\n#define IS_IMA(inode)\t\t((inode)->i_flags & S_IMA)\n#define IS_AUTOMOUNT(inode)\t((inode)->i_flags & S_AUTOMOUNT)\n#define IS_NOSEC(inode)\t\t((inode)->i_flags & S_NOSEC)\n#define IS_DAX(inode)\t\t((inode)->i_flags & S_DAX)\n#define IS_ENCRYPTED(inode)\t((inode)->i_flags & S_ENCRYPTED)\n#define IS_CASEFOLDED(inode)\t((inode)->i_flags & S_CASEFOLD)\n#define IS_VERITY(inode)\t((inode)->i_flags & S_VERITY)\n\n#define IS_WHITEOUT(inode)\t(S_ISCHR(inode->i_mode) && \\\n\t\t\t\t (inode)->i_rdev == WHITEOUT_DEV)\n\nstatic inline bool HAS_UNMAPPED_ID(struct inode *inode)\n{\n\treturn !uid_valid(inode->i_uid) || !gid_valid(inode->i_gid);\n}\n\nstatic inline enum rw_hint file_write_hint(struct file *file)\n{\n\tif (file->f_write_hint != WRITE_LIFE_NOT_SET)\n\t\treturn file->f_write_hint;\n\n\treturn file_inode(file)->i_write_hint;\n}\n\nstatic inline int iocb_flags(struct file *file);\n\nstatic inline u16 ki_hint_validate(enum rw_hint hint)\n{\n\ttypeof(((struct kiocb *)0)->ki_hint) max_hint = -1;\n\n\tif (hint <= max_hint)\n\t\treturn hint;\n\treturn 0;\n}\n\nstatic inline void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)\n{\n\t*kiocb = (struct kiocb) {\n\t\t.ki_filp = filp,\n\t\t.ki_flags = iocb_flags(filp),\n\t\t.ki_hint = ki_hint_validate(file_write_hint(filp)),\n\t\t.ki_ioprio = get_current_ioprio(),\n\t};\n}\n\nstatic inline void kiocb_clone(struct kiocb *kiocb, struct kiocb *kiocb_src,\n\t\t\t       struct file *filp)\n{\n\t*kiocb = (struct kiocb) {\n\t\t.ki_filp = filp,\n\t\t.ki_flags = kiocb_src->ki_flags,\n\t\t.ki_hint = kiocb_src->ki_hint,\n\t\t.ki_ioprio = kiocb_src->ki_ioprio,\n\t\t.ki_pos = kiocb_src->ki_pos,\n\t};\n}\n\n/*\n * Inode state bits.  Protected by inode->i_lock\n *\n * Three bits determine the dirty state of the inode, I_DIRTY_SYNC,\n * I_DIRTY_DATASYNC and I_DIRTY_PAGES.\n *\n * Four bits define the lifetime of an inode.  Initially, inodes are I_NEW,\n * until that flag is cleared.  I_WILL_FREE, I_FREEING and I_CLEAR are set at\n * various stages of removing an inode.\n *\n * Two bits are used for locking and completion notification, I_NEW and I_SYNC.\n *\n * I_DIRTY_SYNC\t\tInode is dirty, but doesn't have to be written on\n *\t\t\tfdatasync().  i_atime is the usual cause.\n * I_DIRTY_DATASYNC\tData-related inode changes pending. We keep track of\n *\t\t\tthese changes separately from I_DIRTY_SYNC so that we\n *\t\t\tdon't have to write inode on fdatasync() when only\n *\t\t\tmtime has changed in it.\n * I_DIRTY_PAGES\tInode has dirty pages.  Inode itself may be clean.\n * I_NEW\t\tServes as both a mutex and completion notification.\n *\t\t\tNew inodes set I_NEW.  If two processes both create\n *\t\t\tthe same inode, one of them will release its inode and\n *\t\t\twait for I_NEW to be released before returning.\n *\t\t\tInodes in I_WILL_FREE, I_FREEING or I_CLEAR state can\n *\t\t\talso cause waiting on I_NEW, without I_NEW actually\n *\t\t\tbeing set.  find_inode() uses this to prevent returning\n *\t\t\tnearly-dead inodes.\n * I_WILL_FREE\t\tMust be set when calling write_inode_now() if i_count\n *\t\t\tis zero.  I_FREEING must be set when I_WILL_FREE is\n *\t\t\tcleared.\n * I_FREEING\t\tSet when inode is about to be freed but still has dirty\n *\t\t\tpages or buffers attached or the inode itself is still\n *\t\t\tdirty.\n * I_CLEAR\t\tAdded by clear_inode().  In this state the inode is\n *\t\t\tclean and can be destroyed.  Inode keeps I_FREEING.\n *\n *\t\t\tInodes that are I_WILL_FREE, I_FREEING or I_CLEAR are\n *\t\t\tprohibited for many purposes.  iget() must wait for\n *\t\t\tthe inode to be completely released, then create it\n *\t\t\tanew.  Other functions will just ignore such inodes,\n *\t\t\tif appropriate.  I_NEW is used for waiting.\n *\n * I_SYNC\t\tWriteback of inode is running. The bit is set during\n *\t\t\tdata writeback, and cleared with a wakeup on the bit\n *\t\t\taddress once it is done. The bit is also used to pin\n *\t\t\tthe inode in memory for flusher thread.\n *\n * I_REFERENCED\t\tMarks the inode as recently references on the LRU list.\n *\n * I_DIO_WAKEUP\t\tNever set.  Only used as a key for wait_on_bit().\n *\n * I_WB_SWITCH\t\tCgroup bdi_writeback switching in progress.  Used to\n *\t\t\tsynchronize competing switching instances and to tell\n *\t\t\twb stat updates to grab the i_pages lock.  See\n *\t\t\tinode_switch_wbs_work_fn() for details.\n *\n * I_OVL_INUSE\t\tUsed by overlayfs to get exclusive ownership on upper\n *\t\t\tand work dirs among overlayfs mounts.\n *\n * I_CREATING\t\tNew object's inode in the middle of setting up.\n *\n * I_DONTCACHE\t\tEvict inode as soon as it is not used anymore.\n *\n * I_SYNC_QUEUED\tInode is queued in b_io or b_more_io writeback lists.\n *\t\t\tUsed to detect that mark_inode_dirty() should not move\n * \t\t\tinode between dirty lists.\n *\n * Q: What is the difference between I_WILL_FREE and I_FREEING?\n */\n#define I_DIRTY_SYNC\t\t(1 << 0)\n#define I_DIRTY_DATASYNC\t(1 << 1)\n#define I_DIRTY_PAGES\t\t(1 << 2)\n#define __I_NEW\t\t\t3\n#define I_NEW\t\t\t(1 << __I_NEW)\n#define I_WILL_FREE\t\t(1 << 4)\n#define I_FREEING\t\t(1 << 5)\n#define I_CLEAR\t\t\t(1 << 6)\n#define __I_SYNC\t\t7\n#define I_SYNC\t\t\t(1 << __I_SYNC)\n#define I_REFERENCED\t\t(1 << 8)\n#define __I_DIO_WAKEUP\t\t9\n#define I_DIO_WAKEUP\t\t(1 << __I_DIO_WAKEUP)\n#define I_LINKABLE\t\t(1 << 10)\n#define I_DIRTY_TIME\t\t(1 << 11)\n#define I_WB_SWITCH\t\t(1 << 13)\n#define I_OVL_INUSE\t\t(1 << 14)\n#define I_CREATING\t\t(1 << 15)\n#define I_DONTCACHE\t\t(1 << 16)\n#define I_SYNC_QUEUED\t\t(1 << 17)\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n#define I_DIRTY (I_DIRTY_INODE | I_DIRTY_PAGES)\n#define I_DIRTY_ALL (I_DIRTY | I_DIRTY_TIME)\n\nextern void __mark_inode_dirty(struct inode *, int);\nstatic inline void mark_inode_dirty(struct inode *inode)\n{\n\t__mark_inode_dirty(inode, I_DIRTY);\n}\n\nstatic inline void mark_inode_dirty_sync(struct inode *inode)\n{\n\t__mark_inode_dirty(inode, I_DIRTY_SYNC);\n}\n\nextern void inc_nlink(struct inode *inode);\nextern void drop_nlink(struct inode *inode);\nextern void clear_nlink(struct inode *inode);\nextern void set_nlink(struct inode *inode, unsigned int nlink);\n\nstatic inline void inode_inc_link_count(struct inode *inode)\n{\n\tinc_nlink(inode);\n\tmark_inode_dirty(inode);\n}\n\nstatic inline void inode_dec_link_count(struct inode *inode)\n{\n\tdrop_nlink(inode);\n\tmark_inode_dirty(inode);\n}\n\nenum file_time_flags {\n\tS_ATIME = 1,\n\tS_MTIME = 2,\n\tS_CTIME = 4,\n\tS_VERSION = 8,\n};\n\nextern bool atime_needs_update(const struct path *, struct inode *);\nextern void touch_atime(const struct path *);\nstatic inline void file_accessed(struct file *file)\n{\n\tif (!(file->f_flags & O_NOATIME))\n\t\ttouch_atime(&file->f_path);\n}\n\nextern int file_modified(struct file *file);\n\nint sync_inode(struct inode *inode, struct writeback_control *wbc);\nint sync_inode_metadata(struct inode *inode, int wait);\n\nstruct file_system_type {\n\tconst char *name;\n\tint fs_flags;\n#define FS_REQUIRES_DEV\t\t1 \n#define FS_BINARY_MOUNTDATA\t2\n#define FS_HAS_SUBTYPE\t\t4\n#define FS_USERNS_MOUNT\t\t8\t/* Can be mounted by userns root */\n#define FS_DISALLOW_NOTIFY_PERM\t16\t/* Disable fanotify permission events */\n#define FS_THP_SUPPORT\t\t8192\t/* Remove once all fs converted */\n#define FS_RENAME_DOES_D_MOVE\t32768\t/* FS will handle d_move() during rename() internally. */\n\tint (*init_fs_context)(struct fs_context *);\n\tconst struct fs_parameter_spec *parameters;\n\tstruct dentry *(*mount) (struct file_system_type *, int,\n\t\t       const char *, void *);\n\tvoid (*kill_sb) (struct super_block *);\n\tstruct module *owner;\n\tstruct file_system_type * next;\n\tstruct hlist_head fs_supers;\n\n\tstruct lock_class_key s_lock_key;\n\tstruct lock_class_key s_umount_key;\n\tstruct lock_class_key s_vfs_rename_key;\n\tstruct lock_class_key s_writers_key[SB_FREEZE_LEVELS];\n\n\tstruct lock_class_key i_lock_key;\n\tstruct lock_class_key i_mutex_key;\n\tstruct lock_class_key i_mutex_dir_key;\n};\n\n#define MODULE_ALIAS_FS(NAME) MODULE_ALIAS(\"fs-\" NAME)\n\nextern struct dentry *mount_bdev(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data,\n\tint (*fill_super)(struct super_block *, void *, int));\nextern struct dentry *mount_single(struct file_system_type *fs_type,\n\tint flags, void *data,\n\tint (*fill_super)(struct super_block *, void *, int));\nextern struct dentry *mount_nodev(struct file_system_type *fs_type,\n\tint flags, void *data,\n\tint (*fill_super)(struct super_block *, void *, int));\nextern struct dentry *mount_subtree(struct vfsmount *mnt, const char *path);\nvoid generic_shutdown_super(struct super_block *sb);\nvoid kill_block_super(struct super_block *sb);\nvoid kill_anon_super(struct super_block *sb);\nvoid kill_litter_super(struct super_block *sb);\nvoid deactivate_super(struct super_block *sb);\nvoid deactivate_locked_super(struct super_block *sb);\nint set_anon_super(struct super_block *s, void *data);\nint set_anon_super_fc(struct super_block *s, struct fs_context *fc);\nint get_anon_bdev(dev_t *);\nvoid free_anon_bdev(dev_t);\nstruct super_block *sget_fc(struct fs_context *fc,\n\t\t\t    int (*test)(struct super_block *, struct fs_context *),\n\t\t\t    int (*set)(struct super_block *, struct fs_context *));\nstruct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags, void *data);\n\n/* Alas, no aliases. Too much hassle with bringing module.h everywhere */\n#define fops_get(fops) \\\n\t(((fops) && try_module_get((fops)->owner) ? (fops) : NULL))\n#define fops_put(fops) \\\n\tdo { if (fops) module_put((fops)->owner); } while(0)\n/*\n * This one is to be used *ONLY* from ->open() instances.\n * fops must be non-NULL, pinned down *and* module dependencies\n * should be sufficient to pin the caller down as well.\n */\n#define replace_fops(f, fops) \\\n\tdo {\t\\\n\t\tstruct file *__file = (f); \\\n\t\tfops_put(__file->f_op); \\\n\t\tBUG_ON(!(__file->f_op = (fops))); \\\n\t} while(0)\n\nextern int register_filesystem(struct file_system_type *);\nextern int unregister_filesystem(struct file_system_type *);\nextern struct vfsmount *kern_mount(struct file_system_type *);\nextern void kern_unmount(struct vfsmount *mnt);\nextern int may_umount_tree(struct vfsmount *);\nextern int may_umount(struct vfsmount *);\nextern long do_mount(const char *, const char __user *,\n\t\t     const char *, unsigned long, void *);\nextern struct vfsmount *collect_mounts(const struct path *);\nextern void drop_collected_mounts(struct vfsmount *);\nextern int iterate_mounts(int (*)(struct vfsmount *, void *), void *,\n\t\t\t  struct vfsmount *);\nextern int vfs_statfs(const struct path *, struct kstatfs *);\nextern int user_statfs(const char __user *, struct kstatfs *);\nextern int fd_statfs(int, struct kstatfs *);\nextern int freeze_super(struct super_block *super);\nextern int thaw_super(struct super_block *super);\nextern bool our_mnt(struct vfsmount *mnt);\nextern __printf(2, 3)\nint super_setup_bdi_name(struct super_block *sb, char *fmt, ...);\nextern int super_setup_bdi(struct super_block *sb);\n\nextern int current_umask(void);\n\nextern void ihold(struct inode * inode);\nextern void iput(struct inode *);\nextern int generic_update_time(struct inode *, struct timespec64 *, int);\n\n/* /sys/fs */\nextern struct kobject *fs_kobj;\n\n#define MAX_RW_COUNT (INT_MAX & PAGE_MASK)\n\n#ifdef CONFIG_MANDATORY_FILE_LOCKING\nextern int locks_mandatory_locked(struct file *);\nextern int locks_mandatory_area(struct inode *, struct file *, loff_t, loff_t, unsigned char);\n\n/*\n * Candidates for mandatory locking have the setgid bit set\n * but no group execute bit -  an otherwise meaningless combination.\n */\n\nstatic inline int __mandatory_lock(struct inode *ino)\n{\n\treturn (ino->i_mode & (S_ISGID | S_IXGRP)) == S_ISGID;\n}\n\n/*\n * ... and these candidates should be on SB_MANDLOCK mounted fs,\n * otherwise these will be advisory locks\n */\n\nstatic inline int mandatory_lock(struct inode *ino)\n{\n\treturn IS_MANDLOCK(ino) && __mandatory_lock(ino);\n}\n\nstatic inline int locks_verify_locked(struct file *file)\n{\n\tif (mandatory_lock(locks_inode(file)))\n\t\treturn locks_mandatory_locked(file);\n\treturn 0;\n}\n\nstatic inline int locks_verify_truncate(struct inode *inode,\n\t\t\t\t    struct file *f,\n\t\t\t\t    loff_t size)\n{\n\tif (!inode->i_flctx || !mandatory_lock(inode))\n\t\treturn 0;\n\n\tif (size < inode->i_size) {\n\t\treturn locks_mandatory_area(inode, f, size, inode->i_size - 1,\n\t\t\t\tF_WRLCK);\n\t} else {\n\t\treturn locks_mandatory_area(inode, f, inode->i_size, size - 1,\n\t\t\t\tF_WRLCK);\n\t}\n}\n\n#else /* !CONFIG_MANDATORY_FILE_LOCKING */\n\nstatic inline int locks_mandatory_locked(struct file *file)\n{\n\treturn 0;\n}\n\nstatic inline int locks_mandatory_area(struct inode *inode, struct file *filp,\n                                       loff_t start, loff_t end, unsigned char type)\n{\n\treturn 0;\n}\n\nstatic inline int __mandatory_lock(struct inode *inode)\n{\n\treturn 0;\n}\n\nstatic inline int mandatory_lock(struct inode *inode)\n{\n\treturn 0;\n}\n\nstatic inline int locks_verify_locked(struct file *file)\n{\n\treturn 0;\n}\n\nstatic inline int locks_verify_truncate(struct inode *inode, struct file *filp,\n\t\t\t\t\tsize_t size)\n{\n\treturn 0;\n}\n\n#endif /* CONFIG_MANDATORY_FILE_LOCKING */\n\n\n#ifdef CONFIG_FILE_LOCKING\nstatic inline int break_lease(struct inode *inode, unsigned int mode)\n{\n\t/*\n\t * Since this check is lockless, we must ensure that any refcounts\n\t * taken are done before checking i_flctx->flc_lease. Otherwise, we\n\t * could end up racing with tasks trying to set a new lease on this\n\t * file.\n\t */\n\tsmp_mb();\n\tif (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))\n\t\treturn __break_lease(inode, mode, FL_LEASE);\n\treturn 0;\n}\n\nstatic inline int break_deleg(struct inode *inode, unsigned int mode)\n{\n\t/*\n\t * Since this check is lockless, we must ensure that any refcounts\n\t * taken are done before checking i_flctx->flc_lease. Otherwise, we\n\t * could end up racing with tasks trying to set a new lease on this\n\t * file.\n\t */\n\tsmp_mb();\n\tif (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))\n\t\treturn __break_lease(inode, mode, FL_DELEG);\n\treturn 0;\n}\n\nstatic inline int try_break_deleg(struct inode *inode, struct inode **delegated_inode)\n{\n\tint ret;\n\n\tret = break_deleg(inode, O_WRONLY|O_NONBLOCK);\n\tif (ret == -EWOULDBLOCK && delegated_inode) {\n\t\t*delegated_inode = inode;\n\t\tihold(inode);\n\t}\n\treturn ret;\n}\n\nstatic inline int break_deleg_wait(struct inode **delegated_inode)\n{\n\tint ret;\n\n\tret = break_deleg(*delegated_inode, O_WRONLY);\n\tiput(*delegated_inode);\n\t*delegated_inode = NULL;\n\treturn ret;\n}\n\nstatic inline int break_layout(struct inode *inode, bool wait)\n{\n\tsmp_mb();\n\tif (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))\n\t\treturn __break_lease(inode,\n\t\t\t\twait ? O_WRONLY : O_WRONLY | O_NONBLOCK,\n\t\t\t\tFL_LAYOUT);\n\treturn 0;\n}\n\n#else /* !CONFIG_FILE_LOCKING */\nstatic inline int break_lease(struct inode *inode, unsigned int mode)\n{\n\treturn 0;\n}\n\nstatic inline int break_deleg(struct inode *inode, unsigned int mode)\n{\n\treturn 0;\n}\n\nstatic inline int try_break_deleg(struct inode *inode, struct inode **delegated_inode)\n{\n\treturn 0;\n}\n\nstatic inline int break_deleg_wait(struct inode **delegated_inode)\n{\n\tBUG();\n\treturn 0;\n}\n\nstatic inline int break_layout(struct inode *inode, bool wait)\n{\n\treturn 0;\n}\n\n#endif /* CONFIG_FILE_LOCKING */\n\n/* fs/open.c */\nstruct audit_names;\nstruct filename {\n\tconst char\t\t*name;\t/* pointer to actual string */\n\tconst __user char\t*uptr;\t/* original userland pointer */\n\tint\t\t\trefcnt;\n\tstruct audit_names\t*aname;\n\tconst char\t\tiname[];\n};\nstatic_assert(offsetof(struct filename, iname) % sizeof(long) == 0);\n\nextern long vfs_truncate(const struct path *, loff_t);\nextern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,\n\t\t       struct file *filp);\nextern int vfs_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\tloff_t len);\nextern long do_sys_open(int dfd, const char __user *filename, int flags,\n\t\t\tumode_t mode);\nextern struct file *file_open_name(struct filename *, int, umode_t);\nextern struct file *filp_open(const char *, int, umode_t);\nextern struct file *file_open_root(struct dentry *, struct vfsmount *,\n\t\t\t\t   const char *, int, umode_t);\nextern struct file * dentry_open(const struct path *, int, const struct cred *);\nextern struct file * open_with_fake_path(const struct path *, int,\n\t\t\t\t\t struct inode*, const struct cred *);\nstatic inline struct file *file_clone_open(struct file *file)\n{\n\treturn dentry_open(&file->f_path, file->f_flags, file->f_cred);\n}\nextern int filp_close(struct file *, fl_owner_t id);\n\nextern struct filename *getname_flags(const char __user *, int, int *);\nextern struct filename *getname(const char __user *);\nextern struct filename *getname_kernel(const char *);\nextern void putname(struct filename *name);\n\nextern int finish_open(struct file *file, struct dentry *dentry,\n\t\t\tint (*open)(struct inode *, struct file *));\nextern int finish_no_open(struct file *file, struct dentry *dentry);\n\n/* fs/dcache.c */\nextern void __init vfs_caches_init_early(void);\nextern void __init vfs_caches_init(void);\n\nextern struct kmem_cache *names_cachep;\n\n#define __getname()\t\tkmem_cache_alloc(names_cachep, GFP_KERNEL)\n#define __putname(name)\t\tkmem_cache_free(names_cachep, (void *)(name))\n\nextern struct super_block *blockdev_superblock;\nstatic inline bool sb_is_blkdev_sb(struct super_block *sb)\n{\n\treturn IS_ENABLED(CONFIG_BLOCK) && sb == blockdev_superblock;\n}\n\nvoid emergency_thaw_all(void);\nextern int sync_filesystem(struct super_block *);\nextern const struct file_operations def_blk_fops;\nextern const struct file_operations def_chr_fops;\n\n/* fs/char_dev.c */\n#define CHRDEV_MAJOR_MAX 512\n/* Marks the bottom of the first segment of free char majors */\n#define CHRDEV_MAJOR_DYN_END 234\n/* Marks the top and bottom of the second segment of free char majors */\n#define CHRDEV_MAJOR_DYN_EXT_START 511\n#define CHRDEV_MAJOR_DYN_EXT_END 384\n\nextern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);\nextern int register_chrdev_region(dev_t, unsigned, const char *);\nextern int __register_chrdev(unsigned int major, unsigned int baseminor,\n\t\t\t     unsigned int count, const char *name,\n\t\t\t     const struct file_operations *fops);\nextern void __unregister_chrdev(unsigned int major, unsigned int baseminor,\n\t\t\t\tunsigned int count, const char *name);\nextern void unregister_chrdev_region(dev_t, unsigned);\nextern void chrdev_show(struct seq_file *,off_t);\n\nstatic inline int register_chrdev(unsigned int major, const char *name,\n\t\t\t\t  const struct file_operations *fops)\n{\n\treturn __register_chrdev(major, 0, 256, name, fops);\n}\n\nstatic inline void unregister_chrdev(unsigned int major, const char *name)\n{\n\t__unregister_chrdev(major, 0, 256, name);\n}\n\nextern void init_special_inode(struct inode *, umode_t, dev_t);\n\n/* Invalid inode operations -- fs/bad_inode.c */\nextern void make_bad_inode(struct inode *);\nextern bool is_bad_inode(struct inode *);\n\nunsigned long invalidate_mapping_pages(struct address_space *mapping,\n\t\t\t\t\tpgoff_t start, pgoff_t end);\n\nvoid invalidate_mapping_pagevec(struct address_space *mapping,\n\t\t\t\tpgoff_t start, pgoff_t end,\n\t\t\t\tunsigned long *nr_pagevec);\n\nstatic inline void invalidate_remote_inode(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode))\n\t\tinvalidate_mapping_pages(inode->i_mapping, 0, -1);\n}\nextern int invalidate_inode_pages2(struct address_space *mapping);\nextern int invalidate_inode_pages2_range(struct address_space *mapping,\n\t\t\t\t\t pgoff_t start, pgoff_t end);\nextern int write_inode_now(struct inode *, int);\nextern int filemap_fdatawrite(struct address_space *);\nextern int filemap_flush(struct address_space *);\nextern int filemap_fdatawait_keep_errors(struct address_space *mapping);\nextern int filemap_fdatawait_range(struct address_space *, loff_t lstart,\n\t\t\t\t   loff_t lend);\nextern int filemap_fdatawait_range_keep_errors(struct address_space *mapping,\n\t\tloff_t start_byte, loff_t end_byte);\n\nstatic inline int filemap_fdatawait(struct address_space *mapping)\n{\n\treturn filemap_fdatawait_range(mapping, 0, LLONG_MAX);\n}\n\nextern bool filemap_range_has_page(struct address_space *, loff_t lstart,\n\t\t\t\t  loff_t lend);\nextern int filemap_write_and_wait_range(struct address_space *mapping,\n\t\t\t\t        loff_t lstart, loff_t lend);\nextern int __filemap_fdatawrite_range(struct address_space *mapping,\n\t\t\t\tloff_t start, loff_t end, int sync_mode);\nextern int filemap_fdatawrite_range(struct address_space *mapping,\n\t\t\t\tloff_t start, loff_t end);\nextern int filemap_check_errors(struct address_space *mapping);\nextern void __filemap_set_wb_err(struct address_space *mapping, int err);\n\nstatic inline int filemap_write_and_wait(struct address_space *mapping)\n{\n\treturn filemap_write_and_wait_range(mapping, 0, LLONG_MAX);\n}\n\nextern int __must_check file_fdatawait_range(struct file *file, loff_t lstart,\n\t\t\t\t\t\tloff_t lend);\nextern int __must_check file_check_and_advance_wb_err(struct file *file);\nextern int __must_check file_write_and_wait_range(struct file *file,\n\t\t\t\t\t\tloff_t start, loff_t end);\n\nstatic inline int file_write_and_wait(struct file *file)\n{\n\treturn file_write_and_wait_range(file, 0, LLONG_MAX);\n}\n\n/**\n * filemap_set_wb_err - set a writeback error on an address_space\n * @mapping: mapping in which to set writeback error\n * @err: error to be set in mapping\n *\n * When writeback fails in some way, we must record that error so that\n * userspace can be informed when fsync and the like are called.  We endeavor\n * to report errors on any file that was open at the time of the error.  Some\n * internal callers also need to know when writeback errors have occurred.\n *\n * When a writeback error occurs, most filesystems will want to call\n * filemap_set_wb_err to record the error in the mapping so that it will be\n * automatically reported whenever fsync is called on the file.\n */\nstatic inline void filemap_set_wb_err(struct address_space *mapping, int err)\n{\n\t/* Fastpath for common case of no error */\n\tif (unlikely(err))\n\t\t__filemap_set_wb_err(mapping, err);\n}\n\n/**\n * filemap_check_wb_err - has an error occurred since the mark was sampled?\n * @mapping: mapping to check for writeback errors\n * @since: previously-sampled errseq_t\n *\n * Grab the errseq_t value from the mapping, and see if it has changed \"since\"\n * the given value was sampled.\n *\n * If it has then report the latest error set, otherwise return 0.\n */\nstatic inline int filemap_check_wb_err(struct address_space *mapping,\n\t\t\t\t\terrseq_t since)\n{\n\treturn errseq_check(&mapping->wb_err, since);\n}\n\n/**\n * filemap_sample_wb_err - sample the current errseq_t to test for later errors\n * @mapping: mapping to be sampled\n *\n * Writeback errors are always reported relative to a particular sample point\n * in the past. This function provides those sample points.\n */\nstatic inline errseq_t filemap_sample_wb_err(struct address_space *mapping)\n{\n\treturn errseq_sample(&mapping->wb_err);\n}\n\n/**\n * file_sample_sb_err - sample the current errseq_t to test for later errors\n * @file: file pointer to be sampled\n *\n * Grab the most current superblock-level errseq_t value for the given\n * struct file.\n */\nstatic inline errseq_t file_sample_sb_err(struct file *file)\n{\n\treturn errseq_sample(&file->f_path.dentry->d_sb->s_wb_err);\n}\n\nextern int vfs_fsync_range(struct file *file, loff_t start, loff_t end,\n\t\t\t   int datasync);\nextern int vfs_fsync(struct file *file, int datasync);\n\nextern int sync_file_range(struct file *file, loff_t offset, loff_t nbytes,\n\t\t\t\tunsigned int flags);\n\n/*\n * Sync the bytes written if this was a synchronous write.  Expect ki_pos\n * to already be updated for the write, and will return either the amount\n * of bytes passed in, or an error if syncing the file failed.\n */\nstatic inline ssize_t generic_write_sync(struct kiocb *iocb, ssize_t count)\n{\n\tif (iocb->ki_flags & IOCB_DSYNC) {\n\t\tint ret = vfs_fsync_range(iocb->ki_filp,\n\t\t\t\tiocb->ki_pos - count, iocb->ki_pos - 1,\n\t\t\t\t(iocb->ki_flags & IOCB_SYNC) ? 0 : 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn count;\n}\n\nextern void emergency_sync(void);\nextern void emergency_remount(void);\n\n#ifdef CONFIG_BLOCK\nextern int bmap(struct inode *inode, sector_t *block);\n#else\nstatic inline int bmap(struct inode *inode,  sector_t *block)\n{\n\treturn -EINVAL;\n}\n#endif\n\nextern int notify_change(struct dentry *, struct iattr *, struct inode **);\nextern int inode_permission(struct inode *, int);\nextern int generic_permission(struct inode *, int);\nextern int __check_sticky(struct inode *dir, struct inode *inode);\n\nstatic inline bool execute_ok(struct inode *inode)\n{\n\treturn (inode->i_mode & S_IXUGO) || S_ISDIR(inode->i_mode);\n}\n\nstatic inline void file_start_write(struct file *file)\n{\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn;\n\t__sb_start_write(file_inode(file)->i_sb, SB_FREEZE_WRITE, true);\n}\n\nstatic inline bool file_start_write_trylock(struct file *file)\n{\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn true;\n\treturn __sb_start_write(file_inode(file)->i_sb, SB_FREEZE_WRITE, false);\n}\n\nstatic inline void file_end_write(struct file *file)\n{\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn;\n\t__sb_end_write(file_inode(file)->i_sb, SB_FREEZE_WRITE);\n}\n\n/*\n * get_write_access() gets write permission for a file.\n * put_write_access() releases this write permission.\n * This is used for regular files.\n * We cannot support write (and maybe mmap read-write shared) accesses and\n * MAP_DENYWRITE mmappings simultaneously. The i_writecount field of an inode\n * can have the following values:\n * 0: no writers, no VM_DENYWRITE mappings\n * < 0: (-i_writecount) vm_area_structs with VM_DENYWRITE set exist\n * > 0: (i_writecount) users are writing to the file.\n *\n * Normally we operate on that counter with atomic_{inc,dec} and it's safe\n * except for the cases where we don't hold i_writecount yet. Then we need to\n * use {get,deny}_write_access() - these functions check the sign and refuse\n * to do the change if sign is wrong.\n */\nstatic inline int get_write_access(struct inode *inode)\n{\n\treturn atomic_inc_unless_negative(&inode->i_writecount) ? 0 : -ETXTBSY;\n}\nstatic inline int deny_write_access(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\treturn atomic_dec_unless_positive(&inode->i_writecount) ? 0 : -ETXTBSY;\n}\nstatic inline void put_write_access(struct inode * inode)\n{\n\tatomic_dec(&inode->i_writecount);\n}\nstatic inline void allow_write_access(struct file *file)\n{\n\tif (file)\n\t\tatomic_inc(&file_inode(file)->i_writecount);\n}\nstatic inline bool inode_is_open_for_write(const struct inode *inode)\n{\n\treturn atomic_read(&inode->i_writecount) > 0;\n}\n\n#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)\nstatic inline void i_readcount_dec(struct inode *inode)\n{\n\tBUG_ON(!atomic_read(&inode->i_readcount));\n\tatomic_dec(&inode->i_readcount);\n}\nstatic inline void i_readcount_inc(struct inode *inode)\n{\n\tatomic_inc(&inode->i_readcount);\n}\n#else\nstatic inline void i_readcount_dec(struct inode *inode)\n{\n\treturn;\n}\nstatic inline void i_readcount_inc(struct inode *inode)\n{\n\treturn;\n}\n#endif\nextern int do_pipe_flags(int *, int);\n\nextern ssize_t kernel_read(struct file *, void *, size_t, loff_t *);\nssize_t __kernel_read(struct file *file, void *buf, size_t count, loff_t *pos);\nextern ssize_t kernel_write(struct file *, const void *, size_t, loff_t *);\nextern ssize_t __kernel_write(struct file *, const void *, size_t, loff_t *);\nextern struct file * open_exec(const char *);\n \n/* fs/dcache.c -- generic fs support functions */\nextern bool is_subdir(struct dentry *, struct dentry *);\nextern bool path_is_under(const struct path *, const struct path *);\n\nextern char *file_path(struct file *, char *, int);\n\n#include <linux/err.h>\n\n/* needed for stackable file system support */\nextern loff_t default_llseek(struct file *file, loff_t offset, int whence);\n\nextern loff_t vfs_llseek(struct file *file, loff_t offset, int whence);\n\nextern int inode_init_always(struct super_block *, struct inode *);\nextern void inode_init_once(struct inode *);\nextern void address_space_init_once(struct address_space *mapping);\nextern struct inode * igrab(struct inode *);\nextern ino_t iunique(struct super_block *, ino_t);\nextern int inode_needs_sync(struct inode *inode);\nextern int generic_delete_inode(struct inode *inode);\nstatic inline int generic_drop_inode(struct inode *inode)\n{\n\treturn !inode->i_nlink || inode_unhashed(inode) ||\n\t\t(inode->i_state & I_DONTCACHE);\n}\nextern void d_mark_dontcache(struct inode *inode);\n\nextern struct inode *ilookup5_nowait(struct super_block *sb,\n\t\tunsigned long hashval, int (*test)(struct inode *, void *),\n\t\tvoid *data);\nextern struct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data);\nextern struct inode *ilookup(struct super_block *sb, unsigned long ino);\n\nextern struct inode *inode_insert5(struct inode *inode, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *),\n\t\tvoid *data);\nextern struct inode * iget5_locked(struct super_block *, unsigned long, int (*test)(struct inode *, void *), int (*set)(struct inode *, void *), void *);\nextern struct inode * iget_locked(struct super_block *, unsigned long);\nextern struct inode *find_inode_nowait(struct super_block *,\n\t\t\t\t       unsigned long,\n\t\t\t\t       int (*match)(struct inode *,\n\t\t\t\t\t\t    unsigned long, void *),\n\t\t\t\t       void *data);\nextern struct inode *find_inode_rcu(struct super_block *, unsigned long,\n\t\t\t\t    int (*)(struct inode *, void *), void *);\nextern struct inode *find_inode_by_ino_rcu(struct super_block *, unsigned long);\nextern int insert_inode_locked4(struct inode *, unsigned long, int (*test)(struct inode *, void *), void *);\nextern int insert_inode_locked(struct inode *);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nextern void lockdep_annotate_inode_mutex_key(struct inode *inode);\n#else\nstatic inline void lockdep_annotate_inode_mutex_key(struct inode *inode) { };\n#endif\nextern void unlock_new_inode(struct inode *);\nextern void discard_new_inode(struct inode *);\nextern unsigned int get_next_ino(void);\nextern void evict_inodes(struct super_block *sb);\n\n/*\n * Userspace may rely on the the inode number being non-zero. For example, glibc\n * simply ignores files with zero i_ino in unlink() and other places.\n *\n * As an additional complication, if userspace was compiled with\n * _FILE_OFFSET_BITS=32 on a 64-bit kernel we'll only end up reading out the\n * lower 32 bits, so we need to check that those aren't zero explicitly. With\n * _FILE_OFFSET_BITS=64, this may cause some harmless false-negatives, but\n * better safe than sorry.\n */\nstatic inline bool is_zero_ino(ino_t ino)\n{\n\treturn (u32)ino == 0;\n}\n\nextern void __iget(struct inode * inode);\nextern void iget_failed(struct inode *);\nextern void clear_inode(struct inode *);\nextern void __destroy_inode(struct inode *);\nextern struct inode *new_inode_pseudo(struct super_block *sb);\nextern struct inode *new_inode(struct super_block *sb);\nextern void free_inode_nonrcu(struct inode *inode);\nextern int should_remove_suid(struct dentry *);\nextern int file_remove_privs(struct file *);\n\nextern void __insert_inode_hash(struct inode *, unsigned long hashval);\nstatic inline void insert_inode_hash(struct inode *inode)\n{\n\t__insert_inode_hash(inode, inode->i_ino);\n}\n\nextern void __remove_inode_hash(struct inode *);\nstatic inline void remove_inode_hash(struct inode *inode)\n{\n\tif (!inode_unhashed(inode) && !hlist_fake(&inode->i_hash))\n\t\t__remove_inode_hash(inode);\n}\n\nextern void inode_sb_list_add(struct inode *inode);\n\nextern int sb_set_blocksize(struct super_block *, int);\nextern int sb_min_blocksize(struct super_block *, int);\n\nextern int generic_file_mmap(struct file *, struct vm_area_struct *);\nextern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);\nextern ssize_t generic_write_checks(struct kiocb *, struct iov_iter *);\nextern int generic_write_check_limits(struct file *file, loff_t pos,\n\t\tloff_t *count);\nextern int generic_file_rw_checks(struct file *file_in, struct file *file_out);\nextern ssize_t generic_file_buffered_read(struct kiocb *iocb,\n\t\tstruct iov_iter *to, ssize_t already_read);\nextern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);\nextern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);\nextern ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);\nextern ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *);\nextern ssize_t generic_perform_write(struct file *, struct iov_iter *, loff_t);\n\nssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos,\n\t\trwf_t flags);\nssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos,\n\t\trwf_t flags);\nssize_t vfs_iocb_iter_read(struct file *file, struct kiocb *iocb,\n\t\t\t   struct iov_iter *iter);\nssize_t vfs_iocb_iter_write(struct file *file, struct kiocb *iocb,\n\t\t\t    struct iov_iter *iter);\n\n/* fs/block_dev.c */\nextern ssize_t blkdev_read_iter(struct kiocb *iocb, struct iov_iter *to);\nextern ssize_t blkdev_write_iter(struct kiocb *iocb, struct iov_iter *from);\nextern int blkdev_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\tint datasync);\nextern void block_sync_page(struct page *page);\n\n/* fs/splice.c */\nextern ssize_t generic_file_splice_read(struct file *, loff_t *,\n\t\tstruct pipe_inode_info *, size_t, unsigned int);\nextern ssize_t iter_file_splice_write(struct pipe_inode_info *,\n\t\tstruct file *, loff_t *, size_t, unsigned int);\nextern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,\n\t\tstruct file *out, loff_t *, size_t len, unsigned int flags);\nextern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,\n\t\tloff_t *opos, size_t len, unsigned int flags);\n\n\nextern void\nfile_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);\nextern loff_t noop_llseek(struct file *file, loff_t offset, int whence);\nextern loff_t no_llseek(struct file *file, loff_t offset, int whence);\nextern loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize);\nextern loff_t generic_file_llseek(struct file *file, loff_t offset, int whence);\nextern loff_t generic_file_llseek_size(struct file *file, loff_t offset,\n\t\tint whence, loff_t maxsize, loff_t eof);\nextern loff_t fixed_size_llseek(struct file *file, loff_t offset,\n\t\tint whence, loff_t size);\nextern loff_t no_seek_end_llseek_size(struct file *, loff_t, int, loff_t);\nextern loff_t no_seek_end_llseek(struct file *, loff_t, int);\nextern int generic_file_open(struct inode * inode, struct file * filp);\nextern int nonseekable_open(struct inode * inode, struct file * filp);\nextern int stream_open(struct inode * inode, struct file * filp);\n\n#ifdef CONFIG_BLOCK\ntypedef void (dio_submit_t)(struct bio *bio, struct inode *inode,\n\t\t\t    loff_t file_offset);\n\nenum {\n\t/* need locking between buffered and direct access */\n\tDIO_LOCKING\t= 0x01,\n\n\t/* filesystem does not support filling holes */\n\tDIO_SKIP_HOLES\t= 0x02,\n};\n\nssize_t __blockdev_direct_IO(struct kiocb *iocb, struct inode *inode,\n\t\t\t     struct block_device *bdev, struct iov_iter *iter,\n\t\t\t     get_block_t get_block,\n\t\t\t     dio_iodone_t end_io, dio_submit_t submit_io,\n\t\t\t     int flags);\n\nstatic inline ssize_t blockdev_direct_IO(struct kiocb *iocb,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t struct iov_iter *iter,\n\t\t\t\t\t get_block_t get_block)\n{\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev, iter,\n\t\t\tget_block, NULL, NULL, DIO_LOCKING | DIO_SKIP_HOLES);\n}\n#endif\n\nvoid inode_dio_wait(struct inode *inode);\n\n/*\n * inode_dio_begin - signal start of a direct I/O requests\n * @inode: inode the direct I/O happens on\n *\n * This is called once we've finished processing a direct I/O request,\n * and is used to wake up callers waiting for direct I/O to be quiesced.\n */\nstatic inline void inode_dio_begin(struct inode *inode)\n{\n\tatomic_inc(&inode->i_dio_count);\n}\n\n/*\n * inode_dio_end - signal finish of a direct I/O requests\n * @inode: inode the direct I/O happens on\n *\n * This is called once we've finished processing a direct I/O request,\n * and is used to wake up callers waiting for direct I/O to be quiesced.\n */\nstatic inline void inode_dio_end(struct inode *inode)\n{\n\tif (atomic_dec_and_test(&inode->i_dio_count))\n\t\twake_up_bit(&inode->i_state, __I_DIO_WAKEUP);\n}\n\n/*\n * Warn about a page cache invalidation failure diring a direct I/O write.\n */\nvoid dio_warn_stale_pagecache(struct file *filp);\n\nextern void inode_set_flags(struct inode *inode, unsigned int flags,\n\t\t\t    unsigned int mask);\n\nextern const struct file_operations generic_ro_fops;\n\n#define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))\n\nextern int readlink_copy(char __user *, int, const char *);\nextern int page_readlink(struct dentry *, char __user *, int);\nextern const char *page_get_link(struct dentry *, struct inode *,\n\t\t\t\t struct delayed_call *);\nextern void page_put_link(void *);\nextern int __page_symlink(struct inode *inode, const char *symname, int len,\n\t\tint nofs);\nextern int page_symlink(struct inode *inode, const char *symname, int len);\nextern const struct inode_operations page_symlink_inode_operations;\nextern void kfree_link(void *);\nextern void generic_fillattr(struct inode *, struct kstat *);\nextern int vfs_getattr_nosec(const struct path *, struct kstat *, u32, unsigned int);\nextern int vfs_getattr(const struct path *, struct kstat *, u32, unsigned int);\nvoid __inode_add_bytes(struct inode *inode, loff_t bytes);\nvoid inode_add_bytes(struct inode *inode, loff_t bytes);\nvoid __inode_sub_bytes(struct inode *inode, loff_t bytes);\nvoid inode_sub_bytes(struct inode *inode, loff_t bytes);\nstatic inline loff_t __inode_get_bytes(struct inode *inode)\n{\n\treturn (((loff_t)inode->i_blocks) << 9) + inode->i_bytes;\n}\nloff_t inode_get_bytes(struct inode *inode);\nvoid inode_set_bytes(struct inode *inode, loff_t bytes);\nconst char *simple_get_link(struct dentry *, struct inode *,\n\t\t\t    struct delayed_call *);\nextern const struct inode_operations simple_symlink_inode_operations;\n\nextern int iterate_dir(struct file *, struct dir_context *);\n\nint vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,\n\t\tint flags);\nint vfs_fstat(int fd, struct kstat *stat);\n\nstatic inline int vfs_stat(const char __user *filename, struct kstat *stat)\n{\n\treturn vfs_fstatat(AT_FDCWD, filename, stat, 0);\n}\nstatic inline int vfs_lstat(const char __user *name, struct kstat *stat)\n{\n\treturn vfs_fstatat(AT_FDCWD, name, stat, AT_SYMLINK_NOFOLLOW);\n}\n\nextern const char *vfs_get_link(struct dentry *, struct delayed_call *);\nextern int vfs_readlink(struct dentry *, char __user *, int);\n\nextern struct file_system_type *get_filesystem(struct file_system_type *fs);\nextern void put_filesystem(struct file_system_type *fs);\nextern struct file_system_type *get_fs_type(const char *name);\nextern struct super_block *get_super(struct block_device *);\nextern struct super_block *get_super_thawed(struct block_device *);\nextern struct super_block *get_super_exclusive_thawed(struct block_device *bdev);\nextern struct super_block *get_active_super(struct block_device *bdev);\nextern void drop_super(struct super_block *sb);\nextern void drop_super_exclusive(struct super_block *sb);\nextern void iterate_supers(void (*)(struct super_block *, void *), void *);\nextern void iterate_supers_type(struct file_system_type *,\n\t\t\t        void (*)(struct super_block *, void *), void *);\n\nextern int dcache_dir_open(struct inode *, struct file *);\nextern int dcache_dir_close(struct inode *, struct file *);\nextern loff_t dcache_dir_lseek(struct file *, loff_t, int);\nextern int dcache_readdir(struct file *, struct dir_context *);\nextern int simple_setattr(struct dentry *, struct iattr *);\nextern int simple_getattr(const struct path *, struct kstat *, u32, unsigned int);\nextern int simple_statfs(struct dentry *, struct kstatfs *);\nextern int simple_open(struct inode *inode, struct file *file);\nextern int simple_link(struct dentry *, struct inode *, struct dentry *);\nextern int simple_unlink(struct inode *, struct dentry *);\nextern int simple_rmdir(struct inode *, struct dentry *);\nextern int simple_rename(struct inode *, struct dentry *,\n\t\t\t struct inode *, struct dentry *, unsigned int);\nextern void simple_recursive_removal(struct dentry *,\n                              void (*callback)(struct dentry *));\nextern int noop_fsync(struct file *, loff_t, loff_t, int);\nextern int noop_set_page_dirty(struct page *page);\nextern void noop_invalidatepage(struct page *page, unsigned int offset,\n\t\tunsigned int length);\nextern ssize_t noop_direct_IO(struct kiocb *iocb, struct iov_iter *iter);\nextern int simple_empty(struct dentry *);\nextern int simple_readpage(struct file *file, struct page *page);\nextern int simple_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata);\nextern int simple_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata);\nextern int always_delete_dentry(const struct dentry *);\nextern struct inode *alloc_anon_inode(struct super_block *);\nextern int simple_nosetlease(struct file *, long, struct file_lock **, void **);\nextern const struct dentry_operations simple_dentry_operations;\n\nextern struct dentry *simple_lookup(struct inode *, struct dentry *, unsigned int flags);\nextern ssize_t generic_read_dir(struct file *, char __user *, size_t, loff_t *);\nextern const struct file_operations simple_dir_operations;\nextern const struct inode_operations simple_dir_inode_operations;\nextern void make_empty_dir_inode(struct inode *inode);\nextern bool is_empty_dir_inode(struct inode *inode);\nstruct tree_descr { const char *name; const struct file_operations *ops; int mode; };\nstruct dentry *d_alloc_name(struct dentry *, const char *);\nextern int simple_fill_super(struct super_block *, unsigned long,\n\t\t\t     const struct tree_descr *);\nextern int simple_pin_fs(struct file_system_type *, struct vfsmount **mount, int *count);\nextern void simple_release_fs(struct vfsmount **mount, int *count);\n\nextern ssize_t simple_read_from_buffer(void __user *to, size_t count,\n\t\t\tloff_t *ppos, const void *from, size_t available);\nextern ssize_t simple_write_to_buffer(void *to, size_t available, loff_t *ppos,\n\t\tconst void __user *from, size_t count);\n\nextern int __generic_file_fsync(struct file *, loff_t, loff_t, int);\nextern int generic_file_fsync(struct file *, loff_t, loff_t, int);\n\nextern int generic_check_addressable(unsigned, u64);\n\n#ifdef CONFIG_UNICODE\nextern int generic_ci_d_hash(const struct dentry *dentry, struct qstr *str);\nextern int generic_ci_d_compare(const struct dentry *dentry, unsigned int len,\n\t\t\t\tconst char *str, const struct qstr *name);\n#endif\n\n#ifdef CONFIG_MIGRATION\nextern int buffer_migrate_page(struct address_space *,\n\t\t\t\tstruct page *, struct page *,\n\t\t\t\tenum migrate_mode);\nextern int buffer_migrate_page_norefs(struct address_space *,\n\t\t\t\tstruct page *, struct page *,\n\t\t\t\tenum migrate_mode);\n#else\n#define buffer_migrate_page NULL\n#define buffer_migrate_page_norefs NULL\n#endif\n\nextern int setattr_prepare(struct dentry *, struct iattr *);\nextern int inode_newsize_ok(const struct inode *, loff_t offset);\nextern void setattr_copy(struct inode *inode, const struct iattr *attr);\n\nextern int file_update_time(struct file *file);\n\nstatic inline bool vma_is_dax(const struct vm_area_struct *vma)\n{\n\treturn vma->vm_file && IS_DAX(vma->vm_file->f_mapping->host);\n}\n\nstatic inline bool vma_is_fsdax(struct vm_area_struct *vma)\n{\n\tstruct inode *inode;\n\n\tif (!vma->vm_file)\n\t\treturn false;\n\tif (!vma_is_dax(vma))\n\t\treturn false;\n\tinode = file_inode(vma->vm_file);\n\tif (S_ISCHR(inode->i_mode))\n\t\treturn false; /* device-dax */\n\treturn true;\n}\n\nstatic inline int iocb_flags(struct file *file)\n{\n\tint res = 0;\n\tif (file->f_flags & O_APPEND)\n\t\tres |= IOCB_APPEND;\n\tif (file->f_flags & O_DIRECT)\n\t\tres |= IOCB_DIRECT;\n\tif ((file->f_flags & O_DSYNC) || IS_SYNC(file->f_mapping->host))\n\t\tres |= IOCB_DSYNC;\n\tif (file->f_flags & __O_SYNC)\n\t\tres |= IOCB_SYNC;\n\treturn res;\n}\n\nstatic inline int kiocb_set_rw_flags(struct kiocb *ki, rwf_t flags)\n{\n\tint kiocb_flags = 0;\n\n\t/* make sure there's no overlap between RWF and private IOCB flags */\n\tBUILD_BUG_ON((__force int) RWF_SUPPORTED & IOCB_EVENTFD);\n\n\tif (!flags)\n\t\treturn 0;\n\tif (unlikely(flags & ~RWF_SUPPORTED))\n\t\treturn -EOPNOTSUPP;\n\n\tif (flags & RWF_NOWAIT) {\n\t\tif (!(ki->ki_filp->f_mode & FMODE_NOWAIT))\n\t\t\treturn -EOPNOTSUPP;\n\t\tkiocb_flags |= IOCB_NOIO;\n\t}\n\tkiocb_flags |= (__force int) (flags & RWF_SUPPORTED);\n\tif (flags & RWF_SYNC)\n\t\tkiocb_flags |= IOCB_DSYNC;\n\n\tki->ki_flags |= kiocb_flags;\n\treturn 0;\n}\n\nstatic inline ino_t parent_ino(struct dentry *dentry)\n{\n\tino_t res;\n\n\t/*\n\t * Don't strictly need d_lock here? If the parent ino could change\n\t * then surely we'd have a deeper race in the caller?\n\t */\n\tspin_lock(&dentry->d_lock);\n\tres = dentry->d_parent->d_inode->i_ino;\n\tspin_unlock(&dentry->d_lock);\n\treturn res;\n}\n\n/* Transaction based IO helpers */\n\n/*\n * An argresp is stored in an allocated page and holds the\n * size of the argument or response, along with its content\n */\nstruct simple_transaction_argresp {\n\tssize_t size;\n\tchar data[];\n};\n\n#define SIMPLE_TRANSACTION_LIMIT (PAGE_SIZE - sizeof(struct simple_transaction_argresp))\n\nchar *simple_transaction_get(struct file *file, const char __user *buf,\n\t\t\t\tsize_t size);\nssize_t simple_transaction_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t size, loff_t *pos);\nint simple_transaction_release(struct inode *inode, struct file *file);\n\nvoid simple_transaction_set(struct file *file, size_t n);\n\n/*\n * simple attribute files\n *\n * These attributes behave similar to those in sysfs:\n *\n * Writing to an attribute immediately sets a value, an open file can be\n * written to multiple times.\n *\n * Reading from an attribute creates a buffer from the value that might get\n * read with multiple read calls. When the attribute has been read\n * completely, no further read calls are possible until the file is opened\n * again.\n *\n * All attributes contain a text representation of a numeric value\n * that are accessed with the get() and set() functions.\n */\n#define DEFINE_SIMPLE_ATTRIBUTE(__fops, __get, __set, __fmt)\t\t\\\nstatic int __fops ## _open(struct inode *inode, struct file *file)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t__simple_attr_check_format(__fmt, 0ull);\t\t\t\\\n\treturn simple_attr_open(inode, file, __get, __set, __fmt);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic const struct file_operations __fops = {\t\t\t\t\\\n\t.owner\t = THIS_MODULE,\t\t\t\t\t\t\\\n\t.open\t = __fops ## _open,\t\t\t\t\t\\\n\t.release = simple_attr_release,\t\t\t\t\t\\\n\t.read\t = simple_attr_read,\t\t\t\t\t\\\n\t.write\t = simple_attr_write,\t\t\t\t\t\\\n\t.llseek\t = generic_file_llseek,\t\t\t\t\t\\\n}\n\nstatic inline __printf(1, 2)\nvoid __simple_attr_check_format(const char *fmt, ...)\n{\n\t/* don't do anything, just let the compiler check the arguments; */\n}\n\nint simple_attr_open(struct inode *inode, struct file *file,\n\t\t     int (*get)(void *, u64 *), int (*set)(void *, u64),\n\t\t     const char *fmt);\nint simple_attr_release(struct inode *inode, struct file *file);\nssize_t simple_attr_read(struct file *file, char __user *buf,\n\t\t\t size_t len, loff_t *ppos);\nssize_t simple_attr_write(struct file *file, const char __user *buf,\n\t\t\t  size_t len, loff_t *ppos);\n\nstruct ctl_table;\nint proc_nr_files(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos);\nint proc_nr_dentry(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos);\nint proc_nr_inodes(struct ctl_table *table, int write,\n\t\t   void *buffer, size_t *lenp, loff_t *ppos);\nint __init get_filesystem_list(char *buf);\n\n#define __FMODE_EXEC\t\t((__force int) FMODE_EXEC)\n#define __FMODE_NONOTIFY\t((__force int) FMODE_NONOTIFY)\n\n#define ACC_MODE(x) (\"\\004\\002\\006\\006\"[(x)&O_ACCMODE])\n#define OPEN_FMODE(flag) ((__force fmode_t)(((flag + 1) & O_ACCMODE) | \\\n\t\t\t\t\t    (flag & __FMODE_NONOTIFY)))\n\nstatic inline bool is_sxid(umode_t mode)\n{\n\treturn (mode & S_ISUID) || ((mode & S_ISGID) && (mode & S_IXGRP));\n}\n\nstatic inline int check_sticky(struct inode *dir, struct inode *inode)\n{\n\tif (!(dir->i_mode & S_ISVTX))\n\t\treturn 0;\n\n\treturn __check_sticky(dir, inode);\n}\n\nstatic inline void inode_has_no_xattr(struct inode *inode)\n{\n\tif (!is_sxid(inode->i_mode) && (inode->i_sb->s_flags & SB_NOSEC))\n\t\tinode->i_flags |= S_NOSEC;\n}\n\nstatic inline bool is_root_inode(struct inode *inode)\n{\n\treturn inode == inode->i_sb->s_root->d_inode;\n}\n\nstatic inline bool dir_emit(struct dir_context *ctx,\n\t\t\t    const char *name, int namelen,\n\t\t\t    u64 ino, unsigned type)\n{\n\treturn ctx->actor(ctx, name, namelen, ctx->pos, ino, type) == 0;\n}\nstatic inline bool dir_emit_dot(struct file *file, struct dir_context *ctx)\n{\n\treturn ctx->actor(ctx, \".\", 1, ctx->pos,\n\t\t\t  file->f_path.dentry->d_inode->i_ino, DT_DIR) == 0;\n}\nstatic inline bool dir_emit_dotdot(struct file *file, struct dir_context *ctx)\n{\n\treturn ctx->actor(ctx, \"..\", 2, ctx->pos,\n\t\t\t  parent_ino(file->f_path.dentry), DT_DIR) == 0;\n}\nstatic inline bool dir_emit_dots(struct file *file, struct dir_context *ctx)\n{\n\tif (ctx->pos == 0) {\n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\treturn false;\n\t\tctx->pos = 1;\n\t}\n\tif (ctx->pos == 1) {\n\t\tif (!dir_emit_dotdot(file, ctx))\n\t\t\treturn false;\n\t\tctx->pos = 2;\n\t}\n\treturn true;\n}\nstatic inline bool dir_relax(struct inode *inode)\n{\n\tinode_unlock(inode);\n\tinode_lock(inode);\n\treturn !IS_DEADDIR(inode);\n}\n\nstatic inline bool dir_relax_shared(struct inode *inode)\n{\n\tinode_unlock_shared(inode);\n\tinode_lock_shared(inode);\n\treturn !IS_DEADDIR(inode);\n}\n\nextern bool path_noexec(const struct path *path);\nextern void inode_nohighmem(struct inode *inode);\n\n/* mm/fadvise.c */\nextern int vfs_fadvise(struct file *file, loff_t offset, loff_t len,\n\t\t       int advice);\nextern int generic_fadvise(struct file *file, loff_t offset, loff_t len,\n\t\t\t   int advice);\n\nint vfs_ioc_setflags_prepare(struct inode *inode, unsigned int oldflags,\n\t\t\t     unsigned int flags);\n\nint vfs_ioc_fssetxattr_check(struct inode *inode, const struct fsxattr *old_fa,\n\t\t\t     struct fsxattr *fa);\n\nstatic inline void simple_fill_fsxattr(struct fsxattr *fa, __u32 xflags)\n{\n\tmemset(fa, 0, sizeof(*fa));\n\tfa->fsx_xflags = xflags;\n}\n\n/*\n * Flush file data before changing attributes.  Caller must hold any locks\n * required to prevent further writes to this file until we're done setting\n * flags.\n */\nstatic inline int inode_drain_writes(struct inode *inode)\n{\n\tinode_dio_wait(inode);\n\treturn filemap_write_and_wait(inode->i_mapping);\n}\n\n#endif /* _LINUX_FS_H */\n"}, "6": {"id": 6, "path": "/src/include/uapi/linux/stat.h", "content": "/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n#ifndef _UAPI_LINUX_STAT_H\n#define _UAPI_LINUX_STAT_H\n\n#include <linux/types.h>\n\n#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)\n\n#define S_IFMT  00170000\n#define S_IFSOCK 0140000\n#define S_IFLNK\t 0120000\n#define S_IFREG  0100000\n#define S_IFBLK  0060000\n#define S_IFDIR  0040000\n#define S_IFCHR  0020000\n#define S_IFIFO  0010000\n#define S_ISUID  0004000\n#define S_ISGID  0002000\n#define S_ISVTX  0001000\n\n#define S_ISLNK(m)\t(((m) & S_IFMT) == S_IFLNK)\n#define S_ISREG(m)\t(((m) & S_IFMT) == S_IFREG)\n#define S_ISDIR(m)\t(((m) & S_IFMT) == S_IFDIR)\n#define S_ISCHR(m)\t(((m) & S_IFMT) == S_IFCHR)\n#define S_ISBLK(m)\t(((m) & S_IFMT) == S_IFBLK)\n#define S_ISFIFO(m)\t(((m) & S_IFMT) == S_IFIFO)\n#define S_ISSOCK(m)\t(((m) & S_IFMT) == S_IFSOCK)\n\n#define S_IRWXU 00700\n#define S_IRUSR 00400\n#define S_IWUSR 00200\n#define S_IXUSR 00100\n\n#define S_IRWXG 00070\n#define S_IRGRP 00040\n#define S_IWGRP 00020\n#define S_IXGRP 00010\n\n#define S_IRWXO 00007\n#define S_IROTH 00004\n#define S_IWOTH 00002\n#define S_IXOTH 00001\n\n#endif\n\n/*\n * Timestamp structure for the timestamps in struct statx.\n *\n * tv_sec holds the number of seconds before (negative) or after (positive)\n * 00:00:00 1st January 1970 UTC.\n *\n * tv_nsec holds a number of nanoseconds (0..999,999,999) after the tv_sec time.\n *\n * __reserved is held in case we need a yet finer resolution.\n */\nstruct statx_timestamp {\n\t__s64\ttv_sec;\n\t__u32\ttv_nsec;\n\t__s32\t__reserved;\n};\n\n/*\n * Structures for the extended file attribute retrieval system call\n * (statx()).\n *\n * The caller passes a mask of what they're specifically interested in as a\n * parameter to statx().  What statx() actually got will be indicated in\n * st_mask upon return.\n *\n * For each bit in the mask argument:\n *\n * - if the datum is not supported:\n *\n *   - the bit will be cleared, and\n *\n *   - the datum will be set to an appropriate fabricated value if one is\n *     available (eg. CIFS can take a default uid and gid), otherwise\n *\n *   - the field will be cleared;\n *\n * - otherwise, if explicitly requested:\n *\n *   - the datum will be synchronised to the server if AT_STATX_FORCE_SYNC is\n *     set or if the datum is considered out of date, and\n *\n *   - the field will be filled in and the bit will be set;\n *\n * - otherwise, if not requested, but available in approximate form without any\n *   effort, it will be filled in anyway, and the bit will be set upon return\n *   (it might not be up to date, however, and no attempt will be made to\n *   synchronise the internal state first);\n *\n * - otherwise the field and the bit will be cleared before returning.\n *\n * Items in STATX_BASIC_STATS may be marked unavailable on return, but they\n * will have values installed for compatibility purposes so that stat() and\n * co. can be emulated in userspace.\n */\nstruct statx {\n\t/* 0x00 */\n\t__u32\tstx_mask;\t/* What results were written [uncond] */\n\t__u32\tstx_blksize;\t/* Preferred general I/O size [uncond] */\n\t__u64\tstx_attributes;\t/* Flags conveying information about the file [uncond] */\n\t/* 0x10 */\n\t__u32\tstx_nlink;\t/* Number of hard links */\n\t__u32\tstx_uid;\t/* User ID of owner */\n\t__u32\tstx_gid;\t/* Group ID of owner */\n\t__u16\tstx_mode;\t/* File mode */\n\t__u16\t__spare0[1];\n\t/* 0x20 */\n\t__u64\tstx_ino;\t/* Inode number */\n\t__u64\tstx_size;\t/* File size */\n\t__u64\tstx_blocks;\t/* Number of 512-byte blocks allocated */\n\t__u64\tstx_attributes_mask; /* Mask to show what's supported in stx_attributes */\n\t/* 0x40 */\n\tstruct statx_timestamp\tstx_atime;\t/* Last access time */\n\tstruct statx_timestamp\tstx_btime;\t/* File creation time */\n\tstruct statx_timestamp\tstx_ctime;\t/* Last attribute change time */\n\tstruct statx_timestamp\tstx_mtime;\t/* Last data modification time */\n\t/* 0x80 */\n\t__u32\tstx_rdev_major;\t/* Device ID of special file [if bdev/cdev] */\n\t__u32\tstx_rdev_minor;\n\t__u32\tstx_dev_major;\t/* ID of device containing file [uncond] */\n\t__u32\tstx_dev_minor;\n\t/* 0x90 */\n\t__u64\tstx_mnt_id;\n\t__u64\t__spare2;\n\t/* 0xa0 */\n\t__u64\t__spare3[12];\t/* Spare space for future expansion */\n\t/* 0x100 */\n};\n\n/*\n * Flags to be stx_mask\n *\n * Query request/result mask for statx() and struct statx::stx_mask.\n *\n * These bits should be set in the mask argument of statx() to request\n * particular items when calling statx().\n */\n#define STATX_TYPE\t\t0x00000001U\t/* Want/got stx_mode & S_IFMT */\n#define STATX_MODE\t\t0x00000002U\t/* Want/got stx_mode & ~S_IFMT */\n#define STATX_NLINK\t\t0x00000004U\t/* Want/got stx_nlink */\n#define STATX_UID\t\t0x00000008U\t/* Want/got stx_uid */\n#define STATX_GID\t\t0x00000010U\t/* Want/got stx_gid */\n#define STATX_ATIME\t\t0x00000020U\t/* Want/got stx_atime */\n#define STATX_MTIME\t\t0x00000040U\t/* Want/got stx_mtime */\n#define STATX_CTIME\t\t0x00000080U\t/* Want/got stx_ctime */\n#define STATX_INO\t\t0x00000100U\t/* Want/got stx_ino */\n#define STATX_SIZE\t\t0x00000200U\t/* Want/got stx_size */\n#define STATX_BLOCKS\t\t0x00000400U\t/* Want/got stx_blocks */\n#define STATX_BASIC_STATS\t0x000007ffU\t/* The stuff in the normal stat struct */\n#define STATX_BTIME\t\t0x00000800U\t/* Want/got stx_btime */\n#define STATX_MNT_ID\t\t0x00001000U\t/* Got stx_mnt_id */\n\n#define STATX__RESERVED\t\t0x80000000U\t/* Reserved for future struct statx expansion */\n\n#ifndef __KERNEL__\n/*\n * This is deprecated, and shall remain the same value in the future.  To avoid\n * confusion please use the equivalent (STATX_BASIC_STATS | STATX_BTIME)\n * instead.\n */\n#define STATX_ALL\t\t0x00000fffU\n#endif\n\n/*\n * Attributes to be found in stx_attributes and masked in stx_attributes_mask.\n *\n * These give information about the features or the state of a file that might\n * be of use to ordinary userspace programs such as GUIs or ls rather than\n * specialised tools.\n *\n * Note that the flags marked [I] correspond to generic FS_IOC_FLAGS\n * semantically.  Where possible, the numerical value is picked to correspond\n * also.\n */\n#define STATX_ATTR_COMPRESSED\t\t0x00000004 /* [I] File is compressed by the fs */\n#define STATX_ATTR_IMMUTABLE\t\t0x00000010 /* [I] File is marked immutable */\n#define STATX_ATTR_APPEND\t\t0x00000020 /* [I] File is append-only */\n#define STATX_ATTR_NODUMP\t\t0x00000040 /* [I] File is not to be dumped */\n#define STATX_ATTR_ENCRYPTED\t\t0x00000800 /* [I] File requires key to decrypt in fs */\n#define STATX_ATTR_AUTOMOUNT\t\t0x00001000 /* Dir: Automount trigger */\n#define STATX_ATTR_MOUNT_ROOT\t\t0x00002000 /* Root of a mount */\n#define STATX_ATTR_VERITY\t\t0x00100000 /* [I] Verity protected file */\n#define STATX_ATTR_DAX\t\t\t0x00002000 /* [I] File is DAX */\n\n\n#endif /* _UAPI_LINUX_STAT_H */\n"}, "7": {"id": 7, "path": "/src/include/linux/compiler.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_COMPILER_H\n#define __LINUX_COMPILER_H\n\n#include <linux/compiler_types.h>\n\n#ifndef __ASSEMBLY__\n\n#ifdef __KERNEL__\n\n/*\n * Note: DISABLE_BRANCH_PROFILING can be used by special lowlevel code\n * to disable branch tracing on a per file basis.\n */\n#if defined(CONFIG_TRACE_BRANCH_PROFILING) \\\n    && !defined(DISABLE_BRANCH_PROFILING) && !defined(__CHECKER__)\nvoid ftrace_likely_update(struct ftrace_likely_data *f, int val,\n\t\t\t  int expect, int is_constant);\n\n#define likely_notrace(x)\t__builtin_expect(!!(x), 1)\n#define unlikely_notrace(x)\t__builtin_expect(!!(x), 0)\n\n#define __branch_check__(x, expect, is_constant) ({\t\t\t\\\n\t\t\tlong ______r;\t\t\t\t\t\\\n\t\t\tstatic struct ftrace_likely_data\t\t\\\n\t\t\t\t__aligned(4)\t\t\t\t\\\n\t\t\t\t__section(_ftrace_annotated_branch)\t\\\n\t\t\t\t______f = {\t\t\t\t\\\n\t\t\t\t.data.func = __func__,\t\t\t\\\n\t\t\t\t.data.file = __FILE__,\t\t\t\\\n\t\t\t\t.data.line = __LINE__,\t\t\t\\\n\t\t\t};\t\t\t\t\t\t\\\n\t\t\t______r = __builtin_expect(!!(x), expect);\t\\\n\t\t\tftrace_likely_update(&______f, ______r,\t\t\\\n\t\t\t\t\t     expect, is_constant);\t\\\n\t\t\t______r;\t\t\t\t\t\\\n\t\t})\n\n/*\n * Using __builtin_constant_p(x) to ignore cases where the return\n * value is always the same.  This idea is taken from a similar patch\n * written by Daniel Walker.\n */\n# ifndef likely\n#  define likely(x)\t(__branch_check__(x, 1, __builtin_constant_p(x)))\n# endif\n# ifndef unlikely\n#  define unlikely(x)\t(__branch_check__(x, 0, __builtin_constant_p(x)))\n# endif\n\n#ifdef CONFIG_PROFILE_ALL_BRANCHES\n/*\n * \"Define 'is'\", Bill Clinton\n * \"Define 'if'\", Steven Rostedt\n */\n#define if(cond, ...) if ( __trace_if_var( !!(cond , ## __VA_ARGS__) ) )\n\n#define __trace_if_var(cond) (__builtin_constant_p(cond) ? (cond) : __trace_if_value(cond))\n\n#define __trace_if_value(cond) ({\t\t\t\\\n\tstatic struct ftrace_branch_data\t\t\\\n\t\t__aligned(4)\t\t\t\t\\\n\t\t__section(_ftrace_branch)\t\t\\\n\t\t__if_trace = {\t\t\t\t\\\n\t\t\t.func = __func__,\t\t\\\n\t\t\t.file = __FILE__,\t\t\\\n\t\t\t.line = __LINE__,\t\t\\\n\t\t};\t\t\t\t\t\\\n\t(cond) ?\t\t\t\t\t\\\n\t\t(__if_trace.miss_hit[1]++,1) :\t\t\\\n\t\t(__if_trace.miss_hit[0]++,0);\t\t\\\n})\n\n#endif /* CONFIG_PROFILE_ALL_BRANCHES */\n\n#else\n# define likely(x)\t__builtin_expect(!!(x), 1)\n# define unlikely(x)\t__builtin_expect(!!(x), 0)\n#endif\n\n/* Optimization barrier */\n#ifndef barrier\n# define barrier() __memory_barrier()\n#endif\n\n#ifndef barrier_data\n# define barrier_data(ptr) barrier()\n#endif\n\n/* workaround for GCC PR82365 if needed */\n#ifndef barrier_before_unreachable\n# define barrier_before_unreachable() do { } while (0)\n#endif\n\n/* Unreachable code */\n#ifdef CONFIG_STACK_VALIDATION\n/*\n * These macros help objtool understand GCC code flow for unreachable code.\n * The __COUNTER__ based labels are a hack to make each instance of the macros\n * unique, to convince GCC not to merge duplicate inline asm statements.\n */\n#define annotate_reachable() ({\t\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.reachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define annotate_unreachable() ({\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.unreachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define ASM_UNREACHABLE\t\t\t\t\t\t\t\\\n\t\"999:\\n\\t\"\t\t\t\t\t\t\t\\\n\t\".pushsection .discard.unreachable\\n\\t\"\t\t\t\t\\\n\t\".long 999b - .\\n\\t\"\t\t\t\t\t\t\\\n\t\".popsection\\n\\t\"\n\n/* Annotate a C jump table to allow objtool to follow the code flow */\n#define __annotate_jump_table __section(.rodata..c_jump_table)\n\n#else\n#define annotate_reachable()\n#define annotate_unreachable()\n#define __annotate_jump_table\n#endif\n\n#ifndef ASM_UNREACHABLE\n# define ASM_UNREACHABLE\n#endif\n#ifndef unreachable\n# define unreachable() do {\t\t\\\n\tannotate_unreachable();\t\t\\\n\t__builtin_unreachable();\t\\\n} while (0)\n#endif\n\n/*\n * KENTRY - kernel entry point\n * This can be used to annotate symbols (functions or data) that are used\n * without their linker symbol being referenced explicitly. For example,\n * interrupt vector handlers, or functions in the kernel image that are found\n * programatically.\n *\n * Not required for symbols exported with EXPORT_SYMBOL, or initcalls. Those\n * are handled in their own way (with KEEP() in linker scripts).\n *\n * KENTRY can be avoided if the symbols in question are marked as KEEP() in the\n * linker script. For example an architecture could KEEP() its entire\n * boot/exception vector code rather than annotate each function and data.\n */\n#ifndef KENTRY\n# define KENTRY(sym)\t\t\t\t\t\t\\\n\textern typeof(sym) sym;\t\t\t\t\t\\\n\tstatic const unsigned long __kentry_##sym\t\t\\\n\t__used\t\t\t\t\t\t\t\\\n\t__attribute__((__section__(\"___kentry+\" #sym)))\t\t\\\n\t= (unsigned long)&sym;\n#endif\n\n#ifndef RELOC_HIDE\n# define RELOC_HIDE(ptr, off)\t\t\t\t\t\\\n  ({ unsigned long __ptr;\t\t\t\t\t\\\n     __ptr = (unsigned long) (ptr);\t\t\t\t\\\n    (typeof(ptr)) (__ptr + (off)); })\n#endif\n\n#ifndef OPTIMIZER_HIDE_VAR\n/* Make the optimizer believe the variable can be manipulated arbitrarily. */\n#define OPTIMIZER_HIDE_VAR(var)\t\t\t\t\t\t\\\n\t__asm__ (\"\" : \"=r\" (var) : \"0\" (var))\n#endif\n\n/* Not-quite-unique ID. */\n#ifndef __UNIQUE_ID\n# define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __LINE__)\n#endif\n\n/**\n * data_race - mark an expression as containing intentional data races\n *\n * This data_race() macro is useful for situations in which data races\n * should be forgiven.  One example is diagnostic code that accesses\n * shared variables but is not a part of the core synchronization design.\n *\n * This macro *does not* affect normal code generation, but is a hint\n * to tooling that data races here are to be ignored.\n */\n#define data_race(expr)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__unqual_scalar_typeof(({ expr; })) __v = ({\t\t\t\\\n\t\t__kcsan_disable_current();\t\t\t\t\\\n\t\texpr;\t\t\t\t\t\t\t\\\n\t});\t\t\t\t\t\t\t\t\\\n\t__kcsan_enable_current();\t\t\t\t\t\\\n\t__v;\t\t\t\t\t\t\t\t\\\n})\n\n#endif /* __KERNEL__ */\n\n/*\n * Force the compiler to emit 'sym' as a symbol, so that we can reference\n * it from inline assembler. Necessary in case 'sym' could be inlined\n * otherwise, or eliminated entirely due to lack of references that are\n * visible to the compiler.\n */\n#define __ADDRESSABLE(sym) \\\n\tstatic void * __section(.discard.addressable) __used \\\n\t\t__UNIQUE_ID(__PASTE(__addressable_,sym)) = (void *)&sym;\n\n/**\n * offset_to_ptr - convert a relative memory offset to an absolute pointer\n * @off:\tthe address of the 32-bit offset value\n */\nstatic inline void *offset_to_ptr(const int *off)\n{\n\treturn (void *)((unsigned long)off + *off);\n}\n\n#endif /* __ASSEMBLY__ */\n\n/* &a[0] degrades to a pointer: a different type from an array */\n#define __must_be_array(a)\tBUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))\n\n/*\n * This is needed in functions which generate the stack canary, see\n * arch/x86/kernel/smpboot.c::start_secondary() for an example.\n */\n#define prevent_tail_call_optimization()\tmb()\n\n#include <asm/rwonce.h>\n\n#endif /* __LINUX_COMPILER_H */\n"}, "8": {"id": 8, "path": "/src/include/linux/err.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_ERR_H\n#define _LINUX_ERR_H\n\n#include <linux/compiler.h>\n#include <linux/types.h>\n\n#include <asm/errno.h>\n\n/*\n * Kernel pointers have redundant information, so we can use a\n * scheme where we can return either an error code or a normal\n * pointer with the same return value.\n *\n * This should be a per-architecture thing, to allow different\n * error and pointer decisions.\n */\n#define MAX_ERRNO\t4095\n\n#ifndef __ASSEMBLY__\n\n#define IS_ERR_VALUE(x) unlikely((unsigned long)(void *)(x) >= (unsigned long)-MAX_ERRNO)\n\nstatic inline void * __must_check ERR_PTR(long error)\n{\n\treturn (void *) error;\n}\n\nstatic inline long __must_check PTR_ERR(__force const void *ptr)\n{\n\treturn (long) ptr;\n}\n\nstatic inline bool __must_check IS_ERR(__force const void *ptr)\n{\n\treturn IS_ERR_VALUE((unsigned long)ptr);\n}\n\nstatic inline bool __must_check IS_ERR_OR_NULL(__force const void *ptr)\n{\n\treturn unlikely(!ptr) || IS_ERR_VALUE((unsigned long)ptr);\n}\n\n/**\n * ERR_CAST - Explicitly cast an error-valued pointer to another pointer type\n * @ptr: The pointer to cast.\n *\n * Explicitly cast an error-valued pointer to another pointer type in such a\n * way as to make it clear that's what's going on.\n */\nstatic inline void * __must_check ERR_CAST(__force const void *ptr)\n{\n\t/* cast away the const */\n\treturn (void *) ptr;\n}\n\nstatic inline int __must_check PTR_ERR_OR_ZERO(__force const void *ptr)\n{\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\telse\n\t\treturn 0;\n}\n\n#endif\n\n#endif /* _LINUX_ERR_H */\n"}, "9": {"id": 9, "path": "/src/include/linux/jbd2.h", "content": "/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n * linux/include/linux/jbd2.h\n *\n * Written by Stephen C. Tweedie <sct@redhat.com>\n *\n * Copyright 1998-2000 Red Hat, Inc --- All Rights Reserved\n *\n * Definitions for transaction data structures for the buffer cache\n * filesystem journaling support.\n */\n\n#ifndef _LINUX_JBD2_H\n#define _LINUX_JBD2_H\n\n/* Allow this file to be included directly into e2fsprogs */\n#ifndef __KERNEL__\n#include \"jfs_compat.h\"\n#define JBD2_DEBUG\n#else\n\n#include <linux/types.h>\n#include <linux/buffer_head.h>\n#include <linux/journal-head.h>\n#include <linux/stddef.h>\n#include <linux/mutex.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/blkdev.h>\n#include <crypto/hash.h>\n#endif\n\n#define journal_oom_retry 1\n\n/*\n * Define JBD2_PARANIOD_IOFAIL to cause a kernel BUG() if ext4 finds\n * certain classes of error which can occur due to failed IOs.  Under\n * normal use we want ext4 to continue after such errors, because\n * hardware _can_ fail, but for debugging purposes when running tests on\n * known-good hardware we may want to trap these errors.\n */\n#undef JBD2_PARANOID_IOFAIL\n\n/*\n * The default maximum commit age, in seconds.\n */\n#define JBD2_DEFAULT_MAX_COMMIT_AGE 5\n\n#ifdef CONFIG_JBD2_DEBUG\n/*\n * Define JBD2_EXPENSIVE_CHECKING to enable more expensive internal\n * consistency checks.  By default we don't do this unless\n * CONFIG_JBD2_DEBUG is on.\n */\n#define JBD2_EXPENSIVE_CHECKING\nextern ushort jbd2_journal_enable_debug;\nvoid __jbd2_debug(int level, const char *file, const char *func,\n\t\t  unsigned int line, const char *fmt, ...);\n\n#define jbd_debug(n, fmt, a...) \\\n\t__jbd2_debug((n), __FILE__, __func__, __LINE__, (fmt), ##a)\n#else\n#define jbd_debug(n, fmt, a...)    /**/\n#endif\n\nextern void *jbd2_alloc(size_t size, gfp_t flags);\nextern void jbd2_free(void *ptr, size_t size);\n\n#define JBD2_MIN_JOURNAL_BLOCKS 1024\n\n#ifdef __KERNEL__\n\n/**\n * typedef handle_t - The handle_t type represents a single atomic update being performed by some process.\n *\n * All filesystem modifications made by the process go\n * through this handle.  Recursive operations (such as quota operations)\n * are gathered into a single update.\n *\n * The buffer credits field is used to account for journaled buffers\n * being modified by the running process.  To ensure that there is\n * enough log space for all outstanding operations, we need to limit the\n * number of outstanding buffers possible at any time.  When the\n * operation completes, any buffer credits not used are credited back to\n * the transaction, so that at all times we know how many buffers the\n * outstanding updates on a transaction might possibly touch.\n *\n * This is an opaque datatype.\n **/\ntypedef struct jbd2_journal_handle handle_t;\t/* Atomic operation type */\n\n\n/**\n * typedef journal_t - The journal_t maintains all of the journaling state information for a single filesystem.\n *\n * journal_t is linked to from the fs superblock structure.\n *\n * We use the journal_t to keep track of all outstanding transaction\n * activity on the filesystem, and to manage the state of the log\n * writing process.\n *\n * This is an opaque datatype.\n **/\ntypedef struct journal_s\tjournal_t;\t/* Journal control structure */\n#endif\n\n/*\n * Internal structures used by the logging mechanism:\n */\n\n#define JBD2_MAGIC_NUMBER 0xc03b3998U /* The first 4 bytes of /dev/random! */\n\n/*\n * On-disk structures\n */\n\n/*\n * Descriptor block types:\n */\n\n#define JBD2_DESCRIPTOR_BLOCK\t1\n#define JBD2_COMMIT_BLOCK\t2\n#define JBD2_SUPERBLOCK_V1\t3\n#define JBD2_SUPERBLOCK_V2\t4\n#define JBD2_REVOKE_BLOCK\t5\n\n/*\n * Standard header for all descriptor blocks:\n */\ntypedef struct journal_header_s\n{\n\t__be32\t\th_magic;\n\t__be32\t\th_blocktype;\n\t__be32\t\th_sequence;\n} journal_header_t;\n\n/*\n * Checksum types.\n */\n#define JBD2_CRC32_CHKSUM   1\n#define JBD2_MD5_CHKSUM     2\n#define JBD2_SHA1_CHKSUM    3\n#define JBD2_CRC32C_CHKSUM  4\n\n#define JBD2_CRC32_CHKSUM_SIZE 4\n\n#define JBD2_CHECKSUM_BYTES (32 / sizeof(u32))\n/*\n * Commit block header for storing transactional checksums:\n *\n * NOTE: If FEATURE_COMPAT_CHECKSUM (checksum v1) is set, the h_chksum*\n * fields are used to store a checksum of the descriptor and data blocks.\n *\n * If FEATURE_INCOMPAT_CSUM_V2 (checksum v2) is set, then the h_chksum\n * field is used to store crc32c(uuid+commit_block).  Each journal metadata\n * block gets its own checksum, and data block checksums are stored in\n * journal_block_tag (in the descriptor).  The other h_chksum* fields are\n * not used.\n *\n * If FEATURE_INCOMPAT_CSUM_V3 is set, the descriptor block uses\n * journal_block_tag3_t to store a full 32-bit checksum.  Everything else\n * is the same as v2.\n *\n * Checksum v1, v2, and v3 are mutually exclusive features.\n */\nstruct commit_header {\n\t__be32\t\th_magic;\n\t__be32          h_blocktype;\n\t__be32          h_sequence;\n\tunsigned char   h_chksum_type;\n\tunsigned char   h_chksum_size;\n\tunsigned char \th_padding[2];\n\t__be32 \t\th_chksum[JBD2_CHECKSUM_BYTES];\n\t__be64\t\th_commit_sec;\n\t__be32\t\th_commit_nsec;\n};\n\n/*\n * The block tag: used to describe a single buffer in the journal.\n * t_blocknr_high is only used if INCOMPAT_64BIT is set, so this\n * raw struct shouldn't be used for pointer math or sizeof() - use\n * journal_tag_bytes(journal) instead to compute this.\n */\ntypedef struct journal_block_tag3_s\n{\n\t__be32\t\tt_blocknr;\t/* The on-disk block number */\n\t__be32\t\tt_flags;\t/* See below */\n\t__be32\t\tt_blocknr_high; /* most-significant high 32bits. */\n\t__be32\t\tt_checksum;\t/* crc32c(uuid+seq+block) */\n} journal_block_tag3_t;\n\ntypedef struct journal_block_tag_s\n{\n\t__be32\t\tt_blocknr;\t/* The on-disk block number */\n\t__be16\t\tt_checksum;\t/* truncated crc32c(uuid+seq+block) */\n\t__be16\t\tt_flags;\t/* See below */\n\t__be32\t\tt_blocknr_high; /* most-significant high 32bits. */\n} journal_block_tag_t;\n\n/* Tail of descriptor or revoke block, for checksumming */\nstruct jbd2_journal_block_tail {\n\t__be32\t\tt_checksum;\t/* crc32c(uuid+descr_block) */\n};\n\n/*\n * The revoke descriptor: used on disk to describe a series of blocks to\n * be revoked from the log\n */\ntypedef struct jbd2_journal_revoke_header_s\n{\n\tjournal_header_t r_header;\n\t__be32\t\t r_count;\t/* Count of bytes used in the block */\n} jbd2_journal_revoke_header_t;\n\n/* Definitions for the journal tag flags word: */\n#define JBD2_FLAG_ESCAPE\t\t1\t/* on-disk block is escaped */\n#define JBD2_FLAG_SAME_UUID\t2\t/* block has same uuid as previous */\n#define JBD2_FLAG_DELETED\t4\t/* block deleted by this transaction */\n#define JBD2_FLAG_LAST_TAG\t8\t/* last tag in this descriptor block */\n\n\n/*\n * The journal superblock.  All fields are in big-endian byte order.\n */\ntypedef struct journal_superblock_s\n{\n/* 0x0000 */\n\tjournal_header_t s_header;\n\n/* 0x000C */\n\t/* Static information describing the journal */\n\t__be32\ts_blocksize;\t\t/* journal device blocksize */\n\t__be32\ts_maxlen;\t\t/* total blocks in journal file */\n\t__be32\ts_first;\t\t/* first block of log information */\n\n/* 0x0018 */\n\t/* Dynamic information describing the current state of the log */\n\t__be32\ts_sequence;\t\t/* first commit ID expected in log */\n\t__be32\ts_start;\t\t/* blocknr of start of log */\n\n/* 0x0020 */\n\t/* Error value, as set by jbd2_journal_abort(). */\n\t__be32\ts_errno;\n\n/* 0x0024 */\n\t/* Remaining fields are only valid in a version-2 superblock */\n\t__be32\ts_feature_compat;\t/* compatible feature set */\n\t__be32\ts_feature_incompat;\t/* incompatible feature set */\n\t__be32\ts_feature_ro_compat;\t/* readonly-compatible feature set */\n/* 0x0030 */\n\t__u8\ts_uuid[16];\t\t/* 128-bit uuid for journal */\n\n/* 0x0040 */\n\t__be32\ts_nr_users;\t\t/* Nr of filesystems sharing log */\n\n\t__be32\ts_dynsuper;\t\t/* Blocknr of dynamic superblock copy*/\n\n/* 0x0048 */\n\t__be32\ts_max_transaction;\t/* Limit of journal blocks per trans.*/\n\t__be32\ts_max_trans_data;\t/* Limit of data blocks per trans. */\n\n/* 0x0050 */\n\t__u8\ts_checksum_type;\t/* checksum type */\n\t__u8\ts_padding2[3];\n\t__u32\ts_padding[42];\n\t__be32\ts_checksum;\t\t/* crc32c(superblock) */\n\n/* 0x0100 */\n\t__u8\ts_users[16*48];\t\t/* ids of all fs'es sharing the log */\n/* 0x0400 */\n} journal_superblock_t;\n\n/* Use the jbd2_{has,set,clear}_feature_* helpers; these will be removed */\n#define JBD2_HAS_COMPAT_FEATURE(j,mask)\t\t\t\t\t\\\n\t((j)->j_format_version >= 2 &&\t\t\t\t\t\\\n\t ((j)->j_superblock->s_feature_compat & cpu_to_be32((mask))))\n#define JBD2_HAS_RO_COMPAT_FEATURE(j,mask)\t\t\t\t\\\n\t((j)->j_format_version >= 2 &&\t\t\t\t\t\\\n\t ((j)->j_superblock->s_feature_ro_compat & cpu_to_be32((mask))))\n#define JBD2_HAS_INCOMPAT_FEATURE(j,mask)\t\t\t\t\\\n\t((j)->j_format_version >= 2 &&\t\t\t\t\t\\\n\t ((j)->j_superblock->s_feature_incompat & cpu_to_be32((mask))))\n\n#define JBD2_FEATURE_COMPAT_CHECKSUM\t\t0x00000001\n\n#define JBD2_FEATURE_INCOMPAT_REVOKE\t\t0x00000001\n#define JBD2_FEATURE_INCOMPAT_64BIT\t\t0x00000002\n#define JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT\t0x00000004\n#define JBD2_FEATURE_INCOMPAT_CSUM_V2\t\t0x00000008\n#define JBD2_FEATURE_INCOMPAT_CSUM_V3\t\t0x00000010\n#define JBD2_FEATURE_INCOMPAT_FAST_COMMIT\t0x00000020\n\n/* See \"journal feature predicate functions\" below */\n\n/* Features known to this kernel version: */\n#define JBD2_KNOWN_COMPAT_FEATURES\tJBD2_FEATURE_COMPAT_CHECKSUM\n#define JBD2_KNOWN_ROCOMPAT_FEATURES\t0\n#define JBD2_KNOWN_INCOMPAT_FEATURES\t(JBD2_FEATURE_INCOMPAT_REVOKE | \\\n\t\t\t\t\tJBD2_FEATURE_INCOMPAT_64BIT | \\\n\t\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT | \\\n\t\t\t\t\tJBD2_FEATURE_INCOMPAT_CSUM_V2 | \\\n\t\t\t\t\tJBD2_FEATURE_INCOMPAT_CSUM_V3 | \\\n\t\t\t\t\tJBD2_FEATURE_INCOMPAT_FAST_COMMIT)\n\n#ifdef __KERNEL__\n\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nenum jbd_state_bits {\n\tBH_JBD\t\t\t/* Has an attached ext3 journal_head */\n\t  = BH_PrivateStart,\n\tBH_JWrite,\t\t/* Being written to log (@@@ DEBUGGING) */\n\tBH_Freed,\t\t/* Has been freed (truncated) */\n\tBH_Revoked,\t\t/* Has been revoked from the log */\n\tBH_RevokeValid,\t\t/* Revoked flag is valid */\n\tBH_JBDDirty,\t\t/* Is dirty but journaled */\n\tBH_JournalHead,\t\t/* Pins bh->b_private and jh->b_bh */\n\tBH_Shadow,\t\t/* IO on shadow buffer is running */\n\tBH_Verified,\t\t/* Metadata block has been verified ok */\n\tBH_JBDPrivateStart,\t/* First bit available for private use by FS */\n};\n\nBUFFER_FNS(JBD, jbd)\nBUFFER_FNS(JWrite, jwrite)\nBUFFER_FNS(JBDDirty, jbddirty)\nTAS_BUFFER_FNS(JBDDirty, jbddirty)\nBUFFER_FNS(Revoked, revoked)\nTAS_BUFFER_FNS(Revoked, revoked)\nBUFFER_FNS(RevokeValid, revokevalid)\nTAS_BUFFER_FNS(RevokeValid, revokevalid)\nBUFFER_FNS(Freed, freed)\nBUFFER_FNS(Shadow, shadow)\nBUFFER_FNS(Verified, verified)\n\nstatic inline struct buffer_head *jh2bh(struct journal_head *jh)\n{\n\treturn jh->b_bh;\n}\n\nstatic inline struct journal_head *bh2jh(struct buffer_head *bh)\n{\n\treturn bh->b_private;\n}\n\nstatic inline void jbd_lock_bh_journal_head(struct buffer_head *bh)\n{\n\tbit_spin_lock(BH_JournalHead, &bh->b_state);\n}\n\nstatic inline void jbd_unlock_bh_journal_head(struct buffer_head *bh)\n{\n\tbit_spin_unlock(BH_JournalHead, &bh->b_state);\n}\n\n#define J_ASSERT(assert)\tBUG_ON(!(assert))\n\n#define J_ASSERT_BH(bh, expr)\tJ_ASSERT(expr)\n#define J_ASSERT_JH(jh, expr)\tJ_ASSERT(expr)\n\n#if defined(JBD2_PARANOID_IOFAIL)\n#define J_EXPECT(expr, why...)\t\tJ_ASSERT(expr)\n#define J_EXPECT_BH(bh, expr, why...)\tJ_ASSERT_BH(bh, expr)\n#define J_EXPECT_JH(jh, expr, why...)\tJ_ASSERT_JH(jh, expr)\n#else\n#define __journal_expect(expr, why...)\t\t\t\t\t     \\\n\t({\t\t\t\t\t\t\t\t     \\\n\t\tint val = (expr);\t\t\t\t\t     \\\n\t\tif (!val) {\t\t\t\t\t\t     \\\n\t\t\tprintk(KERN_ERR\t\t\t\t\t     \\\n\t\t\t       \"JBD2 unexpected failure: %s: %s;\\n\",\t     \\\n\t\t\t       __func__, #expr);\t\t\t     \\\n\t\t\tprintk(KERN_ERR why \"\\n\");\t\t\t     \\\n\t\t}\t\t\t\t\t\t\t     \\\n\t\tval;\t\t\t\t\t\t\t     \\\n\t})\n#define J_EXPECT(expr, why...)\t\t__journal_expect(expr, ## why)\n#define J_EXPECT_BH(bh, expr, why...)\t__journal_expect(expr, ## why)\n#define J_EXPECT_JH(jh, expr, why...)\t__journal_expect(expr, ## why)\n#endif\n\n/* Flags in jbd_inode->i_flags */\n#define __JI_COMMIT_RUNNING 0\n#define __JI_WRITE_DATA 1\n#define __JI_WAIT_DATA 2\n\n/*\n * Commit of the inode data in progress. We use this flag to protect us from\n * concurrent deletion of inode. We cannot use reference to inode for this\n * since we cannot afford doing last iput() on behalf of kjournald\n */\n#define JI_COMMIT_RUNNING (1 << __JI_COMMIT_RUNNING)\n/* Write allocated dirty buffers in this inode before commit */\n#define JI_WRITE_DATA (1 << __JI_WRITE_DATA)\n/* Wait for outstanding data writes for this inode before commit */\n#define JI_WAIT_DATA (1 << __JI_WAIT_DATA)\n\n/**\n * struct jbd_inode - The jbd_inode type is the structure linking inodes in\n * ordered mode present in a transaction so that we can sync them during commit.\n */\nstruct jbd2_inode {\n\t/**\n\t * @i_transaction:\n\t *\n\t * Which transaction does this inode belong to? Either the running\n\t * transaction or the committing one. [j_list_lock]\n\t */\n\ttransaction_t *i_transaction;\n\n\t/**\n\t * @i_next_transaction:\n\t *\n\t * Pointer to the running transaction modifying inode's data in case\n\t * there is already a committing transaction touching it. [j_list_lock]\n\t */\n\ttransaction_t *i_next_transaction;\n\n\t/**\n\t * @i_list: List of inodes in the i_transaction [j_list_lock]\n\t */\n\tstruct list_head i_list;\n\n\t/**\n\t * @i_vfs_inode:\n\t *\n\t * VFS inode this inode belongs to [constant for lifetime of structure]\n\t */\n\tstruct inode *i_vfs_inode;\n\n\t/**\n\t * @i_flags: Flags of inode [j_list_lock]\n\t */\n\tunsigned long i_flags;\n\n\t/**\n\t * @i_dirty_start:\n\t *\n\t * Offset in bytes where the dirty range for this inode starts.\n\t * [j_list_lock]\n\t */\n\tloff_t i_dirty_start;\n\n\t/**\n\t * @i_dirty_end:\n\t *\n\t * Inclusive offset in bytes where the dirty range for this inode\n\t * ends. [j_list_lock]\n\t */\n\tloff_t i_dirty_end;\n};\n\nstruct jbd2_revoke_table_s;\n\n/**\n * struct jbd2_journal_handle - The jbd2_journal_handle type is the concrete\n *     type associated with handle_t.\n * @h_transaction: Which compound transaction is this update a part of?\n * @h_journal: Which journal handle belongs to - used iff h_reserved set.\n * @h_rsv_handle: Handle reserved for finishing the logical operation.\n * @h_total_credits: Number of remaining buffers we are allowed to add to\n *\tjournal. These are dirty buffers and revoke descriptor blocks.\n * @h_revoke_credits: Number of remaining revoke records available for handle\n * @h_ref: Reference count on this handle.\n * @h_err: Field for caller's use to track errors through large fs operations.\n * @h_sync: Flag for sync-on-close.\n * @h_jdata: Flag to force data journaling.\n * @h_reserved: Flag for handle for reserved credits.\n * @h_aborted: Flag indicating fatal error on handle.\n * @h_type: For handle statistics.\n * @h_line_no: For handle statistics.\n * @h_start_jiffies: Handle Start time.\n * @h_requested_credits: Holds @h_total_credits after handle is started.\n * @h_revoke_credits_requested: Holds @h_revoke_credits after handle is started.\n * @saved_alloc_context: Saved context while transaction is open.\n **/\n\n/* Docbook can't yet cope with the bit fields, but will leave the documentation\n * in so it can be fixed later.\n */\n\nstruct jbd2_journal_handle\n{\n\tunion {\n\t\ttransaction_t\t*h_transaction;\n\t\t/* Which journal handle belongs to - used iff h_reserved set */\n\t\tjournal_t\t*h_journal;\n\t};\n\n\thandle_t\t\t*h_rsv_handle;\n\tint\t\t\th_total_credits;\n\tint\t\t\th_revoke_credits;\n\tint\t\t\th_revoke_credits_requested;\n\tint\t\t\th_ref;\n\tint\t\t\th_err;\n\n\t/* Flags [no locking] */\n\tunsigned int\th_sync:\t\t1;\n\tunsigned int\th_jdata:\t1;\n\tunsigned int\th_reserved:\t1;\n\tunsigned int\th_aborted:\t1;\n\tunsigned int\th_type:\t\t8;\n\tunsigned int\th_line_no:\t16;\n\n\tunsigned long\t\th_start_jiffies;\n\tunsigned int\t\th_requested_credits;\n\n\tunsigned int\t\tsaved_alloc_context;\n};\n\n\n/*\n * Some stats for checkpoint phase\n */\nstruct transaction_chp_stats_s {\n\tunsigned long\t\tcs_chp_time;\n\t__u32\t\t\tcs_forced_to_close;\n\t__u32\t\t\tcs_written;\n\t__u32\t\t\tcs_dropped;\n};\n\n/* The transaction_t type is the guts of the journaling mechanism.  It\n * tracks a compound transaction through its various states:\n *\n * RUNNING:\taccepting new updates\n * LOCKED:\tUpdates still running but we don't accept new ones\n * RUNDOWN:\tUpdates are tidying up but have finished requesting\n *\t\tnew buffers to modify (state not used for now)\n * FLUSH:       All updates complete, but we are still writing to disk\n * COMMIT:      All data on disk, writing commit record\n * FINISHED:\tWe still have to keep the transaction for checkpointing.\n *\n * The transaction keeps track of all of the buffers modified by a\n * running transaction, and all of the buffers committed but not yet\n * flushed to home for finished transactions.\n */\n\n/*\n * Lock ranking:\n *\n *    j_list_lock\n *      ->jbd_lock_bh_journal_head()\t(This is \"innermost\")\n *\n *    j_state_lock\n *    ->b_state_lock\n *\n *    b_state_lock\n *    ->j_list_lock\n *\n *    j_state_lock\n *    ->t_handle_lock\n *\n *    j_state_lock\n *    ->j_list_lock\t\t\t(journal_unmap_buffer)\n *\n */\n\nstruct transaction_s\n{\n\t/* Pointer to the journal for this transaction. [no locking] */\n\tjournal_t\t\t*t_journal;\n\n\t/* Sequence number for this transaction [no locking] */\n\ttid_t\t\t\tt_tid;\n\n\t/*\n\t * Transaction's current state\n\t * [no locking - only kjournald2 alters this]\n\t * [j_list_lock] guards transition of a transaction into T_FINISHED\n\t * state and subsequent call of __jbd2_journal_drop_transaction()\n\t * FIXME: needs barriers\n\t * KLUDGE: [use j_state_lock]\n\t */\n\tenum {\n\t\tT_RUNNING,\n\t\tT_LOCKED,\n\t\tT_SWITCH,\n\t\tT_FLUSH,\n\t\tT_COMMIT,\n\t\tT_COMMIT_DFLUSH,\n\t\tT_COMMIT_JFLUSH,\n\t\tT_COMMIT_CALLBACK,\n\t\tT_FINISHED\n\t}\t\t\tt_state;\n\n\t/*\n\t * Where in the log does this transaction's commit start? [no locking]\n\t */\n\tunsigned long\t\tt_log_start;\n\n\t/* Number of buffers on the t_buffers list [j_list_lock] */\n\tint\t\t\tt_nr_buffers;\n\n\t/*\n\t * Doubly-linked circular list of all buffers reserved but not yet\n\t * modified by this transaction [j_list_lock]\n\t */\n\tstruct journal_head\t*t_reserved_list;\n\n\t/*\n\t * Doubly-linked circular list of all metadata buffers owned by this\n\t * transaction [j_list_lock]\n\t */\n\tstruct journal_head\t*t_buffers;\n\n\t/*\n\t * Doubly-linked circular list of all forget buffers (superseded\n\t * buffers which we can un-checkpoint once this transaction commits)\n\t * [j_list_lock]\n\t */\n\tstruct journal_head\t*t_forget;\n\n\t/*\n\t * Doubly-linked circular list of all buffers still to be flushed before\n\t * this transaction can be checkpointed. [j_list_lock]\n\t */\n\tstruct journal_head\t*t_checkpoint_list;\n\n\t/*\n\t * Doubly-linked circular list of all buffers submitted for IO while\n\t * checkpointing. [j_list_lock]\n\t */\n\tstruct journal_head\t*t_checkpoint_io_list;\n\n\t/*\n\t * Doubly-linked circular list of metadata buffers being shadowed by log\n\t * IO.  The IO buffers on the iobuf list and the shadow buffers on this\n\t * list match each other one for one at all times. [j_list_lock]\n\t */\n\tstruct journal_head\t*t_shadow_list;\n\n\t/*\n\t * List of inodes associated with the transaction; e.g., ext4 uses\n\t * this to track inodes in data=ordered and data=journal mode that\n\t * need special handling on transaction commit; also used by ocfs2.\n\t * [j_list_lock]\n\t */\n\tstruct list_head\tt_inode_list;\n\n\t/*\n\t * Protects info related to handles\n\t */\n\tspinlock_t\t\tt_handle_lock;\n\n\t/*\n\t * Longest time some handle had to wait for running transaction\n\t */\n\tunsigned long\t\tt_max_wait;\n\n\t/*\n\t * When transaction started\n\t */\n\tunsigned long\t\tt_start;\n\n\t/*\n\t * When commit was requested\n\t */\n\tunsigned long\t\tt_requested;\n\n\t/*\n\t * Checkpointing stats [j_checkpoint_sem]\n\t */\n\tstruct transaction_chp_stats_s t_chp_stats;\n\n\t/*\n\t * Number of outstanding updates running on this transaction\n\t * [none]\n\t */\n\tatomic_t\t\tt_updates;\n\n\t/*\n\t * Number of blocks reserved for this transaction in the journal.\n\t * This is including all credits reserved when starting transaction\n\t * handles as well as all journal descriptor blocks needed for this\n\t * transaction. [none]\n\t */\n\tatomic_t\t\tt_outstanding_credits;\n\n\t/*\n\t * Number of revoke records for this transaction added by already\n\t * stopped handles. [none]\n\t */\n\tatomic_t\t\tt_outstanding_revokes;\n\n\t/*\n\t * How many handles used this transaction? [none]\n\t */\n\tatomic_t\t\tt_handle_count;\n\n\t/*\n\t * Forward and backward links for the circular list of all transactions\n\t * awaiting checkpoint. [j_list_lock]\n\t */\n\ttransaction_t\t\t*t_cpnext, *t_cpprev;\n\n\t/*\n\t * When will the transaction expire (become due for commit), in jiffies?\n\t * [no locking]\n\t */\n\tunsigned long\t\tt_expires;\n\n\t/*\n\t * When this transaction started, in nanoseconds [no locking]\n\t */\n\tktime_t\t\t\tt_start_time;\n\n\t/*\n\t * This transaction is being forced and some process is\n\t * waiting for it to finish.\n\t */\n\tunsigned int t_synchronous_commit:1;\n\n\t/* Disk flush needs to be sent to fs partition [no locking] */\n\tint\t\t\tt_need_data_flush;\n\n\t/*\n\t * For use by the filesystem to store fs-specific data\n\t * structures associated with the transaction\n\t */\n\tstruct list_head\tt_private_list;\n};\n\nstruct transaction_run_stats_s {\n\tunsigned long\t\trs_wait;\n\tunsigned long\t\trs_request_delay;\n\tunsigned long\t\trs_running;\n\tunsigned long\t\trs_locked;\n\tunsigned long\t\trs_flushing;\n\tunsigned long\t\trs_logging;\n\n\t__u32\t\t\trs_handle_count;\n\t__u32\t\t\trs_blocks;\n\t__u32\t\t\trs_blocks_logged;\n};\n\nstruct transaction_stats_s {\n\tunsigned long\t\tts_tid;\n\tunsigned long\t\tts_requested;\n\tstruct transaction_run_stats_s run;\n};\n\nstatic inline unsigned long\njbd2_time_diff(unsigned long start, unsigned long end)\n{\n\tif (end >= start)\n\t\treturn end - start;\n\n\treturn end + (MAX_JIFFY_OFFSET - start);\n}\n\n#define JBD2_NR_BATCH\t64\n\nenum passtype {PASS_SCAN, PASS_REVOKE, PASS_REPLAY};\n\n#define JBD2_FC_REPLAY_STOP\t0\n#define JBD2_FC_REPLAY_CONTINUE\t1\n\n/**\n * struct journal_s - The journal_s type is the concrete type associated with\n *     journal_t.\n */\nstruct journal_s\n{\n\t/**\n\t * @j_flags: General journaling state flags [j_state_lock]\n\t */\n\tunsigned long\t\tj_flags;\n\n\t/**\n\t * @j_errno:\n\t *\n\t * Is there an outstanding uncleared error on the journal (from a prior\n\t * abort)? [j_state_lock]\n\t */\n\tint\t\t\tj_errno;\n\n\t/**\n\t * @j_abort_mutex: Lock the whole aborting procedure.\n\t */\n\tstruct mutex\t\tj_abort_mutex;\n\n\t/**\n\t * @j_sb_buffer: The first part of the superblock buffer.\n\t */\n\tstruct buffer_head\t*j_sb_buffer;\n\n\t/**\n\t * @j_superblock: The second part of the superblock buffer.\n\t */\n\tjournal_superblock_t\t*j_superblock;\n\n\t/**\n\t * @j_format_version: Version of the superblock format.\n\t */\n\tint\t\t\tj_format_version;\n\n\t/**\n\t * @j_state_lock: Protect the various scalars in the journal.\n\t */\n\trwlock_t\t\tj_state_lock;\n\n\t/**\n\t * @j_barrier_count:\n\t *\n\t * Number of processes waiting to create a barrier lock [j_state_lock]\n\t */\n\tint\t\t\tj_barrier_count;\n\n\t/**\n\t * @j_barrier: The barrier lock itself.\n\t */\n\tstruct mutex\t\tj_barrier;\n\n\t/**\n\t * @j_running_transaction:\n\t *\n\t * Transactions: The current running transaction...\n\t * [j_state_lock] [caller holding open handle]\n\t */\n\ttransaction_t\t\t*j_running_transaction;\n\n\t/**\n\t * @j_committing_transaction:\n\t *\n\t * the transaction we are pushing to disk\n\t * [j_state_lock] [caller holding open handle]\n\t */\n\ttransaction_t\t\t*j_committing_transaction;\n\n\t/**\n\t * @j_checkpoint_transactions:\n\t *\n\t * ... and a linked circular list of all transactions waiting for\n\t * checkpointing. [j_list_lock]\n\t */\n\ttransaction_t\t\t*j_checkpoint_transactions;\n\n\t/**\n\t * @j_wait_transaction_locked:\n\t *\n\t * Wait queue for waiting for a locked transaction to start committing,\n\t * or for a barrier lock to be released.\n\t */\n\twait_queue_head_t\tj_wait_transaction_locked;\n\n\t/**\n\t * @j_wait_done_commit: Wait queue for waiting for commit to complete.\n\t */\n\twait_queue_head_t\tj_wait_done_commit;\n\n\t/**\n\t * @j_wait_commit: Wait queue to trigger commit.\n\t */\n\twait_queue_head_t\tj_wait_commit;\n\n\t/**\n\t * @j_wait_updates: Wait queue to wait for updates to complete.\n\t */\n\twait_queue_head_t\tj_wait_updates;\n\n\t/**\n\t * @j_wait_reserved:\n\t *\n\t * Wait queue to wait for reserved buffer credits to drop.\n\t */\n\twait_queue_head_t\tj_wait_reserved;\n\n\t/**\n\t * @j_fc_wait:\n\t *\n\t * Wait queue to wait for completion of async fast commits.\n\t */\n\twait_queue_head_t\tj_fc_wait;\n\n\t/**\n\t * @j_checkpoint_mutex:\n\t *\n\t * Semaphore for locking against concurrent checkpoints.\n\t */\n\tstruct mutex\t\tj_checkpoint_mutex;\n\n\t/**\n\t * @j_chkpt_bhs:\n\t *\n\t * List of buffer heads used by the checkpoint routine.  This\n\t * was moved from jbd2_log_do_checkpoint() to reduce stack\n\t * usage.  Access to this array is controlled by the\n\t * @j_checkpoint_mutex.  [j_checkpoint_mutex]\n\t */\n\tstruct buffer_head\t*j_chkpt_bhs[JBD2_NR_BATCH];\n\n\t/**\n\t * @j_head:\n\t *\n\t * Journal head: identifies the first unused block in the journal.\n\t * [j_state_lock]\n\t */\n\tunsigned long\t\tj_head;\n\n\t/**\n\t * @j_tail:\n\t *\n\t * Journal tail: identifies the oldest still-used block in the journal.\n\t * [j_state_lock]\n\t */\n\tunsigned long\t\tj_tail;\n\n\t/**\n\t * @j_free:\n\t *\n\t * Journal free: how many free blocks are there in the journal?\n\t * [j_state_lock]\n\t */\n\tunsigned long\t\tj_free;\n\n\t/**\n\t * @j_first:\n\t *\n\t * The block number of the first usable block in the journal\n\t * [j_state_lock].\n\t */\n\tunsigned long\t\tj_first;\n\n\t/**\n\t * @j_last:\n\t *\n\t * The block number one beyond the last usable block in the journal\n\t * [j_state_lock].\n\t */\n\tunsigned long\t\tj_last;\n\n\t/**\n\t * @j_fc_first:\n\t *\n\t * The block number of the first fast commit block in the journal\n\t * [j_state_lock].\n\t */\n\tunsigned long\t\tj_fc_first;\n\n\t/**\n\t * @j_fc_off:\n\t *\n\t * Number of fast commit blocks currently allocated.\n\t * [j_state_lock].\n\t */\n\tunsigned long\t\tj_fc_off;\n\n\t/**\n\t * @j_fc_last:\n\t *\n\t * The block number one beyond the last fast commit block in the journal\n\t * [j_state_lock].\n\t */\n\tunsigned long\t\tj_fc_last;\n\n\t/**\n\t * @j_dev: Device where we store the journal.\n\t */\n\tstruct block_device\t*j_dev;\n\n\t/**\n\t * @j_blocksize: Block size for the location where we store the journal.\n\t */\n\tint\t\t\tj_blocksize;\n\n\t/**\n\t * @j_blk_offset:\n\t *\n\t * Starting block offset into the device where we store the journal.\n\t */\n\tunsigned long long\tj_blk_offset;\n\n\t/**\n\t * @j_devname: Journal device name.\n\t */\n\tchar\t\t\tj_devname[BDEVNAME_SIZE+24];\n\n\t/**\n\t * @j_fs_dev:\n\t *\n\t * Device which holds the client fs.  For internal journal this will be\n\t * equal to j_dev.\n\t */\n\tstruct block_device\t*j_fs_dev;\n\n\t/**\n\t * @j_maxlen: Total maximum capacity of the journal region on disk.\n\t */\n\tunsigned int\t\tj_maxlen;\n\n\t/**\n\t * @j_reserved_credits:\n\t *\n\t * Number of buffers reserved from the running transaction.\n\t */\n\tatomic_t\t\tj_reserved_credits;\n\n\t/**\n\t * @j_list_lock: Protects the buffer lists and internal buffer state.\n\t */\n\tspinlock_t\t\tj_list_lock;\n\n\t/**\n\t * @j_inode:\n\t *\n\t * Optional inode where we store the journal.  If present, all\n\t * journal block numbers are mapped into this inode via bmap().\n\t */\n\tstruct inode\t\t*j_inode;\n\n\t/**\n\t * @j_tail_sequence:\n\t *\n\t * Sequence number of the oldest transaction in the log [j_state_lock]\n\t */\n\ttid_t\t\t\tj_tail_sequence;\n\n\t/**\n\t * @j_transaction_sequence:\n\t *\n\t * Sequence number of the next transaction to grant [j_state_lock]\n\t */\n\ttid_t\t\t\tj_transaction_sequence;\n\n\t/**\n\t * @j_commit_sequence:\n\t *\n\t * Sequence number of the most recently committed transaction\n\t * [j_state_lock].\n\t */\n\ttid_t\t\t\tj_commit_sequence;\n\n\t/**\n\t * @j_commit_request:\n\t *\n\t * Sequence number of the most recent transaction wanting commit\n\t * [j_state_lock]\n\t */\n\ttid_t\t\t\tj_commit_request;\n\n\t/**\n\t * @j_uuid:\n\t *\n\t * Journal uuid: identifies the object (filesystem, LVM volume etc)\n\t * backed by this journal.  This will eventually be replaced by an array\n\t * of uuids, allowing us to index multiple devices within a single\n\t * journal and to perform atomic updates across them.\n\t */\n\t__u8\t\t\tj_uuid[16];\n\n\t/**\n\t * @j_task: Pointer to the current commit thread for this journal.\n\t */\n\tstruct task_struct\t*j_task;\n\n\t/**\n\t * @j_max_transaction_buffers:\n\t *\n\t * Maximum number of metadata buffers to allow in a single compound\n\t * commit transaction.\n\t */\n\tint\t\t\tj_max_transaction_buffers;\n\n\t/**\n\t * @j_revoke_records_per_block:\n\t *\n\t * Number of revoke records that fit in one descriptor block.\n\t */\n\tint\t\t\tj_revoke_records_per_block;\n\n\t/**\n\t * @j_commit_interval:\n\t *\n\t * What is the maximum transaction lifetime before we begin a commit?\n\t */\n\tunsigned long\t\tj_commit_interval;\n\n\t/**\n\t * @j_commit_timer: The timer used to wakeup the commit thread.\n\t */\n\tstruct timer_list\tj_commit_timer;\n\n\t/**\n\t * @j_revoke_lock: Protect the revoke table.\n\t */\n\tspinlock_t\t\tj_revoke_lock;\n\n\t/**\n\t * @j_revoke:\n\t *\n\t * The revoke table - maintains the list of revoked blocks in the\n\t * current transaction.\n\t */\n\tstruct jbd2_revoke_table_s *j_revoke;\n\n\t/**\n\t * @j_revoke_table: Alternate revoke tables for j_revoke.\n\t */\n\tstruct jbd2_revoke_table_s *j_revoke_table[2];\n\n\t/**\n\t * @j_wbuf: Array of bhs for jbd2_journal_commit_transaction.\n\t */\n\tstruct buffer_head\t**j_wbuf;\n\n\t/**\n\t * @j_fc_wbuf: Array of fast commit bhs for\n\t * jbd2_journal_commit_transaction.\n\t */\n\tstruct buffer_head\t**j_fc_wbuf;\n\n\t/**\n\t * @j_wbufsize:\n\t *\n\t * Size of @j_wbuf array.\n\t */\n\tint\t\t\tj_wbufsize;\n\n\t/**\n\t * @j_fc_wbufsize:\n\t *\n\t * Size of @j_fc_wbuf array.\n\t */\n\tint\t\t\tj_fc_wbufsize;\n\n\t/**\n\t * @j_last_sync_writer:\n\t *\n\t * The pid of the last person to run a synchronous operation\n\t * through the journal.\n\t */\n\tpid_t\t\t\tj_last_sync_writer;\n\n\t/**\n\t * @j_average_commit_time:\n\t *\n\t * The average amount of time in nanoseconds it takes to commit a\n\t * transaction to disk. [j_state_lock]\n\t */\n\tu64\t\t\tj_average_commit_time;\n\n\t/**\n\t * @j_min_batch_time:\n\t *\n\t * Minimum time that we should wait for additional filesystem operations\n\t * to get batched into a synchronous handle in microseconds.\n\t */\n\tu32\t\t\tj_min_batch_time;\n\n\t/**\n\t * @j_max_batch_time:\n\t *\n\t * Maximum time that we should wait for additional filesystem operations\n\t * to get batched into a synchronous handle in microseconds.\n\t */\n\tu32\t\t\tj_max_batch_time;\n\n\t/**\n\t * @j_commit_callback:\n\t *\n\t * This function is called when a transaction is closed.\n\t */\n\tvoid\t\t\t(*j_commit_callback)(journal_t *,\n\t\t\t\t\t\t     transaction_t *);\n\n\t/**\n\t * @j_submit_inode_data_buffers:\n\t *\n\t * This function is called for all inodes associated with the\n\t * committing transaction marked with JI_WRITE_DATA flag\n\t * before we start to write out the transaction to the journal.\n\t */\n\tint\t\t\t(*j_submit_inode_data_buffers)\n\t\t\t\t\t(struct jbd2_inode *);\n\n\t/**\n\t * @j_finish_inode_data_buffers:\n\t *\n\t * This function is called for all inodes associated with the\n\t * committing transaction marked with JI_WAIT_DATA flag\n\t * after we have written the transaction to the journal\n\t * but before we write out the commit block.\n\t */\n\tint\t\t\t(*j_finish_inode_data_buffers)\n\t\t\t\t\t(struct jbd2_inode *);\n\n\t/*\n\t * Journal statistics\n\t */\n\n\t/**\n\t * @j_history_lock: Protect the transactions statistics history.\n\t */\n\tspinlock_t\t\tj_history_lock;\n\n\t/**\n\t * @j_proc_entry: procfs entry for the jbd statistics directory.\n\t */\n\tstruct proc_dir_entry\t*j_proc_entry;\n\n\t/**\n\t * @j_stats: Overall statistics.\n\t */\n\tstruct transaction_stats_s j_stats;\n\n\t/**\n\t * @j_failed_commit: Failed journal commit ID.\n\t */\n\tunsigned int\t\tj_failed_commit;\n\n\t/**\n\t * @j_private:\n\t *\n\t * An opaque pointer to fs-private information.  ext3 puts its\n\t * superblock pointer here.\n\t */\n\tvoid *j_private;\n\n\t/**\n\t * @j_chksum_driver:\n\t *\n\t * Reference to checksum algorithm driver via cryptoapi.\n\t */\n\tstruct crypto_shash *j_chksum_driver;\n\n\t/**\n\t * @j_csum_seed:\n\t *\n\t * Precomputed journal UUID checksum for seeding other checksums.\n\t */\n\t__u32 j_csum_seed;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t/**\n\t * @j_trans_commit_map:\n\t *\n\t * Lockdep entity to track transaction commit dependencies. Handles\n\t * hold this \"lock\" for read, when we wait for commit, we acquire the\n\t * \"lock\" for writing. This matches the properties of jbd2 journalling\n\t * where the running transaction has to wait for all handles to be\n\t * dropped to commit that transaction and also acquiring a handle may\n\t * require transaction commit to finish.\n\t */\n\tstruct lockdep_map\tj_trans_commit_map;\n#endif\n\n\t/**\n\t * @j_fc_cleanup_callback:\n\t *\n\t * Clean-up after fast commit or full commit. JBD2 calls this function\n\t * after every commit operation.\n\t */\n\tvoid (*j_fc_cleanup_callback)(struct journal_s *journal, int);\n\n\t/*\n\t * @j_fc_replay_callback:\n\t *\n\t * File-system specific function that performs replay of a fast\n\t * commit. JBD2 calls this function for each fast commit block found in\n\t * the journal. This function should return JBD2_FC_REPLAY_CONTINUE\n\t * to indicate that the block was processed correctly and more fast\n\t * commit replay should continue. Return value of JBD2_FC_REPLAY_STOP\n\t * indicates the end of replay (no more blocks remaining). A negative\n\t * return value indicates error.\n\t */\n\tint (*j_fc_replay_callback)(struct journal_s *journal,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    enum passtype pass, int off,\n\t\t\t\t    tid_t expected_commit_id);\n};\n\n#define jbd2_might_wait_for_commit(j) \\\n\tdo { \\\n\t\trwsem_acquire(&j->j_trans_commit_map, 0, 0, _THIS_IP_); \\\n\t\trwsem_release(&j->j_trans_commit_map, _THIS_IP_); \\\n\t} while (0)\n\n/* journal feature predicate functions */\n#define JBD2_FEATURE_COMPAT_FUNCS(name, flagname) \\\nstatic inline bool jbd2_has_feature_##name(journal_t *j) \\\n{ \\\n\treturn ((j)->j_format_version >= 2 && \\\n\t\t((j)->j_superblock->s_feature_compat & \\\n\t\t cpu_to_be32(JBD2_FEATURE_COMPAT_##flagname)) != 0); \\\n} \\\nstatic inline void jbd2_set_feature_##name(journal_t *j) \\\n{ \\\n\t(j)->j_superblock->s_feature_compat |= \\\n\t\tcpu_to_be32(JBD2_FEATURE_COMPAT_##flagname); \\\n} \\\nstatic inline void jbd2_clear_feature_##name(journal_t *j) \\\n{ \\\n\t(j)->j_superblock->s_feature_compat &= \\\n\t\t~cpu_to_be32(JBD2_FEATURE_COMPAT_##flagname); \\\n}\n\n#define JBD2_FEATURE_RO_COMPAT_FUNCS(name, flagname) \\\nstatic inline bool jbd2_has_feature_##name(journal_t *j) \\\n{ \\\n\treturn ((j)->j_format_version >= 2 && \\\n\t\t((j)->j_superblock->s_feature_ro_compat & \\\n\t\t cpu_to_be32(JBD2_FEATURE_RO_COMPAT_##flagname)) != 0); \\\n} \\\nstatic inline void jbd2_set_feature_##name(journal_t *j) \\\n{ \\\n\t(j)->j_superblock->s_feature_ro_compat |= \\\n\t\tcpu_to_be32(JBD2_FEATURE_RO_COMPAT_##flagname); \\\n} \\\nstatic inline void jbd2_clear_feature_##name(journal_t *j) \\\n{ \\\n\t(j)->j_superblock->s_feature_ro_compat &= \\\n\t\t~cpu_to_be32(JBD2_FEATURE_RO_COMPAT_##flagname); \\\n}\n\n#define JBD2_FEATURE_INCOMPAT_FUNCS(name, flagname) \\\nstatic inline bool jbd2_has_feature_##name(journal_t *j) \\\n{ \\\n\treturn ((j)->j_format_version >= 2 && \\\n\t\t((j)->j_superblock->s_feature_incompat & \\\n\t\t cpu_to_be32(JBD2_FEATURE_INCOMPAT_##flagname)) != 0); \\\n} \\\nstatic inline void jbd2_set_feature_##name(journal_t *j) \\\n{ \\\n\t(j)->j_superblock->s_feature_incompat |= \\\n\t\tcpu_to_be32(JBD2_FEATURE_INCOMPAT_##flagname); \\\n} \\\nstatic inline void jbd2_clear_feature_##name(journal_t *j) \\\n{ \\\n\t(j)->j_superblock->s_feature_incompat &= \\\n\t\t~cpu_to_be32(JBD2_FEATURE_INCOMPAT_##flagname); \\\n}\n\nJBD2_FEATURE_COMPAT_FUNCS(checksum,\t\tCHECKSUM)\n\nJBD2_FEATURE_INCOMPAT_FUNCS(revoke,\t\tREVOKE)\nJBD2_FEATURE_INCOMPAT_FUNCS(64bit,\t\t64BIT)\nJBD2_FEATURE_INCOMPAT_FUNCS(async_commit,\tASYNC_COMMIT)\nJBD2_FEATURE_INCOMPAT_FUNCS(csum2,\t\tCSUM_V2)\nJBD2_FEATURE_INCOMPAT_FUNCS(csum3,\t\tCSUM_V3)\nJBD2_FEATURE_INCOMPAT_FUNCS(fast_commit,\tFAST_COMMIT)\n\n/*\n * Journal flag definitions\n */\n#define JBD2_UNMOUNT\t0x001\t/* Journal thread is being destroyed */\n#define JBD2_ABORT\t0x002\t/* Journaling has been aborted for errors. */\n#define JBD2_ACK_ERR\t0x004\t/* The errno in the sb has been acked */\n#define JBD2_FLUSHED\t0x008\t/* The journal superblock has been flushed */\n#define JBD2_LOADED\t0x010\t/* The journal superblock has been loaded */\n#define JBD2_BARRIER\t0x020\t/* Use IDE barriers */\n#define JBD2_ABORT_ON_SYNCDATA_ERR\t0x040\t/* Abort the journal on file\n\t\t\t\t\t\t * data write error in ordered\n\t\t\t\t\t\t * mode */\n#define JBD2_FAST_COMMIT_ONGOING\t0x100\t/* Fast commit is ongoing */\n#define JBD2_FULL_COMMIT_ONGOING\t0x200\t/* Full commit is ongoing */\n\n/*\n * Function declarations for the journaling transaction and buffer\n * management\n */\n\n/* Filing buffers */\nextern void jbd2_journal_unfile_buffer(journal_t *, struct journal_head *);\nextern bool __jbd2_journal_refile_buffer(struct journal_head *);\nextern void jbd2_journal_refile_buffer(journal_t *, struct journal_head *);\nextern void __jbd2_journal_file_buffer(struct journal_head *, transaction_t *, int);\nextern void __journal_free_buffer(struct journal_head *bh);\nextern void jbd2_journal_file_buffer(struct journal_head *, transaction_t *, int);\nextern void __journal_clean_data_list(transaction_t *transaction);\nstatic inline void jbd2_file_log_bh(struct list_head *head, struct buffer_head *bh)\n{\n\tlist_add_tail(&bh->b_assoc_buffers, head);\n}\nstatic inline void jbd2_unfile_log_bh(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n}\n\n/* Log buffer allocation */\nstruct buffer_head *jbd2_journal_get_descriptor_buffer(transaction_t *, int);\nvoid jbd2_descriptor_block_csum_set(journal_t *, struct buffer_head *);\nint jbd2_journal_next_log_block(journal_t *, unsigned long long *);\nint jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,\n\t\t\t      unsigned long *block);\nint __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);\nvoid jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);\n\n/* Commit management */\nextern void jbd2_journal_commit_transaction(journal_t *);\n\n/* Checkpoint list management */\nvoid __jbd2_journal_clean_checkpoint_list(journal_t *journal, bool destroy);\nint __jbd2_journal_remove_checkpoint(struct journal_head *);\nvoid jbd2_journal_destroy_checkpoint(journal_t *journal);\nvoid __jbd2_journal_insert_checkpoint(struct journal_head *, transaction_t *);\n\n\n/*\n * Triggers\n */\n\nstruct jbd2_buffer_trigger_type {\n\t/*\n\t * Fired a the moment data to write to the journal are known to be\n\t * stable - so either at the moment b_frozen_data is created or just\n\t * before a buffer is written to the journal.  mapped_data is a mapped\n\t * buffer that is the frozen data for commit.\n\t */\n\tvoid (*t_frozen)(struct jbd2_buffer_trigger_type *type,\n\t\t\t struct buffer_head *bh, void *mapped_data,\n\t\t\t size_t size);\n\n\t/*\n\t * Fired during journal abort for dirty buffers that will not be\n\t * committed.\n\t */\n\tvoid (*t_abort)(struct jbd2_buffer_trigger_type *type,\n\t\t\tstruct buffer_head *bh);\n};\n\nextern void jbd2_buffer_frozen_trigger(struct journal_head *jh,\n\t\t\t\t       void *mapped_data,\n\t\t\t\t       struct jbd2_buffer_trigger_type *triggers);\nextern void jbd2_buffer_abort_trigger(struct journal_head *jh,\n\t\t\t\t      struct jbd2_buffer_trigger_type *triggers);\n\n/* Buffer IO */\nextern int jbd2_journal_write_metadata_buffer(transaction_t *transaction,\n\t\t\t\t\t      struct journal_head *jh_in,\n\t\t\t\t\t      struct buffer_head **bh_out,\n\t\t\t\t\t      sector_t blocknr);\n\n/* Transaction locking */\nextern void\t\t__wait_on_journal (journal_t *);\n\n/* Transaction cache support */\nextern void jbd2_journal_destroy_transaction_cache(void);\nextern int __init jbd2_journal_init_transaction_cache(void);\nextern void jbd2_journal_free_transaction(transaction_t *);\n\n/*\n * Journal locking.\n *\n * We need to lock the journal during transaction state changes so that nobody\n * ever tries to take a handle on the running transaction while we are in the\n * middle of moving it to the commit phase.  j_state_lock does this.\n *\n * Note that the locking is completely interrupt unsafe.  We never touch\n * journal structures from interrupts.\n */\n\nstatic inline handle_t *journal_current_handle(void)\n{\n\treturn current->journal_info;\n}\n\n/* The journaling code user interface:\n *\n * Create and destroy handles\n * Register buffer modifications against the current transaction.\n */\n\nextern handle_t *jbd2_journal_start(journal_t *, int nblocks);\nextern handle_t *jbd2__journal_start(journal_t *, int blocks, int rsv_blocks,\n\t\t\t\t     int revoke_records, gfp_t gfp_mask,\n\t\t\t\t     unsigned int type, unsigned int line_no);\nextern int\t jbd2_journal_restart(handle_t *, int nblocks);\nextern int\t jbd2__journal_restart(handle_t *, int nblocks,\n\t\t\t\t       int revoke_records, gfp_t gfp_mask);\nextern int\t jbd2_journal_start_reserved(handle_t *handle,\n\t\t\t\tunsigned int type, unsigned int line_no);\nextern void\t jbd2_journal_free_reserved(handle_t *handle);\nextern int\t jbd2_journal_extend(handle_t *handle, int nblocks,\n\t\t\t\t     int revoke_records);\nextern int\t jbd2_journal_get_write_access(handle_t *, struct buffer_head *);\nextern int\t jbd2_journal_get_create_access (handle_t *, struct buffer_head *);\nextern int\t jbd2_journal_get_undo_access(handle_t *, struct buffer_head *);\nvoid\t\t jbd2_journal_set_triggers(struct buffer_head *,\n\t\t\t\t\t   struct jbd2_buffer_trigger_type *type);\nextern int\t jbd2_journal_dirty_metadata (handle_t *, struct buffer_head *);\nextern int\t jbd2_journal_forget (handle_t *, struct buffer_head *);\nextern int\t jbd2_journal_invalidatepage(journal_t *,\n\t\t\t\tstruct page *, unsigned int, unsigned int);\nextern int\t jbd2_journal_try_to_free_buffers(journal_t *journal, struct page *page);\nextern int\t jbd2_journal_stop(handle_t *);\nextern int\t jbd2_journal_flush (journal_t *);\nextern void\t jbd2_journal_lock_updates (journal_t *);\nextern void\t jbd2_journal_unlock_updates (journal_t *);\n\nextern journal_t * jbd2_journal_init_dev(struct block_device *bdev,\n\t\t\t\tstruct block_device *fs_dev,\n\t\t\t\tunsigned long long start, int len, int bsize);\nextern journal_t * jbd2_journal_init_inode (struct inode *);\nextern int\t   jbd2_journal_update_format (journal_t *);\nextern int\t   jbd2_journal_check_used_features\n\t\t   (journal_t *, unsigned long, unsigned long, unsigned long);\nextern int\t   jbd2_journal_check_available_features\n\t\t   (journal_t *, unsigned long, unsigned long, unsigned long);\nextern int\t   jbd2_journal_set_features\n\t\t   (journal_t *, unsigned long, unsigned long, unsigned long);\nextern void\t   jbd2_journal_clear_features\n\t\t   (journal_t *, unsigned long, unsigned long, unsigned long);\nextern int\t   jbd2_journal_load       (journal_t *journal);\nextern int\t   jbd2_journal_destroy    (journal_t *);\nextern int\t   jbd2_journal_recover    (journal_t *journal);\nextern int\t   jbd2_journal_wipe       (journal_t *, int);\nextern int\t   jbd2_journal_skip_recovery\t(journal_t *);\nextern void\t   jbd2_journal_update_sb_errno(journal_t *);\nextern int\t   jbd2_journal_update_sb_log_tail\t(journal_t *, tid_t,\n\t\t\t\tunsigned long, int);\nextern void\t   jbd2_journal_abort      (journal_t *, int);\nextern int\t   jbd2_journal_errno      (journal_t *);\nextern void\t   jbd2_journal_ack_err    (journal_t *);\nextern int\t   jbd2_journal_clear_err  (journal_t *);\nextern int\t   jbd2_journal_bmap(journal_t *, unsigned long, unsigned long long *);\nextern int\t   jbd2_journal_force_commit(journal_t *);\nextern int\t   jbd2_journal_force_commit_nested(journal_t *);\nextern int\t   jbd2_journal_inode_ranged_write(handle_t *handle,\n\t\t\tstruct jbd2_inode *inode, loff_t start_byte,\n\t\t\tloff_t length);\nextern int\t   jbd2_journal_inode_ranged_wait(handle_t *handle,\n\t\t\tstruct jbd2_inode *inode, loff_t start_byte,\n\t\t\tloff_t length);\nextern int\t   jbd2_journal_submit_inode_data_buffers(\n\t\t\tstruct jbd2_inode *jinode);\nextern int\t   jbd2_journal_finish_inode_data_buffers(\n\t\t\tstruct jbd2_inode *jinode);\nextern int\t   jbd2_journal_begin_ordered_truncate(journal_t *journal,\n\t\t\t\tstruct jbd2_inode *inode, loff_t new_size);\nextern void\t   jbd2_journal_init_jbd_inode(struct jbd2_inode *jinode, struct inode *inode);\nextern void\t   jbd2_journal_release_jbd_inode(journal_t *journal, struct jbd2_inode *jinode);\n\n/*\n * journal_head management\n */\nstruct journal_head *jbd2_journal_add_journal_head(struct buffer_head *bh);\nstruct journal_head *jbd2_journal_grab_journal_head(struct buffer_head *bh);\nvoid jbd2_journal_put_journal_head(struct journal_head *jh);\n\n/*\n * handle management\n */\nextern struct kmem_cache *jbd2_handle_cache;\n\nstatic inline handle_t *jbd2_alloc_handle(gfp_t gfp_flags)\n{\n\treturn kmem_cache_zalloc(jbd2_handle_cache, gfp_flags);\n}\n\nstatic inline void jbd2_free_handle(handle_t *handle)\n{\n\tkmem_cache_free(jbd2_handle_cache, handle);\n}\n\n/*\n * jbd2_inode management (optional, for those file systems that want to use\n * dynamically allocated jbd2_inode structures)\n */\nextern struct kmem_cache *jbd2_inode_cache;\n\nstatic inline struct jbd2_inode *jbd2_alloc_inode(gfp_t gfp_flags)\n{\n\treturn kmem_cache_alloc(jbd2_inode_cache, gfp_flags);\n}\n\nstatic inline void jbd2_free_inode(struct jbd2_inode *jinode)\n{\n\tkmem_cache_free(jbd2_inode_cache, jinode);\n}\n\n/* Primary revoke support */\n#define JOURNAL_REVOKE_DEFAULT_HASH 256\nextern int\t   jbd2_journal_init_revoke(journal_t *, int);\nextern void\t   jbd2_journal_destroy_revoke_record_cache(void);\nextern void\t   jbd2_journal_destroy_revoke_table_cache(void);\nextern int __init jbd2_journal_init_revoke_record_cache(void);\nextern int __init jbd2_journal_init_revoke_table_cache(void);\n\nextern void\t   jbd2_journal_destroy_revoke(journal_t *);\nextern int\t   jbd2_journal_revoke (handle_t *, unsigned long long, struct buffer_head *);\nextern int\t   jbd2_journal_cancel_revoke(handle_t *, struct journal_head *);\nextern void\t   jbd2_journal_write_revoke_records(transaction_t *transaction,\n\t\t\t\t\t\t     struct list_head *log_bufs);\n\n/* Recovery revoke support */\nextern int\tjbd2_journal_set_revoke(journal_t *, unsigned long long, tid_t);\nextern int\tjbd2_journal_test_revoke(journal_t *, unsigned long long, tid_t);\nextern void\tjbd2_journal_clear_revoke(journal_t *);\nextern void\tjbd2_journal_switch_revoke_table(journal_t *journal);\nextern void\tjbd2_clear_buffer_revoked_flags(journal_t *journal);\n\n/*\n * The log thread user interface:\n *\n * Request space in the current transaction, and force transaction commit\n * transitions on demand.\n */\n\nint jbd2_log_start_commit(journal_t *journal, tid_t tid);\nint __jbd2_log_start_commit(journal_t *journal, tid_t tid);\nint jbd2_journal_start_commit(journal_t *journal, tid_t *tid);\nint jbd2_log_wait_commit(journal_t *journal, tid_t tid);\nint jbd2_transaction_committed(journal_t *journal, tid_t tid);\nint jbd2_complete_transaction(journal_t *journal, tid_t tid);\nint jbd2_log_do_checkpoint(journal_t *journal);\nint jbd2_trans_will_send_data_barrier(journal_t *journal, tid_t tid);\n\nvoid __jbd2_log_wait_for_space(journal_t *journal);\nextern void __jbd2_journal_drop_transaction(journal_t *, transaction_t *);\nextern int jbd2_cleanup_journal_tail(journal_t *);\n\n/* Fast commit related APIs */\nint jbd2_fc_init(journal_t *journal, int num_fc_blks);\nint jbd2_fc_begin_commit(journal_t *journal, tid_t tid);\nint jbd2_fc_end_commit(journal_t *journal);\nint jbd2_fc_end_commit_fallback(journal_t *journal, tid_t tid);\nint jbd2_fc_get_buf(journal_t *journal, struct buffer_head **bh_out);\nint jbd2_submit_inode_data(struct jbd2_inode *jinode);\nint jbd2_wait_inode_data(journal_t *journal, struct jbd2_inode *jinode);\nint jbd2_fc_wait_bufs(journal_t *journal, int num_blks);\nint jbd2_fc_release_bufs(journal_t *journal);\n\n/*\n * is_journal_abort\n *\n * Simple test wrapper function to test the JBD2_ABORT state flag.  This\n * bit, when set, indicates that we have had a fatal error somewhere,\n * either inside the journaling layer or indicated to us by the client\n * (eg. ext3), and that we and should not commit any further\n * transactions.\n */\n\nstatic inline int is_journal_aborted(journal_t *journal)\n{\n\treturn journal->j_flags & JBD2_ABORT;\n}\n\nstatic inline int is_handle_aborted(handle_t *handle)\n{\n\tif (handle->h_aborted || !handle->h_transaction)\n\t\treturn 1;\n\treturn is_journal_aborted(handle->h_transaction->t_journal);\n}\n\nstatic inline void jbd2_journal_abort_handle(handle_t *handle)\n{\n\thandle->h_aborted = 1;\n}\n\n#endif /* __KERNEL__   */\n\n/* Comparison functions for transaction IDs: perform comparisons using\n * modulo arithmetic so that they work over sequence number wraps. */\n\nstatic inline int tid_gt(tid_t x, tid_t y)\n{\n\tint difference = (x - y);\n\treturn (difference > 0);\n}\n\nstatic inline int tid_geq(tid_t x, tid_t y)\n{\n\tint difference = (x - y);\n\treturn (difference >= 0);\n}\n\nextern int jbd2_journal_blocks_per_page(struct inode *inode);\nextern size_t journal_tag_bytes(journal_t *journal);\n\nstatic inline bool jbd2_journal_has_csum_v2or3_feature(journal_t *j)\n{\n\treturn jbd2_has_feature_csum2(j) || jbd2_has_feature_csum3(j);\n}\n\nstatic inline int jbd2_journal_has_csum_v2or3(journal_t *journal)\n{\n\tWARN_ON_ONCE(jbd2_journal_has_csum_v2or3_feature(journal) &&\n\t\t     journal->j_chksum_driver == NULL);\n\n\treturn journal->j_chksum_driver != NULL;\n}\n\n/*\n * Return number of free blocks in the log. Must be called under j_state_lock.\n */\nstatic inline unsigned long jbd2_log_space_left(journal_t *journal)\n{\n\t/* Allow for rounding errors */\n\tlong free = journal->j_free - 32;\n\n\tif (journal->j_committing_transaction) {\n\t\tfree -= atomic_read(&journal->\n                        j_committing_transaction->t_outstanding_credits);\n\t}\n\treturn max_t(long, free, 0);\n}\n\n/*\n * Definitions which augment the buffer_head layer\n */\n\n/* journaling buffer types */\n#define BJ_None\t\t0\t/* Not journaled */\n#define BJ_Metadata\t1\t/* Normal journaled metadata */\n#define BJ_Forget\t2\t/* Buffer superseded by this transaction */\n#define BJ_Shadow\t3\t/* Buffer contents being shadowed to the log */\n#define BJ_Reserved\t4\t/* Buffer is reserved for access by journal */\n#define BJ_Types\t5\n\nextern int jbd_blocks_per_page(struct inode *inode);\n\n/* JBD uses a CRC32 checksum */\n#define JBD_MAX_CHECKSUM_SIZE 4\n\nstatic inline u32 jbd2_chksum(journal_t *journal, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[JBD_MAX_CHECKSUM_SIZE];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(journal->j_chksum_driver) >\n\t\tJBD_MAX_CHECKSUM_SIZE);\n\n\tdesc.shash.tfm = journal->j_chksum_driver;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}\n\n/* Return most recent uncommitted transaction */\nstatic inline tid_t  jbd2_get_latest_transaction(journal_t *journal)\n{\n\ttid_t tid;\n\n\tread_lock(&journal->j_state_lock);\n\ttid = journal->j_commit_request;\n\tif (journal->j_running_transaction)\n\t\ttid = journal->j_running_transaction->t_tid;\n\tread_unlock(&journal->j_state_lock);\n\treturn tid;\n}\n\nstatic inline int jbd2_handle_buffer_credits(handle_t *handle)\n{\n\tjournal_t *journal;\n\n\tif (!handle->h_reserved)\n\t\tjournal = handle->h_transaction->t_journal;\n\telse\n\t\tjournal = handle->h_journal;\n\n\treturn handle->h_total_credits -\n\t\tDIV_ROUND_UP(handle->h_revoke_credits_requested,\n\t\t\t     journal->j_revoke_records_per_block);\n}\n\n#ifdef __KERNEL__\n\n#define buffer_trace_init(bh)\tdo {} while (0)\n#define print_buffer_fields(bh)\tdo {} while (0)\n#define print_buffer_trace(bh)\tdo {} while (0)\n#define BUFFER_TRACE(bh, info)\tdo {} while (0)\n#define BUFFER_TRACE2(bh, bh2, info)\tdo {} while (0)\n#define JBUFFER_TRACE(jh, info)\tdo {} while (0)\n\n#endif\t/* __KERNEL__ */\n\n#define EFSBADCRC\tEBADMSG\t\t/* Bad CRC detected */\n#define EFSCORRUPTED\tEUCLEAN\t\t/* Filesystem is corrupted */\n\n#endif\t/* _LINUX_JBD2_H */\n"}, "10": {"id": 10, "path": "/src/include/trace/events/ext4.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM ext4\n\n#if !defined(_TRACE_EXT4_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _TRACE_EXT4_H\n\n#include <linux/writeback.h>\n#include <linux/tracepoint.h>\n\nstruct ext4_allocation_context;\nstruct ext4_allocation_request;\nstruct ext4_extent;\nstruct ext4_prealloc_space;\nstruct ext4_inode_info;\nstruct mpage_da_data;\nstruct ext4_map_blocks;\nstruct extent_status;\nstruct ext4_fsmap;\nstruct partial_cluster;\n\n#define EXT4_I(inode) (container_of(inode, struct ext4_inode_info, vfs_inode))\n\n#define show_mballoc_flags(flags) __print_flags(flags, \"|\",\t\\\n\t{ EXT4_MB_HINT_MERGE,\t\t\"HINT_MERGE\" },\t\t\\\n\t{ EXT4_MB_HINT_RESERVED,\t\"HINT_RESV\" },\t\t\\\n\t{ EXT4_MB_HINT_METADATA,\t\"HINT_MDATA\" },\t\t\\\n\t{ EXT4_MB_HINT_FIRST,\t\t\"HINT_FIRST\" },\t\t\\\n\t{ EXT4_MB_HINT_BEST,\t\t\"HINT_BEST\" },\t\t\\\n\t{ EXT4_MB_HINT_DATA,\t\t\"HINT_DATA\" },\t\t\\\n\t{ EXT4_MB_HINT_NOPREALLOC,\t\"HINT_NOPREALLOC\" },\t\\\n\t{ EXT4_MB_HINT_GROUP_ALLOC,\t\"HINT_GRP_ALLOC\" },\t\\\n\t{ EXT4_MB_HINT_GOAL_ONLY,\t\"HINT_GOAL_ONLY\" },\t\\\n\t{ EXT4_MB_HINT_TRY_GOAL,\t\"HINT_TRY_GOAL\" },\t\\\n\t{ EXT4_MB_DELALLOC_RESERVED,\t\"DELALLOC_RESV\" },\t\\\n\t{ EXT4_MB_STREAM_ALLOC,\t\t\"STREAM_ALLOC\" },\t\\\n\t{ EXT4_MB_USE_ROOT_BLOCKS,\t\"USE_ROOT_BLKS\" },\t\\\n\t{ EXT4_MB_USE_RESERVED,\t\t\"USE_RESV\" },\t\t\\\n\t{ EXT4_MB_STRICT_CHECK,\t\t\"STRICT_CHECK\" })\n\n#define show_map_flags(flags) __print_flags(flags, \"|\",\t\t\t\\\n\t{ EXT4_GET_BLOCKS_CREATE,\t\t\"CREATE\" },\t\t\\\n\t{ EXT4_GET_BLOCKS_UNWRIT_EXT,\t\t\"UNWRIT\" },\t\t\\\n\t{ EXT4_GET_BLOCKS_DELALLOC_RESERVE,\t\"DELALLOC\" },\t\t\\\n\t{ EXT4_GET_BLOCKS_PRE_IO,\t\t\"PRE_IO\" },\t\t\\\n\t{ EXT4_GET_BLOCKS_CONVERT,\t\t\"CONVERT\" },\t\t\\\n\t{ EXT4_GET_BLOCKS_METADATA_NOFAIL,\t\"METADATA_NOFAIL\" },\t\\\n\t{ EXT4_GET_BLOCKS_NO_NORMALIZE,\t\t\"NO_NORMALIZE\" },\t\\\n\t{ EXT4_GET_BLOCKS_CONVERT_UNWRITTEN,\t\"CONVERT_UNWRITTEN\" },  \\\n\t{ EXT4_GET_BLOCKS_ZERO,\t\t\t\"ZERO\" },\t\t\\\n\t{ EXT4_GET_BLOCKS_IO_SUBMIT,\t\t\"IO_SUBMIT\" },\t\t\\\n\t{ EXT4_EX_NOCACHE,\t\t\t\"EX_NOCACHE\" })\n\n/*\n * __print_flags() requires that all enum values be wrapped in the\n * TRACE_DEFINE_ENUM macro so that the enum value can be encoded in the ftrace\n * ring buffer.\n */\nTRACE_DEFINE_ENUM(BH_New);\nTRACE_DEFINE_ENUM(BH_Mapped);\nTRACE_DEFINE_ENUM(BH_Unwritten);\nTRACE_DEFINE_ENUM(BH_Boundary);\n\n#define show_mflags(flags) __print_flags(flags, \"\",\t\\\n\t{ EXT4_MAP_NEW,\t\t\"N\" },\t\t\t\\\n\t{ EXT4_MAP_MAPPED,\t\"M\" },\t\t\t\\\n\t{ EXT4_MAP_UNWRITTEN,\t\"U\" },\t\t\t\\\n\t{ EXT4_MAP_BOUNDARY,\t\"B\" })\n\n#define show_free_flags(flags) __print_flags(flags, \"|\",\t\\\n\t{ EXT4_FREE_BLOCKS_METADATA,\t\t\"METADATA\" },\t\\\n\t{ EXT4_FREE_BLOCKS_FORGET,\t\t\"FORGET\" },\t\\\n\t{ EXT4_FREE_BLOCKS_VALIDATED,\t\t\"VALIDATED\" },\t\\\n\t{ EXT4_FREE_BLOCKS_NO_QUOT_UPDATE,\t\"NO_QUOTA\" },\t\\\n\t{ EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER,\"1ST_CLUSTER\" },\\\n\t{ EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER,\t\"LAST_CLUSTER\" })\n\nTRACE_DEFINE_ENUM(ES_WRITTEN_B);\nTRACE_DEFINE_ENUM(ES_UNWRITTEN_B);\nTRACE_DEFINE_ENUM(ES_DELAYED_B);\nTRACE_DEFINE_ENUM(ES_HOLE_B);\nTRACE_DEFINE_ENUM(ES_REFERENCED_B);\n\n#define show_extent_status(status) __print_flags(status, \"\",\t\\\n\t{ EXTENT_STATUS_WRITTEN,\t\"W\" },\t\t\t\\\n\t{ EXTENT_STATUS_UNWRITTEN,\t\"U\" },\t\t\t\\\n\t{ EXTENT_STATUS_DELAYED,\t\"D\" },\t\t\t\\\n\t{ EXTENT_STATUS_HOLE,\t\t\"H\" },\t\t\t\\\n\t{ EXTENT_STATUS_REFERENCED,\t\"R\" })\n\n#define show_falloc_mode(mode) __print_flags(mode, \"|\",\t\t\\\n\t{ FALLOC_FL_KEEP_SIZE,\t\t\"KEEP_SIZE\"},\t\t\\\n\t{ FALLOC_FL_PUNCH_HOLE,\t\t\"PUNCH_HOLE\"},\t\t\\\n\t{ FALLOC_FL_NO_HIDE_STALE,\t\"NO_HIDE_STALE\"},\t\\\n\t{ FALLOC_FL_COLLAPSE_RANGE,\t\"COLLAPSE_RANGE\"},\t\\\n\t{ FALLOC_FL_ZERO_RANGE,\t\t\"ZERO_RANGE\"})\n\n#define show_fc_reason(reason)\t\t\t\t\t\t\\\n\t__print_symbolic(reason,\t\t\t\t\t\\\n\t\t{ EXT4_FC_REASON_XATTR,\t\t\"XATTR\"},\t\t\\\n\t\t{ EXT4_FC_REASON_CROSS_RENAME,\t\"CROSS_RENAME\"},\t\\\n\t\t{ EXT4_FC_REASON_JOURNAL_FLAG_CHANGE, \"JOURNAL_FLAG_CHANGE\"}, \\\n\t\t{ EXT4_FC_REASON_MEM,\t\"NO_MEM\"},\t\t\t\\\n\t\t{ EXT4_FC_REASON_SWAP_BOOT,\t\"SWAP_BOOT\"},\t\t\\\n\t\t{ EXT4_FC_REASON_RESIZE,\t\"RESIZE\"},\t\t\\\n\t\t{ EXT4_FC_REASON_RENAME_DIR,\t\"RENAME_DIR\"},\t\t\\\n\t\t{ EXT4_FC_REASON_FALLOC_RANGE,\t\"FALLOC_RANGE\"})\n\nTRACE_EVENT(ext4_other_inode_update_time,\n\tTP_PROTO(struct inode *inode, ino_t orig_ino),\n\n\tTP_ARGS(inode, orig_ino),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tino_t,\torig_ino\t\t)\n\t\t__field(\tuid_t,\tuid\t\t\t)\n\t\t__field(\tgid_t,\tgid\t\t\t)\n\t\t__field(\t__u16, mode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->orig_ino = orig_ino;\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->uid\t= i_uid_read(inode);\n\t\t__entry->gid\t= i_gid_read(inode);\n\t\t__entry->mode\t= inode->i_mode;\n\t),\n\n\tTP_printk(\"dev %d,%d orig_ino %lu ino %lu mode 0%o uid %u gid %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->orig_ino,\n\t\t  (unsigned long) __entry->ino, __entry->mode,\n\t\t  __entry->uid, __entry->gid)\n);\n\nTRACE_EVENT(ext4_free_inode,\n\tTP_PROTO(struct inode *inode),\n\n\tTP_ARGS(inode),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tuid_t,\tuid\t\t\t)\n\t\t__field(\tgid_t,\tgid\t\t\t)\n\t\t__field(\t__u64, blocks\t\t\t)\n\t\t__field(\t__u16, mode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->uid\t= i_uid_read(inode);\n\t\t__entry->gid\t= i_gid_read(inode);\n\t\t__entry->blocks\t= inode->i_blocks;\n\t\t__entry->mode\t= inode->i_mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu mode 0%o uid %u gid %u blocks %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->mode,\n\t\t  __entry->uid, __entry->gid, __entry->blocks)\n);\n\nTRACE_EVENT(ext4_request_inode,\n\tTP_PROTO(struct inode *dir, int mode),\n\n\tTP_ARGS(dir, mode),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tdir\t\t\t)\n\t\t__field(\t__u16, mode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= dir->i_sb->s_dev;\n\t\t__entry->dir\t= dir->i_ino;\n\t\t__entry->mode\t= mode;\n\t),\n\n\tTP_printk(\"dev %d,%d dir %lu mode 0%o\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->dir, __entry->mode)\n);\n\nTRACE_EVENT(ext4_allocate_inode,\n\tTP_PROTO(struct inode *inode, struct inode *dir, int mode),\n\n\tTP_ARGS(inode, dir, mode),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tino_t,\tdir\t\t\t)\n\t\t__field(\t__u16,\tmode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->dir\t= dir->i_ino;\n\t\t__entry->mode\t= mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu dir %lu mode 0%o\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned long) __entry->dir, __entry->mode)\n);\n\nTRACE_EVENT(ext4_evict_inode,\n\tTP_PROTO(struct inode *inode),\n\n\tTP_ARGS(inode),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tint,\tnlink\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->nlink\t= inode->i_nlink;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu nlink %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->nlink)\n);\n\nTRACE_EVENT(ext4_drop_inode,\n\tTP_PROTO(struct inode *inode, int drop),\n\n\tTP_ARGS(inode, drop),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tint,\tdrop\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->drop\t= drop;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu drop %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->drop)\n);\n\nTRACE_EVENT(ext4_nfs_commit_metadata,\n\tTP_PROTO(struct inode *inode),\n\n\tTP_ARGS(inode),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino)\n);\n\nTRACE_EVENT(ext4_mark_inode_dirty,\n\tTP_PROTO(struct inode *inode, unsigned long IP),\n\n\tTP_ARGS(inode, IP),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(unsigned long,\tip\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->ip\t= IP;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu caller %pS\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, (void *)__entry->ip)\n);\n\nTRACE_EVENT(ext4_begin_ordered_truncate,\n\tTP_PROTO(struct inode *inode, loff_t new_size),\n\n\tTP_ARGS(inode, new_size),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tloff_t,\tnew_size\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->new_size\t= new_size;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu new_size %lld\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->new_size)\n);\n\nDECLARE_EVENT_CLASS(ext4__write_begin,\n\n\tTP_PROTO(struct inode *inode, loff_t pos, unsigned int len,\n\t\t unsigned int flags),\n\n\tTP_ARGS(inode, pos, len, flags),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tloff_t,\tpos\t\t\t)\n\t\t__field(\tunsigned int, len\t\t)\n\t\t__field(\tunsigned int, flags\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->pos\t= pos;\n\t\t__entry->len\t= len;\n\t\t__entry->flags\t= flags;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu pos %lld len %u flags %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->pos, __entry->len, __entry->flags)\n);\n\nDEFINE_EVENT(ext4__write_begin, ext4_write_begin,\n\n\tTP_PROTO(struct inode *inode, loff_t pos, unsigned int len,\n\t\t unsigned int flags),\n\n\tTP_ARGS(inode, pos, len, flags)\n);\n\nDEFINE_EVENT(ext4__write_begin, ext4_da_write_begin,\n\n\tTP_PROTO(struct inode *inode, loff_t pos, unsigned int len,\n\t\t unsigned int flags),\n\n\tTP_ARGS(inode, pos, len, flags)\n);\n\nDECLARE_EVENT_CLASS(ext4__write_end,\n\tTP_PROTO(struct inode *inode, loff_t pos, unsigned int len,\n\t\t\tunsigned int copied),\n\n\tTP_ARGS(inode, pos, len, copied),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tloff_t,\tpos\t\t\t)\n\t\t__field(\tunsigned int, len\t\t)\n\t\t__field(\tunsigned int, copied\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->pos\t= pos;\n\t\t__entry->len\t= len;\n\t\t__entry->copied\t= copied;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu pos %lld len %u copied %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->pos, __entry->len, __entry->copied)\n);\n\nDEFINE_EVENT(ext4__write_end, ext4_write_end,\n\n\tTP_PROTO(struct inode *inode, loff_t pos, unsigned int len,\n\t\t unsigned int copied),\n\n\tTP_ARGS(inode, pos, len, copied)\n);\n\nDEFINE_EVENT(ext4__write_end, ext4_journalled_write_end,\n\n\tTP_PROTO(struct inode *inode, loff_t pos, unsigned int len,\n\t\t unsigned int copied),\n\n\tTP_ARGS(inode, pos, len, copied)\n);\n\nDEFINE_EVENT(ext4__write_end, ext4_da_write_end,\n\n\tTP_PROTO(struct inode *inode, loff_t pos, unsigned int len,\n\t\t unsigned int copied),\n\n\tTP_ARGS(inode, pos, len, copied)\n);\n\nTRACE_EVENT(ext4_writepages,\n\tTP_PROTO(struct inode *inode, struct writeback_control *wbc),\n\n\tTP_ARGS(inode, wbc),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tlong,\tnr_to_write\t\t)\n\t\t__field(\tlong,\tpages_skipped\t\t)\n\t\t__field(\tloff_t,\trange_start\t\t)\n\t\t__field(\tloff_t,\trange_end\t\t)\n\t\t__field(       pgoff_t,\twriteback_index\t\t)\n\t\t__field(\tint,\tsync_mode\t\t)\n\t\t__field(\tchar,\tfor_kupdate\t\t)\n\t\t__field(\tchar,\trange_cyclic\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->nr_to_write\t= wbc->nr_to_write;\n\t\t__entry->pages_skipped\t= wbc->pages_skipped;\n\t\t__entry->range_start\t= wbc->range_start;\n\t\t__entry->range_end\t= wbc->range_end;\n\t\t__entry->writeback_index = inode->i_mapping->writeback_index;\n\t\t__entry->sync_mode\t= wbc->sync_mode;\n\t\t__entry->for_kupdate\t= wbc->for_kupdate;\n\t\t__entry->range_cyclic\t= wbc->range_cyclic;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu nr_to_write %ld pages_skipped %ld \"\n\t\t  \"range_start %lld range_end %lld sync_mode %d \"\n\t\t  \"for_kupdate %d range_cyclic %d writeback_index %lu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->nr_to_write,\n\t\t  __entry->pages_skipped, __entry->range_start,\n\t\t  __entry->range_end, __entry->sync_mode,\n\t\t  __entry->for_kupdate, __entry->range_cyclic,\n\t\t  (unsigned long) __entry->writeback_index)\n);\n\nTRACE_EVENT(ext4_da_write_pages,\n\tTP_PROTO(struct inode *inode, pgoff_t first_page,\n\t\t struct writeback_control *wbc),\n\n\tTP_ARGS(inode, first_page, wbc),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(      pgoff_t,\tfirst_page\t\t)\n\t\t__field(\t long,\tnr_to_write\t\t)\n\t\t__field(\t  int,\tsync_mode\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->first_page\t= first_page;\n\t\t__entry->nr_to_write\t= wbc->nr_to_write;\n\t\t__entry->sync_mode\t= wbc->sync_mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu first_page %lu nr_to_write %ld \"\n\t\t  \"sync_mode %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->first_page,\n\t\t  __entry->nr_to_write, __entry->sync_mode)\n);\n\nTRACE_EVENT(ext4_da_write_pages_extent,\n\tTP_PROTO(struct inode *inode, struct ext4_map_blocks *map),\n\n\tTP_ARGS(inode, map),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u64,\tlblk\t\t\t)\n\t\t__field(\t__u32,\tlen\t\t\t)\n\t\t__field(\t__u32,\tflags\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->lblk\t\t= map->m_lblk;\n\t\t__entry->len\t\t= map->m_len;\n\t\t__entry->flags\t\t= map->m_flags;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu lblk %llu len %u flags %s\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->lblk, __entry->len,\n\t\t  show_mflags(__entry->flags))\n);\n\nTRACE_EVENT(ext4_writepages_result,\n\tTP_PROTO(struct inode *inode, struct writeback_control *wbc,\n\t\t\tint ret, int pages_written),\n\n\tTP_ARGS(inode, wbc, ret, pages_written),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tint,\tret\t\t\t)\n\t\t__field(\tint,\tpages_written\t\t)\n\t\t__field(\tlong,\tpages_skipped\t\t)\n\t\t__field(       pgoff_t,\twriteback_index\t\t)\n\t\t__field(\tint,\tsync_mode\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->ret\t\t= ret;\n\t\t__entry->pages_written\t= pages_written;\n\t\t__entry->pages_skipped\t= wbc->pages_skipped;\n\t\t__entry->writeback_index = inode->i_mapping->writeback_index;\n\t\t__entry->sync_mode\t= wbc->sync_mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu ret %d pages_written %d pages_skipped %ld \"\n\t\t  \"sync_mode %d writeback_index %lu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->ret,\n\t\t  __entry->pages_written, __entry->pages_skipped,\n\t\t  __entry->sync_mode,\n\t\t  (unsigned long) __entry->writeback_index)\n);\n\nDECLARE_EVENT_CLASS(ext4__page_op,\n\tTP_PROTO(struct page *page),\n\n\tTP_ARGS(page),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tpgoff_t, index\t\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= page->mapping->host->i_sb->s_dev;\n\t\t__entry->ino\t= page->mapping->host->i_ino;\n\t\t__entry->index\t= page->index;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu page_index %lu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned long) __entry->index)\n);\n\nDEFINE_EVENT(ext4__page_op, ext4_writepage,\n\n\tTP_PROTO(struct page *page),\n\n\tTP_ARGS(page)\n);\n\nDEFINE_EVENT(ext4__page_op, ext4_readpage,\n\n\tTP_PROTO(struct page *page),\n\n\tTP_ARGS(page)\n);\n\nDEFINE_EVENT(ext4__page_op, ext4_releasepage,\n\n\tTP_PROTO(struct page *page),\n\n\tTP_ARGS(page)\n);\n\nDECLARE_EVENT_CLASS(ext4_invalidatepage_op,\n\tTP_PROTO(struct page *page, unsigned int offset, unsigned int length),\n\n\tTP_ARGS(page, offset, length),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tpgoff_t, index\t\t\t)\n\t\t__field(\tunsigned int, offset\t\t)\n\t\t__field(\tunsigned int, length\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= page->mapping->host->i_sb->s_dev;\n\t\t__entry->ino\t= page->mapping->host->i_ino;\n\t\t__entry->index\t= page->index;\n\t\t__entry->offset\t= offset;\n\t\t__entry->length\t= length;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu page_index %lu offset %u length %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned long) __entry->index,\n\t\t  __entry->offset, __entry->length)\n);\n\nDEFINE_EVENT(ext4_invalidatepage_op, ext4_invalidatepage,\n\tTP_PROTO(struct page *page, unsigned int offset, unsigned int length),\n\n\tTP_ARGS(page, offset, length)\n);\n\nDEFINE_EVENT(ext4_invalidatepage_op, ext4_journalled_invalidatepage,\n\tTP_PROTO(struct page *page, unsigned int offset, unsigned int length),\n\n\tTP_ARGS(page, offset, length)\n);\n\nTRACE_EVENT(ext4_discard_blocks,\n\tTP_PROTO(struct super_block *sb, unsigned long long blk,\n\t\t\tunsigned long long count),\n\n\tTP_ARGS(sb, blk, count),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\t__u64,\tblk\t\t\t)\n\t\t__field(\t__u64,\tcount\t\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->blk\t= blk;\n\t\t__entry->count\t= count;\n\t),\n\n\tTP_printk(\"dev %d,%d blk %llu count %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->blk, __entry->count)\n);\n\nDECLARE_EVENT_CLASS(ext4__mb_new_pa,\n\tTP_PROTO(struct ext4_allocation_context *ac,\n\t\t struct ext4_prealloc_space *pa),\n\n\tTP_ARGS(ac, pa),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u64,\tpa_pstart\t\t)\n\t\t__field(\t__u64,\tpa_lstart\t\t)\n\t\t__field(\t__u32,\tpa_len\t\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= ac->ac_sb->s_dev;\n\t\t__entry->ino\t\t= ac->ac_inode->i_ino;\n\t\t__entry->pa_pstart\t= pa->pa_pstart;\n\t\t__entry->pa_lstart\t= pa->pa_lstart;\n\t\t__entry->pa_len\t\t= pa->pa_len;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu pstart %llu len %u lstart %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->pa_pstart, __entry->pa_len, __entry->pa_lstart)\n);\n\nDEFINE_EVENT(ext4__mb_new_pa, ext4_mb_new_inode_pa,\n\n\tTP_PROTO(struct ext4_allocation_context *ac,\n\t\t struct ext4_prealloc_space *pa),\n\n\tTP_ARGS(ac, pa)\n);\n\nDEFINE_EVENT(ext4__mb_new_pa, ext4_mb_new_group_pa,\n\n\tTP_PROTO(struct ext4_allocation_context *ac,\n\t\t struct ext4_prealloc_space *pa),\n\n\tTP_ARGS(ac, pa)\n);\n\nTRACE_EVENT(ext4_mb_release_inode_pa,\n\tTP_PROTO(struct ext4_prealloc_space *pa,\n\t\t unsigned long long block, unsigned int count),\n\n\tTP_ARGS(pa, block, count),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u64,\tblock\t\t\t)\n\t\t__field(\t__u32,\tcount\t\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= pa->pa_inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= pa->pa_inode->i_ino;\n\t\t__entry->block\t\t= block;\n\t\t__entry->count\t\t= count;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu block %llu count %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->block, __entry->count)\n);\n\nTRACE_EVENT(ext4_mb_release_group_pa,\n\tTP_PROTO(struct super_block *sb, struct ext4_prealloc_space *pa),\n\n\tTP_ARGS(sb, pa),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\t__u64,\tpa_pstart\t\t)\n\t\t__field(\t__u32,\tpa_len\t\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= sb->s_dev;\n\t\t__entry->pa_pstart\t= pa->pa_pstart;\n\t\t__entry->pa_len\t\t= pa->pa_len;\n\t),\n\n\tTP_printk(\"dev %d,%d pstart %llu len %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->pa_pstart, __entry->pa_len)\n);\n\nTRACE_EVENT(ext4_discard_preallocations,\n\tTP_PROTO(struct inode *inode, unsigned int len, unsigned int needed),\n\n\tTP_ARGS(inode, len, needed),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\tunsigned int,\tlen\t\t)\n\t\t__field(\tunsigned int,\tneeded\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->len\t= len;\n\t\t__entry->needed\t= needed;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu len: %u needed %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->len,\n\t\t  __entry->needed)\n);\n\nTRACE_EVENT(ext4_mb_discard_preallocations,\n\tTP_PROTO(struct super_block *sb, int needed),\n\n\tTP_ARGS(sb, needed),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tint,\tneeded\t\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->needed\t= needed;\n\t),\n\n\tTP_printk(\"dev %d,%d needed %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->needed)\n);\n\nTRACE_EVENT(ext4_request_blocks,\n\tTP_PROTO(struct ext4_allocation_request *ar),\n\n\tTP_ARGS(ar),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tunsigned int, len\t\t)\n\t\t__field(\t__u32,  logical\t\t\t)\n\t\t__field(\t__u32,\tlleft\t\t\t)\n\t\t__field(\t__u32,\tlright\t\t\t)\n\t\t__field(\t__u64,\tgoal\t\t\t)\n\t\t__field(\t__u64,\tpleft\t\t\t)\n\t\t__field(\t__u64,\tpright\t\t\t)\n\t\t__field(\tunsigned int, flags\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= ar->inode->i_sb->s_dev;\n\t\t__entry->ino\t= ar->inode->i_ino;\n\t\t__entry->len\t= ar->len;\n\t\t__entry->logical = ar->logical;\n\t\t__entry->goal\t= ar->goal;\n\t\t__entry->lleft\t= ar->lleft;\n\t\t__entry->lright\t= ar->lright;\n\t\t__entry->pleft\t= ar->pleft;\n\t\t__entry->pright\t= ar->pright;\n\t\t__entry->flags\t= ar->flags;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu flags %s len %u lblk %u goal %llu \"\n\t\t  \"lleft %u lright %u pleft %llu pright %llu \",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, show_mballoc_flags(__entry->flags),\n\t\t  __entry->len, __entry->logical, __entry->goal,\n\t\t  __entry->lleft, __entry->lright, __entry->pleft,\n\t\t  __entry->pright)\n);\n\nTRACE_EVENT(ext4_allocate_blocks,\n\tTP_PROTO(struct ext4_allocation_request *ar, unsigned long long block),\n\n\tTP_ARGS(ar, block),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u64,\tblock\t\t\t)\n\t\t__field(\tunsigned int, len\t\t)\n\t\t__field(\t__u32,  logical\t\t\t)\n\t\t__field(\t__u32,\tlleft\t\t\t)\n\t\t__field(\t__u32,\tlright\t\t\t)\n\t\t__field(\t__u64,\tgoal\t\t\t)\n\t\t__field(\t__u64,\tpleft\t\t\t)\n\t\t__field(\t__u64,\tpright\t\t\t)\n\t\t__field(\tunsigned int, flags\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= ar->inode->i_sb->s_dev;\n\t\t__entry->ino\t= ar->inode->i_ino;\n\t\t__entry->block\t= block;\n\t\t__entry->len\t= ar->len;\n\t\t__entry->logical = ar->logical;\n\t\t__entry->goal\t= ar->goal;\n\t\t__entry->lleft\t= ar->lleft;\n\t\t__entry->lright\t= ar->lright;\n\t\t__entry->pleft\t= ar->pleft;\n\t\t__entry->pright\t= ar->pright;\n\t\t__entry->flags\t= ar->flags;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu flags %s len %u block %llu lblk %u \"\n\t\t  \"goal %llu lleft %u lright %u pleft %llu pright %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, show_mballoc_flags(__entry->flags),\n\t\t  __entry->len, __entry->block, __entry->logical,\n\t\t  __entry->goal,  __entry->lleft, __entry->lright,\n\t\t  __entry->pleft, __entry->pright)\n);\n\nTRACE_EVENT(ext4_free_blocks,\n\tTP_PROTO(struct inode *inode, __u64 block, unsigned long count,\n\t\t int flags),\n\n\tTP_ARGS(inode, block, count, flags),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u64,\tblock\t\t\t)\n\t\t__field(\tunsigned long,\tcount\t\t)\n\t\t__field(\tint,\tflags\t\t\t)\n\t\t__field(\t__u16,\tmode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->block\t\t= block;\n\t\t__entry->count\t\t= count;\n\t\t__entry->flags\t\t= flags;\n\t\t__entry->mode\t\t= inode->i_mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu mode 0%o block %llu count %lu flags %s\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->mode, __entry->block, __entry->count,\n\t\t  show_free_flags(__entry->flags))\n);\n\nTRACE_EVENT(ext4_sync_file_enter,\n\tTP_PROTO(struct file *file, int datasync),\n\n\tTP_ARGS(file, datasync),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tino_t,\tparent\t\t\t)\n\t\t__field(\tint,\tdatasync\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\tstruct dentry *dentry = file->f_path.dentry;\n\n\t\t__entry->dev\t\t= dentry->d_sb->s_dev;\n\t\t__entry->ino\t\t= d_inode(dentry)->i_ino;\n\t\t__entry->datasync\t= datasync;\n\t\t__entry->parent\t\t= d_inode(dentry->d_parent)->i_ino;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu parent %lu datasync %d \",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned long) __entry->parent, __entry->datasync)\n);\n\nTRACE_EVENT(ext4_sync_file_exit,\n\tTP_PROTO(struct inode *inode, int ret),\n\n\tTP_ARGS(inode, ret),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tint,\tret\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->ret\t\t= ret;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu ret %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->ret)\n);\n\nTRACE_EVENT(ext4_sync_fs,\n\tTP_PROTO(struct super_block *sb, int wait),\n\n\tTP_ARGS(sb, wait),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tint,\twait\t\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->wait\t= wait;\n\t),\n\n\tTP_printk(\"dev %d,%d wait %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->wait)\n);\n\nTRACE_EVENT(ext4_alloc_da_blocks,\n\tTP_PROTO(struct inode *inode),\n\n\tTP_ARGS(inode),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field( unsigned int,\tdata_blocks\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->data_blocks = EXT4_I(inode)->i_reserved_data_blocks;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu reserved_data_blocks %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->data_blocks)\n);\n\nTRACE_EVENT(ext4_mballoc_alloc,\n\tTP_PROTO(struct ext4_allocation_context *ac),\n\n\tTP_ARGS(ac),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u32, \torig_logical\t\t)\n\t\t__field(\t  int,\torig_start\t\t)\n\t\t__field(\t__u32, \torig_group\t\t)\n\t\t__field(\t  int,\torig_len\t\t)\n\t\t__field(\t__u32, \tgoal_logical\t\t)\n\t\t__field(\t  int,\tgoal_start\t\t)\n\t\t__field(\t__u32, \tgoal_group\t\t)\n\t\t__field(\t  int,\tgoal_len\t\t)\n\t\t__field(\t__u32, \tresult_logical\t\t)\n\t\t__field(\t  int,\tresult_start\t\t)\n\t\t__field(\t__u32, \tresult_group\t\t)\n\t\t__field(\t  int,\tresult_len\t\t)\n\t\t__field(\t__u16,\tfound\t\t\t)\n\t\t__field(\t__u16,\tgroups\t\t\t)\n\t\t__field(\t__u16,\tbuddy\t\t\t)\n\t\t__field(\t__u16,\tflags\t\t\t)\n\t\t__field(\t__u16,\ttail\t\t\t)\n\t\t__field(\t__u8,\tcr\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= ac->ac_inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= ac->ac_inode->i_ino;\n\t\t__entry->orig_logical\t= ac->ac_o_ex.fe_logical;\n\t\t__entry->orig_start\t= ac->ac_o_ex.fe_start;\n\t\t__entry->orig_group\t= ac->ac_o_ex.fe_group;\n\t\t__entry->orig_len\t= ac->ac_o_ex.fe_len;\n\t\t__entry->goal_logical\t= ac->ac_g_ex.fe_logical;\n\t\t__entry->goal_start\t= ac->ac_g_ex.fe_start;\n\t\t__entry->goal_group\t= ac->ac_g_ex.fe_group;\n\t\t__entry->goal_len\t= ac->ac_g_ex.fe_len;\n\t\t__entry->result_logical\t= ac->ac_f_ex.fe_logical;\n\t\t__entry->result_start\t= ac->ac_f_ex.fe_start;\n\t\t__entry->result_group\t= ac->ac_f_ex.fe_group;\n\t\t__entry->result_len\t= ac->ac_f_ex.fe_len;\n\t\t__entry->found\t\t= ac->ac_found;\n\t\t__entry->flags\t\t= ac->ac_flags;\n\t\t__entry->groups\t\t= ac->ac_groups_scanned;\n\t\t__entry->buddy\t\t= ac->ac_buddy;\n\t\t__entry->tail\t\t= ac->ac_tail;\n\t\t__entry->cr\t\t= ac->ac_criteria;\n\t),\n\n\tTP_printk(\"dev %d,%d inode %lu orig %u/%d/%u@%u goal %u/%d/%u@%u \"\n\t\t  \"result %u/%d/%u@%u blks %u grps %u cr %u flags %s \"\n\t\t  \"tail %u broken %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->orig_group, __entry->orig_start,\n\t\t  __entry->orig_len, __entry->orig_logical,\n\t\t  __entry->goal_group, __entry->goal_start,\n\t\t  __entry->goal_len, __entry->goal_logical,\n\t\t  __entry->result_group, __entry->result_start,\n\t\t  __entry->result_len, __entry->result_logical,\n\t\t  __entry->found, __entry->groups, __entry->cr,\n\t\t  show_mballoc_flags(__entry->flags), __entry->tail,\n\t\t  __entry->buddy ? 1 << __entry->buddy : 0)\n);\n\nTRACE_EVENT(ext4_mballoc_prealloc,\n\tTP_PROTO(struct ext4_allocation_context *ac),\n\n\tTP_ARGS(ac),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u32, \torig_logical\t\t)\n\t\t__field(\t  int,\torig_start\t\t)\n\t\t__field(\t__u32, \torig_group\t\t)\n\t\t__field(\t  int,\torig_len\t\t)\n\t\t__field(\t__u32, \tresult_logical\t\t)\n\t\t__field(\t  int,\tresult_start\t\t)\n\t\t__field(\t__u32, \tresult_group\t\t)\n\t\t__field(\t  int,\tresult_len\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= ac->ac_inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= ac->ac_inode->i_ino;\n\t\t__entry->orig_logical\t= ac->ac_o_ex.fe_logical;\n\t\t__entry->orig_start\t= ac->ac_o_ex.fe_start;\n\t\t__entry->orig_group\t= ac->ac_o_ex.fe_group;\n\t\t__entry->orig_len\t= ac->ac_o_ex.fe_len;\n\t\t__entry->result_logical\t= ac->ac_b_ex.fe_logical;\n\t\t__entry->result_start\t= ac->ac_b_ex.fe_start;\n\t\t__entry->result_group\t= ac->ac_b_ex.fe_group;\n\t\t__entry->result_len\t= ac->ac_b_ex.fe_len;\n\t),\n\n\tTP_printk(\"dev %d,%d inode %lu orig %u/%d/%u@%u result %u/%d/%u@%u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->orig_group, __entry->orig_start,\n\t\t  __entry->orig_len, __entry->orig_logical,\n\t\t  __entry->result_group, __entry->result_start,\n\t\t  __entry->result_len, __entry->result_logical)\n);\n\nDECLARE_EVENT_CLASS(ext4__mballoc,\n\tTP_PROTO(struct super_block *sb,\n\t\t struct inode *inode,\n\t\t ext4_group_t group,\n\t\t ext4_grpblk_t start,\n\t\t ext4_grpblk_t len),\n\n\tTP_ARGS(sb, inode, group, start, len),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t  int,\tresult_start\t\t)\n\t\t__field(\t__u32, \tresult_group\t\t)\n\t\t__field(\t  int,\tresult_len\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= sb->s_dev;\n\t\t__entry->ino\t\t= inode ? inode->i_ino : 0;\n\t\t__entry->result_start\t= start;\n\t\t__entry->result_group\t= group;\n\t\t__entry->result_len\t= len;\n\t),\n\n\tTP_printk(\"dev %d,%d inode %lu extent %u/%d/%d \",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->result_group, __entry->result_start,\n\t\t  __entry->result_len)\n);\n\nDEFINE_EVENT(ext4__mballoc, ext4_mballoc_discard,\n\n\tTP_PROTO(struct super_block *sb,\n\t\t struct inode *inode,\n\t\t ext4_group_t group,\n\t\t ext4_grpblk_t start,\n\t\t ext4_grpblk_t len),\n\n\tTP_ARGS(sb, inode, group, start, len)\n);\n\nDEFINE_EVENT(ext4__mballoc, ext4_mballoc_free,\n\n\tTP_PROTO(struct super_block *sb,\n\t\t struct inode *inode,\n\t\t ext4_group_t group,\n\t\t ext4_grpblk_t start,\n\t\t ext4_grpblk_t len),\n\n\tTP_ARGS(sb, inode, group, start, len)\n);\n\nTRACE_EVENT(ext4_forget,\n\tTP_PROTO(struct inode *inode, int is_metadata, __u64 block),\n\n\tTP_ARGS(inode, is_metadata, block),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u64,\tblock\t\t\t)\n\t\t__field(\tint,\tis_metadata\t\t)\n\t\t__field(\t__u16,\tmode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->block\t= block;\n\t\t__entry->is_metadata = is_metadata;\n\t\t__entry->mode\t= inode->i_mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu mode 0%o is_metadata %d block %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->mode, __entry->is_metadata, __entry->block)\n);\n\nTRACE_EVENT(ext4_da_update_reserve_space,\n\tTP_PROTO(struct inode *inode, int used_blocks, int quota_claim),\n\n\tTP_ARGS(inode, used_blocks, quota_claim),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u64,\ti_blocks\t\t)\n\t\t__field(\tint,\tused_blocks\t\t)\n\t\t__field(\tint,\treserved_data_blocks\t)\n\t\t__field(\tint,\tquota_claim\t\t)\n\t\t__field(\t__u16,\tmode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->i_blocks = inode->i_blocks;\n\t\t__entry->used_blocks = used_blocks;\n\t\t__entry->reserved_data_blocks =\n\t\t\t\tEXT4_I(inode)->i_reserved_data_blocks;\n\t\t__entry->quota_claim = quota_claim;\n\t\t__entry->mode\t= inode->i_mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu mode 0%o i_blocks %llu used_blocks %d \"\n\t\t  \"reserved_data_blocks %d quota_claim %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->mode, __entry->i_blocks,\n\t\t  __entry->used_blocks, __entry->reserved_data_blocks,\n\t\t  __entry->quota_claim)\n);\n\nTRACE_EVENT(ext4_da_reserve_space,\n\tTP_PROTO(struct inode *inode),\n\n\tTP_ARGS(inode),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u64,\ti_blocks\t\t)\n\t\t__field(\tint,\treserved_data_blocks\t)\n\t\t__field(\t__u16,  mode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->i_blocks = inode->i_blocks;\n\t\t__entry->reserved_data_blocks = EXT4_I(inode)->i_reserved_data_blocks;\n\t\t__entry->mode\t= inode->i_mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu mode 0%o i_blocks %llu \"\n\t\t  \"reserved_data_blocks %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->mode, __entry->i_blocks,\n\t\t  __entry->reserved_data_blocks)\n);\n\nTRACE_EVENT(ext4_da_release_space,\n\tTP_PROTO(struct inode *inode, int freed_blocks),\n\n\tTP_ARGS(inode, freed_blocks),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u64,\ti_blocks\t\t)\n\t\t__field(\tint,\tfreed_blocks\t\t)\n\t\t__field(\tint,\treserved_data_blocks\t)\n\t\t__field(\t__u16,  mode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->i_blocks = inode->i_blocks;\n\t\t__entry->freed_blocks = freed_blocks;\n\t\t__entry->reserved_data_blocks = EXT4_I(inode)->i_reserved_data_blocks;\n\t\t__entry->mode\t= inode->i_mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu mode 0%o i_blocks %llu freed_blocks %d \"\n\t\t  \"reserved_data_blocks %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->mode, __entry->i_blocks,\n\t\t  __entry->freed_blocks, __entry->reserved_data_blocks)\n);\n\nDECLARE_EVENT_CLASS(ext4__bitmap_load,\n\tTP_PROTO(struct super_block *sb, unsigned long group),\n\n\tTP_ARGS(sb, group),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\t__u32,\tgroup\t\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->group\t= group;\n\t),\n\n\tTP_printk(\"dev %d,%d group %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->group)\n);\n\nDEFINE_EVENT(ext4__bitmap_load, ext4_mb_bitmap_load,\n\n\tTP_PROTO(struct super_block *sb, unsigned long group),\n\n\tTP_ARGS(sb, group)\n);\n\nDEFINE_EVENT(ext4__bitmap_load, ext4_mb_buddy_bitmap_load,\n\n\tTP_PROTO(struct super_block *sb, unsigned long group),\n\n\tTP_ARGS(sb, group)\n);\n\nDEFINE_EVENT(ext4__bitmap_load, ext4_load_inode_bitmap,\n\n\tTP_PROTO(struct super_block *sb, unsigned long group),\n\n\tTP_ARGS(sb, group)\n);\n\nTRACE_EVENT(ext4_read_block_bitmap_load,\n\tTP_PROTO(struct super_block *sb, unsigned long group, bool prefetch),\n\n\tTP_ARGS(sb, group, prefetch),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\t__u32,\tgroup\t\t\t)\n\t\t__field(\tbool,\tprefetch\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->group\t= group;\n\t\t__entry->prefetch = prefetch;\n\t),\n\n\tTP_printk(\"dev %d,%d group %u prefetch %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->group, __entry->prefetch)\n);\n\nTRACE_EVENT(ext4_direct_IO_enter,\n\tTP_PROTO(struct inode *inode, loff_t offset, unsigned long len, int rw),\n\n\tTP_ARGS(inode, offset, len, rw),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tloff_t,\tpos\t\t\t)\n\t\t__field(\tunsigned long,\tlen\t\t)\n\t\t__field(\tint,\trw\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->pos\t= offset;\n\t\t__entry->len\t= len;\n\t\t__entry->rw\t= rw;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu pos %lld len %lu rw %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->pos, __entry->len, __entry->rw)\n);\n\nTRACE_EVENT(ext4_direct_IO_exit,\n\tTP_PROTO(struct inode *inode, loff_t offset, unsigned long len,\n\t\t int rw, int ret),\n\n\tTP_ARGS(inode, offset, len, rw, ret),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tloff_t,\tpos\t\t\t)\n\t\t__field(\tunsigned long,\tlen\t\t)\n\t\t__field(\tint,\trw\t\t\t)\n\t\t__field(\tint,\tret\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->pos\t= offset;\n\t\t__entry->len\t= len;\n\t\t__entry->rw\t= rw;\n\t\t__entry->ret\t= ret;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu pos %lld len %lu rw %d ret %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->pos, __entry->len,\n\t\t  __entry->rw, __entry->ret)\n);\n\nDECLARE_EVENT_CLASS(ext4__fallocate_mode,\n\tTP_PROTO(struct inode *inode, loff_t offset, loff_t len, int mode),\n\n\tTP_ARGS(inode, offset, len, mode),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tloff_t,\toffset\t\t\t)\n\t\t__field(\tloff_t, len\t\t\t)\n\t\t__field(\tint,\tmode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->offset\t= offset;\n\t\t__entry->len\t= len;\n\t\t__entry->mode\t= mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu offset %lld len %lld mode %s\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->offset, __entry->len,\n\t\t  show_falloc_mode(__entry->mode))\n);\n\nDEFINE_EVENT(ext4__fallocate_mode, ext4_fallocate_enter,\n\n\tTP_PROTO(struct inode *inode, loff_t offset, loff_t len, int mode),\n\n\tTP_ARGS(inode, offset, len, mode)\n);\n\nDEFINE_EVENT(ext4__fallocate_mode, ext4_punch_hole,\n\n\tTP_PROTO(struct inode *inode, loff_t offset, loff_t len, int mode),\n\n\tTP_ARGS(inode, offset, len, mode)\n);\n\nDEFINE_EVENT(ext4__fallocate_mode, ext4_zero_range,\n\n\tTP_PROTO(struct inode *inode, loff_t offset, loff_t len, int mode),\n\n\tTP_ARGS(inode, offset, len, mode)\n);\n\nTRACE_EVENT(ext4_fallocate_exit,\n\tTP_PROTO(struct inode *inode, loff_t offset,\n\t\t unsigned int max_blocks, int ret),\n\n\tTP_ARGS(inode, offset, max_blocks, ret),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tloff_t,\tpos\t\t\t)\n\t\t__field(\tunsigned int,\tblocks\t\t)\n\t\t__field(\tint, \tret\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->pos\t= offset;\n\t\t__entry->blocks\t= max_blocks;\n\t\t__entry->ret\t= ret;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu pos %lld blocks %u ret %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->pos, __entry->blocks,\n\t\t  __entry->ret)\n);\n\nTRACE_EVENT(ext4_unlink_enter,\n\tTP_PROTO(struct inode *parent, struct dentry *dentry),\n\n\tTP_ARGS(parent, dentry),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tino_t,\tparent\t\t\t)\n\t\t__field(\tloff_t,\tsize\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= dentry->d_sb->s_dev;\n\t\t__entry->ino\t\t= d_inode(dentry)->i_ino;\n\t\t__entry->parent\t\t= parent->i_ino;\n\t\t__entry->size\t\t= d_inode(dentry)->i_size;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu size %lld parent %lu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->size,\n\t\t  (unsigned long) __entry->parent)\n);\n\nTRACE_EVENT(ext4_unlink_exit,\n\tTP_PROTO(struct dentry *dentry, int ret),\n\n\tTP_ARGS(dentry, ret),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tint,\tret\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= dentry->d_sb->s_dev;\n\t\t__entry->ino\t\t= d_inode(dentry)->i_ino;\n\t\t__entry->ret\t\t= ret;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu ret %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->ret)\n);\n\nDECLARE_EVENT_CLASS(ext4__truncate,\n\tTP_PROTO(struct inode *inode),\n\n\tTP_ARGS(inode),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\t__u64,\t\tblocks\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev    = inode->i_sb->s_dev;\n\t\t__entry->ino    = inode->i_ino;\n\t\t__entry->blocks\t= inode->i_blocks;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu blocks %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->blocks)\n);\n\nDEFINE_EVENT(ext4__truncate, ext4_truncate_enter,\n\n\tTP_PROTO(struct inode *inode),\n\n\tTP_ARGS(inode)\n);\n\nDEFINE_EVENT(ext4__truncate, ext4_truncate_exit,\n\n\tTP_PROTO(struct inode *inode),\n\n\tTP_ARGS(inode)\n);\n\n/* 'ux' is the unwritten extent. */\nTRACE_EVENT(ext4_ext_convert_to_initialized_enter,\n\tTP_PROTO(struct inode *inode, struct ext4_map_blocks *map,\n\t\t struct ext4_extent *ux),\n\n\tTP_ARGS(inode, map, ux),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_lblk_t,\tm_lblk\t)\n\t\t__field(\tunsigned,\tm_len\t)\n\t\t__field(\text4_lblk_t,\tu_lblk\t)\n\t\t__field(\tunsigned,\tu_len\t)\n\t\t__field(\text4_fsblk_t,\tu_pblk\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->m_lblk\t\t= map->m_lblk;\n\t\t__entry->m_len\t\t= map->m_len;\n\t\t__entry->u_lblk\t\t= le32_to_cpu(ux->ee_block);\n\t\t__entry->u_len\t\t= ext4_ext_get_actual_len(ux);\n\t\t__entry->u_pblk\t\t= ext4_ext_pblock(ux);\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu m_lblk %u m_len %u u_lblk %u u_len %u \"\n\t\t  \"u_pblk %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->m_lblk, __entry->m_len,\n\t\t  __entry->u_lblk, __entry->u_len, __entry->u_pblk)\n);\n\n/*\n * 'ux' is the unwritten extent.\n * 'ix' is the initialized extent to which blocks are transferred.\n */\nTRACE_EVENT(ext4_ext_convert_to_initialized_fastpath,\n\tTP_PROTO(struct inode *inode, struct ext4_map_blocks *map,\n\t\t struct ext4_extent *ux, struct ext4_extent *ix),\n\n\tTP_ARGS(inode, map, ux, ix),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_lblk_t,\tm_lblk\t)\n\t\t__field(\tunsigned,\tm_len\t)\n\t\t__field(\text4_lblk_t,\tu_lblk\t)\n\t\t__field(\tunsigned,\tu_len\t)\n\t\t__field(\text4_fsblk_t,\tu_pblk\t)\n\t\t__field(\text4_lblk_t,\ti_lblk\t)\n\t\t__field(\tunsigned,\ti_len\t)\n\t\t__field(\text4_fsblk_t,\ti_pblk\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->m_lblk\t\t= map->m_lblk;\n\t\t__entry->m_len\t\t= map->m_len;\n\t\t__entry->u_lblk\t\t= le32_to_cpu(ux->ee_block);\n\t\t__entry->u_len\t\t= ext4_ext_get_actual_len(ux);\n\t\t__entry->u_pblk\t\t= ext4_ext_pblock(ux);\n\t\t__entry->i_lblk\t\t= le32_to_cpu(ix->ee_block);\n\t\t__entry->i_len\t\t= ext4_ext_get_actual_len(ix);\n\t\t__entry->i_pblk\t\t= ext4_ext_pblock(ix);\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu m_lblk %u m_len %u \"\n\t\t  \"u_lblk %u u_len %u u_pblk %llu \"\n\t\t  \"i_lblk %u i_len %u i_pblk %llu \",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->m_lblk, __entry->m_len,\n\t\t  __entry->u_lblk, __entry->u_len, __entry->u_pblk,\n\t\t  __entry->i_lblk, __entry->i_len, __entry->i_pblk)\n);\n\nDECLARE_EVENT_CLASS(ext4__map_blocks_enter,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk,\n\t\t unsigned int len, unsigned int flags),\n\n\tTP_ARGS(inode, lblk, len, flags),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t\t__field(\tunsigned int,\tlen\t\t)\n\t\t__field(\tunsigned int,\tflags\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev    = inode->i_sb->s_dev;\n\t\t__entry->ino    = inode->i_ino;\n\t\t__entry->lblk\t= lblk;\n\t\t__entry->len\t= len;\n\t\t__entry->flags\t= flags;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu lblk %u len %u flags %s\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->lblk, __entry->len, show_map_flags(__entry->flags))\n);\n\nDEFINE_EVENT(ext4__map_blocks_enter, ext4_ext_map_blocks_enter,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk,\n\t\t unsigned len, unsigned flags),\n\n\tTP_ARGS(inode, lblk, len, flags)\n);\n\nDEFINE_EVENT(ext4__map_blocks_enter, ext4_ind_map_blocks_enter,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk,\n\t\t unsigned len, unsigned flags),\n\n\tTP_ARGS(inode, lblk, len, flags)\n);\n\nDECLARE_EVENT_CLASS(ext4__map_blocks_exit,\n\tTP_PROTO(struct inode *inode, unsigned flags, struct ext4_map_blocks *map,\n\t\t int ret),\n\n\tTP_ARGS(inode, flags, map, ret),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\tunsigned int,\tflags\t\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t\t__field(\tunsigned int,\tlen\t\t)\n\t\t__field(\tunsigned int,\tmflags\t\t)\n\t\t__field(\tint,\t\tret\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev    = inode->i_sb->s_dev;\n\t\t__entry->ino    = inode->i_ino;\n\t\t__entry->flags\t= flags;\n\t\t__entry->pblk\t= map->m_pblk;\n\t\t__entry->lblk\t= map->m_lblk;\n\t\t__entry->len\t= map->m_len;\n\t\t__entry->mflags\t= map->m_flags;\n\t\t__entry->ret\t= ret;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu flags %s lblk %u pblk %llu len %u \"\n\t\t  \"mflags %s ret %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  show_map_flags(__entry->flags), __entry->lblk, __entry->pblk,\n\t\t  __entry->len, show_mflags(__entry->mflags), __entry->ret)\n);\n\nDEFINE_EVENT(ext4__map_blocks_exit, ext4_ext_map_blocks_exit,\n\tTP_PROTO(struct inode *inode, unsigned flags,\n\t\t struct ext4_map_blocks *map, int ret),\n\n\tTP_ARGS(inode, flags, map, ret)\n);\n\nDEFINE_EVENT(ext4__map_blocks_exit, ext4_ind_map_blocks_exit,\n\tTP_PROTO(struct inode *inode, unsigned flags,\n\t\t struct ext4_map_blocks *map, int ret),\n\n\tTP_ARGS(inode, flags, map, ret)\n);\n\nTRACE_EVENT(ext4_ext_load_extent,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk, ext4_fsblk_t pblk),\n\n\tTP_ARGS(inode, lblk, pblk),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev    = inode->i_sb->s_dev;\n\t\t__entry->ino    = inode->i_ino;\n\t\t__entry->pblk\t= pblk;\n\t\t__entry->lblk\t= lblk;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu lblk %u pblk %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->lblk, __entry->pblk)\n);\n\nTRACE_EVENT(ext4_load_inode,\n\tTP_PROTO(struct super_block *sb, unsigned long ino),\n\n\tTP_ARGS(sb, ino),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t)\n\t\t__field(\tino_t,\tino\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= sb->s_dev;\n\t\t__entry->ino\t\t= ino;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %ld\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino)\n);\n\nTRACE_EVENT(ext4_journal_start,\n\tTP_PROTO(struct super_block *sb, int blocks, int rsv_blocks,\n\t\t int revoke_creds, unsigned long IP),\n\n\tTP_ARGS(sb, blocks, rsv_blocks, revoke_creds, IP),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(unsigned long,\tip\t\t\t)\n\t\t__field(\t  int,\tblocks\t\t\t)\n\t\t__field(\t  int,\trsv_blocks\t\t)\n\t\t__field(\t  int,\trevoke_creds\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t = sb->s_dev;\n\t\t__entry->ip\t\t = IP;\n\t\t__entry->blocks\t\t = blocks;\n\t\t__entry->rsv_blocks\t = rsv_blocks;\n\t\t__entry->revoke_creds\t = revoke_creds;\n\t),\n\n\tTP_printk(\"dev %d,%d blocks %d, rsv_blocks %d, revoke_creds %d, \"\n\t\t  \"caller %pS\", MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->blocks, __entry->rsv_blocks, __entry->revoke_creds,\n\t\t  (void *)__entry->ip)\n);\n\nTRACE_EVENT(ext4_journal_start_reserved,\n\tTP_PROTO(struct super_block *sb, int blocks, unsigned long IP),\n\n\tTP_ARGS(sb, blocks, IP),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(unsigned long,\tip\t\t\t)\n\t\t__field(\t  int,\tblocks\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t = sb->s_dev;\n\t\t__entry->ip\t\t = IP;\n\t\t__entry->blocks\t\t = blocks;\n\t),\n\n\tTP_printk(\"dev %d,%d blocks, %d caller %pS\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->blocks, (void *)__entry->ip)\n);\n\nDECLARE_EVENT_CLASS(ext4__trim,\n\tTP_PROTO(struct super_block *sb,\n\t\t ext4_group_t group,\n\t\t ext4_grpblk_t start,\n\t\t ext4_grpblk_t len),\n\n\tTP_ARGS(sb, group, start, len),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tint,\tdev_major\t\t)\n\t\t__field(\tint,\tdev_minor\t\t)\n\t\t__field(\t__u32, \tgroup\t\t\t)\n\t\t__field(\tint,\tstart\t\t\t)\n\t\t__field(\tint,\tlen\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev_major\t= MAJOR(sb->s_dev);\n\t\t__entry->dev_minor\t= MINOR(sb->s_dev);\n\t\t__entry->group\t\t= group;\n\t\t__entry->start\t\t= start;\n\t\t__entry->len\t\t= len;\n\t),\n\n\tTP_printk(\"dev %d,%d group %u, start %d, len %d\",\n\t\t  __entry->dev_major, __entry->dev_minor,\n\t\t  __entry->group, __entry->start, __entry->len)\n);\n\nDEFINE_EVENT(ext4__trim, ext4_trim_extent,\n\n\tTP_PROTO(struct super_block *sb,\n\t\t ext4_group_t group,\n\t\t ext4_grpblk_t start,\n\t\t ext4_grpblk_t len),\n\n\tTP_ARGS(sb, group, start, len)\n);\n\nDEFINE_EVENT(ext4__trim, ext4_trim_all_free,\n\n\tTP_PROTO(struct super_block *sb,\n\t\t ext4_group_t group,\n\t\t ext4_grpblk_t start,\n\t\t ext4_grpblk_t len),\n\n\tTP_ARGS(sb, group, start, len)\n);\n\nTRACE_EVENT(ext4_ext_handle_unwritten_extents,\n\tTP_PROTO(struct inode *inode, struct ext4_map_blocks *map, int flags,\n\t\t unsigned int allocated, ext4_fsblk_t newblock),\n\n\tTP_ARGS(inode, map, flags, allocated, newblock),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\tint,\t\tflags\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t\t)\n\t\t__field(\tunsigned int,\tlen\t\t)\n\t\t__field(\tunsigned int,\tallocated\t)\n\t\t__field(\text4_fsblk_t,\tnewblk\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->flags\t\t= flags;\n\t\t__entry->lblk\t\t= map->m_lblk;\n\t\t__entry->pblk\t\t= map->m_pblk;\n\t\t__entry->len\t\t= map->m_len;\n\t\t__entry->allocated\t= allocated;\n\t\t__entry->newblk\t\t= newblock;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu m_lblk %u m_pblk %llu m_len %u flags %s \"\n\t\t  \"allocated %d newblock %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->lblk, (unsigned long long) __entry->pblk,\n\t\t  __entry->len, show_map_flags(__entry->flags),\n\t\t  (unsigned int) __entry->allocated,\n\t\t  (unsigned long long) __entry->newblk)\n);\n\nTRACE_EVENT(ext4_get_implied_cluster_alloc_exit,\n\tTP_PROTO(struct super_block *sb, struct ext4_map_blocks *map, int ret),\n\n\tTP_ARGS(sb, map, ret),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tunsigned int,\tflags\t)\n\t\t__field(\text4_lblk_t,\tlblk\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t)\n\t\t__field(\tunsigned int,\tlen\t)\n\t\t__field(\tint,\t\tret\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->flags\t= map->m_flags;\n\t\t__entry->lblk\t= map->m_lblk;\n\t\t__entry->pblk\t= map->m_pblk;\n\t\t__entry->len\t= map->m_len;\n\t\t__entry->ret\t= ret;\n\t),\n\n\tTP_printk(\"dev %d,%d m_lblk %u m_pblk %llu m_len %u m_flags %s ret %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->lblk, (unsigned long long) __entry->pblk,\n\t\t  __entry->len, show_mflags(__entry->flags), __entry->ret)\n);\n\nTRACE_EVENT(ext4_ext_put_in_cache,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk, unsigned int len,\n\t\t ext4_fsblk_t start),\n\n\tTP_ARGS(inode, lblk, len, start),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_lblk_t,\tlblk\t)\n\t\t__field(\tunsigned int,\tlen\t)\n\t\t__field(\text4_fsblk_t,\tstart\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->lblk\t= lblk;\n\t\t__entry->len\t= len;\n\t\t__entry->start\t= start;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu lblk %u len %u start %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->lblk,\n\t\t  __entry->len,\n\t\t  (unsigned long long) __entry->start)\n);\n\nTRACE_EVENT(ext4_ext_in_cache,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk, int ret),\n\n\tTP_ARGS(inode, lblk, ret),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_lblk_t,\tlblk\t)\n\t\t__field(\tint,\t\tret\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->lblk\t= lblk;\n\t\t__entry->ret\t= ret;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu lblk %u ret %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->lblk,\n\t\t  __entry->ret)\n\n);\n\nTRACE_EVENT(ext4_find_delalloc_range,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t from, ext4_lblk_t to,\n\t\tint reverse, int found, ext4_lblk_t found_blk),\n\n\tTP_ARGS(inode, from, to, reverse, found, found_blk),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_lblk_t,\tfrom\t\t)\n\t\t__field(\text4_lblk_t,\tto\t\t)\n\t\t__field(\tint,\t\treverse\t\t)\n\t\t__field(\tint,\t\tfound\t\t)\n\t\t__field(\text4_lblk_t,\tfound_blk\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->from\t\t= from;\n\t\t__entry->to\t\t= to;\n\t\t__entry->reverse\t= reverse;\n\t\t__entry->found\t\t= found;\n\t\t__entry->found_blk\t= found_blk;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu from %u to %u reverse %d found %d \"\n\t\t  \"(blk = %u)\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->from, (unsigned) __entry->to,\n\t\t  __entry->reverse, __entry->found,\n\t\t  (unsigned) __entry->found_blk)\n);\n\nTRACE_EVENT(ext4_get_reserved_cluster_alloc,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk, unsigned int len),\n\n\tTP_ARGS(inode, lblk, len),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_lblk_t,\tlblk\t)\n\t\t__field(\tunsigned int,\tlen\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->lblk\t= lblk;\n\t\t__entry->len\t= len;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu lblk %u len %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->lblk,\n\t\t  __entry->len)\n);\n\nTRACE_EVENT(ext4_ext_show_extent,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk, ext4_fsblk_t pblk,\n\t\t unsigned short len),\n\n\tTP_ARGS(inode, lblk, pblk, len),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t)\n\t\t__field(\text4_lblk_t,\tlblk\t)\n\t\t__field(\tunsigned short,\tlen\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->pblk\t= pblk;\n\t\t__entry->lblk\t= lblk;\n\t\t__entry->len\t= len;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu lblk %u pblk %llu len %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->lblk,\n\t\t  (unsigned long long) __entry->pblk,\n\t\t  (unsigned short) __entry->len)\n);\n\nTRACE_EVENT(ext4_remove_blocks,\n\tTP_PROTO(struct inode *inode, struct ext4_extent *ex,\n\t\t ext4_lblk_t from, ext4_fsblk_t to,\n\t\t struct partial_cluster *pc),\n\n\tTP_ARGS(inode, ex, from, to, pc),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_lblk_t,\tfrom\t)\n\t\t__field(\text4_lblk_t,\tto\t)\n\t\t__field(\text4_fsblk_t,\tee_pblk\t)\n\t\t__field(\text4_lblk_t,\tee_lblk\t)\n\t\t__field(\tunsigned short,\tee_len\t)\n\t\t__field(\text4_fsblk_t,\tpc_pclu\t)\n\t\t__field(\text4_lblk_t,\tpc_lblk\t)\n\t\t__field(\tint,\t\tpc_state)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->from\t\t= from;\n\t\t__entry->to\t\t= to;\n\t\t__entry->ee_pblk\t= ext4_ext_pblock(ex);\n\t\t__entry->ee_lblk\t= le32_to_cpu(ex->ee_block);\n\t\t__entry->ee_len\t\t= ext4_ext_get_actual_len(ex);\n\t\t__entry->pc_pclu\t= pc->pclu;\n\t\t__entry->pc_lblk\t= pc->lblk;\n\t\t__entry->pc_state\t= pc->state;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu extent [%u(%llu), %u]\"\n\t\t  \"from %u to %u partial [pclu %lld lblk %u state %d]\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->ee_lblk,\n\t\t  (unsigned long long) __entry->ee_pblk,\n\t\t  (unsigned short) __entry->ee_len,\n\t\t  (unsigned) __entry->from,\n\t\t  (unsigned) __entry->to,\n\t\t  (long long) __entry->pc_pclu,\n\t\t  (unsigned int) __entry->pc_lblk,\n\t\t  (int) __entry->pc_state)\n);\n\nTRACE_EVENT(ext4_ext_rm_leaf,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t start,\n\t\t struct ext4_extent *ex,\n\t\t struct partial_cluster *pc),\n\n\tTP_ARGS(inode, start, ex, pc),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_lblk_t,\tstart\t)\n\t\t__field(\text4_lblk_t,\tee_lblk\t)\n\t\t__field(\text4_fsblk_t,\tee_pblk\t)\n\t\t__field(\tshort,\t\tee_len\t)\n\t\t__field(\text4_fsblk_t,\tpc_pclu\t)\n\t\t__field(\text4_lblk_t,\tpc_lblk\t)\n\t\t__field(\tint,\t\tpc_state)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->start\t\t= start;\n\t\t__entry->ee_lblk\t= le32_to_cpu(ex->ee_block);\n\t\t__entry->ee_pblk\t= ext4_ext_pblock(ex);\n\t\t__entry->ee_len\t\t= ext4_ext_get_actual_len(ex);\n\t\t__entry->pc_pclu\t= pc->pclu;\n\t\t__entry->pc_lblk\t= pc->lblk;\n\t\t__entry->pc_state\t= pc->state;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu start_lblk %u last_extent [%u(%llu), %u]\"\n\t\t  \"partial [pclu %lld lblk %u state %d]\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->start,\n\t\t  (unsigned) __entry->ee_lblk,\n\t\t  (unsigned long long) __entry->ee_pblk,\n\t\t  (unsigned short) __entry->ee_len,\n\t\t  (long long) __entry->pc_pclu,\n\t\t  (unsigned int) __entry->pc_lblk,\n\t\t  (int) __entry->pc_state)\n);\n\nTRACE_EVENT(ext4_ext_rm_idx,\n\tTP_PROTO(struct inode *inode, ext4_fsblk_t pblk),\n\n\tTP_ARGS(inode, pblk),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->pblk\t= pblk;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu index_pblk %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned long long) __entry->pblk)\n);\n\nTRACE_EVENT(ext4_ext_remove_space,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t start,\n\t\t ext4_lblk_t end, int depth),\n\n\tTP_ARGS(inode, start, end, depth),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_lblk_t,\tstart\t)\n\t\t__field(\text4_lblk_t,\tend\t)\n\t\t__field(\tint,\t\tdepth\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->start\t= start;\n\t\t__entry->end\t= end;\n\t\t__entry->depth\t= depth;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu since %u end %u depth %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->start,\n\t\t  (unsigned) __entry->end,\n\t\t  __entry->depth)\n);\n\nTRACE_EVENT(ext4_ext_remove_space_done,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t start, ext4_lblk_t end,\n\t\t int depth, struct partial_cluster *pc, __le16 eh_entries),\n\n\tTP_ARGS(inode, start, end, depth, pc, eh_entries),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_lblk_t,\tstart\t\t)\n\t\t__field(\text4_lblk_t,\tend\t\t)\n\t\t__field(\tint,\t\tdepth\t\t)\n\t\t__field(\text4_fsblk_t,\tpc_pclu\t\t)\n\t\t__field(\text4_lblk_t,\tpc_lblk\t\t)\n\t\t__field(\tint,\t\tpc_state\t)\n\t\t__field(\tunsigned short,\teh_entries\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->start\t\t= start;\n\t\t__entry->end\t\t= end;\n\t\t__entry->depth\t\t= depth;\n\t\t__entry->pc_pclu\t= pc->pclu;\n\t\t__entry->pc_lblk\t= pc->lblk;\n\t\t__entry->pc_state\t= pc->state;\n\t\t__entry->eh_entries\t= le16_to_cpu(eh_entries);\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu since %u end %u depth %d \"\n\t\t  \"partial [pclu %lld lblk %u state %d] \"\n\t\t  \"remaining_entries %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->start,\n\t\t  (unsigned) __entry->end,\n\t\t  __entry->depth,\n\t\t  (long long) __entry->pc_pclu,\n\t\t  (unsigned int) __entry->pc_lblk,\n\t\t  (int) __entry->pc_state,\n\t\t  (unsigned short) __entry->eh_entries)\n);\n\nDECLARE_EVENT_CLASS(ext4__es_extent,\n\tTP_PROTO(struct inode *inode, struct extent_status *es),\n\n\tTP_ARGS(inode, es),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t\t__field(\text4_lblk_t,\tlen\t\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t\t)\n\t\t__field(\tchar, status\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->lblk\t= es->es_lblk;\n\t\t__entry->len\t= es->es_len;\n\t\t__entry->pblk\t= ext4_es_show_pblock(es);\n\t\t__entry->status\t= ext4_es_status(es);\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu es [%u/%u) mapped %llu status %s\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->lblk, __entry->len,\n\t\t  __entry->pblk, show_extent_status(__entry->status))\n);\n\nDEFINE_EVENT(ext4__es_extent, ext4_es_insert_extent,\n\tTP_PROTO(struct inode *inode, struct extent_status *es),\n\n\tTP_ARGS(inode, es)\n);\n\nDEFINE_EVENT(ext4__es_extent, ext4_es_cache_extent,\n\tTP_PROTO(struct inode *inode, struct extent_status *es),\n\n\tTP_ARGS(inode, es)\n);\n\nTRACE_EVENT(ext4_es_remove_extent,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t len),\n\n\tTP_ARGS(inode, lblk, len),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tloff_t,\tlblk\t\t\t)\n\t\t__field(\tloff_t,\tlen\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->lblk\t= lblk;\n\t\t__entry->len\t= len;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu es [%lld/%lld)\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->lblk, __entry->len)\n);\n\nTRACE_EVENT(ext4_es_find_extent_range_enter,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk),\n\n\tTP_ARGS(inode, lblk),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->lblk\t= lblk;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu lblk %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->lblk)\n);\n\nTRACE_EVENT(ext4_es_find_extent_range_exit,\n\tTP_PROTO(struct inode *inode, struct extent_status *es),\n\n\tTP_ARGS(inode, es),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t\t__field(\text4_lblk_t,\tlen\t\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t\t)\n\t\t__field(\tchar, status\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->lblk\t= es->es_lblk;\n\t\t__entry->len\t= es->es_len;\n\t\t__entry->pblk\t= ext4_es_show_pblock(es);\n\t\t__entry->status\t= ext4_es_status(es);\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu es [%u/%u) mapped %llu status %s\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->lblk, __entry->len,\n\t\t  __entry->pblk, show_extent_status(__entry->status))\n);\n\nTRACE_EVENT(ext4_es_lookup_extent_enter,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk),\n\n\tTP_ARGS(inode, lblk),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->lblk\t= lblk;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu lblk %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->lblk)\n);\n\nTRACE_EVENT(ext4_es_lookup_extent_exit,\n\tTP_PROTO(struct inode *inode, struct extent_status *es,\n\t\t int found),\n\n\tTP_ARGS(inode, es, found),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t\t__field(\text4_lblk_t,\tlen\t\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t\t)\n\t\t__field(\tchar,\t\tstatus\t\t)\n\t\t__field(\tint,\t\tfound\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->lblk\t= es->es_lblk;\n\t\t__entry->len\t= es->es_len;\n\t\t__entry->pblk\t= ext4_es_show_pblock(es);\n\t\t__entry->status\t= ext4_es_status(es);\n\t\t__entry->found\t= found;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu found %d [%u/%u) %llu %s\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->found,\n\t\t  __entry->lblk, __entry->len,\n\t\t  __entry->found ? __entry->pblk : 0,\n\t\t  show_extent_status(__entry->found ? __entry->status : 0))\n);\n\nDECLARE_EVENT_CLASS(ext4__es_shrink_enter,\n\tTP_PROTO(struct super_block *sb, int nr_to_scan, int cache_cnt),\n\n\tTP_ARGS(sb, nr_to_scan, cache_cnt),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tint,\tnr_to_scan\t\t)\n\t\t__field(\tint,\tcache_cnt\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= sb->s_dev;\n\t\t__entry->nr_to_scan\t= nr_to_scan;\n\t\t__entry->cache_cnt\t= cache_cnt;\n\t),\n\n\tTP_printk(\"dev %d,%d nr_to_scan %d cache_cnt %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->nr_to_scan, __entry->cache_cnt)\n);\n\nDEFINE_EVENT(ext4__es_shrink_enter, ext4_es_shrink_count,\n\tTP_PROTO(struct super_block *sb, int nr_to_scan, int cache_cnt),\n\n\tTP_ARGS(sb, nr_to_scan, cache_cnt)\n);\n\nDEFINE_EVENT(ext4__es_shrink_enter, ext4_es_shrink_scan_enter,\n\tTP_PROTO(struct super_block *sb, int nr_to_scan, int cache_cnt),\n\n\tTP_ARGS(sb, nr_to_scan, cache_cnt)\n);\n\nTRACE_EVENT(ext4_es_shrink_scan_exit,\n\tTP_PROTO(struct super_block *sb, int nr_shrunk, int cache_cnt),\n\n\tTP_ARGS(sb, nr_shrunk, cache_cnt),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tint,\tnr_shrunk\t\t)\n\t\t__field(\tint,\tcache_cnt\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= sb->s_dev;\n\t\t__entry->nr_shrunk\t= nr_shrunk;\n\t\t__entry->cache_cnt\t= cache_cnt;\n\t),\n\n\tTP_printk(\"dev %d,%d nr_shrunk %d cache_cnt %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->nr_shrunk, __entry->cache_cnt)\n);\n\nTRACE_EVENT(ext4_collapse_range,\n\tTP_PROTO(struct inode *inode, loff_t offset, loff_t len),\n\n\tTP_ARGS(inode, offset, len),\n\n\tTP_STRUCT__entry(\n\t\t__field(dev_t,\tdev)\n\t\t__field(ino_t,\tino)\n\t\t__field(loff_t,\toffset)\n\t\t__field(loff_t, len)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->offset\t= offset;\n\t\t__entry->len\t= len;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu offset %lld len %lld\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->offset, __entry->len)\n);\n\nTRACE_EVENT(ext4_insert_range,\n\tTP_PROTO(struct inode *inode, loff_t offset, loff_t len),\n\n\tTP_ARGS(inode, offset, len),\n\n\tTP_STRUCT__entry(\n\t\t__field(dev_t,\tdev)\n\t\t__field(ino_t,\tino)\n\t\t__field(loff_t,\toffset)\n\t\t__field(loff_t, len)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->offset\t= offset;\n\t\t__entry->len\t= len;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu offset %lld len %lld\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->offset, __entry->len)\n);\n\nTRACE_EVENT(ext4_es_shrink,\n\tTP_PROTO(struct super_block *sb, int nr_shrunk, u64 scan_time,\n\t\t int nr_skipped, int retried),\n\n\tTP_ARGS(sb, nr_shrunk, scan_time, nr_skipped, retried),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tint,\t\tnr_shrunk\t)\n\t\t__field(\tunsigned long long, scan_time\t)\n\t\t__field(\tint,\t\tnr_skipped\t)\n\t\t__field(\tint,\t\tretried\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= sb->s_dev;\n\t\t__entry->nr_shrunk\t= nr_shrunk;\n\t\t__entry->scan_time\t= div_u64(scan_time, 1000);\n\t\t__entry->nr_skipped\t= nr_skipped;\n\t\t__entry->retried\t= retried;\n\t),\n\n\tTP_printk(\"dev %d,%d nr_shrunk %d, scan_time %llu \"\n\t\t  \"nr_skipped %d retried %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev), __entry->nr_shrunk,\n\t\t  __entry->scan_time, __entry->nr_skipped, __entry->retried)\n);\n\nTRACE_EVENT(ext4_es_insert_delayed_block,\n\tTP_PROTO(struct inode *inode, struct extent_status *es,\n\t\t bool allocated),\n\n\tTP_ARGS(inode, es, allocated),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t\t__field(\text4_lblk_t,\tlen\t\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t\t)\n\t\t__field(\tchar,\t\tstatus\t\t)\n\t\t__field(\tbool,\t\tallocated\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->lblk\t\t= es->es_lblk;\n\t\t__entry->len\t\t= es->es_len;\n\t\t__entry->pblk\t\t= ext4_es_show_pblock(es);\n\t\t__entry->status\t\t= ext4_es_status(es);\n\t\t__entry->allocated\t= allocated;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu es [%u/%u) mapped %llu status %s \"\n\t\t  \"allocated %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->lblk, __entry->len,\n\t\t  __entry->pblk, show_extent_status(__entry->status),\n\t\t  __entry->allocated)\n);\n\n/* fsmap traces */\nDECLARE_EVENT_CLASS(ext4_fsmap_class,\n\tTP_PROTO(struct super_block *sb, u32 keydev, u32 agno, u64 bno, u64 len,\n\t\t u64 owner),\n\tTP_ARGS(sb, keydev, agno, bno, len, owner),\n\tTP_STRUCT__entry(\n\t\t__field(dev_t, dev)\n\t\t__field(dev_t, keydev)\n\t\t__field(u32, agno)\n\t\t__field(u64, bno)\n\t\t__field(u64, len)\n\t\t__field(u64, owner)\n\t),\n\tTP_fast_assign(\n\t\t__entry->dev = sb->s_bdev->bd_dev;\n\t\t__entry->keydev = new_decode_dev(keydev);\n\t\t__entry->agno = agno;\n\t\t__entry->bno = bno;\n\t\t__entry->len = len;\n\t\t__entry->owner = owner;\n\t),\n\tTP_printk(\"dev %d:%d keydev %d:%d agno %u bno %llu len %llu owner %lld\\n\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  MAJOR(__entry->keydev), MINOR(__entry->keydev),\n\t\t  __entry->agno,\n\t\t  __entry->bno,\n\t\t  __entry->len,\n\t\t  __entry->owner)\n)\n#define DEFINE_FSMAP_EVENT(name) \\\nDEFINE_EVENT(ext4_fsmap_class, name, \\\n\tTP_PROTO(struct super_block *sb, u32 keydev, u32 agno, u64 bno, u64 len, \\\n\t\t u64 owner), \\\n\tTP_ARGS(sb, keydev, agno, bno, len, owner))\nDEFINE_FSMAP_EVENT(ext4_fsmap_low_key);\nDEFINE_FSMAP_EVENT(ext4_fsmap_high_key);\nDEFINE_FSMAP_EVENT(ext4_fsmap_mapping);\n\nDECLARE_EVENT_CLASS(ext4_getfsmap_class,\n\tTP_PROTO(struct super_block *sb, struct ext4_fsmap *fsmap),\n\tTP_ARGS(sb, fsmap),\n\tTP_STRUCT__entry(\n\t\t__field(dev_t, dev)\n\t\t__field(dev_t, keydev)\n\t\t__field(u64, block)\n\t\t__field(u64, len)\n\t\t__field(u64, owner)\n\t\t__field(u64, flags)\n\t),\n\tTP_fast_assign(\n\t\t__entry->dev = sb->s_bdev->bd_dev;\n\t\t__entry->keydev = new_decode_dev(fsmap->fmr_device);\n\t\t__entry->block = fsmap->fmr_physical;\n\t\t__entry->len = fsmap->fmr_length;\n\t\t__entry->owner = fsmap->fmr_owner;\n\t\t__entry->flags = fsmap->fmr_flags;\n\t),\n\tTP_printk(\"dev %d:%d keydev %d:%d block %llu len %llu owner %lld flags 0x%llx\\n\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  MAJOR(__entry->keydev), MINOR(__entry->keydev),\n\t\t  __entry->block,\n\t\t  __entry->len,\n\t\t  __entry->owner,\n\t\t  __entry->flags)\n)\n#define DEFINE_GETFSMAP_EVENT(name) \\\nDEFINE_EVENT(ext4_getfsmap_class, name, \\\n\tTP_PROTO(struct super_block *sb, struct ext4_fsmap *fsmap), \\\n\tTP_ARGS(sb, fsmap))\nDEFINE_GETFSMAP_EVENT(ext4_getfsmap_low_key);\nDEFINE_GETFSMAP_EVENT(ext4_getfsmap_high_key);\nDEFINE_GETFSMAP_EVENT(ext4_getfsmap_mapping);\n\nTRACE_EVENT(ext4_shutdown,\n\tTP_PROTO(struct super_block *sb, unsigned long flags),\n\n\tTP_ARGS(sb, flags),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(     unsigned,\tflags\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->flags\t= flags;\n\t),\n\n\tTP_printk(\"dev %d,%d flags %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->flags)\n);\n\nTRACE_EVENT(ext4_error,\n\tTP_PROTO(struct super_block *sb, const char *function,\n\t\t unsigned int line),\n\n\tTP_ARGS(sb, function, line),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field( const char *,\tfunction\t\t)\n\t\t__field(     unsigned,\tline\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->function = function;\n\t\t__entry->line\t= line;\n\t),\n\n\tTP_printk(\"dev %d,%d function %s line %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->function, __entry->line)\n);\n\nTRACE_EVENT(ext4_prefetch_bitmaps,\n\t    TP_PROTO(struct super_block *sb, ext4_group_t group,\n\t\t     ext4_group_t next, unsigned int prefetch_ios),\n\n\tTP_ARGS(sb, group, next, prefetch_ios),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\t__u32,\tgroup\t\t\t)\n\t\t__field(\t__u32,\tnext\t\t\t)\n\t\t__field(\t__u32,\tios\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->group\t= group;\n\t\t__entry->next\t= next;\n\t\t__entry->ios\t= prefetch_ios;\n\t),\n\n\tTP_printk(\"dev %d,%d group %u next %u ios %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->group, __entry->next, __entry->ios)\n);\n\nTRACE_EVENT(ext4_lazy_itable_init,\n\t    TP_PROTO(struct super_block *sb, ext4_group_t group),\n\n\tTP_ARGS(sb, group),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\t__u32,\tgroup\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->group\t= group;\n\t),\n\n\tTP_printk(\"dev %d,%d group %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev), __entry->group)\n);\n\nTRACE_EVENT(ext4_fc_replay_scan,\n\tTP_PROTO(struct super_block *sb, int error, int off),\n\n\tTP_ARGS(sb, error, off),\n\n\tTP_STRUCT__entry(\n\t\t__field(dev_t, dev)\n\t\t__field(int, error)\n\t\t__field(int, off)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev = sb->s_dev;\n\t\t__entry->error = error;\n\t\t__entry->off = off;\n\t),\n\n\tTP_printk(\"FC scan pass on dev %d,%d: error %d, off %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->error, __entry->off)\n);\n\nTRACE_EVENT(ext4_fc_replay,\n\tTP_PROTO(struct super_block *sb, int tag, int ino, int priv1, int priv2),\n\n\tTP_ARGS(sb, tag, ino, priv1, priv2),\n\n\tTP_STRUCT__entry(\n\t\t__field(dev_t, dev)\n\t\t__field(int, tag)\n\t\t__field(int, ino)\n\t\t__field(int, priv1)\n\t\t__field(int, priv2)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev = sb->s_dev;\n\t\t__entry->tag = tag;\n\t\t__entry->ino = ino;\n\t\t__entry->priv1 = priv1;\n\t\t__entry->priv2 = priv2;\n\t),\n\n\tTP_printk(\"FC Replay %d,%d: tag %d, ino %d, data1 %d, data2 %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->tag, __entry->ino, __entry->priv1, __entry->priv2)\n);\n\nTRACE_EVENT(ext4_fc_commit_start,\n\tTP_PROTO(struct super_block *sb),\n\n\tTP_ARGS(sb),\n\n\tTP_STRUCT__entry(\n\t\t__field(dev_t, dev)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev = sb->s_dev;\n\t),\n\n\tTP_printk(\"fast_commit started on dev %d,%d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev))\n);\n\nTRACE_EVENT(ext4_fc_commit_stop,\n\t    TP_PROTO(struct super_block *sb, int nblks, int reason),\n\n\tTP_ARGS(sb, nblks, reason),\n\n\tTP_STRUCT__entry(\n\t\t__field(dev_t, dev)\n\t\t__field(int, nblks)\n\t\t__field(int, reason)\n\t\t__field(int, num_fc)\n\t\t__field(int, num_fc_ineligible)\n\t\t__field(int, nblks_agg)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev = sb->s_dev;\n\t\t__entry->nblks = nblks;\n\t\t__entry->reason = reason;\n\t\t__entry->num_fc = EXT4_SB(sb)->s_fc_stats.fc_num_commits;\n\t\t__entry->num_fc_ineligible =\n\t\t\tEXT4_SB(sb)->s_fc_stats.fc_ineligible_commits;\n\t\t__entry->nblks_agg = EXT4_SB(sb)->s_fc_stats.fc_numblks;\n\t),\n\n\tTP_printk(\"fc on [%d,%d] nblks %d, reason %d, fc = %d, ineligible = %d, agg_nblks %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->nblks, __entry->reason, __entry->num_fc,\n\t\t  __entry->num_fc_ineligible, __entry->nblks_agg)\n);\n\n#define FC_REASON_NAME_STAT(reason)\t\t\t\t\t\\\n\tshow_fc_reason(reason),\t\t\t\t\t\t\\\n\t__entry->sbi->s_fc_stats.fc_ineligible_reason_count[reason]\n\nTRACE_EVENT(ext4_fc_stats,\n\t    TP_PROTO(struct super_block *sb),\n\n\t    TP_ARGS(sb),\n\n\t    TP_STRUCT__entry(\n\t\t    __field(dev_t, dev)\n\t\t    __field(struct ext4_sb_info *, sbi)\n\t\t    __field(int, count)\n\t\t    ),\n\n\t    TP_fast_assign(\n\t\t    __entry->dev = sb->s_dev;\n\t\t    __entry->sbi = EXT4_SB(sb);\n\t\t    ),\n\n\t    TP_printk(\"dev %d:%d fc ineligible reasons:\\n\"\n\t\t      \"%s:%d, %s:%d, %s:%d, %s:%d, %s:%d, %s:%d, %s:%d, %s,%d; \"\n\t\t      \"num_commits:%ld, ineligible: %ld, numblks: %ld\",\n\t\t      MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t      FC_REASON_NAME_STAT(EXT4_FC_REASON_XATTR),\n\t\t      FC_REASON_NAME_STAT(EXT4_FC_REASON_CROSS_RENAME),\n\t\t      FC_REASON_NAME_STAT(EXT4_FC_REASON_JOURNAL_FLAG_CHANGE),\n\t\t      FC_REASON_NAME_STAT(EXT4_FC_REASON_MEM),\n\t\t      FC_REASON_NAME_STAT(EXT4_FC_REASON_SWAP_BOOT),\n\t\t      FC_REASON_NAME_STAT(EXT4_FC_REASON_RESIZE),\n\t\t      FC_REASON_NAME_STAT(EXT4_FC_REASON_RENAME_DIR),\n\t\t      FC_REASON_NAME_STAT(EXT4_FC_REASON_FALLOC_RANGE),\n\t\t      __entry->sbi->s_fc_stats.fc_num_commits,\n\t\t      __entry->sbi->s_fc_stats.fc_ineligible_commits,\n\t\t      __entry->sbi->s_fc_stats.fc_numblks)\n\n);\n\n#define DEFINE_TRACE_DENTRY_EVENT(__type)\t\t\t\t\\\n\tTRACE_EVENT(ext4_fc_track_##__type,\t\t\t\t\\\n\t    TP_PROTO(struct inode *inode, struct dentry *dentry, int ret), \\\n\t\t\t\t\t\t\t\t\t\\\n\t    TP_ARGS(inode, dentry, ret),\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t    TP_STRUCT__entry(\t\t\t\t\t\t\\\n\t\t    __field(dev_t, dev)\t\t\t\t\t\\\n\t\t    __field(int, ino)\t\t\t\t\t\\\n\t\t    __field(int, error)\t\t\t\t\t\\\n\t\t    ),\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t    TP_fast_assign(\t\t\t\t\t\t\\\n\t\t    __entry->dev = inode->i_sb->s_dev;\t\t\t\\\n\t\t    __entry->ino = inode->i_ino;\t\t\t\\\n\t\t    __entry->error = ret;\t\t\t\t\\\n\t\t    ),\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t    TP_printk(\"dev %d:%d, inode %d, error %d, fc_%s\",\t\t\\\n\t\t      MAJOR(__entry->dev), MINOR(__entry->dev),\t\t\\\n\t\t      __entry->ino, __entry->error,\t\t\t\\\n\t\t      #__type)\t\t\t\t\t\t\\\n\t)\n\nDEFINE_TRACE_DENTRY_EVENT(create);\nDEFINE_TRACE_DENTRY_EVENT(link);\nDEFINE_TRACE_DENTRY_EVENT(unlink);\n\nTRACE_EVENT(ext4_fc_track_inode,\n\t    TP_PROTO(struct inode *inode, int ret),\n\n\t    TP_ARGS(inode, ret),\n\n\t    TP_STRUCT__entry(\n\t\t    __field(dev_t, dev)\n\t\t    __field(int, ino)\n\t\t    __field(int, error)\n\t\t    ),\n\n\t    TP_fast_assign(\n\t\t    __entry->dev = inode->i_sb->s_dev;\n\t\t    __entry->ino = inode->i_ino;\n\t\t    __entry->error = ret;\n\t\t    ),\n\n\t    TP_printk(\"dev %d:%d, inode %d, error %d\",\n\t\t      MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t      __entry->ino, __entry->error)\n\t);\n\nTRACE_EVENT(ext4_fc_track_range,\n\t    TP_PROTO(struct inode *inode, long start, long end, int ret),\n\n\t    TP_ARGS(inode, start, end, ret),\n\n\t    TP_STRUCT__entry(\n\t\t    __field(dev_t, dev)\n\t\t    __field(int, ino)\n\t\t    __field(long, start)\n\t\t    __field(long, end)\n\t\t    __field(int, error)\n\t\t    ),\n\n\t    TP_fast_assign(\n\t\t    __entry->dev = inode->i_sb->s_dev;\n\t\t    __entry->ino = inode->i_ino;\n\t\t    __entry->start = start;\n\t\t    __entry->end = end;\n\t\t    __entry->error = ret;\n\t\t    ),\n\n\t    TP_printk(\"dev %d:%d, inode %d, error %d, start %ld, end %ld\",\n\t\t      MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t      __entry->ino, __entry->error, __entry->start,\n\t\t      __entry->end)\n\t);\n\n#endif /* _TRACE_EXT4_H */\n\n/* This part must be outside protection */\n#include <trace/define_trace.h>\n"}, "11": {"id": 11, "path": "/src/include/linux/kernel.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_KERNEL_H\n#define _LINUX_KERNEL_H\n\n\n#include <stdarg.h>\n#include <linux/limits.h>\n#include <linux/linkage.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n#include <linux/compiler.h>\n#include <linux/bitops.h>\n#include <linux/log2.h>\n#include <linux/minmax.h>\n#include <linux/typecheck.h>\n#include <linux/printk.h>\n#include <linux/build_bug.h>\n#include <asm/byteorder.h>\n#include <asm/div64.h>\n#include <uapi/linux/kernel.h>\n\n#define STACK_MAGIC\t0xdeadbeef\n\n/**\n * REPEAT_BYTE - repeat the value @x multiple times as an unsigned long value\n * @x: value to repeat\n *\n * NOTE: @x is not checked for > 0xff; larger values produce odd results.\n */\n#define REPEAT_BYTE(x)\t((~0ul / 0xff) * (x))\n\n/* @a is a power of 2 value */\n#define ALIGN(x, a)\t\t__ALIGN_KERNEL((x), (a))\n#define ALIGN_DOWN(x, a)\t__ALIGN_KERNEL((x) - ((a) - 1), (a))\n#define __ALIGN_MASK(x, mask)\t__ALIGN_KERNEL_MASK((x), (mask))\n#define PTR_ALIGN(p, a)\t\t((typeof(p))ALIGN((unsigned long)(p), (a)))\n#define PTR_ALIGN_DOWN(p, a)\t((typeof(p))ALIGN_DOWN((unsigned long)(p), (a)))\n#define IS_ALIGNED(x, a)\t\t(((x) & ((typeof(x))(a) - 1)) == 0)\n\n/* generic data direction definitions */\n#define READ\t\t\t0\n#define WRITE\t\t\t1\n\n/**\n * ARRAY_SIZE - get the number of elements in array @arr\n * @arr: array to be sized\n */\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr))\n\n#define u64_to_user_ptr(x) (\t\t\\\n{\t\t\t\t\t\\\n\ttypecheck(u64, (x));\t\t\\\n\t(void __user *)(uintptr_t)(x);\t\\\n}\t\t\t\t\t\\\n)\n\n/*\n * This looks more complex than it should be. But we need to\n * get the type for the ~ right in round_down (it needs to be\n * as wide as the result!), and we want to evaluate the macro\n * arguments just once each.\n */\n#define __round_mask(x, y) ((__typeof__(x))((y)-1))\n/**\n * round_up - round up to next specified power of 2\n * @x: the value to round\n * @y: multiple to round up to (must be a power of 2)\n *\n * Rounds @x up to next multiple of @y (which must be a power of 2).\n * To perform arbitrary rounding up, use roundup() below.\n */\n#define round_up(x, y) ((((x)-1) | __round_mask(x, y))+1)\n/**\n * round_down - round down to next specified power of 2\n * @x: the value to round\n * @y: multiple to round down to (must be a power of 2)\n *\n * Rounds @x down to next multiple of @y (which must be a power of 2).\n * To perform arbitrary rounding down, use rounddown() below.\n */\n#define round_down(x, y) ((x) & ~__round_mask(x, y))\n\n#define typeof_member(T, m)\ttypeof(((T*)0)->m)\n\n#define DIV_ROUND_UP __KERNEL_DIV_ROUND_UP\n\n#define DIV_ROUND_DOWN_ULL(ll, d) \\\n\t({ unsigned long long _tmp = (ll); do_div(_tmp, d); _tmp; })\n\n#define DIV_ROUND_UP_ULL(ll, d) \\\n\tDIV_ROUND_DOWN_ULL((unsigned long long)(ll) + (d) - 1, (d))\n\n#if BITS_PER_LONG == 32\n# define DIV_ROUND_UP_SECTOR_T(ll,d) DIV_ROUND_UP_ULL(ll, d)\n#else\n# define DIV_ROUND_UP_SECTOR_T(ll,d) DIV_ROUND_UP(ll,d)\n#endif\n\n/**\n * roundup - round up to the next specified multiple\n * @x: the value to up\n * @y: multiple to round up to\n *\n * Rounds @x up to next multiple of @y. If @y will always be a power\n * of 2, consider using the faster round_up().\n */\n#define roundup(x, y) (\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\ttypeof(y) __y = y;\t\t\t\t\\\n\t(((x) + (__y - 1)) / __y) * __y;\t\t\\\n}\t\t\t\t\t\t\t\\\n)\n/**\n * rounddown - round down to next specified multiple\n * @x: the value to round\n * @y: multiple to round down to\n *\n * Rounds @x down to next multiple of @y. If @y will always be a power\n * of 2, consider using the faster round_down().\n */\n#define rounddown(x, y) (\t\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\ttypeof(x) __x = (x);\t\t\t\t\\\n\t__x - (__x % (y));\t\t\t\t\\\n}\t\t\t\t\t\t\t\\\n)\n\n/*\n * Divide positive or negative dividend by positive or negative divisor\n * and round to closest integer. Result is undefined for negative\n * divisors if the dividend variable type is unsigned and for negative\n * dividends if the divisor variable type is unsigned.\n */\n#define DIV_ROUND_CLOSEST(x, divisor)(\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\ttypeof(x) __x = x;\t\t\t\t\\\n\ttypeof(divisor) __d = divisor;\t\t\t\\\n\t(((typeof(x))-1) > 0 ||\t\t\t\t\\\n\t ((typeof(divisor))-1) > 0 ||\t\t\t\\\n\t (((__x) > 0) == ((__d) > 0))) ?\t\t\\\n\t\t(((__x) + ((__d) / 2)) / (__d)) :\t\\\n\t\t(((__x) - ((__d) / 2)) / (__d));\t\\\n}\t\t\t\t\t\t\t\\\n)\n/*\n * Same as above but for u64 dividends. divisor must be a 32-bit\n * number.\n */\n#define DIV_ROUND_CLOSEST_ULL(x, divisor)(\t\t\\\n{\t\t\t\t\t\t\t\\\n\ttypeof(divisor) __d = divisor;\t\t\t\\\n\tunsigned long long _tmp = (x) + (__d) / 2;\t\\\n\tdo_div(_tmp, __d);\t\t\t\t\\\n\t_tmp;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\\\n)\n\n/*\n * Multiplies an integer by a fraction, while avoiding unnecessary\n * overflow or loss of precision.\n */\n#define mult_frac(x, numer, denom)(\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\ttypeof(x) quot = (x) / (denom);\t\t\t\\\n\ttypeof(x) rem  = (x) % (denom);\t\t\t\\\n\t(quot * (numer)) + ((rem * (numer)) / (denom));\t\\\n}\t\t\t\t\t\t\t\\\n)\n\n\n#define _RET_IP_\t\t(unsigned long)__builtin_return_address(0)\n#define _THIS_IP_  ({ __label__ __here; __here: (unsigned long)&&__here; })\n\n#define sector_div(a, b) do_div(a, b)\n\n/**\n * upper_32_bits - return bits 32-63 of a number\n * @n: the number we're accessing\n *\n * A basic shift-right of a 64- or 32-bit quantity.  Use this to suppress\n * the \"right shift count >= width of type\" warning when that quantity is\n * 32-bits.\n */\n#define upper_32_bits(n) ((u32)(((n) >> 16) >> 16))\n\n/**\n * lower_32_bits - return bits 0-31 of a number\n * @n: the number we're accessing\n */\n#define lower_32_bits(n) ((u32)((n) & 0xffffffff))\n\nstruct completion;\nstruct pt_regs;\nstruct user;\n\n#ifdef CONFIG_PREEMPT_VOLUNTARY\nextern int _cond_resched(void);\n# define might_resched() _cond_resched()\n#else\n# define might_resched() do { } while (0)\n#endif\n\n#ifdef CONFIG_DEBUG_ATOMIC_SLEEP\nextern void ___might_sleep(const char *file, int line, int preempt_offset);\nextern void __might_sleep(const char *file, int line, int preempt_offset);\nextern void __cant_sleep(const char *file, int line, int preempt_offset);\n\n/**\n * might_sleep - annotation for functions that can sleep\n *\n * this macro will print a stack trace if it is executed in an atomic\n * context (spinlock, irq-handler, ...). Additional sections where blocking is\n * not allowed can be annotated with non_block_start() and non_block_end()\n * pairs.\n *\n * This is a useful debugging help to be able to catch problems early and not\n * be bitten later when the calling function happens to sleep when it is not\n * supposed to.\n */\n# define might_sleep() \\\n\tdo { __might_sleep(__FILE__, __LINE__, 0); might_resched(); } while (0)\n/**\n * cant_sleep - annotation for functions that cannot sleep\n *\n * this macro will print a stack trace if it is executed with preemption enabled\n */\n# define cant_sleep() \\\n\tdo { __cant_sleep(__FILE__, __LINE__, 0); } while (0)\n# define sched_annotate_sleep()\t(current->task_state_change = 0)\n/**\n * non_block_start - annotate the start of section where sleeping is prohibited\n *\n * This is on behalf of the oom reaper, specifically when it is calling the mmu\n * notifiers. The problem is that if the notifier were to block on, for example,\n * mutex_lock() and if the process which holds that mutex were to perform a\n * sleeping memory allocation, the oom reaper is now blocked on completion of\n * that memory allocation. Other blocking calls like wait_event() pose similar\n * issues.\n */\n# define non_block_start() (current->non_block_count++)\n/**\n * non_block_end - annotate the end of section where sleeping is prohibited\n *\n * Closes a section opened by non_block_start().\n */\n# define non_block_end() WARN_ON(current->non_block_count-- == 0)\n#else\n  static inline void ___might_sleep(const char *file, int line,\n\t\t\t\t   int preempt_offset) { }\n  static inline void __might_sleep(const char *file, int line,\n\t\t\t\t   int preempt_offset) { }\n# define might_sleep() do { might_resched(); } while (0)\n# define cant_sleep() do { } while (0)\n# define sched_annotate_sleep() do { } while (0)\n# define non_block_start() do { } while (0)\n# define non_block_end() do { } while (0)\n#endif\n\n#define might_sleep_if(cond) do { if (cond) might_sleep(); } while (0)\n\n#ifndef CONFIG_PREEMPT_RT\n# define cant_migrate()\t\tcant_sleep()\n#else\n  /* Placeholder for now */\n# define cant_migrate()\t\tdo { } while (0)\n#endif\n\n/**\n * abs - return absolute value of an argument\n * @x: the value.  If it is unsigned type, it is converted to signed type first.\n *     char is treated as if it was signed (regardless of whether it really is)\n *     but the macro's return type is preserved as char.\n *\n * Return: an absolute value of x.\n */\n#define abs(x)\t__abs_choose_expr(x, long long,\t\t\t\t\\\n\t\t__abs_choose_expr(x, long,\t\t\t\t\\\n\t\t__abs_choose_expr(x, int,\t\t\t\t\\\n\t\t__abs_choose_expr(x, short,\t\t\t\t\\\n\t\t__abs_choose_expr(x, char,\t\t\t\t\\\n\t\t__builtin_choose_expr(\t\t\t\t\t\\\n\t\t\t__builtin_types_compatible_p(typeof(x), char),\t\\\n\t\t\t(char)({ signed char __x = (x); __x<0?-__x:__x; }), \\\n\t\t\t((void)0)))))))\n\n#define __abs_choose_expr(x, type, other) __builtin_choose_expr(\t\\\n\t__builtin_types_compatible_p(typeof(x),   signed type) ||\t\\\n\t__builtin_types_compatible_p(typeof(x), unsigned type),\t\t\\\n\t({ signed type __x = (x); __x < 0 ? -__x : __x; }), other)\n\n/**\n * reciprocal_scale - \"scale\" a value into range [0, ep_ro)\n * @val: value\n * @ep_ro: right open interval endpoint\n *\n * Perform a \"reciprocal multiplication\" in order to \"scale\" a value into\n * range [0, @ep_ro), where the upper interval endpoint is right-open.\n * This is useful, e.g. for accessing a index of an array containing\n * @ep_ro elements, for example. Think of it as sort of modulus, only that\n * the result isn't that of modulo. ;) Note that if initial input is a\n * small value, then result will return 0.\n *\n * Return: a result based on @val in interval [0, @ep_ro).\n */\nstatic inline u32 reciprocal_scale(u32 val, u32 ep_ro)\n{\n\treturn (u32)(((u64) val * ep_ro) >> 32);\n}\n\n#if defined(CONFIG_MMU) && \\\n\t(defined(CONFIG_PROVE_LOCKING) || defined(CONFIG_DEBUG_ATOMIC_SLEEP))\n#define might_fault() __might_fault(__FILE__, __LINE__)\nvoid __might_fault(const char *file, int line);\n#else\nstatic inline void might_fault(void) { }\n#endif\n\nextern struct atomic_notifier_head panic_notifier_list;\nextern long (*panic_blink)(int state);\n__printf(1, 2)\nvoid panic(const char *fmt, ...) __noreturn __cold;\nvoid nmi_panic(struct pt_regs *regs, const char *msg);\nextern void oops_enter(void);\nextern void oops_exit(void);\nextern bool oops_may_print(void);\nvoid do_exit(long error_code) __noreturn;\nvoid complete_and_exit(struct completion *, long) __noreturn;\n\n/* Internal, do not use. */\nint __must_check _kstrtoul(const char *s, unsigned int base, unsigned long *res);\nint __must_check _kstrtol(const char *s, unsigned int base, long *res);\n\nint __must_check kstrtoull(const char *s, unsigned int base, unsigned long long *res);\nint __must_check kstrtoll(const char *s, unsigned int base, long long *res);\n\n/**\n * kstrtoul - convert a string to an unsigned long\n * @s: The start of the string. The string must be null-terminated, and may also\n *  include a single newline before its terminating null. The first character\n *  may also be a plus sign, but not a minus sign.\n * @base: The number base to use. The maximum supported base is 16. If base is\n *  given as 0, then the base of the string is automatically detected with the\n *  conventional semantics - If it begins with 0x the number will be parsed as a\n *  hexadecimal (case insensitive), if it otherwise begins with 0, it will be\n *  parsed as an octal number. Otherwise it will be parsed as a decimal.\n * @res: Where to write the result of the conversion on success.\n *\n * Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.\n * Preferred over simple_strtoul(). Return code must be checked.\n*/\nstatic inline int __must_check kstrtoul(const char *s, unsigned int base, unsigned long *res)\n{\n\t/*\n\t * We want to shortcut function call, but\n\t * __builtin_types_compatible_p(unsigned long, unsigned long long) = 0.\n\t */\n\tif (sizeof(unsigned long) == sizeof(unsigned long long) &&\n\t    __alignof__(unsigned long) == __alignof__(unsigned long long))\n\t\treturn kstrtoull(s, base, (unsigned long long *)res);\n\telse\n\t\treturn _kstrtoul(s, base, res);\n}\n\n/**\n * kstrtol - convert a string to a long\n * @s: The start of the string. The string must be null-terminated, and may also\n *  include a single newline before its terminating null. The first character\n *  may also be a plus sign or a minus sign.\n * @base: The number base to use. The maximum supported base is 16. If base is\n *  given as 0, then the base of the string is automatically detected with the\n *  conventional semantics - If it begins with 0x the number will be parsed as a\n *  hexadecimal (case insensitive), if it otherwise begins with 0, it will be\n *  parsed as an octal number. Otherwise it will be parsed as a decimal.\n * @res: Where to write the result of the conversion on success.\n *\n * Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.\n * Preferred over simple_strtol(). Return code must be checked.\n */\nstatic inline int __must_check kstrtol(const char *s, unsigned int base, long *res)\n{\n\t/*\n\t * We want to shortcut function call, but\n\t * __builtin_types_compatible_p(long, long long) = 0.\n\t */\n\tif (sizeof(long) == sizeof(long long) &&\n\t    __alignof__(long) == __alignof__(long long))\n\t\treturn kstrtoll(s, base, (long long *)res);\n\telse\n\t\treturn _kstrtol(s, base, res);\n}\n\nint __must_check kstrtouint(const char *s, unsigned int base, unsigned int *res);\nint __must_check kstrtoint(const char *s, unsigned int base, int *res);\n\nstatic inline int __must_check kstrtou64(const char *s, unsigned int base, u64 *res)\n{\n\treturn kstrtoull(s, base, res);\n}\n\nstatic inline int __must_check kstrtos64(const char *s, unsigned int base, s64 *res)\n{\n\treturn kstrtoll(s, base, res);\n}\n\nstatic inline int __must_check kstrtou32(const char *s, unsigned int base, u32 *res)\n{\n\treturn kstrtouint(s, base, res);\n}\n\nstatic inline int __must_check kstrtos32(const char *s, unsigned int base, s32 *res)\n{\n\treturn kstrtoint(s, base, res);\n}\n\nint __must_check kstrtou16(const char *s, unsigned int base, u16 *res);\nint __must_check kstrtos16(const char *s, unsigned int base, s16 *res);\nint __must_check kstrtou8(const char *s, unsigned int base, u8 *res);\nint __must_check kstrtos8(const char *s, unsigned int base, s8 *res);\nint __must_check kstrtobool(const char *s, bool *res);\n\nint __must_check kstrtoull_from_user(const char __user *s, size_t count, unsigned int base, unsigned long long *res);\nint __must_check kstrtoll_from_user(const char __user *s, size_t count, unsigned int base, long long *res);\nint __must_check kstrtoul_from_user(const char __user *s, size_t count, unsigned int base, unsigned long *res);\nint __must_check kstrtol_from_user(const char __user *s, size_t count, unsigned int base, long *res);\nint __must_check kstrtouint_from_user(const char __user *s, size_t count, unsigned int base, unsigned int *res);\nint __must_check kstrtoint_from_user(const char __user *s, size_t count, unsigned int base, int *res);\nint __must_check kstrtou16_from_user(const char __user *s, size_t count, unsigned int base, u16 *res);\nint __must_check kstrtos16_from_user(const char __user *s, size_t count, unsigned int base, s16 *res);\nint __must_check kstrtou8_from_user(const char __user *s, size_t count, unsigned int base, u8 *res);\nint __must_check kstrtos8_from_user(const char __user *s, size_t count, unsigned int base, s8 *res);\nint __must_check kstrtobool_from_user(const char __user *s, size_t count, bool *res);\n\nstatic inline int __must_check kstrtou64_from_user(const char __user *s, size_t count, unsigned int base, u64 *res)\n{\n\treturn kstrtoull_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtos64_from_user(const char __user *s, size_t count, unsigned int base, s64 *res)\n{\n\treturn kstrtoll_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtou32_from_user(const char __user *s, size_t count, unsigned int base, u32 *res)\n{\n\treturn kstrtouint_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtos32_from_user(const char __user *s, size_t count, unsigned int base, s32 *res)\n{\n\treturn kstrtoint_from_user(s, count, base, res);\n}\n\n/*\n * Use kstrto<foo> instead.\n *\n * NOTE: simple_strto<foo> does not check for the range overflow and,\n *\t depending on the input, may give interesting results.\n *\n * Use these functions if and only if you cannot use kstrto<foo>, because\n * the conversion ends on the first non-digit character, which may be far\n * beyond the supported range. It might be useful to parse the strings like\n * 10x50 or 12:21 without altering original string or temporary buffer in use.\n * Keep in mind above caveat.\n */\n\nextern unsigned long simple_strtoul(const char *,char **,unsigned int);\nextern long simple_strtol(const char *,char **,unsigned int);\nextern unsigned long long simple_strtoull(const char *,char **,unsigned int);\nextern long long simple_strtoll(const char *,char **,unsigned int);\n\nextern int num_to_str(char *buf, int size,\n\t\t      unsigned long long num, unsigned int width);\n\n/* lib/printf utilities */\n\nextern __printf(2, 3) int sprintf(char *buf, const char * fmt, ...);\nextern __printf(2, 0) int vsprintf(char *buf, const char *, va_list);\nextern __printf(3, 4)\nint snprintf(char *buf, size_t size, const char *fmt, ...);\nextern __printf(3, 0)\nint vsnprintf(char *buf, size_t size, const char *fmt, va_list args);\nextern __printf(3, 4)\nint scnprintf(char *buf, size_t size, const char *fmt, ...);\nextern __printf(3, 0)\nint vscnprintf(char *buf, size_t size, const char *fmt, va_list args);\nextern __printf(2, 3) __malloc\nchar *kasprintf(gfp_t gfp, const char *fmt, ...);\nextern __printf(2, 0) __malloc\nchar *kvasprintf(gfp_t gfp, const char *fmt, va_list args);\nextern __printf(2, 0)\nconst char *kvasprintf_const(gfp_t gfp, const char *fmt, va_list args);\n\nextern __scanf(2, 3)\nint sscanf(const char *, const char *, ...);\nextern __scanf(2, 0)\nint vsscanf(const char *, const char *, va_list);\n\nextern int get_option(char **str, int *pint);\nextern char *get_options(const char *str, int nints, int *ints);\nextern unsigned long long memparse(const char *ptr, char **retptr);\nextern bool parse_option_str(const char *str, const char *option);\nextern char *next_arg(char *args, char **param, char **val);\n\nextern int core_kernel_text(unsigned long addr);\nextern int init_kernel_text(unsigned long addr);\nextern int core_kernel_data(unsigned long addr);\nextern int __kernel_text_address(unsigned long addr);\nextern int kernel_text_address(unsigned long addr);\nextern int func_ptr_is_kernel_text(void *ptr);\n\nu64 int_pow(u64 base, unsigned int exp);\nunsigned long int_sqrt(unsigned long);\n\n#if BITS_PER_LONG < 64\nu32 int_sqrt64(u64 x);\n#else\nstatic inline u32 int_sqrt64(u64 x)\n{\n\treturn (u32)int_sqrt(x);\n}\n#endif\n\n#ifdef CONFIG_SMP\nextern unsigned int sysctl_oops_all_cpu_backtrace;\n#else\n#define sysctl_oops_all_cpu_backtrace 0\n#endif /* CONFIG_SMP */\n\nextern void bust_spinlocks(int yes);\nextern int panic_timeout;\nextern unsigned long panic_print;\nextern int panic_on_oops;\nextern int panic_on_unrecovered_nmi;\nextern int panic_on_io_nmi;\nextern int panic_on_warn;\nextern unsigned long panic_on_taint;\nextern bool panic_on_taint_nousertaint;\nextern int sysctl_panic_on_rcu_stall;\nextern int sysctl_panic_on_stackoverflow;\n\nextern bool crash_kexec_post_notifiers;\n\n/*\n * panic_cpu is used for synchronizing panic() and crash_kexec() execution. It\n * holds a CPU number which is executing panic() currently. A value of\n * PANIC_CPU_INVALID means no CPU has entered panic() or crash_kexec().\n */\nextern atomic_t panic_cpu;\n#define PANIC_CPU_INVALID\t-1\n\n/*\n * Only to be used by arch init code. If the user over-wrote the default\n * CONFIG_PANIC_TIMEOUT, honor it.\n */\nstatic inline void set_arch_panic_timeout(int timeout, int arch_default_timeout)\n{\n\tif (panic_timeout == arch_default_timeout)\n\t\tpanic_timeout = timeout;\n}\nextern const char *print_tainted(void);\nenum lockdep_ok {\n\tLOCKDEP_STILL_OK,\n\tLOCKDEP_NOW_UNRELIABLE\n};\nextern void add_taint(unsigned flag, enum lockdep_ok);\nextern int test_taint(unsigned flag);\nextern unsigned long get_taint(void);\nextern int root_mountflags;\n\nextern bool early_boot_irqs_disabled;\n\n/*\n * Values used for system_state. Ordering of the states must not be changed\n * as code checks for <, <=, >, >= STATE.\n */\nextern enum system_states {\n\tSYSTEM_BOOTING,\n\tSYSTEM_SCHEDULING,\n\tSYSTEM_RUNNING,\n\tSYSTEM_HALT,\n\tSYSTEM_POWER_OFF,\n\tSYSTEM_RESTART,\n\tSYSTEM_SUSPEND,\n} system_state;\n\n/* This cannot be an enum because some may be used in assembly source. */\n#define TAINT_PROPRIETARY_MODULE\t0\n#define TAINT_FORCED_MODULE\t\t1\n#define TAINT_CPU_OUT_OF_SPEC\t\t2\n#define TAINT_FORCED_RMMOD\t\t3\n#define TAINT_MACHINE_CHECK\t\t4\n#define TAINT_BAD_PAGE\t\t\t5\n#define TAINT_USER\t\t\t6\n#define TAINT_DIE\t\t\t7\n#define TAINT_OVERRIDDEN_ACPI_TABLE\t8\n#define TAINT_WARN\t\t\t9\n#define TAINT_CRAP\t\t\t10\n#define TAINT_FIRMWARE_WORKAROUND\t11\n#define TAINT_OOT_MODULE\t\t12\n#define TAINT_UNSIGNED_MODULE\t\t13\n#define TAINT_SOFTLOCKUP\t\t14\n#define TAINT_LIVEPATCH\t\t\t15\n#define TAINT_AUX\t\t\t16\n#define TAINT_RANDSTRUCT\t\t17\n#define TAINT_FLAGS_COUNT\t\t18\n#define TAINT_FLAGS_MAX\t\t\t((1UL << TAINT_FLAGS_COUNT) - 1)\n\nstruct taint_flag {\n\tchar c_true;\t/* character printed when tainted */\n\tchar c_false;\t/* character printed when not tainted */\n\tbool module;\t/* also show as a per-module taint flag */\n};\n\nextern const struct taint_flag taint_flags[TAINT_FLAGS_COUNT];\n\nextern const char hex_asc[];\n#define hex_asc_lo(x)\thex_asc[((x) & 0x0f)]\n#define hex_asc_hi(x)\thex_asc[((x) & 0xf0) >> 4]\n\nstatic inline char *hex_byte_pack(char *buf, u8 byte)\n{\n\t*buf++ = hex_asc_hi(byte);\n\t*buf++ = hex_asc_lo(byte);\n\treturn buf;\n}\n\nextern const char hex_asc_upper[];\n#define hex_asc_upper_lo(x)\thex_asc_upper[((x) & 0x0f)]\n#define hex_asc_upper_hi(x)\thex_asc_upper[((x) & 0xf0) >> 4]\n\nstatic inline char *hex_byte_pack_upper(char *buf, u8 byte)\n{\n\t*buf++ = hex_asc_upper_hi(byte);\n\t*buf++ = hex_asc_upper_lo(byte);\n\treturn buf;\n}\n\nextern int hex_to_bin(char ch);\nextern int __must_check hex2bin(u8 *dst, const char *src, size_t count);\nextern char *bin2hex(char *dst, const void *src, size_t count);\n\nbool mac_pton(const char *s, u8 *mac);\n\n/*\n * General tracing related utility functions - trace_printk(),\n * tracing_on/tracing_off and tracing_start()/tracing_stop\n *\n * Use tracing_on/tracing_off when you want to quickly turn on or off\n * tracing. It simply enables or disables the recording of the trace events.\n * This also corresponds to the user space /sys/kernel/debug/tracing/tracing_on\n * file, which gives a means for the kernel and userspace to interact.\n * Place a tracing_off() in the kernel where you want tracing to end.\n * From user space, examine the trace, and then echo 1 > tracing_on\n * to continue tracing.\n *\n * tracing_stop/tracing_start has slightly more overhead. It is used\n * by things like suspend to ram where disabling the recording of the\n * trace is not enough, but tracing must actually stop because things\n * like calling smp_processor_id() may crash the system.\n *\n * Most likely, you want to use tracing_on/tracing_off.\n */\n\nenum ftrace_dump_mode {\n\tDUMP_NONE,\n\tDUMP_ALL,\n\tDUMP_ORIG,\n};\n\n#ifdef CONFIG_TRACING\nvoid tracing_on(void);\nvoid tracing_off(void);\nint tracing_is_on(void);\nvoid tracing_snapshot(void);\nvoid tracing_snapshot_alloc(void);\n\nextern void tracing_start(void);\nextern void tracing_stop(void);\n\nstatic inline __printf(1, 2)\nvoid ____trace_printk_check_format(const char *fmt, ...)\n{\n}\n#define __trace_printk_check_format(fmt, args...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\t\\\n\t\t____trace_printk_check_format(fmt, ##args);\t\t\\\n} while (0)\n\n/**\n * trace_printk - printf formatting in the ftrace buffer\n * @fmt: the printf format for printing\n *\n * Note: __trace_printk is an internal function for trace_printk() and\n *       the @ip is passed in via the trace_printk() macro.\n *\n * This function allows a kernel developer to debug fast path sections\n * that printk is not appropriate for. By scattering in various\n * printk like tracing in the code, a developer can quickly see\n * where problems are occurring.\n *\n * This is intended as a debugging tool for the developer only.\n * Please refrain from leaving trace_printks scattered around in\n * your code. (Extra memory is used for special buffers that are\n * allocated when trace_printk() is used.)\n *\n * A little optimization trick is done here. If there's only one\n * argument, there's no need to scan the string for printf formats.\n * The trace_puts() will suffice. But how can we take advantage of\n * using trace_puts() when trace_printk() has only one argument?\n * By stringifying the args and checking the size we can tell\n * whether or not there are args. __stringify((__VA_ARGS__)) will\n * turn into \"()\\0\" with a size of 3 when there are no args, anything\n * else will be bigger. All we need to do is define a string to this,\n * and then take its size and compare to 3. If it's bigger, use\n * do_trace_printk() otherwise, optimize it to trace_puts(). Then just\n * let gcc optimize the rest.\n */\n\n#define trace_printk(fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tchar _______STR[] = __stringify((__VA_ARGS__));\t\\\n\tif (sizeof(_______STR) > 3)\t\t\t\\\n\t\tdo_trace_printk(fmt, ##__VA_ARGS__);\t\\\n\telse\t\t\t\t\t\t\\\n\t\ttrace_puts(fmt);\t\t\t\\\n} while (0)\n\n#define do_trace_printk(fmt, args...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tstatic const char *trace_printk_fmt __used\t\t\t\\\n\t\t__attribute__((section(\"__trace_printk_fmt\"))) =\t\\\n\t\t__builtin_constant_p(fmt) ? fmt : NULL;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__trace_printk_check_format(fmt, ##args);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(fmt))\t\t\t\t\t\\\n\t\t__trace_bprintk(_THIS_IP_, trace_printk_fmt, ##args);\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t__trace_printk(_THIS_IP_, fmt, ##args);\t\t\t\\\n} while (0)\n\nextern __printf(2, 3)\nint __trace_bprintk(unsigned long ip, const char *fmt, ...);\n\nextern __printf(2, 3)\nint __trace_printk(unsigned long ip, const char *fmt, ...);\n\n/**\n * trace_puts - write a string into the ftrace buffer\n * @str: the string to record\n *\n * Note: __trace_bputs is an internal function for trace_puts and\n *       the @ip is passed in via the trace_puts macro.\n *\n * This is similar to trace_printk() but is made for those really fast\n * paths that a developer wants the least amount of \"Heisenbug\" effects,\n * where the processing of the print format is still too much.\n *\n * This function allows a kernel developer to debug fast path sections\n * that printk is not appropriate for. By scattering in various\n * printk like tracing in the code, a developer can quickly see\n * where problems are occurring.\n *\n * This is intended as a debugging tool for the developer only.\n * Please refrain from leaving trace_puts scattered around in\n * your code. (Extra memory is used for special buffers that are\n * allocated when trace_puts() is used.)\n *\n * Returns: 0 if nothing was written, positive # if string was.\n *  (1 when __trace_bputs is used, strlen(str) when __trace_puts is used)\n */\n\n#define trace_puts(str) ({\t\t\t\t\t\t\\\n\tstatic const char *trace_printk_fmt __used\t\t\t\\\n\t\t__attribute__((section(\"__trace_printk_fmt\"))) =\t\\\n\t\t__builtin_constant_p(str) ? str : NULL;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(str))\t\t\t\t\t\\\n\t\t__trace_bputs(_THIS_IP_, trace_printk_fmt);\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t__trace_puts(_THIS_IP_, str, strlen(str));\t\t\\\n})\nextern int __trace_bputs(unsigned long ip, const char *str);\nextern int __trace_puts(unsigned long ip, const char *str, int size);\n\nextern void trace_dump_stack(int skip);\n\n/*\n * The double __builtin_constant_p is because gcc will give us an error\n * if we try to allocate the static variable to fmt if it is not a\n * constant. Even with the outer if statement.\n */\n#define ftrace_vprintk(fmt, vargs)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(fmt)) {\t\t\t\t\\\n\t\tstatic const char *trace_printk_fmt __used\t\t\\\n\t\t  __attribute__((section(\"__trace_printk_fmt\"))) =\t\\\n\t\t\t__builtin_constant_p(fmt) ? fmt : NULL;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t__ftrace_vbprintk(_THIS_IP_, trace_printk_fmt, vargs);\t\\\n\t} else\t\t\t\t\t\t\t\t\\\n\t\t__ftrace_vprintk(_THIS_IP_, fmt, vargs);\t\t\\\n} while (0)\n\nextern __printf(2, 0) int\n__ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap);\n\nextern __printf(2, 0) int\n__ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap);\n\nextern void ftrace_dump(enum ftrace_dump_mode oops_dump_mode);\n#else\nstatic inline void tracing_start(void) { }\nstatic inline void tracing_stop(void) { }\nstatic inline void trace_dump_stack(int skip) { }\n\nstatic inline void tracing_on(void) { }\nstatic inline void tracing_off(void) { }\nstatic inline int tracing_is_on(void) { return 0; }\nstatic inline void tracing_snapshot(void) { }\nstatic inline void tracing_snapshot_alloc(void) { }\n\nstatic inline __printf(1, 2)\nint trace_printk(const char *fmt, ...)\n{\n\treturn 0;\n}\nstatic __printf(1, 0) inline int\nftrace_vprintk(const char *fmt, va_list ap)\n{\n\treturn 0;\n}\nstatic inline void ftrace_dump(enum ftrace_dump_mode oops_dump_mode) { }\n#endif /* CONFIG_TRACING */\n\n/* This counts to 12. Any more, it will return 13th argument. */\n#define __COUNT_ARGS(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _n, X...) _n\n#define COUNT_ARGS(X...) __COUNT_ARGS(, ##X, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)\n\n#define __CONCAT(a, b) a ## b\n#define CONCATENATE(a, b) __CONCAT(a, b)\n\n/**\n * container_of - cast a member of a structure out to the containing structure\n * @ptr:\tthe pointer to the member.\n * @type:\tthe type of the container struct this is embedded in.\n * @member:\tthe name of the member within the struct.\n *\n */\n#define container_of(ptr, type, member) ({\t\t\t\t\\\n\tvoid *__mptr = (void *)(ptr);\t\t\t\t\t\\\n\tBUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&\t\\\n\t\t\t !__same_type(*(ptr), void),\t\t\t\\\n\t\t\t \"pointer type mismatch in container_of()\");\t\\\n\t((type *)(__mptr - offsetof(type, member))); })\n\n/**\n * container_of_safe - cast a member of a structure out to the containing structure\n * @ptr:\tthe pointer to the member.\n * @type:\tthe type of the container struct this is embedded in.\n * @member:\tthe name of the member within the struct.\n *\n * If IS_ERR_OR_NULL(ptr), ptr is returned unchanged.\n */\n#define container_of_safe(ptr, type, member) ({\t\t\t\t\\\n\tvoid *__mptr = (void *)(ptr);\t\t\t\t\t\\\n\tBUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&\t\\\n\t\t\t !__same_type(*(ptr), void),\t\t\t\\\n\t\t\t \"pointer type mismatch in container_of()\");\t\\\n\tIS_ERR_OR_NULL(__mptr) ? ERR_CAST(__mptr) :\t\t\t\\\n\t\t((type *)(__mptr - offsetof(type, member))); })\n\n/* Rebuild everything on CONFIG_FTRACE_MCOUNT_RECORD */\n#ifdef CONFIG_FTRACE_MCOUNT_RECORD\n# define REBUILD_DUE_TO_FTRACE_MCOUNT_RECORD\n#endif\n\n/* Permissions on a sysfs file: you didn't miss the 0 prefix did you? */\n#define VERIFY_OCTAL_PERMISSIONS(perms)\t\t\t\t\t\t\\\n\t(BUILD_BUG_ON_ZERO((perms) < 0) +\t\t\t\t\t\\\n\t BUILD_BUG_ON_ZERO((perms) > 0777) +\t\t\t\t\t\\\n\t /* USER_READABLE >= GROUP_READABLE >= OTHER_READABLE */\t\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 6) & 4) < (((perms) >> 3) & 4)) +\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 3) & 4) < ((perms) & 4)) +\t\t\\\n\t /* USER_WRITABLE >= GROUP_WRITABLE */\t\t\t\t\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 6) & 2) < (((perms) >> 3) & 2)) +\t\\\n\t /* OTHER_WRITABLE?  Generally considered a bad idea. */\t\t\\\n\t BUILD_BUG_ON_ZERO((perms) & 2) +\t\t\t\t\t\\\n\t (perms))\n#endif\n"}, "12": {"id": 12, "path": "/src/include/linux/build_bug.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_BUILD_BUG_H\n#define _LINUX_BUILD_BUG_H\n\n#include <linux/compiler.h>\n\n#ifdef __CHECKER__\n#define BUILD_BUG_ON_ZERO(e) (0)\n#else /* __CHECKER__ */\n/*\n * Force a compilation error if condition is true, but also produce a\n * result (of value 0 and type int), so the expression can be used\n * e.g. in a structure initializer (or where-ever else comma expressions\n * aren't permitted).\n */\n#define BUILD_BUG_ON_ZERO(e) ((int)(sizeof(struct { int:(-!!(e)); })))\n#endif /* __CHECKER__ */\n\n/* Force a compilation error if a constant expression is not a power of 2 */\n#define __BUILD_BUG_ON_NOT_POWER_OF_2(n)\t\\\n\tBUILD_BUG_ON(((n) & ((n) - 1)) != 0)\n#define BUILD_BUG_ON_NOT_POWER_OF_2(n)\t\t\t\\\n\tBUILD_BUG_ON((n) == 0 || (((n) & ((n) - 1)) != 0))\n\n/*\n * BUILD_BUG_ON_INVALID() permits the compiler to check the validity of the\n * expression but avoids the generation of any code, even if that expression\n * has side-effects.\n */\n#define BUILD_BUG_ON_INVALID(e) ((void)(sizeof((__force long)(e))))\n\n/**\n * BUILD_BUG_ON_MSG - break compile if a condition is true & emit supplied\n *\t\t      error message.\n * @condition: the condition which the compiler should know is false.\n *\n * See BUILD_BUG_ON for description.\n */\n#define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n\n/**\n * BUILD_BUG_ON - break compile if a condition is true.\n * @condition: the condition which the compiler should know is false.\n *\n * If you have some code which relies on certain constants being equal, or\n * some other compile-time-evaluated condition, you should use BUILD_BUG_ON to\n * detect if someone changes it.\n */\n#define BUILD_BUG_ON(condition) \\\n\tBUILD_BUG_ON_MSG(condition, \"BUILD_BUG_ON failed: \" #condition)\n\n/**\n * BUILD_BUG - break compile if used.\n *\n * If you have some code that you expect the compiler to eliminate at\n * build time, you should use BUILD_BUG to detect if it is\n * unexpectedly used.\n */\n#define BUILD_BUG() BUILD_BUG_ON_MSG(1, \"BUILD_BUG failed\")\n\n/**\n * static_assert - check integer constant expression at build time\n *\n * static_assert() is a wrapper for the C11 _Static_assert, with a\n * little macro magic to make the message optional (defaulting to the\n * stringification of the tested expression).\n *\n * Contrary to BUILD_BUG_ON(), static_assert() can be used at global\n * scope, but requires the expression to be an integer constant\n * expression (i.e., it is not enough that __builtin_constant_p() is\n * true for expr).\n *\n * Also note that BUILD_BUG_ON() fails the build if the condition is\n * true, while static_assert() fails the build if the expression is\n * false.\n */\n#define static_assert(expr, ...) __static_assert(expr, ##__VA_ARGS__, #expr)\n#define __static_assert(expr, msg, ...) _Static_assert(expr, msg)\n\n#endif\t/* _LINUX_BUILD_BUG_H */\n"}, "13": {"id": 13, "path": "/src/include/linux/compiler_types.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_COMPILER_TYPES_H\n#define __LINUX_COMPILER_TYPES_H\n\n#ifndef __ASSEMBLY__\n\n#ifdef __CHECKER__\n/* address spaces */\n# define __kernel\t__attribute__((address_space(0)))\n# define __user\t\t__attribute__((noderef, address_space(__user)))\n# define __iomem\t__attribute__((noderef, address_space(__iomem)))\n# define __percpu\t__attribute__((noderef, address_space(__percpu)))\n# define __rcu\t\t__attribute__((noderef, address_space(__rcu)))\nstatic inline void __chk_user_ptr(const volatile void __user *ptr) { }\nstatic inline void __chk_io_ptr(const volatile void __iomem *ptr) { }\n/* context/locking */\n# define __must_hold(x)\t__attribute__((context(x,1,1)))\n# define __acquires(x)\t__attribute__((context(x,0,1)))\n# define __releases(x)\t__attribute__((context(x,1,0)))\n# define __acquire(x)\t__context__(x,1)\n# define __release(x)\t__context__(x,-1)\n# define __cond_lock(x,c)\t((c) ? ({ __acquire(x); 1; }) : 0)\n/* other */\n# define __force\t__attribute__((force))\n# define __nocast\t__attribute__((nocast))\n# define __safe\t\t__attribute__((safe))\n# define __private\t__attribute__((noderef))\n# define ACCESS_PRIVATE(p, member) (*((typeof((p)->member) __force *) &(p)->member))\n#else /* __CHECKER__ */\n/* address spaces */\n# define __kernel\n# ifdef STRUCTLEAK_PLUGIN\n#  define __user\t__attribute__((user))\n# else\n#  define __user\n# endif\n# define __iomem\n# define __percpu\n# define __rcu\n# define __chk_user_ptr(x)\t(void)0\n# define __chk_io_ptr(x)\t(void)0\n/* context/locking */\n# define __must_hold(x)\n# define __acquires(x)\n# define __releases(x)\n# define __acquire(x)\t(void)0\n# define __release(x)\t(void)0\n# define __cond_lock(x,c) (c)\n/* other */\n# define __force\n# define __nocast\n# define __safe\n# define __private\n# define ACCESS_PRIVATE(p, member) ((p)->member)\n# define __builtin_warning(x, y...) (1)\n#endif /* __CHECKER__ */\n\n/* Indirect macros required for expanded argument pasting, eg. __LINE__. */\n#define ___PASTE(a,b) a##b\n#define __PASTE(a,b) ___PASTE(a,b)\n\n#ifdef __KERNEL__\n\n/* Attributes */\n#include <linux/compiler_attributes.h>\n\n/* Compiler specific macros. */\n#ifdef __clang__\n#include <linux/compiler-clang.h>\n#elif defined(__INTEL_COMPILER)\n#include <linux/compiler-intel.h>\n#elif defined(__GNUC__)\n/* The above compilers also define __GNUC__, so order is important here. */\n#include <linux/compiler-gcc.h>\n#else\n#error \"Unknown compiler\"\n#endif\n\n/*\n * Some architectures need to provide custom definitions of macros provided\n * by linux/compiler-*.h, and can do so using asm/compiler.h. We include that\n * conditionally rather than using an asm-generic wrapper in order to avoid\n * build failures if any C compilation, which will include this file via an\n * -include argument in c_flags, occurs prior to the asm-generic wrappers being\n * generated.\n */\n#ifdef CONFIG_HAVE_ARCH_COMPILER_H\n#include <asm/compiler.h>\n#endif\n\nstruct ftrace_branch_data {\n\tconst char *func;\n\tconst char *file;\n\tunsigned line;\n\tunion {\n\t\tstruct {\n\t\t\tunsigned long correct;\n\t\t\tunsigned long incorrect;\n\t\t};\n\t\tstruct {\n\t\t\tunsigned long miss;\n\t\t\tunsigned long hit;\n\t\t};\n\t\tunsigned long miss_hit[2];\n\t};\n};\n\nstruct ftrace_likely_data {\n\tstruct ftrace_branch_data\tdata;\n\tunsigned long\t\t\tconstant;\n};\n\n#ifdef CONFIG_ENABLE_MUST_CHECK\n#define __must_check\t\t__attribute__((__warn_unused_result__))\n#else\n#define __must_check\n#endif\n\n#if defined(CC_USING_HOTPATCH)\n#define notrace\t\t\t__attribute__((hotpatch(0, 0)))\n#elif defined(CC_USING_PATCHABLE_FUNCTION_ENTRY)\n#define notrace\t\t\t__attribute__((patchable_function_entry(0, 0)))\n#else\n#define notrace\t\t\t__attribute__((__no_instrument_function__))\n#endif\n\n/*\n * it doesn't make sense on ARM (currently the only user of __naked)\n * to trace naked functions because then mcount is called without\n * stack and frame pointer being set up and there is no chance to\n * restore the lr register to the value before mcount was called.\n */\n#define __naked\t\t\t__attribute__((__naked__)) notrace\n\n#define __compiler_offsetof(a, b)\t__builtin_offsetof(a, b)\n\n/*\n * Prefer gnu_inline, so that extern inline functions do not emit an\n * externally visible function. This makes extern inline behave as per gnu89\n * semantics rather than c99. This prevents multiple symbol definition errors\n * of extern inline functions at link time.\n * A lot of inline functions can cause havoc with function tracing.\n */\n#define inline inline __gnu_inline __inline_maybe_unused notrace\n\n/*\n * gcc provides both __inline__ and __inline as alternate spellings of\n * the inline keyword, though the latter is undocumented. New kernel\n * code should only use the inline spelling, but some existing code\n * uses __inline__. Since we #define inline above, to ensure\n * __inline__ has the same semantics, we need this #define.\n *\n * However, the spelling __inline is strictly reserved for referring\n * to the bare keyword.\n */\n#define __inline__ inline\n\n/*\n * GCC does not warn about unused static inline functions for -Wunused-function.\n * Suppress the warning in clang as well by using __maybe_unused, but enable it\n * for W=1 build. This will allow clang to find unused functions. Remove the\n * __inline_maybe_unused entirely after fixing most of -Wunused-function warnings.\n */\n#ifdef KBUILD_EXTRA_WARN1\n#define __inline_maybe_unused\n#else\n#define __inline_maybe_unused __maybe_unused\n#endif\n\n/*\n * Rather then using noinline to prevent stack consumption, use\n * noinline_for_stack instead.  For documentation reasons.\n */\n#define noinline_for_stack noinline\n\n/*\n * Sanitizer helper attributes: Because using __always_inline and\n * __no_sanitize_* conflict, provide helper attributes that will either expand\n * to __no_sanitize_* in compilation units where instrumentation is enabled\n * (__SANITIZE_*__), or __always_inline in compilation units without\n * instrumentation (__SANITIZE_*__ undefined).\n */\n#ifdef __SANITIZE_ADDRESS__\n/*\n * We can't declare function 'inline' because __no_sanitize_address conflicts\n * with inlining. Attempt to inline it may cause a build failure.\n *     https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67368\n * '__maybe_unused' allows us to avoid defined-but-not-used warnings.\n */\n# define __no_kasan_or_inline __no_sanitize_address notrace __maybe_unused\n# define __no_sanitize_or_inline __no_kasan_or_inline\n#else\n# define __no_kasan_or_inline __always_inline\n#endif\n\n#define __no_kcsan __no_sanitize_thread\n#ifdef __SANITIZE_THREAD__\n# define __no_sanitize_or_inline __no_kcsan notrace __maybe_unused\n#endif\n\n#ifndef __no_sanitize_or_inline\n#define __no_sanitize_or_inline __always_inline\n#endif\n\n/* Section for code which can't be instrumented at all */\n#define noinstr\t\t\t\t\t\t\t\t\\\n\tnoinline notrace __attribute((__section__(\".noinstr.text\")))\t\\\n\t__no_kcsan __no_sanitize_address\n\n#endif /* __KERNEL__ */\n\n#endif /* __ASSEMBLY__ */\n\n/*\n * The below symbols may be defined for one or more, but not ALL, of the above\n * compilers. We don't consider that to be an error, so set them to nothing.\n * For example, some of them are for compiler specific plugins.\n */\n#ifndef __latent_entropy\n# define __latent_entropy\n#endif\n\n#ifndef __randomize_layout\n# define __randomize_layout __designated_init\n#endif\n\n#ifndef __no_randomize_layout\n# define __no_randomize_layout\n#endif\n\n#ifndef randomized_struct_fields_start\n# define randomized_struct_fields_start\n# define randomized_struct_fields_end\n#endif\n\n#ifndef __noscs\n# define __noscs\n#endif\n\n#ifndef asm_volatile_goto\n#define asm_volatile_goto(x...) asm goto(x)\n#endif\n\n#ifdef CONFIG_CC_HAS_ASM_INLINE\n#define asm_inline asm __inline\n#else\n#define asm_inline asm\n#endif\n\n#ifndef __no_fgcse\n# define __no_fgcse\n#endif\n\n/* Are two types/vars the same type (ignoring qualifiers)? */\n#define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))\n\n/*\n * __unqual_scalar_typeof(x) - Declare an unqualified scalar type, leaving\n *\t\t\t       non-scalar types unchanged.\n */\n/*\n * Prefer C11 _Generic for better compile-times and simpler code. Note: 'char'\n * is not type-compatible with 'signed char', and we define a separate case.\n */\n#define __scalar_type_to_expr_cases(type)\t\t\t\t\\\n\t\tunsigned type:\t(unsigned type)0,\t\t\t\\\n\t\tsigned type:\t(signed type)0\n\n#define __unqual_scalar_typeof(x) typeof(\t\t\t\t\\\n\t\t_Generic((x),\t\t\t\t\t\t\\\n\t\t\t char:\t(char)0,\t\t\t\t\\\n\t\t\t __scalar_type_to_expr_cases(char),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(short),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(int),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(long),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(long long),\t\\\n\t\t\t default: (x)))\n\n/* Is this type a native word size -- useful for atomic operations */\n#define __native_word(t) \\\n\t(sizeof(t) == sizeof(char) || sizeof(t) == sizeof(short) || \\\n\t sizeof(t) == sizeof(int) || sizeof(t) == sizeof(long))\n\n/* Compile time object size, -1 for unknown */\n#ifndef __compiletime_object_size\n# define __compiletime_object_size(obj) -1\n#endif\n#ifndef __compiletime_warning\n# define __compiletime_warning(message)\n#endif\n#ifndef __compiletime_error\n# define __compiletime_error(message)\n#endif\n\n#ifdef __OPTIMIZE__\n# define __compiletime_assert(condition, msg, prefix, suffix)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\textern void prefix ## suffix(void) __compiletime_error(msg); \\\n\t\tif (!(condition))\t\t\t\t\t\\\n\t\t\tprefix ## suffix();\t\t\t\t\\\n\t} while (0)\n#else\n# define __compiletime_assert(condition, msg, prefix, suffix) do { } while (0)\n#endif\n\n#define _compiletime_assert(condition, msg, prefix, suffix) \\\n\t__compiletime_assert(condition, msg, prefix, suffix)\n\n/**\n * compiletime_assert - break build and emit msg if condition is false\n * @condition: a compile-time constant condition to check\n * @msg:       a message to emit if condition is false\n *\n * In tradition of POSIX assert, this macro will break the build if the\n * supplied condition is *false*, emitting the supplied error message if the\n * compiler has support to do so.\n */\n#define compiletime_assert(condition, msg) \\\n\t_compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n\n#define compiletime_assert_atomic_type(t)\t\t\t\t\\\n\tcompiletime_assert(__native_word(t),\t\t\t\t\\\n\t\t\"Need native word sized stores/loads for atomicity.\")\n\n/* Helpers for emitting diagnostics in pragmas. */\n#ifndef __diag\n#define __diag(string)\n#endif\n\n#ifndef __diag_GCC\n#define __diag_GCC(version, severity, string)\n#endif\n\n#define __diag_push()\t__diag(push)\n#define __diag_pop()\t__diag(pop)\n\n#define __diag_ignore(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, ignore, option)\n#define __diag_warn(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, warn, option)\n#define __diag_error(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, error, option)\n\n#endif /* __LINUX_COMPILER_TYPES_H */\n"}, "14": {"id": 14, "path": "/src/include/linux/minmax.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_MINMAX_H\n#define _LINUX_MINMAX_H\n\n/*\n * min()/max()/clamp() macros must accomplish three things:\n *\n * - avoid multiple evaluations of the arguments (so side-effects like\n *   \"x++\" happen only once) when non-constant.\n * - perform strict type-checking (to generate warnings instead of\n *   nasty runtime surprises). See the \"unnecessary\" pointer comparison\n *   in __typecheck().\n * - retain result as a constant expressions when called with only\n *   constant expressions (to avoid tripping VLA warnings in stack\n *   allocation usage).\n */\n#define __typecheck(x, y) \\\n\t(!!(sizeof((typeof(x) *)1 == (typeof(y) *)1)))\n\n/*\n * This returns a constant expression while determining if an argument is\n * a constant expression, most importantly without evaluating the argument.\n * Glory to Martin Uecker <Martin.Uecker@med.uni-goettingen.de>\n */\n#define __is_constexpr(x) \\\n\t(sizeof(int) == sizeof(*(8 ? ((void *)((long)(x) * 0l)) : (int *)8)))\n\n#define __no_side_effects(x, y) \\\n\t\t(__is_constexpr(x) && __is_constexpr(y))\n\n#define __safe_cmp(x, y) \\\n\t\t(__typecheck(x, y) && __no_side_effects(x, y))\n\n#define __cmp(x, y, op)\t((x) op (y) ? (x) : (y))\n\n#define __cmp_once(x, y, unique_x, unique_y, op) ({\t\\\n\t\ttypeof(x) unique_x = (x);\t\t\\\n\t\ttypeof(y) unique_y = (y);\t\t\\\n\t\t__cmp(unique_x, unique_y, op); })\n\n#define __careful_cmp(x, y, op) \\\n\t__builtin_choose_expr(__safe_cmp(x, y), \\\n\t\t__cmp(x, y, op), \\\n\t\t__cmp_once(x, y, __UNIQUE_ID(__x), __UNIQUE_ID(__y), op))\n\n/**\n * min - return minimum of two values of the same or compatible types\n * @x: first value\n * @y: second value\n */\n#define min(x, y)\t__careful_cmp(x, y, <)\n\n/**\n * max - return maximum of two values of the same or compatible types\n * @x: first value\n * @y: second value\n */\n#define max(x, y)\t__careful_cmp(x, y, >)\n\n/**\n * min3 - return minimum of three values\n * @x: first value\n * @y: second value\n * @z: third value\n */\n#define min3(x, y, z) min((typeof(x))min(x, y), z)\n\n/**\n * max3 - return maximum of three values\n * @x: first value\n * @y: second value\n * @z: third value\n */\n#define max3(x, y, z) max((typeof(x))max(x, y), z)\n\n/**\n * min_not_zero - return the minimum that is _not_ zero, unless both are zero\n * @x: value1\n * @y: value2\n */\n#define min_not_zero(x, y) ({\t\t\t\\\n\ttypeof(x) __x = (x);\t\t\t\\\n\ttypeof(y) __y = (y);\t\t\t\\\n\t__x == 0 ? __y : ((__y == 0) ? __x : min(__x, __y)); })\n\n/**\n * clamp - return a value clamped to a given range with strict typechecking\n * @val: current value\n * @lo: lowest allowable value\n * @hi: highest allowable value\n *\n * This macro does strict typechecking of @lo/@hi to make sure they are of the\n * same type as @val.  See the unnecessary pointer comparisons.\n */\n#define clamp(val, lo, hi) min((typeof(val))max(val, lo), hi)\n\n/*\n * ..and if you can't take the strict\n * types, you can specify one yourself.\n *\n * Or not use min/max/clamp at all, of course.\n */\n\n/**\n * min_t - return minimum of two values, using the specified type\n * @type: data type to use\n * @x: first value\n * @y: second value\n */\n#define min_t(type, x, y)\t__careful_cmp((type)(x), (type)(y), <)\n\n/**\n * max_t - return maximum of two values, using the specified type\n * @type: data type to use\n * @x: first value\n * @y: second value\n */\n#define max_t(type, x, y)\t__careful_cmp((type)(x), (type)(y), >)\n\n/**\n * clamp_t - return a value clamped to a given range using a given type\n * @type: the type of variable to use\n * @val: current value\n * @lo: minimum allowable value\n * @hi: maximum allowable value\n *\n * This macro does no typechecking and uses temporary variables of type\n * @type to make all the comparisons.\n */\n#define clamp_t(type, val, lo, hi) min_t(type, max_t(type, val, lo), hi)\n\n/**\n * clamp_val - return a value clamped to a given range using val's type\n * @val: current value\n * @lo: minimum allowable value\n * @hi: maximum allowable value\n *\n * This macro does no typechecking and uses temporary variables of whatever\n * type the input argument @val is.  This is useful when @val is an unsigned\n * type and @lo and @hi are literals that will otherwise be assigned a signed\n * integer type.\n */\n#define clamp_val(val, lo, hi) clamp_t(typeof(val), val, lo, hi)\n\n/**\n * swap - swap values of @a and @b\n * @a: first value\n * @b: second value\n */\n#define swap(a, b) \\\n\tdo { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)\n\n#endif\t/* _LINUX_MINMAX_H */\n"}}, "reports": [{"events": [{"location": {"col": 6, "file": 0, "line": 3739}, "message": "Assuming field 'inode' is null"}, {"location": {"col": 16, "file": 0, "line": 3739}, "message": "Left side of '&&' is false"}, {"location": {"col": 7, "file": 0, "line": 3745}, "message": "Assuming the condition is false"}, {"location": {"col": 62, "file": 0, "line": 3745}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 3751}, "message": "Assuming 'retval' is 0"}, {"location": {"col": 2, "file": 0, "line": 3751}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3754}, "message": "Assuming 'retval' is 0"}, {"location": {"col": 2, "file": 0, "line": 3754}, "message": "Taking false branch"}, {"location": {"col": 10, "file": 0, "line": 3759}, "message": "Field 'inode' is null"}, {"location": {"col": 2, "file": 0, "line": 3759}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 3766}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3775}, "message": "Assuming field 'bh' is non-null"}, {"location": {"col": 6, "file": 0, "line": 3775}, "message": "Left side of '||' is false"}, {"location": {"col": 17, "file": 0, "line": 3775}, "message": "Assuming field 'inode' is equal to field 'i_ino'"}, {"location": {"col": 21, "file": 1, "line": 89}, "message": "expanded from macro 'le32_to_cpu'"}, {"location": {"col": 26, "file": 2, "line": 34}, "message": "expanded from macro '__le32_to_cpu'"}, {"location": {"col": 2, "file": 0, "line": 3775}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 3780}, "message": "Taking false branch"}, {"location": {"col": 10, "file": 0, "line": 3785}, "message": "Field 'bh' is null"}, {"location": {"col": 2, "file": 0, "line": 3785}, "message": "Taking false branch"}, {"location": {"col": 10, "file": 0, "line": 3791}, "message": "Field 'inode' is null"}, {"location": {"col": 16, "file": 0, "line": 3791}, "message": "Left side of '&&' is false"}, {"location": {"col": 17, "file": 0, "line": 3794}, "message": "'?' condition is false"}, {"location": {"col": 37, "file": 3, "line": 48}, "message": "expanded from macro 'EXT4_DATA_TRANS_BLOCKS'"}, {"location": {"col": 3, "file": 3, "line": 34}, "message": "expanded from macro 'EXT4_SINGLEDATA_TRANS_BLOCKS'"}, {"location": {"col": 17, "file": 0, "line": 3794}, "message": "Assuming the condition is false"}, {"location": {"col": 7, "file": 3, "line": 50}, "message": "expanded from macro 'EXT4_DATA_TRANS_BLOCKS'"}, {"location": {"col": 57, "file": 3, "line": 107}, "message": "expanded from macro 'EXT4_MAXQUOTAS_TRANS_BLOCKS'"}, {"location": {"col": 39, "file": 3, "line": 89}, "message": "expanded from macro 'EXT4_QUOTA_TRANS_BLOCKS'"}, {"location": {"col": 29, "file": 4, "line": 1250}, "message": "expanded from macro 'test_opt'"}, {"location": {"col": 17, "file": 0, "line": 3794}, "message": "Left side of '||' is false"}, {"location": {"col": 7, "file": 3, "line": 50}, "message": "expanded from macro 'EXT4_DATA_TRANS_BLOCKS'"}, {"location": {"col": 57, "file": 3, "line": 107}, "message": "expanded from macro 'EXT4_MAXQUOTAS_TRANS_BLOCKS'"}, {"location": {"col": 39, "file": 3, "line": 89}, "message": "expanded from macro 'EXT4_QUOTA_TRANS_BLOCKS'"}, {"location": {"col": 28, "file": 4, "line": 1250}, "message": "expanded from macro 'test_opt'"}, {"location": {"col": 17, "file": 0, "line": 3794}, "message": "'?' condition is false"}, {"location": {"col": 7, "file": 3, "line": 50}, "message": "expanded from macro 'EXT4_DATA_TRANS_BLOCKS'"}, {"location": {"col": 57, "file": 3, "line": 107}, "message": "expanded from macro 'EXT4_MAXQUOTAS_TRANS_BLOCKS'"}, {"location": {"col": 38, "file": 3, "line": 89}, "message": "expanded from macro 'EXT4_QUOTA_TRANS_BLOCKS'"}, {"location": {"col": 6, "file": 0, "line": 3796}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 3796}, "message": "Taking false branch"}, {"location": {"col": 3, "file": 0, "line": 3805}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3812}, "message": "Assuming the condition is false"}, {"location": {"col": 28, "file": 5, "line": 1998}, "message": "expanded from macro 'IS_DIRSYNC'"}, {"location": {"col": 31, "file": 5, "line": 1992}, "message": "expanded from macro '__IS_FLG'"}, {"location": {"col": 6, "file": 0, "line": 3812}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 5, "line": 1998}, "message": "expanded from macro 'IS_DIRSYNC'"}, {"location": {"col": 30, "file": 5, "line": 1992}, "message": "expanded from macro '__IS_FLG'"}, {"location": {"col": 6, "file": 0, "line": 3812}, "message": "Assuming the condition is false"}, {"location": {"col": 7, "file": 5, "line": 1999}, "message": "expanded from macro 'IS_DIRSYNC'"}, {"location": {"col": 6, "file": 0, "line": 3812}, "message": "Left side of '||' is false"}, {"location": {"col": 27, "file": 5, "line": 1998}, "message": "expanded from macro 'IS_DIRSYNC'"}, {"location": {"col": 29, "file": 0, "line": 3812}, "message": "Assuming the condition is false"}, {"location": {"col": 28, "file": 5, "line": 1998}, "message": "expanded from macro 'IS_DIRSYNC'"}, {"location": {"col": 31, "file": 5, "line": 1992}, "message": "expanded from macro '__IS_FLG'"}, {"location": {"col": 29, "file": 0, "line": 3812}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 5, "line": 1998}, "message": "expanded from macro 'IS_DIRSYNC'"}, {"location": {"col": 30, "file": 5, "line": 1992}, "message": "expanded from macro '__IS_FLG'"}, {"location": {"col": 29, "file": 0, "line": 3812}, "message": "Assuming the condition is false"}, {"location": {"col": 7, "file": 5, "line": 1999}, "message": "expanded from macro 'IS_DIRSYNC'"}, {"location": {"col": 2, "file": 0, "line": 3812}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3815}, "message": "Assuming the condition is false"}, {"location": {"col": 21, "file": 6, "line": 23}, "message": "expanded from macro 'S_ISDIR'"}, {"location": {"col": 2, "file": 0, "line": 3815}, "message": "Taking false branch"}, {"location": {"col": 18, "file": 0, "line": 3836}, "message": "Assuming 'new.dir->i_ino' is not equal to 'old.dir->i_ino'"}, {"location": {"col": 51, "file": 0, "line": 3836}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 3840}, "message": "'whiteout' is non-null"}, {"location": {"col": 2, "file": 0, "line": 3840}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 3847}, "message": "Assuming 'retval' is 0"}, {"location": {"col": 3, "file": 0, "line": 3847}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 3850}, "message": "Assuming 'retval' is 0"}, {"location": {"col": 40, "file": 7, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 3, "file": 0, "line": 3850}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 3853}, "message": "Field 'bh' is null"}, {"location": {"col": 2, "file": 0, "line": 3853}, "message": "Taking true branch"}, {"location": {"col": 12, "file": 0, "line": 3854}, "message": "Calling 'ext4_add_entry'"}, {"location": {"col": 6, "file": 0, "line": 2193}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 2193}, "message": "Taking false branch"}, {"location": {"col": 22, "file": 0, "line": 2198}, "message": "Field 'len' is not equal to 0"}, {"location": {"col": 2, "file": 0, "line": 2198}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 2209}, "message": "'retval' is 0"}, {"location": {"col": 2, "file": 0, "line": 2209}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 2212}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 2222}, "message": "Left side of '&&' is true"}, {"location": {"col": 21, "file": 4, "line": 2256}, "message": "expanded from macro 'is_dx'"}, {"location": {"col": 6, "file": 0, "line": 2222}, "message": "Assuming the condition is true"}, {"location": {"col": 7, "file": 4, "line": 2257}, "message": "expanded from macro 'is_dx'"}, {"location": {"col": 2, "file": 0, "line": 2222}, "message": "Taking true branch"}, {"location": {"col": 12, "file": 0, "line": 2223}, "message": "Calling 'ext4_dx_add_entry'"}, {"location": {"col": 6, "file": 0, "line": 2306}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 8, "line": 36}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 8, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 7, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 8, "line": 36}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 2306}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 2, "file": 0, "line": 2306}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 2311}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 8, "line": 36}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 8, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 7, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 8, "line": 36}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 2311}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 2, "file": 0, "line": 2311}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 2317}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 32, "file": 9, "line": 1769}, "message": "expanded from macro 'BUFFER_TRACE'"}, {"location": {"col": 6, "file": 0, "line": 2319}, "message": "Assuming 'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 2319}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 2323}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 2331}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 2331}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 2442}, "message": "Calling 'do_split'"}, {"location": {"col": 6, "file": 0, "line": 1832}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1832}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1836}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1842}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 32, "file": 9, "line": 1769}, "message": "expanded from macro 'BUFFER_TRACE'"}, {"location": {"col": 6, "file": 0, "line": 1844}, "message": "Assuming 'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 1844}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1847}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 32, "file": 9, "line": 1769}, "message": "expanded from macro 'BUFFER_TRACE'"}, {"location": {"col": 6, "file": 0, "line": 1849}, "message": "Assuming 'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 1849}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1863}, "message": "Loop condition is false. Execution continues on line 1877"}, {"location": {"col": 6, "file": 0, "line": 1877}, "message": "'i' is <= 0"}, {"location": {"col": 2, "file": 0, "line": 1877}, "message": "Taking false branch"}, {"location": {"col": 14, "file": 0, "line": 1883}, "message": "Assuming 'hash2' is not equal to field 'hash'"}, {"location": {"col": 6, "file": 0, "line": 1898}, "message": "'csum_size' is 0"}, {"location": {"col": 2, "file": 0, "line": 1898}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1909}, "message": "Assuming 'hash2' is > field 'hash'"}, {"location": {"col": 2, "file": 0, "line": 1909}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1915}, "message": "Assuming 'err' is not equal to 0"}, {"location": {"col": 2, "file": 0, "line": 1915}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 1916}, "message": "Control jumps to line 1925"}, {"location": {"col": 2, "file": 0, "line": 1927}, "message": "Null pointer value stored to 'bh'"}, {"location": {"col": 28, "file": 0, "line": 1928}, "message": "'err' is not equal to 0"}, {"location": {"col": 7, "file": 4, "line": 3211}, "message": "expanded from macro 'ext4_std_error'"}, {"location": {"col": 2, "file": 0, "line": 1928}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 4, "line": 3211}, "message": "expanded from macro 'ext4_std_error'"}, {"location": {"col": 2, "file": 0, "line": 1928}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 38, "file": 4, "line": 3209}, "message": "expanded from macro 'ext4_std_error'"}, {"location": {"col": 7, "file": 0, "line": 2442}, "message": "Returning from 'do_split'"}, {"location": {"col": 6, "file": 0, "line": 2443}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 8, "line": 36}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 8, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 7, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 8, "line": 36}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 2443}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 2, "file": 0, "line": 2443}, "message": "Taking false branch"}, {"location": {"col": 57, "file": 0, "line": 2447}, "message": "Passing null pointer value via 6th parameter 'bh'"}, {"location": {"col": 8, "file": 0, "line": 2447}, "message": "Calling 'add_dirent_to_buf'"}, {"location": {"col": 6, "file": 0, "line": 2007}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 2007}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 2010}, "message": "Assuming 'de' is non-null"}, {"location": {"col": 2, "file": 0, "line": 2010}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 2016}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 32, "file": 9, "line": 1769}, "message": "expanded from macro 'BUFFER_TRACE'"}, {"location": {"col": 6, "file": 0, "line": 2018}, "message": "Assuming 'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 2018}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 2041}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 32, "file": 9, "line": 1769}, "message": "expanded from macro 'BUFFER_TRACE'"}, {"location": {"col": 48, "file": 0, "line": 2042}, "message": "Passing null pointer value via 3rd parameter 'bh'"}, {"location": {"col": 8, "file": 0, "line": 2042}, "message": "Calling 'ext4_handle_dirty_dirblock'"}, {"location": {"col": 32, "file": 0, "line": 410}, "message": "Passing null pointer value via 2nd parameter 'bh'"}, {"location": {"col": 2, "file": 0, "line": 410}, "message": "Calling 'ext4_dirblock_csum_set'"}, {"location": {"col": 6, "file": 0, "line": 393}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 393}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 397}, "message": "Assuming 't' is non-null"}, {"location": {"col": 2, "file": 0, "line": 397}, "message": "Taking false branch"}, {"location": {"col": 46, "file": 0, "line": 402}, "message": "Access to field 'b_data' results in a dereference of a null pointer (loaded from variable 'bh')"}, {"location": {"col": 46, "file": 0, "line": 402}, "message": "Access to field 'b_data' results in a dereference of a null pointer (loaded from variable 'bh')"}], "macros": [], "notes": [], "path": "/src/fs/ext4/namei.c", "reportHash": "20864b18dc55dd91cac6dc061f4ee95c", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 0, "line": 3969}, "message": "Assuming the condition is false"}, {"location": {"col": 61, "file": 0, "line": 3969}, "message": "Left side of '&&' is false"}, {"location": {"col": 7, "file": 0, "line": 3972}, "message": "Assuming the condition is false"}, {"location": {"col": 61, "file": 0, "line": 3972}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 3978}, "message": "Assuming 'retval' is 0"}, {"location": {"col": 2, "file": 0, "line": 3978}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3981}, "message": "Assuming 'retval' is 0"}, {"location": {"col": 2, "file": 0, "line": 3981}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 3984}, "message": "Calling 'ext4_find_entry'"}, {"location": {"col": 8, "file": 0, "line": 1596}, "message": "Calling 'ext4_fname_setup_filename'"}, {"location": {"col": 2, "file": 4, "line": 2641}, "message": "Returning without writing to 'fname->hinfo.hash'"}, {"location": {"col": 8, "file": 0, "line": 1596}, "message": "Returning from 'ext4_fname_setup_filename'"}, {"location": {"col": 2, "file": 0, "line": 1597}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1599}, "message": "'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 1599}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1602}, "message": "Calling '__ext4_find_entry'"}, {"location": {"col": 6, "file": 0, "line": 1462}, "message": "Assuming 'namelen' is <= EXT4_NAME_LEN"}, {"location": {"col": 2, "file": 0, "line": 1462}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1465}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1476}, "message": "Assuming 'namelen' is > 2"}, {"location": {"col": 21, "file": 0, "line": 1476}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 1486}, "message": "Left side of '&&' is true"}, {"location": {"col": 21, "file": 4, "line": 2256}, "message": "expanded from macro 'is_dx'"}, {"location": {"col": 6, "file": 0, "line": 1486}, "message": "Assuming the condition is true"}, {"location": {"col": 7, "file": 4, "line": 2257}, "message": "expanded from macro 'is_dx'"}, {"location": {"col": 2, "file": 0, "line": 1486}, "message": "Taking true branch"}, {"location": {"col": 9, "file": 0, "line": 1487}, "message": "Calling 'ext4_dx_find_entry'"}, {"location": {"col": 10, "file": 0, "line": 1641}, "message": "Calling 'dx_probe'"}, {"location": {"col": 6, "file": 0, "line": 768}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 8, "line": 36}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 8, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 7, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 8, "line": 36}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 768}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 2, "file": 0, "line": 768}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 772}, "message": "Assuming field 'hash_version' is equal to DX_HASH_TEA"}, {"location": {"col": 45, "file": 0, "line": 772}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 779}, "message": "'fname' is non-null"}, {"location": {"col": 2, "file": 0, "line": 779}, "message": "Taking true branch"}, {"location": {"col": 13, "file": 0, "line": 782}, "message": "Field 'hash_version' is <= DX_HASH_TEA"}, {"location": {"col": 2, "file": 0, "line": 782}, "message": "Taking true branch"}, {"location": {"col": 6, "file": 0, "line": 785}, "message": "'fname' is non-null"}, {"location": {"col": 6, "file": 0, "line": 785}, "message": "Left side of '&&' is true"}, {"location": {"col": 15, "file": 0, "line": 785}, "message": "Assuming field 'name' is null"}, {"location": {"col": 23, "file": 4, "line": 2323}, "message": "expanded from macro 'fname_name'"}, {"location": {"col": 2, "file": 0, "line": 785}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 787}, "message": "Assigned value is garbage or undefined"}, {"location": {"col": 7, "file": 0, "line": 787}, "message": "Assigned value is garbage or undefined"}], "macros": [], "notes": [], "path": "/src/fs/ext4/namei.c", "reportHash": "c3837e13a7261a04529926b4d6bbb724", "checkerName": "clang-analyzer-core.uninitialized.Assign", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 0, "line": 3969}, "message": "Assuming the condition is false"}, {"location": {"col": 61, "file": 0, "line": 3969}, "message": "Left side of '&&' is false"}, {"location": {"col": 7, "file": 0, "line": 3972}, "message": "Assuming the condition is false"}, {"location": {"col": 61, "file": 0, "line": 3972}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 3978}, "message": "Assuming 'retval' is 0"}, {"location": {"col": 2, "file": 0, "line": 3978}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3981}, "message": "Assuming 'retval' is 0"}, {"location": {"col": 2, "file": 0, "line": 3981}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 3984}, "message": "Calling 'ext4_find_entry'"}, {"location": {"col": 2, "file": 0, "line": 1597}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1599}, "message": "'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 1599}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1602}, "message": "Calling '__ext4_find_entry'"}, {"location": {"col": 6, "file": 0, "line": 1462}, "message": "Assuming 'namelen' is <= EXT4_NAME_LEN"}, {"location": {"col": 2, "file": 0, "line": 1462}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1465}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1476}, "message": "Assuming 'namelen' is > 2"}, {"location": {"col": 21, "file": 0, "line": 1476}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 1486}, "message": "Left side of '&&' is true"}, {"location": {"col": 21, "file": 4, "line": 2256}, "message": "expanded from macro 'is_dx'"}, {"location": {"col": 6, "file": 0, "line": 1486}, "message": "Assuming the condition is true"}, {"location": {"col": 7, "file": 4, "line": 2257}, "message": "expanded from macro 'is_dx'"}, {"location": {"col": 2, "file": 0, "line": 1486}, "message": "Taking true branch"}, {"location": {"col": 9, "file": 0, "line": 1487}, "message": "Calling 'ext4_dx_find_entry'"}, {"location": {"col": 6, "file": 0, "line": 1642}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 0, "line": 1642}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 1643}, "message": "Address of stack memory associated with local variable 'frames' returned to caller"}, {"location": {"col": 3, "file": 0, "line": 1643}, "message": "Address of stack memory associated with local variable 'frames' returned to caller"}], "macros": [], "notes": [], "path": "/src/fs/ext4/namei.c", "reportHash": "3cdf5e36aef938c226f090a9fd6bcbf6", "checkerName": "clang-analyzer-core.StackAddressEscape", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 0, "line": 3739}, "message": "Assuming field 'inode' is null"}, {"location": {"col": 16, "file": 0, "line": 3739}, "message": "Left side of '&&' is false"}, {"location": {"col": 7, "file": 0, "line": 3745}, "message": "Assuming the condition is false"}, {"location": {"col": 62, "file": 0, "line": 3745}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 3751}, "message": "Assuming 'retval' is 0"}, {"location": {"col": 2, "file": 0, "line": 3751}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3754}, "message": "Assuming 'retval' is 0"}, {"location": {"col": 2, "file": 0, "line": 3754}, "message": "Taking false branch"}, {"location": {"col": 10, "file": 0, "line": 3759}, "message": "Field 'inode' is null"}, {"location": {"col": 2, "file": 0, "line": 3759}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 3766}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3775}, "message": "Assuming field 'bh' is non-null"}, {"location": {"col": 6, "file": 0, "line": 3775}, "message": "Left side of '||' is false"}, {"location": {"col": 17, "file": 0, "line": 3775}, "message": "Assuming field 'inode' is equal to field 'i_ino'"}, {"location": {"col": 21, "file": 1, "line": 89}, "message": "expanded from macro 'le32_to_cpu'"}, {"location": {"col": 26, "file": 2, "line": 34}, "message": "expanded from macro '__le32_to_cpu'"}, {"location": {"col": 2, "file": 0, "line": 3775}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 3780}, "message": "Taking false branch"}, {"location": {"col": 10, "file": 0, "line": 3785}, "message": "Field 'bh' is null"}, {"location": {"col": 2, "file": 0, "line": 3785}, "message": "Taking false branch"}, {"location": {"col": 10, "file": 0, "line": 3791}, "message": "Field 'inode' is null"}, {"location": {"col": 16, "file": 0, "line": 3791}, "message": "Left side of '&&' is false"}, {"location": {"col": 17, "file": 0, "line": 3794}, "message": "'?' condition is false"}, {"location": {"col": 37, "file": 3, "line": 48}, "message": "expanded from macro 'EXT4_DATA_TRANS_BLOCKS'"}, {"location": {"col": 3, "file": 3, "line": 34}, "message": "expanded from macro 'EXT4_SINGLEDATA_TRANS_BLOCKS'"}, {"location": {"col": 17, "file": 0, "line": 3794}, "message": "Assuming the condition is false"}, {"location": {"col": 7, "file": 3, "line": 50}, "message": "expanded from macro 'EXT4_DATA_TRANS_BLOCKS'"}, {"location": {"col": 57, "file": 3, "line": 107}, "message": "expanded from macro 'EXT4_MAXQUOTAS_TRANS_BLOCKS'"}, {"location": {"col": 39, "file": 3, "line": 89}, "message": "expanded from macro 'EXT4_QUOTA_TRANS_BLOCKS'"}, {"location": {"col": 29, "file": 4, "line": 1250}, "message": "expanded from macro 'test_opt'"}, {"location": {"col": 17, "file": 0, "line": 3794}, "message": "Left side of '||' is false"}, {"location": {"col": 7, "file": 3, "line": 50}, "message": "expanded from macro 'EXT4_DATA_TRANS_BLOCKS'"}, {"location": {"col": 57, "file": 3, "line": 107}, "message": "expanded from macro 'EXT4_MAXQUOTAS_TRANS_BLOCKS'"}, {"location": {"col": 39, "file": 3, "line": 89}, "message": "expanded from macro 'EXT4_QUOTA_TRANS_BLOCKS'"}, {"location": {"col": 28, "file": 4, "line": 1250}, "message": "expanded from macro 'test_opt'"}, {"location": {"col": 17, "file": 0, "line": 3794}, "message": "'?' condition is false"}, {"location": {"col": 7, "file": 3, "line": 50}, "message": "expanded from macro 'EXT4_DATA_TRANS_BLOCKS'"}, {"location": {"col": 57, "file": 3, "line": 107}, "message": "expanded from macro 'EXT4_MAXQUOTAS_TRANS_BLOCKS'"}, {"location": {"col": 38, "file": 3, "line": 89}, "message": "expanded from macro 'EXT4_QUOTA_TRANS_BLOCKS'"}, {"location": {"col": 6, "file": 0, "line": 3796}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 3796}, "message": "Taking false branch"}, {"location": {"col": 3, "file": 0, "line": 3805}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3812}, "message": "Assuming the condition is false"}, {"location": {"col": 28, "file": 5, "line": 1998}, "message": "expanded from macro 'IS_DIRSYNC'"}, {"location": {"col": 31, "file": 5, "line": 1992}, "message": "expanded from macro '__IS_FLG'"}, {"location": {"col": 6, "file": 0, "line": 3812}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 5, "line": 1998}, "message": "expanded from macro 'IS_DIRSYNC'"}, {"location": {"col": 30, "file": 5, "line": 1992}, "message": "expanded from macro '__IS_FLG'"}, {"location": {"col": 6, "file": 0, "line": 3812}, "message": "Assuming the condition is false"}, {"location": {"col": 7, "file": 5, "line": 1999}, "message": "expanded from macro 'IS_DIRSYNC'"}, {"location": {"col": 6, "file": 0, "line": 3812}, "message": "Left side of '||' is false"}, {"location": {"col": 27, "file": 5, "line": 1998}, "message": "expanded from macro 'IS_DIRSYNC'"}, {"location": {"col": 29, "file": 0, "line": 3812}, "message": "Assuming the condition is false"}, {"location": {"col": 28, "file": 5, "line": 1998}, "message": "expanded from macro 'IS_DIRSYNC'"}, {"location": {"col": 31, "file": 5, "line": 1992}, "message": "expanded from macro '__IS_FLG'"}, {"location": {"col": 29, "file": 0, "line": 3812}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 5, "line": 1998}, "message": "expanded from macro 'IS_DIRSYNC'"}, {"location": {"col": 30, "file": 5, "line": 1992}, "message": "expanded from macro '__IS_FLG'"}, {"location": {"col": 29, "file": 0, "line": 3812}, "message": "Assuming the condition is false"}, {"location": {"col": 7, "file": 5, "line": 1999}, "message": "expanded from macro 'IS_DIRSYNC'"}, {"location": {"col": 2, "file": 0, "line": 3812}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3815}, "message": "Assuming the condition is false"}, {"location": {"col": 21, "file": 6, "line": 23}, "message": "expanded from macro 'S_ISDIR'"}, {"location": {"col": 2, "file": 0, "line": 3815}, "message": "Taking false branch"}, {"location": {"col": 18, "file": 0, "line": 3836}, "message": "Assuming 'new.dir->i_ino' is not equal to 'old.dir->i_ino'"}, {"location": {"col": 51, "file": 0, "line": 3836}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 3840}, "message": "'whiteout' is non-null"}, {"location": {"col": 2, "file": 0, "line": 3840}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 3847}, "message": "Assuming 'retval' is 0"}, {"location": {"col": 3, "file": 0, "line": 3847}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 3850}, "message": "Assuming 'retval' is 0"}, {"location": {"col": 40, "file": 7, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 3, "file": 0, "line": 3850}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 3853}, "message": "Field 'bh' is null"}, {"location": {"col": 2, "file": 0, "line": 3853}, "message": "Taking true branch"}, {"location": {"col": 12, "file": 0, "line": 3854}, "message": "Calling 'ext4_add_entry'"}, {"location": {"col": 6, "file": 0, "line": 2193}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 2193}, "message": "Taking false branch"}, {"location": {"col": 22, "file": 0, "line": 2198}, "message": "Field 'len' is not equal to 0"}, {"location": {"col": 2, "file": 0, "line": 2198}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 2209}, "message": "'retval' is 0"}, {"location": {"col": 2, "file": 0, "line": 2209}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 2212}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 2222}, "message": "Left side of '&&' is true"}, {"location": {"col": 21, "file": 4, "line": 2256}, "message": "expanded from macro 'is_dx'"}, {"location": {"col": 6, "file": 0, "line": 2222}, "message": "Assuming the condition is true"}, {"location": {"col": 7, "file": 4, "line": 2257}, "message": "expanded from macro 'is_dx'"}, {"location": {"col": 2, "file": 0, "line": 2222}, "message": "Taking true branch"}, {"location": {"col": 12, "file": 0, "line": 2223}, "message": "Calling 'ext4_dx_add_entry'"}, {"location": {"col": 6, "file": 0, "line": 2306}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 8, "line": 36}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 8, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 7, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 8, "line": 36}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 2306}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 2, "file": 0, "line": 2306}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 2311}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 8, "line": 36}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 8, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 7, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 8, "line": 36}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 2311}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 2, "file": 0, "line": 2311}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 2317}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 32, "file": 9, "line": 1769}, "message": "expanded from macro 'BUFFER_TRACE'"}, {"location": {"col": 6, "file": 0, "line": 2319}, "message": "Assuming 'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 2319}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 2323}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 2331}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 2331}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 2442}, "message": "Calling 'do_split'"}, {"location": {"col": 6, "file": 0, "line": 1832}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1832}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1836}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1842}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 32, "file": 9, "line": 1769}, "message": "expanded from macro 'BUFFER_TRACE'"}, {"location": {"col": 6, "file": 0, "line": 1844}, "message": "Assuming 'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 1844}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1847}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 32, "file": 9, "line": 1769}, "message": "expanded from macro 'BUFFER_TRACE'"}, {"location": {"col": 6, "file": 0, "line": 1849}, "message": "Assuming 'err' is not equal to 0"}, {"location": {"col": 2, "file": 0, "line": 1849}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 1850}, "message": "Control jumps to line 1925"}, {"location": {"col": 2, "file": 0, "line": 1927}, "message": "Null pointer value stored to 'bh'"}, {"location": {"col": 28, "file": 0, "line": 1928}, "message": "'err' is not equal to 0"}, {"location": {"col": 7, "file": 4, "line": 3211}, "message": "expanded from macro 'ext4_std_error'"}, {"location": {"col": 2, "file": 0, "line": 1928}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 4, "line": 3211}, "message": "expanded from macro 'ext4_std_error'"}, {"location": {"col": 2, "file": 0, "line": 1928}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 38, "file": 4, "line": 3209}, "message": "expanded from macro 'ext4_std_error'"}, {"location": {"col": 7, "file": 0, "line": 2442}, "message": "Returning from 'do_split'"}, {"location": {"col": 6, "file": 0, "line": 2443}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 8, "line": 36}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 8, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 7, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 8, "line": 36}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 2443}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 2, "file": 0, "line": 2443}, "message": "Taking false branch"}, {"location": {"col": 57, "file": 0, "line": 2447}, "message": "Passing null pointer value via 6th parameter 'bh'"}, {"location": {"col": 8, "file": 0, "line": 2447}, "message": "Calling 'add_dirent_to_buf'"}, {"location": {"col": 6, "file": 0, "line": 2007}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 2007}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 2010}, "message": "Assuming 'de' is null"}, {"location": {"col": 2, "file": 0, "line": 2010}, "message": "Taking true branch"}, {"location": {"col": 43, "file": 0, "line": 2011}, "message": "Access to field 'b_data' results in a dereference of a null pointer (loaded from variable 'bh')"}, {"location": {"col": 43, "file": 0, "line": 2011}, "message": "Access to field 'b_data' results in a dereference of a null pointer (loaded from variable 'bh')"}], "macros": [], "notes": [], "path": "/src/fs/ext4/namei.c", "reportHash": "380c8b45dfab44eb7cfdfa45119d5ce5", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 0, "line": 2326}, "message": "Value stored to 'err' is never read"}, {"location": {"col": 2, "file": 0, "line": 2326}, "message": "Value stored to 'err' is never read"}], "macros": [], "notes": [], "path": "/src/fs/ext4/namei.c", "reportHash": "980edd5f6efd2276b6e4cd404b0363d5", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 0, "line": 2398}, "message": "Although the value stored to 'at' is used in the enclosing expression, the value is never actually read from 'at'"}, {"location": {"col": 17, "file": 0, "line": 2398}, "message": "Although the value stored to 'at' is used in the enclosing expression, the value is never actually read from 'at'"}], "macros": [], "notes": [], "path": "/src/fs/ext4/namei.c", "reportHash": "ec311fc61e398a84bf052ceb26d1fff8", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 0, "line": 2399}, "message": "Although the value stored to 'entries' is used in the enclosing expression, the value is never actually read from 'entries'"}, {"location": {"col": 22, "file": 0, "line": 2399}, "message": "Although the value stored to 'entries' is used in the enclosing expression, the value is never actually read from 'entries'"}], "macros": [], "notes": [], "path": "/src/fs/ext4/namei.c", "reportHash": "ae564535d437c2904a9d0f0b41dce8bd", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 0, "line": 3247}, "message": "Value stored to 'retval' is never read"}, {"location": {"col": 3, "file": 0, "line": 3247}, "message": "Value stored to 'retval' is never read"}], "macros": [], "notes": [], "path": "/src/fs/ext4/namei.c", "reportHash": "75e30cf3a590b5e269b5a5561b007e02", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 1, "line": 89}, "message": "expanded from macro 'le32_to_cpu'"}, {"location": {"col": 50, "file": 2, "line": 34}, "message": "expanded from macro '__le32_to_cpu'"}, {"location": {"col": 6, "file": 0, "line": 3739}, "message": "Assuming field 'inode' is null"}, {"location": {"col": 16, "file": 0, "line": 3739}, "message": "Left side of '&&' is false"}, {"location": {"col": 7, "file": 0, "line": 3745}, "message": "Assuming the condition is false"}, {"location": {"col": 62, "file": 0, "line": 3745}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 3751}, "message": "Assuming 'retval' is 0"}, {"location": {"col": 2, "file": 0, "line": 3751}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3754}, "message": "Assuming 'retval' is 0"}, {"location": {"col": 2, "file": 0, "line": 3754}, "message": "Taking false branch"}, {"location": {"col": 10, "file": 0, "line": 3759}, "message": "Field 'inode' is null"}, {"location": {"col": 2, "file": 0, "line": 3759}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 3765}, "message": "Calling 'ext4_find_entry'"}, {"location": {"col": 8, "file": 0, "line": 1596}, "message": "Calling 'ext4_fname_setup_filename'"}, {"location": {"col": 2, "file": 4, "line": 2641}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 8, "file": 0, "line": 1596}, "message": "Returning from 'ext4_fname_setup_filename'"}, {"location": {"col": 2, "file": 0, "line": 1597}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1599}, "message": "'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 1599}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1602}, "message": "Calling '__ext4_find_entry'"}, {"location": {"col": 2, "file": 0, "line": 1459}, "message": "Null pointer value stored to 'old.de'"}, {"location": {"col": 6, "file": 0, "line": 1462}, "message": "Assuming 'namelen' is <= EXT4_NAME_LEN"}, {"location": {"col": 2, "file": 0, "line": 1462}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1465}, "message": "Calling 'ext4_has_inline_data'"}, {"location": {"col": 9, "file": 4, "line": 3445}, "message": "Assuming the condition is false"}, {"location": {"col": 61, "file": 4, "line": 3445}, "message": "Left side of '&&' is false"}, {"location": {"col": 2, "file": 4, "line": 3445}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 1465}, "message": "Returning from 'ext4_has_inline_data'"}, {"location": {"col": 2, "file": 0, "line": 1465}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1476}, "message": "Assuming 'namelen' is > 2"}, {"location": {"col": 21, "file": 0, "line": 1476}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 1486}, "message": "Calling 'ext4_has_feature_dir_index'"}, {"location": {"col": 21, "file": 4, "line": 2256}, "message": "expanded from macro 'is_dx'"}, {"location": {"col": 1, "file": 4, "line": 1976}, "message": "Assuming the condition is false"}, {"location": {"col": 10, "file": 4, "line": 1920}, "message": "expanded from macro 'EXT4_FEATURE_COMPAT_FUNCS'"}, {"location": {"col": 1, "file": 4, "line": 1976}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 2, "file": 4, "line": 1920}, "message": "expanded from macro 'EXT4_FEATURE_COMPAT_FUNCS'"}, {"location": {"col": 6, "file": 0, "line": 1486}, "message": "Returning from 'ext4_has_feature_dir_index'"}, {"location": {"col": 21, "file": 4, "line": 2256}, "message": "expanded from macro 'is_dx'"}, {"location": {"col": 6, "file": 0, "line": 1486}, "message": "Left side of '&&' is false"}, {"location": {"col": 61, "file": 4, "line": 2256}, "message": "expanded from macro 'is_dx'"}, {"location": {"col": 6, "file": 0, "line": 1500}, "message": "Assuming 'nblocks' is not equal to 0, which participates in a condition later"}, {"location": {"col": 2, "file": 0, "line": 1500}, "message": "Taking false branch"}, {"location": {"col": 10, "file": 0, "line": 1504}, "message": "Left side of '&&' is false"}, {"location": {"col": 24, "file": 10, "line": 22}, "message": "expanded from macro 'EXT4_I'"}, {"location": {"col": 61, "file": 11, "line": 853}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 10, "file": 0, "line": 1504}, "message": "Taking false branch"}, {"location": {"col": 24, "file": 10, "line": 22}, "message": "expanded from macro 'EXT4_I'"}, {"location": {"col": 2, "file": 11, "line": 853}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 37, "file": 12, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 13, "line": 319}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 13, "line": 307}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 3, "file": 13, "line": 299}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 10, "file": 0, "line": 1504}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 24, "file": 10, "line": 22}, "message": "expanded from macro 'EXT4_I'"}, {"location": {"col": 2, "file": 11, "line": 853}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 37, "file": 12, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 13, "line": 319}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 13, "line": 307}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 2, "file": 13, "line": 297}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 6, "file": 0, "line": 1505}, "message": "Assuming 'start' is < 'nblocks'"}, {"location": {"col": 2, "file": 0, "line": 1505}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1514}, "message": "'ra_ptr' is >= 'ra_max'"}, {"location": {"col": 3, "file": 0, "line": 1514}, "message": "Taking true branch"}, {"location": {"col": 8, "file": 0, "line": 1517}, "message": "'block' is >= 'start'"}, {"location": {"col": 4, "file": 0, "line": 1517}, "message": "Taking false branch"}, {"location": {"col": 13, "file": 0, "line": 1521}, "message": "Assuming '__UNIQUE_ID___x1168' is >= '__UNIQUE_ID___y1169'"}, {"location": {"col": 19, "file": 14, "line": 51}, "message": "expanded from macro 'min'"}, {"location": {"col": 3, "file": 14, "line": 44}, "message": "expanded from macro '__careful_cmp'"}, {"location": {"col": 3, "file": 14, "line": 39}, "message": "expanded from macro '__cmp_once'"}, {"location": {"col": 26, "file": 14, "line": 34}, "message": "expanded from macro '__cmp'"}, {"location": {"col": 13, "file": 0, "line": 1521}, "message": "'?' condition is false"}, {"location": {"col": 19, "file": 14, "line": 51}, "message": "expanded from macro 'min'"}, {"location": {"col": 3, "file": 14, "line": 44}, "message": "expanded from macro '__careful_cmp'"}, {"location": {"col": 3, "file": 14, "line": 39}, "message": "expanded from macro '__cmp_once'"}, {"location": {"col": 26, "file": 14, "line": 34}, "message": "expanded from macro '__cmp'"}, {"location": {"col": 8, "file": 0, "line": 1524}, "message": "Assuming 'retval' is not equal to 0"}, {"location": {"col": 4, "file": 0, "line": 1524}, "message": "Taking true branch"}, {"location": {"col": 5, "file": 0, "line": 1527}, "message": "Control jumps to line 1582"}, {"location": {"col": 2, "file": 0, "line": 1582}, "message": "Loop condition is false. Execution continues on line 1584"}, {"location": {"col": 2, "file": 0, "line": 1584}, "message": "Returning pointer (loaded from 'ret'), which participates in a condition later"}, {"location": {"col": 7, "file": 0, "line": 1602}, "message": "Returning from '__ext4_find_entry'"}, {"location": {"col": 2, "file": 0, "line": 1605}, "message": "Returning pointer (loaded from 'bh'), which participates in a condition later"}, {"location": {"col": 11, "file": 0, "line": 3765}, "message": "Returning from 'ext4_find_entry'"}, {"location": {"col": 6, "file": 0, "line": 3766}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 8, "line": 36}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 8, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 7, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 8, "line": 36}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 3766}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 2, "file": 0, "line": 3766}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3775}, "message": "Assuming field 'bh' is non-null"}, {"location": {"col": 6, "file": 0, "line": 3775}, "message": "Left side of '||' is false"}, {"location": {"col": 17, "file": 0, "line": 3775}, "message": "Access to field 'inode' results in a dereference of a null pointer (loaded from field 'de')"}, {"location": {"col": 21, "file": 1, "line": 89}, "message": "expanded from macro 'le32_to_cpu'"}, {"location": {"col": 50, "file": 2, "line": 34}, "message": "expanded from macro '__le32_to_cpu'"}, {"location": {"col": 17, "file": 0, "line": 3775}, "message": "Access to field 'inode' results in a dereference of a null pointer (loaded from field 'de')"}], "macros": [], "notes": [], "path": "/src/fs/ext4/namei.c", "reportHash": "f007f4f6e4bc49d0aeb49a920423b229", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 1, "line": 89}, "message": "expanded from macro 'le32_to_cpu'"}, {"location": {"col": 50, "file": 2, "line": 34}, "message": "expanded from macro '__le32_to_cpu'"}, {"location": {"col": 7, "file": 0, "line": 3969}, "message": "Assuming the condition is false"}, {"location": {"col": 61, "file": 0, "line": 3969}, "message": "Left side of '&&' is false"}, {"location": {"col": 7, "file": 0, "line": 3972}, "message": "Assuming the condition is false"}, {"location": {"col": 61, "file": 0, "line": 3972}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 3978}, "message": "Assuming 'retval' is 0"}, {"location": {"col": 2, "file": 0, "line": 3978}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3981}, "message": "Assuming 'retval' is 0"}, {"location": {"col": 2, "file": 0, "line": 3981}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 3984}, "message": "Calling 'ext4_find_entry'"}, {"location": {"col": 8, "file": 0, "line": 1596}, "message": "Calling 'ext4_fname_setup_filename'"}, {"location": {"col": 2, "file": 4, "line": 2641}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 8, "file": 0, "line": 1596}, "message": "Returning from 'ext4_fname_setup_filename'"}, {"location": {"col": 2, "file": 0, "line": 1597}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1599}, "message": "'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 1599}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1602}, "message": "Calling '__ext4_find_entry'"}, {"location": {"col": 2, "file": 0, "line": 1459}, "message": "Null pointer value stored to 'old.de'"}, {"location": {"col": 6, "file": 0, "line": 1462}, "message": "Assuming 'namelen' is <= EXT4_NAME_LEN"}, {"location": {"col": 2, "file": 0, "line": 1462}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1465}, "message": "Calling 'ext4_has_inline_data'"}, {"location": {"col": 9, "file": 4, "line": 3445}, "message": "Assuming the condition is false"}, {"location": {"col": 61, "file": 4, "line": 3445}, "message": "Left side of '&&' is false"}, {"location": {"col": 2, "file": 4, "line": 3445}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 1465}, "message": "Returning from 'ext4_has_inline_data'"}, {"location": {"col": 2, "file": 0, "line": 1465}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1476}, "message": "Assuming 'namelen' is > 2"}, {"location": {"col": 21, "file": 0, "line": 1476}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 1486}, "message": "Calling 'ext4_has_feature_dir_index'"}, {"location": {"col": 21, "file": 4, "line": 2256}, "message": "expanded from macro 'is_dx'"}, {"location": {"col": 1, "file": 4, "line": 1976}, "message": "Assuming the condition is false"}, {"location": {"col": 10, "file": 4, "line": 1920}, "message": "expanded from macro 'EXT4_FEATURE_COMPAT_FUNCS'"}, {"location": {"col": 1, "file": 4, "line": 1976}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 2, "file": 4, "line": 1920}, "message": "expanded from macro 'EXT4_FEATURE_COMPAT_FUNCS'"}, {"location": {"col": 6, "file": 0, "line": 1486}, "message": "Returning from 'ext4_has_feature_dir_index'"}, {"location": {"col": 21, "file": 4, "line": 2256}, "message": "expanded from macro 'is_dx'"}, {"location": {"col": 6, "file": 0, "line": 1486}, "message": "Left side of '&&' is false"}, {"location": {"col": 61, "file": 4, "line": 2256}, "message": "expanded from macro 'is_dx'"}, {"location": {"col": 6, "file": 0, "line": 1500}, "message": "Assuming 'nblocks' is not equal to 0, which participates in a condition later"}, {"location": {"col": 2, "file": 0, "line": 1500}, "message": "Taking false branch"}, {"location": {"col": 10, "file": 0, "line": 1504}, "message": "Left side of '&&' is false"}, {"location": {"col": 24, "file": 10, "line": 22}, "message": "expanded from macro 'EXT4_I'"}, {"location": {"col": 61, "file": 11, "line": 853}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 10, "file": 0, "line": 1504}, "message": "Taking false branch"}, {"location": {"col": 24, "file": 10, "line": 22}, "message": "expanded from macro 'EXT4_I'"}, {"location": {"col": 2, "file": 11, "line": 853}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 37, "file": 12, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 13, "line": 319}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 13, "line": 307}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 3, "file": 13, "line": 299}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 10, "file": 0, "line": 1504}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 24, "file": 10, "line": 22}, "message": "expanded from macro 'EXT4_I'"}, {"location": {"col": 2, "file": 11, "line": 853}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 37, "file": 12, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 13, "line": 319}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 13, "line": 307}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 2, "file": 13, "line": 297}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 6, "file": 0, "line": 1505}, "message": "Assuming 'start' is < 'nblocks'"}, {"location": {"col": 2, "file": 0, "line": 1505}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1514}, "message": "'ra_ptr' is >= 'ra_max'"}, {"location": {"col": 3, "file": 0, "line": 1514}, "message": "Taking true branch"}, {"location": {"col": 8, "file": 0, "line": 1517}, "message": "'block' is >= 'start'"}, {"location": {"col": 4, "file": 0, "line": 1517}, "message": "Taking false branch"}, {"location": {"col": 13, "file": 0, "line": 1521}, "message": "Assuming '__UNIQUE_ID___x1168' is >= '__UNIQUE_ID___y1169'"}, {"location": {"col": 19, "file": 14, "line": 51}, "message": "expanded from macro 'min'"}, {"location": {"col": 3, "file": 14, "line": 44}, "message": "expanded from macro '__careful_cmp'"}, {"location": {"col": 3, "file": 14, "line": 39}, "message": "expanded from macro '__cmp_once'"}, {"location": {"col": 26, "file": 14, "line": 34}, "message": "expanded from macro '__cmp'"}, {"location": {"col": 13, "file": 0, "line": 1521}, "message": "'?' condition is false"}, {"location": {"col": 19, "file": 14, "line": 51}, "message": "expanded from macro 'min'"}, {"location": {"col": 3, "file": 14, "line": 44}, "message": "expanded from macro '__careful_cmp'"}, {"location": {"col": 3, "file": 14, "line": 39}, "message": "expanded from macro '__cmp_once'"}, {"location": {"col": 26, "file": 14, "line": 34}, "message": "expanded from macro '__cmp'"}, {"location": {"col": 8, "file": 0, "line": 1524}, "message": "Assuming 'retval' is not equal to 0"}, {"location": {"col": 4, "file": 0, "line": 1524}, "message": "Taking true branch"}, {"location": {"col": 5, "file": 0, "line": 1527}, "message": "Control jumps to line 1582"}, {"location": {"col": 2, "file": 0, "line": 1582}, "message": "Loop condition is false. Execution continues on line 1584"}, {"location": {"col": 2, "file": 0, "line": 1584}, "message": "Returning pointer (loaded from 'ret'), which participates in a condition later"}, {"location": {"col": 7, "file": 0, "line": 1602}, "message": "Returning from '__ext4_find_entry'"}, {"location": {"col": 2, "file": 0, "line": 1605}, "message": "Returning pointer (loaded from 'bh'), which participates in a condition later"}, {"location": {"col": 11, "file": 0, "line": 3984}, "message": "Returning from 'ext4_find_entry'"}, {"location": {"col": 6, "file": 0, "line": 3986}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 8, "line": 36}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 8, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 7, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 8, "line": 36}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 3986}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 2, "file": 0, "line": 3986}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3995}, "message": "Assuming field 'bh' is non-null"}, {"location": {"col": 6, "file": 0, "line": 3995}, "message": "Left side of '||' is false"}, {"location": {"col": 17, "file": 0, "line": 3995}, "message": "Access to field 'inode' results in a dereference of a null pointer (loaded from field 'de')"}, {"location": {"col": 21, "file": 1, "line": 89}, "message": "expanded from macro 'le32_to_cpu'"}, {"location": {"col": 50, "file": 2, "line": 34}, "message": "expanded from macro '__le32_to_cpu'"}, {"location": {"col": 17, "file": 0, "line": 3995}, "message": "Access to field 'inode' results in a dereference of a null pointer (loaded from field 'de')"}], "macros": [], "notes": [], "path": "/src/fs/ext4/namei.c", "reportHash": "f007f4f6e4bc49d0aeb49a920423b229", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 1, "line": 89}, "message": "expanded from macro 'le32_to_cpu'"}, {"location": {"col": 50, "file": 2, "line": 34}, "message": "expanded from macro '__le32_to_cpu'"}, {"location": {"col": 7, "file": 0, "line": 3969}, "message": "Assuming the condition is false"}, {"location": {"col": 61, "file": 0, "line": 3969}, "message": "Left side of '&&' is false"}, {"location": {"col": 7, "file": 0, "line": 3972}, "message": "Assuming the condition is false"}, {"location": {"col": 61, "file": 0, "line": 3972}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 3978}, "message": "Assuming 'retval' is 0"}, {"location": {"col": 2, "file": 0, "line": 3978}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3981}, "message": "Assuming 'retval' is 0"}, {"location": {"col": 2, "file": 0, "line": 3981}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 3984}, "message": "Calling 'ext4_find_entry'"}, {"location": {"col": 8, "file": 0, "line": 1596}, "message": "Calling 'ext4_fname_setup_filename'"}, {"location": {"col": 2, "file": 4, "line": 2641}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 8, "file": 0, "line": 1596}, "message": "Returning from 'ext4_fname_setup_filename'"}, {"location": {"col": 2, "file": 0, "line": 1597}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1599}, "message": "'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 1599}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1602}, "message": "Calling '__ext4_find_entry'"}, {"location": {"col": 6, "file": 0, "line": 1462}, "message": "Assuming 'namelen' is <= EXT4_NAME_LEN"}, {"location": {"col": 2, "file": 0, "line": 1462}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1465}, "message": "Calling 'ext4_has_inline_data'"}, {"location": {"col": 9, "file": 4, "line": 3445}, "message": "Assuming the condition is true"}, {"location": {"col": 9, "file": 4, "line": 3445}, "message": "Left side of '&&' is true"}, {"location": {"col": 2, "file": 4, "line": 3445}, "message": "Returning value, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 1465}, "message": "Returning from 'ext4_has_inline_data'"}, {"location": {"col": 6, "file": 0, "line": 1465}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 0, "line": 1465}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 1469}, "message": "Assuming 'has_inline_data' is not equal to 0"}, {"location": {"col": 3, "file": 0, "line": 1469}, "message": "Taking true branch"}, {"location": {"col": 8, "file": 0, "line": 1470}, "message": "'inlined' is non-null"}, {"location": {"col": 4, "file": 0, "line": 1470}, "message": "Taking true branch"}, {"location": {"col": 4, "file": 0, "line": 1472}, "message": "Control jumps to line 1582"}, {"location": {"col": 2, "file": 0, "line": 1582}, "message": "Loop condition is false. Execution continues on line 1584"}, {"location": {"col": 2, "file": 0, "line": 1584}, "message": "Returning pointer (loaded from 'ret'), which participates in a condition later"}, {"location": {"col": 7, "file": 0, "line": 1602}, "message": "Returning from '__ext4_find_entry'"}, {"location": {"col": 2, "file": 0, "line": 1605}, "message": "Returning pointer (loaded from 'bh'), which participates in a condition later"}, {"location": {"col": 11, "file": 0, "line": 3984}, "message": "Returning from 'ext4_find_entry'"}, {"location": {"col": 6, "file": 0, "line": 3986}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 8, "line": 36}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 8, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 7, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 8, "line": 36}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 3986}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 2, "file": 0, "line": 3986}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3995}, "message": "Assuming field 'bh' is non-null"}, {"location": {"col": 6, "file": 0, "line": 3995}, "message": "Left side of '||' is false"}, {"location": {"col": 17, "file": 0, "line": 3995}, "message": "Assuming field 'inode' is equal to field 'i_ino'"}, {"location": {"col": 21, "file": 1, "line": 89}, "message": "expanded from macro 'le32_to_cpu'"}, {"location": {"col": 26, "file": 2, "line": 34}, "message": "expanded from macro '__le32_to_cpu'"}, {"location": {"col": 2, "file": 0, "line": 3995}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 3998}, "message": "Calling 'ext4_find_entry'"}, {"location": {"col": 8, "file": 0, "line": 1596}, "message": "Calling 'ext4_fname_setup_filename'"}, {"location": {"col": 2, "file": 4, "line": 2641}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 8, "file": 0, "line": 1596}, "message": "Returning from 'ext4_fname_setup_filename'"}, {"location": {"col": 2, "file": 0, "line": 1597}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1599}, "message": "'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 1599}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1602}, "message": "Calling '__ext4_find_entry'"}, {"location": {"col": 2, "file": 0, "line": 1459}, "message": "Null pointer value stored to 'new.de'"}, {"location": {"col": 6, "file": 0, "line": 1462}, "message": "Assuming 'namelen' is <= EXT4_NAME_LEN"}, {"location": {"col": 2, "file": 0, "line": 1462}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1465}, "message": "Calling 'ext4_has_inline_data'"}, {"location": {"col": 9, "file": 4, "line": 3445}, "message": "Assuming the condition is false"}, {"location": {"col": 61, "file": 4, "line": 3445}, "message": "Left side of '&&' is false"}, {"location": {"col": 2, "file": 4, "line": 3445}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 1465}, "message": "Returning from 'ext4_has_inline_data'"}, {"location": {"col": 2, "file": 0, "line": 1465}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1476}, "message": "Assuming 'namelen' is > 2"}, {"location": {"col": 21, "file": 0, "line": 1476}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 1486}, "message": "Calling 'ext4_has_feature_dir_index'"}, {"location": {"col": 21, "file": 4, "line": 2256}, "message": "expanded from macro 'is_dx'"}, {"location": {"col": 1, "file": 4, "line": 1976}, "message": "Assuming the condition is false"}, {"location": {"col": 10, "file": 4, "line": 1920}, "message": "expanded from macro 'EXT4_FEATURE_COMPAT_FUNCS'"}, {"location": {"col": 1, "file": 4, "line": 1976}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 2, "file": 4, "line": 1920}, "message": "expanded from macro 'EXT4_FEATURE_COMPAT_FUNCS'"}, {"location": {"col": 6, "file": 0, "line": 1486}, "message": "Returning from 'ext4_has_feature_dir_index'"}, {"location": {"col": 21, "file": 4, "line": 2256}, "message": "expanded from macro 'is_dx'"}, {"location": {"col": 6, "file": 0, "line": 1486}, "message": "Left side of '&&' is false"}, {"location": {"col": 61, "file": 4, "line": 2256}, "message": "expanded from macro 'is_dx'"}, {"location": {"col": 6, "file": 0, "line": 1500}, "message": "Assuming 'nblocks' is not equal to 0, which participates in a condition later"}, {"location": {"col": 2, "file": 0, "line": 1500}, "message": "Taking false branch"}, {"location": {"col": 10, "file": 0, "line": 1504}, "message": "Left side of '&&' is false"}, {"location": {"col": 24, "file": 10, "line": 22}, "message": "expanded from macro 'EXT4_I'"}, {"location": {"col": 61, "file": 11, "line": 853}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 10, "file": 0, "line": 1504}, "message": "Taking false branch"}, {"location": {"col": 24, "file": 10, "line": 22}, "message": "expanded from macro 'EXT4_I'"}, {"location": {"col": 2, "file": 11, "line": 853}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 37, "file": 12, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 13, "line": 319}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 13, "line": 307}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 3, "file": 13, "line": 299}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 10, "file": 0, "line": 1504}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 24, "file": 10, "line": 22}, "message": "expanded from macro 'EXT4_I'"}, {"location": {"col": 2, "file": 11, "line": 853}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 37, "file": 12, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 13, "line": 319}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 13, "line": 307}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 2, "file": 13, "line": 297}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 6, "file": 0, "line": 1505}, "message": "Assuming 'start' is < 'nblocks'"}, {"location": {"col": 2, "file": 0, "line": 1505}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1514}, "message": "'ra_ptr' is >= 'ra_max'"}, {"location": {"col": 3, "file": 0, "line": 1514}, "message": "Taking true branch"}, {"location": {"col": 8, "file": 0, "line": 1517}, "message": "'block' is >= 'start'"}, {"location": {"col": 4, "file": 0, "line": 1517}, "message": "Taking false branch"}, {"location": {"col": 13, "file": 0, "line": 1521}, "message": "Assuming '__UNIQUE_ID___x1168' is >= '__UNIQUE_ID___y1169'"}, {"location": {"col": 19, "file": 14, "line": 51}, "message": "expanded from macro 'min'"}, {"location": {"col": 3, "file": 14, "line": 44}, "message": "expanded from macro '__careful_cmp'"}, {"location": {"col": 3, "file": 14, "line": 39}, "message": "expanded from macro '__cmp_once'"}, {"location": {"col": 26, "file": 14, "line": 34}, "message": "expanded from macro '__cmp'"}, {"location": {"col": 13, "file": 0, "line": 1521}, "message": "'?' condition is false"}, {"location": {"col": 19, "file": 14, "line": 51}, "message": "expanded from macro 'min'"}, {"location": {"col": 3, "file": 14, "line": 44}, "message": "expanded from macro '__careful_cmp'"}, {"location": {"col": 3, "file": 14, "line": 39}, "message": "expanded from macro '__cmp_once'"}, {"location": {"col": 26, "file": 14, "line": 34}, "message": "expanded from macro '__cmp'"}, {"location": {"col": 8, "file": 0, "line": 1524}, "message": "Assuming 'retval' is not equal to 0"}, {"location": {"col": 4, "file": 0, "line": 1524}, "message": "Taking true branch"}, {"location": {"col": 5, "file": 0, "line": 1527}, "message": "Control jumps to line 1582"}, {"location": {"col": 2, "file": 0, "line": 1582}, "message": "Loop condition is false. Execution continues on line 1584"}, {"location": {"col": 2, "file": 0, "line": 1584}, "message": "Returning pointer (loaded from 'ret'), which participates in a condition later"}, {"location": {"col": 7, "file": 0, "line": 1602}, "message": "Returning from '__ext4_find_entry'"}, {"location": {"col": 2, "file": 0, "line": 1605}, "message": "Returning pointer (loaded from 'bh'), which participates in a condition later"}, {"location": {"col": 11, "file": 0, "line": 3998}, "message": "Returning from 'ext4_find_entry'"}, {"location": {"col": 6, "file": 0, "line": 4000}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 8, "line": 36}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 8, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 7, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 8, "line": 36}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 4000}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 2, "file": 0, "line": 4000}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 4007}, "message": "Assuming field 'bh' is non-null"}, {"location": {"col": 6, "file": 0, "line": 4007}, "message": "Left side of '||' is false"}, {"location": {"col": 17, "file": 0, "line": 4007}, "message": "Access to field 'inode' results in a dereference of a null pointer (loaded from field 'de')"}, {"location": {"col": 21, "file": 1, "line": 89}, "message": "expanded from macro 'le32_to_cpu'"}, {"location": {"col": 50, "file": 2, "line": 34}, "message": "expanded from macro '__le32_to_cpu'"}, {"location": {"col": 17, "file": 0, "line": 4007}, "message": "Access to field 'inode' results in a dereference of a null pointer (loaded from field 'de')"}], "macros": [], "notes": [], "path": "/src/fs/ext4/namei.c", "reportHash": "de481bc911365e63ec43fabf7cd1352b", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
