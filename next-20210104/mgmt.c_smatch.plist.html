<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/net/bluetooth/mgmt.c", "content": "/*\n   BlueZ - Bluetooth protocol stack for Linux\n\n   Copyright (C) 2010  Nokia Corporation\n   Copyright (C) 2011-2012 Intel Corporation\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License version 2 as\n   published by the Free Software Foundation;\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY\n   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES\n   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,\n   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS\n   SOFTWARE IS DISCLAIMED.\n*/\n\n/* Bluetooth HCI Management interface */\n\n#include <linux/module.h>\n#include <asm/unaligned.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/hci_sock.h>\n#include <net/bluetooth/l2cap.h>\n#include <net/bluetooth/mgmt.h>\n\n#include \"hci_request.h\"\n#include \"smp.h\"\n#include \"mgmt_util.h\"\n#include \"mgmt_config.h\"\n#include \"msft.h\"\n\n#define MGMT_VERSION\t1\n#define MGMT_REVISION\t19\n\nstatic const u16 mgmt_commands[] = {\n\tMGMT_OP_READ_INDEX_LIST,\n\tMGMT_OP_READ_INFO,\n\tMGMT_OP_SET_POWERED,\n\tMGMT_OP_SET_DISCOVERABLE,\n\tMGMT_OP_SET_CONNECTABLE,\n\tMGMT_OP_SET_FAST_CONNECTABLE,\n\tMGMT_OP_SET_BONDABLE,\n\tMGMT_OP_SET_LINK_SECURITY,\n\tMGMT_OP_SET_SSP,\n\tMGMT_OP_SET_HS,\n\tMGMT_OP_SET_LE,\n\tMGMT_OP_SET_DEV_CLASS,\n\tMGMT_OP_SET_LOCAL_NAME,\n\tMGMT_OP_ADD_UUID,\n\tMGMT_OP_REMOVE_UUID,\n\tMGMT_OP_LOAD_LINK_KEYS,\n\tMGMT_OP_LOAD_LONG_TERM_KEYS,\n\tMGMT_OP_DISCONNECT,\n\tMGMT_OP_GET_CONNECTIONS,\n\tMGMT_OP_PIN_CODE_REPLY,\n\tMGMT_OP_PIN_CODE_NEG_REPLY,\n\tMGMT_OP_SET_IO_CAPABILITY,\n\tMGMT_OP_PAIR_DEVICE,\n\tMGMT_OP_CANCEL_PAIR_DEVICE,\n\tMGMT_OP_UNPAIR_DEVICE,\n\tMGMT_OP_USER_CONFIRM_REPLY,\n\tMGMT_OP_USER_CONFIRM_NEG_REPLY,\n\tMGMT_OP_USER_PASSKEY_REPLY,\n\tMGMT_OP_USER_PASSKEY_NEG_REPLY,\n\tMGMT_OP_READ_LOCAL_OOB_DATA,\n\tMGMT_OP_ADD_REMOTE_OOB_DATA,\n\tMGMT_OP_REMOVE_REMOTE_OOB_DATA,\n\tMGMT_OP_START_DISCOVERY,\n\tMGMT_OP_STOP_DISCOVERY,\n\tMGMT_OP_CONFIRM_NAME,\n\tMGMT_OP_BLOCK_DEVICE,\n\tMGMT_OP_UNBLOCK_DEVICE,\n\tMGMT_OP_SET_DEVICE_ID,\n\tMGMT_OP_SET_ADVERTISING,\n\tMGMT_OP_SET_BREDR,\n\tMGMT_OP_SET_STATIC_ADDRESS,\n\tMGMT_OP_SET_SCAN_PARAMS,\n\tMGMT_OP_SET_SECURE_CONN,\n\tMGMT_OP_SET_DEBUG_KEYS,\n\tMGMT_OP_SET_PRIVACY,\n\tMGMT_OP_LOAD_IRKS,\n\tMGMT_OP_GET_CONN_INFO,\n\tMGMT_OP_GET_CLOCK_INFO,\n\tMGMT_OP_ADD_DEVICE,\n\tMGMT_OP_REMOVE_DEVICE,\n\tMGMT_OP_LOAD_CONN_PARAM,\n\tMGMT_OP_READ_UNCONF_INDEX_LIST,\n\tMGMT_OP_READ_CONFIG_INFO,\n\tMGMT_OP_SET_EXTERNAL_CONFIG,\n\tMGMT_OP_SET_PUBLIC_ADDRESS,\n\tMGMT_OP_START_SERVICE_DISCOVERY,\n\tMGMT_OP_READ_LOCAL_OOB_EXT_DATA,\n\tMGMT_OP_READ_EXT_INDEX_LIST,\n\tMGMT_OP_READ_ADV_FEATURES,\n\tMGMT_OP_ADD_ADVERTISING,\n\tMGMT_OP_REMOVE_ADVERTISING,\n\tMGMT_OP_GET_ADV_SIZE_INFO,\n\tMGMT_OP_START_LIMITED_DISCOVERY,\n\tMGMT_OP_READ_EXT_INFO,\n\tMGMT_OP_SET_APPEARANCE,\n\tMGMT_OP_SET_BLOCKED_KEYS,\n\tMGMT_OP_SET_WIDEBAND_SPEECH,\n\tMGMT_OP_READ_CONTROLLER_CAP,\n\tMGMT_OP_READ_EXP_FEATURES_INFO,\n\tMGMT_OP_SET_EXP_FEATURE,\n\tMGMT_OP_READ_DEF_SYSTEM_CONFIG,\n\tMGMT_OP_SET_DEF_SYSTEM_CONFIG,\n\tMGMT_OP_READ_DEF_RUNTIME_CONFIG,\n\tMGMT_OP_SET_DEF_RUNTIME_CONFIG,\n\tMGMT_OP_GET_DEVICE_FLAGS,\n\tMGMT_OP_SET_DEVICE_FLAGS,\n\tMGMT_OP_READ_ADV_MONITOR_FEATURES,\n\tMGMT_OP_ADD_ADV_PATTERNS_MONITOR,\n\tMGMT_OP_REMOVE_ADV_MONITOR,\n\tMGMT_OP_ADD_EXT_ADV_PARAMS,\n\tMGMT_OP_ADD_EXT_ADV_DATA,\n};\n\nstatic const u16 mgmt_events[] = {\n\tMGMT_EV_CONTROLLER_ERROR,\n\tMGMT_EV_INDEX_ADDED,\n\tMGMT_EV_INDEX_REMOVED,\n\tMGMT_EV_NEW_SETTINGS,\n\tMGMT_EV_CLASS_OF_DEV_CHANGED,\n\tMGMT_EV_LOCAL_NAME_CHANGED,\n\tMGMT_EV_NEW_LINK_KEY,\n\tMGMT_EV_NEW_LONG_TERM_KEY,\n\tMGMT_EV_DEVICE_CONNECTED,\n\tMGMT_EV_DEVICE_DISCONNECTED,\n\tMGMT_EV_CONNECT_FAILED,\n\tMGMT_EV_PIN_CODE_REQUEST,\n\tMGMT_EV_USER_CONFIRM_REQUEST,\n\tMGMT_EV_USER_PASSKEY_REQUEST,\n\tMGMT_EV_AUTH_FAILED,\n\tMGMT_EV_DEVICE_FOUND,\n\tMGMT_EV_DISCOVERING,\n\tMGMT_EV_DEVICE_BLOCKED,\n\tMGMT_EV_DEVICE_UNBLOCKED,\n\tMGMT_EV_DEVICE_UNPAIRED,\n\tMGMT_EV_PASSKEY_NOTIFY,\n\tMGMT_EV_NEW_IRK,\n\tMGMT_EV_NEW_CSRK,\n\tMGMT_EV_DEVICE_ADDED,\n\tMGMT_EV_DEVICE_REMOVED,\n\tMGMT_EV_NEW_CONN_PARAM,\n\tMGMT_EV_UNCONF_INDEX_ADDED,\n\tMGMT_EV_UNCONF_INDEX_REMOVED,\n\tMGMT_EV_NEW_CONFIG_OPTIONS,\n\tMGMT_EV_EXT_INDEX_ADDED,\n\tMGMT_EV_EXT_INDEX_REMOVED,\n\tMGMT_EV_LOCAL_OOB_DATA_UPDATED,\n\tMGMT_EV_ADVERTISING_ADDED,\n\tMGMT_EV_ADVERTISING_REMOVED,\n\tMGMT_EV_EXT_INFO_CHANGED,\n\tMGMT_EV_PHY_CONFIGURATION_CHANGED,\n\tMGMT_EV_EXP_FEATURE_CHANGED,\n\tMGMT_EV_DEVICE_FLAGS_CHANGED,\n\tMGMT_EV_CONTROLLER_SUSPEND,\n\tMGMT_EV_CONTROLLER_RESUME,\n};\n\nstatic const u16 mgmt_untrusted_commands[] = {\n\tMGMT_OP_READ_INDEX_LIST,\n\tMGMT_OP_READ_INFO,\n\tMGMT_OP_READ_UNCONF_INDEX_LIST,\n\tMGMT_OP_READ_CONFIG_INFO,\n\tMGMT_OP_READ_EXT_INDEX_LIST,\n\tMGMT_OP_READ_EXT_INFO,\n\tMGMT_OP_READ_CONTROLLER_CAP,\n\tMGMT_OP_READ_EXP_FEATURES_INFO,\n\tMGMT_OP_READ_DEF_SYSTEM_CONFIG,\n\tMGMT_OP_READ_DEF_RUNTIME_CONFIG,\n};\n\nstatic const u16 mgmt_untrusted_events[] = {\n\tMGMT_EV_INDEX_ADDED,\n\tMGMT_EV_INDEX_REMOVED,\n\tMGMT_EV_NEW_SETTINGS,\n\tMGMT_EV_CLASS_OF_DEV_CHANGED,\n\tMGMT_EV_LOCAL_NAME_CHANGED,\n\tMGMT_EV_UNCONF_INDEX_ADDED,\n\tMGMT_EV_UNCONF_INDEX_REMOVED,\n\tMGMT_EV_NEW_CONFIG_OPTIONS,\n\tMGMT_EV_EXT_INDEX_ADDED,\n\tMGMT_EV_EXT_INDEX_REMOVED,\n\tMGMT_EV_EXT_INFO_CHANGED,\n\tMGMT_EV_EXP_FEATURE_CHANGED,\n\tMGMT_EV_ADV_MONITOR_ADDED,\n\tMGMT_EV_ADV_MONITOR_REMOVED,\n};\n\n#define CACHE_TIMEOUT\tmsecs_to_jiffies(2 * 1000)\n\n#define ZERO_KEY \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \\\n\t\t \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\n/* HCI to MGMT error code conversion table */\nstatic const u8 mgmt_status_table[] = {\n\tMGMT_STATUS_SUCCESS,\n\tMGMT_STATUS_UNKNOWN_COMMAND,\t/* Unknown Command */\n\tMGMT_STATUS_NOT_CONNECTED,\t/* No Connection */\n\tMGMT_STATUS_FAILED,\t\t/* Hardware Failure */\n\tMGMT_STATUS_CONNECT_FAILED,\t/* Page Timeout */\n\tMGMT_STATUS_AUTH_FAILED,\t/* Authentication Failed */\n\tMGMT_STATUS_AUTH_FAILED,\t/* PIN or Key Missing */\n\tMGMT_STATUS_NO_RESOURCES,\t/* Memory Full */\n\tMGMT_STATUS_TIMEOUT,\t\t/* Connection Timeout */\n\tMGMT_STATUS_NO_RESOURCES,\t/* Max Number of Connections */\n\tMGMT_STATUS_NO_RESOURCES,\t/* Max Number of SCO Connections */\n\tMGMT_STATUS_ALREADY_CONNECTED,\t/* ACL Connection Exists */\n\tMGMT_STATUS_BUSY,\t\t/* Command Disallowed */\n\tMGMT_STATUS_NO_RESOURCES,\t/* Rejected Limited Resources */\n\tMGMT_STATUS_REJECTED,\t\t/* Rejected Security */\n\tMGMT_STATUS_REJECTED,\t\t/* Rejected Personal */\n\tMGMT_STATUS_TIMEOUT,\t\t/* Host Timeout */\n\tMGMT_STATUS_NOT_SUPPORTED,\t/* Unsupported Feature */\n\tMGMT_STATUS_INVALID_PARAMS,\t/* Invalid Parameters */\n\tMGMT_STATUS_DISCONNECTED,\t/* OE User Ended Connection */\n\tMGMT_STATUS_NO_RESOURCES,\t/* OE Low Resources */\n\tMGMT_STATUS_DISCONNECTED,\t/* OE Power Off */\n\tMGMT_STATUS_DISCONNECTED,\t/* Connection Terminated */\n\tMGMT_STATUS_BUSY,\t\t/* Repeated Attempts */\n\tMGMT_STATUS_REJECTED,\t\t/* Pairing Not Allowed */\n\tMGMT_STATUS_FAILED,\t\t/* Unknown LMP PDU */\n\tMGMT_STATUS_NOT_SUPPORTED,\t/* Unsupported Remote Feature */\n\tMGMT_STATUS_REJECTED,\t\t/* SCO Offset Rejected */\n\tMGMT_STATUS_REJECTED,\t\t/* SCO Interval Rejected */\n\tMGMT_STATUS_REJECTED,\t\t/* Air Mode Rejected */\n\tMGMT_STATUS_INVALID_PARAMS,\t/* Invalid LMP Parameters */\n\tMGMT_STATUS_FAILED,\t\t/* Unspecified Error */\n\tMGMT_STATUS_NOT_SUPPORTED,\t/* Unsupported LMP Parameter Value */\n\tMGMT_STATUS_FAILED,\t\t/* Role Change Not Allowed */\n\tMGMT_STATUS_TIMEOUT,\t\t/* LMP Response Timeout */\n\tMGMT_STATUS_FAILED,\t\t/* LMP Error Transaction Collision */\n\tMGMT_STATUS_FAILED,\t\t/* LMP PDU Not Allowed */\n\tMGMT_STATUS_REJECTED,\t\t/* Encryption Mode Not Accepted */\n\tMGMT_STATUS_FAILED,\t\t/* Unit Link Key Used */\n\tMGMT_STATUS_NOT_SUPPORTED,\t/* QoS Not Supported */\n\tMGMT_STATUS_TIMEOUT,\t\t/* Instant Passed */\n\tMGMT_STATUS_NOT_SUPPORTED,\t/* Pairing Not Supported */\n\tMGMT_STATUS_FAILED,\t\t/* Transaction Collision */\n\tMGMT_STATUS_INVALID_PARAMS,\t/* Unacceptable Parameter */\n\tMGMT_STATUS_REJECTED,\t\t/* QoS Rejected */\n\tMGMT_STATUS_NOT_SUPPORTED,\t/* Classification Not Supported */\n\tMGMT_STATUS_REJECTED,\t\t/* Insufficient Security */\n\tMGMT_STATUS_INVALID_PARAMS,\t/* Parameter Out Of Range */\n\tMGMT_STATUS_BUSY,\t\t/* Role Switch Pending */\n\tMGMT_STATUS_FAILED,\t\t/* Slot Violation */\n\tMGMT_STATUS_FAILED,\t\t/* Role Switch Failed */\n\tMGMT_STATUS_INVALID_PARAMS,\t/* EIR Too Large */\n\tMGMT_STATUS_NOT_SUPPORTED,\t/* Simple Pairing Not Supported */\n\tMGMT_STATUS_BUSY,\t\t/* Host Busy Pairing */\n\tMGMT_STATUS_REJECTED,\t\t/* Rejected, No Suitable Channel */\n\tMGMT_STATUS_BUSY,\t\t/* Controller Busy */\n\tMGMT_STATUS_INVALID_PARAMS,\t/* Unsuitable Connection Interval */\n\tMGMT_STATUS_TIMEOUT,\t\t/* Directed Advertising Timeout */\n\tMGMT_STATUS_AUTH_FAILED,\t/* Terminated Due to MIC Failure */\n\tMGMT_STATUS_CONNECT_FAILED,\t/* Connection Establishment Failed */\n\tMGMT_STATUS_CONNECT_FAILED,\t/* MAC Connection Failed */\n};\n\nstatic u8 mgmt_status(u8 hci_status)\n{\n\tif (hci_status < ARRAY_SIZE(mgmt_status_table))\n\t\treturn mgmt_status_table[hci_status];\n\n\treturn MGMT_STATUS_FAILED;\n}\n\nstatic int mgmt_index_event(u16 event, struct hci_dev *hdev, void *data,\n\t\t\t    u16 len, int flag)\n{\n\treturn mgmt_send_event(event, hdev, HCI_CHANNEL_CONTROL, data, len,\n\t\t\t       flag, NULL);\n}\n\nstatic int mgmt_limited_event(u16 event, struct hci_dev *hdev, void *data,\n\t\t\t      u16 len, int flag, struct sock *skip_sk)\n{\n\treturn mgmt_send_event(event, hdev, HCI_CHANNEL_CONTROL, data, len,\n\t\t\t       flag, skip_sk);\n}\n\nstatic int mgmt_event(u16 event, struct hci_dev *hdev, void *data, u16 len,\n\t\t      struct sock *skip_sk)\n{\n\treturn mgmt_send_event(event, hdev, HCI_CHANNEL_CONTROL, data, len,\n\t\t\t       HCI_SOCK_TRUSTED, skip_sk);\n}\n\nstatic u8 le_addr_type(u8 mgmt_addr_type)\n{\n\tif (mgmt_addr_type == BDADDR_LE_PUBLIC)\n\t\treturn ADDR_LE_DEV_PUBLIC;\n\telse\n\t\treturn ADDR_LE_DEV_RANDOM;\n}\n\nvoid mgmt_fill_version_info(void *ver)\n{\n\tstruct mgmt_rp_read_version *rp = ver;\n\n\trp->version = MGMT_VERSION;\n\trp->revision = cpu_to_le16(MGMT_REVISION);\n}\n\nstatic int read_version(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\tu16 data_len)\n{\n\tstruct mgmt_rp_read_version rp;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tmgmt_fill_version_info(&rp);\n\n\treturn mgmt_cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_VERSION, 0,\n\t\t\t\t &rp, sizeof(rp));\n}\n\nstatic int read_commands(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t u16 data_len)\n{\n\tstruct mgmt_rp_read_commands *rp;\n\tu16 num_commands, num_events;\n\tsize_t rp_size;\n\tint i, err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (hci_sock_test_flag(sk, HCI_SOCK_TRUSTED)) {\n\t\tnum_commands = ARRAY_SIZE(mgmt_commands);\n\t\tnum_events = ARRAY_SIZE(mgmt_events);\n\t} else {\n\t\tnum_commands = ARRAY_SIZE(mgmt_untrusted_commands);\n\t\tnum_events = ARRAY_SIZE(mgmt_untrusted_events);\n\t}\n\n\trp_size = sizeof(*rp) + ((num_commands + num_events) * sizeof(u16));\n\n\trp = kmalloc(rp_size, GFP_KERNEL);\n\tif (!rp)\n\t\treturn -ENOMEM;\n\n\trp->num_commands = cpu_to_le16(num_commands);\n\trp->num_events = cpu_to_le16(num_events);\n\n\tif (hci_sock_test_flag(sk, HCI_SOCK_TRUSTED)) {\n\t\t__le16 *opcode = rp->opcodes;\n\n\t\tfor (i = 0; i < num_commands; i++, opcode++)\n\t\t\tput_unaligned_le16(mgmt_commands[i], opcode);\n\n\t\tfor (i = 0; i < num_events; i++, opcode++)\n\t\t\tput_unaligned_le16(mgmt_events[i], opcode);\n\t} else {\n\t\t__le16 *opcode = rp->opcodes;\n\n\t\tfor (i = 0; i < num_commands; i++, opcode++)\n\t\t\tput_unaligned_le16(mgmt_untrusted_commands[i], opcode);\n\n\t\tfor (i = 0; i < num_events; i++, opcode++)\n\t\t\tput_unaligned_le16(mgmt_untrusted_events[i], opcode);\n\t}\n\n\terr = mgmt_cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_COMMANDS, 0,\n\t\t\t\trp, rp_size);\n\tkfree(rp);\n\n\treturn err;\n}\n\nstatic int read_index_list(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t   u16 data_len)\n{\n\tstruct mgmt_rp_read_index_list *rp;\n\tstruct hci_dev *d;\n\tsize_t rp_len;\n\tu16 count;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tread_lock(&hci_dev_list_lock);\n\n\tcount = 0;\n\tlist_for_each_entry(d, &hci_dev_list, list) {\n\t\tif (d->dev_type == HCI_PRIMARY &&\n\t\t    !hci_dev_test_flag(d, HCI_UNCONFIGURED))\n\t\t\tcount++;\n\t}\n\n\trp_len = sizeof(*rp) + (2 * count);\n\trp = kmalloc(rp_len, GFP_ATOMIC);\n\tif (!rp) {\n\t\tread_unlock(&hci_dev_list_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tcount = 0;\n\tlist_for_each_entry(d, &hci_dev_list, list) {\n\t\tif (hci_dev_test_flag(d, HCI_SETUP) ||\n\t\t    hci_dev_test_flag(d, HCI_CONFIG) ||\n\t\t    hci_dev_test_flag(d, HCI_USER_CHANNEL))\n\t\t\tcontinue;\n\n\t\t/* Devices marked as raw-only are neither configured\n\t\t * nor unconfigured controllers.\n\t\t */\n\t\tif (test_bit(HCI_QUIRK_RAW_DEVICE, &d->quirks))\n\t\t\tcontinue;\n\n\t\tif (d->dev_type == HCI_PRIMARY &&\n\t\t    !hci_dev_test_flag(d, HCI_UNCONFIGURED)) {\n\t\t\trp->index[count++] = cpu_to_le16(d->id);\n\t\t\tbt_dev_dbg(hdev, \"Added hci%u\", d->id);\n\t\t}\n\t}\n\n\trp->num_controllers = cpu_to_le16(count);\n\trp_len = sizeof(*rp) + (2 * count);\n\n\tread_unlock(&hci_dev_list_lock);\n\n\terr = mgmt_cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_INDEX_LIST,\n\t\t\t\t0, rp, rp_len);\n\n\tkfree(rp);\n\n\treturn err;\n}\n\nstatic int read_unconf_index_list(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t  void *data, u16 data_len)\n{\n\tstruct mgmt_rp_read_unconf_index_list *rp;\n\tstruct hci_dev *d;\n\tsize_t rp_len;\n\tu16 count;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tread_lock(&hci_dev_list_lock);\n\n\tcount = 0;\n\tlist_for_each_entry(d, &hci_dev_list, list) {\n\t\tif (d->dev_type == HCI_PRIMARY &&\n\t\t    hci_dev_test_flag(d, HCI_UNCONFIGURED))\n\t\t\tcount++;\n\t}\n\n\trp_len = sizeof(*rp) + (2 * count);\n\trp = kmalloc(rp_len, GFP_ATOMIC);\n\tif (!rp) {\n\t\tread_unlock(&hci_dev_list_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tcount = 0;\n\tlist_for_each_entry(d, &hci_dev_list, list) {\n\t\tif (hci_dev_test_flag(d, HCI_SETUP) ||\n\t\t    hci_dev_test_flag(d, HCI_CONFIG) ||\n\t\t    hci_dev_test_flag(d, HCI_USER_CHANNEL))\n\t\t\tcontinue;\n\n\t\t/* Devices marked as raw-only are neither configured\n\t\t * nor unconfigured controllers.\n\t\t */\n\t\tif (test_bit(HCI_QUIRK_RAW_DEVICE, &d->quirks))\n\t\t\tcontinue;\n\n\t\tif (d->dev_type == HCI_PRIMARY &&\n\t\t    hci_dev_test_flag(d, HCI_UNCONFIGURED)) {\n\t\t\trp->index[count++] = cpu_to_le16(d->id);\n\t\t\tbt_dev_dbg(hdev, \"Added hci%u\", d->id);\n\t\t}\n\t}\n\n\trp->num_controllers = cpu_to_le16(count);\n\trp_len = sizeof(*rp) + (2 * count);\n\n\tread_unlock(&hci_dev_list_lock);\n\n\terr = mgmt_cmd_complete(sk, MGMT_INDEX_NONE,\n\t\t\t\tMGMT_OP_READ_UNCONF_INDEX_LIST, 0, rp, rp_len);\n\n\tkfree(rp);\n\n\treturn err;\n}\n\nstatic int read_ext_index_list(struct sock *sk, struct hci_dev *hdev,\n\t\t\t       void *data, u16 data_len)\n{\n\tstruct mgmt_rp_read_ext_index_list *rp;\n\tstruct hci_dev *d;\n\tu16 count;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tread_lock(&hci_dev_list_lock);\n\n\tcount = 0;\n\tlist_for_each_entry(d, &hci_dev_list, list) {\n\t\tif (d->dev_type == HCI_PRIMARY || d->dev_type == HCI_AMP)\n\t\t\tcount++;\n\t}\n\n\trp = kmalloc(struct_size(rp, entry, count), GFP_ATOMIC);\n\tif (!rp) {\n\t\tread_unlock(&hci_dev_list_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tcount = 0;\n\tlist_for_each_entry(d, &hci_dev_list, list) {\n\t\tif (hci_dev_test_flag(d, HCI_SETUP) ||\n\t\t    hci_dev_test_flag(d, HCI_CONFIG) ||\n\t\t    hci_dev_test_flag(d, HCI_USER_CHANNEL))\n\t\t\tcontinue;\n\n\t\t/* Devices marked as raw-only are neither configured\n\t\t * nor unconfigured controllers.\n\t\t */\n\t\tif (test_bit(HCI_QUIRK_RAW_DEVICE, &d->quirks))\n\t\t\tcontinue;\n\n\t\tif (d->dev_type == HCI_PRIMARY) {\n\t\t\tif (hci_dev_test_flag(d, HCI_UNCONFIGURED))\n\t\t\t\trp->entry[count].type = 0x01;\n\t\t\telse\n\t\t\t\trp->entry[count].type = 0x00;\n\t\t} else if (d->dev_type == HCI_AMP) {\n\t\t\trp->entry[count].type = 0x02;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\trp->entry[count].bus = d->bus;\n\t\trp->entry[count++].index = cpu_to_le16(d->id);\n\t\tbt_dev_dbg(hdev, \"Added hci%u\", d->id);\n\t}\n\n\trp->num_controllers = cpu_to_le16(count);\n\n\tread_unlock(&hci_dev_list_lock);\n\n\t/* If this command is called at least once, then all the\n\t * default index and unconfigured index events are disabled\n\t * and from now on only extended index events are used.\n\t */\n\thci_sock_set_flag(sk, HCI_MGMT_EXT_INDEX_EVENTS);\n\thci_sock_clear_flag(sk, HCI_MGMT_INDEX_EVENTS);\n\thci_sock_clear_flag(sk, HCI_MGMT_UNCONF_INDEX_EVENTS);\n\n\terr = mgmt_cmd_complete(sk, MGMT_INDEX_NONE,\n\t\t\t\tMGMT_OP_READ_EXT_INDEX_LIST, 0, rp,\n\t\t\t\tstruct_size(rp, entry, count));\n\n\tkfree(rp);\n\n\treturn err;\n}\n\nstatic bool is_configured(struct hci_dev *hdev)\n{\n\tif (test_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks) &&\n\t    !hci_dev_test_flag(hdev, HCI_EXT_CONFIGURED))\n\t\treturn false;\n\n\tif ((test_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks) ||\n\t     test_bit(HCI_QUIRK_USE_BDADDR_PROPERTY, &hdev->quirks)) &&\n\t    !bacmp(&hdev->public_addr, BDADDR_ANY))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic __le32 get_missing_options(struct hci_dev *hdev)\n{\n\tu32 options = 0;\n\n\tif (test_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks) &&\n\t    !hci_dev_test_flag(hdev, HCI_EXT_CONFIGURED))\n\t\toptions |= MGMT_OPTION_EXTERNAL_CONFIG;\n\n\tif ((test_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks) ||\n\t     test_bit(HCI_QUIRK_USE_BDADDR_PROPERTY, &hdev->quirks)) &&\n\t    !bacmp(&hdev->public_addr, BDADDR_ANY))\n\t\toptions |= MGMT_OPTION_PUBLIC_ADDRESS;\n\n\treturn cpu_to_le32(options);\n}\n\nstatic int new_options(struct hci_dev *hdev, struct sock *skip)\n{\n\t__le32 options = get_missing_options(hdev);\n\n\treturn mgmt_limited_event(MGMT_EV_NEW_CONFIG_OPTIONS, hdev, &options,\n\t\t\t\t  sizeof(options), HCI_MGMT_OPTION_EVENTS, skip);\n}\n\nstatic int send_options_rsp(struct sock *sk, u16 opcode, struct hci_dev *hdev)\n{\n\t__le32 options = get_missing_options(hdev);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, opcode, 0, &options,\n\t\t\t\t sizeof(options));\n}\n\nstatic int read_config_info(struct sock *sk, struct hci_dev *hdev,\n\t\t\t    void *data, u16 data_len)\n{\n\tstruct mgmt_rp_read_config_info rp;\n\tu32 options = 0;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tmemset(&rp, 0, sizeof(rp));\n\trp.manufacturer = cpu_to_le16(hdev->manufacturer);\n\n\tif (test_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks))\n\t\toptions |= MGMT_OPTION_EXTERNAL_CONFIG;\n\n\tif (hdev->set_bdaddr)\n\t\toptions |= MGMT_OPTION_PUBLIC_ADDRESS;\n\n\trp.supported_options = cpu_to_le32(options);\n\trp.missing_options = get_missing_options(hdev);\n\n\thci_dev_unlock(hdev);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_CONFIG_INFO, 0,\n\t\t\t\t &rp, sizeof(rp));\n}\n\nstatic u32 get_supported_phys(struct hci_dev *hdev)\n{\n\tu32 supported_phys = 0;\n\n\tif (lmp_bredr_capable(hdev)) {\n\t\tsupported_phys |= MGMT_PHY_BR_1M_1SLOT;\n\n\t\tif (hdev->features[0][0] & LMP_3SLOT)\n\t\t\tsupported_phys |= MGMT_PHY_BR_1M_3SLOT;\n\n\t\tif (hdev->features[0][0] & LMP_5SLOT)\n\t\t\tsupported_phys |= MGMT_PHY_BR_1M_5SLOT;\n\n\t\tif (lmp_edr_2m_capable(hdev)) {\n\t\t\tsupported_phys |= MGMT_PHY_EDR_2M_1SLOT;\n\n\t\t\tif (lmp_edr_3slot_capable(hdev))\n\t\t\t\tsupported_phys |= MGMT_PHY_EDR_2M_3SLOT;\n\n\t\t\tif (lmp_edr_5slot_capable(hdev))\n\t\t\t\tsupported_phys |= MGMT_PHY_EDR_2M_5SLOT;\n\n\t\t\tif (lmp_edr_3m_capable(hdev)) {\n\t\t\t\tsupported_phys |= MGMT_PHY_EDR_3M_1SLOT;\n\n\t\t\t\tif (lmp_edr_3slot_capable(hdev))\n\t\t\t\t\tsupported_phys |= MGMT_PHY_EDR_3M_3SLOT;\n\n\t\t\t\tif (lmp_edr_5slot_capable(hdev))\n\t\t\t\t\tsupported_phys |= MGMT_PHY_EDR_3M_5SLOT;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (lmp_le_capable(hdev)) {\n\t\tsupported_phys |= MGMT_PHY_LE_1M_TX;\n\t\tsupported_phys |= MGMT_PHY_LE_1M_RX;\n\n\t\tif (hdev->le_features[1] & HCI_LE_PHY_2M) {\n\t\t\tsupported_phys |= MGMT_PHY_LE_2M_TX;\n\t\t\tsupported_phys |= MGMT_PHY_LE_2M_RX;\n\t\t}\n\n\t\tif (hdev->le_features[1] & HCI_LE_PHY_CODED) {\n\t\t\tsupported_phys |= MGMT_PHY_LE_CODED_TX;\n\t\t\tsupported_phys |= MGMT_PHY_LE_CODED_RX;\n\t\t}\n\t}\n\n\treturn supported_phys;\n}\n\nstatic u32 get_selected_phys(struct hci_dev *hdev)\n{\n\tu32 selected_phys = 0;\n\n\tif (lmp_bredr_capable(hdev)) {\n\t\tselected_phys |= MGMT_PHY_BR_1M_1SLOT;\n\n\t\tif (hdev->pkt_type & (HCI_DM3 | HCI_DH3))\n\t\t\tselected_phys |= MGMT_PHY_BR_1M_3SLOT;\n\n\t\tif (hdev->pkt_type & (HCI_DM5 | HCI_DH5))\n\t\t\tselected_phys |= MGMT_PHY_BR_1M_5SLOT;\n\n\t\tif (lmp_edr_2m_capable(hdev)) {\n\t\t\tif (!(hdev->pkt_type & HCI_2DH1))\n\t\t\t\tselected_phys |= MGMT_PHY_EDR_2M_1SLOT;\n\n\t\t\tif (lmp_edr_3slot_capable(hdev) &&\n\t\t\t    !(hdev->pkt_type & HCI_2DH3))\n\t\t\t\tselected_phys |= MGMT_PHY_EDR_2M_3SLOT;\n\n\t\t\tif (lmp_edr_5slot_capable(hdev) &&\n\t\t\t    !(hdev->pkt_type & HCI_2DH5))\n\t\t\t\tselected_phys |= MGMT_PHY_EDR_2M_5SLOT;\n\n\t\t\tif (lmp_edr_3m_capable(hdev)) {\n\t\t\t\tif (!(hdev->pkt_type & HCI_3DH1))\n\t\t\t\t\tselected_phys |= MGMT_PHY_EDR_3M_1SLOT;\n\n\t\t\t\tif (lmp_edr_3slot_capable(hdev) &&\n\t\t\t\t    !(hdev->pkt_type & HCI_3DH3))\n\t\t\t\t\tselected_phys |= MGMT_PHY_EDR_3M_3SLOT;\n\n\t\t\t\tif (lmp_edr_5slot_capable(hdev) &&\n\t\t\t\t    !(hdev->pkt_type & HCI_3DH5))\n\t\t\t\t\tselected_phys |= MGMT_PHY_EDR_3M_5SLOT;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (lmp_le_capable(hdev)) {\n\t\tif (hdev->le_tx_def_phys & HCI_LE_SET_PHY_1M)\n\t\t\tselected_phys |= MGMT_PHY_LE_1M_TX;\n\n\t\tif (hdev->le_rx_def_phys & HCI_LE_SET_PHY_1M)\n\t\t\tselected_phys |= MGMT_PHY_LE_1M_RX;\n\n\t\tif (hdev->le_tx_def_phys & HCI_LE_SET_PHY_2M)\n\t\t\tselected_phys |= MGMT_PHY_LE_2M_TX;\n\n\t\tif (hdev->le_rx_def_phys & HCI_LE_SET_PHY_2M)\n\t\t\tselected_phys |= MGMT_PHY_LE_2M_RX;\n\n\t\tif (hdev->le_tx_def_phys & HCI_LE_SET_PHY_CODED)\n\t\t\tselected_phys |= MGMT_PHY_LE_CODED_TX;\n\n\t\tif (hdev->le_rx_def_phys & HCI_LE_SET_PHY_CODED)\n\t\t\tselected_phys |= MGMT_PHY_LE_CODED_RX;\n\t}\n\n\treturn selected_phys;\n}\n\nstatic u32 get_configurable_phys(struct hci_dev *hdev)\n{\n\treturn (get_supported_phys(hdev) & ~MGMT_PHY_BR_1M_1SLOT &\n\t\t~MGMT_PHY_LE_1M_TX & ~MGMT_PHY_LE_1M_RX);\n}\n\nstatic u32 get_supported_settings(struct hci_dev *hdev)\n{\n\tu32 settings = 0;\n\n\tsettings |= MGMT_SETTING_POWERED;\n\tsettings |= MGMT_SETTING_BONDABLE;\n\tsettings |= MGMT_SETTING_DEBUG_KEYS;\n\tsettings |= MGMT_SETTING_CONNECTABLE;\n\tsettings |= MGMT_SETTING_DISCOVERABLE;\n\n\tif (lmp_bredr_capable(hdev)) {\n\t\tif (hdev->hci_ver >= BLUETOOTH_VER_1_2)\n\t\t\tsettings |= MGMT_SETTING_FAST_CONNECTABLE;\n\t\tsettings |= MGMT_SETTING_BREDR;\n\t\tsettings |= MGMT_SETTING_LINK_SECURITY;\n\n\t\tif (lmp_ssp_capable(hdev)) {\n\t\t\tsettings |= MGMT_SETTING_SSP;\n\t\t\tif (IS_ENABLED(CONFIG_BT_HS))\n\t\t\t\tsettings |= MGMT_SETTING_HS;\n\t\t}\n\n\t\tif (lmp_sc_capable(hdev))\n\t\t\tsettings |= MGMT_SETTING_SECURE_CONN;\n\n\t\tif (test_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED,\n\t\t\t     &hdev->quirks))\n\t\t\tsettings |= MGMT_SETTING_WIDEBAND_SPEECH;\n\t}\n\n\tif (lmp_le_capable(hdev)) {\n\t\tsettings |= MGMT_SETTING_LE;\n\t\tsettings |= MGMT_SETTING_SECURE_CONN;\n\t\tsettings |= MGMT_SETTING_PRIVACY;\n\t\tsettings |= MGMT_SETTING_STATIC_ADDRESS;\n\n\t\t/* When the experimental feature for LL Privacy support is\n\t\t * enabled, then advertising is no longer supported.\n\t\t */\n\t\tif (!hci_dev_test_flag(hdev, HCI_ENABLE_LL_PRIVACY))\n\t\t\tsettings |= MGMT_SETTING_ADVERTISING;\n\t}\n\n\tif (test_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks) ||\n\t    hdev->set_bdaddr)\n\t\tsettings |= MGMT_SETTING_CONFIGURATION;\n\n\tsettings |= MGMT_SETTING_PHY_CONFIGURATION;\n\n\treturn settings;\n}\n\nstatic u32 get_current_settings(struct hci_dev *hdev)\n{\n\tu32 settings = 0;\n\n\tif (hdev_is_powered(hdev))\n\t\tsettings |= MGMT_SETTING_POWERED;\n\n\tif (hci_dev_test_flag(hdev, HCI_CONNECTABLE))\n\t\tsettings |= MGMT_SETTING_CONNECTABLE;\n\n\tif (hci_dev_test_flag(hdev, HCI_FAST_CONNECTABLE))\n\t\tsettings |= MGMT_SETTING_FAST_CONNECTABLE;\n\n\tif (hci_dev_test_flag(hdev, HCI_DISCOVERABLE))\n\t\tsettings |= MGMT_SETTING_DISCOVERABLE;\n\n\tif (hci_dev_test_flag(hdev, HCI_BONDABLE))\n\t\tsettings |= MGMT_SETTING_BONDABLE;\n\n\tif (hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\n\t\tsettings |= MGMT_SETTING_BREDR;\n\n\tif (hci_dev_test_flag(hdev, HCI_LE_ENABLED))\n\t\tsettings |= MGMT_SETTING_LE;\n\n\tif (hci_dev_test_flag(hdev, HCI_LINK_SECURITY))\n\t\tsettings |= MGMT_SETTING_LINK_SECURITY;\n\n\tif (hci_dev_test_flag(hdev, HCI_SSP_ENABLED))\n\t\tsettings |= MGMT_SETTING_SSP;\n\n\tif (hci_dev_test_flag(hdev, HCI_HS_ENABLED))\n\t\tsettings |= MGMT_SETTING_HS;\n\n\tif (hci_dev_test_flag(hdev, HCI_ADVERTISING))\n\t\tsettings |= MGMT_SETTING_ADVERTISING;\n\n\tif (hci_dev_test_flag(hdev, HCI_SC_ENABLED))\n\t\tsettings |= MGMT_SETTING_SECURE_CONN;\n\n\tif (hci_dev_test_flag(hdev, HCI_KEEP_DEBUG_KEYS))\n\t\tsettings |= MGMT_SETTING_DEBUG_KEYS;\n\n\tif (hci_dev_test_flag(hdev, HCI_PRIVACY))\n\t\tsettings |= MGMT_SETTING_PRIVACY;\n\n\t/* The current setting for static address has two purposes. The\n\t * first is to indicate if the static address will be used and\n\t * the second is to indicate if it is actually set.\n\t *\n\t * This means if the static address is not configured, this flag\n\t * will never be set. If the address is configured, then if the\n\t * address is actually used decides if the flag is set or not.\n\t *\n\t * For single mode LE only controllers and dual-mode controllers\n\t * with BR/EDR disabled, the existence of the static address will\n\t * be evaluated.\n\t */\n\tif (hci_dev_test_flag(hdev, HCI_FORCE_STATIC_ADDR) ||\n\t    !hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) ||\n\t    !bacmp(&hdev->bdaddr, BDADDR_ANY)) {\n\t\tif (bacmp(&hdev->static_addr, BDADDR_ANY))\n\t\t\tsettings |= MGMT_SETTING_STATIC_ADDRESS;\n\t}\n\n\tif (hci_dev_test_flag(hdev, HCI_WIDEBAND_SPEECH_ENABLED))\n\t\tsettings |= MGMT_SETTING_WIDEBAND_SPEECH;\n\n\treturn settings;\n}\n\nstatic struct mgmt_pending_cmd *pending_find(u16 opcode, struct hci_dev *hdev)\n{\n\treturn mgmt_pending_find(HCI_CHANNEL_CONTROL, opcode, hdev);\n}\n\nstatic struct mgmt_pending_cmd *pending_find_data(u16 opcode,\n\t\t\t\t\t\t  struct hci_dev *hdev,\n\t\t\t\t\t\t  const void *data)\n{\n\treturn mgmt_pending_find_data(HCI_CHANNEL_CONTROL, opcode, hdev, data);\n}\n\nu8 mgmt_get_adv_discov_flags(struct hci_dev *hdev)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\t/* If there's a pending mgmt command the flags will not yet have\n\t * their final values, so check for this first.\n\t */\n\tcmd = pending_find(MGMT_OP_SET_DISCOVERABLE, hdev);\n\tif (cmd) {\n\t\tstruct mgmt_mode *cp = cmd->param;\n\t\tif (cp->val == 0x01)\n\t\t\treturn LE_AD_GENERAL;\n\t\telse if (cp->val == 0x02)\n\t\t\treturn LE_AD_LIMITED;\n\t} else {\n\t\tif (hci_dev_test_flag(hdev, HCI_LIMITED_DISCOVERABLE))\n\t\t\treturn LE_AD_LIMITED;\n\t\telse if (hci_dev_test_flag(hdev, HCI_DISCOVERABLE))\n\t\t\treturn LE_AD_GENERAL;\n\t}\n\n\treturn 0;\n}\n\nbool mgmt_get_connectable(struct hci_dev *hdev)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\t/* If there's a pending mgmt command the flag will not yet have\n\t * it's final value, so check for this first.\n\t */\n\tcmd = pending_find(MGMT_OP_SET_CONNECTABLE, hdev);\n\tif (cmd) {\n\t\tstruct mgmt_mode *cp = cmd->param;\n\n\t\treturn cp->val;\n\t}\n\n\treturn hci_dev_test_flag(hdev, HCI_CONNECTABLE);\n}\n\nstatic void service_cache_off(struct work_struct *work)\n{\n\tstruct hci_dev *hdev = container_of(work, struct hci_dev,\n\t\t\t\t\t    service_cache.work);\n\tstruct hci_request req;\n\n\tif (!hci_dev_test_and_clear_flag(hdev, HCI_SERVICE_CACHE))\n\t\treturn;\n\n\thci_req_init(&req, hdev);\n\n\thci_dev_lock(hdev);\n\n\t__hci_req_update_eir(&req);\n\t__hci_req_update_class(&req);\n\n\thci_dev_unlock(hdev);\n\n\thci_req_run(&req, NULL);\n}\n\nstatic void rpa_expired(struct work_struct *work)\n{\n\tstruct hci_dev *hdev = container_of(work, struct hci_dev,\n\t\t\t\t\t    rpa_expired.work);\n\tstruct hci_request req;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\thci_dev_set_flag(hdev, HCI_RPA_EXPIRED);\n\n\tif (!hci_dev_test_flag(hdev, HCI_ADVERTISING))\n\t\treturn;\n\n\t/* The generation of a new RPA and programming it into the\n\t * controller happens in the hci_req_enable_advertising()\n\t * function.\n\t */\n\thci_req_init(&req, hdev);\n\tif (ext_adv_capable(hdev))\n\t\t__hci_req_start_ext_adv(&req, hdev->cur_adv_instance);\n\telse\n\t\t__hci_req_enable_advertising(&req);\n\thci_req_run(&req, NULL);\n}\n\nstatic void mgmt_init_hdev(struct sock *sk, struct hci_dev *hdev)\n{\n\tif (hci_dev_test_and_set_flag(hdev, HCI_MGMT))\n\t\treturn;\n\n\tINIT_DELAYED_WORK(&hdev->service_cache, service_cache_off);\n\tINIT_DELAYED_WORK(&hdev->rpa_expired, rpa_expired);\n\n\t/* Non-mgmt controlled devices get this bit set\n\t * implicitly so that pairing works for them, however\n\t * for mgmt we require user-space to explicitly enable\n\t * it\n\t */\n\thci_dev_clear_flag(hdev, HCI_BONDABLE);\n}\n\nstatic int read_controller_info(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\tvoid *data, u16 data_len)\n{\n\tstruct mgmt_rp_read_info rp;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tmemset(&rp, 0, sizeof(rp));\n\n\tbacpy(&rp.bdaddr, &hdev->bdaddr);\n\n\trp.version = hdev->hci_ver;\n\trp.manufacturer = cpu_to_le16(hdev->manufacturer);\n\n\trp.supported_settings = cpu_to_le32(get_supported_settings(hdev));\n\trp.current_settings = cpu_to_le32(get_current_settings(hdev));\n\n\tmemcpy(rp.dev_class, hdev->dev_class, 3);\n\n\tmemcpy(rp.name, hdev->dev_name, sizeof(hdev->dev_name));\n\tmemcpy(rp.short_name, hdev->short_name, sizeof(hdev->short_name));\n\n\thci_dev_unlock(hdev);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_INFO, 0, &rp,\n\t\t\t\t sizeof(rp));\n}\n\nstatic u16 append_eir_data_to_buf(struct hci_dev *hdev, u8 *eir)\n{\n\tu16 eir_len = 0;\n\tsize_t name_len;\n\n\tif (hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\n\t\teir_len = eir_append_data(eir, eir_len, EIR_CLASS_OF_DEV,\n\t\t\t\t\t  hdev->dev_class, 3);\n\n\tif (hci_dev_test_flag(hdev, HCI_LE_ENABLED))\n\t\teir_len = eir_append_le16(eir, eir_len, EIR_APPEARANCE,\n\t\t\t\t\t  hdev->appearance);\n\n\tname_len = strlen(hdev->dev_name);\n\teir_len = eir_append_data(eir, eir_len, EIR_NAME_COMPLETE,\n\t\t\t\t  hdev->dev_name, name_len);\n\n\tname_len = strlen(hdev->short_name);\n\teir_len = eir_append_data(eir, eir_len, EIR_NAME_SHORT,\n\t\t\t\t  hdev->short_name, name_len);\n\n\treturn eir_len;\n}\n\nstatic int read_ext_controller_info(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t    void *data, u16 data_len)\n{\n\tchar buf[512];\n\tstruct mgmt_rp_read_ext_info *rp = (void *)buf;\n\tu16 eir_len;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tmemset(&buf, 0, sizeof(buf));\n\n\thci_dev_lock(hdev);\n\n\tbacpy(&rp->bdaddr, &hdev->bdaddr);\n\n\trp->version = hdev->hci_ver;\n\trp->manufacturer = cpu_to_le16(hdev->manufacturer);\n\n\trp->supported_settings = cpu_to_le32(get_supported_settings(hdev));\n\trp->current_settings = cpu_to_le32(get_current_settings(hdev));\n\n\n\teir_len = append_eir_data_to_buf(hdev, rp->eir);\n\trp->eir_len = cpu_to_le16(eir_len);\n\n\thci_dev_unlock(hdev);\n\n\t/* If this command is called at least once, then the events\n\t * for class of device and local name changes are disabled\n\t * and only the new extended controller information event\n\t * is used.\n\t */\n\thci_sock_set_flag(sk, HCI_MGMT_EXT_INFO_EVENTS);\n\thci_sock_clear_flag(sk, HCI_MGMT_DEV_CLASS_EVENTS);\n\thci_sock_clear_flag(sk, HCI_MGMT_LOCAL_NAME_EVENTS);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_EXT_INFO, 0, rp,\n\t\t\t\t sizeof(*rp) + eir_len);\n}\n\nstatic int ext_info_changed(struct hci_dev *hdev, struct sock *skip)\n{\n\tchar buf[512];\n\tstruct mgmt_ev_ext_info_changed *ev = (void *)buf;\n\tu16 eir_len;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\teir_len = append_eir_data_to_buf(hdev, ev->eir);\n\tev->eir_len = cpu_to_le16(eir_len);\n\n\treturn mgmt_limited_event(MGMT_EV_EXT_INFO_CHANGED, hdev, ev,\n\t\t\t\t  sizeof(*ev) + eir_len,\n\t\t\t\t  HCI_MGMT_EXT_INFO_EVENTS, skip);\n}\n\nstatic int send_settings_rsp(struct sock *sk, u16 opcode, struct hci_dev *hdev)\n{\n\t__le32 settings = cpu_to_le32(get_current_settings(hdev));\n\n\treturn mgmt_cmd_complete(sk, hdev->id, opcode, 0, &settings,\n\t\t\t\t sizeof(settings));\n}\n\nstatic void clean_up_hci_complete(struct hci_dev *hdev, u8 status, u16 opcode)\n{\n\tbt_dev_dbg(hdev, \"status 0x%02x\", status);\n\n\tif (hci_conn_count(hdev) == 0) {\n\t\tcancel_delayed_work(&hdev->power_off);\n\t\tqueue_work(hdev->req_workqueue, &hdev->power_off.work);\n\t}\n}\n\nvoid mgmt_advertising_added(struct sock *sk, struct hci_dev *hdev, u8 instance)\n{\n\tstruct mgmt_ev_advertising_added ev;\n\n\tev.instance = instance;\n\n\tmgmt_event(MGMT_EV_ADVERTISING_ADDED, hdev, &ev, sizeof(ev), sk);\n}\n\nvoid mgmt_advertising_removed(struct sock *sk, struct hci_dev *hdev,\n\t\t\t      u8 instance)\n{\n\tstruct mgmt_ev_advertising_removed ev;\n\n\tev.instance = instance;\n\n\tmgmt_event(MGMT_EV_ADVERTISING_REMOVED, hdev, &ev, sizeof(ev), sk);\n}\n\nstatic void cancel_adv_timeout(struct hci_dev *hdev)\n{\n\tif (hdev->adv_instance_timeout) {\n\t\thdev->adv_instance_timeout = 0;\n\t\tcancel_delayed_work(&hdev->adv_instance_expire);\n\t}\n}\n\nstatic int clean_up_hci_state(struct hci_dev *hdev)\n{\n\tstruct hci_request req;\n\tstruct hci_conn *conn;\n\tbool discov_stopped;\n\tint err;\n\n\thci_req_init(&req, hdev);\n\n\tif (test_bit(HCI_ISCAN, &hdev->flags) ||\n\t    test_bit(HCI_PSCAN, &hdev->flags)) {\n\t\tu8 scan = 0x00;\n\t\thci_req_add(&req, HCI_OP_WRITE_SCAN_ENABLE, 1, &scan);\n\t}\n\n\thci_req_clear_adv_instance(hdev, NULL, NULL, 0x00, false);\n\n\tif (hci_dev_test_flag(hdev, HCI_LE_ADV))\n\t\t__hci_req_disable_advertising(&req);\n\n\tdiscov_stopped = hci_req_stop_discovery(&req);\n\n\tlist_for_each_entry(conn, &hdev->conn_hash.list, list) {\n\t\t/* 0x15 == Terminated due to Power Off */\n\t\t__hci_abort_conn(&req, conn, 0x15);\n\t}\n\n\terr = hci_req_run(&req, clean_up_hci_complete);\n\tif (!err && discov_stopped)\n\t\thci_discovery_set_state(hdev, DISCOVERY_STOPPING);\n\n\treturn err;\n}\n\nstatic int set_powered(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t       u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_POWERED,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (pending_find(MGMT_OP_SET_POWERED, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_POWERED,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto failed;\n\t}\n\n\tif (!!cp->val == hdev_is_powered(hdev)) {\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_POWERED, hdev);\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_POWERED, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tif (cp->val) {\n\t\tqueue_work(hdev->req_workqueue, &hdev->power_on);\n\t\terr = 0;\n\t} else {\n\t\t/* Disconnect connections, stop scans, etc */\n\t\terr = clean_up_hci_state(hdev);\n\t\tif (!err)\n\t\t\tqueue_delayed_work(hdev->req_workqueue, &hdev->power_off,\n\t\t\t\t\t   HCI_POWER_OFF_TIMEOUT);\n\n\t\t/* ENODATA means there were no HCI commands queued */\n\t\tif (err == -ENODATA) {\n\t\t\tcancel_delayed_work(&hdev->power_off);\n\t\t\tqueue_work(hdev->req_workqueue, &hdev->power_off.work);\n\t\t\terr = 0;\n\t\t}\n\t}\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int new_settings(struct hci_dev *hdev, struct sock *skip)\n{\n\t__le32 ev = cpu_to_le32(get_current_settings(hdev));\n\n\treturn mgmt_limited_event(MGMT_EV_NEW_SETTINGS, hdev, &ev,\n\t\t\t\t  sizeof(ev), HCI_MGMT_SETTING_EVENTS, skip);\n}\n\nint mgmt_new_settings(struct hci_dev *hdev)\n{\n\treturn new_settings(hdev, NULL);\n}\n\nstruct cmd_lookup {\n\tstruct sock *sk;\n\tstruct hci_dev *hdev;\n\tu8 mgmt_status;\n};\n\nstatic void settings_rsp(struct mgmt_pending_cmd *cmd, void *data)\n{\n\tstruct cmd_lookup *match = data;\n\n\tsend_settings_rsp(cmd->sk, cmd->opcode, match->hdev);\n\n\tlist_del(&cmd->list);\n\n\tif (match->sk == NULL) {\n\t\tmatch->sk = cmd->sk;\n\t\tsock_hold(match->sk);\n\t}\n\n\tmgmt_pending_free(cmd);\n}\n\nstatic void cmd_status_rsp(struct mgmt_pending_cmd *cmd, void *data)\n{\n\tu8 *status = data;\n\n\tmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode, *status);\n\tmgmt_pending_remove(cmd);\n}\n\nstatic void cmd_complete_rsp(struct mgmt_pending_cmd *cmd, void *data)\n{\n\tif (cmd->cmd_complete) {\n\t\tu8 *status = data;\n\n\t\tcmd->cmd_complete(cmd, *status);\n\t\tmgmt_pending_remove(cmd);\n\n\t\treturn;\n\t}\n\n\tcmd_status_rsp(cmd, data);\n}\n\nstatic int generic_cmd_complete(struct mgmt_pending_cmd *cmd, u8 status)\n{\n\treturn mgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode, status,\n\t\t\t\t cmd->param, cmd->param_len);\n}\n\nstatic int addr_cmd_complete(struct mgmt_pending_cmd *cmd, u8 status)\n{\n\treturn mgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode, status,\n\t\t\t\t cmd->param, sizeof(struct mgmt_addr_info));\n}\n\nstatic u8 mgmt_bredr_support(struct hci_dev *hdev)\n{\n\tif (!lmp_bredr_capable(hdev))\n\t\treturn MGMT_STATUS_NOT_SUPPORTED;\n\telse if (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\n\t\treturn MGMT_STATUS_REJECTED;\n\telse\n\t\treturn MGMT_STATUS_SUCCESS;\n}\n\nstatic u8 mgmt_le_support(struct hci_dev *hdev)\n{\n\tif (!lmp_le_capable(hdev))\n\t\treturn MGMT_STATUS_NOT_SUPPORTED;\n\telse if (!hci_dev_test_flag(hdev, HCI_LE_ENABLED))\n\t\treturn MGMT_STATUS_REJECTED;\n\telse\n\t\treturn MGMT_STATUS_SUCCESS;\n}\n\nvoid mgmt_set_discoverable_complete(struct hci_dev *hdev, u8 status)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tbt_dev_dbg(hdev, \"status 0x%02x\", status);\n\n\thci_dev_lock(hdev);\n\n\tcmd = pending_find(MGMT_OP_SET_DISCOVERABLE, hdev);\n\tif (!cmd)\n\t\tgoto unlock;\n\n\tif (status) {\n\t\tu8 mgmt_err = mgmt_status(status);\n\t\tmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode, mgmt_err);\n\t\thci_dev_clear_flag(hdev, HCI_LIMITED_DISCOVERABLE);\n\t\tgoto remove_cmd;\n\t}\n\n\tif (hci_dev_test_flag(hdev, HCI_DISCOVERABLE) &&\n\t    hdev->discov_timeout > 0) {\n\t\tint to = msecs_to_jiffies(hdev->discov_timeout * 1000);\n\t\tqueue_delayed_work(hdev->req_workqueue, &hdev->discov_off, to);\n\t}\n\n\tsend_settings_rsp(cmd->sk, MGMT_OP_SET_DISCOVERABLE, hdev);\n\tnew_settings(hdev, cmd->sk);\n\nremove_cmd:\n\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic int set_discoverable(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t    u16 len)\n{\n\tstruct mgmt_cp_set_discoverable *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tu16 timeout;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED) &&\n\t    !hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\tif (cp->val != 0x00 && cp->val != 0x01 && cp->val != 0x02)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\ttimeout = __le16_to_cpu(cp->timeout);\n\n\t/* Disabling discoverable requires that no timeout is set,\n\t * and enabling limited discoverable requires a timeout.\n\t */\n\tif ((cp->val == 0x00 && timeout > 0) ||\n\t    (cp->val == 0x02 && timeout == 0))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev) && timeout > 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\n\t\t\t\t      MGMT_STATUS_NOT_POWERED);\n\t\tgoto failed;\n\t}\n\n\tif (pending_find(MGMT_OP_SET_DISCOVERABLE, hdev) ||\n\t    pending_find(MGMT_OP_SET_CONNECTABLE, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto failed;\n\t}\n\n\tif (!hci_dev_test_flag(hdev, HCI_CONNECTABLE)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\n\t\t\t\t      MGMT_STATUS_REJECTED);\n\t\tgoto failed;\n\t}\n\n\tif (hdev->advertising_paused) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto failed;\n\t}\n\n\tif (!hdev_is_powered(hdev)) {\n\t\tbool changed = false;\n\n\t\t/* Setting limited discoverable when powered off is\n\t\t * not a valid operation since it requires a timeout\n\t\t * and so no need to check HCI_LIMITED_DISCOVERABLE.\n\t\t */\n\t\tif (!!cp->val != hci_dev_test_flag(hdev, HCI_DISCOVERABLE)) {\n\t\t\thci_dev_change_flag(hdev, HCI_DISCOVERABLE);\n\t\t\tchanged = true;\n\t\t}\n\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_DISCOVERABLE, hdev);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tif (changed)\n\t\t\terr = new_settings(hdev, sk);\n\n\t\tgoto failed;\n\t}\n\n\t/* If the current mode is the same, then just update the timeout\n\t * value with the new value. And if only the timeout gets updated,\n\t * then no need for any HCI transactions.\n\t */\n\tif (!!cp->val == hci_dev_test_flag(hdev, HCI_DISCOVERABLE) &&\n\t    (cp->val == 0x02) == hci_dev_test_flag(hdev,\n\t\t\t\t\t\t   HCI_LIMITED_DISCOVERABLE)) {\n\t\tcancel_delayed_work(&hdev->discov_off);\n\t\thdev->discov_timeout = timeout;\n\n\t\tif (cp->val && hdev->discov_timeout > 0) {\n\t\t\tint to = msecs_to_jiffies(hdev->discov_timeout * 1000);\n\t\t\tqueue_delayed_work(hdev->req_workqueue,\n\t\t\t\t\t   &hdev->discov_off, to);\n\t\t}\n\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_DISCOVERABLE, hdev);\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_DISCOVERABLE, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\t/* Cancel any potential discoverable timeout that might be\n\t * still active and store new timeout value. The arming of\n\t * the timeout happens in the complete handler.\n\t */\n\tcancel_delayed_work(&hdev->discov_off);\n\thdev->discov_timeout = timeout;\n\n\tif (cp->val)\n\t\thci_dev_set_flag(hdev, HCI_DISCOVERABLE);\n\telse\n\t\thci_dev_clear_flag(hdev, HCI_DISCOVERABLE);\n\n\t/* Limited discoverable mode */\n\tif (cp->val == 0x02)\n\t\thci_dev_set_flag(hdev, HCI_LIMITED_DISCOVERABLE);\n\telse\n\t\thci_dev_clear_flag(hdev, HCI_LIMITED_DISCOVERABLE);\n\n\tqueue_work(hdev->req_workqueue, &hdev->discoverable_update);\n\terr = 0;\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nvoid mgmt_set_connectable_complete(struct hci_dev *hdev, u8 status)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tbt_dev_dbg(hdev, \"status 0x%02x\", status);\n\n\thci_dev_lock(hdev);\n\n\tcmd = pending_find(MGMT_OP_SET_CONNECTABLE, hdev);\n\tif (!cmd)\n\t\tgoto unlock;\n\n\tif (status) {\n\t\tu8 mgmt_err = mgmt_status(status);\n\t\tmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode, mgmt_err);\n\t\tgoto remove_cmd;\n\t}\n\n\tsend_settings_rsp(cmd->sk, MGMT_OP_SET_CONNECTABLE, hdev);\n\tnew_settings(hdev, cmd->sk);\n\nremove_cmd:\n\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic int set_connectable_update_settings(struct hci_dev *hdev,\n\t\t\t\t\t   struct sock *sk, u8 val)\n{\n\tbool changed = false;\n\tint err;\n\n\tif (!!val != hci_dev_test_flag(hdev, HCI_CONNECTABLE))\n\t\tchanged = true;\n\n\tif (val) {\n\t\thci_dev_set_flag(hdev, HCI_CONNECTABLE);\n\t} else {\n\t\thci_dev_clear_flag(hdev, HCI_CONNECTABLE);\n\t\thci_dev_clear_flag(hdev, HCI_DISCOVERABLE);\n\t}\n\n\terr = send_settings_rsp(sk, MGMT_OP_SET_CONNECTABLE, hdev);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (changed) {\n\t\thci_req_update_scan(hdev);\n\t\thci_update_background_scan(hdev);\n\t\treturn new_settings(hdev, sk);\n\t}\n\n\treturn 0;\n}\n\nstatic int set_connectable(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t   u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED) &&\n\t    !hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_CONNECTABLE,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_CONNECTABLE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = set_connectable_update_settings(hdev, sk, cp->val);\n\t\tgoto failed;\n\t}\n\n\tif (pending_find(MGMT_OP_SET_DISCOVERABLE, hdev) ||\n\t    pending_find(MGMT_OP_SET_CONNECTABLE, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_CONNECTABLE,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_CONNECTABLE, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tif (cp->val) {\n\t\thci_dev_set_flag(hdev, HCI_CONNECTABLE);\n\t} else {\n\t\tif (hdev->discov_timeout > 0)\n\t\t\tcancel_delayed_work(&hdev->discov_off);\n\n\t\thci_dev_clear_flag(hdev, HCI_LIMITED_DISCOVERABLE);\n\t\thci_dev_clear_flag(hdev, HCI_DISCOVERABLE);\n\t\thci_dev_clear_flag(hdev, HCI_CONNECTABLE);\n\t}\n\n\tqueue_work(hdev->req_workqueue, &hdev->connectable_update);\n\terr = 0;\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_bondable(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\tu16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tbool changed;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BONDABLE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (cp->val)\n\t\tchanged = !hci_dev_test_and_set_flag(hdev, HCI_BONDABLE);\n\telse\n\t\tchanged = hci_dev_test_and_clear_flag(hdev, HCI_BONDABLE);\n\n\terr = send_settings_rsp(sk, MGMT_OP_SET_BONDABLE, hdev);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tif (changed) {\n\t\t/* In limited privacy mode the change of bondable mode\n\t\t * may affect the local advertising address.\n\t\t */\n\t\tif (hdev_is_powered(hdev) &&\n\t\t    hci_dev_test_flag(hdev, HCI_ADVERTISING) &&\n\t\t    hci_dev_test_flag(hdev, HCI_DISCOVERABLE) &&\n\t\t    hci_dev_test_flag(hdev, HCI_LIMITED_PRIVACY))\n\t\t\tqueue_work(hdev->req_workqueue,\n\t\t\t\t   &hdev->discoverable_update);\n\n\t\terr = new_settings(hdev, sk);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_link_security(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t     u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tu8 val, status;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tstatus = mgmt_bredr_support(hdev);\n\tif (status)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LINK_SECURITY,\n\t\t\t\t       status);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LINK_SECURITY,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\tbool changed = false;\n\n\t\tif (!!cp->val != hci_dev_test_flag(hdev, HCI_LINK_SECURITY)) {\n\t\t\thci_dev_change_flag(hdev, HCI_LINK_SECURITY);\n\t\t\tchanged = true;\n\t\t}\n\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_LINK_SECURITY, hdev);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tif (changed)\n\t\t\terr = new_settings(hdev, sk);\n\n\t\tgoto failed;\n\t}\n\n\tif (pending_find(MGMT_OP_SET_LINK_SECURITY, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LINK_SECURITY,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto failed;\n\t}\n\n\tval = !!cp->val;\n\n\tif (test_bit(HCI_AUTH, &hdev->flags) == val) {\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_LINK_SECURITY, hdev);\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_LINK_SECURITY, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\terr = hci_send_cmd(hdev, HCI_OP_WRITE_AUTH_ENABLE, sizeof(val), &val);\n\tif (err < 0) {\n\t\tmgmt_pending_remove(cmd);\n\t\tgoto failed;\n\t}\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_ssp(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tu8 status;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tstatus = mgmt_bredr_support(hdev);\n\tif (status)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SSP, status);\n\n\tif (!lmp_ssp_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SSP,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SSP,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\tbool changed;\n\n\t\tif (cp->val) {\n\t\t\tchanged = !hci_dev_test_and_set_flag(hdev,\n\t\t\t\t\t\t\t     HCI_SSP_ENABLED);\n\t\t} else {\n\t\t\tchanged = hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t\t      HCI_SSP_ENABLED);\n\t\t\tif (!changed)\n\t\t\t\tchanged = hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t\t\t      HCI_HS_ENABLED);\n\t\t\telse\n\t\t\t\thci_dev_clear_flag(hdev, HCI_HS_ENABLED);\n\t\t}\n\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_SSP, hdev);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tif (changed)\n\t\t\terr = new_settings(hdev, sk);\n\n\t\tgoto failed;\n\t}\n\n\tif (pending_find(MGMT_OP_SET_SSP, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SSP,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto failed;\n\t}\n\n\tif (!!cp->val == hci_dev_test_flag(hdev, HCI_SSP_ENABLED)) {\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_SSP, hdev);\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_SSP, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tif (!cp->val && hci_dev_test_flag(hdev, HCI_USE_DEBUG_KEYS))\n\t\thci_send_cmd(hdev, HCI_OP_WRITE_SSP_DEBUG_MODE,\n\t\t\t     sizeof(cp->val), &cp->val);\n\n\terr = hci_send_cmd(hdev, HCI_OP_WRITE_SSP_MODE, 1, &cp->val);\n\tif (err < 0) {\n\t\tmgmt_pending_remove(cmd);\n\t\tgoto failed;\n\t}\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_hs(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tbool changed;\n\tu8 status;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!IS_ENABLED(CONFIG_BT_HS))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tstatus = mgmt_bredr_support(hdev);\n\tif (status)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS, status);\n\n\tif (!lmp_ssp_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (!hci_dev_test_flag(hdev, HCI_SSP_ENABLED))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (pending_find(MGMT_OP_SET_SSP, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tif (cp->val) {\n\t\tchanged = !hci_dev_test_and_set_flag(hdev, HCI_HS_ENABLED);\n\t} else {\n\t\tif (hdev_is_powered(hdev)) {\n\t\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS,\n\t\t\t\t\t      MGMT_STATUS_REJECTED);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tchanged = hci_dev_test_and_clear_flag(hdev, HCI_HS_ENABLED);\n\t}\n\n\terr = send_settings_rsp(sk, MGMT_OP_SET_HS, hdev);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tif (changed)\n\t\terr = new_settings(hdev, sk);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic void le_enable_complete(struct hci_dev *hdev, u8 status, u16 opcode)\n{\n\tstruct cmd_lookup match = { NULL, hdev };\n\n\thci_dev_lock(hdev);\n\n\tif (status) {\n\t\tu8 mgmt_err = mgmt_status(status);\n\n\t\tmgmt_pending_foreach(MGMT_OP_SET_LE, hdev, cmd_status_rsp,\n\t\t\t\t     &mgmt_err);\n\t\tgoto unlock;\n\t}\n\n\tmgmt_pending_foreach(MGMT_OP_SET_LE, hdev, settings_rsp, &match);\n\n\tnew_settings(hdev, match.sk);\n\n\tif (match.sk)\n\t\tsock_put(match.sk);\n\n\t/* Make sure the controller has a good default for\n\t * advertising data. Restrict the update to when LE\n\t * has actually been enabled. During power on, the\n\t * update in powered_update_hci will take care of it.\n\t */\n\tif (hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {\n\t\tstruct hci_request req;\n\t\thci_req_init(&req, hdev);\n\t\tif (ext_adv_capable(hdev)) {\n\t\t\tint err;\n\n\t\t\terr = __hci_req_setup_ext_adv_instance(&req, 0x00);\n\t\t\tif (!err)\n\t\t\t\t__hci_req_update_scan_rsp_data(&req, 0x00);\n\t\t} else {\n\t\t\t__hci_req_update_adv_data(&req, 0x00);\n\t\t\t__hci_req_update_scan_rsp_data(&req, 0x00);\n\t\t}\n\t\thci_req_run(&req, NULL);\n\t\thci_update_background_scan(hdev);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic int set_le(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tstruct hci_cp_write_le_host_supported hci_cp;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_request req;\n\tint err;\n\tu8 val, enabled;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LE,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\t/* Bluetooth single mode LE only controllers or dual-mode\n\t * controllers configured as LE only devices, do not allow\n\t * switching LE off. These have either LE enabled explicitly\n\t * or BR/EDR has been previously switched off.\n\t *\n\t * When trying to enable an already enabled LE, then gracefully\n\t * send a positive response. Trying to disable it however will\n\t * result into rejection.\n\t */\n\tif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED)) {\n\t\tif (cp->val == 0x01)\n\t\t\treturn send_settings_rsp(sk, MGMT_OP_SET_LE, hdev);\n\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LE,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\t}\n\n\thci_dev_lock(hdev);\n\n\tval = !!cp->val;\n\tenabled = lmp_host_le_capable(hdev);\n\n\tif (!val)\n\t\thci_req_clear_adv_instance(hdev, NULL, NULL, 0x00, true);\n\n\tif (!hdev_is_powered(hdev) || val == enabled) {\n\t\tbool changed = false;\n\n\t\tif (val != hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {\n\t\t\thci_dev_change_flag(hdev, HCI_LE_ENABLED);\n\t\t\tchanged = true;\n\t\t}\n\n\t\tif (!val && hci_dev_test_flag(hdev, HCI_ADVERTISING)) {\n\t\t\thci_dev_clear_flag(hdev, HCI_ADVERTISING);\n\t\t\tchanged = true;\n\t\t}\n\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_LE, hdev);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\n\t\tif (changed)\n\t\t\terr = new_settings(hdev, sk);\n\n\t\tgoto unlock;\n\t}\n\n\tif (pending_find(MGMT_OP_SET_LE, hdev) ||\n\t    pending_find(MGMT_OP_SET_ADVERTISING, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LE,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_LE, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\thci_req_init(&req, hdev);\n\n\tmemset(&hci_cp, 0, sizeof(hci_cp));\n\n\tif (val) {\n\t\thci_cp.le = val;\n\t\thci_cp.simul = 0x00;\n\t} else {\n\t\tif (hci_dev_test_flag(hdev, HCI_LE_ADV))\n\t\t\t__hci_req_disable_advertising(&req);\n\n\t\tif (ext_adv_capable(hdev))\n\t\t\t__hci_req_clear_ext_adv_sets(&req);\n\t}\n\n\thci_req_add(&req, HCI_OP_WRITE_LE_HOST_SUPPORTED, sizeof(hci_cp),\n\t\t    &hci_cp);\n\n\terr = hci_req_run(&req, le_enable_complete);\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\n/* This is a helper function to test for pending mgmt commands that can\n * cause CoD or EIR HCI commands. We can only allow one such pending\n * mgmt command at a time since otherwise we cannot easily track what\n * the current values are, will be, and based on that calculate if a new\n * HCI command needs to be sent and if yes with what value.\n */\nstatic bool pending_eir_or_class(struct hci_dev *hdev)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tlist_for_each_entry(cmd, &hdev->mgmt_pending, list) {\n\t\tswitch (cmd->opcode) {\n\t\tcase MGMT_OP_ADD_UUID:\n\t\tcase MGMT_OP_REMOVE_UUID:\n\t\tcase MGMT_OP_SET_DEV_CLASS:\n\t\tcase MGMT_OP_SET_POWERED:\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic const u8 bluetooth_base_uuid[] = {\n\t\t\t0xfb, 0x34, 0x9b, 0x5f, 0x80, 0x00, 0x00, 0x80,\n\t\t\t0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n};\n\nstatic u8 get_uuid_size(const u8 *uuid)\n{\n\tu32 val;\n\n\tif (memcmp(uuid, bluetooth_base_uuid, 12))\n\t\treturn 128;\n\n\tval = get_unaligned_le32(&uuid[12]);\n\tif (val > 0xffff)\n\t\treturn 32;\n\n\treturn 16;\n}\n\nstatic void mgmt_class_complete(struct hci_dev *hdev, u16 mgmt_op, u8 status)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\thci_dev_lock(hdev);\n\n\tcmd = pending_find(mgmt_op, hdev);\n\tif (!cmd)\n\t\tgoto unlock;\n\n\tmgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode,\n\t\t\t  mgmt_status(status), hdev->dev_class, 3);\n\n\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic void add_uuid_complete(struct hci_dev *hdev, u8 status, u16 opcode)\n{\n\tbt_dev_dbg(hdev, \"status 0x%02x\", status);\n\n\tmgmt_class_complete(hdev, MGMT_OP_ADD_UUID, status);\n}\n\nstatic int add_uuid(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\n{\n\tstruct mgmt_cp_add_uuid *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_request req;\n\tstruct bt_uuid *uuid;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (pending_eir_or_class(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_UUID,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto failed;\n\t}\n\n\tuuid = kmalloc(sizeof(*uuid), GFP_KERNEL);\n\tif (!uuid) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tmemcpy(uuid->uuid, cp->uuid, 16);\n\tuuid->svc_hint = cp->svc_hint;\n\tuuid->size = get_uuid_size(cp->uuid);\n\n\tlist_add_tail(&uuid->list, &hdev->uuids);\n\n\thci_req_init(&req, hdev);\n\n\t__hci_req_update_class(&req);\n\t__hci_req_update_eir(&req);\n\n\terr = hci_req_run(&req, add_uuid_complete);\n\tif (err < 0) {\n\t\tif (err != -ENODATA)\n\t\t\tgoto failed;\n\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_UUID, 0,\n\t\t\t\t\thdev->dev_class, 3);\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_ADD_UUID, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\terr = 0;\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic bool enable_service_cache(struct hci_dev *hdev)\n{\n\tif (!hdev_is_powered(hdev))\n\t\treturn false;\n\n\tif (!hci_dev_test_and_set_flag(hdev, HCI_SERVICE_CACHE)) {\n\t\tqueue_delayed_work(hdev->workqueue, &hdev->service_cache,\n\t\t\t\t   CACHE_TIMEOUT);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void remove_uuid_complete(struct hci_dev *hdev, u8 status, u16 opcode)\n{\n\tbt_dev_dbg(hdev, \"status 0x%02x\", status);\n\n\tmgmt_class_complete(hdev, MGMT_OP_REMOVE_UUID, status);\n}\n\nstatic int remove_uuid(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t       u16 len)\n{\n\tstruct mgmt_cp_remove_uuid *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct bt_uuid *match, *tmp;\n\tu8 bt_uuid_any[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\tstruct hci_request req;\n\tint err, found;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (pending_eir_or_class(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_UUID,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tif (memcmp(cp->uuid, bt_uuid_any, 16) == 0) {\n\t\thci_uuids_clear(hdev);\n\n\t\tif (enable_service_cache(hdev)) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_REMOVE_UUID,\n\t\t\t\t\t\t0, hdev->dev_class, 3);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tgoto update_class;\n\t}\n\n\tfound = 0;\n\n\tlist_for_each_entry_safe(match, tmp, &hdev->uuids, list) {\n\t\tif (memcmp(match->uuid, cp->uuid, 16) != 0)\n\t\t\tcontinue;\n\n\t\tlist_del(&match->list);\n\t\tkfree(match);\n\t\tfound++;\n\t}\n\n\tif (found == 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_UUID,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto unlock;\n\t}\n\nupdate_class:\n\thci_req_init(&req, hdev);\n\n\t__hci_req_update_class(&req);\n\t__hci_req_update_eir(&req);\n\n\terr = hci_req_run(&req, remove_uuid_complete);\n\tif (err < 0) {\n\t\tif (err != -ENODATA)\n\t\t\tgoto unlock;\n\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_UUID, 0,\n\t\t\t\t\thdev->dev_class, 3);\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_REMOVE_UUID, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\terr = 0;\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic void set_class_complete(struct hci_dev *hdev, u8 status, u16 opcode)\n{\n\tbt_dev_dbg(hdev, \"status 0x%02x\", status);\n\n\tmgmt_class_complete(hdev, MGMT_OP_SET_DEV_CLASS, status);\n}\n\nstatic int set_dev_class(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t u16 len)\n{\n\tstruct mgmt_cp_set_dev_class *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_request req;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_bredr_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DEV_CLASS,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\thci_dev_lock(hdev);\n\n\tif (pending_eir_or_class(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DEV_CLASS,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tif ((cp->minor & 0x03) != 0 || (cp->major & 0xe0) != 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DEV_CLASS,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto unlock;\n\t}\n\n\thdev->major_class = cp->major;\n\thdev->minor_class = cp->minor;\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_DEV_CLASS, 0,\n\t\t\t\t\thdev->dev_class, 3);\n\t\tgoto unlock;\n\t}\n\n\thci_req_init(&req, hdev);\n\n\tif (hci_dev_test_and_clear_flag(hdev, HCI_SERVICE_CACHE)) {\n\t\thci_dev_unlock(hdev);\n\t\tcancel_delayed_work_sync(&hdev->service_cache);\n\t\thci_dev_lock(hdev);\n\t\t__hci_req_update_eir(&req);\n\t}\n\n\t__hci_req_update_class(&req);\n\n\terr = hci_req_run(&req, set_class_complete);\n\tif (err < 0) {\n\t\tif (err != -ENODATA)\n\t\t\tgoto unlock;\n\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_DEV_CLASS, 0,\n\t\t\t\t\thdev->dev_class, 3);\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_DEV_CLASS, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\terr = 0;\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int load_link_keys(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t  u16 len)\n{\n\tstruct mgmt_cp_load_link_keys *cp = data;\n\tconst u16 max_key_count = ((U16_MAX - sizeof(*cp)) /\n\t\t\t\t   sizeof(struct mgmt_link_key_info));\n\tu16 key_count, expected_len;\n\tbool changed;\n\tint i;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_bredr_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tkey_count = __le16_to_cpu(cp->key_count);\n\tif (key_count > max_key_count) {\n\t\tbt_dev_err(hdev, \"load_link_keys: too big key_count value %u\",\n\t\t\t   key_count);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\texpected_len = struct_size(cp, keys, key_count);\n\tif (expected_len != len) {\n\t\tbt_dev_err(hdev, \"load_link_keys: expected %u bytes, got %u bytes\",\n\t\t\t   expected_len, len);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\tif (cp->debug_keys != 0x00 && cp->debug_keys != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tbt_dev_dbg(hdev, \"debug_keys %u key_count %u\", cp->debug_keys,\n\t\t   key_count);\n\n\tfor (i = 0; i < key_count; i++) {\n\t\tstruct mgmt_link_key_info *key = &cp->keys[i];\n\n\t\tif (key->addr.type != BDADDR_BREDR || key->type > 0x08)\n\t\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t\t       MGMT_OP_LOAD_LINK_KEYS,\n\t\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\thci_dev_lock(hdev);\n\n\thci_link_keys_clear(hdev);\n\n\tif (cp->debug_keys)\n\t\tchanged = !hci_dev_test_and_set_flag(hdev, HCI_KEEP_DEBUG_KEYS);\n\telse\n\t\tchanged = hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t      HCI_KEEP_DEBUG_KEYS);\n\n\tif (changed)\n\t\tnew_settings(hdev, NULL);\n\n\tfor (i = 0; i < key_count; i++) {\n\t\tstruct mgmt_link_key_info *key = &cp->keys[i];\n\n\t\tif (hci_is_blocked_key(hdev,\n\t\t\t\t       HCI_BLOCKED_KEY_TYPE_LINKKEY,\n\t\t\t\t       key->val)) {\n\t\t\tbt_dev_warn(hdev, \"Skipping blocked link key for %pMR\",\n\t\t\t\t    &key->addr.bdaddr);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Always ignore debug keys and require a new pairing if\n\t\t * the user wants to use them.\n\t\t */\n\t\tif (key->type == HCI_LK_DEBUG_COMBINATION)\n\t\t\tcontinue;\n\n\t\thci_add_link_key(hdev, NULL, &key->addr.bdaddr, key->val,\n\t\t\t\t key->type, key->pin_len, NULL);\n\t}\n\n\tmgmt_cmd_complete(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS, 0, NULL, 0);\n\n\thci_dev_unlock(hdev);\n\n\treturn 0;\n}\n\nstatic int device_unpaired(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t   u8 addr_type, struct sock *skip_sk)\n{\n\tstruct mgmt_ev_device_unpaired ev;\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = addr_type;\n\n\treturn mgmt_event(MGMT_EV_DEVICE_UNPAIRED, hdev, &ev, sizeof(ev),\n\t\t\t  skip_sk);\n}\n\nstatic int unpair_device(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t u16 len)\n{\n\tstruct mgmt_cp_unpair_device *cp = data;\n\tstruct mgmt_rp_unpair_device rp;\n\tstruct hci_conn_params *params;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_conn *conn;\n\tu8 addr_type;\n\tint err;\n\n\tmemset(&rp, 0, sizeof(rp));\n\tbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\n\trp.addr.type = cp->addr.type;\n\n\tif (!bdaddr_type_is_valid(cp->addr.type))\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &rp, sizeof(rp));\n\n\tif (cp->disconnect != 0x00 && cp->disconnect != 0x01)\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &rp, sizeof(rp));\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,\n\t\t\t\t\tMGMT_STATUS_NOT_POWERED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tif (cp->addr.type == BDADDR_BREDR) {\n\t\t/* If disconnection is requested, then look up the\n\t\t * connection. If the remote device is connected, it\n\t\t * will be later used to terminate the link.\n\t\t *\n\t\t * Setting it to NULL explicitly will cause no\n\t\t * termination of the link.\n\t\t */\n\t\tif (cp->disconnect)\n\t\t\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,\n\t\t\t\t\t\t       &cp->addr.bdaddr);\n\t\telse\n\t\t\tconn = NULL;\n\n\t\terr = hci_remove_link_key(hdev, &cp->addr.bdaddr);\n\t\tif (err < 0) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_UNPAIR_DEVICE,\n\t\t\t\t\t\tMGMT_STATUS_NOT_PAIRED, &rp,\n\t\t\t\t\t\tsizeof(rp));\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tgoto done;\n\t}\n\n\t/* LE address type */\n\taddr_type = le_addr_type(cp->addr.type);\n\n\t/* Abort any ongoing SMP pairing. Removes ltk and irk if they exist. */\n\terr = smp_cancel_and_remove_pairing(hdev, &cp->addr.bdaddr, addr_type);\n\tif (err < 0) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,\n\t\t\t\t\tMGMT_STATUS_NOT_PAIRED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tconn = hci_conn_hash_lookup_le(hdev, &cp->addr.bdaddr, addr_type);\n\tif (!conn) {\n\t\thci_conn_params_del(hdev, &cp->addr.bdaddr, addr_type);\n\t\tgoto done;\n\t}\n\n\n\t/* Defer clearing up the connection parameters until closing to\n\t * give a chance of keeping them if a repairing happens.\n\t */\n\tset_bit(HCI_CONN_PARAM_REMOVAL_PEND, &conn->flags);\n\n\t/* Disable auto-connection parameters if present */\n\tparams = hci_conn_params_lookup(hdev, &cp->addr.bdaddr, addr_type);\n\tif (params) {\n\t\tif (params->explicit_connect)\n\t\t\tparams->auto_connect = HCI_AUTO_CONN_EXPLICIT;\n\t\telse\n\t\t\tparams->auto_connect = HCI_AUTO_CONN_DISABLED;\n\t}\n\n\t/* If disconnection is not requested, then clear the connection\n\t * variable so that the link is not terminated.\n\t */\n\tif (!cp->disconnect)\n\t\tconn = NULL;\n\ndone:\n\t/* If the connection variable is set, then termination of the\n\t * link is requested.\n\t */\n\tif (!conn) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE, 0,\n\t\t\t\t\t&rp, sizeof(rp));\n\t\tdevice_unpaired(hdev, &cp->addr.bdaddr, cp->addr.type, sk);\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_UNPAIR_DEVICE, hdev, cp,\n\t\t\t       sizeof(*cp));\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tcmd->cmd_complete = addr_cmd_complete;\n\n\terr = hci_abort_conn(conn, HCI_ERROR_REMOTE_USER_TERM);\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int disconnect(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t      u16 len)\n{\n\tstruct mgmt_cp_disconnect *cp = data;\n\tstruct mgmt_rp_disconnect rp;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_conn *conn;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tmemset(&rp, 0, sizeof(rp));\n\tbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\n\trp.addr.type = cp->addr.type;\n\n\tif (!bdaddr_type_is_valid(cp->addr.type))\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_DISCONNECT,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &rp, sizeof(rp));\n\n\thci_dev_lock(hdev);\n\n\tif (!test_bit(HCI_UP, &hdev->flags)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_DISCONNECT,\n\t\t\t\t\tMGMT_STATUS_NOT_POWERED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto failed;\n\t}\n\n\tif (pending_find(MGMT_OP_DISCONNECT, hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_DISCONNECT,\n\t\t\t\t\tMGMT_STATUS_BUSY, &rp, sizeof(rp));\n\t\tgoto failed;\n\t}\n\n\tif (cp->addr.type == BDADDR_BREDR)\n\t\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,\n\t\t\t\t\t       &cp->addr.bdaddr);\n\telse\n\t\tconn = hci_conn_hash_lookup_le(hdev, &cp->addr.bdaddr,\n\t\t\t\t\t       le_addr_type(cp->addr.type));\n\n\tif (!conn || conn->state == BT_OPEN || conn->state == BT_CLOSED) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_DISCONNECT,\n\t\t\t\t\tMGMT_STATUS_NOT_CONNECTED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_DISCONNECT, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tcmd->cmd_complete = generic_cmd_complete;\n\n\terr = hci_disconnect(conn, HCI_ERROR_REMOTE_USER_TERM);\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic u8 link_to_bdaddr(u8 link_type, u8 addr_type)\n{\n\tswitch (link_type) {\n\tcase LE_LINK:\n\t\tswitch (addr_type) {\n\t\tcase ADDR_LE_DEV_PUBLIC:\n\t\t\treturn BDADDR_LE_PUBLIC;\n\n\t\tdefault:\n\t\t\t/* Fallback to LE Random address type */\n\t\t\treturn BDADDR_LE_RANDOM;\n\t\t}\n\n\tdefault:\n\t\t/* Fallback to BR/EDR type */\n\t\treturn BDADDR_BREDR;\n\t}\n}\n\nstatic int get_connections(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t   u16 data_len)\n{\n\tstruct mgmt_rp_get_connections *rp;\n\tstruct hci_conn *c;\n\tint err;\n\tu16 i;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_GET_CONNECTIONS,\n\t\t\t\t      MGMT_STATUS_NOT_POWERED);\n\t\tgoto unlock;\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(c, &hdev->conn_hash.list, list) {\n\t\tif (test_bit(HCI_CONN_MGMT_CONNECTED, &c->flags))\n\t\t\ti++;\n\t}\n\n\trp = kmalloc(struct_size(rp, addr, i), GFP_KERNEL);\n\tif (!rp) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(c, &hdev->conn_hash.list, list) {\n\t\tif (!test_bit(HCI_CONN_MGMT_CONNECTED, &c->flags))\n\t\t\tcontinue;\n\t\tbacpy(&rp->addr[i].bdaddr, &c->dst);\n\t\trp->addr[i].type = link_to_bdaddr(c->type, c->dst_type);\n\t\tif (c->type == SCO_LINK || c->type == ESCO_LINK)\n\t\t\tcontinue;\n\t\ti++;\n\t}\n\n\trp->conn_count = cpu_to_le16(i);\n\n\t/* Recalculate length in case of filtered SCO connections, etc */\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONNECTIONS, 0, rp,\n\t\t\t\tstruct_size(rp, addr, i));\n\n\tkfree(rp);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int send_pin_code_neg_reply(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t   struct mgmt_cp_pin_code_neg_reply *cp)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_NEG_REPLY, hdev, cp,\n\t\t\t       sizeof(*cp));\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->cmd_complete = addr_cmd_complete;\n\n\terr = hci_send_cmd(hdev, HCI_OP_PIN_CODE_NEG_REPLY,\n\t\t\t   sizeof(cp->addr.bdaddr), &cp->addr.bdaddr);\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\n\treturn err;\n}\n\nstatic int pin_code_reply(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t  u16 len)\n{\n\tstruct hci_conn *conn;\n\tstruct mgmt_cp_pin_code_reply *cp = data;\n\tstruct hci_cp_pin_code_reply reply;\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,\n\t\t\t\t      MGMT_STATUS_NOT_POWERED);\n\t\tgoto failed;\n\t}\n\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->addr.bdaddr);\n\tif (!conn) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,\n\t\t\t\t      MGMT_STATUS_NOT_CONNECTED);\n\t\tgoto failed;\n\t}\n\n\tif (conn->pending_sec_level == BT_SECURITY_HIGH && cp->pin_len != 16) {\n\t\tstruct mgmt_cp_pin_code_neg_reply ncp;\n\n\t\tmemcpy(&ncp.addr, &cp->addr, sizeof(ncp.addr));\n\n\t\tbt_dev_err(hdev, \"PIN code is not 16 bytes long\");\n\n\t\terr = send_pin_code_neg_reply(sk, hdev, &ncp);\n\t\tif (err >= 0)\n\t\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,\n\t\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_REPLY, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tcmd->cmd_complete = addr_cmd_complete;\n\n\tbacpy(&reply.bdaddr, &cp->addr.bdaddr);\n\treply.pin_len = cp->pin_len;\n\tmemcpy(reply.pin_code, cp->pin_code, sizeof(reply.pin_code));\n\n\terr = hci_send_cmd(hdev, HCI_OP_PIN_CODE_REPLY, sizeof(reply), &reply);\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_io_capability(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t     u16 len)\n{\n\tstruct mgmt_cp_set_io_capability *cp = data;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (cp->io_capability > SMP_IO_KEYBOARD_DISPLAY)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_IO_CAPABILITY,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\thdev->io_capability = cp->io_capability;\n\n\tbt_dev_dbg(hdev, \"IO capability set to 0x%02x\", hdev->io_capability);\n\n\thci_dev_unlock(hdev);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_IO_CAPABILITY, 0,\n\t\t\t\t NULL, 0);\n}\n\nstatic struct mgmt_pending_cmd *find_pairing(struct hci_conn *conn)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\tstruct mgmt_pending_cmd *cmd;\n\n\tlist_for_each_entry(cmd, &hdev->mgmt_pending, list) {\n\t\tif (cmd->opcode != MGMT_OP_PAIR_DEVICE)\n\t\t\tcontinue;\n\n\t\tif (cmd->user_data != conn)\n\t\t\tcontinue;\n\n\t\treturn cmd;\n\t}\n\n\treturn NULL;\n}\n\nstatic int pairing_complete(struct mgmt_pending_cmd *cmd, u8 status)\n{\n\tstruct mgmt_rp_pair_device rp;\n\tstruct hci_conn *conn = cmd->user_data;\n\tint err;\n\n\tbacpy(&rp.addr.bdaddr, &conn->dst);\n\trp.addr.type = link_to_bdaddr(conn->type, conn->dst_type);\n\n\terr = mgmt_cmd_complete(cmd->sk, cmd->index, MGMT_OP_PAIR_DEVICE,\n\t\t\t\tstatus, &rp, sizeof(rp));\n\n\t/* So we don't get further callbacks for this connection */\n\tconn->connect_cfm_cb = NULL;\n\tconn->security_cfm_cb = NULL;\n\tconn->disconn_cfm_cb = NULL;\n\n\thci_conn_drop(conn);\n\n\t/* The device is paired so there is no need to remove\n\t * its connection parameters anymore.\n\t */\n\tclear_bit(HCI_CONN_PARAM_REMOVAL_PEND, &conn->flags);\n\n\thci_conn_put(conn);\n\n\treturn err;\n}\n\nvoid mgmt_smp_complete(struct hci_conn *conn, bool complete)\n{\n\tu8 status = complete ? MGMT_STATUS_SUCCESS : MGMT_STATUS_FAILED;\n\tstruct mgmt_pending_cmd *cmd;\n\n\tcmd = find_pairing(conn);\n\tif (cmd) {\n\t\tcmd->cmd_complete(cmd, status);\n\t\tmgmt_pending_remove(cmd);\n\t}\n}\n\nstatic void pairing_complete_cb(struct hci_conn *conn, u8 status)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tBT_DBG(\"status %u\", status);\n\n\tcmd = find_pairing(conn);\n\tif (!cmd) {\n\t\tBT_DBG(\"Unable to find a pending command\");\n\t\treturn;\n\t}\n\n\tcmd->cmd_complete(cmd, mgmt_status(status));\n\tmgmt_pending_remove(cmd);\n}\n\nstatic void le_pairing_complete_cb(struct hci_conn *conn, u8 status)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tBT_DBG(\"status %u\", status);\n\n\tif (!status)\n\t\treturn;\n\n\tcmd = find_pairing(conn);\n\tif (!cmd) {\n\t\tBT_DBG(\"Unable to find a pending command\");\n\t\treturn;\n\t}\n\n\tcmd->cmd_complete(cmd, mgmt_status(status));\n\tmgmt_pending_remove(cmd);\n}\n\nstatic int pair_device(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t       u16 len)\n{\n\tstruct mgmt_cp_pair_device *cp = data;\n\tstruct mgmt_rp_pair_device rp;\n\tstruct mgmt_pending_cmd *cmd;\n\tu8 sec_level, auth_type;\n\tstruct hci_conn *conn;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tmemset(&rp, 0, sizeof(rp));\n\tbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\n\trp.addr.type = cp->addr.type;\n\n\tif (!bdaddr_type_is_valid(cp->addr.type))\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &rp, sizeof(rp));\n\n\tif (cp->io_cap > SMP_IO_KEYBOARD_DISPLAY)\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &rp, sizeof(rp));\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\n\t\t\t\t\tMGMT_STATUS_NOT_POWERED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tif (hci_bdaddr_is_paired(hdev, &cp->addr.bdaddr, cp->addr.type)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\n\t\t\t\t\tMGMT_STATUS_ALREADY_PAIRED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tsec_level = BT_SECURITY_MEDIUM;\n\tauth_type = HCI_AT_DEDICATED_BONDING;\n\n\tif (cp->addr.type == BDADDR_BREDR) {\n\t\tconn = hci_connect_acl(hdev, &cp->addr.bdaddr, sec_level,\n\t\t\t\t       auth_type, CONN_REASON_PAIR_DEVICE);\n\t} else {\n\t\tu8 addr_type = le_addr_type(cp->addr.type);\n\t\tstruct hci_conn_params *p;\n\n\t\t/* When pairing a new device, it is expected to remember\n\t\t * this device for future connections. Adding the connection\n\t\t * parameter information ahead of time allows tracking\n\t\t * of the slave preferred values and will speed up any\n\t\t * further connection establishment.\n\t\t *\n\t\t * If connection parameters already exist, then they\n\t\t * will be kept and this function does nothing.\n\t\t */\n\t\tp = hci_conn_params_add(hdev, &cp->addr.bdaddr, addr_type);\n\n\t\tif (p->auto_connect == HCI_AUTO_CONN_EXPLICIT)\n\t\t\tp->auto_connect = HCI_AUTO_CONN_DISABLED;\n\n\t\tconn = hci_connect_le_scan(hdev, &cp->addr.bdaddr, addr_type,\n\t\t\t\t\t   sec_level, HCI_LE_CONN_TIMEOUT,\n\t\t\t\t\t   CONN_REASON_PAIR_DEVICE);\n\t}\n\n\tif (IS_ERR(conn)) {\n\t\tint status;\n\n\t\tif (PTR_ERR(conn) == -EBUSY)\n\t\t\tstatus = MGMT_STATUS_BUSY;\n\t\telse if (PTR_ERR(conn) == -EOPNOTSUPP)\n\t\t\tstatus = MGMT_STATUS_NOT_SUPPORTED;\n\t\telse if (PTR_ERR(conn) == -ECONNREFUSED)\n\t\t\tstatus = MGMT_STATUS_REJECTED;\n\t\telse\n\t\t\tstatus = MGMT_STATUS_CONNECT_FAILED;\n\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\n\t\t\t\t\tstatus, &rp, sizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tif (conn->connect_cfm_cb) {\n\t\thci_conn_drop(conn);\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\n\t\t\t\t\tMGMT_STATUS_BUSY, &rp, sizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_PAIR_DEVICE, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\thci_conn_drop(conn);\n\t\tgoto unlock;\n\t}\n\n\tcmd->cmd_complete = pairing_complete;\n\n\t/* For LE, just connecting isn't a proof that the pairing finished */\n\tif (cp->addr.type == BDADDR_BREDR) {\n\t\tconn->connect_cfm_cb = pairing_complete_cb;\n\t\tconn->security_cfm_cb = pairing_complete_cb;\n\t\tconn->disconn_cfm_cb = pairing_complete_cb;\n\t} else {\n\t\tconn->connect_cfm_cb = le_pairing_complete_cb;\n\t\tconn->security_cfm_cb = le_pairing_complete_cb;\n\t\tconn->disconn_cfm_cb = le_pairing_complete_cb;\n\t}\n\n\tconn->io_capability = cp->io_cap;\n\tcmd->user_data = hci_conn_get(conn);\n\n\tif ((conn->state == BT_CONNECTED || conn->state == BT_CONFIG) &&\n\t    hci_conn_security(conn, sec_level, auth_type, true)) {\n\t\tcmd->cmd_complete(cmd, 0);\n\t\tmgmt_pending_remove(cmd);\n\t}\n\n\terr = 0;\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int cancel_pair_device(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t      u16 len)\n{\n\tstruct mgmt_addr_info *addr = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_conn *conn;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE,\n\t\t\t\t      MGMT_STATUS_NOT_POWERED);\n\t\tgoto unlock;\n\t}\n\n\tcmd = pending_find(MGMT_OP_PAIR_DEVICE, hdev);\n\tif (!cmd) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto unlock;\n\t}\n\n\tconn = cmd->user_data;\n\n\tif (bacmp(&addr->bdaddr, &conn->dst) != 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto unlock;\n\t}\n\n\tcmd->cmd_complete(cmd, MGMT_STATUS_CANCELLED);\n\tmgmt_pending_remove(cmd);\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE, 0,\n\t\t\t\taddr, sizeof(*addr));\n\n\t/* Since user doesn't want to proceed with the connection, abort any\n\t * ongoing pairing and then terminate the link if it was created\n\t * because of the pair device action.\n\t */\n\tif (addr->type == BDADDR_BREDR)\n\t\thci_remove_link_key(hdev, &addr->bdaddr);\n\telse\n\t\tsmp_cancel_and_remove_pairing(hdev, &addr->bdaddr,\n\t\t\t\t\t      le_addr_type(addr->type));\n\n\tif (conn->conn_reason == CONN_REASON_PAIR_DEVICE)\n\t\thci_abort_conn(conn, HCI_ERROR_REMOTE_USER_TERM);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int user_pairing_resp(struct sock *sk, struct hci_dev *hdev,\n\t\t\t     struct mgmt_addr_info *addr, u16 mgmt_op,\n\t\t\t     u16 hci_op, __le32 passkey)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_conn *conn;\n\tint err;\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, mgmt_op,\n\t\t\t\t\tMGMT_STATUS_NOT_POWERED, addr,\n\t\t\t\t\tsizeof(*addr));\n\t\tgoto done;\n\t}\n\n\tif (addr->type == BDADDR_BREDR)\n\t\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &addr->bdaddr);\n\telse\n\t\tconn = hci_conn_hash_lookup_le(hdev, &addr->bdaddr,\n\t\t\t\t\t       le_addr_type(addr->type));\n\n\tif (!conn) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, mgmt_op,\n\t\t\t\t\tMGMT_STATUS_NOT_CONNECTED, addr,\n\t\t\t\t\tsizeof(*addr));\n\t\tgoto done;\n\t}\n\n\tif (addr->type == BDADDR_LE_PUBLIC || addr->type == BDADDR_LE_RANDOM) {\n\t\terr = smp_user_confirm_reply(conn, mgmt_op, passkey);\n\t\tif (!err)\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id, mgmt_op,\n\t\t\t\t\t\tMGMT_STATUS_SUCCESS, addr,\n\t\t\t\t\t\tsizeof(*addr));\n\t\telse\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id, mgmt_op,\n\t\t\t\t\t\tMGMT_STATUS_FAILED, addr,\n\t\t\t\t\t\tsizeof(*addr));\n\n\t\tgoto done;\n\t}\n\n\tcmd = mgmt_pending_add(sk, mgmt_op, hdev, addr, sizeof(*addr));\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tcmd->cmd_complete = addr_cmd_complete;\n\n\t/* Continue with pairing via HCI */\n\tif (hci_op == HCI_OP_USER_PASSKEY_REPLY) {\n\t\tstruct hci_cp_user_passkey_reply cp;\n\n\t\tbacpy(&cp.bdaddr, &addr->bdaddr);\n\t\tcp.passkey = passkey;\n\t\terr = hci_send_cmd(hdev, hci_op, sizeof(cp), &cp);\n\t} else\n\t\terr = hci_send_cmd(hdev, hci_op, sizeof(addr->bdaddr),\n\t\t\t\t   &addr->bdaddr);\n\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\ndone:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int pin_code_neg_reply(struct sock *sk, struct hci_dev *hdev,\n\t\t\t      void *data, u16 len)\n{\n\tstruct mgmt_cp_pin_code_neg_reply *cp = data;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\treturn user_pairing_resp(sk, hdev, &cp->addr,\n\t\t\t\tMGMT_OP_PIN_CODE_NEG_REPLY,\n\t\t\t\tHCI_OP_PIN_CODE_NEG_REPLY, 0);\n}\n\nstatic int user_confirm_reply(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t      u16 len)\n{\n\tstruct mgmt_cp_user_confirm_reply *cp = data;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (len != sizeof(*cp))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_USER_CONFIRM_REPLY,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\treturn user_pairing_resp(sk, hdev, &cp->addr,\n\t\t\t\t MGMT_OP_USER_CONFIRM_REPLY,\n\t\t\t\t HCI_OP_USER_CONFIRM_REPLY, 0);\n}\n\nstatic int user_confirm_neg_reply(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t  void *data, u16 len)\n{\n\tstruct mgmt_cp_user_confirm_neg_reply *cp = data;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\treturn user_pairing_resp(sk, hdev, &cp->addr,\n\t\t\t\t MGMT_OP_USER_CONFIRM_NEG_REPLY,\n\t\t\t\t HCI_OP_USER_CONFIRM_NEG_REPLY, 0);\n}\n\nstatic int user_passkey_reply(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t      u16 len)\n{\n\tstruct mgmt_cp_user_passkey_reply *cp = data;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\treturn user_pairing_resp(sk, hdev, &cp->addr,\n\t\t\t\t MGMT_OP_USER_PASSKEY_REPLY,\n\t\t\t\t HCI_OP_USER_PASSKEY_REPLY, cp->passkey);\n}\n\nstatic int user_passkey_neg_reply(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t  void *data, u16 len)\n{\n\tstruct mgmt_cp_user_passkey_neg_reply *cp = data;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\treturn user_pairing_resp(sk, hdev, &cp->addr,\n\t\t\t\t MGMT_OP_USER_PASSKEY_NEG_REPLY,\n\t\t\t\t HCI_OP_USER_PASSKEY_NEG_REPLY, 0);\n}\n\nstatic void adv_expire(struct hci_dev *hdev, u32 flags)\n{\n\tstruct adv_info *adv_instance;\n\tstruct hci_request req;\n\tint err;\n\n\tadv_instance = hci_find_adv_instance(hdev, hdev->cur_adv_instance);\n\tif (!adv_instance)\n\t\treturn;\n\n\t/* stop if current instance doesn't need to be changed */\n\tif (!(adv_instance->flags & flags))\n\t\treturn;\n\n\tcancel_adv_timeout(hdev);\n\n\tadv_instance = hci_get_next_instance(hdev, adv_instance->instance);\n\tif (!adv_instance)\n\t\treturn;\n\n\thci_req_init(&req, hdev);\n\terr = __hci_req_schedule_adv_instance(&req, adv_instance->instance,\n\t\t\t\t\t      true);\n\tif (err)\n\t\treturn;\n\n\thci_req_run(&req, NULL);\n}\n\nstatic void set_name_complete(struct hci_dev *hdev, u8 status, u16 opcode)\n{\n\tstruct mgmt_cp_set_local_name *cp;\n\tstruct mgmt_pending_cmd *cmd;\n\n\tbt_dev_dbg(hdev, \"status 0x%02x\", status);\n\n\thci_dev_lock(hdev);\n\n\tcmd = pending_find(MGMT_OP_SET_LOCAL_NAME, hdev);\n\tif (!cmd)\n\t\tgoto unlock;\n\n\tcp = cmd->param;\n\n\tif (status) {\n\t\tmgmt_cmd_status(cmd->sk, hdev->id, MGMT_OP_SET_LOCAL_NAME,\n\t\t\t        mgmt_status(status));\n\t} else {\n\t\tmgmt_cmd_complete(cmd->sk, hdev->id, MGMT_OP_SET_LOCAL_NAME, 0,\n\t\t\t\t  cp, sizeof(*cp));\n\n\t\tif (hci_dev_test_flag(hdev, HCI_LE_ADV))\n\t\t\tadv_expire(hdev, MGMT_ADV_FLAG_LOCAL_NAME);\n\t}\n\n\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic int set_local_name(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t  u16 len)\n{\n\tstruct mgmt_cp_set_local_name *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_request req;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\t/* If the old values are the same as the new ones just return a\n\t * direct command complete event.\n\t */\n\tif (!memcmp(hdev->dev_name, cp->name, sizeof(hdev->dev_name)) &&\n\t    !memcmp(hdev->short_name, cp->short_name,\n\t\t    sizeof(hdev->short_name))) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_LOCAL_NAME, 0,\n\t\t\t\t\tdata, len);\n\t\tgoto failed;\n\t}\n\n\tmemcpy(hdev->short_name, cp->short_name, sizeof(hdev->short_name));\n\n\tif (!hdev_is_powered(hdev)) {\n\t\tmemcpy(hdev->dev_name, cp->name, sizeof(hdev->dev_name));\n\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_LOCAL_NAME, 0,\n\t\t\t\t\tdata, len);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\terr = mgmt_limited_event(MGMT_EV_LOCAL_NAME_CHANGED, hdev, data,\n\t\t\t\t\t len, HCI_MGMT_LOCAL_NAME_EVENTS, sk);\n\t\text_info_changed(hdev, sk);\n\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_LOCAL_NAME, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tmemcpy(hdev->dev_name, cp->name, sizeof(hdev->dev_name));\n\n\thci_req_init(&req, hdev);\n\n\tif (lmp_bredr_capable(hdev)) {\n\t\t__hci_req_update_name(&req);\n\t\t__hci_req_update_eir(&req);\n\t}\n\n\t/* The name is stored in the scan response data and so\n\t * no need to udpate the advertising data here.\n\t */\n\tif (lmp_le_capable(hdev) && hci_dev_test_flag(hdev, HCI_ADVERTISING))\n\t\t__hci_req_update_scan_rsp_data(&req, hdev->cur_adv_instance);\n\n\terr = hci_req_run(&req, set_name_complete);\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_appearance(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t  u16 len)\n{\n\tstruct mgmt_cp_set_appearance *cp = data;\n\tu16 appearance;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_APPEARANCE,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tappearance = le16_to_cpu(cp->appearance);\n\n\thci_dev_lock(hdev);\n\n\tif (hdev->appearance != appearance) {\n\t\thdev->appearance = appearance;\n\n\t\tif (hci_dev_test_flag(hdev, HCI_LE_ADV))\n\t\t\tadv_expire(hdev, MGMT_ADV_FLAG_APPEARANCE);\n\n\t\text_info_changed(hdev, sk);\n\t}\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_APPEARANCE, 0, NULL,\n\t\t\t\t0);\n\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic int get_phy_configuration(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t void *data, u16 len)\n{\n\tstruct mgmt_rp_get_phy_configuration rp;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tmemset(&rp, 0, sizeof(rp));\n\n\trp.supported_phys = cpu_to_le32(get_supported_phys(hdev));\n\trp.selected_phys = cpu_to_le32(get_selected_phys(hdev));\n\trp.configurable_phys = cpu_to_le32(get_configurable_phys(hdev));\n\n\thci_dev_unlock(hdev);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_PHY_CONFIGURATION, 0,\n\t\t\t\t &rp, sizeof(rp));\n}\n\nint mgmt_phy_configuration_changed(struct hci_dev *hdev, struct sock *skip)\n{\n\tstruct mgmt_ev_phy_configuration_changed ev;\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\tev.selected_phys = cpu_to_le32(get_selected_phys(hdev));\n\n\treturn mgmt_event(MGMT_EV_PHY_CONFIGURATION_CHANGED, hdev, &ev,\n\t\t\t  sizeof(ev), skip);\n}\n\nstatic void set_default_phy_complete(struct hci_dev *hdev, u8 status,\n\t\t\t\t     u16 opcode, struct sk_buff *skb)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tbt_dev_dbg(hdev, \"status 0x%02x\", status);\n\n\thci_dev_lock(hdev);\n\n\tcmd = pending_find(MGMT_OP_SET_PHY_CONFIGURATION, hdev);\n\tif (!cmd)\n\t\tgoto unlock;\n\n\tif (status) {\n\t\tmgmt_cmd_status(cmd->sk, hdev->id,\n\t\t\t\tMGMT_OP_SET_PHY_CONFIGURATION,\n\t\t\t\tmgmt_status(status));\n\t} else {\n\t\tmgmt_cmd_complete(cmd->sk, hdev->id,\n\t\t\t\t  MGMT_OP_SET_PHY_CONFIGURATION, 0,\n\t\t\t\t  NULL, 0);\n\n\t\tmgmt_phy_configuration_changed(hdev, cmd->sk);\n\t}\n\n\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic int set_phy_configuration(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t void *data, u16 len)\n{\n\tstruct mgmt_cp_set_phy_configuration *cp = data;\n\tstruct hci_cp_le_set_default_phy cp_phy;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_request req;\n\tu32 selected_phys, configurable_phys, supported_phys, unconfigure_phys;\n\tu16 pkt_type = (HCI_DH1 | HCI_DM1);\n\tbool changed = false;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tconfigurable_phys = get_configurable_phys(hdev);\n\tsupported_phys = get_supported_phys(hdev);\n\tselected_phys = __le32_to_cpu(cp->selected_phys);\n\n\tif (selected_phys & ~supported_phys)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_PHY_CONFIGURATION,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tunconfigure_phys = supported_phys & ~configurable_phys;\n\n\tif ((selected_phys & unconfigure_phys) != unconfigure_phys)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_PHY_CONFIGURATION,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tif (selected_phys == get_selected_phys(hdev))\n\t\treturn mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t MGMT_OP_SET_PHY_CONFIGURATION,\n\t\t\t\t\t 0, NULL, 0);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t      MGMT_OP_SET_PHY_CONFIGURATION,\n\t\t\t\t      MGMT_STATUS_REJECTED);\n\t\tgoto unlock;\n\t}\n\n\tif (pending_find(MGMT_OP_SET_PHY_CONFIGURATION, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t      MGMT_OP_SET_PHY_CONFIGURATION,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tif (selected_phys & MGMT_PHY_BR_1M_3SLOT)\n\t\tpkt_type |= (HCI_DH3 | HCI_DM3);\n\telse\n\t\tpkt_type &= ~(HCI_DH3 | HCI_DM3);\n\n\tif (selected_phys & MGMT_PHY_BR_1M_5SLOT)\n\t\tpkt_type |= (HCI_DH5 | HCI_DM5);\n\telse\n\t\tpkt_type &= ~(HCI_DH5 | HCI_DM5);\n\n\tif (selected_phys & MGMT_PHY_EDR_2M_1SLOT)\n\t\tpkt_type &= ~HCI_2DH1;\n\telse\n\t\tpkt_type |= HCI_2DH1;\n\n\tif (selected_phys & MGMT_PHY_EDR_2M_3SLOT)\n\t\tpkt_type &= ~HCI_2DH3;\n\telse\n\t\tpkt_type |= HCI_2DH3;\n\n\tif (selected_phys & MGMT_PHY_EDR_2M_5SLOT)\n\t\tpkt_type &= ~HCI_2DH5;\n\telse\n\t\tpkt_type |= HCI_2DH5;\n\n\tif (selected_phys & MGMT_PHY_EDR_3M_1SLOT)\n\t\tpkt_type &= ~HCI_3DH1;\n\telse\n\t\tpkt_type |= HCI_3DH1;\n\n\tif (selected_phys & MGMT_PHY_EDR_3M_3SLOT)\n\t\tpkt_type &= ~HCI_3DH3;\n\telse\n\t\tpkt_type |= HCI_3DH3;\n\n\tif (selected_phys & MGMT_PHY_EDR_3M_5SLOT)\n\t\tpkt_type &= ~HCI_3DH5;\n\telse\n\t\tpkt_type |= HCI_3DH5;\n\n\tif (pkt_type != hdev->pkt_type) {\n\t\thdev->pkt_type = pkt_type;\n\t\tchanged = true;\n\t}\n\n\tif ((selected_phys & MGMT_PHY_LE_MASK) ==\n\t    (get_selected_phys(hdev) & MGMT_PHY_LE_MASK)) {\n\t\tif (changed)\n\t\t\tmgmt_phy_configuration_changed(hdev, sk);\n\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_SET_PHY_CONFIGURATION,\n\t\t\t\t\t0, NULL, 0);\n\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_PHY_CONFIGURATION, hdev, data,\n\t\t\t       len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\thci_req_init(&req, hdev);\n\n\tmemset(&cp_phy, 0, sizeof(cp_phy));\n\n\tif (!(selected_phys & MGMT_PHY_LE_TX_MASK))\n\t\tcp_phy.all_phys |= 0x01;\n\n\tif (!(selected_phys & MGMT_PHY_LE_RX_MASK))\n\t\tcp_phy.all_phys |= 0x02;\n\n\tif (selected_phys & MGMT_PHY_LE_1M_TX)\n\t\tcp_phy.tx_phys |= HCI_LE_SET_PHY_1M;\n\n\tif (selected_phys & MGMT_PHY_LE_2M_TX)\n\t\tcp_phy.tx_phys |= HCI_LE_SET_PHY_2M;\n\n\tif (selected_phys & MGMT_PHY_LE_CODED_TX)\n\t\tcp_phy.tx_phys |= HCI_LE_SET_PHY_CODED;\n\n\tif (selected_phys & MGMT_PHY_LE_1M_RX)\n\t\tcp_phy.rx_phys |= HCI_LE_SET_PHY_1M;\n\n\tif (selected_phys & MGMT_PHY_LE_2M_RX)\n\t\tcp_phy.rx_phys |= HCI_LE_SET_PHY_2M;\n\n\tif (selected_phys & MGMT_PHY_LE_CODED_RX)\n\t\tcp_phy.rx_phys |= HCI_LE_SET_PHY_CODED;\n\n\thci_req_add(&req, HCI_OP_LE_SET_DEFAULT_PHY, sizeof(cp_phy), &cp_phy);\n\n\terr = hci_req_run_skb(&req, set_default_phy_complete);\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic int set_blocked_keys(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t    u16 len)\n{\n\tint err = MGMT_STATUS_SUCCESS;\n\tstruct mgmt_cp_set_blocked_keys *keys = data;\n\tconst u16 max_key_count = ((U16_MAX - sizeof(*keys)) /\n\t\t\t\t   sizeof(struct mgmt_blocked_key_info));\n\tu16 key_count, expected_len;\n\tint i;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tkey_count = __le16_to_cpu(keys->key_count);\n\tif (key_count > max_key_count) {\n\t\tbt_dev_err(hdev, \"too big key_count value %u\", key_count);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\texpected_len = struct_size(keys, keys, key_count);\n\tif (expected_len != len) {\n\t\tbt_dev_err(hdev, \"expected %u bytes, got %u bytes\",\n\t\t\t   expected_len, len);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\thci_dev_lock(hdev);\n\n\thci_blocked_keys_clear(hdev);\n\n\tfor (i = 0; i < keys->key_count; ++i) {\n\t\tstruct blocked_key *b = kzalloc(sizeof(*b), GFP_KERNEL);\n\n\t\tif (!b) {\n\t\t\terr = MGMT_STATUS_NO_RESOURCES;\n\t\t\tbreak;\n\t\t}\n\n\t\tb->type = keys->keys[i].type;\n\t\tmemcpy(b->val, keys->keys[i].val, sizeof(b->val));\n\t\tlist_add_rcu(&b->list, &hdev->blocked_keys);\n\t}\n\thci_dev_unlock(hdev);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,\n\t\t\t\terr, NULL, 0);\n}\n\nstatic int set_wideband_speech(struct sock *sk, struct hci_dev *hdev,\n\t\t\t       void *data, u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tint err;\n\tbool changed = false;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!test_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED, &hdev->quirks))\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_WIDEBAND_SPEECH,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t       MGMT_OP_SET_WIDEBAND_SPEECH,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (pending_find(MGMT_OP_SET_WIDEBAND_SPEECH, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t      MGMT_OP_SET_WIDEBAND_SPEECH,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tif (hdev_is_powered(hdev) &&\n\t    !!cp->val != hci_dev_test_flag(hdev,\n\t\t\t\t\t   HCI_WIDEBAND_SPEECH_ENABLED)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t      MGMT_OP_SET_WIDEBAND_SPEECH,\n\t\t\t\t      MGMT_STATUS_REJECTED);\n\t\tgoto unlock;\n\t}\n\n\tif (cp->val)\n\t\tchanged = !hci_dev_test_and_set_flag(hdev,\n\t\t\t\t\t\t   HCI_WIDEBAND_SPEECH_ENABLED);\n\telse\n\t\tchanged = hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t   HCI_WIDEBAND_SPEECH_ENABLED);\n\n\terr = send_settings_rsp(sk, MGMT_OP_SET_WIDEBAND_SPEECH, hdev);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tif (changed)\n\t\terr = new_settings(hdev, sk);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int read_controller_cap(struct sock *sk, struct hci_dev *hdev,\n\t\t\t       void *data, u16 data_len)\n{\n\tchar buf[20];\n\tstruct mgmt_rp_read_controller_cap *rp = (void *)buf;\n\tu16 cap_len = 0;\n\tu8 flags = 0;\n\tu8 tx_power_range[2];\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tmemset(&buf, 0, sizeof(buf));\n\n\thci_dev_lock(hdev);\n\n\t/* When the Read Simple Pairing Options command is supported, then\n\t * the remote public key validation is supported.\n\t */\n\tif (hdev->commands[41] & 0x08)\n\t\tflags |= 0x01;\t/* Remote public key validation (BR/EDR) */\n\n\tflags |= 0x02;\t\t/* Remote public key validation (LE) */\n\n\t/* When the Read Encryption Key Size command is supported, then the\n\t * encryption key size is enforced.\n\t */\n\tif (hdev->commands[20] & 0x10)\n\t\tflags |= 0x04;\t/* Encryption key size enforcement (BR/EDR) */\n\n\tflags |= 0x08;\t\t/* Encryption key size enforcement (LE) */\n\n\tcap_len = eir_append_data(rp->cap, cap_len, MGMT_CAP_SEC_FLAGS,\n\t\t\t\t  &flags, 1);\n\n\t/* When the Read Simple Pairing Options command is supported, then\n\t * also max encryption key size information is provided.\n\t */\n\tif (hdev->commands[41] & 0x08)\n\t\tcap_len = eir_append_le16(rp->cap, cap_len,\n\t\t\t\t\t  MGMT_CAP_MAX_ENC_KEY_SIZE,\n\t\t\t\t\t  hdev->max_enc_key_size);\n\n\tcap_len = eir_append_le16(rp->cap, cap_len,\n\t\t\t\t  MGMT_CAP_SMP_MAX_ENC_KEY_SIZE,\n\t\t\t\t  SMP_MAX_ENC_KEY_SIZE);\n\n\t/* Append the min/max LE tx power parameters if we were able to fetch\n\t * it from the controller\n\t */\n\tif (hdev->commands[38] & 0x80) {\n\t\tmemcpy(&tx_power_range[0], &hdev->min_le_tx_power, 1);\n\t\tmemcpy(&tx_power_range[1], &hdev->max_le_tx_power, 1);\n\t\tcap_len = eir_append_data(rp->cap, cap_len, MGMT_CAP_LE_TX_PWR,\n\t\t\t\t\t  tx_power_range, 2);\n\t}\n\n\trp->cap_len = cpu_to_le16(cap_len);\n\n\thci_dev_unlock(hdev);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_CONTROLLER_CAP, 0,\n\t\t\t\t rp, sizeof(*rp) + cap_len);\n}\n\n#ifdef CONFIG_BT_FEATURE_DEBUG\n/* d4992530-b9ec-469f-ab01-6c481c47da1c */\nstatic const u8 debug_uuid[16] = {\n\t0x1c, 0xda, 0x47, 0x1c, 0x48, 0x6c, 0x01, 0xab,\n\t0x9f, 0x46, 0xec, 0xb9, 0x30, 0x25, 0x99, 0xd4,\n};\n#endif\n\n/* 671b10b5-42c0-4696-9227-eb28d1b049d6 */\nstatic const u8 simult_central_periph_uuid[16] = {\n\t0xd6, 0x49, 0xb0, 0xd1, 0x28, 0xeb, 0x27, 0x92,\n\t0x96, 0x46, 0xc0, 0x42, 0xb5, 0x10, 0x1b, 0x67,\n};\n\n/* 15c0a148-c273-11ea-b3de-0242ac130004 */\nstatic const u8 rpa_resolution_uuid[16] = {\n\t0x04, 0x00, 0x13, 0xac, 0x42, 0x02, 0xde, 0xb3,\n\t0xea, 0x11, 0x73, 0xc2, 0x48, 0xa1, 0xc0, 0x15,\n};\n\nstatic int read_exp_features_info(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t  void *data, u16 data_len)\n{\n\tchar buf[62];\t/* Enough space for 3 features */\n\tstruct mgmt_rp_read_exp_features_info *rp = (void *)buf;\n\tu16 idx = 0;\n\tu32 flags;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tmemset(&buf, 0, sizeof(buf));\n\n#ifdef CONFIG_BT_FEATURE_DEBUG\n\tif (!hdev) {\n\t\tflags = bt_dbg_get() ? BIT(0) : 0;\n\n\t\tmemcpy(rp->features[idx].uuid, debug_uuid, 16);\n\t\trp->features[idx].flags = cpu_to_le32(flags);\n\t\tidx++;\n\t}\n#endif\n\n\tif (hdev) {\n\t\tif (test_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks) &&\n\t\t    (hdev->le_states[4] & 0x08) &&\t/* Central */\n\t\t    (hdev->le_states[4] & 0x40) &&\t/* Peripheral */\n\t\t    (hdev->le_states[3] & 0x10))\t/* Simultaneous */\n\t\t\tflags = BIT(0);\n\t\telse\n\t\t\tflags = 0;\n\n\t\tmemcpy(rp->features[idx].uuid, simult_central_periph_uuid, 16);\n\t\trp->features[idx].flags = cpu_to_le32(flags);\n\t\tidx++;\n\t}\n\n\tif (hdev && use_ll_privacy(hdev)) {\n\t\tif (hci_dev_test_flag(hdev, HCI_ENABLE_LL_PRIVACY))\n\t\t\tflags = BIT(0) | BIT(1);\n\t\telse\n\t\t\tflags = BIT(1);\n\n\t\tmemcpy(rp->features[idx].uuid, rpa_resolution_uuid, 16);\n\t\trp->features[idx].flags = cpu_to_le32(flags);\n\t\tidx++;\n\t}\n\n\trp->feature_count = cpu_to_le16(idx);\n\n\t/* After reading the experimental features information, enable\n\t * the events to update client on any future change.\n\t */\n\thci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);\n\n\treturn mgmt_cmd_complete(sk, hdev ? hdev->id : MGMT_INDEX_NONE,\n\t\t\t\t MGMT_OP_READ_EXP_FEATURES_INFO,\n\t\t\t\t 0, rp, sizeof(*rp) + (20 * idx));\n}\n\nstatic int exp_ll_privacy_feature_changed(bool enabled, struct hci_dev *hdev,\n\t\t\t\t\t  struct sock *skip)\n{\n\tstruct mgmt_ev_exp_feature_changed ev;\n\n\tmemset(&ev, 0, sizeof(ev));\n\tmemcpy(ev.uuid, rpa_resolution_uuid, 16);\n\tev.flags = cpu_to_le32((enabled ? BIT(0) : 0) | BIT(1));\n\n\treturn mgmt_limited_event(MGMT_EV_EXP_FEATURE_CHANGED, hdev,\n\t\t\t\t  &ev, sizeof(ev),\n\t\t\t\t  HCI_MGMT_EXP_FEATURE_EVENTS, skip);\n\n}\n\n#ifdef CONFIG_BT_FEATURE_DEBUG\nstatic int exp_debug_feature_changed(bool enabled, struct sock *skip)\n{\n\tstruct mgmt_ev_exp_feature_changed ev;\n\n\tmemset(&ev, 0, sizeof(ev));\n\tmemcpy(ev.uuid, debug_uuid, 16);\n\tev.flags = cpu_to_le32(enabled ? BIT(0) : 0);\n\n\treturn mgmt_limited_event(MGMT_EV_EXP_FEATURE_CHANGED, NULL,\n\t\t\t\t  &ev, sizeof(ev),\n\t\t\t\t  HCI_MGMT_EXP_FEATURE_EVENTS, skip);\n}\n#endif\n\nstatic int set_exp_feature(struct sock *sk, struct hci_dev *hdev,\n\t\t\t   void *data, u16 data_len)\n{\n\tstruct mgmt_cp_set_exp_feature *cp = data;\n\tstruct mgmt_rp_set_exp_feature rp;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!memcmp(cp->uuid, ZERO_KEY, 16)) {\n\t\tmemset(rp.uuid, 0, 16);\n\t\trp.flags = cpu_to_le32(0);\n\n#ifdef CONFIG_BT_FEATURE_DEBUG\n\t\tif (!hdev) {\n\t\t\tbool changed = bt_dbg_get();\n\n\t\t\tbt_dbg_set(false);\n\n\t\t\tif (changed)\n\t\t\t\texp_debug_feature_changed(false, sk);\n\t\t}\n#endif\n\n\t\tif (hdev && use_ll_privacy(hdev) && !hdev_is_powered(hdev)) {\n\t\t\tbool changed = hci_dev_test_flag(hdev,\n\t\t\t\t\t\t\t HCI_ENABLE_LL_PRIVACY);\n\n\t\t\thci_dev_clear_flag(hdev, HCI_ENABLE_LL_PRIVACY);\n\n\t\t\tif (changed)\n\t\t\t\texp_ll_privacy_feature_changed(false, hdev, sk);\n\t\t}\n\n\t\thci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);\n\n\t\treturn mgmt_cmd_complete(sk, hdev ? hdev->id : MGMT_INDEX_NONE,\n\t\t\t\t\t MGMT_OP_SET_EXP_FEATURE, 0,\n\t\t\t\t\t &rp, sizeof(rp));\n\t}\n\n#ifdef CONFIG_BT_FEATURE_DEBUG\n\tif (!memcmp(cp->uuid, debug_uuid, 16)) {\n\t\tbool val, changed;\n\t\tint err;\n\n\t\t/* Command requires to use the non-controller index */\n\t\tif (hdev)\n\t\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t\t       MGMT_STATUS_INVALID_INDEX);\n\n\t\t/* Parameters are limited to a single octet */\n\t\tif (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)\n\t\t\treturn mgmt_cmd_status(sk, MGMT_INDEX_NONE,\n\t\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\t\t/* Only boolean on/off is supported */\n\t\tif (cp->param[0] != 0x00 && cp->param[0] != 0x01)\n\t\t\treturn mgmt_cmd_status(sk, MGMT_INDEX_NONE,\n\t\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\t\tval = !!cp->param[0];\n\t\tchanged = val ? !bt_dbg_get() : bt_dbg_get();\n\t\tbt_dbg_set(val);\n\n\t\tmemcpy(rp.uuid, debug_uuid, 16);\n\t\trp.flags = cpu_to_le32(val ? BIT(0) : 0);\n\n\t\thci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);\n\n\t\terr = mgmt_cmd_complete(sk, MGMT_INDEX_NONE,\n\t\t\t\t\tMGMT_OP_SET_EXP_FEATURE, 0,\n\t\t\t\t\t&rp, sizeof(rp));\n\n\t\tif (changed)\n\t\t\texp_debug_feature_changed(val, sk);\n\n\t\treturn err;\n\t}\n#endif\n\n\tif (!memcmp(cp->uuid, rpa_resolution_uuid, 16)) {\n\t\tbool val, changed;\n\t\tint err;\n\t\tu32 flags;\n\n\t\t/* Command requires to use the controller index */\n\t\tif (!hdev)\n\t\t\treturn mgmt_cmd_status(sk, MGMT_INDEX_NONE,\n\t\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t\t       MGMT_STATUS_INVALID_INDEX);\n\n\t\t/* Changes can only be made when controller is powered down */\n\t\tif (hdev_is_powered(hdev))\n\t\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t\t       MGMT_STATUS_NOT_POWERED);\n\n\t\t/* Parameters are limited to a single octet */\n\t\tif (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)\n\t\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\t\t/* Only boolean on/off is supported */\n\t\tif (cp->param[0] != 0x00 && cp->param[0] != 0x01)\n\t\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\t\tval = !!cp->param[0];\n\n\t\tif (val) {\n\t\t\tchanged = !hci_dev_test_flag(hdev,\n\t\t\t\t\t\t     HCI_ENABLE_LL_PRIVACY);\n\t\t\thci_dev_set_flag(hdev, HCI_ENABLE_LL_PRIVACY);\n\t\t\thci_dev_clear_flag(hdev, HCI_ADVERTISING);\n\n\t\t\t/* Enable LL privacy + supported settings changed */\n\t\t\tflags = BIT(0) | BIT(1);\n\t\t} else {\n\t\t\tchanged = hci_dev_test_flag(hdev,\n\t\t\t\t\t\t    HCI_ENABLE_LL_PRIVACY);\n\t\t\thci_dev_clear_flag(hdev, HCI_ENABLE_LL_PRIVACY);\n\n\t\t\t/* Disable LL privacy + supported settings changed */\n\t\t\tflags = BIT(1);\n\t\t}\n\n\t\tmemcpy(rp.uuid, rpa_resolution_uuid, 16);\n\t\trp.flags = cpu_to_le32(flags);\n\n\t\thci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);\n\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_SET_EXP_FEATURE, 0,\n\t\t\t\t\t&rp, sizeof(rp));\n\n\t\tif (changed)\n\t\t\texp_ll_privacy_feature_changed(val, hdev, sk);\n\n\t\treturn err;\n\t}\n\n\treturn mgmt_cmd_status(sk, hdev ? hdev->id : MGMT_INDEX_NONE,\n\t\t\t       MGMT_OP_SET_EXP_FEATURE,\n\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n}\n\n#define SUPPORTED_DEVICE_FLAGS() ((1U << HCI_CONN_FLAG_MAX) - 1)\n\nstatic int get_device_flags(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t    u16 data_len)\n{\n\tstruct mgmt_cp_get_device_flags *cp = data;\n\tstruct mgmt_rp_get_device_flags rp;\n\tstruct bdaddr_list_with_flags *br_params;\n\tstruct hci_conn_params *params;\n\tu32 supported_flags = SUPPORTED_DEVICE_FLAGS();\n\tu32 current_flags = 0;\n\tu8 status = MGMT_STATUS_INVALID_PARAMS;\n\n\tbt_dev_dbg(hdev, \"Get device flags %pMR (type 0x%x)\\n\",\n\t\t   &cp->addr.bdaddr, cp->addr.type);\n\n\thci_dev_lock(hdev);\n\n\tif (cp->addr.type == BDADDR_BREDR) {\n\t\tbr_params = hci_bdaddr_list_lookup_with_flags(&hdev->whitelist,\n\t\t\t\t\t\t\t      &cp->addr.bdaddr,\n\t\t\t\t\t\t\t      cp->addr.type);\n\t\tif (!br_params)\n\t\t\tgoto done;\n\n\t\tcurrent_flags = br_params->current_flags;\n\t} else {\n\t\tparams = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,\n\t\t\t\t\t\tle_addr_type(cp->addr.type));\n\n\t\tif (!params)\n\t\t\tgoto done;\n\n\t\tcurrent_flags = params->current_flags;\n\t}\n\n\tbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\n\trp.addr.type = cp->addr.type;\n\trp.supported_flags = cpu_to_le32(supported_flags);\n\trp.current_flags = cpu_to_le32(current_flags);\n\n\tstatus = MGMT_STATUS_SUCCESS;\n\ndone:\n\thci_dev_unlock(hdev);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_DEVICE_FLAGS, status,\n\t\t\t\t&rp, sizeof(rp));\n}\n\nstatic void device_flags_changed(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t bdaddr_t *bdaddr, u8 bdaddr_type,\n\t\t\t\t u32 supported_flags, u32 current_flags)\n{\n\tstruct mgmt_ev_device_flags_changed ev;\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = bdaddr_type;\n\tev.supported_flags = cpu_to_le32(supported_flags);\n\tev.current_flags = cpu_to_le32(current_flags);\n\n\tmgmt_event(MGMT_EV_DEVICE_FLAGS_CHANGED, hdev, &ev, sizeof(ev), sk);\n}\n\nstatic int set_device_flags(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t    u16 len)\n{\n\tstruct mgmt_cp_set_device_flags *cp = data;\n\tstruct bdaddr_list_with_flags *br_params;\n\tstruct hci_conn_params *params;\n\tu8 status = MGMT_STATUS_INVALID_PARAMS;\n\tu32 supported_flags = SUPPORTED_DEVICE_FLAGS();\n\tu32 current_flags = __le32_to_cpu(cp->current_flags);\n\n\tbt_dev_dbg(hdev, \"Set device flags %pMR (type 0x%x) = 0x%x\",\n\t\t   &cp->addr.bdaddr, cp->addr.type,\n\t\t   __le32_to_cpu(current_flags));\n\n\tif ((supported_flags | current_flags) != supported_flags) {\n\t\tbt_dev_warn(hdev, \"Bad flag given (0x%x) vs supported (0x%0x)\",\n\t\t\t    current_flags, supported_flags);\n\t\tgoto done;\n\t}\n\n\thci_dev_lock(hdev);\n\n\tif (cp->addr.type == BDADDR_BREDR) {\n\t\tbr_params = hci_bdaddr_list_lookup_with_flags(&hdev->whitelist,\n\t\t\t\t\t\t\t      &cp->addr.bdaddr,\n\t\t\t\t\t\t\t      cp->addr.type);\n\n\t\tif (br_params) {\n\t\t\tbr_params->current_flags = current_flags;\n\t\t\tstatus = MGMT_STATUS_SUCCESS;\n\t\t} else {\n\t\t\tbt_dev_warn(hdev, \"No such BR/EDR device %pMR (0x%x)\",\n\t\t\t\t    &cp->addr.bdaddr, cp->addr.type);\n\t\t}\n\t} else {\n\t\tparams = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,\n\t\t\t\t\t\tle_addr_type(cp->addr.type));\n\t\tif (params) {\n\t\t\tparams->current_flags = current_flags;\n\t\t\tstatus = MGMT_STATUS_SUCCESS;\n\t\t} else {\n\t\t\tbt_dev_warn(hdev, \"No such LE device %pMR (0x%x)\",\n\t\t\t\t    &cp->addr.bdaddr,\n\t\t\t\t    le_addr_type(cp->addr.type));\n\t\t}\n\t}\n\ndone:\n\thci_dev_unlock(hdev);\n\n\tif (status == MGMT_STATUS_SUCCESS)\n\t\tdevice_flags_changed(sk, hdev, &cp->addr.bdaddr, cp->addr.type,\n\t\t\t\t     supported_flags, current_flags);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_DEVICE_FLAGS, status,\n\t\t\t\t &cp->addr, sizeof(cp->addr));\n}\n\nstatic void mgmt_adv_monitor_added(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t   u16 handle)\n{\n\tstruct mgmt_ev_adv_monitor_added ev;\n\n\tev.monitor_handle = cpu_to_le16(handle);\n\n\tmgmt_event(MGMT_EV_ADV_MONITOR_ADDED, hdev, &ev, sizeof(ev), sk);\n}\n\nstatic void mgmt_adv_monitor_removed(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t     u16 handle)\n{\n\tstruct mgmt_ev_adv_monitor_added ev;\n\n\tev.monitor_handle = cpu_to_le16(handle);\n\n\tmgmt_event(MGMT_EV_ADV_MONITOR_REMOVED, hdev, &ev, sizeof(ev), sk);\n}\n\nstatic int read_adv_mon_features(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t void *data, u16 len)\n{\n\tstruct adv_monitor *monitor = NULL;\n\tstruct mgmt_rp_read_adv_monitor_features *rp = NULL;\n\tint handle, err;\n\tsize_t rp_size = 0;\n\t__u32 supported = 0;\n\t__u16 num_handles = 0;\n\t__u16 handles[HCI_MAX_ADV_MONITOR_NUM_HANDLES];\n\n\tBT_DBG(\"request for %s\", hdev->name);\n\n\thci_dev_lock(hdev);\n\n\tif (msft_get_features(hdev) & MSFT_FEATURE_MASK_LE_ADV_MONITOR)\n\t\tsupported |= MGMT_ADV_MONITOR_FEATURE_MASK_OR_PATTERNS;\n\n\tidr_for_each_entry(&hdev->adv_monitors_idr, monitor, handle) {\n\t\thandles[num_handles++] = monitor->handle;\n\t}\n\n\thci_dev_unlock(hdev);\n\n\trp_size = sizeof(*rp) + (num_handles * sizeof(u16));\n\trp = kmalloc(rp_size, GFP_KERNEL);\n\tif (!rp)\n\t\treturn -ENOMEM;\n\n\t/* Once controller-based monitoring is in place, the enabled_features\n\t * should reflect the use.\n\t */\n\trp->supported_features = cpu_to_le32(supported);\n\trp->enabled_features = 0;\n\trp->max_num_handles = cpu_to_le16(HCI_MAX_ADV_MONITOR_NUM_HANDLES);\n\trp->max_num_patterns = HCI_MAX_ADV_MONITOR_NUM_PATTERNS;\n\trp->num_handles = cpu_to_le16(num_handles);\n\tif (num_handles)\n\t\tmemcpy(&rp->handles, &handles, (num_handles * sizeof(u16)));\n\n\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\tMGMT_OP_READ_ADV_MONITOR_FEATURES,\n\t\t\t\tMGMT_STATUS_SUCCESS, rp, rp_size);\n\n\tkfree(rp);\n\n\treturn err;\n}\n\nstatic int add_adv_patterns_monitor(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t    void *data, u16 len)\n{\n\tstruct mgmt_cp_add_adv_patterns_monitor *cp = data;\n\tstruct mgmt_rp_add_adv_patterns_monitor rp;\n\tstruct adv_monitor *m = NULL;\n\tstruct adv_pattern *p = NULL;\n\tunsigned int mp_cnt = 0, prev_adv_monitors_cnt;\n\t__u8 cp_ofst = 0, cp_len = 0;\n\tint err, i;\n\n\tBT_DBG(\"request for %s\", hdev->name);\n\n\tif (len <= sizeof(*cp) || cp->pattern_count == 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t      MGMT_OP_ADD_ADV_PATTERNS_MONITOR,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto failed;\n\t}\n\n\tm = kmalloc(sizeof(*m), GFP_KERNEL);\n\tif (!m) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tINIT_LIST_HEAD(&m->patterns);\n\tm->active = false;\n\n\tfor (i = 0; i < cp->pattern_count; i++) {\n\t\tif (++mp_cnt > HCI_MAX_ADV_MONITOR_NUM_PATTERNS) {\n\t\t\terr = mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t\t      MGMT_OP_ADD_ADV_PATTERNS_MONITOR,\n\t\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tcp_ofst = cp->patterns[i].offset;\n\t\tcp_len = cp->patterns[i].length;\n\t\tif (cp_ofst >= HCI_MAX_AD_LENGTH ||\n\t\t    cp_len > HCI_MAX_AD_LENGTH ||\n\t\t    (cp_ofst + cp_len) > HCI_MAX_AD_LENGTH) {\n\t\t\terr = mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t\t      MGMT_OP_ADD_ADV_PATTERNS_MONITOR,\n\t\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tp->ad_type = cp->patterns[i].ad_type;\n\t\tp->offset = cp->patterns[i].offset;\n\t\tp->length = cp->patterns[i].length;\n\t\tmemcpy(p->value, cp->patterns[i].value, p->length);\n\n\t\tINIT_LIST_HEAD(&p->list);\n\t\tlist_add(&p->list, &m->patterns);\n\t}\n\n\tif (mp_cnt != cp->pattern_count) {\n\t\terr = mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t      MGMT_OP_ADD_ADV_PATTERNS_MONITOR,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto failed;\n\t}\n\n\thci_dev_lock(hdev);\n\n\tprev_adv_monitors_cnt = hdev->adv_monitors_cnt;\n\n\terr = hci_add_adv_monitor(hdev, m);\n\tif (err) {\n\t\tif (err == -ENOSPC) {\n\t\t\tmgmt_cmd_status(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_ADD_ADV_PATTERNS_MONITOR,\n\t\t\t\t\tMGMT_STATUS_NO_RESOURCES);\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\tif (hdev->adv_monitors_cnt > prev_adv_monitors_cnt)\n\t\tmgmt_adv_monitor_added(sk, hdev, m->handle);\n\n\thci_dev_unlock(hdev);\n\n\trp.monitor_handle = cpu_to_le16(m->handle);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_ADV_PATTERNS_MONITOR,\n\t\t\t\t MGMT_STATUS_SUCCESS, &rp, sizeof(rp));\n\nunlock:\n\thci_dev_unlock(hdev);\n\nfailed:\n\thci_free_adv_monitor(m);\n\treturn err;\n}\n\nstatic int remove_adv_monitor(struct sock *sk, struct hci_dev *hdev,\n\t\t\t      void *data, u16 len)\n{\n\tstruct mgmt_cp_remove_adv_monitor *cp = data;\n\tstruct mgmt_rp_remove_adv_monitor rp;\n\tunsigned int prev_adv_monitors_cnt;\n\tu16 handle;\n\tint err;\n\n\tBT_DBG(\"request for %s\", hdev->name);\n\n\thci_dev_lock(hdev);\n\n\thandle = __le16_to_cpu(cp->monitor_handle);\n\tprev_adv_monitors_cnt = hdev->adv_monitors_cnt;\n\n\terr = hci_remove_adv_monitor(hdev, handle);\n\tif (err == -ENOENT) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_ADV_MONITOR,\n\t\t\t\t      MGMT_STATUS_INVALID_INDEX);\n\t\tgoto unlock;\n\t}\n\n\tif (hdev->adv_monitors_cnt < prev_adv_monitors_cnt)\n\t\tmgmt_adv_monitor_removed(sk, hdev, handle);\n\n\thci_dev_unlock(hdev);\n\n\trp.monitor_handle = cp->monitor_handle;\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_ADV_MONITOR,\n\t\t\t\t MGMT_STATUS_SUCCESS, &rp, sizeof(rp));\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic void read_local_oob_data_complete(struct hci_dev *hdev, u8 status,\n\t\t\t\t         u16 opcode, struct sk_buff *skb)\n{\n\tstruct mgmt_rp_read_local_oob_data mgmt_rp;\n\tsize_t rp_size = sizeof(mgmt_rp);\n\tstruct mgmt_pending_cmd *cmd;\n\n\tbt_dev_dbg(hdev, \"status %u\", status);\n\n\tcmd = pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, hdev);\n\tif (!cmd)\n\t\treturn;\n\n\tif (status || !skb) {\n\t\tmgmt_cmd_status(cmd->sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,\n\t\t\t\tstatus ? mgmt_status(status) : MGMT_STATUS_FAILED);\n\t\tgoto remove;\n\t}\n\n\tmemset(&mgmt_rp, 0, sizeof(mgmt_rp));\n\n\tif (opcode == HCI_OP_READ_LOCAL_OOB_DATA) {\n\t\tstruct hci_rp_read_local_oob_data *rp = (void *) skb->data;\n\n\t\tif (skb->len < sizeof(*rp)) {\n\t\t\tmgmt_cmd_status(cmd->sk, hdev->id,\n\t\t\t\t\tMGMT_OP_READ_LOCAL_OOB_DATA,\n\t\t\t\t\tMGMT_STATUS_FAILED);\n\t\t\tgoto remove;\n\t\t}\n\n\t\tmemcpy(mgmt_rp.hash192, rp->hash, sizeof(rp->hash));\n\t\tmemcpy(mgmt_rp.rand192, rp->rand, sizeof(rp->rand));\n\n\t\trp_size -= sizeof(mgmt_rp.hash256) + sizeof(mgmt_rp.rand256);\n\t} else {\n\t\tstruct hci_rp_read_local_oob_ext_data *rp = (void *) skb->data;\n\n\t\tif (skb->len < sizeof(*rp)) {\n\t\t\tmgmt_cmd_status(cmd->sk, hdev->id,\n\t\t\t\t\tMGMT_OP_READ_LOCAL_OOB_DATA,\n\t\t\t\t\tMGMT_STATUS_FAILED);\n\t\t\tgoto remove;\n\t\t}\n\n\t\tmemcpy(mgmt_rp.hash192, rp->hash192, sizeof(rp->hash192));\n\t\tmemcpy(mgmt_rp.rand192, rp->rand192, sizeof(rp->rand192));\n\n\t\tmemcpy(mgmt_rp.hash256, rp->hash256, sizeof(rp->hash256));\n\t\tmemcpy(mgmt_rp.rand256, rp->rand256, sizeof(rp->rand256));\n\t}\n\n\tmgmt_cmd_complete(cmd->sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,\n\t\t\t  MGMT_STATUS_SUCCESS, &mgmt_rp, rp_size);\n\nremove:\n\tmgmt_pending_remove(cmd);\n}\n\nstatic int read_local_oob_data(struct sock *sk, struct hci_dev *hdev,\n\t\t\t       void *data, u16 data_len)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_request req;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,\n\t\t\t\t      MGMT_STATUS_NOT_POWERED);\n\t\tgoto unlock;\n\t}\n\n\tif (!lmp_ssp_capable(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,\n\t\t\t\t      MGMT_STATUS_NOT_SUPPORTED);\n\t\tgoto unlock;\n\t}\n\n\tif (pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_READ_LOCAL_OOB_DATA, hdev, NULL, 0);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\thci_req_init(&req, hdev);\n\n\tif (bredr_sc_enabled(hdev))\n\t\thci_req_add(&req, HCI_OP_READ_LOCAL_OOB_EXT_DATA, 0, NULL);\n\telse\n\t\thci_req_add(&req, HCI_OP_READ_LOCAL_OOB_DATA, 0, NULL);\n\n\terr = hci_req_run_skb(&req, read_local_oob_data_complete);\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int add_remote_oob_data(struct sock *sk, struct hci_dev *hdev,\n\t\t\t       void *data, u16 len)\n{\n\tstruct mgmt_addr_info *addr = data;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!bdaddr_type_is_valid(addr->type))\n\t\treturn mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t MGMT_OP_ADD_REMOTE_OOB_DATA,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t addr, sizeof(*addr));\n\n\thci_dev_lock(hdev);\n\n\tif (len == MGMT_ADD_REMOTE_OOB_DATA_SIZE) {\n\t\tstruct mgmt_cp_add_remote_oob_data *cp = data;\n\t\tu8 status;\n\n\t\tif (cp->addr.type != BDADDR_BREDR) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_ADD_REMOTE_OOB_DATA,\n\t\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t\t&cp->addr, sizeof(cp->addr));\n\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = hci_add_remote_oob_data(hdev, &cp->addr.bdaddr,\n\t\t\t\t\t      cp->addr.type, cp->hash,\n\t\t\t\t\t      cp->rand, NULL, NULL);\n\t\tif (err < 0)\n\t\t\tstatus = MGMT_STATUS_FAILED;\n\t\telse\n\t\t\tstatus = MGMT_STATUS_SUCCESS;\n\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_ADD_REMOTE_OOB_DATA, status,\n\t\t\t\t\t&cp->addr, sizeof(cp->addr));\n\t} else if (len == MGMT_ADD_REMOTE_OOB_EXT_DATA_SIZE) {\n\t\tstruct mgmt_cp_add_remote_oob_ext_data *cp = data;\n\t\tu8 *rand192, *hash192, *rand256, *hash256;\n\t\tu8 status;\n\n\t\tif (bdaddr_type_is_le(cp->addr.type)) {\n\t\t\t/* Enforce zero-valued 192-bit parameters as\n\t\t\t * long as legacy SMP OOB isn't implemented.\n\t\t\t */\n\t\t\tif (memcmp(cp->rand192, ZERO_KEY, 16) ||\n\t\t\t    memcmp(cp->hash192, ZERO_KEY, 16)) {\n\t\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\t\tMGMT_OP_ADD_REMOTE_OOB_DATA,\n\t\t\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t\t\taddr, sizeof(*addr));\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\trand192 = NULL;\n\t\t\thash192 = NULL;\n\t\t} else {\n\t\t\t/* In case one of the P-192 values is set to zero,\n\t\t\t * then just disable OOB data for P-192.\n\t\t\t */\n\t\t\tif (!memcmp(cp->rand192, ZERO_KEY, 16) ||\n\t\t\t    !memcmp(cp->hash192, ZERO_KEY, 16)) {\n\t\t\t\trand192 = NULL;\n\t\t\t\thash192 = NULL;\n\t\t\t} else {\n\t\t\t\trand192 = cp->rand192;\n\t\t\t\thash192 = cp->hash192;\n\t\t\t}\n\t\t}\n\n\t\t/* In case one of the P-256 values is set to zero, then just\n\t\t * disable OOB data for P-256.\n\t\t */\n\t\tif (!memcmp(cp->rand256, ZERO_KEY, 16) ||\n\t\t    !memcmp(cp->hash256, ZERO_KEY, 16)) {\n\t\t\trand256 = NULL;\n\t\t\thash256 = NULL;\n\t\t} else {\n\t\t\trand256 = cp->rand256;\n\t\t\thash256 = cp->hash256;\n\t\t}\n\n\t\terr = hci_add_remote_oob_data(hdev, &cp->addr.bdaddr,\n\t\t\t\t\t      cp->addr.type, hash192, rand192,\n\t\t\t\t\t      hash256, rand256);\n\t\tif (err < 0)\n\t\t\tstatus = MGMT_STATUS_FAILED;\n\t\telse\n\t\t\tstatus = MGMT_STATUS_SUCCESS;\n\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_ADD_REMOTE_OOB_DATA,\n\t\t\t\t\tstatus, &cp->addr, sizeof(cp->addr));\n\t} else {\n\t\tbt_dev_err(hdev, \"add_remote_oob_data: invalid len of %u bytes\",\n\t\t\t   len);\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_REMOTE_OOB_DATA,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int remove_remote_oob_data(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t  void *data, u16 len)\n{\n\tstruct mgmt_cp_remove_remote_oob_data *cp = data;\n\tu8 status;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (cp->addr.type != BDADDR_BREDR)\n\t\treturn mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t MGMT_OP_REMOVE_REMOTE_OOB_DATA,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &cp->addr, sizeof(cp->addr));\n\n\thci_dev_lock(hdev);\n\n\tif (!bacmp(&cp->addr.bdaddr, BDADDR_ANY)) {\n\t\thci_remote_oob_data_clear(hdev);\n\t\tstatus = MGMT_STATUS_SUCCESS;\n\t\tgoto done;\n\t}\n\n\terr = hci_remove_remote_oob_data(hdev, &cp->addr.bdaddr, cp->addr.type);\n\tif (err < 0)\n\t\tstatus = MGMT_STATUS_INVALID_PARAMS;\n\telse\n\t\tstatus = MGMT_STATUS_SUCCESS;\n\ndone:\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_REMOTE_OOB_DATA,\n\t\t\t\tstatus, &cp->addr, sizeof(cp->addr));\n\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nvoid mgmt_start_discovery_complete(struct hci_dev *hdev, u8 status)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tbt_dev_dbg(hdev, \"status %d\", status);\n\n\thci_dev_lock(hdev);\n\n\tcmd = pending_find(MGMT_OP_START_DISCOVERY, hdev);\n\tif (!cmd)\n\t\tcmd = pending_find(MGMT_OP_START_SERVICE_DISCOVERY, hdev);\n\n\tif (!cmd)\n\t\tcmd = pending_find(MGMT_OP_START_LIMITED_DISCOVERY, hdev);\n\n\tif (cmd) {\n\t\tcmd->cmd_complete(cmd, mgmt_status(status));\n\t\tmgmt_pending_remove(cmd);\n\t}\n\n\thci_dev_unlock(hdev);\n\n\t/* Handle suspend notifier */\n\tif (test_and_clear_bit(SUSPEND_UNPAUSE_DISCOVERY,\n\t\t\t       hdev->suspend_tasks)) {\n\t\tbt_dev_dbg(hdev, \"Unpaused discovery\");\n\t\twake_up(&hdev->suspend_wait_q);\n\t}\n}\n\nstatic bool discovery_type_is_valid(struct hci_dev *hdev, uint8_t type,\n\t\t\t\t    uint8_t *mgmt_status)\n{\n\tswitch (type) {\n\tcase DISCOV_TYPE_LE:\n\t\t*mgmt_status = mgmt_le_support(hdev);\n\t\tif (*mgmt_status)\n\t\t\treturn false;\n\t\tbreak;\n\tcase DISCOV_TYPE_INTERLEAVED:\n\t\t*mgmt_status = mgmt_le_support(hdev);\n\t\tif (*mgmt_status)\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase DISCOV_TYPE_BREDR:\n\t\t*mgmt_status = mgmt_bredr_support(hdev);\n\t\tif (*mgmt_status)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\t*mgmt_status = MGMT_STATUS_INVALID_PARAMS;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int start_discovery_internal(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t    u16 op, void *data, u16 len)\n{\n\tstruct mgmt_cp_start_discovery *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tu8 status;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, op,\n\t\t\t\t\tMGMT_STATUS_NOT_POWERED,\n\t\t\t\t\t&cp->type, sizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\tif (hdev->discovery.state != DISCOVERY_STOPPED ||\n\t    hci_dev_test_flag(hdev, HCI_PERIODIC_INQ)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, op, MGMT_STATUS_BUSY,\n\t\t\t\t\t&cp->type, sizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\tif (!discovery_type_is_valid(hdev, cp->type, &status)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, op, status,\n\t\t\t\t\t&cp->type, sizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\t/* Can't start discovery when it is paused */\n\tif (hdev->discovery_paused) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, op, MGMT_STATUS_BUSY,\n\t\t\t\t\t&cp->type, sizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\t/* Clear the discovery filter first to free any previously\n\t * allocated memory for the UUID list.\n\t */\n\thci_discovery_filter_clear(hdev);\n\n\thdev->discovery.type = cp->type;\n\thdev->discovery.report_invalid_rssi = false;\n\tif (op == MGMT_OP_START_LIMITED_DISCOVERY)\n\t\thdev->discovery.limited = true;\n\telse\n\t\thdev->discovery.limited = false;\n\n\tcmd = mgmt_pending_add(sk, op, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tcmd->cmd_complete = generic_cmd_complete;\n\n\thci_discovery_set_state(hdev, DISCOVERY_STARTING);\n\tqueue_work(hdev->req_workqueue, &hdev->discov_update);\n\terr = 0;\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int start_discovery(struct sock *sk, struct hci_dev *hdev,\n\t\t\t   void *data, u16 len)\n{\n\treturn start_discovery_internal(sk, hdev, MGMT_OP_START_DISCOVERY,\n\t\t\t\t\tdata, len);\n}\n\nstatic int start_limited_discovery(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t   void *data, u16 len)\n{\n\treturn start_discovery_internal(sk, hdev,\n\t\t\t\t\tMGMT_OP_START_LIMITED_DISCOVERY,\n\t\t\t\t\tdata, len);\n}\n\nstatic int service_discovery_cmd_complete(struct mgmt_pending_cmd *cmd,\n\t\t\t\t\t  u8 status)\n{\n\treturn mgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode, status,\n\t\t\t\t cmd->param, 1);\n}\n\nstatic int start_service_discovery(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t   void *data, u16 len)\n{\n\tstruct mgmt_cp_start_service_discovery *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tconst u16 max_uuid_count = ((U16_MAX - sizeof(*cp)) / 16);\n\tu16 uuid_count, expected_len;\n\tu8 status;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_START_SERVICE_DISCOVERY,\n\t\t\t\t\tMGMT_STATUS_NOT_POWERED,\n\t\t\t\t\t&cp->type, sizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\tif (hdev->discovery.state != DISCOVERY_STOPPED ||\n\t    hci_dev_test_flag(hdev, HCI_PERIODIC_INQ)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_START_SERVICE_DISCOVERY,\n\t\t\t\t\tMGMT_STATUS_BUSY, &cp->type,\n\t\t\t\t\tsizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\tif (hdev->discovery_paused) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_START_SERVICE_DISCOVERY,\n\t\t\t\t\tMGMT_STATUS_BUSY, &cp->type,\n\t\t\t\t\tsizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\tuuid_count = __le16_to_cpu(cp->uuid_count);\n\tif (uuid_count > max_uuid_count) {\n\t\tbt_dev_err(hdev, \"service_discovery: too big uuid_count value %u\",\n\t\t\t   uuid_count);\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_START_SERVICE_DISCOVERY,\n\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS, &cp->type,\n\t\t\t\t\tsizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\texpected_len = sizeof(*cp) + uuid_count * 16;\n\tif (expected_len != len) {\n\t\tbt_dev_err(hdev, \"service_discovery: expected %u bytes, got %u bytes\",\n\t\t\t   expected_len, len);\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_START_SERVICE_DISCOVERY,\n\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS, &cp->type,\n\t\t\t\t\tsizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\tif (!discovery_type_is_valid(hdev, cp->type, &status)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_START_SERVICE_DISCOVERY,\n\t\t\t\t\tstatus, &cp->type, sizeof(cp->type));\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_START_SERVICE_DISCOVERY,\n\t\t\t       hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tcmd->cmd_complete = service_discovery_cmd_complete;\n\n\t/* Clear the discovery filter first to free any previously\n\t * allocated memory for the UUID list.\n\t */\n\thci_discovery_filter_clear(hdev);\n\n\thdev->discovery.result_filtering = true;\n\thdev->discovery.type = cp->type;\n\thdev->discovery.rssi = cp->rssi;\n\thdev->discovery.uuid_count = uuid_count;\n\n\tif (uuid_count > 0) {\n\t\thdev->discovery.uuids = kmemdup(cp->uuids, uuid_count * 16,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!hdev->discovery.uuids) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_START_SERVICE_DISCOVERY,\n\t\t\t\t\t\tMGMT_STATUS_FAILED,\n\t\t\t\t\t\t&cp->type, sizeof(cp->type));\n\t\t\tmgmt_pending_remove(cmd);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\thci_discovery_set_state(hdev, DISCOVERY_STARTING);\n\tqueue_work(hdev->req_workqueue, &hdev->discov_update);\n\terr = 0;\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nvoid mgmt_stop_discovery_complete(struct hci_dev *hdev, u8 status)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tbt_dev_dbg(hdev, \"status %d\", status);\n\n\thci_dev_lock(hdev);\n\n\tcmd = pending_find(MGMT_OP_STOP_DISCOVERY, hdev);\n\tif (cmd) {\n\t\tcmd->cmd_complete(cmd, mgmt_status(status));\n\t\tmgmt_pending_remove(cmd);\n\t}\n\n\thci_dev_unlock(hdev);\n\n\t/* Handle suspend notifier */\n\tif (test_and_clear_bit(SUSPEND_PAUSE_DISCOVERY, hdev->suspend_tasks)) {\n\t\tbt_dev_dbg(hdev, \"Paused discovery\");\n\t\twake_up(&hdev->suspend_wait_q);\n\t}\n}\n\nstatic int stop_discovery(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t  u16 len)\n{\n\tstruct mgmt_cp_stop_discovery *mgmt_cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (!hci_discovery_active(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_STOP_DISCOVERY,\n\t\t\t\t\tMGMT_STATUS_REJECTED, &mgmt_cp->type,\n\t\t\t\t\tsizeof(mgmt_cp->type));\n\t\tgoto unlock;\n\t}\n\n\tif (hdev->discovery.type != mgmt_cp->type) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_STOP_DISCOVERY,\n\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t&mgmt_cp->type, sizeof(mgmt_cp->type));\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_STOP_DISCOVERY, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tcmd->cmd_complete = generic_cmd_complete;\n\n\thci_discovery_set_state(hdev, DISCOVERY_STOPPING);\n\tqueue_work(hdev->req_workqueue, &hdev->discov_update);\n\terr = 0;\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int confirm_name(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\tu16 len)\n{\n\tstruct mgmt_cp_confirm_name *cp = data;\n\tstruct inquiry_entry *e;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (!hci_discovery_active(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_CONFIRM_NAME,\n\t\t\t\t\tMGMT_STATUS_FAILED, &cp->addr,\n\t\t\t\t\tsizeof(cp->addr));\n\t\tgoto failed;\n\t}\n\n\te = hci_inquiry_cache_lookup_unknown(hdev, &cp->addr.bdaddr);\n\tif (!e) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_CONFIRM_NAME,\n\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS, &cp->addr,\n\t\t\t\t\tsizeof(cp->addr));\n\t\tgoto failed;\n\t}\n\n\tif (cp->name_known) {\n\t\te->name_state = NAME_KNOWN;\n\t\tlist_del(&e->list);\n\t} else {\n\t\te->name_state = NAME_NEEDED;\n\t\thci_inquiry_cache_update_resolve(hdev, e);\n\t}\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_CONFIRM_NAME, 0,\n\t\t\t\t&cp->addr, sizeof(cp->addr));\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int block_device(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\tu16 len)\n{\n\tstruct mgmt_cp_block_device *cp = data;\n\tu8 status;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!bdaddr_type_is_valid(cp->addr.type))\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_BLOCK_DEVICE,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &cp->addr, sizeof(cp->addr));\n\n\thci_dev_lock(hdev);\n\n\terr = hci_bdaddr_list_add(&hdev->blacklist, &cp->addr.bdaddr,\n\t\t\t\t  cp->addr.type);\n\tif (err < 0) {\n\t\tstatus = MGMT_STATUS_FAILED;\n\t\tgoto done;\n\t}\n\n\tmgmt_event(MGMT_EV_DEVICE_BLOCKED, hdev, &cp->addr, sizeof(cp->addr),\n\t\t   sk);\n\tstatus = MGMT_STATUS_SUCCESS;\n\ndone:\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_BLOCK_DEVICE, status,\n\t\t\t\t&cp->addr, sizeof(cp->addr));\n\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic int unblock_device(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t  u16 len)\n{\n\tstruct mgmt_cp_unblock_device *cp = data;\n\tu8 status;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!bdaddr_type_is_valid(cp->addr.type))\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNBLOCK_DEVICE,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &cp->addr, sizeof(cp->addr));\n\n\thci_dev_lock(hdev);\n\n\terr = hci_bdaddr_list_del(&hdev->blacklist, &cp->addr.bdaddr,\n\t\t\t\t  cp->addr.type);\n\tif (err < 0) {\n\t\tstatus = MGMT_STATUS_INVALID_PARAMS;\n\t\tgoto done;\n\t}\n\n\tmgmt_event(MGMT_EV_DEVICE_UNBLOCKED, hdev, &cp->addr, sizeof(cp->addr),\n\t\t   sk);\n\tstatus = MGMT_STATUS_SUCCESS;\n\ndone:\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNBLOCK_DEVICE, status,\n\t\t\t\t&cp->addr, sizeof(cp->addr));\n\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic int set_device_id(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t u16 len)\n{\n\tstruct mgmt_cp_set_device_id *cp = data;\n\tstruct hci_request req;\n\tint err;\n\t__u16 source;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tsource = __le16_to_cpu(cp->source);\n\n\tif (source > 0x0002)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DEVICE_ID,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\thdev->devid_source = source;\n\thdev->devid_vendor = __le16_to_cpu(cp->vendor);\n\thdev->devid_product = __le16_to_cpu(cp->product);\n\thdev->devid_version = __le16_to_cpu(cp->version);\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_DEVICE_ID, 0,\n\t\t\t\tNULL, 0);\n\n\thci_req_init(&req, hdev);\n\t__hci_req_update_eir(&req);\n\thci_req_run(&req, NULL);\n\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic void enable_advertising_instance(struct hci_dev *hdev, u8 status,\n\t\t\t\t\tu16 opcode)\n{\n\tbt_dev_dbg(hdev, \"status %d\", status);\n}\n\nstatic void set_advertising_complete(struct hci_dev *hdev, u8 status,\n\t\t\t\t     u16 opcode)\n{\n\tstruct cmd_lookup match = { NULL, hdev };\n\tstruct hci_request req;\n\tu8 instance;\n\tstruct adv_info *adv_instance;\n\tint err;\n\n\thci_dev_lock(hdev);\n\n\tif (status) {\n\t\tu8 mgmt_err = mgmt_status(status);\n\n\t\tmgmt_pending_foreach(MGMT_OP_SET_ADVERTISING, hdev,\n\t\t\t\t     cmd_status_rsp, &mgmt_err);\n\t\tgoto unlock;\n\t}\n\n\tif (hci_dev_test_flag(hdev, HCI_LE_ADV))\n\t\thci_dev_set_flag(hdev, HCI_ADVERTISING);\n\telse\n\t\thci_dev_clear_flag(hdev, HCI_ADVERTISING);\n\n\tmgmt_pending_foreach(MGMT_OP_SET_ADVERTISING, hdev, settings_rsp,\n\t\t\t     &match);\n\n\tnew_settings(hdev, match.sk);\n\n\tif (match.sk)\n\t\tsock_put(match.sk);\n\n\t/* Handle suspend notifier */\n\tif (test_and_clear_bit(SUSPEND_PAUSE_ADVERTISING,\n\t\t\t       hdev->suspend_tasks)) {\n\t\tbt_dev_dbg(hdev, \"Paused advertising\");\n\t\twake_up(&hdev->suspend_wait_q);\n\t} else if (test_and_clear_bit(SUSPEND_UNPAUSE_ADVERTISING,\n\t\t\t\t      hdev->suspend_tasks)) {\n\t\tbt_dev_dbg(hdev, \"Unpaused advertising\");\n\t\twake_up(&hdev->suspend_wait_q);\n\t}\n\n\t/* If \"Set Advertising\" was just disabled and instance advertising was\n\t * set up earlier, then re-enable multi-instance advertising.\n\t */\n\tif (hci_dev_test_flag(hdev, HCI_ADVERTISING) ||\n\t    list_empty(&hdev->adv_instances))\n\t\tgoto unlock;\n\n\tinstance = hdev->cur_adv_instance;\n\tif (!instance) {\n\t\tadv_instance = list_first_entry_or_null(&hdev->adv_instances,\n\t\t\t\t\t\t\tstruct adv_info, list);\n\t\tif (!adv_instance)\n\t\t\tgoto unlock;\n\n\t\tinstance = adv_instance->instance;\n\t}\n\n\thci_req_init(&req, hdev);\n\n\terr = __hci_req_schedule_adv_instance(&req, instance, true);\n\n\tif (!err)\n\t\terr = hci_req_run(&req, enable_advertising_instance);\n\n\tif (err)\n\t\tbt_dev_err(hdev, \"failed to re-configure advertising\");\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic int set_advertising(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t   u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_request req;\n\tu8 val, status;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tstatus = mgmt_le_support(hdev);\n\tif (status)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_ADVERTISING,\n\t\t\t\t       status);\n\n\t/* Enabling the experimental LL Privay support disables support for\n\t * advertising.\n\t */\n\tif (hci_dev_test_flag(hdev, HCI_ENABLE_LL_PRIVACY))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_ADVERTISING,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (cp->val != 0x00 && cp->val != 0x01 && cp->val != 0x02)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_ADVERTISING,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tif (hdev->advertising_paused)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_ADVERTISING,\n\t\t\t\t       MGMT_STATUS_BUSY);\n\n\thci_dev_lock(hdev);\n\n\tval = !!cp->val;\n\n\t/* The following conditions are ones which mean that we should\n\t * not do any HCI communication but directly send a mgmt\n\t * response to user space (after toggling the flag if\n\t * necessary).\n\t */\n\tif (!hdev_is_powered(hdev) ||\n\t    (val == hci_dev_test_flag(hdev, HCI_ADVERTISING) &&\n\t     (cp->val == 0x02) == hci_dev_test_flag(hdev, HCI_ADVERTISING_CONNECTABLE)) ||\n\t    hci_conn_num(hdev, LE_LINK) > 0 ||\n\t    (hci_dev_test_flag(hdev, HCI_LE_SCAN) &&\n\t     hdev->le_scan_type == LE_SCAN_ACTIVE)) {\n\t\tbool changed;\n\n\t\tif (cp->val) {\n\t\t\thdev->cur_adv_instance = 0x00;\n\t\t\tchanged = !hci_dev_test_and_set_flag(hdev, HCI_ADVERTISING);\n\t\t\tif (cp->val == 0x02)\n\t\t\t\thci_dev_set_flag(hdev, HCI_ADVERTISING_CONNECTABLE);\n\t\t\telse\n\t\t\t\thci_dev_clear_flag(hdev, HCI_ADVERTISING_CONNECTABLE);\n\t\t} else {\n\t\t\tchanged = hci_dev_test_and_clear_flag(hdev, HCI_ADVERTISING);\n\t\t\thci_dev_clear_flag(hdev, HCI_ADVERTISING_CONNECTABLE);\n\t\t}\n\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_ADVERTISING, hdev);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\n\t\tif (changed)\n\t\t\terr = new_settings(hdev, sk);\n\n\t\tgoto unlock;\n\t}\n\n\tif (pending_find(MGMT_OP_SET_ADVERTISING, hdev) ||\n\t    pending_find(MGMT_OP_SET_LE, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_ADVERTISING,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_ADVERTISING, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\thci_req_init(&req, hdev);\n\n\tif (cp->val == 0x02)\n\t\thci_dev_set_flag(hdev, HCI_ADVERTISING_CONNECTABLE);\n\telse\n\t\thci_dev_clear_flag(hdev, HCI_ADVERTISING_CONNECTABLE);\n\n\tcancel_adv_timeout(hdev);\n\n\tif (val) {\n\t\t/* Switch to instance \"0\" for the Set Advertising setting.\n\t\t * We cannot use update_[adv|scan_rsp]_data() here as the\n\t\t * HCI_ADVERTISING flag is not yet set.\n\t\t */\n\t\thdev->cur_adv_instance = 0x00;\n\n\t\tif (ext_adv_capable(hdev)) {\n\t\t\t__hci_req_start_ext_adv(&req, 0x00);\n\t\t} else {\n\t\t\t__hci_req_update_adv_data(&req, 0x00);\n\t\t\t__hci_req_update_scan_rsp_data(&req, 0x00);\n\t\t\t__hci_req_enable_advertising(&req);\n\t\t}\n\t} else {\n\t\t__hci_req_disable_advertising(&req);\n\t}\n\n\terr = hci_req_run(&req, set_advertising_complete);\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_static_address(struct sock *sk, struct hci_dev *hdev,\n\t\t\t      void *data, u16 len)\n{\n\tstruct mgmt_cp_set_static_address *cp = data;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_STATIC_ADDRESS,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (hdev_is_powered(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_STATIC_ADDRESS,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\tif (bacmp(&cp->bdaddr, BDADDR_ANY)) {\n\t\tif (!bacmp(&cp->bdaddr, BDADDR_NONE))\n\t\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t\t       MGMT_OP_SET_STATIC_ADDRESS,\n\t\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\t\t/* Two most significant bits shall be set */\n\t\tif ((cp->bdaddr.b[5] & 0xc0) != 0xc0)\n\t\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t\t       MGMT_OP_SET_STATIC_ADDRESS,\n\t\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\thci_dev_lock(hdev);\n\n\tbacpy(&hdev->static_addr, &cp->bdaddr);\n\n\terr = send_settings_rsp(sk, MGMT_OP_SET_STATIC_ADDRESS, hdev);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\terr = new_settings(hdev, sk);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_scan_params(struct sock *sk, struct hci_dev *hdev,\n\t\t\t   void *data, u16 len)\n{\n\tstruct mgmt_cp_set_scan_params *cp = data;\n\t__u16 interval, window;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SCAN_PARAMS,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tinterval = __le16_to_cpu(cp->interval);\n\n\tif (interval < 0x0004 || interval > 0x4000)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SCAN_PARAMS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\twindow = __le16_to_cpu(cp->window);\n\n\tif (window < 0x0004 || window > 0x4000)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SCAN_PARAMS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tif (window > interval)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SCAN_PARAMS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\thdev->le_scan_interval = interval;\n\thdev->le_scan_window = window;\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_SCAN_PARAMS, 0,\n\t\t\t\tNULL, 0);\n\n\t/* If background scan is running, restart it so new parameters are\n\t * loaded.\n\t */\n\tif (hci_dev_test_flag(hdev, HCI_LE_SCAN) &&\n\t    hdev->discovery.state == DISCOVERY_STOPPED) {\n\t\tstruct hci_request req;\n\n\t\thci_req_init(&req, hdev);\n\n\t\thci_req_add_le_scan_disable(&req, false);\n\t\thci_req_add_le_passive_scan(&req);\n\n\t\thci_req_run(&req, NULL);\n\t}\n\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic void fast_connectable_complete(struct hci_dev *hdev, u8 status,\n\t\t\t\t      u16 opcode)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tbt_dev_dbg(hdev, \"status 0x%02x\", status);\n\n\thci_dev_lock(hdev);\n\n\tcmd = pending_find(MGMT_OP_SET_FAST_CONNECTABLE, hdev);\n\tif (!cmd)\n\t\tgoto unlock;\n\n\tif (status) {\n\t\tmgmt_cmd_status(cmd->sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,\n\t\t\t        mgmt_status(status));\n\t} else {\n\t\tstruct mgmt_mode *cp = cmd->param;\n\n\t\tif (cp->val)\n\t\t\thci_dev_set_flag(hdev, HCI_FAST_CONNECTABLE);\n\t\telse\n\t\t\thci_dev_clear_flag(hdev, HCI_FAST_CONNECTABLE);\n\n\t\tsend_settings_rsp(cmd->sk, MGMT_OP_SET_FAST_CONNECTABLE, hdev);\n\t\tnew_settings(hdev, cmd->sk);\n\t}\n\n\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic int set_fast_connectable(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\tvoid *data, u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_request req;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) ||\n\t    hdev->hci_ver < BLUETOOTH_VER_1_2)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (pending_find(MGMT_OP_SET_FAST_CONNECTABLE, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tif (!!cp->val == hci_dev_test_flag(hdev, HCI_FAST_CONNECTABLE)) {\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_FAST_CONNECTABLE,\n\t\t\t\t\thdev);\n\t\tgoto unlock;\n\t}\n\n\tif (!hdev_is_powered(hdev)) {\n\t\thci_dev_change_flag(hdev, HCI_FAST_CONNECTABLE);\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_FAST_CONNECTABLE,\n\t\t\t\t\thdev);\n\t\tnew_settings(hdev, sk);\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_FAST_CONNECTABLE, hdev,\n\t\t\t       data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\thci_req_init(&req, hdev);\n\n\t__hci_req_write_fast_connectable(&req, cp->val);\n\n\terr = hci_req_run(&req, fast_connectable_complete);\n\tif (err < 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,\n\t\t\t\t      MGMT_STATUS_FAILED);\n\t\tmgmt_pending_remove(cmd);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic void set_bredr_complete(struct hci_dev *hdev, u8 status, u16 opcode)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tbt_dev_dbg(hdev, \"status 0x%02x\", status);\n\n\thci_dev_lock(hdev);\n\n\tcmd = pending_find(MGMT_OP_SET_BREDR, hdev);\n\tif (!cmd)\n\t\tgoto unlock;\n\n\tif (status) {\n\t\tu8 mgmt_err = mgmt_status(status);\n\n\t\t/* We need to restore the flag if related HCI commands\n\t\t * failed.\n\t\t */\n\t\thci_dev_clear_flag(hdev, HCI_BREDR_ENABLED);\n\n\t\tmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode, mgmt_err);\n\t} else {\n\t\tsend_settings_rsp(cmd->sk, MGMT_OP_SET_BREDR, hdev);\n\t\tnew_settings(hdev, cmd->sk);\n\t}\n\n\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic int set_bredr(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_request req;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_bredr_capable(hdev) || !lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BREDR,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BREDR,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\tif (cp->val != 0x00 && cp->val != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BREDR,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (cp->val == hci_dev_test_flag(hdev, HCI_BREDR_ENABLED)) {\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_BREDR, hdev);\n\t\tgoto unlock;\n\t}\n\n\tif (!hdev_is_powered(hdev)) {\n\t\tif (!cp->val) {\n\t\t\thci_dev_clear_flag(hdev, HCI_DISCOVERABLE);\n\t\t\thci_dev_clear_flag(hdev, HCI_SSP_ENABLED);\n\t\t\thci_dev_clear_flag(hdev, HCI_LINK_SECURITY);\n\t\t\thci_dev_clear_flag(hdev, HCI_FAST_CONNECTABLE);\n\t\t\thci_dev_clear_flag(hdev, HCI_HS_ENABLED);\n\t\t}\n\n\t\thci_dev_change_flag(hdev, HCI_BREDR_ENABLED);\n\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_BREDR, hdev);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\n\t\terr = new_settings(hdev, sk);\n\t\tgoto unlock;\n\t}\n\n\t/* Reject disabling when powered on */\n\tif (!cp->val) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BREDR,\n\t\t\t\t      MGMT_STATUS_REJECTED);\n\t\tgoto unlock;\n\t} else {\n\t\t/* When configuring a dual-mode controller to operate\n\t\t * with LE only and using a static address, then switching\n\t\t * BR/EDR back on is not allowed.\n\t\t *\n\t\t * Dual-mode controllers shall operate with the public\n\t\t * address as its identity address for BR/EDR and LE. So\n\t\t * reject the attempt to create an invalid configuration.\n\t\t *\n\t\t * The same restrictions applies when secure connections\n\t\t * has been enabled. For BR/EDR this is a controller feature\n\t\t * while for LE it is a host stack feature. This means that\n\t\t * switching BR/EDR back on when secure connections has been\n\t\t * enabled is not a supported transaction.\n\t\t */\n\t\tif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) &&\n\t\t    (bacmp(&hdev->static_addr, BDADDR_ANY) ||\n\t\t     hci_dev_test_flag(hdev, HCI_SC_ENABLED))) {\n\t\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BREDR,\n\t\t\t\t\t      MGMT_STATUS_REJECTED);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tif (pending_find(MGMT_OP_SET_BREDR, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BREDR,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_BREDR, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\t/* We need to flip the bit already here so that\n\t * hci_req_update_adv_data generates the correct flags.\n\t */\n\thci_dev_set_flag(hdev, HCI_BREDR_ENABLED);\n\n\thci_req_init(&req, hdev);\n\n\t__hci_req_write_fast_connectable(&req, false);\n\t__hci_req_update_scan(&req);\n\n\t/* Since only the advertising data flags will change, there\n\t * is no need to update the scan response data.\n\t */\n\t__hci_req_update_adv_data(&req, hdev->cur_adv_instance);\n\n\terr = hci_req_run(&req, set_bredr_complete);\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic void sc_enable_complete(struct hci_dev *hdev, u8 status, u16 opcode)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct mgmt_mode *cp;\n\n\tbt_dev_dbg(hdev, \"status %u\", status);\n\n\thci_dev_lock(hdev);\n\n\tcmd = pending_find(MGMT_OP_SET_SECURE_CONN, hdev);\n\tif (!cmd)\n\t\tgoto unlock;\n\n\tif (status) {\n\t\tmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode,\n\t\t\t        mgmt_status(status));\n\t\tgoto remove;\n\t}\n\n\tcp = cmd->param;\n\n\tswitch (cp->val) {\n\tcase 0x00:\n\t\thci_dev_clear_flag(hdev, HCI_SC_ENABLED);\n\t\thci_dev_clear_flag(hdev, HCI_SC_ONLY);\n\t\tbreak;\n\tcase 0x01:\n\t\thci_dev_set_flag(hdev, HCI_SC_ENABLED);\n\t\thci_dev_clear_flag(hdev, HCI_SC_ONLY);\n\t\tbreak;\n\tcase 0x02:\n\t\thci_dev_set_flag(hdev, HCI_SC_ENABLED);\n\t\thci_dev_set_flag(hdev, HCI_SC_ONLY);\n\t\tbreak;\n\t}\n\n\tsend_settings_rsp(cmd->sk, MGMT_OP_SET_SECURE_CONN, hdev);\n\tnew_settings(hdev, cmd->sk);\n\nremove:\n\tmgmt_pending_remove(cmd);\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic int set_secure_conn(struct sock *sk, struct hci_dev *hdev,\n\t\t\t   void *data, u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_request req;\n\tu8 val;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_sc_capable(hdev) &&\n\t    !hci_dev_test_flag(hdev, HCI_LE_ENABLED))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SECURE_CONN,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) &&\n\t    lmp_sc_capable(hdev) &&\n\t    !hci_dev_test_flag(hdev, HCI_SSP_ENABLED))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SECURE_CONN,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\tif (cp->val != 0x00 && cp->val != 0x01 && cp->val != 0x02)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SECURE_CONN,\n\t\t\t\t  MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev) || !lmp_sc_capable(hdev) ||\n\t    !hci_dev_test_flag(hdev, HCI_BREDR_ENABLED)) {\n\t\tbool changed;\n\n\t\tif (cp->val) {\n\t\t\tchanged = !hci_dev_test_and_set_flag(hdev,\n\t\t\t\t\t\t\t     HCI_SC_ENABLED);\n\t\t\tif (cp->val == 0x02)\n\t\t\t\thci_dev_set_flag(hdev, HCI_SC_ONLY);\n\t\t\telse\n\t\t\t\thci_dev_clear_flag(hdev, HCI_SC_ONLY);\n\t\t} else {\n\t\t\tchanged = hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t\t      HCI_SC_ENABLED);\n\t\t\thci_dev_clear_flag(hdev, HCI_SC_ONLY);\n\t\t}\n\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_SECURE_CONN, hdev);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tif (changed)\n\t\t\terr = new_settings(hdev, sk);\n\n\t\tgoto failed;\n\t}\n\n\tif (pending_find(MGMT_OP_SET_SECURE_CONN, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SECURE_CONN,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto failed;\n\t}\n\n\tval = !!cp->val;\n\n\tif (val == hci_dev_test_flag(hdev, HCI_SC_ENABLED) &&\n\t    (cp->val == 0x02) == hci_dev_test_flag(hdev, HCI_SC_ONLY)) {\n\t\terr = send_settings_rsp(sk, MGMT_OP_SET_SECURE_CONN, hdev);\n\t\tgoto failed;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_SET_SECURE_CONN, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\thci_req_init(&req, hdev);\n\thci_req_add(&req, HCI_OP_WRITE_SC_SUPPORT, 1, &val);\n\terr = hci_req_run(&req, sc_enable_complete);\n\tif (err < 0) {\n\t\tmgmt_pending_remove(cmd);\n\t\tgoto failed;\n\t}\n\nfailed:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_debug_keys(struct sock *sk, struct hci_dev *hdev,\n\t\t\t  void *data, u16 len)\n{\n\tstruct mgmt_mode *cp = data;\n\tbool changed, use_changed;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (cp->val != 0x00 && cp->val != 0x01 && cp->val != 0x02)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DEBUG_KEYS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (cp->val)\n\t\tchanged = !hci_dev_test_and_set_flag(hdev, HCI_KEEP_DEBUG_KEYS);\n\telse\n\t\tchanged = hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t      HCI_KEEP_DEBUG_KEYS);\n\n\tif (cp->val == 0x02)\n\t\tuse_changed = !hci_dev_test_and_set_flag(hdev,\n\t\t\t\t\t\t\t HCI_USE_DEBUG_KEYS);\n\telse\n\t\tuse_changed = hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t\t  HCI_USE_DEBUG_KEYS);\n\n\tif (hdev_is_powered(hdev) && use_changed &&\n\t    hci_dev_test_flag(hdev, HCI_SSP_ENABLED)) {\n\t\tu8 mode = (cp->val == 0x02) ? 0x01 : 0x00;\n\t\thci_send_cmd(hdev, HCI_OP_WRITE_SSP_DEBUG_MODE,\n\t\t\t     sizeof(mode), &mode);\n\t}\n\n\terr = send_settings_rsp(sk, MGMT_OP_SET_DEBUG_KEYS, hdev);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tif (changed)\n\t\terr = new_settings(hdev, sk);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_privacy(struct sock *sk, struct hci_dev *hdev, void *cp_data,\n\t\t       u16 len)\n{\n\tstruct mgmt_cp_set_privacy *cp = cp_data;\n\tbool changed;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PRIVACY,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (cp->privacy != 0x00 && cp->privacy != 0x01 && cp->privacy != 0x02)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PRIVACY,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tif (hdev_is_powered(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PRIVACY,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\thci_dev_lock(hdev);\n\n\t/* If user space supports this command it is also expected to\n\t * handle IRKs. Therefore, set the HCI_RPA_RESOLVING flag.\n\t */\n\thci_dev_set_flag(hdev, HCI_RPA_RESOLVING);\n\n\tif (cp->privacy) {\n\t\tchanged = !hci_dev_test_and_set_flag(hdev, HCI_PRIVACY);\n\t\tmemcpy(hdev->irk, cp->irk, sizeof(hdev->irk));\n\t\thci_dev_set_flag(hdev, HCI_RPA_EXPIRED);\n\t\thci_adv_instances_set_rpa_expired(hdev, true);\n\t\tif (cp->privacy == 0x02)\n\t\t\thci_dev_set_flag(hdev, HCI_LIMITED_PRIVACY);\n\t\telse\n\t\t\thci_dev_clear_flag(hdev, HCI_LIMITED_PRIVACY);\n\t} else {\n\t\tchanged = hci_dev_test_and_clear_flag(hdev, HCI_PRIVACY);\n\t\tmemset(hdev->irk, 0, sizeof(hdev->irk));\n\t\thci_dev_clear_flag(hdev, HCI_RPA_EXPIRED);\n\t\thci_adv_instances_set_rpa_expired(hdev, false);\n\t\thci_dev_clear_flag(hdev, HCI_LIMITED_PRIVACY);\n\t}\n\n\terr = send_settings_rsp(sk, MGMT_OP_SET_PRIVACY, hdev);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tif (changed)\n\t\terr = new_settings(hdev, sk);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic bool irk_is_valid(struct mgmt_irk_info *irk)\n{\n\tswitch (irk->addr.type) {\n\tcase BDADDR_LE_PUBLIC:\n\t\treturn true;\n\n\tcase BDADDR_LE_RANDOM:\n\t\t/* Two most significant bits shall be set */\n\t\tif ((irk->addr.bdaddr.b[5] & 0xc0) != 0xc0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int load_irks(struct sock *sk, struct hci_dev *hdev, void *cp_data,\n\t\t     u16 len)\n{\n\tstruct mgmt_cp_load_irks *cp = cp_data;\n\tconst u16 max_irk_count = ((U16_MAX - sizeof(*cp)) /\n\t\t\t\t   sizeof(struct mgmt_irk_info));\n\tu16 irk_count, expected_len;\n\tint i, err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_IRKS,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tirk_count = __le16_to_cpu(cp->irk_count);\n\tif (irk_count > max_irk_count) {\n\t\tbt_dev_err(hdev, \"load_irks: too big irk_count value %u\",\n\t\t\t   irk_count);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_IRKS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\texpected_len = struct_size(cp, irks, irk_count);\n\tif (expected_len != len) {\n\t\tbt_dev_err(hdev, \"load_irks: expected %u bytes, got %u bytes\",\n\t\t\t   expected_len, len);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_IRKS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\tbt_dev_dbg(hdev, \"irk_count %u\", irk_count);\n\n\tfor (i = 0; i < irk_count; i++) {\n\t\tstruct mgmt_irk_info *key = &cp->irks[i];\n\n\t\tif (!irk_is_valid(key))\n\t\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t\t       MGMT_OP_LOAD_IRKS,\n\t\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\thci_dev_lock(hdev);\n\n\thci_smp_irks_clear(hdev);\n\n\tfor (i = 0; i < irk_count; i++) {\n\t\tstruct mgmt_irk_info *irk = &cp->irks[i];\n\n\t\tif (hci_is_blocked_key(hdev,\n\t\t\t\t       HCI_BLOCKED_KEY_TYPE_IRK,\n\t\t\t\t       irk->val)) {\n\t\t\tbt_dev_warn(hdev, \"Skipping blocked IRK for %pMR\",\n\t\t\t\t    &irk->addr.bdaddr);\n\t\t\tcontinue;\n\t\t}\n\n\t\thci_add_irk(hdev, &irk->addr.bdaddr,\n\t\t\t    le_addr_type(irk->addr.type), irk->val,\n\t\t\t    BDADDR_ANY);\n\t}\n\n\thci_dev_set_flag(hdev, HCI_RPA_RESOLVING);\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_LOAD_IRKS, 0, NULL, 0);\n\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic bool ltk_is_valid(struct mgmt_ltk_info *key)\n{\n\tif (key->master != 0x00 && key->master != 0x01)\n\t\treturn false;\n\n\tswitch (key->addr.type) {\n\tcase BDADDR_LE_PUBLIC:\n\t\treturn true;\n\n\tcase BDADDR_LE_RANDOM:\n\t\t/* Two most significant bits shall be set */\n\t\tif ((key->addr.bdaddr.b[5] & 0xc0) != 0xc0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int load_long_term_keys(struct sock *sk, struct hci_dev *hdev,\n\t\t\t       void *cp_data, u16 len)\n{\n\tstruct mgmt_cp_load_long_term_keys *cp = cp_data;\n\tconst u16 max_key_count = ((U16_MAX - sizeof(*cp)) /\n\t\t\t\t   sizeof(struct mgmt_ltk_info));\n\tu16 key_count, expected_len;\n\tint i, err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LONG_TERM_KEYS,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tkey_count = __le16_to_cpu(cp->key_count);\n\tif (key_count > max_key_count) {\n\t\tbt_dev_err(hdev, \"load_ltks: too big key_count value %u\",\n\t\t\t   key_count);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LONG_TERM_KEYS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\texpected_len = struct_size(cp, keys, key_count);\n\tif (expected_len != len) {\n\t\tbt_dev_err(hdev, \"load_keys: expected %u bytes, got %u bytes\",\n\t\t\t   expected_len, len);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LONG_TERM_KEYS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\tbt_dev_dbg(hdev, \"key_count %u\", key_count);\n\n\tfor (i = 0; i < key_count; i++) {\n\t\tstruct mgmt_ltk_info *key = &cp->keys[i];\n\n\t\tif (!ltk_is_valid(key))\n\t\t\treturn mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t\t       MGMT_OP_LOAD_LONG_TERM_KEYS,\n\t\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\thci_dev_lock(hdev);\n\n\thci_smp_ltks_clear(hdev);\n\n\tfor (i = 0; i < key_count; i++) {\n\t\tstruct mgmt_ltk_info *key = &cp->keys[i];\n\t\tu8 type, authenticated;\n\n\t\tif (hci_is_blocked_key(hdev,\n\t\t\t\t       HCI_BLOCKED_KEY_TYPE_LTK,\n\t\t\t\t       key->val)) {\n\t\t\tbt_dev_warn(hdev, \"Skipping blocked LTK for %pMR\",\n\t\t\t\t    &key->addr.bdaddr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (key->type) {\n\t\tcase MGMT_LTK_UNAUTHENTICATED:\n\t\t\tauthenticated = 0x00;\n\t\t\ttype = key->master ? SMP_LTK : SMP_LTK_SLAVE;\n\t\t\tbreak;\n\t\tcase MGMT_LTK_AUTHENTICATED:\n\t\t\tauthenticated = 0x01;\n\t\t\ttype = key->master ? SMP_LTK : SMP_LTK_SLAVE;\n\t\t\tbreak;\n\t\tcase MGMT_LTK_P256_UNAUTH:\n\t\t\tauthenticated = 0x00;\n\t\t\ttype = SMP_LTK_P256;\n\t\t\tbreak;\n\t\tcase MGMT_LTK_P256_AUTH:\n\t\t\tauthenticated = 0x01;\n\t\t\ttype = SMP_LTK_P256;\n\t\t\tbreak;\n\t\tcase MGMT_LTK_P256_DEBUG:\n\t\t\tauthenticated = 0x00;\n\t\t\ttype = SMP_LTK_P256_DEBUG;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\thci_add_ltk(hdev, &key->addr.bdaddr,\n\t\t\t    le_addr_type(key->addr.type), type, authenticated,\n\t\t\t    key->val, key->enc_size, key->ediv, key->rand);\n\t}\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_LOAD_LONG_TERM_KEYS, 0,\n\t\t\t   NULL, 0);\n\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic int conn_info_cmd_complete(struct mgmt_pending_cmd *cmd, u8 status)\n{\n\tstruct hci_conn *conn = cmd->user_data;\n\tstruct mgmt_rp_get_conn_info rp;\n\tint err;\n\n\tmemcpy(&rp.addr, cmd->param, sizeof(rp.addr));\n\n\tif (status == MGMT_STATUS_SUCCESS) {\n\t\trp.rssi = conn->rssi;\n\t\trp.tx_power = conn->tx_power;\n\t\trp.max_tx_power = conn->max_tx_power;\n\t} else {\n\t\trp.rssi = HCI_RSSI_INVALID;\n\t\trp.tx_power = HCI_TX_POWER_INVALID;\n\t\trp.max_tx_power = HCI_TX_POWER_INVALID;\n\t}\n\n\terr = mgmt_cmd_complete(cmd->sk, cmd->index, MGMT_OP_GET_CONN_INFO,\n\t\t\t\tstatus, &rp, sizeof(rp));\n\n\thci_conn_drop(conn);\n\thci_conn_put(conn);\n\n\treturn err;\n}\n\nstatic void conn_info_refresh_complete(struct hci_dev *hdev, u8 hci_status,\n\t\t\t\t       u16 opcode)\n{\n\tstruct hci_cp_read_rssi *cp;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_conn *conn;\n\tu16 handle;\n\tu8 status;\n\n\tbt_dev_dbg(hdev, \"status 0x%02x\", hci_status);\n\n\thci_dev_lock(hdev);\n\n\t/* Commands sent in request are either Read RSSI or Read Transmit Power\n\t * Level so we check which one was last sent to retrieve connection\n\t * handle.  Both commands have handle as first parameter so it's safe to\n\t * cast data on the same command struct.\n\t *\n\t * First command sent is always Read RSSI and we fail only if it fails.\n\t * In other case we simply override error to indicate success as we\n\t * already remembered if TX power value is actually valid.\n\t */\n\tcp = hci_sent_cmd_data(hdev, HCI_OP_READ_RSSI);\n\tif (!cp) {\n\t\tcp = hci_sent_cmd_data(hdev, HCI_OP_READ_TX_POWER);\n\t\tstatus = MGMT_STATUS_SUCCESS;\n\t} else {\n\t\tstatus = mgmt_status(hci_status);\n\t}\n\n\tif (!cp) {\n\t\tbt_dev_err(hdev, \"invalid sent_cmd in conn_info response\");\n\t\tgoto unlock;\n\t}\n\n\thandle = __le16_to_cpu(cp->handle);\n\tconn = hci_conn_hash_lookup_handle(hdev, handle);\n\tif (!conn) {\n\t\tbt_dev_err(hdev, \"unknown handle (%d) in conn_info response\",\n\t\t\t   handle);\n\t\tgoto unlock;\n\t}\n\n\tcmd = pending_find_data(MGMT_OP_GET_CONN_INFO, hdev, conn);\n\tif (!cmd)\n\t\tgoto unlock;\n\n\tcmd->cmd_complete(cmd, status);\n\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic int get_conn_info(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t u16 len)\n{\n\tstruct mgmt_cp_get_conn_info *cp = data;\n\tstruct mgmt_rp_get_conn_info rp;\n\tstruct hci_conn *conn;\n\tunsigned long conn_info_age;\n\tint err = 0;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tmemset(&rp, 0, sizeof(rp));\n\tbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\n\trp.addr.type = cp->addr.type;\n\n\tif (!bdaddr_type_is_valid(cp->addr.type))\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &rp, sizeof(rp));\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,\n\t\t\t\t\tMGMT_STATUS_NOT_POWERED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tif (cp->addr.type == BDADDR_BREDR)\n\t\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,\n\t\t\t\t\t       &cp->addr.bdaddr);\n\telse\n\t\tconn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->addr.bdaddr);\n\n\tif (!conn || conn->state != BT_CONNECTED) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,\n\t\t\t\t\tMGMT_STATUS_NOT_CONNECTED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tif (pending_find_data(MGMT_OP_GET_CONN_INFO, hdev, conn)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,\n\t\t\t\t\tMGMT_STATUS_BUSY, &rp, sizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\t/* To avoid client trying to guess when to poll again for information we\n\t * calculate conn info age as random value between min/max set in hdev.\n\t */\n\tconn_info_age = hdev->conn_info_min_age +\n\t\t\tprandom_u32_max(hdev->conn_info_max_age -\n\t\t\t\t\thdev->conn_info_min_age);\n\n\t/* Query controller to refresh cached values if they are too old or were\n\t * never read.\n\t */\n\tif (time_after(jiffies, conn->conn_info_timestamp +\n\t\t       msecs_to_jiffies(conn_info_age)) ||\n\t    !conn->conn_info_timestamp) {\n\t\tstruct hci_request req;\n\t\tstruct hci_cp_read_tx_power req_txp_cp;\n\t\tstruct hci_cp_read_rssi req_rssi_cp;\n\t\tstruct mgmt_pending_cmd *cmd;\n\n\t\thci_req_init(&req, hdev);\n\t\treq_rssi_cp.handle = cpu_to_le16(conn->handle);\n\t\thci_req_add(&req, HCI_OP_READ_RSSI, sizeof(req_rssi_cp),\n\t\t\t    &req_rssi_cp);\n\n\t\t/* For LE links TX power does not change thus we don't need to\n\t\t * query for it once value is known.\n\t\t */\n\t\tif (!bdaddr_type_is_le(cp->addr.type) ||\n\t\t    conn->tx_power == HCI_TX_POWER_INVALID) {\n\t\t\treq_txp_cp.handle = cpu_to_le16(conn->handle);\n\t\t\treq_txp_cp.type = 0x00;\n\t\t\thci_req_add(&req, HCI_OP_READ_TX_POWER,\n\t\t\t\t    sizeof(req_txp_cp), &req_txp_cp);\n\t\t}\n\n\t\t/* Max TX power needs to be read only once per connection */\n\t\tif (conn->max_tx_power == HCI_TX_POWER_INVALID) {\n\t\t\treq_txp_cp.handle = cpu_to_le16(conn->handle);\n\t\t\treq_txp_cp.type = 0x01;\n\t\t\thci_req_add(&req, HCI_OP_READ_TX_POWER,\n\t\t\t\t    sizeof(req_txp_cp), &req_txp_cp);\n\t\t}\n\n\t\terr = hci_req_run(&req, conn_info_refresh_complete);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\n\t\tcmd = mgmt_pending_add(sk, MGMT_OP_GET_CONN_INFO, hdev,\n\t\t\t\t       data, len);\n\t\tif (!cmd) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\thci_conn_hold(conn);\n\t\tcmd->user_data = hci_conn_get(conn);\n\t\tcmd->cmd_complete = conn_info_cmd_complete;\n\n\t\tconn->conn_info_timestamp = jiffies;\n\t} else {\n\t\t/* Cache is valid, just reply with values cached in hci_conn */\n\t\trp.rssi = conn->rssi;\n\t\trp.tx_power = conn->tx_power;\n\t\trp.max_tx_power = conn->max_tx_power;\n\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,\n\t\t\t\t\tMGMT_STATUS_SUCCESS, &rp, sizeof(rp));\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int clock_info_cmd_complete(struct mgmt_pending_cmd *cmd, u8 status)\n{\n\tstruct hci_conn *conn = cmd->user_data;\n\tstruct mgmt_rp_get_clock_info rp;\n\tstruct hci_dev *hdev;\n\tint err;\n\n\tmemset(&rp, 0, sizeof(rp));\n\tmemcpy(&rp.addr, cmd->param, sizeof(rp.addr));\n\n\tif (status)\n\t\tgoto complete;\n\n\thdev = hci_dev_get(cmd->index);\n\tif (hdev) {\n\t\trp.local_clock = cpu_to_le32(hdev->clock);\n\t\thci_dev_put(hdev);\n\t}\n\n\tif (conn) {\n\t\trp.piconet_clock = cpu_to_le32(conn->clock);\n\t\trp.accuracy = cpu_to_le16(conn->clock_accuracy);\n\t}\n\ncomplete:\n\terr = mgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode, status, &rp,\n\t\t\t\tsizeof(rp));\n\n\tif (conn) {\n\t\thci_conn_drop(conn);\n\t\thci_conn_put(conn);\n\t}\n\n\treturn err;\n}\n\nstatic void get_clock_info_complete(struct hci_dev *hdev, u8 status, u16 opcode)\n{\n\tstruct hci_cp_read_clock *hci_cp;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_conn *conn;\n\n\tbt_dev_dbg(hdev, \"status %u\", status);\n\n\thci_dev_lock(hdev);\n\n\thci_cp = hci_sent_cmd_data(hdev, HCI_OP_READ_CLOCK);\n\tif (!hci_cp)\n\t\tgoto unlock;\n\n\tif (hci_cp->which) {\n\t\tu16 handle = __le16_to_cpu(hci_cp->handle);\n\t\tconn = hci_conn_hash_lookup_handle(hdev, handle);\n\t} else {\n\t\tconn = NULL;\n\t}\n\n\tcmd = pending_find_data(MGMT_OP_GET_CLOCK_INFO, hdev, conn);\n\tif (!cmd)\n\t\tgoto unlock;\n\n\tcmd->cmd_complete(cmd, mgmt_status(status));\n\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic int get_clock_info(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t u16 len)\n{\n\tstruct mgmt_cp_get_clock_info *cp = data;\n\tstruct mgmt_rp_get_clock_info rp;\n\tstruct hci_cp_read_clock hci_cp;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_request req;\n\tstruct hci_conn *conn;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tmemset(&rp, 0, sizeof(rp));\n\tbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\n\trp.addr.type = cp->addr.type;\n\n\tif (cp->addr.type != BDADDR_BREDR)\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CLOCK_INFO,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &rp, sizeof(rp));\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CLOCK_INFO,\n\t\t\t\t\tMGMT_STATUS_NOT_POWERED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tif (bacmp(&cp->addr.bdaddr, BDADDR_ANY)) {\n\t\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,\n\t\t\t\t\t       &cp->addr.bdaddr);\n\t\tif (!conn || conn->state != BT_CONNECTED) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_GET_CLOCK_INFO,\n\t\t\t\t\t\tMGMT_STATUS_NOT_CONNECTED,\n\t\t\t\t\t\t&rp, sizeof(rp));\n\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\tconn = NULL;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_GET_CLOCK_INFO, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tcmd->cmd_complete = clock_info_cmd_complete;\n\n\thci_req_init(&req, hdev);\n\n\tmemset(&hci_cp, 0, sizeof(hci_cp));\n\thci_req_add(&req, HCI_OP_READ_CLOCK, sizeof(hci_cp), &hci_cp);\n\n\tif (conn) {\n\t\thci_conn_hold(conn);\n\t\tcmd->user_data = hci_conn_get(conn);\n\n\t\thci_cp.handle = cpu_to_le16(conn->handle);\n\t\thci_cp.which = 0x01; /* Piconet clock */\n\t\thci_req_add(&req, HCI_OP_READ_CLOCK, sizeof(hci_cp), &hci_cp);\n\t}\n\n\terr = hci_req_run(&req, get_clock_info_complete);\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic bool is_connected(struct hci_dev *hdev, bdaddr_t *addr, u8 type)\n{\n\tstruct hci_conn *conn;\n\n\tconn = hci_conn_hash_lookup_ba(hdev, LE_LINK, addr);\n\tif (!conn)\n\t\treturn false;\n\n\tif (conn->dst_type != type)\n\t\treturn false;\n\n\tif (conn->state != BT_CONNECTED)\n\t\treturn false;\n\n\treturn true;\n}\n\n/* This function requires the caller holds hdev->lock */\nstatic int hci_conn_params_set(struct hci_dev *hdev, bdaddr_t *addr,\n\t\t\t       u8 addr_type, u8 auto_connect)\n{\n\tstruct hci_conn_params *params;\n\n\tparams = hci_conn_params_add(hdev, addr, addr_type);\n\tif (!params)\n\t\treturn -EIO;\n\n\tif (params->auto_connect == auto_connect)\n\t\treturn 0;\n\n\tlist_del_init(&params->action);\n\n\tswitch (auto_connect) {\n\tcase HCI_AUTO_CONN_DISABLED:\n\tcase HCI_AUTO_CONN_LINK_LOSS:\n\t\t/* If auto connect is being disabled when we're trying to\n\t\t * connect to device, keep connecting.\n\t\t */\n\t\tif (params->explicit_connect)\n\t\t\tlist_add(&params->action, &hdev->pend_le_conns);\n\t\tbreak;\n\tcase HCI_AUTO_CONN_REPORT:\n\t\tif (params->explicit_connect)\n\t\t\tlist_add(&params->action, &hdev->pend_le_conns);\n\t\telse\n\t\t\tlist_add(&params->action, &hdev->pend_le_reports);\n\t\tbreak;\n\tcase HCI_AUTO_CONN_DIRECT:\n\tcase HCI_AUTO_CONN_ALWAYS:\n\t\tif (!is_connected(hdev, addr, addr_type))\n\t\t\tlist_add(&params->action, &hdev->pend_le_conns);\n\t\tbreak;\n\t}\n\n\tparams->auto_connect = auto_connect;\n\n\tbt_dev_dbg(hdev, \"addr %pMR (type %u) auto_connect %u\",\n\t\t   addr, addr_type, auto_connect);\n\n\treturn 0;\n}\n\nstatic void device_added(struct sock *sk, struct hci_dev *hdev,\n\t\t\t bdaddr_t *bdaddr, u8 type, u8 action)\n{\n\tstruct mgmt_ev_device_added ev;\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = type;\n\tev.action = action;\n\n\tmgmt_event(MGMT_EV_DEVICE_ADDED, hdev, &ev, sizeof(ev), sk);\n}\n\nstatic int add_device(struct sock *sk, struct hci_dev *hdev,\n\t\t      void *data, u16 len)\n{\n\tstruct mgmt_cp_add_device *cp = data;\n\tu8 auto_conn, addr_type;\n\tstruct hci_conn_params *params;\n\tint err;\n\tu32 current_flags = 0;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!bdaddr_type_is_valid(cp->addr.type) ||\n\t    !bacmp(&cp->addr.bdaddr, BDADDR_ANY))\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &cp->addr, sizeof(cp->addr));\n\n\tif (cp->action != 0x00 && cp->action != 0x01 && cp->action != 0x02)\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &cp->addr, sizeof(cp->addr));\n\n\thci_dev_lock(hdev);\n\n\tif (cp->addr.type == BDADDR_BREDR) {\n\t\t/* Only incoming connections action is supported for now */\n\t\tif (cp->action != 0x01) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_ADD_DEVICE,\n\t\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t\t&cp->addr, sizeof(cp->addr));\n\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = hci_bdaddr_list_add_with_flags(&hdev->whitelist,\n\t\t\t\t\t\t     &cp->addr.bdaddr,\n\t\t\t\t\t\t     cp->addr.type, 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\thci_req_update_scan(hdev);\n\n\t\tgoto added;\n\t}\n\n\taddr_type = le_addr_type(cp->addr.type);\n\n\tif (cp->action == 0x02)\n\t\tauto_conn = HCI_AUTO_CONN_ALWAYS;\n\telse if (cp->action == 0x01)\n\t\tauto_conn = HCI_AUTO_CONN_DIRECT;\n\telse\n\t\tauto_conn = HCI_AUTO_CONN_REPORT;\n\n\t/* Kernel internally uses conn_params with resolvable private\n\t * address, but Add Device allows only identity addresses.\n\t * Make sure it is enforced before calling\n\t * hci_conn_params_lookup.\n\t */\n\tif (!hci_is_identity_address(&cp->addr.bdaddr, addr_type)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,\n\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t&cp->addr, sizeof(cp->addr));\n\t\tgoto unlock;\n\t}\n\n\t/* If the connection parameters don't exist for this device,\n\t * they will be created and configured with defaults.\n\t */\n\tif (hci_conn_params_set(hdev, &cp->addr.bdaddr, addr_type,\n\t\t\t\tauto_conn) < 0) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,\n\t\t\t\t\tMGMT_STATUS_FAILED, &cp->addr,\n\t\t\t\t\tsizeof(cp->addr));\n\t\tgoto unlock;\n\t} else {\n\t\tparams = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,\n\t\t\t\t\t\taddr_type);\n\t\tif (params)\n\t\t\tcurrent_flags = params->current_flags;\n\t}\n\n\thci_update_background_scan(hdev);\n\nadded:\n\tdevice_added(sk, hdev, &cp->addr.bdaddr, cp->addr.type, cp->action);\n\tdevice_flags_changed(NULL, hdev, &cp->addr.bdaddr, cp->addr.type,\n\t\t\t     SUPPORTED_DEVICE_FLAGS(), current_flags);\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,\n\t\t\t\tMGMT_STATUS_SUCCESS, &cp->addr,\n\t\t\t\tsizeof(cp->addr));\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic void device_removed(struct sock *sk, struct hci_dev *hdev,\n\t\t\t   bdaddr_t *bdaddr, u8 type)\n{\n\tstruct mgmt_ev_device_removed ev;\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = type;\n\n\tmgmt_event(MGMT_EV_DEVICE_REMOVED, hdev, &ev, sizeof(ev), sk);\n}\n\nstatic int remove_device(struct sock *sk, struct hci_dev *hdev,\n\t\t\t void *data, u16 len)\n{\n\tstruct mgmt_cp_remove_device *cp = data;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\thci_dev_lock(hdev);\n\n\tif (bacmp(&cp->addr.bdaddr, BDADDR_ANY)) {\n\t\tstruct hci_conn_params *params;\n\t\tu8 addr_type;\n\n\t\tif (!bdaddr_type_is_valid(cp->addr.type)) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_REMOVE_DEVICE,\n\t\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t\t&cp->addr, sizeof(cp->addr));\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (cp->addr.type == BDADDR_BREDR) {\n\t\t\terr = hci_bdaddr_list_del(&hdev->whitelist,\n\t\t\t\t\t\t  &cp->addr.bdaddr,\n\t\t\t\t\t\t  cp->addr.type);\n\t\t\tif (err) {\n\t\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\t\tMGMT_OP_REMOVE_DEVICE,\n\t\t\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t\t\t&cp->addr,\n\t\t\t\t\t\t\tsizeof(cp->addr));\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\thci_req_update_scan(hdev);\n\n\t\t\tdevice_removed(sk, hdev, &cp->addr.bdaddr,\n\t\t\t\t       cp->addr.type);\n\t\t\tgoto complete;\n\t\t}\n\n\t\taddr_type = le_addr_type(cp->addr.type);\n\n\t\t/* Kernel internally uses conn_params with resolvable private\n\t\t * address, but Remove Device allows only identity addresses.\n\t\t * Make sure it is enforced before calling\n\t\t * hci_conn_params_lookup.\n\t\t */\n\t\tif (!hci_is_identity_address(&cp->addr.bdaddr, addr_type)) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_REMOVE_DEVICE,\n\t\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t\t&cp->addr, sizeof(cp->addr));\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tparams = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,\n\t\t\t\t\t\taddr_type);\n\t\tif (!params) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_REMOVE_DEVICE,\n\t\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t\t&cp->addr, sizeof(cp->addr));\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (params->auto_connect == HCI_AUTO_CONN_DISABLED ||\n\t\t    params->auto_connect == HCI_AUTO_CONN_EXPLICIT) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_REMOVE_DEVICE,\n\t\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t\t&cp->addr, sizeof(cp->addr));\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tlist_del(&params->action);\n\t\tlist_del(&params->list);\n\t\tkfree(params);\n\t\thci_update_background_scan(hdev);\n\n\t\tdevice_removed(sk, hdev, &cp->addr.bdaddr, cp->addr.type);\n\t} else {\n\t\tstruct hci_conn_params *p, *tmp;\n\t\tstruct bdaddr_list *b, *btmp;\n\n\t\tif (cp->addr.type) {\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_REMOVE_DEVICE,\n\t\t\t\t\t\tMGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t\t&cp->addr, sizeof(cp->addr));\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tlist_for_each_entry_safe(b, btmp, &hdev->whitelist, list) {\n\t\t\tdevice_removed(sk, hdev, &b->bdaddr, b->bdaddr_type);\n\t\t\tlist_del(&b->list);\n\t\t\tkfree(b);\n\t\t}\n\n\t\thci_req_update_scan(hdev);\n\n\t\tlist_for_each_entry_safe(p, tmp, &hdev->le_conn_params, list) {\n\t\t\tif (p->auto_connect == HCI_AUTO_CONN_DISABLED)\n\t\t\t\tcontinue;\n\t\t\tdevice_removed(sk, hdev, &p->addr, p->addr_type);\n\t\t\tif (p->explicit_connect) {\n\t\t\t\tp->auto_connect = HCI_AUTO_CONN_EXPLICIT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlist_del(&p->action);\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t}\n\n\t\tbt_dev_dbg(hdev, \"All LE connection parameters were removed\");\n\n\t\thci_update_background_scan(hdev);\n\t}\n\ncomplete:\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_DEVICE,\n\t\t\t\tMGMT_STATUS_SUCCESS, &cp->addr,\n\t\t\t\tsizeof(cp->addr));\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int load_conn_param(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t   u16 len)\n{\n\tstruct mgmt_cp_load_conn_param *cp = data;\n\tconst u16 max_param_count = ((U16_MAX - sizeof(*cp)) /\n\t\t\t\t     sizeof(struct mgmt_conn_param));\n\tu16 param_count, expected_len;\n\tint i;\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_CONN_PARAM,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tparam_count = __le16_to_cpu(cp->param_count);\n\tif (param_count > max_param_count) {\n\t\tbt_dev_err(hdev, \"load_conn_param: too big param_count value %u\",\n\t\t\t   param_count);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_CONN_PARAM,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\texpected_len = struct_size(cp, params, param_count);\n\tif (expected_len != len) {\n\t\tbt_dev_err(hdev, \"load_conn_param: expected %u bytes, got %u bytes\",\n\t\t\t   expected_len, len);\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_CONN_PARAM,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\t}\n\n\tbt_dev_dbg(hdev, \"param_count %u\", param_count);\n\n\thci_dev_lock(hdev);\n\n\thci_conn_params_clear_disabled(hdev);\n\n\tfor (i = 0; i < param_count; i++) {\n\t\tstruct mgmt_conn_param *param = &cp->params[i];\n\t\tstruct hci_conn_params *hci_param;\n\t\tu16 min, max, latency, timeout;\n\t\tu8 addr_type;\n\n\t\tbt_dev_dbg(hdev, \"Adding %pMR (type %u)\", &param->addr.bdaddr,\n\t\t\t   param->addr.type);\n\n\t\tif (param->addr.type == BDADDR_LE_PUBLIC) {\n\t\t\taddr_type = ADDR_LE_DEV_PUBLIC;\n\t\t} else if (param->addr.type == BDADDR_LE_RANDOM) {\n\t\t\taddr_type = ADDR_LE_DEV_RANDOM;\n\t\t} else {\n\t\t\tbt_dev_err(hdev, \"ignoring invalid connection parameters\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tmin = le16_to_cpu(param->min_interval);\n\t\tmax = le16_to_cpu(param->max_interval);\n\t\tlatency = le16_to_cpu(param->latency);\n\t\ttimeout = le16_to_cpu(param->timeout);\n\n\t\tbt_dev_dbg(hdev, \"min 0x%04x max 0x%04x latency 0x%04x timeout 0x%04x\",\n\t\t\t   min, max, latency, timeout);\n\n\t\tif (hci_check_conn_params(min, max, latency, timeout) < 0) {\n\t\t\tbt_dev_err(hdev, \"ignoring invalid connection parameters\");\n\t\t\tcontinue;\n\t\t}\n\n\t\thci_param = hci_conn_params_add(hdev, &param->addr.bdaddr,\n\t\t\t\t\t\taddr_type);\n\t\tif (!hci_param) {\n\t\t\tbt_dev_err(hdev, \"failed to add connection parameters\");\n\t\t\tcontinue;\n\t\t}\n\n\t\thci_param->conn_min_interval = min;\n\t\thci_param->conn_max_interval = max;\n\t\thci_param->conn_latency = latency;\n\t\thci_param->supervision_timeout = timeout;\n\t}\n\n\thci_dev_unlock(hdev);\n\n\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_LOAD_CONN_PARAM, 0,\n\t\t\t\t NULL, 0);\n}\n\nstatic int set_external_config(struct sock *sk, struct hci_dev *hdev,\n\t\t\t       void *data, u16 len)\n{\n\tstruct mgmt_cp_set_external_config *cp = data;\n\tbool changed;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (hdev_is_powered(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_EXTERNAL_CONFIG,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\tif (cp->config != 0x00 && cp->config != 0x01)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_EXTERNAL_CONFIG,\n\t\t\t\t         MGMT_STATUS_INVALID_PARAMS);\n\n\tif (!test_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_EXTERNAL_CONFIG,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\thci_dev_lock(hdev);\n\n\tif (cp->config)\n\t\tchanged = !hci_dev_test_and_set_flag(hdev, HCI_EXT_CONFIGURED);\n\telse\n\t\tchanged = hci_dev_test_and_clear_flag(hdev, HCI_EXT_CONFIGURED);\n\n\terr = send_options_rsp(sk, MGMT_OP_SET_EXTERNAL_CONFIG, hdev);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tif (!changed)\n\t\tgoto unlock;\n\n\terr = new_options(hdev, sk);\n\n\tif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED) == is_configured(hdev)) {\n\t\tmgmt_index_removed(hdev);\n\n\t\tif (hci_dev_test_and_change_flag(hdev, HCI_UNCONFIGURED)) {\n\t\t\thci_dev_set_flag(hdev, HCI_CONFIG);\n\t\t\thci_dev_set_flag(hdev, HCI_AUTO_OFF);\n\n\t\t\tqueue_work(hdev->req_workqueue, &hdev->power_on);\n\t\t} else {\n\t\t\tset_bit(HCI_RAW, &hdev->flags);\n\t\t\tmgmt_index_added(hdev);\n\t\t}\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic int set_public_address(struct sock *sk, struct hci_dev *hdev,\n\t\t\t      void *data, u16 len)\n{\n\tstruct mgmt_cp_set_public_address *cp = data;\n\tbool changed;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (hdev_is_powered(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PUBLIC_ADDRESS,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\tif (!bacmp(&cp->bdaddr, BDADDR_ANY))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PUBLIC_ADDRESS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tif (!hdev->set_bdaddr)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PUBLIC_ADDRESS,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\thci_dev_lock(hdev);\n\n\tchanged = !!bacmp(&hdev->public_addr, &cp->bdaddr);\n\tbacpy(&hdev->public_addr, &cp->bdaddr);\n\n\terr = send_options_rsp(sk, MGMT_OP_SET_PUBLIC_ADDRESS, hdev);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tif (!changed)\n\t\tgoto unlock;\n\n\tif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED))\n\t\terr = new_options(hdev, sk);\n\n\tif (is_configured(hdev)) {\n\t\tmgmt_index_removed(hdev);\n\n\t\thci_dev_clear_flag(hdev, HCI_UNCONFIGURED);\n\n\t\thci_dev_set_flag(hdev, HCI_CONFIG);\n\t\thci_dev_set_flag(hdev, HCI_AUTO_OFF);\n\n\t\tqueue_work(hdev->req_workqueue, &hdev->power_on);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n\nstatic void read_local_oob_ext_data_complete(struct hci_dev *hdev, u8 status,\n\t\t\t\t\t     u16 opcode, struct sk_buff *skb)\n{\n\tconst struct mgmt_cp_read_local_oob_ext_data *mgmt_cp;\n\tstruct mgmt_rp_read_local_oob_ext_data *mgmt_rp;\n\tu8 *h192, *r192, *h256, *r256;\n\tstruct mgmt_pending_cmd *cmd;\n\tu16 eir_len;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"status %u\", status);\n\n\tcmd = pending_find(MGMT_OP_READ_LOCAL_OOB_EXT_DATA, hdev);\n\tif (!cmd)\n\t\treturn;\n\n\tmgmt_cp = cmd->param;\n\n\tif (status) {\n\t\tstatus = mgmt_status(status);\n\t\teir_len = 0;\n\n\t\th192 = NULL;\n\t\tr192 = NULL;\n\t\th256 = NULL;\n\t\tr256 = NULL;\n\t} else if (opcode == HCI_OP_READ_LOCAL_OOB_DATA) {\n\t\tstruct hci_rp_read_local_oob_data *rp;\n\n\t\tif (skb->len != sizeof(*rp)) {\n\t\t\tstatus = MGMT_STATUS_FAILED;\n\t\t\teir_len = 0;\n\t\t} else {\n\t\t\tstatus = MGMT_STATUS_SUCCESS;\n\t\t\trp = (void *)skb->data;\n\n\t\t\teir_len = 5 + 18 + 18;\n\t\t\th192 = rp->hash;\n\t\t\tr192 = rp->rand;\n\t\t\th256 = NULL;\n\t\t\tr256 = NULL;\n\t\t}\n\t} else {\n\t\tstruct hci_rp_read_local_oob_ext_data *rp;\n\n\t\tif (skb->len != sizeof(*rp)) {\n\t\t\tstatus = MGMT_STATUS_FAILED;\n\t\t\teir_len = 0;\n\t\t} else {\n\t\t\tstatus = MGMT_STATUS_SUCCESS;\n\t\t\trp = (void *)skb->data;\n\n\t\t\tif (hci_dev_test_flag(hdev, HCI_SC_ONLY)) {\n\t\t\t\teir_len = 5 + 18 + 18;\n\t\t\t\th192 = NULL;\n\t\t\t\tr192 = NULL;\n\t\t\t} else {\n\t\t\t\teir_len = 5 + 18 + 18 + 18 + 18;\n\t\t\t\th192 = rp->hash192;\n\t\t\t\tr192 = rp->rand192;\n\t\t\t}\n\n\t\t\th256 = rp->hash256;\n\t\t\tr256 = rp->rand256;\n\t\t}\n\t}\n\n\tmgmt_rp = kmalloc(sizeof(*mgmt_rp) + eir_len, GFP_KERNEL);\n\tif (!mgmt_rp)\n\t\tgoto done;\n\n\tif (status)\n\t\tgoto send_rsp;\n\n\teir_len = eir_append_data(mgmt_rp->eir, 0, EIR_CLASS_OF_DEV,\n\t\t\t\t  hdev->dev_class, 3);\n\n\tif (h192 && r192) {\n\t\teir_len = eir_append_data(mgmt_rp->eir, eir_len,\n\t\t\t\t\t  EIR_SSP_HASH_C192, h192, 16);\n\t\teir_len = eir_append_data(mgmt_rp->eir, eir_len,\n\t\t\t\t\t  EIR_SSP_RAND_R192, r192, 16);\n\t}\n\n\tif (h256 && r256) {\n\t\teir_len = eir_append_data(mgmt_rp->eir, eir_len,\n\t\t\t\t\t  EIR_SSP_HASH_C256, h256, 16);\n\t\teir_len = eir_append_data(mgmt_rp->eir, eir_len,\n\t\t\t\t\t  EIR_SSP_RAND_R256, r256, 16);\n\t}\n\nsend_rsp:\n\tmgmt_rp->type = mgmt_cp->type;\n\tmgmt_rp->eir_len = cpu_to_le16(eir_len);\n\n\terr = mgmt_cmd_complete(cmd->sk, hdev->id,\n\t\t\t\tMGMT_OP_READ_LOCAL_OOB_EXT_DATA, status,\n\t\t\t\tmgmt_rp, sizeof(*mgmt_rp) + eir_len);\n\tif (err < 0 || status)\n\t\tgoto done;\n\n\thci_sock_set_flag(cmd->sk, HCI_MGMT_OOB_DATA_EVENTS);\n\n\terr = mgmt_limited_event(MGMT_EV_LOCAL_OOB_DATA_UPDATED, hdev,\n\t\t\t\t mgmt_rp, sizeof(*mgmt_rp) + eir_len,\n\t\t\t\t HCI_MGMT_OOB_DATA_EVENTS, cmd->sk);\ndone:\n\tkfree(mgmt_rp);\n\tmgmt_pending_remove(cmd);\n}\n\nstatic int read_local_ssp_oob_req(struct hci_dev *hdev, struct sock *sk,\n\t\t\t\t  struct mgmt_cp_read_local_oob_ext_data *cp)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_request req;\n\tint err;\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_READ_LOCAL_OOB_EXT_DATA, hdev,\n\t\t\t       cp, sizeof(*cp));\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\thci_req_init(&req, hdev);\n\n\tif (bredr_sc_enabled(hdev))\n\t\thci_req_add(&req, HCI_OP_READ_LOCAL_OOB_EXT_DATA, 0, NULL);\n\telse\n\t\thci_req_add(&req, HCI_OP_READ_LOCAL_OOB_DATA, 0, NULL);\n\n\terr = hci_req_run_skb(&req, read_local_oob_ext_data_complete);\n\tif (err < 0) {\n\t\tmgmt_pending_remove(cmd);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_local_oob_ext_data(struct sock *sk, struct hci_dev *hdev,\n\t\t\t\t   void *data, u16 data_len)\n{\n\tstruct mgmt_cp_read_local_oob_ext_data *cp = data;\n\tstruct mgmt_rp_read_local_oob_ext_data *rp;\n\tsize_t rp_len;\n\tu16 eir_len;\n\tu8 status, flags, role, addr[7], hash[16], rand[16];\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (hdev_is_powered(hdev)) {\n\t\tswitch (cp->type) {\n\t\tcase BIT(BDADDR_BREDR):\n\t\t\tstatus = mgmt_bredr_support(hdev);\n\t\t\tif (status)\n\t\t\t\teir_len = 0;\n\t\t\telse\n\t\t\t\teir_len = 5;\n\t\t\tbreak;\n\t\tcase (BIT(BDADDR_LE_PUBLIC) | BIT(BDADDR_LE_RANDOM)):\n\t\t\tstatus = mgmt_le_support(hdev);\n\t\t\tif (status)\n\t\t\t\teir_len = 0;\n\t\t\telse\n\t\t\t\teir_len = 9 + 3 + 18 + 18 + 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = MGMT_STATUS_INVALID_PARAMS;\n\t\t\teir_len = 0;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tstatus = MGMT_STATUS_NOT_POWERED;\n\t\teir_len = 0;\n\t}\n\n\trp_len = sizeof(*rp) + eir_len;\n\trp = kmalloc(rp_len, GFP_ATOMIC);\n\tif (!rp)\n\t\treturn -ENOMEM;\n\n\tif (status)\n\t\tgoto complete;\n\n\thci_dev_lock(hdev);\n\n\teir_len = 0;\n\tswitch (cp->type) {\n\tcase BIT(BDADDR_BREDR):\n\t\tif (hci_dev_test_flag(hdev, HCI_SSP_ENABLED)) {\n\t\t\terr = read_local_ssp_oob_req(hdev, sk, cp);\n\t\t\thci_dev_unlock(hdev);\n\t\t\tif (!err)\n\t\t\t\tgoto done;\n\n\t\t\tstatus = MGMT_STATUS_FAILED;\n\t\t\tgoto complete;\n\t\t} else {\n\t\t\teir_len = eir_append_data(rp->eir, eir_len,\n\t\t\t\t\t\t  EIR_CLASS_OF_DEV,\n\t\t\t\t\t\t  hdev->dev_class, 3);\n\t\t}\n\t\tbreak;\n\tcase (BIT(BDADDR_LE_PUBLIC) | BIT(BDADDR_LE_RANDOM)):\n\t\tif (hci_dev_test_flag(hdev, HCI_SC_ENABLED) &&\n\t\t    smp_generate_oob(hdev, hash, rand) < 0) {\n\t\t\thci_dev_unlock(hdev);\n\t\t\tstatus = MGMT_STATUS_FAILED;\n\t\t\tgoto complete;\n\t\t}\n\n\t\t/* This should return the active RPA, but since the RPA\n\t\t * is only programmed on demand, it is really hard to fill\n\t\t * this in at the moment. For now disallow retrieving\n\t\t * local out-of-band data when privacy is in use.\n\t\t *\n\t\t * Returning the identity address will not help here since\n\t\t * pairing happens before the identity resolving key is\n\t\t * known and thus the connection establishment happens\n\t\t * based on the RPA and not the identity address.\n\t\t */\n\t\tif (hci_dev_test_flag(hdev, HCI_PRIVACY)) {\n\t\t\thci_dev_unlock(hdev);\n\t\t\tstatus = MGMT_STATUS_REJECTED;\n\t\t\tgoto complete;\n\t\t}\n\n\t\tif (hci_dev_test_flag(hdev, HCI_FORCE_STATIC_ADDR) ||\n\t\t   !bacmp(&hdev->bdaddr, BDADDR_ANY) ||\n\t\t   (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) &&\n\t\t    bacmp(&hdev->static_addr, BDADDR_ANY))) {\n\t\t\tmemcpy(addr, &hdev->static_addr, 6);\n\t\t\taddr[6] = 0x01;\n\t\t} else {\n\t\t\tmemcpy(addr, &hdev->bdaddr, 6);\n\t\t\taddr[6] = 0x00;\n\t\t}\n\n\t\teir_len = eir_append_data(rp->eir, eir_len, EIR_LE_BDADDR,\n\t\t\t\t\t  addr, sizeof(addr));\n\n\t\tif (hci_dev_test_flag(hdev, HCI_ADVERTISING))\n\t\t\trole = 0x02;\n\t\telse\n\t\t\trole = 0x01;\n\n\t\teir_len = eir_append_data(rp->eir, eir_len, EIR_LE_ROLE,\n\t\t\t\t\t  &role, sizeof(role));\n\n\t\tif (hci_dev_test_flag(hdev, HCI_SC_ENABLED)) {\n\t\t\teir_len = eir_append_data(rp->eir, eir_len,\n\t\t\t\t\t\t  EIR_LE_SC_CONFIRM,\n\t\t\t\t\t\t  hash, sizeof(hash));\n\n\t\t\teir_len = eir_append_data(rp->eir, eir_len,\n\t\t\t\t\t\t  EIR_LE_SC_RANDOM,\n\t\t\t\t\t\t  rand, sizeof(rand));\n\t\t}\n\n\t\tflags = mgmt_get_adv_discov_flags(hdev);\n\n\t\tif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\n\t\t\tflags |= LE_AD_NO_BREDR;\n\n\t\teir_len = eir_append_data(rp->eir, eir_len, EIR_FLAGS,\n\t\t\t\t\t  &flags, sizeof(flags));\n\t\tbreak;\n\t}\n\n\thci_dev_unlock(hdev);\n\n\thci_sock_set_flag(sk, HCI_MGMT_OOB_DATA_EVENTS);\n\n\tstatus = MGMT_STATUS_SUCCESS;\n\ncomplete:\n\trp->type = cp->type;\n\trp->eir_len = cpu_to_le16(eir_len);\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_EXT_DATA,\n\t\t\t\tstatus, rp, sizeof(*rp) + eir_len);\n\tif (err < 0 || status)\n\t\tgoto done;\n\n\terr = mgmt_limited_event(MGMT_EV_LOCAL_OOB_DATA_UPDATED, hdev,\n\t\t\t\t rp, sizeof(*rp) + eir_len,\n\t\t\t\t HCI_MGMT_OOB_DATA_EVENTS, sk);\n\ndone:\n\tkfree(rp);\n\n\treturn err;\n}\n\nstatic u32 get_supported_adv_flags(struct hci_dev *hdev)\n{\n\tu32 flags = 0;\n\n\tflags |= MGMT_ADV_FLAG_CONNECTABLE;\n\tflags |= MGMT_ADV_FLAG_DISCOV;\n\tflags |= MGMT_ADV_FLAG_LIMITED_DISCOV;\n\tflags |= MGMT_ADV_FLAG_MANAGED_FLAGS;\n\tflags |= MGMT_ADV_FLAG_APPEARANCE;\n\tflags |= MGMT_ADV_FLAG_LOCAL_NAME;\n\tflags |= MGMT_ADV_PARAM_DURATION;\n\tflags |= MGMT_ADV_PARAM_TIMEOUT;\n\tflags |= MGMT_ADV_PARAM_INTERVALS;\n\tflags |= MGMT_ADV_PARAM_TX_POWER;\n\n\t/* In extended adv TX_POWER returned from Set Adv Param\n\t * will be always valid.\n\t */\n\tif ((hdev->adv_tx_power != HCI_TX_POWER_INVALID) ||\n\t    ext_adv_capable(hdev))\n\t\tflags |= MGMT_ADV_FLAG_TX_POWER;\n\n\tif (ext_adv_capable(hdev)) {\n\t\tflags |= MGMT_ADV_FLAG_SEC_1M;\n\t\tflags |= MGMT_ADV_FLAG_HW_OFFLOAD;\n\t\tflags |= MGMT_ADV_FLAG_CAN_SET_TX_POWER;\n\n\t\tif (hdev->le_features[1] & HCI_LE_PHY_2M)\n\t\t\tflags |= MGMT_ADV_FLAG_SEC_2M;\n\n\t\tif (hdev->le_features[1] & HCI_LE_PHY_CODED)\n\t\t\tflags |= MGMT_ADV_FLAG_SEC_CODED;\n\t}\n\n\treturn flags;\n}\n\nstatic int read_adv_features(struct sock *sk, struct hci_dev *hdev,\n\t\t\t     void *data, u16 data_len)\n{\n\tstruct mgmt_rp_read_adv_features *rp;\n\tsize_t rp_len;\n\tint err;\n\tstruct adv_info *adv_instance;\n\tu32 supported_flags;\n\tu8 *instance;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_ADV_FEATURES,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\t/* Enabling the experimental LL Privay support disables support for\n\t * advertising.\n\t */\n\tif (hci_dev_test_flag(hdev, HCI_ENABLE_LL_PRIVACY))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_ADVERTISING,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\thci_dev_lock(hdev);\n\n\trp_len = sizeof(*rp) + hdev->adv_instance_cnt;\n\trp = kmalloc(rp_len, GFP_ATOMIC);\n\tif (!rp) {\n\t\thci_dev_unlock(hdev);\n\t\treturn -ENOMEM;\n\t}\n\n\tsupported_flags = get_supported_adv_flags(hdev);\n\n\trp->supported_flags = cpu_to_le32(supported_flags);\n\trp->max_adv_data_len = HCI_MAX_AD_LENGTH;\n\trp->max_scan_rsp_len = HCI_MAX_AD_LENGTH;\n\trp->max_instances = hdev->le_num_of_adv_sets;\n\trp->num_instances = hdev->adv_instance_cnt;\n\n\tinstance = rp->instance;\n\tlist_for_each_entry(adv_instance, &hdev->adv_instances, list) {\n\t\t*instance = adv_instance->instance;\n\t\tinstance++;\n\t}\n\n\thci_dev_unlock(hdev);\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_ADV_FEATURES,\n\t\t\t\tMGMT_STATUS_SUCCESS, rp, rp_len);\n\n\tkfree(rp);\n\n\treturn err;\n}\n\nstatic u8 calculate_name_len(struct hci_dev *hdev)\n{\n\tu8 buf[HCI_MAX_SHORT_NAME_LENGTH + 3];\n\n\treturn append_local_name(hdev, buf, 0);\n}\n\nstatic u8 tlv_data_max_len(struct hci_dev *hdev, u32 adv_flags,\n\t\t\t   bool is_adv_data)\n{\n\tu8 max_len = HCI_MAX_AD_LENGTH;\n\n\tif (is_adv_data) {\n\t\tif (adv_flags & (MGMT_ADV_FLAG_DISCOV |\n\t\t\t\t MGMT_ADV_FLAG_LIMITED_DISCOV |\n\t\t\t\t MGMT_ADV_FLAG_MANAGED_FLAGS))\n\t\t\tmax_len -= 3;\n\n\t\tif (adv_flags & MGMT_ADV_FLAG_TX_POWER)\n\t\t\tmax_len -= 3;\n\t} else {\n\t\tif (adv_flags & MGMT_ADV_FLAG_LOCAL_NAME)\n\t\t\tmax_len -= calculate_name_len(hdev);\n\n\t\tif (adv_flags & (MGMT_ADV_FLAG_APPEARANCE))\n\t\t\tmax_len -= 4;\n\t}\n\n\treturn max_len;\n}\n\nstatic bool flags_managed(u32 adv_flags)\n{\n\treturn adv_flags & (MGMT_ADV_FLAG_DISCOV |\n\t\t\t    MGMT_ADV_FLAG_LIMITED_DISCOV |\n\t\t\t    MGMT_ADV_FLAG_MANAGED_FLAGS);\n}\n\nstatic bool tx_power_managed(u32 adv_flags)\n{\n\treturn adv_flags & MGMT_ADV_FLAG_TX_POWER;\n}\n\nstatic bool name_managed(u32 adv_flags)\n{\n\treturn adv_flags & MGMT_ADV_FLAG_LOCAL_NAME;\n}\n\nstatic bool appearance_managed(u32 adv_flags)\n{\n\treturn adv_flags & MGMT_ADV_FLAG_APPEARANCE;\n}\n\nstatic bool tlv_data_is_valid(struct hci_dev *hdev, u32 adv_flags, u8 *data,\n\t\t\t      u8 len, bool is_adv_data)\n{\n\tint i, cur_len;\n\tu8 max_len;\n\n\tmax_len = tlv_data_max_len(hdev, adv_flags, is_adv_data);\n\n\tif (len > max_len)\n\t\treturn false;\n\n\t/* Make sure that the data is correctly formatted. */\n\tfor (i = 0, cur_len = 0; i < len; i += (cur_len + 1)) {\n\t\tcur_len = data[i];\n\n\t\tif (data[i + 1] == EIR_FLAGS &&\n\t\t    (!is_adv_data || flags_managed(adv_flags)))\n\t\t\treturn false;\n\n\t\tif (data[i + 1] == EIR_TX_POWER && tx_power_managed(adv_flags))\n\t\t\treturn false;\n\n\t\tif (data[i + 1] == EIR_NAME_COMPLETE && name_managed(adv_flags))\n\t\t\treturn false;\n\n\t\tif (data[i + 1] == EIR_NAME_SHORT && name_managed(adv_flags))\n\t\t\treturn false;\n\n\t\tif (data[i + 1] == EIR_APPEARANCE &&\n\t\t    appearance_managed(adv_flags))\n\t\t\treturn false;\n\n\t\t/* If the current field length would exceed the total data\n\t\t * length, then it's invalid.\n\t\t */\n\t\tif (i + cur_len >= len)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool requested_adv_flags_are_valid(struct hci_dev *hdev, u32 adv_flags)\n{\n\tu32 supported_flags, phy_flags;\n\n\t/* The current implementation only supports a subset of the specified\n\t * flags. Also need to check mutual exclusiveness of sec flags.\n\t */\n\tsupported_flags = get_supported_adv_flags(hdev);\n\tphy_flags = adv_flags & MGMT_ADV_FLAG_SEC_MASK;\n\tif (adv_flags & ~supported_flags ||\n\t    ((phy_flags && (phy_flags ^ (phy_flags & -phy_flags)))))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool adv_busy(struct hci_dev *hdev)\n{\n\treturn (pending_find(MGMT_OP_ADD_ADVERTISING, hdev) ||\n\t\tpending_find(MGMT_OP_REMOVE_ADVERTISING, hdev) ||\n\t\tpending_find(MGMT_OP_SET_LE, hdev) ||\n\t\tpending_find(MGMT_OP_ADD_EXT_ADV_PARAMS, hdev) ||\n\t\tpending_find(MGMT_OP_ADD_EXT_ADV_DATA, hdev));\n}\n\nstatic void add_advertising_complete(struct hci_dev *hdev, u8 status,\n\t\t\t\t     u16 opcode)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct mgmt_cp_add_advertising *cp;\n\tstruct mgmt_rp_add_advertising rp;\n\tstruct adv_info *adv_instance, *n;\n\tu8 instance;\n\n\tbt_dev_dbg(hdev, \"status %d\", status);\n\n\thci_dev_lock(hdev);\n\n\tcmd = pending_find(MGMT_OP_ADD_ADVERTISING, hdev);\n\tif (!cmd)\n\t\tcmd = pending_find(MGMT_OP_ADD_EXT_ADV_DATA, hdev);\n\n\tlist_for_each_entry_safe(adv_instance, n, &hdev->adv_instances, list) {\n\t\tif (!adv_instance->pending)\n\t\t\tcontinue;\n\n\t\tif (!status) {\n\t\t\tadv_instance->pending = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinstance = adv_instance->instance;\n\n\t\tif (hdev->cur_adv_instance == instance)\n\t\t\tcancel_adv_timeout(hdev);\n\n\t\thci_remove_adv_instance(hdev, instance);\n\t\tmgmt_advertising_removed(cmd ? cmd->sk : NULL, hdev, instance);\n\t}\n\n\tif (!cmd)\n\t\tgoto unlock;\n\n\tcp = cmd->param;\n\trp.instance = cp->instance;\n\n\tif (status)\n\t\tmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode,\n\t\t\t\tmgmt_status(status));\n\telse\n\t\tmgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode,\n\t\t\t\t  mgmt_status(status), &rp, sizeof(rp));\n\n\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic int add_advertising(struct sock *sk, struct hci_dev *hdev,\n\t\t\t   void *data, u16 data_len)\n{\n\tstruct mgmt_cp_add_advertising *cp = data;\n\tstruct mgmt_rp_add_advertising rp;\n\tu32 flags;\n\tu8 status;\n\tu16 timeout, duration;\n\tunsigned int prev_instance_cnt = hdev->adv_instance_cnt;\n\tu8 schedule_instance = 0;\n\tstruct adv_info *next_instance;\n\tint err;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_request req;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tstatus = mgmt_le_support(hdev);\n\tif (status)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t       status);\n\n\t/* Enabling the experimental LL Privay support disables support for\n\t * advertising.\n\t */\n\tif (hci_dev_test_flag(hdev, HCI_ENABLE_LL_PRIVACY))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_ADVERTISING,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\tif (cp->instance < 1 || cp->instance > hdev->le_num_of_adv_sets)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tif (data_len != sizeof(*cp) + cp->adv_data_len + cp->scan_rsp_len)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tflags = __le32_to_cpu(cp->flags);\n\ttimeout = __le16_to_cpu(cp->timeout);\n\tduration = __le16_to_cpu(cp->duration);\n\n\tif (!requested_adv_flags_are_valid(hdev, flags))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\tif (timeout && !hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t      MGMT_STATUS_REJECTED);\n\t\tgoto unlock;\n\t}\n\n\tif (adv_busy(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tif (!tlv_data_is_valid(hdev, flags, cp->data, cp->adv_data_len, true) ||\n\t    !tlv_data_is_valid(hdev, flags, cp->data + cp->adv_data_len,\n\t\t\t       cp->scan_rsp_len, false)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto unlock;\n\t}\n\n\terr = hci_add_adv_instance(hdev, cp->instance, flags,\n\t\t\t\t   cp->adv_data_len, cp->data,\n\t\t\t\t   cp->scan_rsp_len,\n\t\t\t\t   cp->data + cp->adv_data_len,\n\t\t\t\t   timeout, duration,\n\t\t\t\t   HCI_ADV_TX_POWER_NO_PREFERENCE,\n\t\t\t\t   hdev->le_adv_min_interval,\n\t\t\t\t   hdev->le_adv_max_interval);\n\tif (err < 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t      MGMT_STATUS_FAILED);\n\t\tgoto unlock;\n\t}\n\n\t/* Only trigger an advertising added event if a new instance was\n\t * actually added.\n\t */\n\tif (hdev->adv_instance_cnt > prev_instance_cnt)\n\t\tmgmt_advertising_added(sk, hdev, cp->instance);\n\n\tif (hdev->cur_adv_instance == cp->instance) {\n\t\t/* If the currently advertised instance is being changed then\n\t\t * cancel the current advertising and schedule the next\n\t\t * instance. If there is only one instance then the overridden\n\t\t * advertising data will be visible right away.\n\t\t */\n\t\tcancel_adv_timeout(hdev);\n\n\t\tnext_instance = hci_get_next_instance(hdev, cp->instance);\n\t\tif (next_instance)\n\t\t\tschedule_instance = next_instance->instance;\n\t} else if (!hdev->adv_instance_timeout) {\n\t\t/* Immediately advertise the new instance if no other\n\t\t * instance is currently being advertised.\n\t\t */\n\t\tschedule_instance = cp->instance;\n\t}\n\n\t/* If the HCI_ADVERTISING flag is set or the device isn't powered or\n\t * there is no instance to be advertised then we have no HCI\n\t * communication to make. Simply return.\n\t */\n\tif (!hdev_is_powered(hdev) ||\n\t    hci_dev_test_flag(hdev, HCI_ADVERTISING) ||\n\t    !schedule_instance) {\n\t\trp.instance = cp->instance;\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t\tMGMT_STATUS_SUCCESS, &rp, sizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\t/* We're good to go, update advertising data, parameters, and start\n\t * advertising.\n\t */\n\tcmd = mgmt_pending_add(sk, MGMT_OP_ADD_ADVERTISING, hdev, data,\n\t\t\t       data_len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\thci_req_init(&req, hdev);\n\n\terr = __hci_req_schedule_adv_instance(&req, schedule_instance, true);\n\n\tif (!err)\n\t\terr = hci_req_run(&req, add_advertising_complete);\n\n\tif (err < 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t      MGMT_STATUS_FAILED);\n\t\tmgmt_pending_remove(cmd);\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic void add_ext_adv_params_complete(struct hci_dev *hdev, u8 status,\n\t\t\t\t\tu16 opcode)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct mgmt_cp_add_ext_adv_params *cp;\n\tstruct mgmt_rp_add_ext_adv_params rp;\n\tstruct adv_info *adv_instance;\n\tu32 flags;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\thci_dev_lock(hdev);\n\n\tcmd = pending_find(MGMT_OP_ADD_EXT_ADV_PARAMS, hdev);\n\tif (!cmd)\n\t\tgoto unlock;\n\n\tcp = cmd->param;\n\tadv_instance = hci_find_adv_instance(hdev, cp->instance);\n\tif (!adv_instance)\n\t\tgoto unlock;\n\n\trp.instance = cp->instance;\n\trp.tx_power = adv_instance->tx_power;\n\n\t/* While we're at it, inform userspace of the available space for this\n\t * advertisement, given the flags that will be used.\n\t */\n\tflags = __le32_to_cpu(cp->flags);\n\trp.max_adv_data_len = tlv_data_max_len(hdev, flags, true);\n\trp.max_scan_rsp_len = tlv_data_max_len(hdev, flags, false);\n\n\tif (status) {\n\t\t/* If this advertisement was previously advertising and we\n\t\t * failed to update it, we signal that it has been removed and\n\t\t * delete its structure\n\t\t */\n\t\tif (!adv_instance->pending)\n\t\t\tmgmt_advertising_removed(cmd->sk, hdev, cp->instance);\n\n\t\thci_remove_adv_instance(hdev, cp->instance);\n\n\t\tmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode,\n\t\t\t\tmgmt_status(status));\n\n\t} else {\n\t\tmgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode,\n\t\t\t\t  mgmt_status(status), &rp, sizeof(rp));\n\t}\n\nunlock:\n\tif (cmd)\n\t\tmgmt_pending_remove(cmd);\n\n\thci_dev_unlock(hdev);\n}\n\nstatic int add_ext_adv_params(struct sock *sk, struct hci_dev *hdev,\n\t\t\t      void *data, u16 data_len)\n{\n\tstruct mgmt_cp_add_ext_adv_params *cp = data;\n\tstruct mgmt_rp_add_ext_adv_params rp;\n\tstruct mgmt_pending_cmd *cmd = NULL;\n\tstruct adv_info *adv_instance;\n\tstruct hci_request req;\n\tu32 flags, min_interval, max_interval;\n\tu16 timeout, duration;\n\tu8 status;\n\ts8 tx_power;\n\tint err;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tstatus = mgmt_le_support(hdev);\n\tif (status)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_PARAMS,\n\t\t\t\t       status);\n\n\tif (cp->instance < 1 || cp->instance > hdev->le_num_of_adv_sets)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_PARAMS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\t/* The purpose of breaking add_advertising into two separate MGMT calls\n\t * for params and data is to allow more parameters to be added to this\n\t * structure in the future. For this reason, we verify that we have the\n\t * bare minimum structure we know of when the interface was defined. Any\n\t * extra parameters we don't know about will be ignored in this request.\n\t */\n\tif (data_len < MGMT_ADD_EXT_ADV_PARAMS_MIN_SIZE)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tflags = __le32_to_cpu(cp->flags);\n\n\tif (!requested_adv_flags_are_valid(hdev, flags))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_PARAMS,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\thci_dev_lock(hdev);\n\n\t/* In new interface, we require that we are powered to register */\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_PARAMS,\n\t\t\t\t      MGMT_STATUS_REJECTED);\n\t\tgoto unlock;\n\t}\n\n\tif (adv_busy(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_PARAMS,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\t/* Parse defined parameters from request, use defaults otherwise */\n\ttimeout = (flags & MGMT_ADV_PARAM_TIMEOUT) ?\n\t\t  __le16_to_cpu(cp->timeout) : 0;\n\n\tduration = (flags & MGMT_ADV_PARAM_DURATION) ?\n\t\t   __le16_to_cpu(cp->duration) :\n\t\t   hdev->def_multi_adv_rotation_duration;\n\n\tmin_interval = (flags & MGMT_ADV_PARAM_INTERVALS) ?\n\t\t       __le32_to_cpu(cp->min_interval) :\n\t\t       hdev->le_adv_min_interval;\n\n\tmax_interval = (flags & MGMT_ADV_PARAM_INTERVALS) ?\n\t\t       __le32_to_cpu(cp->max_interval) :\n\t\t       hdev->le_adv_max_interval;\n\n\ttx_power = (flags & MGMT_ADV_PARAM_TX_POWER) ?\n\t\t   cp->tx_power :\n\t\t   HCI_ADV_TX_POWER_NO_PREFERENCE;\n\n\t/* Create advertising instance with no advertising or response data */\n\terr = hci_add_adv_instance(hdev, cp->instance, flags,\n\t\t\t\t   0, NULL, 0, NULL, timeout, duration,\n\t\t\t\t   tx_power, min_interval, max_interval);\n\n\tif (err < 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_PARAMS,\n\t\t\t\t      MGMT_STATUS_FAILED);\n\t\tgoto unlock;\n\t}\n\n\thdev->cur_adv_instance = cp->instance;\n\t/* Submit request for advertising params if ext adv available */\n\tif (ext_adv_capable(hdev)) {\n\t\thci_req_init(&req, hdev);\n\t\tadv_instance = hci_find_adv_instance(hdev, cp->instance);\n\n\t\t/* Updating parameters of an active instance will return a\n\t\t * Command Disallowed error, so we must first disable the\n\t\t * instance if it is active.\n\t\t */\n\t\tif (!adv_instance->pending)\n\t\t\t__hci_req_disable_ext_adv_instance(&req, cp->instance);\n\n\t\t__hci_req_setup_ext_adv_instance(&req, cp->instance);\n\n\t\terr = hci_req_run(&req, add_ext_adv_params_complete);\n\n\t\tif (!err)\n\t\t\tcmd = mgmt_pending_add(sk, MGMT_OP_ADD_EXT_ADV_PARAMS,\n\t\t\t\t\t       hdev, data, data_len);\n\t\tif (!cmd) {\n\t\t\terr = -ENOMEM;\n\t\t\thci_remove_adv_instance(hdev, cp->instance);\n\t\t\tgoto unlock;\n\t\t}\n\n\t} else {\n\t\trp.instance = cp->instance;\n\t\trp.tx_power = HCI_ADV_TX_POWER_NO_PREFERENCE;\n\t\trp.max_adv_data_len = tlv_data_max_len(hdev, flags, true);\n\t\trp.max_scan_rsp_len = tlv_data_max_len(hdev, flags, false);\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_ADD_EXT_ADV_PARAMS,\n\t\t\t\t\tMGMT_STATUS_SUCCESS, &rp, sizeof(rp));\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic int add_ext_adv_data(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t\t    u16 data_len)\n{\n\tstruct mgmt_cp_add_ext_adv_data *cp = data;\n\tstruct mgmt_rp_add_ext_adv_data rp;\n\tu8 schedule_instance = 0;\n\tstruct adv_info *next_instance;\n\tstruct adv_info *adv_instance;\n\tint err = 0;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_request req;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\thci_dev_lock(hdev);\n\n\tadv_instance = hci_find_adv_instance(hdev, cp->instance);\n\n\tif (!adv_instance) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_DATA,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto unlock;\n\t}\n\n\t/* In new interface, we require that we are powered to register */\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_DATA,\n\t\t\t\t      MGMT_STATUS_REJECTED);\n\t\tgoto clear_new_instance;\n\t}\n\n\tif (adv_busy(hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_DATA,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto clear_new_instance;\n\t}\n\n\t/* Validate new data */\n\tif (!tlv_data_is_valid(hdev, adv_instance->flags, cp->data,\n\t\t\t       cp->adv_data_len, true) ||\n\t    !tlv_data_is_valid(hdev, adv_instance->flags, cp->data +\n\t\t\t       cp->adv_data_len, cp->scan_rsp_len, false)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_DATA,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto clear_new_instance;\n\t}\n\n\t/* Set the data in the advertising instance */\n\thci_set_adv_instance_data(hdev, cp->instance, cp->adv_data_len,\n\t\t\t\t  cp->data, cp->scan_rsp_len,\n\t\t\t\t  cp->data + cp->adv_data_len);\n\n\t/* We're good to go, update advertising data, parameters, and start\n\t * advertising.\n\t */\n\n\thci_req_init(&req, hdev);\n\n\thci_req_add(&req, HCI_OP_READ_LOCAL_NAME, 0, NULL);\n\n\tif (ext_adv_capable(hdev)) {\n\t\t__hci_req_update_adv_data(&req, cp->instance);\n\t\t__hci_req_update_scan_rsp_data(&req, cp->instance);\n\t\t__hci_req_enable_ext_advertising(&req, cp->instance);\n\n\t} else {\n\t\t/* If using software rotation, determine next instance to use */\n\n\t\tif (hdev->cur_adv_instance == cp->instance) {\n\t\t\t/* If the currently advertised instance is being changed\n\t\t\t * then cancel the current advertising and schedule the\n\t\t\t * next instance. If there is only one instance then the\n\t\t\t * overridden advertising data will be visible right\n\t\t\t * away\n\t\t\t */\n\t\t\tcancel_adv_timeout(hdev);\n\n\t\t\tnext_instance = hci_get_next_instance(hdev,\n\t\t\t\t\t\t\t      cp->instance);\n\t\t\tif (next_instance)\n\t\t\t\tschedule_instance = next_instance->instance;\n\t\t} else if (!hdev->adv_instance_timeout) {\n\t\t\t/* Immediately advertise the new instance if no other\n\t\t\t * instance is currently being advertised.\n\t\t\t */\n\t\t\tschedule_instance = cp->instance;\n\t\t}\n\n\t\t/* If the HCI_ADVERTISING flag is set or there is no instance to\n\t\t * be advertised then we have no HCI communication to make.\n\t\t * Simply return.\n\t\t */\n\t\tif (hci_dev_test_flag(hdev, HCI_ADVERTISING) ||\n\t\t    !schedule_instance) {\n\t\t\tif (adv_instance->pending) {\n\t\t\t\tmgmt_advertising_added(sk, hdev, cp->instance);\n\t\t\t\tadv_instance->pending = false;\n\t\t\t}\n\t\t\trp.instance = cp->instance;\n\t\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\t\tMGMT_OP_ADD_EXT_ADV_DATA,\n\t\t\t\t\t\tMGMT_STATUS_SUCCESS, &rp,\n\t\t\t\t\t\tsizeof(rp));\n\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = __hci_req_schedule_adv_instance(&req, schedule_instance,\n\t\t\t\t\t\t      true);\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_ADD_EXT_ADV_DATA, hdev, data,\n\t\t\t       data_len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto clear_new_instance;\n\t}\n\n\tif (!err)\n\t\terr = hci_req_run(&req, add_advertising_complete);\n\n\tif (err < 0) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_EXT_ADV_DATA,\n\t\t\t\t      MGMT_STATUS_FAILED);\n\t\tmgmt_pending_remove(cmd);\n\t\tgoto clear_new_instance;\n\t}\n\n\t/* We were successful in updating data, so trigger advertising_added\n\t * event if this is an instance that wasn't previously advertising. If\n\t * a failure occurs in the requests we initiated, we will remove the\n\t * instance again in add_advertising_complete\n\t */\n\tif (adv_instance->pending)\n\t\tmgmt_advertising_added(sk, hdev, cp->instance);\n\n\tgoto unlock;\n\nclear_new_instance:\n\thci_remove_adv_instance(hdev, cp->instance);\n\nunlock:\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic void remove_advertising_complete(struct hci_dev *hdev, u8 status,\n\t\t\t\t\tu16 opcode)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct mgmt_cp_remove_advertising *cp;\n\tstruct mgmt_rp_remove_advertising rp;\n\n\tbt_dev_dbg(hdev, \"status %d\", status);\n\n\thci_dev_lock(hdev);\n\n\t/* A failure status here only means that we failed to disable\n\t * advertising. Otherwise, the advertising instance has been removed,\n\t * so report success.\n\t */\n\tcmd = pending_find(MGMT_OP_REMOVE_ADVERTISING, hdev);\n\tif (!cmd)\n\t\tgoto unlock;\n\n\tcp = cmd->param;\n\trp.instance = cp->instance;\n\n\tmgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode, MGMT_STATUS_SUCCESS,\n\t\t\t  &rp, sizeof(rp));\n\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n}\n\nstatic int remove_advertising(struct sock *sk, struct hci_dev *hdev,\n\t\t\t      void *data, u16 data_len)\n{\n\tstruct mgmt_cp_remove_advertising *cp = data;\n\tstruct mgmt_rp_remove_advertising rp;\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct hci_request req;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\t/* Enabling the experimental LL Privay support disables support for\n\t * advertising.\n\t */\n\tif (hci_dev_test_flag(hdev, HCI_ENABLE_LL_PRIVACY))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_ADVERTISING,\n\t\t\t\t       MGMT_STATUS_NOT_SUPPORTED);\n\n\thci_dev_lock(hdev);\n\n\tif (cp->instance && !hci_find_adv_instance(hdev, cp->instance)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id,\n\t\t\t\t      MGMT_OP_REMOVE_ADVERTISING,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto unlock;\n\t}\n\n\tif (pending_find(MGMT_OP_ADD_ADVERTISING, hdev) ||\n\t    pending_find(MGMT_OP_REMOVE_ADVERTISING, hdev) ||\n\t    pending_find(MGMT_OP_SET_LE, hdev)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_ADVERTISING,\n\t\t\t\t      MGMT_STATUS_BUSY);\n\t\tgoto unlock;\n\t}\n\n\tif (list_empty(&hdev->adv_instances)) {\n\t\terr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_ADVERTISING,\n\t\t\t\t      MGMT_STATUS_INVALID_PARAMS);\n\t\tgoto unlock;\n\t}\n\n\thci_req_init(&req, hdev);\n\n\t/* If we use extended advertising, instance is disabled and removed */\n\tif (ext_adv_capable(hdev)) {\n\t\t__hci_req_disable_ext_adv_instance(&req, cp->instance);\n\t\t__hci_req_remove_ext_adv_instance(&req, cp->instance);\n\t}\n\n\thci_req_clear_adv_instance(hdev, sk, &req, cp->instance, true);\n\n\tif (list_empty(&hdev->adv_instances))\n\t\t__hci_req_disable_advertising(&req);\n\n\t/* If no HCI commands have been collected so far or the HCI_ADVERTISING\n\t * flag is set or the device isn't powered then we have no HCI\n\t * communication to make. Simply return.\n\t */\n\tif (skb_queue_empty(&req.cmd_q) ||\n\t    !hdev_is_powered(hdev) ||\n\t    hci_dev_test_flag(hdev, HCI_ADVERTISING)) {\n\t\thci_req_purge(&req);\n\t\trp.instance = cp->instance;\n\t\terr = mgmt_cmd_complete(sk, hdev->id,\n\t\t\t\t\tMGMT_OP_REMOVE_ADVERTISING,\n\t\t\t\t\tMGMT_STATUS_SUCCESS, &rp, sizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_REMOVE_ADVERTISING, hdev, data,\n\t\t\t       data_len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\terr = hci_req_run(&req, remove_advertising_complete);\n\tif (err < 0)\n\t\tmgmt_pending_remove(cmd);\n\nunlock:\n\thci_dev_unlock(hdev);\n\n\treturn err;\n}\n\nstatic int get_adv_size_info(struct sock *sk, struct hci_dev *hdev,\n\t\t\t     void *data, u16 data_len)\n{\n\tstruct mgmt_cp_get_adv_size_info *cp = data;\n\tstruct mgmt_rp_get_adv_size_info rp;\n\tu32 flags, supported_flags;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tif (!lmp_le_capable(hdev))\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,\n\t\t\t\t       MGMT_STATUS_REJECTED);\n\n\tif (cp->instance < 1 || cp->instance > hdev->le_num_of_adv_sets)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\tflags = __le32_to_cpu(cp->flags);\n\n\t/* The current implementation only supports a subset of the specified\n\t * flags.\n\t */\n\tsupported_flags = get_supported_adv_flags(hdev);\n\tif (flags & ~supported_flags)\n\t\treturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,\n\t\t\t\t       MGMT_STATUS_INVALID_PARAMS);\n\n\trp.instance = cp->instance;\n\trp.flags = cp->flags;\n\trp.max_adv_data_len = tlv_data_max_len(hdev, flags, true);\n\trp.max_scan_rsp_len = tlv_data_max_len(hdev, flags, false);\n\n\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,\n\t\t\t\tMGMT_STATUS_SUCCESS, &rp, sizeof(rp));\n\n\treturn err;\n}\n\nstatic const struct hci_mgmt_handler mgmt_handlers[] = {\n\t{ NULL }, /* 0x0000 (no command) */\n\t{ read_version,            MGMT_READ_VERSION_SIZE,\n\t\t\t\t\t\tHCI_MGMT_NO_HDEV |\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ read_commands,           MGMT_READ_COMMANDS_SIZE,\n\t\t\t\t\t\tHCI_MGMT_NO_HDEV |\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ read_index_list,         MGMT_READ_INDEX_LIST_SIZE,\n\t\t\t\t\t\tHCI_MGMT_NO_HDEV |\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ read_controller_info,    MGMT_READ_INFO_SIZE,\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ set_powered,             MGMT_SETTING_SIZE },\n\t{ set_discoverable,        MGMT_SET_DISCOVERABLE_SIZE },\n\t{ set_connectable,         MGMT_SETTING_SIZE },\n\t{ set_fast_connectable,    MGMT_SETTING_SIZE },\n\t{ set_bondable,            MGMT_SETTING_SIZE },\n\t{ set_link_security,       MGMT_SETTING_SIZE },\n\t{ set_ssp,                 MGMT_SETTING_SIZE },\n\t{ set_hs,                  MGMT_SETTING_SIZE },\n\t{ set_le,                  MGMT_SETTING_SIZE },\n\t{ set_dev_class,           MGMT_SET_DEV_CLASS_SIZE },\n\t{ set_local_name,          MGMT_SET_LOCAL_NAME_SIZE },\n\t{ add_uuid,                MGMT_ADD_UUID_SIZE },\n\t{ remove_uuid,             MGMT_REMOVE_UUID_SIZE },\n\t{ load_link_keys,          MGMT_LOAD_LINK_KEYS_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ load_long_term_keys,     MGMT_LOAD_LONG_TERM_KEYS_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ disconnect,              MGMT_DISCONNECT_SIZE },\n\t{ get_connections,         MGMT_GET_CONNECTIONS_SIZE },\n\t{ pin_code_reply,          MGMT_PIN_CODE_REPLY_SIZE },\n\t{ pin_code_neg_reply,      MGMT_PIN_CODE_NEG_REPLY_SIZE },\n\t{ set_io_capability,       MGMT_SET_IO_CAPABILITY_SIZE },\n\t{ pair_device,             MGMT_PAIR_DEVICE_SIZE },\n\t{ cancel_pair_device,      MGMT_CANCEL_PAIR_DEVICE_SIZE },\n\t{ unpair_device,           MGMT_UNPAIR_DEVICE_SIZE },\n\t{ user_confirm_reply,      MGMT_USER_CONFIRM_REPLY_SIZE },\n\t{ user_confirm_neg_reply,  MGMT_USER_CONFIRM_NEG_REPLY_SIZE },\n\t{ user_passkey_reply,      MGMT_USER_PASSKEY_REPLY_SIZE },\n\t{ user_passkey_neg_reply,  MGMT_USER_PASSKEY_NEG_REPLY_SIZE },\n\t{ read_local_oob_data,     MGMT_READ_LOCAL_OOB_DATA_SIZE },\n\t{ add_remote_oob_data,     MGMT_ADD_REMOTE_OOB_DATA_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ remove_remote_oob_data,  MGMT_REMOVE_REMOTE_OOB_DATA_SIZE },\n\t{ start_discovery,         MGMT_START_DISCOVERY_SIZE },\n\t{ stop_discovery,          MGMT_STOP_DISCOVERY_SIZE },\n\t{ confirm_name,            MGMT_CONFIRM_NAME_SIZE },\n\t{ block_device,            MGMT_BLOCK_DEVICE_SIZE },\n\t{ unblock_device,          MGMT_UNBLOCK_DEVICE_SIZE },\n\t{ set_device_id,           MGMT_SET_DEVICE_ID_SIZE },\n\t{ set_advertising,         MGMT_SETTING_SIZE },\n\t{ set_bredr,               MGMT_SETTING_SIZE },\n\t{ set_static_address,      MGMT_SET_STATIC_ADDRESS_SIZE },\n\t{ set_scan_params,         MGMT_SET_SCAN_PARAMS_SIZE },\n\t{ set_secure_conn,         MGMT_SETTING_SIZE },\n\t{ set_debug_keys,          MGMT_SETTING_SIZE },\n\t{ set_privacy,             MGMT_SET_PRIVACY_SIZE },\n\t{ load_irks,               MGMT_LOAD_IRKS_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ get_conn_info,           MGMT_GET_CONN_INFO_SIZE },\n\t{ get_clock_info,          MGMT_GET_CLOCK_INFO_SIZE },\n\t{ add_device,              MGMT_ADD_DEVICE_SIZE },\n\t{ remove_device,           MGMT_REMOVE_DEVICE_SIZE },\n\t{ load_conn_param,         MGMT_LOAD_CONN_PARAM_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ read_unconf_index_list,  MGMT_READ_UNCONF_INDEX_LIST_SIZE,\n\t\t\t\t\t\tHCI_MGMT_NO_HDEV |\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ read_config_info,        MGMT_READ_CONFIG_INFO_SIZE,\n\t\t\t\t\t\tHCI_MGMT_UNCONFIGURED |\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ set_external_config,     MGMT_SET_EXTERNAL_CONFIG_SIZE,\n\t\t\t\t\t\tHCI_MGMT_UNCONFIGURED },\n\t{ set_public_address,      MGMT_SET_PUBLIC_ADDRESS_SIZE,\n\t\t\t\t\t\tHCI_MGMT_UNCONFIGURED },\n\t{ start_service_discovery, MGMT_START_SERVICE_DISCOVERY_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ read_local_oob_ext_data, MGMT_READ_LOCAL_OOB_EXT_DATA_SIZE },\n\t{ read_ext_index_list,     MGMT_READ_EXT_INDEX_LIST_SIZE,\n\t\t\t\t\t\tHCI_MGMT_NO_HDEV |\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ read_adv_features,       MGMT_READ_ADV_FEATURES_SIZE },\n\t{ add_advertising,\t   MGMT_ADD_ADVERTISING_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ remove_advertising,\t   MGMT_REMOVE_ADVERTISING_SIZE },\n\t{ get_adv_size_info,       MGMT_GET_ADV_SIZE_INFO_SIZE },\n\t{ start_limited_discovery, MGMT_START_DISCOVERY_SIZE },\n\t{ read_ext_controller_info,MGMT_READ_EXT_INFO_SIZE,\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ set_appearance,\t   MGMT_SET_APPEARANCE_SIZE },\n\t{ get_phy_configuration,   MGMT_GET_PHY_CONFIGURATION_SIZE },\n\t{ set_phy_configuration,   MGMT_SET_PHY_CONFIGURATION_SIZE },\n\t{ set_blocked_keys,\t   MGMT_OP_SET_BLOCKED_KEYS_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ set_wideband_speech,\t   MGMT_SETTING_SIZE },\n\t{ read_controller_cap,     MGMT_READ_CONTROLLER_CAP_SIZE,\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ read_exp_features_info,  MGMT_READ_EXP_FEATURES_INFO_SIZE,\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED |\n\t\t\t\t\t\tHCI_MGMT_HDEV_OPTIONAL },\n\t{ set_exp_feature,         MGMT_SET_EXP_FEATURE_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN |\n\t\t\t\t\t\tHCI_MGMT_HDEV_OPTIONAL },\n\t{ read_def_system_config,  MGMT_READ_DEF_SYSTEM_CONFIG_SIZE,\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ set_def_system_config,   MGMT_SET_DEF_SYSTEM_CONFIG_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ read_def_runtime_config, MGMT_READ_DEF_RUNTIME_CONFIG_SIZE,\n\t\t\t\t\t\tHCI_MGMT_UNTRUSTED },\n\t{ set_def_runtime_config,  MGMT_SET_DEF_RUNTIME_CONFIG_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ get_device_flags,        MGMT_GET_DEVICE_FLAGS_SIZE },\n\t{ set_device_flags,        MGMT_SET_DEVICE_FLAGS_SIZE },\n\t{ read_adv_mon_features,   MGMT_READ_ADV_MONITOR_FEATURES_SIZE },\n\t{ add_adv_patterns_monitor,MGMT_ADD_ADV_PATTERNS_MONITOR_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ remove_adv_monitor,      MGMT_REMOVE_ADV_MONITOR_SIZE },\n\t{ add_ext_adv_params,      MGMT_ADD_EXT_ADV_PARAMS_MIN_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n\t{ add_ext_adv_data,        MGMT_ADD_EXT_ADV_DATA_SIZE,\n\t\t\t\t\t\tHCI_MGMT_VAR_LEN },\n};\n\nvoid mgmt_index_added(struct hci_dev *hdev)\n{\n\tstruct mgmt_ev_ext_index ev;\n\n\tif (test_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks))\n\t\treturn;\n\n\tswitch (hdev->dev_type) {\n\tcase HCI_PRIMARY:\n\t\tif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED)) {\n\t\t\tmgmt_index_event(MGMT_EV_UNCONF_INDEX_ADDED, hdev,\n\t\t\t\t\t NULL, 0, HCI_MGMT_UNCONF_INDEX_EVENTS);\n\t\t\tev.type = 0x01;\n\t\t} else {\n\t\t\tmgmt_index_event(MGMT_EV_INDEX_ADDED, hdev, NULL, 0,\n\t\t\t\t\t HCI_MGMT_INDEX_EVENTS);\n\t\t\tev.type = 0x00;\n\t\t}\n\t\tbreak;\n\tcase HCI_AMP:\n\t\tev.type = 0x02;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tev.bus = hdev->bus;\n\n\tmgmt_index_event(MGMT_EV_EXT_INDEX_ADDED, hdev, &ev, sizeof(ev),\n\t\t\t HCI_MGMT_EXT_INDEX_EVENTS);\n}\n\nvoid mgmt_index_removed(struct hci_dev *hdev)\n{\n\tstruct mgmt_ev_ext_index ev;\n\tu8 status = MGMT_STATUS_INVALID_INDEX;\n\n\tif (test_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks))\n\t\treturn;\n\n\tswitch (hdev->dev_type) {\n\tcase HCI_PRIMARY:\n\t\tmgmt_pending_foreach(0, hdev, cmd_complete_rsp, &status);\n\n\t\tif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED)) {\n\t\t\tmgmt_index_event(MGMT_EV_UNCONF_INDEX_REMOVED, hdev,\n\t\t\t\t\t NULL, 0, HCI_MGMT_UNCONF_INDEX_EVENTS);\n\t\t\tev.type = 0x01;\n\t\t} else {\n\t\t\tmgmt_index_event(MGMT_EV_INDEX_REMOVED, hdev, NULL, 0,\n\t\t\t\t\t HCI_MGMT_INDEX_EVENTS);\n\t\t\tev.type = 0x00;\n\t\t}\n\t\tbreak;\n\tcase HCI_AMP:\n\t\tev.type = 0x02;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tev.bus = hdev->bus;\n\n\tmgmt_index_event(MGMT_EV_EXT_INDEX_REMOVED, hdev, &ev, sizeof(ev),\n\t\t\t HCI_MGMT_EXT_INDEX_EVENTS);\n}\n\n/* This function requires the caller holds hdev->lock */\nstatic void restart_le_actions(struct hci_dev *hdev)\n{\n\tstruct hci_conn_params *p;\n\n\tlist_for_each_entry(p, &hdev->le_conn_params, list) {\n\t\t/* Needed for AUTO_OFF case where might not \"really\"\n\t\t * have been powered off.\n\t\t */\n\t\tlist_del_init(&p->action);\n\n\t\tswitch (p->auto_connect) {\n\t\tcase HCI_AUTO_CONN_DIRECT:\n\t\tcase HCI_AUTO_CONN_ALWAYS:\n\t\t\tlist_add(&p->action, &hdev->pend_le_conns);\n\t\t\tbreak;\n\t\tcase HCI_AUTO_CONN_REPORT:\n\t\t\tlist_add(&p->action, &hdev->pend_le_reports);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid mgmt_power_on(struct hci_dev *hdev, int err)\n{\n\tstruct cmd_lookup match = { NULL, hdev };\n\n\tbt_dev_dbg(hdev, \"err %d\", err);\n\n\thci_dev_lock(hdev);\n\n\tif (!err) {\n\t\trestart_le_actions(hdev);\n\t\thci_update_background_scan(hdev);\n\t}\n\n\tmgmt_pending_foreach(MGMT_OP_SET_POWERED, hdev, settings_rsp, &match);\n\n\tnew_settings(hdev, match.sk);\n\n\tif (match.sk)\n\t\tsock_put(match.sk);\n\n\thci_dev_unlock(hdev);\n}\n\nvoid __mgmt_power_off(struct hci_dev *hdev)\n{\n\tstruct cmd_lookup match = { NULL, hdev };\n\tu8 status, zero_cod[] = { 0, 0, 0 };\n\n\tmgmt_pending_foreach(MGMT_OP_SET_POWERED, hdev, settings_rsp, &match);\n\n\t/* If the power off is because of hdev unregistration let\n\t * use the appropriate INVALID_INDEX status. Otherwise use\n\t * NOT_POWERED. We cover both scenarios here since later in\n\t * mgmt_index_removed() any hci_conn callbacks will have already\n\t * been triggered, potentially causing misleading DISCONNECTED\n\t * status responses.\n\t */\n\tif (hci_dev_test_flag(hdev, HCI_UNREGISTER))\n\t\tstatus = MGMT_STATUS_INVALID_INDEX;\n\telse\n\t\tstatus = MGMT_STATUS_NOT_POWERED;\n\n\tmgmt_pending_foreach(0, hdev, cmd_complete_rsp, &status);\n\n\tif (memcmp(hdev->dev_class, zero_cod, sizeof(zero_cod)) != 0) {\n\t\tmgmt_limited_event(MGMT_EV_CLASS_OF_DEV_CHANGED, hdev,\n\t\t\t\t   zero_cod, sizeof(zero_cod),\n\t\t\t\t   HCI_MGMT_DEV_CLASS_EVENTS, NULL);\n\t\text_info_changed(hdev, NULL);\n\t}\n\n\tnew_settings(hdev, match.sk);\n\n\tif (match.sk)\n\t\tsock_put(match.sk);\n}\n\nvoid mgmt_set_powered_failed(struct hci_dev *hdev, int err)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\tu8 status;\n\n\tcmd = pending_find(MGMT_OP_SET_POWERED, hdev);\n\tif (!cmd)\n\t\treturn;\n\n\tif (err == -ERFKILL)\n\t\tstatus = MGMT_STATUS_RFKILLED;\n\telse\n\t\tstatus = MGMT_STATUS_FAILED;\n\n\tmgmt_cmd_status(cmd->sk, hdev->id, MGMT_OP_SET_POWERED, status);\n\n\tmgmt_pending_remove(cmd);\n}\n\nvoid mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,\n\t\t       bool persistent)\n{\n\tstruct mgmt_ev_new_link_key ev;\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\tev.store_hint = persistent;\n\tbacpy(&ev.key.addr.bdaddr, &key->bdaddr);\n\tev.key.addr.type = BDADDR_BREDR;\n\tev.key.type = key->type;\n\tmemcpy(ev.key.val, key->val, HCI_LINK_KEY_SIZE);\n\tev.key.pin_len = key->pin_len;\n\n\tmgmt_event(MGMT_EV_NEW_LINK_KEY, hdev, &ev, sizeof(ev), NULL);\n}\n\nstatic u8 mgmt_ltk_type(struct smp_ltk *ltk)\n{\n\tswitch (ltk->type) {\n\tcase SMP_LTK:\n\tcase SMP_LTK_SLAVE:\n\t\tif (ltk->authenticated)\n\t\t\treturn MGMT_LTK_AUTHENTICATED;\n\t\treturn MGMT_LTK_UNAUTHENTICATED;\n\tcase SMP_LTK_P256:\n\t\tif (ltk->authenticated)\n\t\t\treturn MGMT_LTK_P256_AUTH;\n\t\treturn MGMT_LTK_P256_UNAUTH;\n\tcase SMP_LTK_P256_DEBUG:\n\t\treturn MGMT_LTK_P256_DEBUG;\n\t}\n\n\treturn MGMT_LTK_UNAUTHENTICATED;\n}\n\nvoid mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, bool persistent)\n{\n\tstruct mgmt_ev_new_long_term_key ev;\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\t/* Devices using resolvable or non-resolvable random addresses\n\t * without providing an identity resolving key don't require\n\t * to store long term keys. Their addresses will change the\n\t * next time around.\n\t *\n\t * Only when a remote device provides an identity address\n\t * make sure the long term key is stored. If the remote\n\t * identity is known, the long term keys are internally\n\t * mapped to the identity address. So allow static random\n\t * and public addresses here.\n\t */\n\tif (key->bdaddr_type == ADDR_LE_DEV_RANDOM &&\n\t    (key->bdaddr.b[5] & 0xc0) != 0xc0)\n\t\tev.store_hint = 0x00;\n\telse\n\t\tev.store_hint = persistent;\n\n\tbacpy(&ev.key.addr.bdaddr, &key->bdaddr);\n\tev.key.addr.type = link_to_bdaddr(LE_LINK, key->bdaddr_type);\n\tev.key.type = mgmt_ltk_type(key);\n\tev.key.enc_size = key->enc_size;\n\tev.key.ediv = key->ediv;\n\tev.key.rand = key->rand;\n\n\tif (key->type == SMP_LTK)\n\t\tev.key.master = 1;\n\n\t/* Make sure we copy only the significant bytes based on the\n\t * encryption key size, and set the rest of the value to zeroes.\n\t */\n\tmemcpy(ev.key.val, key->val, key->enc_size);\n\tmemset(ev.key.val + key->enc_size, 0,\n\t       sizeof(ev.key.val) - key->enc_size);\n\n\tmgmt_event(MGMT_EV_NEW_LONG_TERM_KEY, hdev, &ev, sizeof(ev), NULL);\n}\n\nvoid mgmt_new_irk(struct hci_dev *hdev, struct smp_irk *irk, bool persistent)\n{\n\tstruct mgmt_ev_new_irk ev;\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\tev.store_hint = persistent;\n\n\tbacpy(&ev.rpa, &irk->rpa);\n\tbacpy(&ev.irk.addr.bdaddr, &irk->bdaddr);\n\tev.irk.addr.type = link_to_bdaddr(LE_LINK, irk->addr_type);\n\tmemcpy(ev.irk.val, irk->val, sizeof(irk->val));\n\n\tmgmt_event(MGMT_EV_NEW_IRK, hdev, &ev, sizeof(ev), NULL);\n}\n\nvoid mgmt_new_csrk(struct hci_dev *hdev, struct smp_csrk *csrk,\n\t\t   bool persistent)\n{\n\tstruct mgmt_ev_new_csrk ev;\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\t/* Devices using resolvable or non-resolvable random addresses\n\t * without providing an identity resolving key don't require\n\t * to store signature resolving keys. Their addresses will change\n\t * the next time around.\n\t *\n\t * Only when a remote device provides an identity address\n\t * make sure the signature resolving key is stored. So allow\n\t * static random and public addresses here.\n\t */\n\tif (csrk->bdaddr_type == ADDR_LE_DEV_RANDOM &&\n\t    (csrk->bdaddr.b[5] & 0xc0) != 0xc0)\n\t\tev.store_hint = 0x00;\n\telse\n\t\tev.store_hint = persistent;\n\n\tbacpy(&ev.key.addr.bdaddr, &csrk->bdaddr);\n\tev.key.addr.type = link_to_bdaddr(LE_LINK, csrk->bdaddr_type);\n\tev.key.type = csrk->type;\n\tmemcpy(ev.key.val, csrk->val, sizeof(csrk->val));\n\n\tmgmt_event(MGMT_EV_NEW_CSRK, hdev, &ev, sizeof(ev), NULL);\n}\n\nvoid mgmt_new_conn_param(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t u8 bdaddr_type, u8 store_hint, u16 min_interval,\n\t\t\t u16 max_interval, u16 latency, u16 timeout)\n{\n\tstruct mgmt_ev_new_conn_param ev;\n\n\tif (!hci_is_identity_address(bdaddr, bdaddr_type))\n\t\treturn;\n\n\tmemset(&ev, 0, sizeof(ev));\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = link_to_bdaddr(LE_LINK, bdaddr_type);\n\tev.store_hint = store_hint;\n\tev.min_interval = cpu_to_le16(min_interval);\n\tev.max_interval = cpu_to_le16(max_interval);\n\tev.latency = cpu_to_le16(latency);\n\tev.timeout = cpu_to_le16(timeout);\n\n\tmgmt_event(MGMT_EV_NEW_CONN_PARAM, hdev, &ev, sizeof(ev), NULL);\n}\n\nvoid mgmt_device_connected(struct hci_dev *hdev, struct hci_conn *conn,\n\t\t\t   u32 flags, u8 *name, u8 name_len)\n{\n\tchar buf[512];\n\tstruct mgmt_ev_device_connected *ev = (void *) buf;\n\tu16 eir_len = 0;\n\n\tbacpy(&ev->addr.bdaddr, &conn->dst);\n\tev->addr.type = link_to_bdaddr(conn->type, conn->dst_type);\n\n\tev->flags = __cpu_to_le32(flags);\n\n\t/* We must ensure that the EIR Data fields are ordered and\n\t * unique. Keep it simple for now and avoid the problem by not\n\t * adding any BR/EDR data to the LE adv.\n\t */\n\tif (conn->le_adv_data_len > 0) {\n\t\tmemcpy(&ev->eir[eir_len],\n\t\t       conn->le_adv_data, conn->le_adv_data_len);\n\t\teir_len = conn->le_adv_data_len;\n\t} else {\n\t\tif (name_len > 0)\n\t\t\teir_len = eir_append_data(ev->eir, 0, EIR_NAME_COMPLETE,\n\t\t\t\t\t\t  name, name_len);\n\n\t\tif (memcmp(conn->dev_class, \"\\0\\0\\0\", 3) != 0)\n\t\t\teir_len = eir_append_data(ev->eir, eir_len,\n\t\t\t\t\t\t  EIR_CLASS_OF_DEV,\n\t\t\t\t\t\t  conn->dev_class, 3);\n\t}\n\n\tev->eir_len = cpu_to_le16(eir_len);\n\n\tmgmt_event(MGMT_EV_DEVICE_CONNECTED, hdev, buf,\n\t\t    sizeof(*ev) + eir_len, NULL);\n}\n\nstatic void disconnect_rsp(struct mgmt_pending_cmd *cmd, void *data)\n{\n\tstruct sock **sk = data;\n\n\tcmd->cmd_complete(cmd, 0);\n\n\t*sk = cmd->sk;\n\tsock_hold(*sk);\n\n\tmgmt_pending_remove(cmd);\n}\n\nstatic void unpair_device_rsp(struct mgmt_pending_cmd *cmd, void *data)\n{\n\tstruct hci_dev *hdev = data;\n\tstruct mgmt_cp_unpair_device *cp = cmd->param;\n\n\tdevice_unpaired(hdev, &cp->addr.bdaddr, cp->addr.type, cmd->sk);\n\n\tcmd->cmd_complete(cmd, 0);\n\tmgmt_pending_remove(cmd);\n}\n\nbool mgmt_powering_down(struct hci_dev *hdev)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\tstruct mgmt_mode *cp;\n\n\tcmd = pending_find(MGMT_OP_SET_POWERED, hdev);\n\tif (!cmd)\n\t\treturn false;\n\n\tcp = cmd->param;\n\tif (!cp->val)\n\t\treturn true;\n\n\treturn false;\n}\n\nvoid mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t      u8 link_type, u8 addr_type, u8 reason,\n\t\t\t      bool mgmt_connected)\n{\n\tstruct mgmt_ev_device_disconnected ev;\n\tstruct sock *sk = NULL;\n\n\t/* The connection is still in hci_conn_hash so test for 1\n\t * instead of 0 to know if this is the last one.\n\t */\n\tif (mgmt_powering_down(hdev) && hci_conn_count(hdev) == 1) {\n\t\tcancel_delayed_work(&hdev->power_off);\n\t\tqueue_work(hdev->req_workqueue, &hdev->power_off.work);\n\t}\n\n\tif (!mgmt_connected)\n\t\treturn;\n\n\tif (link_type != ACL_LINK && link_type != LE_LINK)\n\t\treturn;\n\n\tmgmt_pending_foreach(MGMT_OP_DISCONNECT, hdev, disconnect_rsp, &sk);\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = link_to_bdaddr(link_type, addr_type);\n\tev.reason = reason;\n\n\t/* Report disconnects due to suspend */\n\tif (hdev->suspended)\n\t\tev.reason = MGMT_DEV_DISCONN_LOCAL_HOST_SUSPEND;\n\n\tmgmt_event(MGMT_EV_DEVICE_DISCONNECTED, hdev, &ev, sizeof(ev), sk);\n\n\tif (sk)\n\t\tsock_put(sk);\n\n\tmgmt_pending_foreach(MGMT_OP_UNPAIR_DEVICE, hdev, unpair_device_rsp,\n\t\t\t     hdev);\n}\n\nvoid mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t    u8 link_type, u8 addr_type, u8 status)\n{\n\tu8 bdaddr_type = link_to_bdaddr(link_type, addr_type);\n\tstruct mgmt_cp_disconnect *cp;\n\tstruct mgmt_pending_cmd *cmd;\n\n\tmgmt_pending_foreach(MGMT_OP_UNPAIR_DEVICE, hdev, unpair_device_rsp,\n\t\t\t     hdev);\n\n\tcmd = pending_find(MGMT_OP_DISCONNECT, hdev);\n\tif (!cmd)\n\t\treturn;\n\n\tcp = cmd->param;\n\n\tif (bacmp(bdaddr, &cp->addr.bdaddr))\n\t\treturn;\n\n\tif (cp->addr.type != bdaddr_type)\n\t\treturn;\n\n\tcmd->cmd_complete(cmd, mgmt_status(status));\n\tmgmt_pending_remove(cmd);\n}\n\nvoid mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,\n\t\t\t u8 addr_type, u8 status)\n{\n\tstruct mgmt_ev_connect_failed ev;\n\n\t/* The connection is still in hci_conn_hash so test for 1\n\t * instead of 0 to know if this is the last one.\n\t */\n\tif (mgmt_powering_down(hdev) && hci_conn_count(hdev) == 1) {\n\t\tcancel_delayed_work(&hdev->power_off);\n\t\tqueue_work(hdev->req_workqueue, &hdev->power_off.work);\n\t}\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = link_to_bdaddr(link_type, addr_type);\n\tev.status = mgmt_status(status);\n\n\tmgmt_event(MGMT_EV_CONNECT_FAILED, hdev, &ev, sizeof(ev), NULL);\n}\n\nvoid mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure)\n{\n\tstruct mgmt_ev_pin_code_request ev;\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = BDADDR_BREDR;\n\tev.secure = secure;\n\n\tmgmt_event(MGMT_EV_PIN_CODE_REQUEST, hdev, &ev, sizeof(ev), NULL);\n}\n\nvoid mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t  u8 status)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tcmd = pending_find(MGMT_OP_PIN_CODE_REPLY, hdev);\n\tif (!cmd)\n\t\treturn;\n\n\tcmd->cmd_complete(cmd, mgmt_status(status));\n\tmgmt_pending_remove(cmd);\n}\n\nvoid mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t      u8 status)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tcmd = pending_find(MGMT_OP_PIN_CODE_NEG_REPLY, hdev);\n\tif (!cmd)\n\t\treturn;\n\n\tcmd->cmd_complete(cmd, mgmt_status(status));\n\tmgmt_pending_remove(cmd);\n}\n\nint mgmt_user_confirm_request(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t      u8 link_type, u8 addr_type, u32 value,\n\t\t\t      u8 confirm_hint)\n{\n\tstruct mgmt_ev_user_confirm_request ev;\n\n\tbt_dev_dbg(hdev, \"bdaddr %pMR\", bdaddr);\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = link_to_bdaddr(link_type, addr_type);\n\tev.confirm_hint = confirm_hint;\n\tev.value = cpu_to_le32(value);\n\n\treturn mgmt_event(MGMT_EV_USER_CONFIRM_REQUEST, hdev, &ev, sizeof(ev),\n\t\t\t  NULL);\n}\n\nint mgmt_user_passkey_request(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t      u8 link_type, u8 addr_type)\n{\n\tstruct mgmt_ev_user_passkey_request ev;\n\n\tbt_dev_dbg(hdev, \"bdaddr %pMR\", bdaddr);\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = link_to_bdaddr(link_type, addr_type);\n\n\treturn mgmt_event(MGMT_EV_USER_PASSKEY_REQUEST, hdev, &ev, sizeof(ev),\n\t\t\t  NULL);\n}\n\nstatic int user_pairing_resp_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t      u8 link_type, u8 addr_type, u8 status,\n\t\t\t\t      u8 opcode)\n{\n\tstruct mgmt_pending_cmd *cmd;\n\n\tcmd = pending_find(opcode, hdev);\n\tif (!cmd)\n\t\treturn -ENOENT;\n\n\tcmd->cmd_complete(cmd, mgmt_status(status));\n\tmgmt_pending_remove(cmd);\n\n\treturn 0;\n}\n\nint mgmt_user_confirm_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t     u8 link_type, u8 addr_type, u8 status)\n{\n\treturn user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,\n\t\t\t\t\t  status, MGMT_OP_USER_CONFIRM_REPLY);\n}\n\nint mgmt_user_confirm_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t\t u8 link_type, u8 addr_type, u8 status)\n{\n\treturn user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,\n\t\t\t\t\t  status,\n\t\t\t\t\t  MGMT_OP_USER_CONFIRM_NEG_REPLY);\n}\n\nint mgmt_user_passkey_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t     u8 link_type, u8 addr_type, u8 status)\n{\n\treturn user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,\n\t\t\t\t\t  status, MGMT_OP_USER_PASSKEY_REPLY);\n}\n\nint mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t\t u8 link_type, u8 addr_type, u8 status)\n{\n\treturn user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,\n\t\t\t\t\t  status,\n\t\t\t\t\t  MGMT_OP_USER_PASSKEY_NEG_REPLY);\n}\n\nint mgmt_user_passkey_notify(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t     u8 link_type, u8 addr_type, u32 passkey,\n\t\t\t     u8 entered)\n{\n\tstruct mgmt_ev_passkey_notify ev;\n\n\tbt_dev_dbg(hdev, \"bdaddr %pMR\", bdaddr);\n\n\tbacpy(&ev.addr.bdaddr, bdaddr);\n\tev.addr.type = link_to_bdaddr(link_type, addr_type);\n\tev.passkey = __cpu_to_le32(passkey);\n\tev.entered = entered;\n\n\treturn mgmt_event(MGMT_EV_PASSKEY_NOTIFY, hdev, &ev, sizeof(ev), NULL);\n}\n\nvoid mgmt_auth_failed(struct hci_conn *conn, u8 hci_status)\n{\n\tstruct mgmt_ev_auth_failed ev;\n\tstruct mgmt_pending_cmd *cmd;\n\tu8 status = mgmt_status(hci_status);\n\n\tbacpy(&ev.addr.bdaddr, &conn->dst);\n\tev.addr.type = link_to_bdaddr(conn->type, conn->dst_type);\n\tev.status = status;\n\n\tcmd = find_pairing(conn);\n\n\tmgmt_event(MGMT_EV_AUTH_FAILED, conn->hdev, &ev, sizeof(ev),\n\t\t    cmd ? cmd->sk : NULL);\n\n\tif (cmd) {\n\t\tcmd->cmd_complete(cmd, status);\n\t\tmgmt_pending_remove(cmd);\n\t}\n}\n\nvoid mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status)\n{\n\tstruct cmd_lookup match = { NULL, hdev };\n\tbool changed;\n\n\tif (status) {\n\t\tu8 mgmt_err = mgmt_status(status);\n\t\tmgmt_pending_foreach(MGMT_OP_SET_LINK_SECURITY, hdev,\n\t\t\t\t     cmd_status_rsp, &mgmt_err);\n\t\treturn;\n\t}\n\n\tif (test_bit(HCI_AUTH, &hdev->flags))\n\t\tchanged = !hci_dev_test_and_set_flag(hdev, HCI_LINK_SECURITY);\n\telse\n\t\tchanged = hci_dev_test_and_clear_flag(hdev, HCI_LINK_SECURITY);\n\n\tmgmt_pending_foreach(MGMT_OP_SET_LINK_SECURITY, hdev, settings_rsp,\n\t\t\t     &match);\n\n\tif (changed)\n\t\tnew_settings(hdev, match.sk);\n\n\tif (match.sk)\n\t\tsock_put(match.sk);\n}\n\nstatic void clear_eir(struct hci_request *req)\n{\n\tstruct hci_dev *hdev = req->hdev;\n\tstruct hci_cp_write_eir cp;\n\n\tif (!lmp_ext_inq_capable(hdev))\n\t\treturn;\n\n\tmemset(hdev->eir, 0, sizeof(hdev->eir));\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\thci_req_add(req, HCI_OP_WRITE_EIR, sizeof(cp), &cp);\n}\n\nvoid mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status)\n{\n\tstruct cmd_lookup match = { NULL, hdev };\n\tstruct hci_request req;\n\tbool changed = false;\n\n\tif (status) {\n\t\tu8 mgmt_err = mgmt_status(status);\n\n\t\tif (enable && hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t\t  HCI_SSP_ENABLED)) {\n\t\t\thci_dev_clear_flag(hdev, HCI_HS_ENABLED);\n\t\t\tnew_settings(hdev, NULL);\n\t\t}\n\n\t\tmgmt_pending_foreach(MGMT_OP_SET_SSP, hdev, cmd_status_rsp,\n\t\t\t\t     &mgmt_err);\n\t\treturn;\n\t}\n\n\tif (enable) {\n\t\tchanged = !hci_dev_test_and_set_flag(hdev, HCI_SSP_ENABLED);\n\t} else {\n\t\tchanged = hci_dev_test_and_clear_flag(hdev, HCI_SSP_ENABLED);\n\t\tif (!changed)\n\t\t\tchanged = hci_dev_test_and_clear_flag(hdev,\n\t\t\t\t\t\t\t      HCI_HS_ENABLED);\n\t\telse\n\t\t\thci_dev_clear_flag(hdev, HCI_HS_ENABLED);\n\t}\n\n\tmgmt_pending_foreach(MGMT_OP_SET_SSP, hdev, settings_rsp, &match);\n\n\tif (changed)\n\t\tnew_settings(hdev, match.sk);\n\n\tif (match.sk)\n\t\tsock_put(match.sk);\n\n\thci_req_init(&req, hdev);\n\n\tif (hci_dev_test_flag(hdev, HCI_SSP_ENABLED)) {\n\t\tif (hci_dev_test_flag(hdev, HCI_USE_DEBUG_KEYS))\n\t\t\thci_req_add(&req, HCI_OP_WRITE_SSP_DEBUG_MODE,\n\t\t\t\t    sizeof(enable), &enable);\n\t\t__hci_req_update_eir(&req);\n\t} else {\n\t\tclear_eir(&req);\n\t}\n\n\thci_req_run(&req, NULL);\n}\n\nstatic void sk_lookup(struct mgmt_pending_cmd *cmd, void *data)\n{\n\tstruct cmd_lookup *match = data;\n\n\tif (match->sk == NULL) {\n\t\tmatch->sk = cmd->sk;\n\t\tsock_hold(match->sk);\n\t}\n}\n\nvoid mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,\n\t\t\t\t    u8 status)\n{\n\tstruct cmd_lookup match = { NULL, hdev, mgmt_status(status) };\n\n\tmgmt_pending_foreach(MGMT_OP_SET_DEV_CLASS, hdev, sk_lookup, &match);\n\tmgmt_pending_foreach(MGMT_OP_ADD_UUID, hdev, sk_lookup, &match);\n\tmgmt_pending_foreach(MGMT_OP_REMOVE_UUID, hdev, sk_lookup, &match);\n\n\tif (!status) {\n\t\tmgmt_limited_event(MGMT_EV_CLASS_OF_DEV_CHANGED, hdev, dev_class,\n\t\t\t\t   3, HCI_MGMT_DEV_CLASS_EVENTS, NULL);\n\t\text_info_changed(hdev, NULL);\n\t}\n\n\tif (match.sk)\n\t\tsock_put(match.sk);\n}\n\nvoid mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status)\n{\n\tstruct mgmt_cp_set_local_name ev;\n\tstruct mgmt_pending_cmd *cmd;\n\n\tif (status)\n\t\treturn;\n\n\tmemset(&ev, 0, sizeof(ev));\n\tmemcpy(ev.name, name, HCI_MAX_NAME_LENGTH);\n\tmemcpy(ev.short_name, hdev->short_name, HCI_MAX_SHORT_NAME_LENGTH);\n\n\tcmd = pending_find(MGMT_OP_SET_LOCAL_NAME, hdev);\n\tif (!cmd) {\n\t\tmemcpy(hdev->dev_name, name, sizeof(hdev->dev_name));\n\n\t\t/* If this is a HCI command related to powering on the\n\t\t * HCI dev don't send any mgmt signals.\n\t\t */\n\t\tif (pending_find(MGMT_OP_SET_POWERED, hdev))\n\t\t\treturn;\n\t}\n\n\tmgmt_limited_event(MGMT_EV_LOCAL_NAME_CHANGED, hdev, &ev, sizeof(ev),\n\t\t\t   HCI_MGMT_LOCAL_NAME_EVENTS, cmd ? cmd->sk : NULL);\n\text_info_changed(hdev, cmd ? cmd->sk : NULL);\n}\n\nstatic inline bool has_uuid(u8 *uuid, u16 uuid_count, u8 (*uuids)[16])\n{\n\tint i;\n\n\tfor (i = 0; i < uuid_count; i++) {\n\t\tif (!memcmp(uuid, uuids[i], 16))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool eir_has_uuids(u8 *eir, u16 eir_len, u16 uuid_count, u8 (*uuids)[16])\n{\n\tu16 parsed = 0;\n\n\twhile (parsed < eir_len) {\n\t\tu8 field_len = eir[0];\n\t\tu8 uuid[16];\n\t\tint i;\n\n\t\tif (field_len == 0)\n\t\t\tbreak;\n\n\t\tif (eir_len - parsed < field_len + 1)\n\t\t\tbreak;\n\n\t\tswitch (eir[1]) {\n\t\tcase EIR_UUID16_ALL:\n\t\tcase EIR_UUID16_SOME:\n\t\t\tfor (i = 0; i + 3 <= field_len; i += 2) {\n\t\t\t\tmemcpy(uuid, bluetooth_base_uuid, 16);\n\t\t\t\tuuid[13] = eir[i + 3];\n\t\t\t\tuuid[12] = eir[i + 2];\n\t\t\t\tif (has_uuid(uuid, uuid_count, uuids))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EIR_UUID32_ALL:\n\t\tcase EIR_UUID32_SOME:\n\t\t\tfor (i = 0; i + 5 <= field_len; i += 4) {\n\t\t\t\tmemcpy(uuid, bluetooth_base_uuid, 16);\n\t\t\t\tuuid[15] = eir[i + 5];\n\t\t\t\tuuid[14] = eir[i + 4];\n\t\t\t\tuuid[13] = eir[i + 3];\n\t\t\t\tuuid[12] = eir[i + 2];\n\t\t\t\tif (has_uuid(uuid, uuid_count, uuids))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EIR_UUID128_ALL:\n\t\tcase EIR_UUID128_SOME:\n\t\t\tfor (i = 0; i + 17 <= field_len; i += 16) {\n\t\t\t\tmemcpy(uuid, eir + i + 2, 16);\n\t\t\t\tif (has_uuid(uuid, uuid_count, uuids))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tparsed += field_len + 1;\n\t\teir += field_len + 1;\n\t}\n\n\treturn false;\n}\n\nstatic void restart_le_scan(struct hci_dev *hdev)\n{\n\t/* If controller is not scanning we are done. */\n\tif (!hci_dev_test_flag(hdev, HCI_LE_SCAN))\n\t\treturn;\n\n\tif (time_after(jiffies + DISCOV_LE_RESTART_DELAY,\n\t\t       hdev->discovery.scan_start +\n\t\t       hdev->discovery.scan_duration))\n\t\treturn;\n\n\tqueue_delayed_work(hdev->req_workqueue, &hdev->le_scan_restart,\n\t\t\t   DISCOV_LE_RESTART_DELAY);\n}\n\nstatic bool is_filter_match(struct hci_dev *hdev, s8 rssi, u8 *eir,\n\t\t\t    u16 eir_len, u8 *scan_rsp, u8 scan_rsp_len)\n{\n\t/* If a RSSI threshold has been specified, and\n\t * HCI_QUIRK_STRICT_DUPLICATE_FILTER is not set, then all results with\n\t * a RSSI smaller than the RSSI threshold will be dropped. If the quirk\n\t * is set, let it through for further processing, as we might need to\n\t * restart the scan.\n\t *\n\t * For BR/EDR devices (pre 1.2) providing no RSSI during inquiry,\n\t * the results are also dropped.\n\t */\n\tif (hdev->discovery.rssi != HCI_RSSI_INVALID &&\n\t    (rssi == HCI_RSSI_INVALID ||\n\t    (rssi < hdev->discovery.rssi &&\n\t     !test_bit(HCI_QUIRK_STRICT_DUPLICATE_FILTER, &hdev->quirks))))\n\t\treturn  false;\n\n\tif (hdev->discovery.uuid_count != 0) {\n\t\t/* If a list of UUIDs is provided in filter, results with no\n\t\t * matching UUID should be dropped.\n\t\t */\n\t\tif (!eir_has_uuids(eir, eir_len, hdev->discovery.uuid_count,\n\t\t\t\t   hdev->discovery.uuids) &&\n\t\t    !eir_has_uuids(scan_rsp, scan_rsp_len,\n\t\t\t\t   hdev->discovery.uuid_count,\n\t\t\t\t   hdev->discovery.uuids))\n\t\t\treturn false;\n\t}\n\n\t/* If duplicate filtering does not report RSSI changes, then restart\n\t * scanning to ensure updated result with updated RSSI values.\n\t */\n\tif (test_bit(HCI_QUIRK_STRICT_DUPLICATE_FILTER, &hdev->quirks)) {\n\t\trestart_le_scan(hdev);\n\n\t\t/* Validate RSSI value against the RSSI threshold once more. */\n\t\tif (hdev->discovery.rssi != HCI_RSSI_INVALID &&\n\t\t    rssi < hdev->discovery.rssi)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,\n\t\t       u8 addr_type, u8 *dev_class, s8 rssi, u32 flags,\n\t\t       u8 *eir, u16 eir_len, u8 *scan_rsp, u8 scan_rsp_len)\n{\n\tchar buf[512];\n\tstruct mgmt_ev_device_found *ev = (void *)buf;\n\tsize_t ev_size;\n\n\t/* Don't send events for a non-kernel initiated discovery. With\n\t * LE one exception is if we have pend_le_reports > 0 in which\n\t * case we're doing passive scanning and want these events.\n\t */\n\tif (!hci_discovery_active(hdev)) {\n\t\tif (link_type == ACL_LINK)\n\t\t\treturn;\n\t\tif (link_type == LE_LINK &&\n\t\t    list_empty(&hdev->pend_le_reports) &&\n\t\t    !hci_is_adv_monitoring(hdev)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (hdev->discovery.result_filtering) {\n\t\t/* We are using service discovery */\n\t\tif (!is_filter_match(hdev, rssi, eir, eir_len, scan_rsp,\n\t\t\t\t     scan_rsp_len))\n\t\t\treturn;\n\t}\n\n\tif (hdev->discovery.limited) {\n\t\t/* Check for limited discoverable bit */\n\t\tif (dev_class) {\n\t\t\tif (!(dev_class[1] & 0x20))\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tu8 *flags = eir_get_data(eir, eir_len, EIR_FLAGS, NULL);\n\t\t\tif (!flags || !(flags[0] & LE_AD_LIMITED))\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Make sure that the buffer is big enough. The 5 extra bytes\n\t * are for the potential CoD field.\n\t */\n\tif (sizeof(*ev) + eir_len + scan_rsp_len + 5 > sizeof(buf))\n\t\treturn;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\t/* In case of device discovery with BR/EDR devices (pre 1.2), the\n\t * RSSI value was reported as 0 when not available. This behavior\n\t * is kept when using device discovery. This is required for full\n\t * backwards compatibility with the API.\n\t *\n\t * However when using service discovery, the value 127 will be\n\t * returned when the RSSI is not available.\n\t */\n\tif (rssi == HCI_RSSI_INVALID && !hdev->discovery.report_invalid_rssi &&\n\t    link_type == ACL_LINK)\n\t\trssi = 0;\n\n\tbacpy(&ev->addr.bdaddr, bdaddr);\n\tev->addr.type = link_to_bdaddr(link_type, addr_type);\n\tev->rssi = rssi;\n\tev->flags = cpu_to_le32(flags);\n\n\tif (eir_len > 0)\n\t\t/* Copy EIR or advertising data into event */\n\t\tmemcpy(ev->eir, eir, eir_len);\n\n\tif (dev_class && !eir_get_data(ev->eir, eir_len, EIR_CLASS_OF_DEV,\n\t\t\t\t       NULL))\n\t\teir_len = eir_append_data(ev->eir, eir_len, EIR_CLASS_OF_DEV,\n\t\t\t\t\t  dev_class, 3);\n\n\tif (scan_rsp_len > 0)\n\t\t/* Append scan response data to event */\n\t\tmemcpy(ev->eir + eir_len, scan_rsp, scan_rsp_len);\n\n\tev->eir_len = cpu_to_le16(eir_len + scan_rsp_len);\n\tev_size = sizeof(*ev) + eir_len + scan_rsp_len;\n\n\tmgmt_event(MGMT_EV_DEVICE_FOUND, hdev, ev, ev_size, NULL);\n}\n\nvoid mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,\n\t\t      u8 addr_type, s8 rssi, u8 *name, u8 name_len)\n{\n\tstruct mgmt_ev_device_found *ev;\n\tchar buf[sizeof(*ev) + HCI_MAX_NAME_LENGTH + 2];\n\tu16 eir_len;\n\n\tev = (struct mgmt_ev_device_found *) buf;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tbacpy(&ev->addr.bdaddr, bdaddr);\n\tev->addr.type = link_to_bdaddr(link_type, addr_type);\n\tev->rssi = rssi;\n\n\teir_len = eir_append_data(ev->eir, 0, EIR_NAME_COMPLETE, name,\n\t\t\t\t  name_len);\n\n\tev->eir_len = cpu_to_le16(eir_len);\n\n\tmgmt_event(MGMT_EV_DEVICE_FOUND, hdev, ev, sizeof(*ev) + eir_len, NULL);\n}\n\nvoid mgmt_discovering(struct hci_dev *hdev, u8 discovering)\n{\n\tstruct mgmt_ev_discovering ev;\n\n\tbt_dev_dbg(hdev, \"discovering %u\", discovering);\n\n\tmemset(&ev, 0, sizeof(ev));\n\tev.type = hdev->discovery.type;\n\tev.discovering = discovering;\n\n\tmgmt_event(MGMT_EV_DISCOVERING, hdev, &ev, sizeof(ev), NULL);\n}\n\nvoid mgmt_suspending(struct hci_dev *hdev, u8 state)\n{\n\tstruct mgmt_ev_controller_suspend ev;\n\n\tev.suspend_state = state;\n\tmgmt_event(MGMT_EV_CONTROLLER_SUSPEND, hdev, &ev, sizeof(ev), NULL);\n}\n\nvoid mgmt_resuming(struct hci_dev *hdev, u8 reason, bdaddr_t *bdaddr,\n\t\t   u8 addr_type)\n{\n\tstruct mgmt_ev_controller_resume ev;\n\n\tev.wake_reason = reason;\n\tif (bdaddr) {\n\t\tbacpy(&ev.addr.bdaddr, bdaddr);\n\t\tev.addr.type = addr_type;\n\t} else {\n\t\tmemset(&ev.addr, 0, sizeof(ev.addr));\n\t}\n\n\tmgmt_event(MGMT_EV_CONTROLLER_RESUME, hdev, &ev, sizeof(ev), NULL);\n}\n\nstatic struct hci_mgmt_chan chan = {\n\t.channel\t= HCI_CHANNEL_CONTROL,\n\t.handler_count\t= ARRAY_SIZE(mgmt_handlers),\n\t.handlers\t= mgmt_handlers,\n\t.hdev_init\t= mgmt_init_hdev,\n};\n\nint mgmt_init(void)\n{\n\treturn hci_mgmt_chan_register(&chan);\n}\n\nvoid mgmt_exit(void)\n{\n\thci_mgmt_chan_unregister(&chan);\n}\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 275}, "message": "warn: potential spectre issue 'mgmt_status_table' [w] (local cap)"}], "macros": [], "notes": [], "path": "/src/net/bluetooth/mgmt.c", "reportHash": "13d4e24edb8488ed82e05a2a556503c1", "checkerName": "smatch.check_spectre", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
