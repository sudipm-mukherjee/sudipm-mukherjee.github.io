<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/net/sctp/socket.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/* SCTP kernel implementation\n * (C) Copyright IBM Corp. 2001, 2004\n * Copyright (c) 1999-2000 Cisco, Inc.\n * Copyright (c) 1999-2001 Motorola, Inc.\n * Copyright (c) 2001-2003 Intel Corp.\n * Copyright (c) 2001-2002 Nokia, Inc.\n * Copyright (c) 2001 La Monte H.P. Yarroll\n *\n * This file is part of the SCTP kernel implementation\n *\n * These functions interface with the sockets layer to implement the\n * SCTP Extensions for the Sockets API.\n *\n * Note that the descriptions from the specification are USER level\n * functions--this file is the functions which populate the struct proto\n * for SCTP which is the BOTTOM of the sockets interface.\n *\n * Please send any bug reports or fixes you make to the\n * email address(es):\n *    lksctp developers <linux-sctp@vger.kernel.org>\n *\n * Written or modified by:\n *    La Monte H.P. Yarroll <piggy@acm.org>\n *    Narasimha Budihal     <narsi@refcode.org>\n *    Karl Knutson          <karl@athena.chicago.il.us>\n *    Jon Grimm             <jgrimm@us.ibm.com>\n *    Xingang Guo           <xingang.guo@intel.com>\n *    Daisy Chang           <daisyc@us.ibm.com>\n *    Sridhar Samudrala     <samudrala@us.ibm.com>\n *    Inaky Perez-Gonzalez  <inaky.gonzalez@intel.com>\n *    Ardelle Fan\t    <ardelle.fan@intel.com>\n *    Ryan Layer\t    <rmlayer@us.ibm.com>\n *    Anup Pemmaiah         <pemmaiah@cc.usu.edu>\n *    Kevin Gao             <kevin.gao@intel.com>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <crypto/hash.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/sched/signal.h>\n#include <linux/ip.h>\n#include <linux/capability.h>\n#include <linux/fcntl.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/compat.h>\n#include <linux/rhashtable.h>\n\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/route.h>\n#include <net/ipv6.h>\n#include <net/inet_common.h>\n#include <net/busy_poll.h>\n\n#include <linux/socket.h> /* for sa_family_t */\n#include <linux/export.h>\n#include <net/sock.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n#include <net/sctp/stream_sched.h>\n\n/* Forward declarations for internal helper functions. */\nstatic bool sctp_writeable(struct sock *sk);\nstatic void sctp_wfree(struct sk_buff *skb);\nstatic int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,\n\t\t\t\tsize_t msg_len);\nstatic int sctp_wait_for_packet(struct sock *sk, int *err, long *timeo_p);\nstatic int sctp_wait_for_connect(struct sctp_association *, long *timeo_p);\nstatic int sctp_wait_for_accept(struct sock *sk, long timeo);\nstatic void sctp_wait_for_close(struct sock *sk, long timeo);\nstatic void sctp_destruct_sock(struct sock *sk);\nstatic struct sctp_af *sctp_sockaddr_af(struct sctp_sock *opt,\n\t\t\t\t\tunion sctp_addr *addr, int len);\nstatic int sctp_bindx_add(struct sock *, struct sockaddr *, int);\nstatic int sctp_bindx_rem(struct sock *, struct sockaddr *, int);\nstatic int sctp_send_asconf_add_ip(struct sock *, struct sockaddr *, int);\nstatic int sctp_send_asconf_del_ip(struct sock *, struct sockaddr *, int);\nstatic int sctp_send_asconf(struct sctp_association *asoc,\n\t\t\t    struct sctp_chunk *chunk);\nstatic int sctp_do_bind(struct sock *, union sctp_addr *, int);\nstatic int sctp_autobind(struct sock *sk);\nstatic int sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,\n\t\t\t     struct sctp_association *assoc,\n\t\t\t     enum sctp_socket_type type);\n\nstatic unsigned long sctp_memory_pressure;\nstatic atomic_long_t sctp_memory_allocated;\nstruct percpu_counter sctp_sockets_allocated;\n\nstatic void sctp_enter_memory_pressure(struct sock *sk)\n{\n\tsctp_memory_pressure = 1;\n}\n\n\n/* Get the sndbuf space available at the time on the association.  */\nstatic inline int sctp_wspace(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\n\treturn asoc->ep->sndbuf_policy ? sk->sk_sndbuf - asoc->sndbuf_used\n\t\t\t\t       : sk_stream_wspace(sk);\n}\n\n/* Increment the used sndbuf space count of the corresponding association by\n * the size of the outgoing data chunk.\n * Also, set the skb destructor for sndbuf accounting later.\n *\n * Since it is always 1-1 between chunk and skb, and also a new skb is always\n * allocated for chunk bundling in sctp_packet_transmit(), we can use the\n * destructor in the data chunk skb for the purpose of the sndbuf space\n * tracking.\n */\nstatic inline void sctp_set_owner_w(struct sctp_chunk *chunk)\n{\n\tstruct sctp_association *asoc = chunk->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\n\t/* The sndbuf space is tracked per association.  */\n\tsctp_association_hold(asoc);\n\n\tif (chunk->shkey)\n\t\tsctp_auth_shkey_hold(chunk->shkey);\n\n\tskb_set_owner_w(chunk->skb, sk);\n\n\tchunk->skb->destructor = sctp_wfree;\n\t/* Save the chunk pointer in skb for sctp_wfree to use later.  */\n\tskb_shinfo(chunk->skb)->destructor_arg = chunk;\n\n\trefcount_add(sizeof(struct sctp_chunk), &sk->sk_wmem_alloc);\n\tasoc->sndbuf_used += chunk->skb->truesize + sizeof(struct sctp_chunk);\n\tsk->sk_wmem_queued += chunk->skb->truesize + sizeof(struct sctp_chunk);\n\tsk_mem_charge(sk, chunk->skb->truesize);\n}\n\nstatic void sctp_clear_owner_w(struct sctp_chunk *chunk)\n{\n\tskb_orphan(chunk->skb);\n}\n\n#define traverse_and_process()\t\\\ndo {\t\t\t\t\\\n\tmsg = chunk->msg;\t\\\n\tif (msg == prev_msg)\t\\\n\t\tcontinue;\t\\\n\tlist_for_each_entry(c, &msg->chunks, frag_list) {\t\\\n\t\tif ((clear && asoc->base.sk == c->skb->sk) ||\t\\\n\t\t    (!clear && asoc->base.sk != c->skb->sk))\t\\\n\t\t\tcb(c);\t\\\n\t}\t\t\t\\\n\tprev_msg = msg;\t\t\\\n} while (0)\n\nstatic void sctp_for_each_tx_datachunk(struct sctp_association *asoc,\n\t\t\t\t       bool clear,\n\t\t\t\t       void (*cb)(struct sctp_chunk *))\n\n{\n\tstruct sctp_datamsg *msg, *prev_msg = NULL;\n\tstruct sctp_outq *q = &asoc->outqueue;\n\tstruct sctp_chunk *chunk, *c;\n\tstruct sctp_transport *t;\n\n\tlist_for_each_entry(t, &asoc->peer.transport_addr_list, transports)\n\t\tlist_for_each_entry(chunk, &t->transmitted, transmitted_list)\n\t\t\ttraverse_and_process();\n\n\tlist_for_each_entry(chunk, &q->retransmit, transmitted_list)\n\t\ttraverse_and_process();\n\n\tlist_for_each_entry(chunk, &q->sacked, transmitted_list)\n\t\ttraverse_and_process();\n\n\tlist_for_each_entry(chunk, &q->abandoned, transmitted_list)\n\t\ttraverse_and_process();\n\n\tlist_for_each_entry(chunk, &q->out_chunk_list, list)\n\t\ttraverse_and_process();\n}\n\nstatic void sctp_for_each_rx_skb(struct sctp_association *asoc, struct sock *sk,\n\t\t\t\t void (*cb)(struct sk_buff *, struct sock *))\n\n{\n\tstruct sk_buff *skb, *tmp;\n\n\tsctp_skb_for_each(skb, &asoc->ulpq.lobby, tmp)\n\t\tcb(skb, sk);\n\n\tsctp_skb_for_each(skb, &asoc->ulpq.reasm, tmp)\n\t\tcb(skb, sk);\n\n\tsctp_skb_for_each(skb, &asoc->ulpq.reasm_uo, tmp)\n\t\tcb(skb, sk);\n}\n\n/* Verify that this is a valid address. */\nstatic inline int sctp_verify_addr(struct sock *sk, union sctp_addr *addr,\n\t\t\t\t   int len)\n{\n\tstruct sctp_af *af;\n\n\t/* Verify basic sockaddr. */\n\taf = sctp_sockaddr_af(sctp_sk(sk), addr, len);\n\tif (!af)\n\t\treturn -EINVAL;\n\n\t/* Is this a valid SCTP address?  */\n\tif (!af->addr_valid(addr, sctp_sk(sk), NULL))\n\t\treturn -EINVAL;\n\n\tif (!sctp_sk(sk)->pf->send_verify(sctp_sk(sk), (addr)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/* Look up the association by its id.  If this is not a UDP-style\n * socket, the ID field is always ignored.\n */\nstruct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)\n{\n\tstruct sctp_association *asoc = NULL;\n\n\t/* If this is not a UDP-style socket, assoc id should be ignored. */\n\tif (!sctp_style(sk, UDP)) {\n\t\t/* Return NULL if the socket state is not ESTABLISHED. It\n\t\t * could be a TCP-style listening socket or a socket which\n\t\t * hasn't yet called connect() to establish an association.\n\t\t */\n\t\tif (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))\n\t\t\treturn NULL;\n\n\t\t/* Get the first and the only association from the list. */\n\t\tif (!list_empty(&sctp_sk(sk)->ep->asocs))\n\t\t\tasoc = list_entry(sctp_sk(sk)->ep->asocs.next,\n\t\t\t\t\t  struct sctp_association, asocs);\n\t\treturn asoc;\n\t}\n\n\t/* Otherwise this is a UDP-style socket. */\n\tif (id <= SCTP_ALL_ASSOC)\n\t\treturn NULL;\n\n\tspin_lock_bh(&sctp_assocs_id_lock);\n\tasoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);\n\tif (asoc && (asoc->base.sk != sk || asoc->base.dead))\n\t\tasoc = NULL;\n\tspin_unlock_bh(&sctp_assocs_id_lock);\n\n\treturn asoc;\n}\n\n/* Look up the transport from an address and an assoc id. If both address and\n * id are specified, the associations matching the address and the id should be\n * the same.\n */\nstatic struct sctp_transport *sctp_addr_id2transport(struct sock *sk,\n\t\t\t\t\t      struct sockaddr_storage *addr,\n\t\t\t\t\t      sctp_assoc_t id)\n{\n\tstruct sctp_association *addr_asoc = NULL, *id_asoc = NULL;\n\tstruct sctp_af *af = sctp_get_af_specific(addr->ss_family);\n\tunion sctp_addr *laddr = (union sctp_addr *)addr;\n\tstruct sctp_transport *transport;\n\n\tif (!af || sctp_verify_addr(sk, laddr, af->sockaddr_len))\n\t\treturn NULL;\n\n\taddr_asoc = sctp_endpoint_lookup_assoc(sctp_sk(sk)->ep,\n\t\t\t\t\t       laddr,\n\t\t\t\t\t       &transport);\n\n\tif (!addr_asoc)\n\t\treturn NULL;\n\n\tid_asoc = sctp_id2assoc(sk, id);\n\tif (id_asoc && (id_asoc != addr_asoc))\n\t\treturn NULL;\n\n\tsctp_get_pf_specific(sk->sk_family)->addr_to_user(sctp_sk(sk),\n\t\t\t\t\t\t(union sctp_addr *)addr);\n\n\treturn transport;\n}\n\n/* API 3.1.2 bind() - UDP Style Syntax\n * The syntax of bind() is,\n *\n *   ret = bind(int sd, struct sockaddr *addr, int addrlen);\n *\n *   sd      - the socket descriptor returned by socket().\n *   addr    - the address structure (struct sockaddr_in or struct\n *             sockaddr_in6 [RFC 2553]),\n *   addr_len - the size of the address structure.\n */\nstatic int sctp_bind(struct sock *sk, struct sockaddr *addr, int addr_len)\n{\n\tint retval = 0;\n\n\tlock_sock(sk);\n\n\tpr_debug(\"%s: sk:%p, addr:%p, addr_len:%d\\n\", __func__, sk,\n\t\t addr, addr_len);\n\n\t/* Disallow binding twice. */\n\tif (!sctp_sk(sk)->ep->base.bind_addr.port)\n\t\tretval = sctp_do_bind(sk, (union sctp_addr *)addr,\n\t\t\t\t      addr_len);\n\telse\n\t\tretval = -EINVAL;\n\n\trelease_sock(sk);\n\n\treturn retval;\n}\n\nstatic int sctp_get_port_local(struct sock *, union sctp_addr *);\n\n/* Verify this is a valid sockaddr. */\nstatic struct sctp_af *sctp_sockaddr_af(struct sctp_sock *opt,\n\t\t\t\t\tunion sctp_addr *addr, int len)\n{\n\tstruct sctp_af *af;\n\n\t/* Check minimum size.  */\n\tif (len < sizeof (struct sockaddr))\n\t\treturn NULL;\n\n\tif (!opt->pf->af_supported(addr->sa.sa_family, opt))\n\t\treturn NULL;\n\n\tif (addr->sa.sa_family == AF_INET6) {\n\t\tif (len < SIN6_LEN_RFC2133)\n\t\t\treturn NULL;\n\t\t/* V4 mapped address are really of AF_INET family */\n\t\tif (ipv6_addr_v4mapped(&addr->v6.sin6_addr) &&\n\t\t    !opt->pf->af_supported(AF_INET, opt))\n\t\t\treturn NULL;\n\t}\n\n\t/* If we get this far, af is valid. */\n\taf = sctp_get_af_specific(addr->sa.sa_family);\n\n\tif (len < af->sockaddr_len)\n\t\treturn NULL;\n\n\treturn af;\n}\n\n/* Bind a local address either to an endpoint or to an association.  */\nstatic int sctp_do_bind(struct sock *sk, union sctp_addr *addr, int len)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tstruct sctp_bind_addr *bp = &ep->base.bind_addr;\n\tstruct sctp_af *af;\n\tunsigned short snum;\n\tint ret = 0;\n\n\t/* Common sockaddr verification. */\n\taf = sctp_sockaddr_af(sp, addr, len);\n\tif (!af) {\n\t\tpr_debug(\"%s: sk:%p, newaddr:%p, len:%d EINVAL\\n\",\n\t\t\t __func__, sk, addr, len);\n\t\treturn -EINVAL;\n\t}\n\n\tsnum = ntohs(addr->v4.sin_port);\n\n\tpr_debug(\"%s: sk:%p, new addr:%pISc, port:%d, new port:%d, len:%d\\n\",\n\t\t __func__, sk, &addr->sa, bp->port, snum, len);\n\n\t/* PF specific bind() address verification. */\n\tif (!sp->pf->bind_verify(sp, addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* We must either be unbound, or bind to the same port.\n\t * It's OK to allow 0 ports if we are already bound.\n\t * We'll just inhert an already bound port in this case\n\t */\n\tif (bp->port) {\n\t\tif (!snum)\n\t\t\tsnum = bp->port;\n\t\telse if (snum != bp->port) {\n\t\t\tpr_debug(\"%s: new port %d doesn't match existing port \"\n\t\t\t\t \"%d\\n\", __func__, snum, bp->port);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (snum && inet_port_requires_bind_service(net, snum) &&\n\t    !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE))\n\t\treturn -EACCES;\n\n\t/* See if the address matches any of the addresses we may have\n\t * already bound before checking against other endpoints.\n\t */\n\tif (sctp_bind_addr_match(bp, addr, sp))\n\t\treturn -EINVAL;\n\n\t/* Make sure we are allowed to bind here.\n\t * The function sctp_get_port_local() does duplicate address\n\t * detection.\n\t */\n\taddr->v4.sin_port = htons(snum);\n\tif (sctp_get_port_local(sk, addr))\n\t\treturn -EADDRINUSE;\n\n\t/* Refresh ephemeral port.  */\n\tif (!bp->port)\n\t\tbp->port = inet_sk(sk)->inet_num;\n\n\t/* Add the address to the bind address list.\n\t * Use GFP_ATOMIC since BHs will be disabled.\n\t */\n\tret = sctp_add_bind_addr(bp, addr, af->sockaddr_len,\n\t\t\t\t SCTP_ADDR_SRC, GFP_ATOMIC);\n\n\tif (ret) {\n\t\tsctp_put_port(sk);\n\t\treturn ret;\n\t}\n\t/* Copy back into socket for getsockname() use. */\n\tinet_sk(sk)->inet_sport = htons(inet_sk(sk)->inet_num);\n\tsp->pf->to_sk_saddr(addr, sk);\n\n\treturn ret;\n}\n\n /* ADDIP Section 4.1.1 Congestion Control of ASCONF Chunks\n *\n * R1) One and only one ASCONF Chunk MAY be in transit and unacknowledged\n * at any one time.  If a sender, after sending an ASCONF chunk, decides\n * it needs to transfer another ASCONF Chunk, it MUST wait until the\n * ASCONF-ACK Chunk returns from the previous ASCONF Chunk before sending a\n * subsequent ASCONF. Note this restriction binds each side, so at any\n * time two ASCONF may be in-transit on any given association (one sent\n * from each endpoint).\n */\nstatic int sctp_send_asconf(struct sctp_association *asoc,\n\t\t\t    struct sctp_chunk *chunk)\n{\n\tint retval = 0;\n\n\t/* If there is an outstanding ASCONF chunk, queue it for later\n\t * transmission.\n\t */\n\tif (asoc->addip_last_asconf) {\n\t\tlist_add_tail(&chunk->list, &asoc->addip_chunk_list);\n\t\tgoto out;\n\t}\n\n\t/* Hold the chunk until an ASCONF_ACK is received. */\n\tsctp_chunk_hold(chunk);\n\tretval = sctp_primitive_ASCONF(asoc->base.net, asoc, chunk);\n\tif (retval)\n\t\tsctp_chunk_free(chunk);\n\telse\n\t\tasoc->addip_last_asconf = chunk;\n\nout:\n\treturn retval;\n}\n\n/* Add a list of addresses as bind addresses to local endpoint or\n * association.\n *\n * Basically run through each address specified in the addrs/addrcnt\n * array/length pair, determine if it is IPv6 or IPv4 and call\n * sctp_do_bind() on it.\n *\n * If any of them fails, then the operation will be reversed and the\n * ones that were added will be removed.\n *\n * Only sctp_setsockopt_bindx() is supposed to call this function.\n */\nstatic int sctp_bindx_add(struct sock *sk, struct sockaddr *addrs, int addrcnt)\n{\n\tint cnt;\n\tint retval = 0;\n\tvoid *addr_buf;\n\tstruct sockaddr *sa_addr;\n\tstruct sctp_af *af;\n\n\tpr_debug(\"%s: sk:%p, addrs:%p, addrcnt:%d\\n\", __func__, sk,\n\t\t addrs, addrcnt);\n\n\taddr_buf = addrs;\n\tfor (cnt = 0; cnt < addrcnt; cnt++) {\n\t\t/* The list may contain either IPv4 or IPv6 address;\n\t\t * determine the address length for walking thru the list.\n\t\t */\n\t\tsa_addr = addr_buf;\n\t\taf = sctp_get_af_specific(sa_addr->sa_family);\n\t\tif (!af) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_add;\n\t\t}\n\n\t\tretval = sctp_do_bind(sk, (union sctp_addr *)sa_addr,\n\t\t\t\t      af->sockaddr_len);\n\n\t\taddr_buf += af->sockaddr_len;\n\nerr_bindx_add:\n\t\tif (retval < 0) {\n\t\t\t/* Failed. Cleanup the ones that have been added */\n\t\t\tif (cnt > 0)\n\t\t\t\tsctp_bindx_rem(sk, addrs, cnt);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\n/* Send an ASCONF chunk with Add IP address parameters to all the peers of the\n * associations that are part of the endpoint indicating that a list of local\n * addresses are added to the endpoint.\n *\n * If any of the addresses is already in the bind address list of the\n * association, we do not send the chunk for that association.  But it will not\n * affect other associations.\n *\n * Only sctp_setsockopt_bindx() is supposed to call this function.\n */\nstatic int sctp_send_asconf_add_ip(struct sock\t\t*sk,\n\t\t\t\t   struct sockaddr\t*addrs,\n\t\t\t\t   int \t\t\taddrcnt)\n{\n\tstruct sctp_sock\t\t*sp;\n\tstruct sctp_endpoint\t\t*ep;\n\tstruct sctp_association\t\t*asoc;\n\tstruct sctp_bind_addr\t\t*bp;\n\tstruct sctp_chunk\t\t*chunk;\n\tstruct sctp_sockaddr_entry\t*laddr;\n\tunion sctp_addr\t\t\t*addr;\n\tunion sctp_addr\t\t\tsaveaddr;\n\tvoid\t\t\t\t*addr_buf;\n\tstruct sctp_af\t\t\t*af;\n\tstruct list_head\t\t*p;\n\tint \t\t\t\ti;\n\tint \t\t\t\tretval = 0;\n\n\tsp = sctp_sk(sk);\n\tep = sp->ep;\n\n\tif (!ep->asconf_enable)\n\t\treturn retval;\n\n\tpr_debug(\"%s: sk:%p, addrs:%p, addrcnt:%d\\n\",\n\t\t __func__, sk, addrs, addrcnt);\n\n\tlist_for_each_entry(asoc, &ep->asocs, asocs) {\n\t\tif (!asoc->peer.asconf_capable)\n\t\t\tcontinue;\n\n\t\tif (asoc->peer.addip_disabled_mask & SCTP_PARAM_ADD_IP)\n\t\t\tcontinue;\n\n\t\tif (!sctp_state(asoc, ESTABLISHED))\n\t\t\tcontinue;\n\n\t\t/* Check if any address in the packed array of addresses is\n\t\t * in the bind address list of the association. If so,\n\t\t * do not send the asconf chunk to its peer, but continue with\n\t\t * other associations.\n\t\t */\n\t\taddr_buf = addrs;\n\t\tfor (i = 0; i < addrcnt; i++) {\n\t\t\taddr = addr_buf;\n\t\t\taf = sctp_get_af_specific(addr->v4.sin_family);\n\t\t\tif (!af) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (sctp_assoc_lookup_laddr(asoc, addr))\n\t\t\t\tbreak;\n\n\t\t\taddr_buf += af->sockaddr_len;\n\t\t}\n\t\tif (i < addrcnt)\n\t\t\tcontinue;\n\n\t\t/* Use the first valid address in bind addr list of\n\t\t * association as Address Parameter of ASCONF CHUNK.\n\t\t */\n\t\tbp = &asoc->base.bind_addr;\n\t\tp = bp->address_list.next;\n\t\tladdr = list_entry(p, struct sctp_sockaddr_entry, list);\n\t\tchunk = sctp_make_asconf_update_ip(asoc, &laddr->a, addrs,\n\t\t\t\t\t\t   addrcnt, SCTP_PARAM_ADD_IP);\n\t\tif (!chunk) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Add the new addresses to the bind address list with\n\t\t * use_as_src set to 0.\n\t\t */\n\t\taddr_buf = addrs;\n\t\tfor (i = 0; i < addrcnt; i++) {\n\t\t\taddr = addr_buf;\n\t\t\taf = sctp_get_af_specific(addr->v4.sin_family);\n\t\t\tmemcpy(&saveaddr, addr, af->sockaddr_len);\n\t\t\tretval = sctp_add_bind_addr(bp, &saveaddr,\n\t\t\t\t\t\t    sizeof(saveaddr),\n\t\t\t\t\t\t    SCTP_ADDR_NEW, GFP_ATOMIC);\n\t\t\taddr_buf += af->sockaddr_len;\n\t\t}\n\t\tif (asoc->src_out_of_asoc_ok) {\n\t\t\tstruct sctp_transport *trans;\n\n\t\t\tlist_for_each_entry(trans,\n\t\t\t    &asoc->peer.transport_addr_list, transports) {\n\t\t\t\ttrans->cwnd = min(4*asoc->pathmtu, max_t(__u32,\n\t\t\t\t    2*asoc->pathmtu, 4380));\n\t\t\t\ttrans->ssthresh = asoc->peer.i.a_rwnd;\n\t\t\t\ttrans->rto = asoc->rto_initial;\n\t\t\t\tsctp_max_rto(asoc, trans);\n\t\t\t\ttrans->rtt = trans->srtt = trans->rttvar = 0;\n\t\t\t\t/* Clear the source and route cache */\n\t\t\t\tsctp_transport_route(trans, NULL,\n\t\t\t\t\t\t     sctp_sk(asoc->base.sk));\n\t\t\t}\n\t\t}\n\t\tretval = sctp_send_asconf(asoc, chunk);\n\t}\n\nout:\n\treturn retval;\n}\n\n/* Remove a list of addresses from bind addresses list.  Do not remove the\n * last address.\n *\n * Basically run through each address specified in the addrs/addrcnt\n * array/length pair, determine if it is IPv6 or IPv4 and call\n * sctp_del_bind() on it.\n *\n * If any of them fails, then the operation will be reversed and the\n * ones that were removed will be added back.\n *\n * At least one address has to be left; if only one address is\n * available, the operation will return -EBUSY.\n *\n * Only sctp_setsockopt_bindx() is supposed to call this function.\n */\nstatic int sctp_bindx_rem(struct sock *sk, struct sockaddr *addrs, int addrcnt)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tint cnt;\n\tstruct sctp_bind_addr *bp = &ep->base.bind_addr;\n\tint retval = 0;\n\tvoid *addr_buf;\n\tunion sctp_addr *sa_addr;\n\tstruct sctp_af *af;\n\n\tpr_debug(\"%s: sk:%p, addrs:%p, addrcnt:%d\\n\",\n\t\t __func__, sk, addrs, addrcnt);\n\n\taddr_buf = addrs;\n\tfor (cnt = 0; cnt < addrcnt; cnt++) {\n\t\t/* If the bind address list is empty or if there is only one\n\t\t * bind address, there is nothing more to be removed (we need\n\t\t * at least one address here).\n\t\t */\n\t\tif (list_empty(&bp->address_list) ||\n\t\t    (sctp_list_single_entry(&bp->address_list))) {\n\t\t\tretval = -EBUSY;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\n\t\tsa_addr = addr_buf;\n\t\taf = sctp_get_af_specific(sa_addr->sa.sa_family);\n\t\tif (!af) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\n\t\tif (!af->addr_valid(sa_addr, sp, NULL)) {\n\t\t\tretval = -EADDRNOTAVAIL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\n\t\tif (sa_addr->v4.sin_port &&\n\t\t    sa_addr->v4.sin_port != htons(bp->port)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\n\t\tif (!sa_addr->v4.sin_port)\n\t\t\tsa_addr->v4.sin_port = htons(bp->port);\n\n\t\t/* FIXME - There is probably a need to check if sk->sk_saddr and\n\t\t * sk->sk_rcv_addr are currently set to one of the addresses to\n\t\t * be removed. This is something which needs to be looked into\n\t\t * when we are fixing the outstanding issues with multi-homing\n\t\t * socket routing and failover schemes. Refer to comments in\n\t\t * sctp_do_bind(). -daisy\n\t\t */\n\t\tretval = sctp_del_bind_addr(bp, sa_addr);\n\n\t\taddr_buf += af->sockaddr_len;\nerr_bindx_rem:\n\t\tif (retval < 0) {\n\t\t\t/* Failed. Add the ones that has been removed back */\n\t\t\tif (cnt > 0)\n\t\t\t\tsctp_bindx_add(sk, addrs, cnt);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\n/* Send an ASCONF chunk with Delete IP address parameters to all the peers of\n * the associations that are part of the endpoint indicating that a list of\n * local addresses are removed from the endpoint.\n *\n * If any of the addresses is already in the bind address list of the\n * association, we do not send the chunk for that association.  But it will not\n * affect other associations.\n *\n * Only sctp_setsockopt_bindx() is supposed to call this function.\n */\nstatic int sctp_send_asconf_del_ip(struct sock\t\t*sk,\n\t\t\t\t   struct sockaddr\t*addrs,\n\t\t\t\t   int\t\t\taddrcnt)\n{\n\tstruct sctp_sock\t*sp;\n\tstruct sctp_endpoint\t*ep;\n\tstruct sctp_association\t*asoc;\n\tstruct sctp_transport\t*transport;\n\tstruct sctp_bind_addr\t*bp;\n\tstruct sctp_chunk\t*chunk;\n\tunion sctp_addr\t\t*laddr;\n\tvoid\t\t\t*addr_buf;\n\tstruct sctp_af\t\t*af;\n\tstruct sctp_sockaddr_entry *saddr;\n\tint \t\t\ti;\n\tint \t\t\tretval = 0;\n\tint\t\t\tstored = 0;\n\n\tchunk = NULL;\n\tsp = sctp_sk(sk);\n\tep = sp->ep;\n\n\tif (!ep->asconf_enable)\n\t\treturn retval;\n\n\tpr_debug(\"%s: sk:%p, addrs:%p, addrcnt:%d\\n\",\n\t\t __func__, sk, addrs, addrcnt);\n\n\tlist_for_each_entry(asoc, &ep->asocs, asocs) {\n\n\t\tif (!asoc->peer.asconf_capable)\n\t\t\tcontinue;\n\n\t\tif (asoc->peer.addip_disabled_mask & SCTP_PARAM_DEL_IP)\n\t\t\tcontinue;\n\n\t\tif (!sctp_state(asoc, ESTABLISHED))\n\t\t\tcontinue;\n\n\t\t/* Check if any address in the packed array of addresses is\n\t\t * not present in the bind address list of the association.\n\t\t * If so, do not send the asconf chunk to its peer, but\n\t\t * continue with other associations.\n\t\t */\n\t\taddr_buf = addrs;\n\t\tfor (i = 0; i < addrcnt; i++) {\n\t\t\tladdr = addr_buf;\n\t\t\taf = sctp_get_af_specific(laddr->v4.sin_family);\n\t\t\tif (!af) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!sctp_assoc_lookup_laddr(asoc, laddr))\n\t\t\t\tbreak;\n\n\t\t\taddr_buf += af->sockaddr_len;\n\t\t}\n\t\tif (i < addrcnt)\n\t\t\tcontinue;\n\n\t\t/* Find one address in the association's bind address list\n\t\t * that is not in the packed array of addresses. This is to\n\t\t * make sure that we do not delete all the addresses in the\n\t\t * association.\n\t\t */\n\t\tbp = &asoc->base.bind_addr;\n\t\tladdr = sctp_find_unmatch_addr(bp, (union sctp_addr *)addrs,\n\t\t\t\t\t       addrcnt, sp);\n\t\tif ((laddr == NULL) && (addrcnt == 1)) {\n\t\t\tif (asoc->asconf_addr_del_pending)\n\t\t\t\tcontinue;\n\t\t\tasoc->asconf_addr_del_pending =\n\t\t\t    kzalloc(sizeof(union sctp_addr), GFP_ATOMIC);\n\t\t\tif (asoc->asconf_addr_del_pending == NULL) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tasoc->asconf_addr_del_pending->sa.sa_family =\n\t\t\t\t    addrs->sa_family;\n\t\t\tasoc->asconf_addr_del_pending->v4.sin_port =\n\t\t\t\t    htons(bp->port);\n\t\t\tif (addrs->sa_family == AF_INET) {\n\t\t\t\tstruct sockaddr_in *sin;\n\n\t\t\t\tsin = (struct sockaddr_in *)addrs;\n\t\t\t\tasoc->asconf_addr_del_pending->v4.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\t} else if (addrs->sa_family == AF_INET6) {\n\t\t\t\tstruct sockaddr_in6 *sin6;\n\n\t\t\t\tsin6 = (struct sockaddr_in6 *)addrs;\n\t\t\t\tasoc->asconf_addr_del_pending->v6.sin6_addr = sin6->sin6_addr;\n\t\t\t}\n\n\t\t\tpr_debug(\"%s: keep the last address asoc:%p %pISc at %p\\n\",\n\t\t\t\t __func__, asoc, &asoc->asconf_addr_del_pending->sa,\n\t\t\t\t asoc->asconf_addr_del_pending);\n\n\t\t\tasoc->src_out_of_asoc_ok = 1;\n\t\t\tstored = 1;\n\t\t\tgoto skip_mkasconf;\n\t\t}\n\n\t\tif (laddr == NULL)\n\t\t\treturn -EINVAL;\n\n\t\t/* We do not need RCU protection throughout this loop\n\t\t * because this is done under a socket lock from the\n\t\t * setsockopt call.\n\t\t */\n\t\tchunk = sctp_make_asconf_update_ip(asoc, laddr, addrs, addrcnt,\n\t\t\t\t\t\t   SCTP_PARAM_DEL_IP);\n\t\tif (!chunk) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\nskip_mkasconf:\n\t\t/* Reset use_as_src flag for the addresses in the bind address\n\t\t * list that are to be deleted.\n\t\t */\n\t\taddr_buf = addrs;\n\t\tfor (i = 0; i < addrcnt; i++) {\n\t\t\tladdr = addr_buf;\n\t\t\taf = sctp_get_af_specific(laddr->v4.sin_family);\n\t\t\tlist_for_each_entry(saddr, &bp->address_list, list) {\n\t\t\t\tif (sctp_cmp_addr_exact(&saddr->a, laddr))\n\t\t\t\t\tsaddr->state = SCTP_ADDR_DEL;\n\t\t\t}\n\t\t\taddr_buf += af->sockaddr_len;\n\t\t}\n\n\t\t/* Update the route and saddr entries for all the transports\n\t\t * as some of the addresses in the bind address list are\n\t\t * about to be deleted and cannot be used as source addresses.\n\t\t */\n\t\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\t\t\ttransports) {\n\t\t\tsctp_transport_route(transport, NULL,\n\t\t\t\t\t     sctp_sk(asoc->base.sk));\n\t\t}\n\n\t\tif (stored)\n\t\t\t/* We don't need to transmit ASCONF */\n\t\t\tcontinue;\n\t\tretval = sctp_send_asconf(asoc, chunk);\n\t}\nout:\n\treturn retval;\n}\n\n/* set addr events to assocs in the endpoint.  ep and addr_wq must be locked */\nint sctp_asconf_mgmt(struct sctp_sock *sp, struct sctp_sockaddr_entry *addrw)\n{\n\tstruct sock *sk = sctp_opt2sk(sp);\n\tunion sctp_addr *addr;\n\tstruct sctp_af *af;\n\n\t/* It is safe to write port space in caller. */\n\taddr = &addrw->a;\n\taddr->v4.sin_port = htons(sp->ep->base.bind_addr.port);\n\taf = sctp_get_af_specific(addr->sa.sa_family);\n\tif (!af)\n\t\treturn -EINVAL;\n\tif (sctp_verify_addr(sk, addr, af->sockaddr_len))\n\t\treturn -EINVAL;\n\n\tif (addrw->state == SCTP_ADDR_NEW)\n\t\treturn sctp_send_asconf_add_ip(sk, (struct sockaddr *)addr, 1);\n\telse\n\t\treturn sctp_send_asconf_del_ip(sk, (struct sockaddr *)addr, 1);\n}\n\n/* Helper for tunneling sctp_bindx() requests through sctp_setsockopt()\n *\n * API 8.1\n * int sctp_bindx(int sd, struct sockaddr *addrs, int addrcnt,\n *                int flags);\n *\n * If sd is an IPv4 socket, the addresses passed must be IPv4 addresses.\n * If the sd is an IPv6 socket, the addresses passed can either be IPv4\n * or IPv6 addresses.\n *\n * A single address may be specified as INADDR_ANY or IN6ADDR_ANY, see\n * Section 3.1.2 for this usage.\n *\n * addrs is a pointer to an array of one or more socket addresses. Each\n * address is contained in its appropriate structure (i.e. struct\n * sockaddr_in or struct sockaddr_in6) the family of the address type\n * must be used to distinguish the address length (note that this\n * representation is termed a \"packed array\" of addresses). The caller\n * specifies the number of addresses in the array with addrcnt.\n *\n * On success, sctp_bindx() returns 0. On failure, sctp_bindx() returns\n * -1, and sets errno to the appropriate error code.\n *\n * For SCTP, the port given in each socket address must be the same, or\n * sctp_bindx() will fail, setting errno to EINVAL.\n *\n * The flags parameter is formed from the bitwise OR of zero or more of\n * the following currently defined flags:\n *\n * SCTP_BINDX_ADD_ADDR\n *\n * SCTP_BINDX_REM_ADDR\n *\n * SCTP_BINDX_ADD_ADDR directs SCTP to add the given addresses to the\n * association, and SCTP_BINDX_REM_ADDR directs SCTP to remove the given\n * addresses from the association. The two flags are mutually exclusive;\n * if both are given, sctp_bindx() will fail with EINVAL. A caller may\n * not remove all addresses from an association; sctp_bindx() will\n * reject such an attempt with EINVAL.\n *\n * An application can use sctp_bindx(SCTP_BINDX_ADD_ADDR) to associate\n * additional addresses with an endpoint after calling bind().  Or use\n * sctp_bindx(SCTP_BINDX_REM_ADDR) to remove some addresses a listening\n * socket is associated with so that no new association accepted will be\n * associated with those addresses. If the endpoint supports dynamic\n * address a SCTP_BINDX_REM_ADDR or SCTP_BINDX_ADD_ADDR may cause a\n * endpoint to send the appropriate message to the peer to change the\n * peers address lists.\n *\n * Adding and removing addresses from a connected association is\n * optional functionality. Implementations that do not support this\n * functionality should return EOPNOTSUPP.\n *\n * Basically do nothing but copying the addresses from user to kernel\n * land and invoking either sctp_bindx_add() or sctp_bindx_rem() on the sk.\n * This is used for tunneling the sctp_bindx() request through sctp_setsockopt()\n * from userspace.\n *\n * On exit there is no need to do sockfd_put(), sys_setsockopt() does\n * it.\n *\n * sk        The sk of the socket\n * addrs     The pointer to the addresses\n * addrssize Size of the addrs buffer\n * op        Operation to perform (add or remove, see the flags of\n *           sctp_bindx)\n *\n * Returns 0 if ok, <0 errno code on error.\n */\nstatic int sctp_setsockopt_bindx(struct sock *sk, struct sockaddr *addrs,\n\t\t\t\t int addrs_size, int op)\n{\n\tint err;\n\tint addrcnt = 0;\n\tint walk_size = 0;\n\tstruct sockaddr *sa_addr;\n\tvoid *addr_buf = addrs;\n\tstruct sctp_af *af;\n\n\tpr_debug(\"%s: sk:%p addrs:%p addrs_size:%d opt:%d\\n\",\n\t\t __func__, sk, addr_buf, addrs_size, op);\n\n\tif (unlikely(addrs_size <= 0))\n\t\treturn -EINVAL;\n\n\t/* Walk through the addrs buffer and count the number of addresses. */\n\twhile (walk_size < addrs_size) {\n\t\tif (walk_size + sizeof(sa_family_t) > addrs_size)\n\t\t\treturn -EINVAL;\n\n\t\tsa_addr = addr_buf;\n\t\taf = sctp_get_af_specific(sa_addr->sa_family);\n\n\t\t/* If the address family is not supported or if this address\n\t\t * causes the address buffer to overflow return EINVAL.\n\t\t */\n\t\tif (!af || (walk_size + af->sockaddr_len) > addrs_size)\n\t\t\treturn -EINVAL;\n\t\taddrcnt++;\n\t\taddr_buf += af->sockaddr_len;\n\t\twalk_size += af->sockaddr_len;\n\t}\n\n\t/* Do the work. */\n\tswitch (op) {\n\tcase SCTP_BINDX_ADD_ADDR:\n\t\t/* Allow security module to validate bindx addresses. */\n\t\terr = security_sctp_bind_connect(sk, SCTP_SOCKOPT_BINDX_ADD,\n\t\t\t\t\t\t addrs, addrs_size);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = sctp_bindx_add(sk, addrs, addrcnt);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn sctp_send_asconf_add_ip(sk, addrs, addrcnt);\n\tcase SCTP_BINDX_REM_ADDR:\n\t\terr = sctp_bindx_rem(sk, addrs, addrcnt);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn sctp_send_asconf_del_ip(sk, addrs, addrcnt);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int sctp_bind_add(struct sock *sk, struct sockaddr *addrs,\n\t\tint addrlen)\n{\n\tint err;\n\n\tlock_sock(sk);\n\terr = sctp_setsockopt_bindx(sk, addrs, addrlen, SCTP_BINDX_ADD_ADDR);\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sctp_connect_new_asoc(struct sctp_endpoint *ep,\n\t\t\t\t const union sctp_addr *daddr,\n\t\t\t\t const struct sctp_initmsg *init,\n\t\t\t\t struct sctp_transport **tp)\n{\n\tstruct sctp_association *asoc;\n\tstruct sock *sk = ep->base.sk;\n\tstruct net *net = sock_net(sk);\n\tenum sctp_scope scope;\n\tint err;\n\n\tif (sctp_endpoint_is_peeled_off(ep, daddr))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (!ep->base.bind_addr.port) {\n\t\tif (sctp_autobind(sk))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tif (inet_port_requires_bind_service(net, ep->base.bind_addr.port) &&\n\t\t    !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE))\n\t\t\treturn -EACCES;\n\t}\n\n\tscope = sctp_scope(daddr);\n\tasoc = sctp_association_new(ep, sk, scope, GFP_KERNEL);\n\tif (!asoc)\n\t\treturn -ENOMEM;\n\n\terr = sctp_assoc_set_bind_addr_from_ep(asoc, scope, GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto free;\n\n\t*tp = sctp_assoc_add_peer(asoc, daddr, GFP_KERNEL, SCTP_UNKNOWN);\n\tif (!*tp) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tif (!init)\n\t\treturn 0;\n\n\tif (init->sinit_num_ostreams) {\n\t\t__u16 outcnt = init->sinit_num_ostreams;\n\n\t\tasoc->c.sinit_num_ostreams = outcnt;\n\t\t/* outcnt has been changed, need to re-init stream */\n\t\terr = sctp_stream_init(&asoc->stream, outcnt, 0, GFP_KERNEL);\n\t\tif (err)\n\t\t\tgoto free;\n\t}\n\n\tif (init->sinit_max_instreams)\n\t\tasoc->c.sinit_max_instreams = init->sinit_max_instreams;\n\n\tif (init->sinit_max_attempts)\n\t\tasoc->max_init_attempts = init->sinit_max_attempts;\n\n\tif (init->sinit_max_init_timeo)\n\t\tasoc->max_init_timeo =\n\t\t\tmsecs_to_jiffies(init->sinit_max_init_timeo);\n\n\treturn 0;\nfree:\n\tsctp_association_free(asoc);\n\treturn err;\n}\n\nstatic int sctp_connect_add_peer(struct sctp_association *asoc,\n\t\t\t\t union sctp_addr *daddr, int addr_len)\n{\n\tstruct sctp_endpoint *ep = asoc->ep;\n\tstruct sctp_association *old;\n\tstruct sctp_transport *t;\n\tint err;\n\n\terr = sctp_verify_addr(ep->base.sk, daddr, addr_len);\n\tif (err)\n\t\treturn err;\n\n\told = sctp_endpoint_lookup_assoc(ep, daddr, &t);\n\tif (old && old != asoc)\n\t\treturn old->state >= SCTP_STATE_ESTABLISHED ? -EISCONN\n\t\t\t\t\t\t\t    : -EALREADY;\n\n\tif (sctp_endpoint_is_peeled_off(ep, daddr))\n\t\treturn -EADDRNOTAVAIL;\n\n\tt = sctp_assoc_add_peer(asoc, daddr, GFP_KERNEL, SCTP_UNKNOWN);\n\tif (!t)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n/* __sctp_connect(struct sock* sk, struct sockaddr *kaddrs, int addrs_size)\n *\n * Common routine for handling connect() and sctp_connectx().\n * Connect will come in with just a single address.\n */\nstatic int __sctp_connect(struct sock *sk, struct sockaddr *kaddrs,\n\t\t\t  int addrs_size, int flags, sctp_assoc_t *assoc_id)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tstruct sctp_transport *transport;\n\tstruct sctp_association *asoc;\n\tvoid *addr_buf = kaddrs;\n\tunion sctp_addr *daddr;\n\tstruct sctp_af *af;\n\tint walk_size, err;\n\tlong timeo;\n\n\tif (sctp_sstate(sk, ESTABLISHED) || sctp_sstate(sk, CLOSING) ||\n\t    (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING)))\n\t\treturn -EISCONN;\n\n\tdaddr = addr_buf;\n\taf = sctp_get_af_specific(daddr->sa.sa_family);\n\tif (!af || af->sockaddr_len > addrs_size)\n\t\treturn -EINVAL;\n\n\terr = sctp_verify_addr(sk, daddr, af->sockaddr_len);\n\tif (err)\n\t\treturn err;\n\n\tasoc = sctp_endpoint_lookup_assoc(ep, daddr, &transport);\n\tif (asoc)\n\t\treturn asoc->state >= SCTP_STATE_ESTABLISHED ? -EISCONN\n\t\t\t\t\t\t\t     : -EALREADY;\n\n\terr = sctp_connect_new_asoc(ep, daddr, NULL, &transport);\n\tif (err)\n\t\treturn err;\n\tasoc = transport->asoc;\n\n\taddr_buf += af->sockaddr_len;\n\twalk_size = af->sockaddr_len;\n\twhile (walk_size < addrs_size) {\n\t\terr = -EINVAL;\n\t\tif (walk_size + sizeof(sa_family_t) > addrs_size)\n\t\t\tgoto out_free;\n\n\t\tdaddr = addr_buf;\n\t\taf = sctp_get_af_specific(daddr->sa.sa_family);\n\t\tif (!af || af->sockaddr_len + walk_size > addrs_size)\n\t\t\tgoto out_free;\n\n\t\tif (asoc->peer.port != ntohs(daddr->v4.sin_port))\n\t\t\tgoto out_free;\n\n\t\terr = sctp_connect_add_peer(asoc, daddr, af->sockaddr_len);\n\t\tif (err)\n\t\t\tgoto out_free;\n\n\t\taddr_buf  += af->sockaddr_len;\n\t\twalk_size += af->sockaddr_len;\n\t}\n\n\t/* In case the user of sctp_connectx() wants an association\n\t * id back, assign one now.\n\t */\n\tif (assoc_id) {\n\t\terr = sctp_assoc_set_id(asoc, GFP_KERNEL);\n\t\tif (err < 0)\n\t\t\tgoto out_free;\n\t}\n\n\terr = sctp_primitive_ASSOCIATE(sock_net(sk), asoc, NULL);\n\tif (err < 0)\n\t\tgoto out_free;\n\n\t/* Initialize sk's dport and daddr for getpeername() */\n\tinet_sk(sk)->inet_dport = htons(asoc->peer.port);\n\tsp->pf->to_sk_daddr(daddr, sk);\n\tsk->sk_err = 0;\n\n\tif (assoc_id)\n\t\t*assoc_id = asoc->assoc_id;\n\n\ttimeo = sock_sndtimeo(sk, flags & O_NONBLOCK);\n\treturn sctp_wait_for_connect(asoc, &timeo);\n\nout_free:\n\tpr_debug(\"%s: took out_free path with asoc:%p kaddrs:%p err:%d\\n\",\n\t\t __func__, asoc, kaddrs, err);\n\tsctp_association_free(asoc);\n\treturn err;\n}\n\n/* Helper for tunneling sctp_connectx() requests through sctp_setsockopt()\n *\n * API 8.9\n * int sctp_connectx(int sd, struct sockaddr *addrs, int addrcnt,\n * \t\t\tsctp_assoc_t *asoc);\n *\n * If sd is an IPv4 socket, the addresses passed must be IPv4 addresses.\n * If the sd is an IPv6 socket, the addresses passed can either be IPv4\n * or IPv6 addresses.\n *\n * A single address may be specified as INADDR_ANY or IN6ADDR_ANY, see\n * Section 3.1.2 for this usage.\n *\n * addrs is a pointer to an array of one or more socket addresses. Each\n * address is contained in its appropriate structure (i.e. struct\n * sockaddr_in or struct sockaddr_in6) the family of the address type\n * must be used to distengish the address length (note that this\n * representation is termed a \"packed array\" of addresses). The caller\n * specifies the number of addresses in the array with addrcnt.\n *\n * On success, sctp_connectx() returns 0. It also sets the assoc_id to\n * the association id of the new association.  On failure, sctp_connectx()\n * returns -1, and sets errno to the appropriate error code.  The assoc_id\n * is not touched by the kernel.\n *\n * For SCTP, the port given in each socket address must be the same, or\n * sctp_connectx() will fail, setting errno to EINVAL.\n *\n * An application can use sctp_connectx to initiate an association with\n * an endpoint that is multi-homed.  Much like sctp_bindx() this call\n * allows a caller to specify multiple addresses at which a peer can be\n * reached.  The way the SCTP stack uses the list of addresses to set up\n * the association is implementation dependent.  This function only\n * specifies that the stack will try to make use of all the addresses in\n * the list when needed.\n *\n * Note that the list of addresses passed in is only used for setting up\n * the association.  It does not necessarily equal the set of addresses\n * the peer uses for the resulting association.  If the caller wants to\n * find out the set of peer addresses, it must use sctp_getpaddrs() to\n * retrieve them after the association has been set up.\n *\n * Basically do nothing but copying the addresses from user to kernel\n * land and invoking either sctp_connectx(). This is used for tunneling\n * the sctp_connectx() request through sctp_setsockopt() from userspace.\n *\n * On exit there is no need to do sockfd_put(), sys_setsockopt() does\n * it.\n *\n * sk        The sk of the socket\n * addrs     The pointer to the addresses\n * addrssize Size of the addrs buffer\n *\n * Returns >=0 if ok, <0 errno code on error.\n */\nstatic int __sctp_setsockopt_connectx(struct sock *sk, struct sockaddr *kaddrs,\n\t\t\t\t      int addrs_size, sctp_assoc_t *assoc_id)\n{\n\tint err = 0, flags = 0;\n\n\tpr_debug(\"%s: sk:%p addrs:%p addrs_size:%d\\n\",\n\t\t __func__, sk, kaddrs, addrs_size);\n\n\t/* make sure the 1st addr's sa_family is accessible later */\n\tif (unlikely(addrs_size < sizeof(sa_family_t)))\n\t\treturn -EINVAL;\n\n\t/* Allow security module to validate connectx addresses. */\n\terr = security_sctp_bind_connect(sk, SCTP_SOCKOPT_CONNECTX,\n\t\t\t\t\t (struct sockaddr *)kaddrs,\n\t\t\t\t\t  addrs_size);\n\tif (err)\n\t\treturn err;\n\n\t/* in-kernel sockets don't generally have a file allocated to them\n\t * if all they do is call sock_create_kern().\n\t */\n\tif (sk->sk_socket->file)\n\t\tflags = sk->sk_socket->file->f_flags;\n\n\treturn __sctp_connect(sk, kaddrs, addrs_size, flags, assoc_id);\n}\n\n/*\n * This is an older interface.  It's kept for backward compatibility\n * to the option that doesn't provide association id.\n */\nstatic int sctp_setsockopt_connectx_old(struct sock *sk,\n\t\t\t\t\tstruct sockaddr *kaddrs,\n\t\t\t\t\tint addrs_size)\n{\n\treturn __sctp_setsockopt_connectx(sk, kaddrs, addrs_size, NULL);\n}\n\n/*\n * New interface for the API.  The since the API is done with a socket\n * option, to make it simple we feed back the association id is as a return\n * indication to the call.  Error is always negative and association id is\n * always positive.\n */\nstatic int sctp_setsockopt_connectx(struct sock *sk,\n\t\t\t\t    struct sockaddr *kaddrs,\n\t\t\t\t    int addrs_size)\n{\n\tsctp_assoc_t assoc_id = 0;\n\tint err = 0;\n\n\terr = __sctp_setsockopt_connectx(sk, kaddrs, addrs_size, &assoc_id);\n\n\tif (err)\n\t\treturn err;\n\telse\n\t\treturn assoc_id;\n}\n\n/*\n * New (hopefully final) interface for the API.\n * We use the sctp_getaddrs_old structure so that use-space library\n * can avoid any unnecessary allocations. The only different part\n * is that we store the actual length of the address buffer into the\n * addrs_num structure member. That way we can re-use the existing\n * code.\n */\n#ifdef CONFIG_COMPAT\nstruct compat_sctp_getaddrs_old {\n\tsctp_assoc_t\tassoc_id;\n\ts32\t\taddr_num;\n\tcompat_uptr_t\taddrs;\t\t/* struct sockaddr * */\n};\n#endif\n\nstatic int sctp_getsockopt_connectx3(struct sock *sk, int len,\n\t\t\t\t     char __user *optval,\n\t\t\t\t     int __user *optlen)\n{\n\tstruct sctp_getaddrs_old param;\n\tsctp_assoc_t assoc_id = 0;\n\tstruct sockaddr *kaddrs;\n\tint err = 0;\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall()) {\n\t\tstruct compat_sctp_getaddrs_old param32;\n\n\t\tif (len < sizeof(param32))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&param32, optval, sizeof(param32)))\n\t\t\treturn -EFAULT;\n\n\t\tparam.assoc_id = param32.assoc_id;\n\t\tparam.addr_num = param32.addr_num;\n\t\tparam.addrs = compat_ptr(param32.addrs);\n\t} else\n#endif\n\t{\n\t\tif (len < sizeof(param))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&param, optval, sizeof(param)))\n\t\t\treturn -EFAULT;\n\t}\n\n\tkaddrs = memdup_user(param.addrs, param.addr_num);\n\tif (IS_ERR(kaddrs))\n\t\treturn PTR_ERR(kaddrs);\n\n\terr = __sctp_setsockopt_connectx(sk, kaddrs, param.addr_num, &assoc_id);\n\tkfree(kaddrs);\n\tif (err == 0 || err == -EINPROGRESS) {\n\t\tif (copy_to_user(optval, &assoc_id, sizeof(assoc_id)))\n\t\t\treturn -EFAULT;\n\t\tif (put_user(sizeof(assoc_id), optlen))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn err;\n}\n\n/* API 3.1.4 close() - UDP Style Syntax\n * Applications use close() to perform graceful shutdown (as described in\n * Section 10.1 of [SCTP]) on ALL the associations currently represented\n * by a UDP-style socket.\n *\n * The syntax is\n *\n *   ret = close(int sd);\n *\n *   sd      - the socket descriptor of the associations to be closed.\n *\n * To gracefully shutdown a specific association represented by the\n * UDP-style socket, an application should use the sendmsg() call,\n * passing no user data, but including the appropriate flag in the\n * ancillary data (see Section xxxx).\n *\n * If sd in the close() call is a branched-off socket representing only\n * one association, the shutdown is performed on that association only.\n *\n * 4.1.6 close() - TCP Style Syntax\n *\n * Applications use close() to gracefully close down an association.\n *\n * The syntax is:\n *\n *    int close(int sd);\n *\n *      sd      - the socket descriptor of the association to be closed.\n *\n * After an application calls close() on a socket descriptor, no further\n * socket operations will succeed on that descriptor.\n *\n * API 7.1.4 SO_LINGER\n *\n * An application using the TCP-style socket can use this option to\n * perform the SCTP ABORT primitive.  The linger option structure is:\n *\n *  struct  linger {\n *     int     l_onoff;                // option on/off\n *     int     l_linger;               // linger time\n * };\n *\n * To enable the option, set l_onoff to 1.  If the l_linger value is set\n * to 0, calling close() is the same as the ABORT primitive.  If the\n * value is set to a negative value, the setsockopt() call will return\n * an error.  If the value is set to a positive value linger_time, the\n * close() can be blocked for at most linger_time ms.  If the graceful\n * shutdown phase does not finish during this period, close() will\n * return but the graceful shutdown phase continues in the system.\n */\nstatic void sctp_close(struct sock *sk, long timeout)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_association *asoc;\n\tstruct list_head *pos, *temp;\n\tunsigned int data_was_unread;\n\n\tpr_debug(\"%s: sk:%p, timeout:%ld\\n\", __func__, sk, timeout);\n\n\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tinet_sk_set_state(sk, SCTP_SS_CLOSING);\n\n\tep = sctp_sk(sk)->ep;\n\n\t/* Clean up any skbs sitting on the receive queue.  */\n\tdata_was_unread = sctp_queue_purge_ulpevents(&sk->sk_receive_queue);\n\tdata_was_unread += sctp_queue_purge_ulpevents(&sctp_sk(sk)->pd_lobby);\n\n\t/* Walk all associations on an endpoint.  */\n\tlist_for_each_safe(pos, temp, &ep->asocs) {\n\t\tasoc = list_entry(pos, struct sctp_association, asocs);\n\n\t\tif (sctp_style(sk, TCP)) {\n\t\t\t/* A closed association can still be in the list if\n\t\t\t * it belongs to a TCP-style listening socket that is\n\t\t\t * not yet accepted. If so, free it. If not, send an\n\t\t\t * ABORT or SHUTDOWN based on the linger options.\n\t\t\t */\n\t\t\tif (sctp_state(asoc, CLOSED)) {\n\t\t\t\tsctp_association_free(asoc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (data_was_unread || !skb_queue_empty(&asoc->ulpq.lobby) ||\n\t\t    !skb_queue_empty(&asoc->ulpq.reasm) ||\n\t\t    !skb_queue_empty(&asoc->ulpq.reasm_uo) ||\n\t\t    (sock_flag(sk, SOCK_LINGER) && !sk->sk_lingertime)) {\n\t\t\tstruct sctp_chunk *chunk;\n\n\t\t\tchunk = sctp_make_abort_user(asoc, NULL, 0);\n\t\t\tsctp_primitive_ABORT(net, asoc, chunk);\n\t\t} else\n\t\t\tsctp_primitive_SHUTDOWN(net, asoc, NULL);\n\t}\n\n\t/* On a TCP-style socket, block for at most linger_time if set. */\n\tif (sctp_style(sk, TCP) && timeout)\n\t\tsctp_wait_for_close(sk, timeout);\n\n\t/* This will run the backlog queue.  */\n\trelease_sock(sk);\n\n\t/* Supposedly, no process has access to the socket, but\n\t * the net layers still may.\n\t * Also, sctp_destroy_sock() needs to be called with addr_wq_lock\n\t * held and that should be grabbed before socket lock.\n\t */\n\tspin_lock_bh(&net->sctp.addr_wq_lock);\n\tbh_lock_sock_nested(sk);\n\n\t/* Hold the sock, since sk_common_release() will put sock_put()\n\t * and we have just a little more cleanup.\n\t */\n\tsock_hold(sk);\n\tsk_common_release(sk);\n\n\tbh_unlock_sock(sk);\n\tspin_unlock_bh(&net->sctp.addr_wq_lock);\n\n\tsock_put(sk);\n\n\tSCTP_DBG_OBJCNT_DEC(sock);\n}\n\n/* Handle EPIPE error. */\nstatic int sctp_error(struct sock *sk, int flags, int err)\n{\n\tif (err == -EPIPE)\n\t\terr = sock_error(sk) ? : -EPIPE;\n\tif (err == -EPIPE && !(flags & MSG_NOSIGNAL))\n\t\tsend_sig(SIGPIPE, current, 0);\n\treturn err;\n}\n\n/* API 3.1.3 sendmsg() - UDP Style Syntax\n *\n * An application uses sendmsg() and recvmsg() calls to transmit data to\n * and receive data from its peer.\n *\n *  ssize_t sendmsg(int socket, const struct msghdr *message,\n *                  int flags);\n *\n *  socket  - the socket descriptor of the endpoint.\n *  message - pointer to the msghdr structure which contains a single\n *            user message and possibly some ancillary data.\n *\n *            See Section 5 for complete description of the data\n *            structures.\n *\n *  flags   - flags sent or received with the user message, see Section\n *            5 for complete description of the flags.\n *\n * Note:  This function could use a rewrite especially when explicit\n * connect support comes in.\n */\n/* BUG:  We do not implement the equivalent of sk_stream_wait_memory(). */\n\nstatic int sctp_msghdr_parse(const struct msghdr *msg,\n\t\t\t     struct sctp_cmsgs *cmsgs);\n\nstatic int sctp_sendmsg_parse(struct sock *sk, struct sctp_cmsgs *cmsgs,\n\t\t\t      struct sctp_sndrcvinfo *srinfo,\n\t\t\t      const struct msghdr *msg, size_t msg_len)\n{\n\t__u16 sflags;\n\tint err;\n\n\tif (sctp_sstate(sk, LISTENING) && sctp_style(sk, TCP))\n\t\treturn -EPIPE;\n\n\tif (msg_len > sk->sk_sndbuf)\n\t\treturn -EMSGSIZE;\n\n\tmemset(cmsgs, 0, sizeof(*cmsgs));\n\terr = sctp_msghdr_parse(msg, cmsgs);\n\tif (err) {\n\t\tpr_debug(\"%s: msghdr parse err:%x\\n\", __func__, err);\n\t\treturn err;\n\t}\n\n\tmemset(srinfo, 0, sizeof(*srinfo));\n\tif (cmsgs->srinfo) {\n\t\tsrinfo->sinfo_stream = cmsgs->srinfo->sinfo_stream;\n\t\tsrinfo->sinfo_flags = cmsgs->srinfo->sinfo_flags;\n\t\tsrinfo->sinfo_ppid = cmsgs->srinfo->sinfo_ppid;\n\t\tsrinfo->sinfo_context = cmsgs->srinfo->sinfo_context;\n\t\tsrinfo->sinfo_assoc_id = cmsgs->srinfo->sinfo_assoc_id;\n\t\tsrinfo->sinfo_timetolive = cmsgs->srinfo->sinfo_timetolive;\n\t}\n\n\tif (cmsgs->sinfo) {\n\t\tsrinfo->sinfo_stream = cmsgs->sinfo->snd_sid;\n\t\tsrinfo->sinfo_flags = cmsgs->sinfo->snd_flags;\n\t\tsrinfo->sinfo_ppid = cmsgs->sinfo->snd_ppid;\n\t\tsrinfo->sinfo_context = cmsgs->sinfo->snd_context;\n\t\tsrinfo->sinfo_assoc_id = cmsgs->sinfo->snd_assoc_id;\n\t}\n\n\tif (cmsgs->prinfo) {\n\t\tsrinfo->sinfo_timetolive = cmsgs->prinfo->pr_value;\n\t\tSCTP_PR_SET_POLICY(srinfo->sinfo_flags,\n\t\t\t\t   cmsgs->prinfo->pr_policy);\n\t}\n\n\tsflags = srinfo->sinfo_flags;\n\tif (!sflags && msg_len)\n\t\treturn 0;\n\n\tif (sctp_style(sk, TCP) && (sflags & (SCTP_EOF | SCTP_ABORT)))\n\t\treturn -EINVAL;\n\n\tif (((sflags & SCTP_EOF) && msg_len > 0) ||\n\t    (!(sflags & (SCTP_EOF | SCTP_ABORT)) && msg_len == 0))\n\t\treturn -EINVAL;\n\n\tif ((sflags & SCTP_ADDR_OVER) && !msg->msg_name)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int sctp_sendmsg_new_asoc(struct sock *sk, __u16 sflags,\n\t\t\t\t struct sctp_cmsgs *cmsgs,\n\t\t\t\t union sctp_addr *daddr,\n\t\t\t\t struct sctp_transport **tp)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_association *asoc;\n\tstruct cmsghdr *cmsg;\n\t__be32 flowinfo = 0;\n\tstruct sctp_af *af;\n\tint err;\n\n\t*tp = NULL;\n\n\tif (sflags & (SCTP_EOF | SCTP_ABORT))\n\t\treturn -EINVAL;\n\n\tif (sctp_style(sk, TCP) && (sctp_sstate(sk, ESTABLISHED) ||\n\t\t\t\t    sctp_sstate(sk, CLOSING)))\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* Label connection socket for first association 1-to-many\n\t * style for client sequence socket()->sendmsg(). This\n\t * needs to be done before sctp_assoc_add_peer() as that will\n\t * set up the initial packet that needs to account for any\n\t * security ip options (CIPSO/CALIPSO) added to the packet.\n\t */\n\taf = sctp_get_af_specific(daddr->sa.sa_family);\n\tif (!af)\n\t\treturn -EINVAL;\n\terr = security_sctp_bind_connect(sk, SCTP_SENDMSG_CONNECT,\n\t\t\t\t\t (struct sockaddr *)daddr,\n\t\t\t\t\t af->sockaddr_len);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = sctp_connect_new_asoc(ep, daddr, cmsgs->init, tp);\n\tif (err)\n\t\treturn err;\n\tasoc = (*tp)->asoc;\n\n\tif (!cmsgs->addrs_msg)\n\t\treturn 0;\n\n\tif (daddr->sa.sa_family == AF_INET6)\n\t\tflowinfo = daddr->v6.sin6_flowinfo;\n\n\t/* sendv addr list parse */\n\tfor_each_cmsghdr(cmsg, cmsgs->addrs_msg) {\n\t\tunion sctp_addr _daddr;\n\t\tint dlen;\n\n\t\tif (cmsg->cmsg_level != IPPROTO_SCTP ||\n\t\t    (cmsg->cmsg_type != SCTP_DSTADDRV4 &&\n\t\t     cmsg->cmsg_type != SCTP_DSTADDRV6))\n\t\t\tcontinue;\n\n\t\tdaddr = &_daddr;\n\t\tmemset(daddr, 0, sizeof(*daddr));\n\t\tdlen = cmsg->cmsg_len - sizeof(struct cmsghdr);\n\t\tif (cmsg->cmsg_type == SCTP_DSTADDRV4) {\n\t\t\tif (dlen < sizeof(struct in_addr)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\tdlen = sizeof(struct in_addr);\n\t\t\tdaddr->v4.sin_family = AF_INET;\n\t\t\tdaddr->v4.sin_port = htons(asoc->peer.port);\n\t\t\tmemcpy(&daddr->v4.sin_addr, CMSG_DATA(cmsg), dlen);\n\t\t} else {\n\t\t\tif (dlen < sizeof(struct in6_addr)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\tdlen = sizeof(struct in6_addr);\n\t\t\tdaddr->v6.sin6_flowinfo = flowinfo;\n\t\t\tdaddr->v6.sin6_family = AF_INET6;\n\t\t\tdaddr->v6.sin6_port = htons(asoc->peer.port);\n\t\t\tmemcpy(&daddr->v6.sin6_addr, CMSG_DATA(cmsg), dlen);\n\t\t}\n\n\t\terr = sctp_connect_add_peer(asoc, daddr, sizeof(*daddr));\n\t\tif (err)\n\t\t\tgoto free;\n\t}\n\n\treturn 0;\n\nfree:\n\tsctp_association_free(asoc);\n\treturn err;\n}\n\nstatic int sctp_sendmsg_check_sflags(struct sctp_association *asoc,\n\t\t\t\t     __u16 sflags, struct msghdr *msg,\n\t\t\t\t     size_t msg_len)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\n\tif (sctp_state(asoc, CLOSED) && sctp_style(sk, TCP))\n\t\treturn -EPIPE;\n\n\tif ((sflags & SCTP_SENDALL) && sctp_style(sk, UDP) &&\n\t    !sctp_state(asoc, ESTABLISHED))\n\t\treturn 0;\n\n\tif (sflags & SCTP_EOF) {\n\t\tpr_debug(\"%s: shutting down association:%p\\n\", __func__, asoc);\n\t\tsctp_primitive_SHUTDOWN(net, asoc, NULL);\n\n\t\treturn 0;\n\t}\n\n\tif (sflags & SCTP_ABORT) {\n\t\tstruct sctp_chunk *chunk;\n\n\t\tchunk = sctp_make_abort_user(asoc, msg, msg_len);\n\t\tif (!chunk)\n\t\t\treturn -ENOMEM;\n\n\t\tpr_debug(\"%s: aborting association:%p\\n\", __func__, asoc);\n\t\tsctp_primitive_ABORT(net, asoc, chunk);\n\t\tiov_iter_revert(&msg->msg_iter, msg_len);\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int sctp_sendmsg_to_asoc(struct sctp_association *asoc,\n\t\t\t\tstruct msghdr *msg, size_t msg_len,\n\t\t\t\tstruct sctp_transport *transport,\n\t\t\t\tstruct sctp_sndrcvinfo *sinfo)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_datamsg *datamsg;\n\tbool wait_connect = false;\n\tstruct sctp_chunk *chunk;\n\tlong timeo;\n\tint err;\n\n\tif (sinfo->sinfo_stream >= asoc->stream.outcnt) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (unlikely(!SCTP_SO(&asoc->stream, sinfo->sinfo_stream)->ext)) {\n\t\terr = sctp_stream_init_ext(&asoc->stream, sinfo->sinfo_stream);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tif (sp->disable_fragments && msg_len > asoc->frag_point) {\n\t\terr = -EMSGSIZE;\n\t\tgoto err;\n\t}\n\n\tif (asoc->pmtu_pending) {\n\t\tif (sp->param_flags & SPP_PMTUD_ENABLE)\n\t\t\tsctp_assoc_sync_pmtu(asoc);\n\t\tasoc->pmtu_pending = 0;\n\t}\n\n\tif (sctp_wspace(asoc) < (int)msg_len)\n\t\tsctp_prsctp_prune(asoc, sinfo, msg_len - sctp_wspace(asoc));\n\n\tif (sk_under_memory_pressure(sk))\n\t\tsk_mem_reclaim(sk);\n\n\tif (sctp_wspace(asoc) <= 0 || !sk_wmem_schedule(sk, msg_len)) {\n\t\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\t\terr = sctp_wait_for_sndbuf(asoc, &timeo, msg_len);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tif (sctp_state(asoc, CLOSED)) {\n\t\terr = sctp_primitive_ASSOCIATE(net, asoc, NULL);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\tif (asoc->ep->intl_enable) {\n\t\t\ttimeo = sock_sndtimeo(sk, 0);\n\t\t\terr = sctp_wait_for_connect(asoc, &timeo);\n\t\t\tif (err) {\n\t\t\t\terr = -ESRCH;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\twait_connect = true;\n\t\t}\n\n\t\tpr_debug(\"%s: we associated primitively\\n\", __func__);\n\t}\n\n\tdatamsg = sctp_datamsg_from_user(asoc, sinfo, &msg->msg_iter);\n\tif (IS_ERR(datamsg)) {\n\t\terr = PTR_ERR(datamsg);\n\t\tgoto err;\n\t}\n\n\tasoc->force_delay = !!(msg->msg_flags & MSG_MORE);\n\n\tlist_for_each_entry(chunk, &datamsg->chunks, frag_list) {\n\t\tsctp_chunk_hold(chunk);\n\t\tsctp_set_owner_w(chunk);\n\t\tchunk->transport = transport;\n\t}\n\n\terr = sctp_primitive_SEND(net, asoc, datamsg);\n\tif (err) {\n\t\tsctp_datamsg_free(datamsg);\n\t\tgoto err;\n\t}\n\n\tpr_debug(\"%s: we sent primitively\\n\", __func__);\n\n\tsctp_datamsg_put(datamsg);\n\n\tif (unlikely(wait_connect)) {\n\t\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\t\tsctp_wait_for_connect(asoc, &timeo);\n\t}\n\n\terr = msg_len;\n\nerr:\n\treturn err;\n}\n\nstatic union sctp_addr *sctp_sendmsg_get_daddr(struct sock *sk,\n\t\t\t\t\t       const struct msghdr *msg,\n\t\t\t\t\t       struct sctp_cmsgs *cmsgs)\n{\n\tunion sctp_addr *daddr = NULL;\n\tint err;\n\n\tif (!sctp_style(sk, UDP_HIGH_BANDWIDTH) && msg->msg_name) {\n\t\tint len = msg->msg_namelen;\n\n\t\tif (len > sizeof(*daddr))\n\t\t\tlen = sizeof(*daddr);\n\n\t\tdaddr = (union sctp_addr *)msg->msg_name;\n\n\t\terr = sctp_verify_addr(sk, daddr, len);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\treturn daddr;\n}\n\nstatic void sctp_sendmsg_update_sinfo(struct sctp_association *asoc,\n\t\t\t\t      struct sctp_sndrcvinfo *sinfo,\n\t\t\t\t      struct sctp_cmsgs *cmsgs)\n{\n\tif (!cmsgs->srinfo && !cmsgs->sinfo) {\n\t\tsinfo->sinfo_stream = asoc->default_stream;\n\t\tsinfo->sinfo_ppid = asoc->default_ppid;\n\t\tsinfo->sinfo_context = asoc->default_context;\n\t\tsinfo->sinfo_assoc_id = sctp_assoc2id(asoc);\n\n\t\tif (!cmsgs->prinfo)\n\t\t\tsinfo->sinfo_flags = asoc->default_flags;\n\t}\n\n\tif (!cmsgs->srinfo && !cmsgs->prinfo)\n\t\tsinfo->sinfo_timetolive = asoc->default_timetolive;\n\n\tif (cmsgs->authinfo) {\n\t\t/* Reuse sinfo_tsn to indicate that authinfo was set and\n\t\t * sinfo_ssn to save the keyid on tx path.\n\t\t */\n\t\tsinfo->sinfo_tsn = 1;\n\t\tsinfo->sinfo_ssn = cmsgs->authinfo->auth_keynumber;\n\t}\n}\n\nstatic int sctp_sendmsg(struct sock *sk, struct msghdr *msg, size_t msg_len)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_transport *transport = NULL;\n\tstruct sctp_sndrcvinfo _sinfo, *sinfo;\n\tstruct sctp_association *asoc, *tmp;\n\tstruct sctp_cmsgs cmsgs;\n\tunion sctp_addr *daddr;\n\tbool new = false;\n\t__u16 sflags;\n\tint err;\n\n\t/* Parse and get snd_info */\n\terr = sctp_sendmsg_parse(sk, &cmsgs, &_sinfo, msg, msg_len);\n\tif (err)\n\t\tgoto out;\n\n\tsinfo  = &_sinfo;\n\tsflags = sinfo->sinfo_flags;\n\n\t/* Get daddr from msg */\n\tdaddr = sctp_sendmsg_get_daddr(sk, msg, &cmsgs);\n\tif (IS_ERR(daddr)) {\n\t\terr = PTR_ERR(daddr);\n\t\tgoto out;\n\t}\n\n\tlock_sock(sk);\n\n\t/* SCTP_SENDALL process */\n\tif ((sflags & SCTP_SENDALL) && sctp_style(sk, UDP)) {\n\t\tlist_for_each_entry_safe(asoc, tmp, &ep->asocs, asocs) {\n\t\t\terr = sctp_sendmsg_check_sflags(asoc, sflags, msg,\n\t\t\t\t\t\t\tmsg_len);\n\t\t\tif (err == 0)\n\t\t\t\tcontinue;\n\t\t\tif (err < 0)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tsctp_sendmsg_update_sinfo(asoc, sinfo, &cmsgs);\n\n\t\t\terr = sctp_sendmsg_to_asoc(asoc, msg, msg_len,\n\t\t\t\t\t\t   NULL, sinfo);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tiov_iter_revert(&msg->msg_iter, err);\n\t\t}\n\n\t\tgoto out_unlock;\n\t}\n\n\t/* Get and check or create asoc */\n\tif (daddr) {\n\t\tasoc = sctp_endpoint_lookup_assoc(ep, daddr, &transport);\n\t\tif (asoc) {\n\t\t\terr = sctp_sendmsg_check_sflags(asoc, sflags, msg,\n\t\t\t\t\t\t\tmsg_len);\n\t\t\tif (err <= 0)\n\t\t\t\tgoto out_unlock;\n\t\t} else {\n\t\t\terr = sctp_sendmsg_new_asoc(sk, sflags, &cmsgs, daddr,\n\t\t\t\t\t\t    &transport);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tasoc = transport->asoc;\n\t\t\tnew = true;\n\t\t}\n\n\t\tif (!sctp_style(sk, TCP) && !(sflags & SCTP_ADDR_OVER))\n\t\t\ttransport = NULL;\n\t} else {\n\t\tasoc = sctp_id2assoc(sk, sinfo->sinfo_assoc_id);\n\t\tif (!asoc) {\n\t\t\terr = -EPIPE;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\terr = sctp_sendmsg_check_sflags(asoc, sflags, msg, msg_len);\n\t\tif (err <= 0)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* Update snd_info with the asoc */\n\tsctp_sendmsg_update_sinfo(asoc, sinfo, &cmsgs);\n\n\t/* Send msg to the asoc */\n\terr = sctp_sendmsg_to_asoc(asoc, msg, msg_len, transport, sinfo);\n\tif (err < 0 && err != -ESRCH && new)\n\t\tsctp_association_free(asoc);\n\nout_unlock:\n\trelease_sock(sk);\nout:\n\treturn sctp_error(sk, msg->msg_flags, err);\n}\n\n/* This is an extended version of skb_pull() that removes the data from the\n * start of a skb even when data is spread across the list of skb's in the\n * frag_list. len specifies the total amount of data that needs to be removed.\n * when 'len' bytes could be removed from the skb, it returns 0.\n * If 'len' exceeds the total skb length,  it returns the no. of bytes that\n * could not be removed.\n */\nstatic int sctp_skb_pull(struct sk_buff *skb, int len)\n{\n\tstruct sk_buff *list;\n\tint skb_len = skb_headlen(skb);\n\tint rlen;\n\n\tif (len <= skb_len) {\n\t\t__skb_pull(skb, len);\n\t\treturn 0;\n\t}\n\tlen -= skb_len;\n\t__skb_pull(skb, skb_len);\n\n\tskb_walk_frags(skb, list) {\n\t\trlen = sctp_skb_pull(list, len);\n\t\tskb->len -= (len-rlen);\n\t\tskb->data_len -= (len-rlen);\n\n\t\tif (!rlen)\n\t\t\treturn 0;\n\n\t\tlen = rlen;\n\t}\n\n\treturn len;\n}\n\n/* API 3.1.3  recvmsg() - UDP Style Syntax\n *\n *  ssize_t recvmsg(int socket, struct msghdr *message,\n *                    int flags);\n *\n *  socket  - the socket descriptor of the endpoint.\n *  message - pointer to the msghdr structure which contains a single\n *            user message and possibly some ancillary data.\n *\n *            See Section 5 for complete description of the data\n *            structures.\n *\n *  flags   - flags sent or received with the user message, see Section\n *            5 for complete description of the flags.\n */\nstatic int sctp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t\tint noblock, int flags, int *addr_len)\n{\n\tstruct sctp_ulpevent *event = NULL;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sk_buff *skb, *head_skb;\n\tint copied;\n\tint err = 0;\n\tint skb_len;\n\n\tpr_debug(\"%s: sk:%p, msghdr:%p, len:%zd, noblock:%d, flags:0x%x, \"\n\t\t \"addr_len:%p)\\n\", __func__, sk, msg, len, noblock, flags,\n\t\t addr_len);\n\n\tlock_sock(sk);\n\n\tif (sctp_style(sk, TCP) && !sctp_sstate(sk, ESTABLISHED) &&\n\t    !sctp_sstate(sk, CLOSING) && !sctp_sstate(sk, CLOSED)) {\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tskb = sctp_skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\t/* Get the total length of the skb including any skb's in the\n\t * frag_list.\n\t */\n\tskb_len = skb->len;\n\n\tcopied = skb_len;\n\tif (copied > len)\n\t\tcopied = len;\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\n\tevent = sctp_skb2event(skb);\n\n\tif (err)\n\t\tgoto out_free;\n\n\tif (event->chunk && event->chunk->head_skb)\n\t\thead_skb = event->chunk->head_skb;\n\telse\n\t\thead_skb = skb;\n\tsock_recv_ts_and_drops(msg, sk, head_skb);\n\tif (sctp_ulpevent_is_notification(event)) {\n\t\tmsg->msg_flags |= MSG_NOTIFICATION;\n\t\tsp->pf->event_msgname(event, msg->msg_name, addr_len);\n\t} else {\n\t\tsp->pf->skb_msgname(head_skb, msg->msg_name, addr_len);\n\t}\n\n\t/* Check if we allow SCTP_NXTINFO. */\n\tif (sp->recvnxtinfo)\n\t\tsctp_ulpevent_read_nxtinfo(event, msg, sk);\n\t/* Check if we allow SCTP_RCVINFO. */\n\tif (sp->recvrcvinfo)\n\t\tsctp_ulpevent_read_rcvinfo(event, msg);\n\t/* Check if we allow SCTP_SNDRCVINFO. */\n\tif (sctp_ulpevent_type_enabled(sp->subscribe, SCTP_DATA_IO_EVENT))\n\t\tsctp_ulpevent_read_sndrcvinfo(event, msg);\n\n\terr = copied;\n\n\t/* If skb's length exceeds the user's buffer, update the skb and\n\t * push it back to the receive_queue so that the next call to\n\t * recvmsg() will return the remaining data. Don't set MSG_EOR.\n\t */\n\tif (skb_len > copied) {\n\t\tmsg->msg_flags &= ~MSG_EOR;\n\t\tif (flags & MSG_PEEK)\n\t\t\tgoto out_free;\n\t\tsctp_skb_pull(skb, copied);\n\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\n\t\t/* When only partial message is copied to the user, increase\n\t\t * rwnd by that amount. If all the data in the skb is read,\n\t\t * rwnd is updated when the event is freed.\n\t\t */\n\t\tif (!sctp_ulpevent_is_notification(event))\n\t\t\tsctp_assoc_rwnd_increase(event->asoc, copied);\n\t\tgoto out;\n\t} else if ((event->msg_flags & MSG_NOTIFICATION) ||\n\t\t   (event->msg_flags & MSG_EOR))\n\t\tmsg->msg_flags |= MSG_EOR;\n\telse\n\t\tmsg->msg_flags &= ~MSG_EOR;\n\nout_free:\n\tif (flags & MSG_PEEK) {\n\t\t/* Release the skb reference acquired after peeking the skb in\n\t\t * sctp_skb_recv_datagram().\n\t\t */\n\t\tkfree_skb(skb);\n\t} else {\n\t\t/* Free the event which includes releasing the reference to\n\t\t * the owner of the skb, freeing the skb and updating the\n\t\t * rwnd.\n\t\t */\n\t\tsctp_ulpevent_free(event);\n\t}\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\n/* 7.1.12 Enable/Disable message fragmentation (SCTP_DISABLE_FRAGMENTS)\n *\n * This option is a on/off flag.  If enabled no SCTP message\n * fragmentation will be performed.  Instead if a message being sent\n * exceeds the current PMTU size, the message will NOT be sent and\n * instead a error will be indicated to the user.\n */\nstatic int sctp_setsockopt_disable_fragments(struct sock *sk, int *val,\n\t\t\t\t\t     unsigned int optlen)\n{\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tsctp_sk(sk)->disable_fragments = (*val == 0) ? 0 : 1;\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_events(struct sock *sk, __u8 *sn_type,\n\t\t\t\t  unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tint i;\n\n\tif (optlen > sizeof(struct sctp_event_subscribe))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < optlen; i++)\n\t\tsctp_ulpevent_type_set(&sp->subscribe, SCTP_SN_TYPE_BASE + i,\n\t\t\t\t       sn_type[i]);\n\n\tlist_for_each_entry(asoc, &sp->ep->asocs, asocs)\n\t\tasoc->subscribe = sctp_sk(sk)->subscribe;\n\n\t/* At the time when a user app subscribes to SCTP_SENDER_DRY_EVENT,\n\t * if there is no data to be sent or retransmit, the stack will\n\t * immediately send up this notification.\n\t */\n\tif (sctp_ulpevent_type_enabled(sp->subscribe, SCTP_SENDER_DRY_EVENT)) {\n\t\tstruct sctp_ulpevent *event;\n\n\t\tasoc = sctp_id2assoc(sk, 0);\n\t\tif (asoc && sctp_outq_is_empty(&asoc->outqueue)) {\n\t\t\tevent = sctp_ulpevent_make_sender_dry_event(asoc,\n\t\t\t\t\tGFP_USER | __GFP_NOWARN);\n\t\t\tif (!event)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tasoc->stream.si->enqueue_event(&asoc->ulpq, event);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* 7.1.8 Automatic Close of associations (SCTP_AUTOCLOSE)\n *\n * This socket option is applicable to the UDP-style socket only.  When\n * set it will cause associations that are idle for more than the\n * specified number of seconds to automatically close.  An association\n * being idle is defined an association that has NOT sent or received\n * user data.  The special value of '0' indicates that no automatic\n * close of any associations should be performed.  The option expects an\n * integer defining the number of seconds of idle time before an\n * association is closed.\n */\nstatic int sctp_setsockopt_autoclose(struct sock *sk, u32 *optval,\n\t\t\t\t     unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct net *net = sock_net(sk);\n\n\t/* Applicable to UDP-style socket only */\n\tif (sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\tif (optlen != sizeof(int))\n\t\treturn -EINVAL;\n\n\tsp->autoclose = *optval;\n\tif (sp->autoclose > net->sctp.max_autoclose)\n\t\tsp->autoclose = net->sctp.max_autoclose;\n\n\treturn 0;\n}\n\n/* 7.1.13 Peer Address Parameters (SCTP_PEER_ADDR_PARAMS)\n *\n * Applications can enable or disable heartbeats for any peer address of\n * an association, modify an address's heartbeat interval, force a\n * heartbeat to be sent immediately, and adjust the address's maximum\n * number of retransmissions sent before an address is considered\n * unreachable.  The following structure is used to access and modify an\n * address's parameters:\n *\n *  struct sctp_paddrparams {\n *     sctp_assoc_t            spp_assoc_id;\n *     struct sockaddr_storage spp_address;\n *     uint32_t                spp_hbinterval;\n *     uint16_t                spp_pathmaxrxt;\n *     uint32_t                spp_pathmtu;\n *     uint32_t                spp_sackdelay;\n *     uint32_t                spp_flags;\n *     uint32_t                spp_ipv6_flowlabel;\n *     uint8_t                 spp_dscp;\n * };\n *\n *   spp_assoc_id    - (one-to-many style socket) This is filled in the\n *                     application, and identifies the association for\n *                     this query.\n *   spp_address     - This specifies which address is of interest.\n *   spp_hbinterval  - This contains the value of the heartbeat interval,\n *                     in milliseconds.  If a  value of zero\n *                     is present in this field then no changes are to\n *                     be made to this parameter.\n *   spp_pathmaxrxt  - This contains the maximum number of\n *                     retransmissions before this address shall be\n *                     considered unreachable. If a  value of zero\n *                     is present in this field then no changes are to\n *                     be made to this parameter.\n *   spp_pathmtu     - When Path MTU discovery is disabled the value\n *                     specified here will be the \"fixed\" path mtu.\n *                     Note that if the spp_address field is empty\n *                     then all associations on this address will\n *                     have this fixed path mtu set upon them.\n *\n *   spp_sackdelay   - When delayed sack is enabled, this value specifies\n *                     the number of milliseconds that sacks will be delayed\n *                     for. This value will apply to all addresses of an\n *                     association if the spp_address field is empty. Note\n *                     also, that if delayed sack is enabled and this\n *                     value is set to 0, no change is made to the last\n *                     recorded delayed sack timer value.\n *\n *   spp_flags       - These flags are used to control various features\n *                     on an association. The flag field may contain\n *                     zero or more of the following options.\n *\n *                     SPP_HB_ENABLE  - Enable heartbeats on the\n *                     specified address. Note that if the address\n *                     field is empty all addresses for the association\n *                     have heartbeats enabled upon them.\n *\n *                     SPP_HB_DISABLE - Disable heartbeats on the\n *                     speicifed address. Note that if the address\n *                     field is empty all addresses for the association\n *                     will have their heartbeats disabled. Note also\n *                     that SPP_HB_ENABLE and SPP_HB_DISABLE are\n *                     mutually exclusive, only one of these two should\n *                     be specified. Enabling both fields will have\n *                     undetermined results.\n *\n *                     SPP_HB_DEMAND - Request a user initiated heartbeat\n *                     to be made immediately.\n *\n *                     SPP_HB_TIME_IS_ZERO - Specify's that the time for\n *                     heartbeat delayis to be set to the value of 0\n *                     milliseconds.\n *\n *                     SPP_PMTUD_ENABLE - This field will enable PMTU\n *                     discovery upon the specified address. Note that\n *                     if the address feild is empty then all addresses\n *                     on the association are effected.\n *\n *                     SPP_PMTUD_DISABLE - This field will disable PMTU\n *                     discovery upon the specified address. Note that\n *                     if the address feild is empty then all addresses\n *                     on the association are effected. Not also that\n *                     SPP_PMTUD_ENABLE and SPP_PMTUD_DISABLE are mutually\n *                     exclusive. Enabling both will have undetermined\n *                     results.\n *\n *                     SPP_SACKDELAY_ENABLE - Setting this flag turns\n *                     on delayed sack. The time specified in spp_sackdelay\n *                     is used to specify the sack delay for this address. Note\n *                     that if spp_address is empty then all addresses will\n *                     enable delayed sack and take on the sack delay\n *                     value specified in spp_sackdelay.\n *                     SPP_SACKDELAY_DISABLE - Setting this flag turns\n *                     off delayed sack. If the spp_address field is blank then\n *                     delayed sack is disabled for the entire association. Note\n *                     also that this field is mutually exclusive to\n *                     SPP_SACKDELAY_ENABLE, setting both will have undefined\n *                     results.\n *\n *                     SPP_IPV6_FLOWLABEL:  Setting this flag enables the\n *                     setting of the IPV6 flow label value.  The value is\n *                     contained in the spp_ipv6_flowlabel field.\n *                     Upon retrieval, this flag will be set to indicate that\n *                     the spp_ipv6_flowlabel field has a valid value returned.\n *                     If a specific destination address is set (in the\n *                     spp_address field), then the value returned is that of\n *                     the address.  If just an association is specified (and\n *                     no address), then the association's default flow label\n *                     is returned.  If neither an association nor a destination\n *                     is specified, then the socket's default flow label is\n *                     returned.  For non-IPv6 sockets, this flag will be left\n *                     cleared.\n *\n *                     SPP_DSCP:  Setting this flag enables the setting of the\n *                     Differentiated Services Code Point (DSCP) value\n *                     associated with either the association or a specific\n *                     address.  The value is obtained in the spp_dscp field.\n *                     Upon retrieval, this flag will be set to indicate that\n *                     the spp_dscp field has a valid value returned.  If a\n *                     specific destination address is set when called (in the\n *                     spp_address field), then that specific destination\n *                     address's DSCP value is returned.  If just an association\n *                     is specified, then the association's default DSCP is\n *                     returned.  If neither an association nor a destination is\n *                     specified, then the socket's default DSCP is returned.\n *\n *   spp_ipv6_flowlabel\n *                   - This field is used in conjunction with the\n *                     SPP_IPV6_FLOWLABEL flag and contains the IPv6 flow label.\n *                     The 20 least significant bits are used for the flow\n *                     label.  This setting has precedence over any IPv6-layer\n *                     setting.\n *\n *   spp_dscp        - This field is used in conjunction with the SPP_DSCP flag\n *                     and contains the DSCP.  The 6 most significant bits are\n *                     used for the DSCP.  This setting has precedence over any\n *                     IPv4- or IPv6- layer setting.\n */\nstatic int sctp_apply_peer_addr_params(struct sctp_paddrparams *params,\n\t\t\t\t       struct sctp_transport   *trans,\n\t\t\t\t       struct sctp_association *asoc,\n\t\t\t\t       struct sctp_sock        *sp,\n\t\t\t\t       int                      hb_change,\n\t\t\t\t       int                      pmtud_change,\n\t\t\t\t       int                      sackdelay_change)\n{\n\tint error;\n\n\tif (params->spp_flags & SPP_HB_DEMAND && trans) {\n\t\terror = sctp_primitive_REQUESTHEARTBEAT(trans->asoc->base.net,\n\t\t\t\t\t\t\ttrans->asoc, trans);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* Note that unless the spp_flag is set to SPP_HB_ENABLE the value of\n\t * this field is ignored.  Note also that a value of zero indicates\n\t * the current setting should be left unchanged.\n\t */\n\tif (params->spp_flags & SPP_HB_ENABLE) {\n\n\t\t/* Re-zero the interval if the SPP_HB_TIME_IS_ZERO is\n\t\t * set.  This lets us use 0 value when this flag\n\t\t * is set.\n\t\t */\n\t\tif (params->spp_flags & SPP_HB_TIME_IS_ZERO)\n\t\t\tparams->spp_hbinterval = 0;\n\n\t\tif (params->spp_hbinterval ||\n\t\t    (params->spp_flags & SPP_HB_TIME_IS_ZERO)) {\n\t\t\tif (trans) {\n\t\t\t\ttrans->hbinterval =\n\t\t\t\t    msecs_to_jiffies(params->spp_hbinterval);\n\t\t\t} else if (asoc) {\n\t\t\t\tasoc->hbinterval =\n\t\t\t\t    msecs_to_jiffies(params->spp_hbinterval);\n\t\t\t} else {\n\t\t\t\tsp->hbinterval = params->spp_hbinterval;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hb_change) {\n\t\tif (trans) {\n\t\t\ttrans->param_flags =\n\t\t\t\t(trans->param_flags & ~SPP_HB) | hb_change;\n\t\t} else if (asoc) {\n\t\t\tasoc->param_flags =\n\t\t\t\t(asoc->param_flags & ~SPP_HB) | hb_change;\n\t\t} else {\n\t\t\tsp->param_flags =\n\t\t\t\t(sp->param_flags & ~SPP_HB) | hb_change;\n\t\t}\n\t}\n\n\t/* When Path MTU discovery is disabled the value specified here will\n\t * be the \"fixed\" path mtu (i.e. the value of the spp_flags field must\n\t * include the flag SPP_PMTUD_DISABLE for this field to have any\n\t * effect).\n\t */\n\tif ((params->spp_flags & SPP_PMTUD_DISABLE) && params->spp_pathmtu) {\n\t\tif (trans) {\n\t\t\ttrans->pathmtu = params->spp_pathmtu;\n\t\t\tsctp_assoc_sync_pmtu(asoc);\n\t\t} else if (asoc) {\n\t\t\tsctp_assoc_set_pmtu(asoc, params->spp_pathmtu);\n\t\t} else {\n\t\t\tsp->pathmtu = params->spp_pathmtu;\n\t\t}\n\t}\n\n\tif (pmtud_change) {\n\t\tif (trans) {\n\t\t\tint update = (trans->param_flags & SPP_PMTUD_DISABLE) &&\n\t\t\t\t(params->spp_flags & SPP_PMTUD_ENABLE);\n\t\t\ttrans->param_flags =\n\t\t\t\t(trans->param_flags & ~SPP_PMTUD) | pmtud_change;\n\t\t\tif (update) {\n\t\t\t\tsctp_transport_pmtu(trans, sctp_opt2sk(sp));\n\t\t\t\tsctp_assoc_sync_pmtu(asoc);\n\t\t\t}\n\t\t} else if (asoc) {\n\t\t\tasoc->param_flags =\n\t\t\t\t(asoc->param_flags & ~SPP_PMTUD) | pmtud_change;\n\t\t} else {\n\t\t\tsp->param_flags =\n\t\t\t\t(sp->param_flags & ~SPP_PMTUD) | pmtud_change;\n\t\t}\n\t}\n\n\t/* Note that unless the spp_flag is set to SPP_SACKDELAY_ENABLE the\n\t * value of this field is ignored.  Note also that a value of zero\n\t * indicates the current setting should be left unchanged.\n\t */\n\tif ((params->spp_flags & SPP_SACKDELAY_ENABLE) && params->spp_sackdelay) {\n\t\tif (trans) {\n\t\t\ttrans->sackdelay =\n\t\t\t\tmsecs_to_jiffies(params->spp_sackdelay);\n\t\t} else if (asoc) {\n\t\t\tasoc->sackdelay =\n\t\t\t\tmsecs_to_jiffies(params->spp_sackdelay);\n\t\t} else {\n\t\t\tsp->sackdelay = params->spp_sackdelay;\n\t\t}\n\t}\n\n\tif (sackdelay_change) {\n\t\tif (trans) {\n\t\t\ttrans->param_flags =\n\t\t\t\t(trans->param_flags & ~SPP_SACKDELAY) |\n\t\t\t\tsackdelay_change;\n\t\t} else if (asoc) {\n\t\t\tasoc->param_flags =\n\t\t\t\t(asoc->param_flags & ~SPP_SACKDELAY) |\n\t\t\t\tsackdelay_change;\n\t\t} else {\n\t\t\tsp->param_flags =\n\t\t\t\t(sp->param_flags & ~SPP_SACKDELAY) |\n\t\t\t\tsackdelay_change;\n\t\t}\n\t}\n\n\t/* Note that a value of zero indicates the current setting should be\n\t   left unchanged.\n\t */\n\tif (params->spp_pathmaxrxt) {\n\t\tif (trans) {\n\t\t\ttrans->pathmaxrxt = params->spp_pathmaxrxt;\n\t\t} else if (asoc) {\n\t\t\tasoc->pathmaxrxt = params->spp_pathmaxrxt;\n\t\t} else {\n\t\t\tsp->pathmaxrxt = params->spp_pathmaxrxt;\n\t\t}\n\t}\n\n\tif (params->spp_flags & SPP_IPV6_FLOWLABEL) {\n\t\tif (trans) {\n\t\t\tif (trans->ipaddr.sa.sa_family == AF_INET6) {\n\t\t\t\ttrans->flowlabel = params->spp_ipv6_flowlabel &\n\t\t\t\t\t\t   SCTP_FLOWLABEL_VAL_MASK;\n\t\t\t\ttrans->flowlabel |= SCTP_FLOWLABEL_SET_MASK;\n\t\t\t}\n\t\t} else if (asoc) {\n\t\t\tstruct sctp_transport *t;\n\n\t\t\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\t\t\t    transports) {\n\t\t\t\tif (t->ipaddr.sa.sa_family != AF_INET6)\n\t\t\t\t\tcontinue;\n\t\t\t\tt->flowlabel = params->spp_ipv6_flowlabel &\n\t\t\t\t\t       SCTP_FLOWLABEL_VAL_MASK;\n\t\t\t\tt->flowlabel |= SCTP_FLOWLABEL_SET_MASK;\n\t\t\t}\n\t\t\tasoc->flowlabel = params->spp_ipv6_flowlabel &\n\t\t\t\t\t  SCTP_FLOWLABEL_VAL_MASK;\n\t\t\tasoc->flowlabel |= SCTP_FLOWLABEL_SET_MASK;\n\t\t} else if (sctp_opt2sk(sp)->sk_family == AF_INET6) {\n\t\t\tsp->flowlabel = params->spp_ipv6_flowlabel &\n\t\t\t\t\tSCTP_FLOWLABEL_VAL_MASK;\n\t\t\tsp->flowlabel |= SCTP_FLOWLABEL_SET_MASK;\n\t\t}\n\t}\n\n\tif (params->spp_flags & SPP_DSCP) {\n\t\tif (trans) {\n\t\t\ttrans->dscp = params->spp_dscp & SCTP_DSCP_VAL_MASK;\n\t\t\ttrans->dscp |= SCTP_DSCP_SET_MASK;\n\t\t} else if (asoc) {\n\t\t\tstruct sctp_transport *t;\n\n\t\t\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\t\t\t    transports) {\n\t\t\t\tt->dscp = params->spp_dscp &\n\t\t\t\t\t  SCTP_DSCP_VAL_MASK;\n\t\t\t\tt->dscp |= SCTP_DSCP_SET_MASK;\n\t\t\t}\n\t\t\tasoc->dscp = params->spp_dscp & SCTP_DSCP_VAL_MASK;\n\t\t\tasoc->dscp |= SCTP_DSCP_SET_MASK;\n\t\t} else {\n\t\t\tsp->dscp = params->spp_dscp & SCTP_DSCP_VAL_MASK;\n\t\t\tsp->dscp |= SCTP_DSCP_SET_MASK;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_peer_addr_params(struct sock *sk,\n\t\t\t\t\t    struct sctp_paddrparams *params,\n\t\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_transport   *trans = NULL;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_sock        *sp = sctp_sk(sk);\n\tint error;\n\tint hb_change, pmtud_change, sackdelay_change;\n\n\tif (optlen == ALIGN(offsetof(struct sctp_paddrparams,\n\t\t\t\t\t    spp_ipv6_flowlabel), 4)) {\n\t\tif (params->spp_flags & (SPP_DSCP | SPP_IPV6_FLOWLABEL))\n\t\t\treturn -EINVAL;\n\t} else if (optlen != sizeof(*params)) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Validate flags and value parameters. */\n\thb_change        = params->spp_flags & SPP_HB;\n\tpmtud_change     = params->spp_flags & SPP_PMTUD;\n\tsackdelay_change = params->spp_flags & SPP_SACKDELAY;\n\n\tif (hb_change        == SPP_HB ||\n\t    pmtud_change     == SPP_PMTUD ||\n\t    sackdelay_change == SPP_SACKDELAY ||\n\t    params->spp_sackdelay > 500 ||\n\t    (params->spp_pathmtu &&\n\t     params->spp_pathmtu < SCTP_DEFAULT_MINSEGMENT))\n\t\treturn -EINVAL;\n\n\t/* If an address other than INADDR_ANY is specified, and\n\t * no transport is found, then the request is invalid.\n\t */\n\tif (!sctp_is_any(sk, (union sctp_addr *)&params->spp_address)) {\n\t\ttrans = sctp_addr_id2transport(sk, &params->spp_address,\n\t\t\t\t\t       params->spp_assoc_id);\n\t\tif (!trans)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* Get association, if assoc_id != SCTP_FUTURE_ASSOC and the\n\t * socket is a one to many style socket, and an association\n\t * was not found, then the id was invalid.\n\t */\n\tasoc = sctp_id2assoc(sk, params->spp_assoc_id);\n\tif (!asoc && params->spp_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Heartbeat demand can only be sent on a transport or\n\t * association, but not a socket.\n\t */\n\tif (params->spp_flags & SPP_HB_DEMAND && !trans && !asoc)\n\t\treturn -EINVAL;\n\n\t/* Process parameters. */\n\terror = sctp_apply_peer_addr_params(params, trans, asoc, sp,\n\t\t\t\t\t    hb_change, pmtud_change,\n\t\t\t\t\t    sackdelay_change);\n\n\tif (error)\n\t\treturn error;\n\n\t/* If changes are for association, also apply parameters to each\n\t * transport.\n\t */\n\tif (!trans && asoc) {\n\t\tlist_for_each_entry(trans, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\t\tsctp_apply_peer_addr_params(params, trans, asoc, sp,\n\t\t\t\t\t\t    hb_change, pmtud_change,\n\t\t\t\t\t\t    sackdelay_change);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline __u32 sctp_spp_sackdelay_enable(__u32 param_flags)\n{\n\treturn (param_flags & ~SPP_SACKDELAY) | SPP_SACKDELAY_ENABLE;\n}\n\nstatic inline __u32 sctp_spp_sackdelay_disable(__u32 param_flags)\n{\n\treturn (param_flags & ~SPP_SACKDELAY) | SPP_SACKDELAY_DISABLE;\n}\n\nstatic void sctp_apply_asoc_delayed_ack(struct sctp_sack_info *params,\n\t\t\t\t\tstruct sctp_association *asoc)\n{\n\tstruct sctp_transport *trans;\n\n\tif (params->sack_delay) {\n\t\tasoc->sackdelay = msecs_to_jiffies(params->sack_delay);\n\t\tasoc->param_flags =\n\t\t\tsctp_spp_sackdelay_enable(asoc->param_flags);\n\t}\n\tif (params->sack_freq == 1) {\n\t\tasoc->param_flags =\n\t\t\tsctp_spp_sackdelay_disable(asoc->param_flags);\n\t} else if (params->sack_freq > 1) {\n\t\tasoc->sackfreq = params->sack_freq;\n\t\tasoc->param_flags =\n\t\t\tsctp_spp_sackdelay_enable(asoc->param_flags);\n\t}\n\n\tlist_for_each_entry(trans, &asoc->peer.transport_addr_list,\n\t\t\t    transports) {\n\t\tif (params->sack_delay) {\n\t\t\ttrans->sackdelay = msecs_to_jiffies(params->sack_delay);\n\t\t\ttrans->param_flags =\n\t\t\t\tsctp_spp_sackdelay_enable(trans->param_flags);\n\t\t}\n\t\tif (params->sack_freq == 1) {\n\t\t\ttrans->param_flags =\n\t\t\t\tsctp_spp_sackdelay_disable(trans->param_flags);\n\t\t} else if (params->sack_freq > 1) {\n\t\t\ttrans->sackfreq = params->sack_freq;\n\t\t\ttrans->param_flags =\n\t\t\t\tsctp_spp_sackdelay_enable(trans->param_flags);\n\t\t}\n\t}\n}\n\n/*\n * 7.1.23.  Get or set delayed ack timer (SCTP_DELAYED_SACK)\n *\n * This option will effect the way delayed acks are performed.  This\n * option allows you to get or set the delayed ack time, in\n * milliseconds.  It also allows changing the delayed ack frequency.\n * Changing the frequency to 1 disables the delayed sack algorithm.  If\n * the assoc_id is 0, then this sets or gets the endpoints default\n * values.  If the assoc_id field is non-zero, then the set or get\n * effects the specified association for the one to many model (the\n * assoc_id field is ignored by the one to one model).  Note that if\n * sack_delay or sack_freq are 0 when setting this option, then the\n * current values will remain unchanged.\n *\n * struct sctp_sack_info {\n *     sctp_assoc_t            sack_assoc_id;\n *     uint32_t                sack_delay;\n *     uint32_t                sack_freq;\n * };\n *\n * sack_assoc_id -  This parameter, indicates which association the user\n *    is performing an action upon.  Note that if this field's value is\n *    zero then the endpoints default value is changed (effecting future\n *    associations only).\n *\n * sack_delay -  This parameter contains the number of milliseconds that\n *    the user is requesting the delayed ACK timer be set to.  Note that\n *    this value is defined in the standard to be between 200 and 500\n *    milliseconds.\n *\n * sack_freq -  This parameter contains the number of packets that must\n *    be received before a sack is sent without waiting for the delay\n *    timer to expire.  The default value for this is 2, setting this\n *    value to 1 will disable the delayed sack algorithm.\n */\nstatic int __sctp_setsockopt_delayed_ack(struct sock *sk,\n\t\t\t\t\t struct sctp_sack_info *params)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\n\t/* Validate value parameter. */\n\tif (params->sack_delay > 500)\n\t\treturn -EINVAL;\n\n\t/* Get association, if sack_assoc_id != SCTP_FUTURE_ASSOC and the\n\t * socket is a one to many style socket, and an association\n\t * was not found, then the id was invalid.\n\t */\n\tasoc = sctp_id2assoc(sk, params->sack_assoc_id);\n\tif (!asoc && params->sack_assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tsctp_apply_asoc_delayed_ack(params, asoc);\n\n\t\treturn 0;\n\t}\n\n\tif (sctp_style(sk, TCP))\n\t\tparams->sack_assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (params->sack_assoc_id == SCTP_FUTURE_ASSOC ||\n\t    params->sack_assoc_id == SCTP_ALL_ASSOC) {\n\t\tif (params->sack_delay) {\n\t\t\tsp->sackdelay = params->sack_delay;\n\t\t\tsp->param_flags =\n\t\t\t\tsctp_spp_sackdelay_enable(sp->param_flags);\n\t\t}\n\t\tif (params->sack_freq == 1) {\n\t\t\tsp->param_flags =\n\t\t\t\tsctp_spp_sackdelay_disable(sp->param_flags);\n\t\t} else if (params->sack_freq > 1) {\n\t\t\tsp->sackfreq = params->sack_freq;\n\t\t\tsp->param_flags =\n\t\t\t\tsctp_spp_sackdelay_enable(sp->param_flags);\n\t\t}\n\t}\n\n\tif (params->sack_assoc_id == SCTP_CURRENT_ASSOC ||\n\t    params->sack_assoc_id == SCTP_ALL_ASSOC)\n\t\tlist_for_each_entry(asoc, &sp->ep->asocs, asocs)\n\t\t\tsctp_apply_asoc_delayed_ack(params, asoc);\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_delayed_ack(struct sock *sk,\n\t\t\t\t       struct sctp_sack_info *params,\n\t\t\t\t       unsigned int optlen)\n{\n\tif (optlen == sizeof(struct sctp_assoc_value)) {\n\t\tstruct sctp_assoc_value *v = (struct sctp_assoc_value *)params;\n\t\tstruct sctp_sack_info p;\n\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of struct sctp_assoc_value in delayed_ack socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_sack_info instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\n\t\tp.sack_assoc_id = v->assoc_id;\n\t\tp.sack_delay = v->assoc_value;\n\t\tp.sack_freq = v->assoc_value ? 0 : 1;\n\t\treturn __sctp_setsockopt_delayed_ack(sk, &p);\n\t}\n\n\tif (optlen != sizeof(struct sctp_sack_info))\n\t\treturn -EINVAL;\n\tif (params->sack_delay == 0 && params->sack_freq == 0)\n\t\treturn 0;\n\treturn __sctp_setsockopt_delayed_ack(sk, params);\n}\n\n/* 7.1.3 Initialization Parameters (SCTP_INITMSG)\n *\n * Applications can specify protocol parameters for the default association\n * initialization.  The option name argument to setsockopt() and getsockopt()\n * is SCTP_INITMSG.\n *\n * Setting initialization parameters is effective only on an unconnected\n * socket (for UDP-style sockets only future associations are effected\n * by the change).  With TCP-style sockets, this option is inherited by\n * sockets derived from a listener socket.\n */\nstatic int sctp_setsockopt_initmsg(struct sock *sk, struct sctp_initmsg *sinit,\n\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (optlen != sizeof(struct sctp_initmsg))\n\t\treturn -EINVAL;\n\n\tif (sinit->sinit_num_ostreams)\n\t\tsp->initmsg.sinit_num_ostreams = sinit->sinit_num_ostreams;\n\tif (sinit->sinit_max_instreams)\n\t\tsp->initmsg.sinit_max_instreams = sinit->sinit_max_instreams;\n\tif (sinit->sinit_max_attempts)\n\t\tsp->initmsg.sinit_max_attempts = sinit->sinit_max_attempts;\n\tif (sinit->sinit_max_init_timeo)\n\t\tsp->initmsg.sinit_max_init_timeo = sinit->sinit_max_init_timeo;\n\n\treturn 0;\n}\n\n/*\n * 7.1.14 Set default send parameters (SCTP_DEFAULT_SEND_PARAM)\n *\n *   Applications that wish to use the sendto() system call may wish to\n *   specify a default set of parameters that would normally be supplied\n *   through the inclusion of ancillary data.  This socket option allows\n *   such an application to set the default sctp_sndrcvinfo structure.\n *   The application that wishes to use this socket option simply passes\n *   in to this call the sctp_sndrcvinfo structure defined in Section\n *   5.2.2) The input parameters accepted by this call include\n *   sinfo_stream, sinfo_flags, sinfo_ppid, sinfo_context,\n *   sinfo_timetolive.  The user must provide the sinfo_assoc_id field in\n *   to this call if the caller is using the UDP model.\n */\nstatic int sctp_setsockopt_default_send_param(struct sock *sk,\n\t\t\t\t\t      struct sctp_sndrcvinfo *info,\n\t\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(*info))\n\t\treturn -EINVAL;\n\tif (info->sinfo_flags &\n\t    ~(SCTP_UNORDERED | SCTP_ADDR_OVER |\n\t      SCTP_ABORT | SCTP_EOF))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, info->sinfo_assoc_id);\n\tif (!asoc && info->sinfo_assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tasoc->default_stream = info->sinfo_stream;\n\t\tasoc->default_flags = info->sinfo_flags;\n\t\tasoc->default_ppid = info->sinfo_ppid;\n\t\tasoc->default_context = info->sinfo_context;\n\t\tasoc->default_timetolive = info->sinfo_timetolive;\n\n\t\treturn 0;\n\t}\n\n\tif (sctp_style(sk, TCP))\n\t\tinfo->sinfo_assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (info->sinfo_assoc_id == SCTP_FUTURE_ASSOC ||\n\t    info->sinfo_assoc_id == SCTP_ALL_ASSOC) {\n\t\tsp->default_stream = info->sinfo_stream;\n\t\tsp->default_flags = info->sinfo_flags;\n\t\tsp->default_ppid = info->sinfo_ppid;\n\t\tsp->default_context = info->sinfo_context;\n\t\tsp->default_timetolive = info->sinfo_timetolive;\n\t}\n\n\tif (info->sinfo_assoc_id == SCTP_CURRENT_ASSOC ||\n\t    info->sinfo_assoc_id == SCTP_ALL_ASSOC) {\n\t\tlist_for_each_entry(asoc, &sp->ep->asocs, asocs) {\n\t\t\tasoc->default_stream = info->sinfo_stream;\n\t\t\tasoc->default_flags = info->sinfo_flags;\n\t\t\tasoc->default_ppid = info->sinfo_ppid;\n\t\t\tasoc->default_context = info->sinfo_context;\n\t\t\tasoc->default_timetolive = info->sinfo_timetolive;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* RFC6458, Section 8.1.31. Set/get Default Send Parameters\n * (SCTP_DEFAULT_SNDINFO)\n */\nstatic int sctp_setsockopt_default_sndinfo(struct sock *sk,\n\t\t\t\t\t   struct sctp_sndinfo *info,\n\t\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(*info))\n\t\treturn -EINVAL;\n\tif (info->snd_flags &\n\t    ~(SCTP_UNORDERED | SCTP_ADDR_OVER |\n\t      SCTP_ABORT | SCTP_EOF))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, info->snd_assoc_id);\n\tif (!asoc && info->snd_assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tasoc->default_stream = info->snd_sid;\n\t\tasoc->default_flags = info->snd_flags;\n\t\tasoc->default_ppid = info->snd_ppid;\n\t\tasoc->default_context = info->snd_context;\n\n\t\treturn 0;\n\t}\n\n\tif (sctp_style(sk, TCP))\n\t\tinfo->snd_assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (info->snd_assoc_id == SCTP_FUTURE_ASSOC ||\n\t    info->snd_assoc_id == SCTP_ALL_ASSOC) {\n\t\tsp->default_stream = info->snd_sid;\n\t\tsp->default_flags = info->snd_flags;\n\t\tsp->default_ppid = info->snd_ppid;\n\t\tsp->default_context = info->snd_context;\n\t}\n\n\tif (info->snd_assoc_id == SCTP_CURRENT_ASSOC ||\n\t    info->snd_assoc_id == SCTP_ALL_ASSOC) {\n\t\tlist_for_each_entry(asoc, &sp->ep->asocs, asocs) {\n\t\t\tasoc->default_stream = info->snd_sid;\n\t\t\tasoc->default_flags = info->snd_flags;\n\t\t\tasoc->default_ppid = info->snd_ppid;\n\t\t\tasoc->default_context = info->snd_context;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* 7.1.10 Set Primary Address (SCTP_PRIMARY_ADDR)\n *\n * Requests that the local SCTP stack use the enclosed peer address as\n * the association primary.  The enclosed address must be one of the\n * association peer's addresses.\n */\nstatic int sctp_setsockopt_primary_addr(struct sock *sk, struct sctp_prim *prim,\n\t\t\t\t\tunsigned int optlen)\n{\n\tstruct sctp_transport *trans;\n\tstruct sctp_af *af;\n\tint err;\n\n\tif (optlen != sizeof(struct sctp_prim))\n\t\treturn -EINVAL;\n\n\t/* Allow security module to validate address but need address len. */\n\taf = sctp_get_af_specific(prim->ssp_addr.ss_family);\n\tif (!af)\n\t\treturn -EINVAL;\n\n\terr = security_sctp_bind_connect(sk, SCTP_PRIMARY_ADDR,\n\t\t\t\t\t (struct sockaddr *)&prim->ssp_addr,\n\t\t\t\t\t af->sockaddr_len);\n\tif (err)\n\t\treturn err;\n\n\ttrans = sctp_addr_id2transport(sk, &prim->ssp_addr, prim->ssp_assoc_id);\n\tif (!trans)\n\t\treturn -EINVAL;\n\n\tsctp_assoc_set_primary(trans->asoc, trans);\n\n\treturn 0;\n}\n\n/*\n * 7.1.5 SCTP_NODELAY\n *\n * Turn on/off any Nagle-like algorithm.  This means that packets are\n * generally sent as soon as possible and no unnecessary delays are\n * introduced, at the cost of more packets in the network.  Expects an\n *  integer boolean flag.\n */\nstatic int sctp_setsockopt_nodelay(struct sock *sk, int *val,\n\t\t\t\t   unsigned int optlen)\n{\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tsctp_sk(sk)->nodelay = (*val == 0) ? 0 : 1;\n\treturn 0;\n}\n\n/*\n *\n * 7.1.1 SCTP_RTOINFO\n *\n * The protocol parameters used to initialize and bound retransmission\n * timeout (RTO) are tunable. sctp_rtoinfo structure is used to access\n * and modify these parameters.\n * All parameters are time values, in milliseconds.  A value of 0, when\n * modifying the parameters, indicates that the current value should not\n * be changed.\n *\n */\nstatic int sctp_setsockopt_rtoinfo(struct sock *sk,\n\t\t\t\t   struct sctp_rtoinfo *rtoinfo,\n\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tunsigned long rto_min, rto_max;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (optlen != sizeof (struct sctp_rtoinfo))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, rtoinfo->srto_assoc_id);\n\n\t/* Set the values to the specific association */\n\tif (!asoc && rtoinfo->srto_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\trto_max = rtoinfo->srto_max;\n\trto_min = rtoinfo->srto_min;\n\n\tif (rto_max)\n\t\trto_max = asoc ? msecs_to_jiffies(rto_max) : rto_max;\n\telse\n\t\trto_max = asoc ? asoc->rto_max : sp->rtoinfo.srto_max;\n\n\tif (rto_min)\n\t\trto_min = asoc ? msecs_to_jiffies(rto_min) : rto_min;\n\telse\n\t\trto_min = asoc ? asoc->rto_min : sp->rtoinfo.srto_min;\n\n\tif (rto_min > rto_max)\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tif (rtoinfo->srto_initial != 0)\n\t\t\tasoc->rto_initial =\n\t\t\t\tmsecs_to_jiffies(rtoinfo->srto_initial);\n\t\tasoc->rto_max = rto_max;\n\t\tasoc->rto_min = rto_min;\n\t} else {\n\t\t/* If there is no association or the association-id = 0\n\t\t * set the values to the endpoint.\n\t\t */\n\t\tif (rtoinfo->srto_initial != 0)\n\t\t\tsp->rtoinfo.srto_initial = rtoinfo->srto_initial;\n\t\tsp->rtoinfo.srto_max = rto_max;\n\t\tsp->rtoinfo.srto_min = rto_min;\n\t}\n\n\treturn 0;\n}\n\n/*\n *\n * 7.1.2 SCTP_ASSOCINFO\n *\n * This option is used to tune the maximum retransmission attempts\n * of the association.\n * Returns an error if the new association retransmission value is\n * greater than the sum of the retransmission value  of the peer.\n * See [SCTP] for more information.\n *\n */\nstatic int sctp_setsockopt_associnfo(struct sock *sk,\n\t\t\t\t     struct sctp_assocparams *assocparams,\n\t\t\t\t     unsigned int optlen)\n{\n\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(struct sctp_assocparams))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, assocparams->sasoc_assoc_id);\n\n\tif (!asoc && assocparams->sasoc_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Set the values to the specific association */\n\tif (asoc) {\n\t\tif (assocparams->sasoc_asocmaxrxt != 0) {\n\t\t\t__u32 path_sum = 0;\n\t\t\tint   paths = 0;\n\t\t\tstruct sctp_transport *peer_addr;\n\n\t\t\tlist_for_each_entry(peer_addr, &asoc->peer.transport_addr_list,\n\t\t\t\t\ttransports) {\n\t\t\t\tpath_sum += peer_addr->pathmaxrxt;\n\t\t\t\tpaths++;\n\t\t\t}\n\n\t\t\t/* Only validate asocmaxrxt if we have more than\n\t\t\t * one path/transport.  We do this because path\n\t\t\t * retransmissions are only counted when we have more\n\t\t\t * then one path.\n\t\t\t */\n\t\t\tif (paths > 1 &&\n\t\t\t    assocparams->sasoc_asocmaxrxt > path_sum)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tasoc->max_retrans = assocparams->sasoc_asocmaxrxt;\n\t\t}\n\n\t\tif (assocparams->sasoc_cookie_life != 0)\n\t\t\tasoc->cookie_life =\n\t\t\t\tms_to_ktime(assocparams->sasoc_cookie_life);\n\t} else {\n\t\t/* Set the values to the endpoint */\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tif (assocparams->sasoc_asocmaxrxt != 0)\n\t\t\tsp->assocparams.sasoc_asocmaxrxt =\n\t\t\t\t\t\tassocparams->sasoc_asocmaxrxt;\n\t\tif (assocparams->sasoc_cookie_life != 0)\n\t\t\tsp->assocparams.sasoc_cookie_life =\n\t\t\t\t\t\tassocparams->sasoc_cookie_life;\n\t}\n\treturn 0;\n}\n\n/*\n * 7.1.16 Set/clear IPv4 mapped addresses (SCTP_I_WANT_MAPPED_V4_ADDR)\n *\n * This socket option is a boolean flag which turns on or off mapped V4\n * addresses.  If this option is turned on and the socket is type\n * PF_INET6, then IPv4 addresses will be mapped to V6 representation.\n * If this option is turned off, then no mapping will be done of V4\n * addresses and a user will receive both PF_INET6 and PF_INET type\n * addresses on the socket.\n */\nstatic int sctp_setsockopt_mappedv4(struct sock *sk, int *val,\n\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (*val)\n\t\tsp->v4mapped = 1;\n\telse\n\t\tsp->v4mapped = 0;\n\n\treturn 0;\n}\n\n/*\n * 8.1.16.  Get or Set the Maximum Fragmentation Size (SCTP_MAXSEG)\n * This option will get or set the maximum size to put in any outgoing\n * SCTP DATA chunk.  If a message is larger than this size it will be\n * fragmented by SCTP into the specified size.  Note that the underlying\n * SCTP implementation may fragment into smaller sized chunks when the\n * PMTU of the underlying association is smaller than the value set by\n * the user.  The default value for this option is '0' which indicates\n * the user is NOT limiting fragmentation and only the PMTU will effect\n * SCTP's choice of DATA chunk size.  Note also that values set larger\n * than the maximum size of an IP datagram will effectively let SCTP\n * control fragmentation (i.e. the same as setting this option to 0).\n *\n * The following structure is used to access and modify this parameter:\n *\n * struct sctp_assoc_value {\n *   sctp_assoc_t assoc_id;\n *   uint32_t assoc_value;\n * };\n *\n * assoc_id:  This parameter is ignored for one-to-one style sockets.\n *    For one-to-many style sockets this parameter indicates which\n *    association the user is performing an action upon.  Note that if\n *    this field's value is zero then the endpoints default value is\n *    changed (effecting future associations only).\n * assoc_value:  This parameter specifies the maximum size in bytes.\n */\nstatic int sctp_setsockopt_maxseg(struct sock *sk,\n\t\t\t\t  struct sctp_assoc_value *params,\n\t\t\t\t  unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tsctp_assoc_t assoc_id;\n\tint val;\n\n\tif (optlen == sizeof(int)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of int in maxseg socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_assoc_value instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tassoc_id = SCTP_FUTURE_ASSOC;\n\t\tval = *(int *)params;\n\t} else if (optlen == sizeof(struct sctp_assoc_value)) {\n\t\tassoc_id = params->assoc_id;\n\t\tval = params->assoc_value;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tasoc = sctp_id2assoc(sk, assoc_id);\n\tif (!asoc && assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (val) {\n\t\tint min_len, max_len;\n\t\t__u16 datasize = asoc ? sctp_datachk_len(&asoc->stream) :\n\t\t\t\t sizeof(struct sctp_data_chunk);\n\n\t\tmin_len = sctp_min_frag_point(sp, datasize);\n\t\tmax_len = SCTP_MAX_CHUNK_LEN - datasize;\n\n\t\tif (val < min_len || val > max_len)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (asoc) {\n\t\tasoc->user_frag = val;\n\t\tsctp_assoc_update_frag_point(asoc);\n\t} else {\n\t\tsp->user_frag = val;\n\t}\n\n\treturn 0;\n}\n\n\n/*\n *  7.1.9 Set Peer Primary Address (SCTP_SET_PEER_PRIMARY_ADDR)\n *\n *   Requests that the peer mark the enclosed address as the association\n *   primary. The enclosed address must be one of the association's\n *   locally bound addresses. The following structure is used to make a\n *   set primary request:\n */\nstatic int sctp_setsockopt_peer_primary_addr(struct sock *sk,\n\t\t\t\t\t     struct sctp_setpeerprim *prim,\n\t\t\t\t\t     unsigned int optlen)\n{\n\tstruct sctp_sock\t*sp;\n\tstruct sctp_association\t*asoc = NULL;\n\tstruct sctp_chunk\t*chunk;\n\tstruct sctp_af\t\t*af;\n\tint \t\t\terr;\n\n\tsp = sctp_sk(sk);\n\n\tif (!sp->ep->asconf_enable)\n\t\treturn -EPERM;\n\n\tif (optlen != sizeof(struct sctp_setpeerprim))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, prim->sspp_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tif (!asoc->peer.asconf_capable)\n\t\treturn -EPERM;\n\n\tif (asoc->peer.addip_disabled_mask & SCTP_PARAM_SET_PRIMARY)\n\t\treturn -EPERM;\n\n\tif (!sctp_state(asoc, ESTABLISHED))\n\t\treturn -ENOTCONN;\n\n\taf = sctp_get_af_specific(prim->sspp_addr.ss_family);\n\tif (!af)\n\t\treturn -EINVAL;\n\n\tif (!af->addr_valid((union sctp_addr *)&prim->sspp_addr, sp, NULL))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (!sctp_assoc_lookup_laddr(asoc, (union sctp_addr *)&prim->sspp_addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* Allow security module to validate address. */\n\terr = security_sctp_bind_connect(sk, SCTP_SET_PEER_PRIMARY_ADDR,\n\t\t\t\t\t (struct sockaddr *)&prim->sspp_addr,\n\t\t\t\t\t af->sockaddr_len);\n\tif (err)\n\t\treturn err;\n\n\t/* Create an ASCONF chunk with SET_PRIMARY parameter\t*/\n\tchunk = sctp_make_asconf_set_prim(asoc,\n\t\t\t\t\t  (union sctp_addr *)&prim->sspp_addr);\n\tif (!chunk)\n\t\treturn -ENOMEM;\n\n\terr = sctp_send_asconf(asoc, chunk);\n\n\tpr_debug(\"%s: we set peer primary addr primitively\\n\", __func__);\n\n\treturn err;\n}\n\nstatic int sctp_setsockopt_adaptation_layer(struct sock *sk,\n\t\t\t\t\t    struct sctp_setadaptation *adapt,\n\t\t\t\t\t    unsigned int optlen)\n{\n\tif (optlen != sizeof(struct sctp_setadaptation))\n\t\treturn -EINVAL;\n\n\tsctp_sk(sk)->adaptation_ind = adapt->ssb_adaptation_ind;\n\n\treturn 0;\n}\n\n/*\n * 7.1.29.  Set or Get the default context (SCTP_CONTEXT)\n *\n * The context field in the sctp_sndrcvinfo structure is normally only\n * used when a failed message is retrieved holding the value that was\n * sent down on the actual send call.  This option allows the setting of\n * a default context on an association basis that will be received on\n * reading messages from the peer.  This is especially helpful in the\n * one-2-many model for an application to keep some reference to an\n * internal state machine that is processing messages on the\n * association.  Note that the setting of this value only effects\n * received messages from the peer and does not effect the value that is\n * saved with outbound messages.\n */\nstatic int sctp_setsockopt_context(struct sock *sk,\n\t\t\t\t   struct sctp_assoc_value *params,\n\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(struct sctp_assoc_value))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tasoc->default_rcv_context = params->assoc_value;\n\n\t\treturn 0;\n\t}\n\n\tif (sctp_style(sk, TCP))\n\t\tparams->assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (params->assoc_id == SCTP_FUTURE_ASSOC ||\n\t    params->assoc_id == SCTP_ALL_ASSOC)\n\t\tsp->default_rcv_context = params->assoc_value;\n\n\tif (params->assoc_id == SCTP_CURRENT_ASSOC ||\n\t    params->assoc_id == SCTP_ALL_ASSOC)\n\t\tlist_for_each_entry(asoc, &sp->ep->asocs, asocs)\n\t\t\tasoc->default_rcv_context = params->assoc_value;\n\n\treturn 0;\n}\n\n/*\n * 7.1.24.  Get or set fragmented interleave (SCTP_FRAGMENT_INTERLEAVE)\n *\n * This options will at a minimum specify if the implementation is doing\n * fragmented interleave.  Fragmented interleave, for a one to many\n * socket, is when subsequent calls to receive a message may return\n * parts of messages from different associations.  Some implementations\n * may allow you to turn this value on or off.  If so, when turned off,\n * no fragment interleave will occur (which will cause a head of line\n * blocking amongst multiple associations sharing the same one to many\n * socket).  When this option is turned on, then each receive call may\n * come from a different association (thus the user must receive data\n * with the extended calls (e.g. sctp_recvmsg) to keep track of which\n * association each receive belongs to.\n *\n * This option takes a boolean value.  A non-zero value indicates that\n * fragmented interleave is on.  A value of zero indicates that\n * fragmented interleave is off.\n *\n * Note that it is important that an implementation that allows this\n * option to be turned on, have it off by default.  Otherwise an unaware\n * application using the one to many model may become confused and act\n * incorrectly.\n */\nstatic int sctp_setsockopt_fragment_interleave(struct sock *sk, int *val,\n\t\t\t\t\t       unsigned int optlen)\n{\n\tif (optlen != sizeof(int))\n\t\treturn -EINVAL;\n\n\tsctp_sk(sk)->frag_interleave = !!*val;\n\n\tif (!sctp_sk(sk)->frag_interleave)\n\t\tsctp_sk(sk)->ep->intl_enable = 0;\n\n\treturn 0;\n}\n\n/*\n * 8.1.21.  Set or Get the SCTP Partial Delivery Point\n *       (SCTP_PARTIAL_DELIVERY_POINT)\n *\n * This option will set or get the SCTP partial delivery point.  This\n * point is the size of a message where the partial delivery API will be\n * invoked to help free up rwnd space for the peer.  Setting this to a\n * lower value will cause partial deliveries to happen more often.  The\n * calls argument is an integer that sets or gets the partial delivery\n * point.  Note also that the call will fail if the user attempts to set\n * this value larger than the socket receive buffer size.\n *\n * Note that any single message having a length smaller than or equal to\n * the SCTP partial delivery point will be delivered in one single read\n * call as long as the user provided buffer is large enough to hold the\n * message.\n */\nstatic int sctp_setsockopt_partial_delivery_point(struct sock *sk, u32 *val,\n\t\t\t\t\t\t  unsigned int optlen)\n{\n\tif (optlen != sizeof(u32))\n\t\treturn -EINVAL;\n\n\t/* Note: We double the receive buffer from what the user sets\n\t * it to be, also initial rwnd is based on rcvbuf/2.\n\t */\n\tif (*val > (sk->sk_rcvbuf >> 1))\n\t\treturn -EINVAL;\n\n\tsctp_sk(sk)->pd_point = *val;\n\n\treturn 0; /* is this the right error code? */\n}\n\n/*\n * 7.1.28.  Set or Get the maximum burst (SCTP_MAX_BURST)\n *\n * This option will allow a user to change the maximum burst of packets\n * that can be emitted by this association.  Note that the default value\n * is 4, and some implementations may restrict this setting so that it\n * can only be lowered.\n *\n * NOTE: This text doesn't seem right.  Do this on a socket basis with\n * future associations inheriting the socket value.\n */\nstatic int sctp_setsockopt_maxburst(struct sock *sk,\n\t\t\t\t    struct sctp_assoc_value *params,\n\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tsctp_assoc_t assoc_id;\n\tu32 assoc_value;\n\n\tif (optlen == sizeof(int)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of int in max_burst socket option deprecated.\\n\"\n\t\t\t\t    \"Use struct sctp_assoc_value instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tassoc_id = SCTP_FUTURE_ASSOC;\n\t\tassoc_value = *((int *)params);\n\t} else if (optlen == sizeof(struct sctp_assoc_value)) {\n\t\tassoc_id = params->assoc_id;\n\t\tassoc_value = params->assoc_value;\n\t} else\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, assoc_id);\n\tif (!asoc && assoc_id > SCTP_ALL_ASSOC && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tasoc->max_burst = assoc_value;\n\n\t\treturn 0;\n\t}\n\n\tif (sctp_style(sk, TCP))\n\t\tassoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (assoc_id == SCTP_FUTURE_ASSOC || assoc_id == SCTP_ALL_ASSOC)\n\t\tsp->max_burst = assoc_value;\n\n\tif (assoc_id == SCTP_CURRENT_ASSOC || assoc_id == SCTP_ALL_ASSOC)\n\t\tlist_for_each_entry(asoc, &sp->ep->asocs, asocs)\n\t\t\tasoc->max_burst = assoc_value;\n\n\treturn 0;\n}\n\n/*\n * 7.1.18.  Add a chunk that must be authenticated (SCTP_AUTH_CHUNK)\n *\n * This set option adds a chunk type that the user is requesting to be\n * received only in an authenticated way.  Changes to the list of chunks\n * will only effect future associations on the socket.\n */\nstatic int sctp_setsockopt_auth_chunk(struct sock *sk,\n\t\t\t\t      struct sctp_authchunk *val,\n\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen != sizeof(struct sctp_authchunk))\n\t\treturn -EINVAL;\n\n\tswitch (val->sauth_chunk) {\n\tcase SCTP_CID_INIT:\n\tcase SCTP_CID_INIT_ACK:\n\tcase SCTP_CID_SHUTDOWN_COMPLETE:\n\tcase SCTP_CID_AUTH:\n\t\treturn -EINVAL;\n\t}\n\n\t/* add this chunk id to the endpoint */\n\treturn sctp_auth_ep_add_chunkid(ep, val->sauth_chunk);\n}\n\n/*\n * 7.1.19.  Get or set the list of supported HMAC Identifiers (SCTP_HMAC_IDENT)\n *\n * This option gets or sets the list of HMAC algorithms that the local\n * endpoint requires the peer to use.\n */\nstatic int sctp_setsockopt_hmac_ident(struct sock *sk,\n\t\t\t\t      struct sctp_hmacalgo *hmacs,\n\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tu32 idents;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen < sizeof(struct sctp_hmacalgo))\n\t\treturn -EINVAL;\n\toptlen = min_t(unsigned int, optlen, sizeof(struct sctp_hmacalgo) +\n\t\t\t\t\t     SCTP_AUTH_NUM_HMACS * sizeof(u16));\n\n\tidents = hmacs->shmac_num_idents;\n\tif (idents == 0 || idents > SCTP_AUTH_NUM_HMACS ||\n\t    (idents * sizeof(u16)) > (optlen - sizeof(struct sctp_hmacalgo)))\n\t\treturn -EINVAL;\n\n\treturn sctp_auth_ep_set_hmacs(ep, hmacs);\n}\n\n/*\n * 7.1.20.  Set a shared key (SCTP_AUTH_KEY)\n *\n * This option will set a shared secret key which is used to build an\n * association shared key.\n */\nstatic int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    struct sctp_authkey *authkey,\n\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_association *asoc;\n\tint ret = -EINVAL;\n\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\t/* authkey->sca_keylength is u16, so optlen can't be bigger than\n\t * this.\n\t */\n\toptlen = min_t(unsigned int, optlen, USHRT_MAX + sizeof(*authkey));\n\n\tif (authkey->sca_keylength > optlen - sizeof(*authkey))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\tgoto out;\n\n\tif (asoc) {\n\t\tret = sctp_auth_set_key(ep, asoc, authkey);\n\t\tgoto out;\n\t}\n\n\tif (sctp_style(sk, TCP))\n\t\tauthkey->sca_assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (authkey->sca_assoc_id == SCTP_FUTURE_ASSOC ||\n\t    authkey->sca_assoc_id == SCTP_ALL_ASSOC) {\n\t\tret = sctp_auth_set_key(ep, asoc, authkey);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = 0;\n\n\tif (authkey->sca_assoc_id == SCTP_CURRENT_ASSOC ||\n\t    authkey->sca_assoc_id == SCTP_ALL_ASSOC) {\n\t\tlist_for_each_entry(asoc, &ep->asocs, asocs) {\n\t\t\tint res = sctp_auth_set_key(ep, asoc, authkey);\n\n\t\t\tif (res && !ret)\n\t\t\t\tret = res;\n\t\t}\n\t}\n\nout:\n\tmemzero_explicit(authkey, optlen);\n\treturn ret;\n}\n\n/*\n * 7.1.21.  Get or set the active shared key (SCTP_AUTH_ACTIVE_KEY)\n *\n * This option will get or set the active shared key to be used to build\n * the association shared key.\n */\nstatic int sctp_setsockopt_active_key(struct sock *sk,\n\t\t\t\t      struct sctp_authkeyid *val,\n\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_association *asoc;\n\tint ret = 0;\n\n\tif (optlen != sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, val->scact_assoc_id);\n\tif (!asoc && val->scact_assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\treturn sctp_auth_set_active_key(ep, asoc, val->scact_keynumber);\n\n\tif (sctp_style(sk, TCP))\n\t\tval->scact_assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (val->scact_assoc_id == SCTP_FUTURE_ASSOC ||\n\t    val->scact_assoc_id == SCTP_ALL_ASSOC) {\n\t\tret = sctp_auth_set_active_key(ep, asoc, val->scact_keynumber);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (val->scact_assoc_id == SCTP_CURRENT_ASSOC ||\n\t    val->scact_assoc_id == SCTP_ALL_ASSOC) {\n\t\tlist_for_each_entry(asoc, &ep->asocs, asocs) {\n\t\t\tint res = sctp_auth_set_active_key(ep, asoc,\n\t\t\t\t\t\t\t   val->scact_keynumber);\n\n\t\t\tif (res && !ret)\n\t\t\t\tret = res;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/*\n * 7.1.22.  Delete a shared key (SCTP_AUTH_DELETE_KEY)\n *\n * This set option will delete a shared secret key from use.\n */\nstatic int sctp_setsockopt_del_key(struct sock *sk,\n\t\t\t\t   struct sctp_authkeyid *val,\n\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_association *asoc;\n\tint ret = 0;\n\n\tif (optlen != sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, val->scact_assoc_id);\n\tif (!asoc && val->scact_assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\treturn sctp_auth_del_key_id(ep, asoc, val->scact_keynumber);\n\n\tif (sctp_style(sk, TCP))\n\t\tval->scact_assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (val->scact_assoc_id == SCTP_FUTURE_ASSOC ||\n\t    val->scact_assoc_id == SCTP_ALL_ASSOC) {\n\t\tret = sctp_auth_del_key_id(ep, asoc, val->scact_keynumber);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (val->scact_assoc_id == SCTP_CURRENT_ASSOC ||\n\t    val->scact_assoc_id == SCTP_ALL_ASSOC) {\n\t\tlist_for_each_entry(asoc, &ep->asocs, asocs) {\n\t\t\tint res = sctp_auth_del_key_id(ep, asoc,\n\t\t\t\t\t\t       val->scact_keynumber);\n\n\t\t\tif (res && !ret)\n\t\t\t\tret = res;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/*\n * 8.3.4  Deactivate a Shared Key (SCTP_AUTH_DEACTIVATE_KEY)\n *\n * This set option will deactivate a shared secret key.\n */\nstatic int sctp_setsockopt_deactivate_key(struct sock *sk,\n\t\t\t\t\t  struct sctp_authkeyid *val,\n\t\t\t\t\t  unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_association *asoc;\n\tint ret = 0;\n\n\tif (optlen != sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, val->scact_assoc_id);\n\tif (!asoc && val->scact_assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\treturn sctp_auth_deact_key_id(ep, asoc, val->scact_keynumber);\n\n\tif (sctp_style(sk, TCP))\n\t\tval->scact_assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (val->scact_assoc_id == SCTP_FUTURE_ASSOC ||\n\t    val->scact_assoc_id == SCTP_ALL_ASSOC) {\n\t\tret = sctp_auth_deact_key_id(ep, asoc, val->scact_keynumber);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (val->scact_assoc_id == SCTP_CURRENT_ASSOC ||\n\t    val->scact_assoc_id == SCTP_ALL_ASSOC) {\n\t\tlist_for_each_entry(asoc, &ep->asocs, asocs) {\n\t\t\tint res = sctp_auth_deact_key_id(ep, asoc,\n\t\t\t\t\t\t\t val->scact_keynumber);\n\n\t\t\tif (res && !ret)\n\t\t\t\tret = res;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/*\n * 8.1.23 SCTP_AUTO_ASCONF\n *\n * This option will enable or disable the use of the automatic generation of\n * ASCONF chunks to add and delete addresses to an existing association.  Note\n * that this option has two caveats namely: a) it only affects sockets that\n * are bound to all addresses available to the SCTP stack, and b) the system\n * administrator may have an overriding control that turns the ASCONF feature\n * off no matter what setting the socket option may have.\n * This option expects an integer boolean flag, where a non-zero value turns on\n * the option, and a zero value turns off the option.\n * Note. In this implementation, socket operation overrides default parameter\n * being set by sysctl as well as FreeBSD implementation\n */\nstatic int sctp_setsockopt_auto_asconf(struct sock *sk, int *val,\n\t\t\t\t\tunsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (!sctp_is_ep_boundall(sk) && *val)\n\t\treturn -EINVAL;\n\tif ((*val && sp->do_auto_asconf) || (!*val && !sp->do_auto_asconf))\n\t\treturn 0;\n\n\tspin_lock_bh(&sock_net(sk)->sctp.addr_wq_lock);\n\tif (*val == 0 && sp->do_auto_asconf) {\n\t\tlist_del(&sp->auto_asconf_list);\n\t\tsp->do_auto_asconf = 0;\n\t} else if (*val && !sp->do_auto_asconf) {\n\t\tlist_add_tail(&sp->auto_asconf_list,\n\t\t    &sock_net(sk)->sctp.auto_asconf_splist);\n\t\tsp->do_auto_asconf = 1;\n\t}\n\tspin_unlock_bh(&sock_net(sk)->sctp.addr_wq_lock);\n\treturn 0;\n}\n\n/*\n * SCTP_PEER_ADDR_THLDS\n *\n * This option allows us to alter the partially failed threshold for one or all\n * transports in an association.  See Section 6.1 of:\n * http://www.ietf.org/id/draft-nishida-tsvwg-sctp-failover-05.txt\n */\nstatic int sctp_setsockopt_paddr_thresholds(struct sock *sk,\n\t\t\t\t\t    struct sctp_paddrthlds_v2 *val,\n\t\t\t\t\t    unsigned int optlen, bool v2)\n{\n\tstruct sctp_transport *trans;\n\tstruct sctp_association *asoc;\n\tint len;\n\n\tlen = v2 ? sizeof(*val) : sizeof(struct sctp_paddrthlds);\n\tif (optlen < len)\n\t\treturn -EINVAL;\n\n\tif (v2 && val->spt_pathpfthld > val->spt_pathcpthld)\n\t\treturn -EINVAL;\n\n\tif (!sctp_is_any(sk, (const union sctp_addr *)&val->spt_address)) {\n\t\ttrans = sctp_addr_id2transport(sk, &val->spt_address,\n\t\t\t\t\t       val->spt_assoc_id);\n\t\tif (!trans)\n\t\t\treturn -ENOENT;\n\n\t\tif (val->spt_pathmaxrxt)\n\t\t\ttrans->pathmaxrxt = val->spt_pathmaxrxt;\n\t\tif (v2)\n\t\t\ttrans->ps_retrans = val->spt_pathcpthld;\n\t\ttrans->pf_retrans = val->spt_pathpfthld;\n\n\t\treturn 0;\n\t}\n\n\tasoc = sctp_id2assoc(sk, val->spt_assoc_id);\n\tif (!asoc && val->spt_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tlist_for_each_entry(trans, &asoc->peer.transport_addr_list,\n\t\t\t\t    transports) {\n\t\t\tif (val->spt_pathmaxrxt)\n\t\t\t\ttrans->pathmaxrxt = val->spt_pathmaxrxt;\n\t\t\tif (v2)\n\t\t\t\ttrans->ps_retrans = val->spt_pathcpthld;\n\t\t\ttrans->pf_retrans = val->spt_pathpfthld;\n\t\t}\n\n\t\tif (val->spt_pathmaxrxt)\n\t\t\tasoc->pathmaxrxt = val->spt_pathmaxrxt;\n\t\tif (v2)\n\t\t\tasoc->ps_retrans = val->spt_pathcpthld;\n\t\tasoc->pf_retrans = val->spt_pathpfthld;\n\t} else {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tif (val->spt_pathmaxrxt)\n\t\t\tsp->pathmaxrxt = val->spt_pathmaxrxt;\n\t\tif (v2)\n\t\t\tsp->ps_retrans = val->spt_pathcpthld;\n\t\tsp->pf_retrans = val->spt_pathpfthld;\n\t}\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_recvrcvinfo(struct sock *sk, int *val,\n\t\t\t\t       unsigned int optlen)\n{\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tsctp_sk(sk)->recvrcvinfo = (*val == 0) ? 0 : 1;\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_recvnxtinfo(struct sock *sk, int *val,\n\t\t\t\t       unsigned int optlen)\n{\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tsctp_sk(sk)->recvnxtinfo = (*val == 0) ? 0 : 1;\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_pr_supported(struct sock *sk,\n\t\t\t\t\tstruct sctp_assoc_value *params,\n\t\t\t\t\tunsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(*params))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tsctp_sk(sk)->ep->prsctp_enable = !!params->assoc_value;\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_default_prinfo(struct sock *sk,\n\t\t\t\t\t  struct sctp_default_prinfo *info,\n\t\t\t\t\t  unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(*info))\n\t\tgoto out;\n\n\tif (info->pr_policy & ~SCTP_PR_SCTP_MASK)\n\t\tgoto out;\n\n\tif (info->pr_policy == SCTP_PR_SCTP_NONE)\n\t\tinfo->pr_value = 0;\n\n\tasoc = sctp_id2assoc(sk, info->pr_assoc_id);\n\tif (!asoc && info->pr_assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\tgoto out;\n\n\tretval = 0;\n\n\tif (asoc) {\n\t\tSCTP_PR_SET_POLICY(asoc->default_flags, info->pr_policy);\n\t\tasoc->default_timetolive = info->pr_value;\n\t\tgoto out;\n\t}\n\n\tif (sctp_style(sk, TCP))\n\t\tinfo->pr_assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (info->pr_assoc_id == SCTP_FUTURE_ASSOC ||\n\t    info->pr_assoc_id == SCTP_ALL_ASSOC) {\n\t\tSCTP_PR_SET_POLICY(sp->default_flags, info->pr_policy);\n\t\tsp->default_timetolive = info->pr_value;\n\t}\n\n\tif (info->pr_assoc_id == SCTP_CURRENT_ASSOC ||\n\t    info->pr_assoc_id == SCTP_ALL_ASSOC) {\n\t\tlist_for_each_entry(asoc, &sp->ep->asocs, asocs) {\n\t\t\tSCTP_PR_SET_POLICY(asoc->default_flags,\n\t\t\t\t\t   info->pr_policy);\n\t\t\tasoc->default_timetolive = info->pr_value;\n\t\t}\n\t}\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_reconfig_supported(struct sock *sk,\n\t\t\t\t\t      struct sctp_assoc_value *params,\n\t\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(*params))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\tgoto out;\n\n\tsctp_sk(sk)->ep->reconf_enable = !!params->assoc_value;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_enable_strreset(struct sock *sk,\n\t\t\t\t\t   struct sctp_assoc_value *params,\n\t\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_association *asoc;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(*params))\n\t\tgoto out;\n\n\tif (params->assoc_value & (~SCTP_ENABLE_STRRESET_MASK))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\tgoto out;\n\n\tretval = 0;\n\n\tif (asoc) {\n\t\tasoc->strreset_enable = params->assoc_value;\n\t\tgoto out;\n\t}\n\n\tif (sctp_style(sk, TCP))\n\t\tparams->assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (params->assoc_id == SCTP_FUTURE_ASSOC ||\n\t    params->assoc_id == SCTP_ALL_ASSOC)\n\t\tep->strreset_enable = params->assoc_value;\n\n\tif (params->assoc_id == SCTP_CURRENT_ASSOC ||\n\t    params->assoc_id == SCTP_ALL_ASSOC)\n\t\tlist_for_each_entry(asoc, &ep->asocs, asocs)\n\t\t\tasoc->strreset_enable = params->assoc_value;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_reset_streams(struct sock *sk,\n\t\t\t\t\t struct sctp_reset_streams *params,\n\t\t\t\t\t unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\n\tif (optlen < sizeof(*params))\n\t\treturn -EINVAL;\n\t/* srs_number_streams is u16, so optlen can't be bigger than this. */\n\toptlen = min_t(unsigned int, optlen, USHRT_MAX +\n\t\t\t\t\t     sizeof(__u16) * sizeof(*params));\n\n\tif (params->srs_number_streams * sizeof(__u16) >\n\t    optlen - sizeof(*params))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, params->srs_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\treturn sctp_send_reset_streams(asoc, params);\n}\n\nstatic int sctp_setsockopt_reset_assoc(struct sock *sk, sctp_assoc_t *associd,\n\t\t\t\t       unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(*associd))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, *associd);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\treturn sctp_send_reset_assoc(asoc);\n}\n\nstatic int sctp_setsockopt_add_streams(struct sock *sk,\n\t\t\t\t       struct sctp_add_streams *params,\n\t\t\t\t       unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(*params))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, params->sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\treturn sctp_send_add_streams(asoc, params);\n}\n\nstatic int sctp_setsockopt_scheduler(struct sock *sk,\n\t\t\t\t     struct sctp_assoc_value *params,\n\t\t\t\t     unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tint retval = 0;\n\n\tif (optlen < sizeof(*params))\n\t\treturn -EINVAL;\n\n\tif (params->assoc_value > SCTP_SS_MAX)\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\treturn sctp_sched_set_sched(asoc, params->assoc_value);\n\n\tif (sctp_style(sk, TCP))\n\t\tparams->assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (params->assoc_id == SCTP_FUTURE_ASSOC ||\n\t    params->assoc_id == SCTP_ALL_ASSOC)\n\t\tsp->default_ss = params->assoc_value;\n\n\tif (params->assoc_id == SCTP_CURRENT_ASSOC ||\n\t    params->assoc_id == SCTP_ALL_ASSOC) {\n\t\tlist_for_each_entry(asoc, &sp->ep->asocs, asocs) {\n\t\t\tint ret = sctp_sched_set_sched(asoc,\n\t\t\t\t\t\t       params->assoc_value);\n\n\t\t\tif (ret && !retval)\n\t\t\t\tretval = ret;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_scheduler_value(struct sock *sk,\n\t\t\t\t\t   struct sctp_stream_value *params,\n\t\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tint retval = -EINVAL;\n\n\tif (optlen < sizeof(*params))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id != SCTP_CURRENT_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\tgoto out;\n\n\tif (asoc) {\n\t\tretval = sctp_sched_set_value(asoc, params->stream_id,\n\t\t\t\t\t      params->stream_value, GFP_KERNEL);\n\t\tgoto out;\n\t}\n\n\tretval = 0;\n\n\tlist_for_each_entry(asoc, &sctp_sk(sk)->ep->asocs, asocs) {\n\t\tint ret = sctp_sched_set_value(asoc, params->stream_id,\n\t\t\t\t\t       params->stream_value,\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (ret && !retval) /* try to return the 1st error. */\n\t\t\tretval = ret;\n\t}\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_interleaving_supported(struct sock *sk,\n\t\t\t\t\t\t  struct sctp_assoc_value *p,\n\t\t\t\t\t\t  unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\n\tif (optlen < sizeof(*p))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, p->assoc_id);\n\tif (!asoc && p->assoc_id != SCTP_FUTURE_ASSOC && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (!sock_net(sk)->sctp.intl_enable || !sp->frag_interleave) {\n\t\treturn -EPERM;\n\t}\n\n\tsp->ep->intl_enable = !!p->assoc_value;\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_reuse_port(struct sock *sk, int *val,\n\t\t\t\t      unsigned int optlen)\n{\n\tif (!sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\n\tif (sctp_sk(sk)->ep->base.bind_addr.port)\n\t\treturn -EFAULT;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tsctp_sk(sk)->reuse = !!*val;\n\n\treturn 0;\n}\n\nstatic int sctp_assoc_ulpevent_type_set(struct sctp_event *param,\n\t\t\t\t\tstruct sctp_association *asoc)\n{\n\tstruct sctp_ulpevent *event;\n\n\tsctp_ulpevent_type_set(&asoc->subscribe, param->se_type, param->se_on);\n\n\tif (param->se_type == SCTP_SENDER_DRY_EVENT && param->se_on) {\n\t\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\t\tevent = sctp_ulpevent_make_sender_dry_event(asoc,\n\t\t\t\t\tGFP_USER | __GFP_NOWARN);\n\t\t\tif (!event)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tasoc->stream.si->enqueue_event(&asoc->ulpq, event);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_event(struct sock *sk, struct sctp_event *param,\n\t\t\t\t unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tint retval = 0;\n\n\tif (optlen < sizeof(*param))\n\t\treturn -EINVAL;\n\n\tif (param->se_type < SCTP_SN_TYPE_BASE ||\n\t    param->se_type > SCTP_SN_TYPE_MAX)\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, param->se_assoc_id);\n\tif (!asoc && param->se_assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\treturn sctp_assoc_ulpevent_type_set(param, asoc);\n\n\tif (sctp_style(sk, TCP))\n\t\tparam->se_assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (param->se_assoc_id == SCTP_FUTURE_ASSOC ||\n\t    param->se_assoc_id == SCTP_ALL_ASSOC)\n\t\tsctp_ulpevent_type_set(&sp->subscribe,\n\t\t\t\t       param->se_type, param->se_on);\n\n\tif (param->se_assoc_id == SCTP_CURRENT_ASSOC ||\n\t    param->se_assoc_id == SCTP_ALL_ASSOC) {\n\t\tlist_for_each_entry(asoc, &sp->ep->asocs, asocs) {\n\t\t\tint ret = sctp_assoc_ulpevent_type_set(param, asoc);\n\n\t\t\tif (ret && !retval)\n\t\t\t\tretval = ret;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_asconf_supported(struct sock *sk,\n\t\t\t\t\t    struct sctp_assoc_value *params,\n\t\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tstruct sctp_endpoint *ep;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(*params))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\tgoto out;\n\n\tep = sctp_sk(sk)->ep;\n\tep->asconf_enable = !!params->assoc_value;\n\n\tif (ep->asconf_enable && ep->auth_enable) {\n\t\tsctp_auth_ep_add_chunkid(ep, SCTP_CID_ASCONF);\n\t\tsctp_auth_ep_add_chunkid(ep, SCTP_CID_ASCONF_ACK);\n\t}\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_auth_supported(struct sock *sk,\n\t\t\t\t\t  struct sctp_assoc_value *params,\n\t\t\t\t\t  unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tstruct sctp_endpoint *ep;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(*params))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\tgoto out;\n\n\tep = sctp_sk(sk)->ep;\n\tif (params->assoc_value) {\n\t\tretval = sctp_auth_init(ep, GFP_KERNEL);\n\t\tif (retval)\n\t\t\tgoto out;\n\t\tif (ep->asconf_enable) {\n\t\t\tsctp_auth_ep_add_chunkid(ep, SCTP_CID_ASCONF);\n\t\t\tsctp_auth_ep_add_chunkid(ep, SCTP_CID_ASCONF_ACK);\n\t\t}\n\t}\n\n\tep->auth_enable = !!params->assoc_value;\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_ecn_supported(struct sock *sk,\n\t\t\t\t\t struct sctp_assoc_value *params,\n\t\t\t\t\t unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(*params))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\tgoto out;\n\n\tsctp_sk(sk)->ep->ecn_enable = !!params->assoc_value;\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_pf_expose(struct sock *sk,\n\t\t\t\t     struct sctp_assoc_value *params,\n\t\t\t\t     unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(*params))\n\t\tgoto out;\n\n\tif (params->assoc_value > SCTP_PF_EXPOSE_MAX)\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\tgoto out;\n\n\tif (asoc)\n\t\tasoc->pf_expose = params->assoc_value;\n\telse\n\t\tsctp_sk(sk)->pf_expose = params->assoc_value;\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_encap_port(struct sock *sk,\n\t\t\t\t      struct sctp_udpencaps *encap,\n\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tstruct sctp_transport *t;\n\t__be16 encap_port;\n\n\tif (optlen != sizeof(*encap))\n\t\treturn -EINVAL;\n\n\t/* If an address other than INADDR_ANY is specified, and\n\t * no transport is found, then the request is invalid.\n\t */\n\tencap_port = (__force __be16)encap->sue_port;\n\tif (!sctp_is_any(sk, (union sctp_addr *)&encap->sue_address)) {\n\t\tt = sctp_addr_id2transport(sk, &encap->sue_address,\n\t\t\t\t\t   encap->sue_assoc_id);\n\t\tif (!t)\n\t\t\treturn -EINVAL;\n\n\t\tt->encap_port = encap_port;\n\t\treturn 0;\n\t}\n\n\t/* Get association, if assoc_id != SCTP_FUTURE_ASSOC and the\n\t * socket is a one to many style socket, and an association\n\t * was not found, then the id was invalid.\n\t */\n\tasoc = sctp_id2assoc(sk, encap->sue_assoc_id);\n\tif (!asoc && encap->sue_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* If changes are for association, also apply encap_port to\n\t * each transport.\n\t */\n\tif (asoc) {\n\t\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\t\t    transports)\n\t\t\tt->encap_port = encap_port;\n\n\t\treturn 0;\n\t}\n\n\tsctp_sk(sk)->encap_port = encap_port;\n\treturn 0;\n}\n\n/* API 6.2 setsockopt(), getsockopt()\n *\n * Applications use setsockopt() and getsockopt() to set or retrieve\n * socket options.  Socket options are used to change the default\n * behavior of sockets calls.  They are described in Section 7.\n *\n * The syntax is:\n *\n *   ret = getsockopt(int sd, int level, int optname, void __user *optval,\n *                    int __user *optlen);\n *   ret = setsockopt(int sd, int level, int optname, const void __user *optval,\n *                    int optlen);\n *\n *   sd      - the socket descript.\n *   level   - set to IPPROTO_SCTP for all SCTP options.\n *   optname - the option name.\n *   optval  - the buffer to store the value of the option.\n *   optlen  - the size of the buffer.\n */\nstatic int sctp_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t   sockptr_t optval, unsigned int optlen)\n{\n\tvoid *kopt = NULL;\n\tint retval = 0;\n\n\tpr_debug(\"%s: sk:%p, optname:%d\\n\", __func__, sk, optname);\n\n\t/* I can hardly begin to describe how wrong this is.  This is\n\t * so broken as to be worse than useless.  The API draft\n\t * REALLY is NOT helpful here...  I am not convinced that the\n\t * semantics of setsockopt() with a level OTHER THAN SOL_SCTP\n\t * are at all well-founded.\n\t */\n\tif (level != SOL_SCTP) {\n\t\tstruct sctp_af *af = sctp_sk(sk)->pf->af;\n\n\t\treturn af->setsockopt(sk, level, optname, optval, optlen);\n\t}\n\n\tif (optlen > 0) {\n\t\tkopt = memdup_sockptr(optval, optlen);\n\t\tif (IS_ERR(kopt))\n\t\t\treturn PTR_ERR(kopt);\n\t}\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SCTP_SOCKOPT_BINDX_ADD:\n\t\t/* 'optlen' is the size of the addresses buffer. */\n\t\tretval = sctp_setsockopt_bindx(sk, kopt, optlen,\n\t\t\t\t\t       SCTP_BINDX_ADD_ADDR);\n\t\tbreak;\n\n\tcase SCTP_SOCKOPT_BINDX_REM:\n\t\t/* 'optlen' is the size of the addresses buffer. */\n\t\tretval = sctp_setsockopt_bindx(sk, kopt, optlen,\n\t\t\t\t\t       SCTP_BINDX_REM_ADDR);\n\t\tbreak;\n\n\tcase SCTP_SOCKOPT_CONNECTX_OLD:\n\t\t/* 'optlen' is the size of the addresses buffer. */\n\t\tretval = sctp_setsockopt_connectx_old(sk, kopt, optlen);\n\t\tbreak;\n\n\tcase SCTP_SOCKOPT_CONNECTX:\n\t\t/* 'optlen' is the size of the addresses buffer. */\n\t\tretval = sctp_setsockopt_connectx(sk, kopt, optlen);\n\t\tbreak;\n\n\tcase SCTP_DISABLE_FRAGMENTS:\n\t\tretval = sctp_setsockopt_disable_fragments(sk, kopt, optlen);\n\t\tbreak;\n\n\tcase SCTP_EVENTS:\n\t\tretval = sctp_setsockopt_events(sk, kopt, optlen);\n\t\tbreak;\n\n\tcase SCTP_AUTOCLOSE:\n\t\tretval = sctp_setsockopt_autoclose(sk, kopt, optlen);\n\t\tbreak;\n\n\tcase SCTP_PEER_ADDR_PARAMS:\n\t\tretval = sctp_setsockopt_peer_addr_params(sk, kopt, optlen);\n\t\tbreak;\n\n\tcase SCTP_DELAYED_SACK:\n\t\tretval = sctp_setsockopt_delayed_ack(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_PARTIAL_DELIVERY_POINT:\n\t\tretval = sctp_setsockopt_partial_delivery_point(sk, kopt, optlen);\n\t\tbreak;\n\n\tcase SCTP_INITMSG:\n\t\tretval = sctp_setsockopt_initmsg(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_SEND_PARAM:\n\t\tretval = sctp_setsockopt_default_send_param(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_SNDINFO:\n\t\tretval = sctp_setsockopt_default_sndinfo(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_PRIMARY_ADDR:\n\t\tretval = sctp_setsockopt_primary_addr(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_SET_PEER_PRIMARY_ADDR:\n\t\tretval = sctp_setsockopt_peer_primary_addr(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_NODELAY:\n\t\tretval = sctp_setsockopt_nodelay(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_RTOINFO:\n\t\tretval = sctp_setsockopt_rtoinfo(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_ASSOCINFO:\n\t\tretval = sctp_setsockopt_associnfo(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_I_WANT_MAPPED_V4_ADDR:\n\t\tretval = sctp_setsockopt_mappedv4(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_MAXSEG:\n\t\tretval = sctp_setsockopt_maxseg(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_ADAPTATION_LAYER:\n\t\tretval = sctp_setsockopt_adaptation_layer(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_CONTEXT:\n\t\tretval = sctp_setsockopt_context(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_FRAGMENT_INTERLEAVE:\n\t\tretval = sctp_setsockopt_fragment_interleave(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_MAX_BURST:\n\t\tretval = sctp_setsockopt_maxburst(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_CHUNK:\n\t\tretval = sctp_setsockopt_auth_chunk(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_HMAC_IDENT:\n\t\tretval = sctp_setsockopt_hmac_ident(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_KEY:\n\t\tretval = sctp_setsockopt_auth_key(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_ACTIVE_KEY:\n\t\tretval = sctp_setsockopt_active_key(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_DELETE_KEY:\n\t\tretval = sctp_setsockopt_del_key(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_DEACTIVATE_KEY:\n\t\tretval = sctp_setsockopt_deactivate_key(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_AUTO_ASCONF:\n\t\tretval = sctp_setsockopt_auto_asconf(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_PEER_ADDR_THLDS:\n\t\tretval = sctp_setsockopt_paddr_thresholds(sk, kopt, optlen,\n\t\t\t\t\t\t\t  false);\n\t\tbreak;\n\tcase SCTP_PEER_ADDR_THLDS_V2:\n\t\tretval = sctp_setsockopt_paddr_thresholds(sk, kopt, optlen,\n\t\t\t\t\t\t\t  true);\n\t\tbreak;\n\tcase SCTP_RECVRCVINFO:\n\t\tretval = sctp_setsockopt_recvrcvinfo(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_RECVNXTINFO:\n\t\tretval = sctp_setsockopt_recvnxtinfo(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_PR_SUPPORTED:\n\t\tretval = sctp_setsockopt_pr_supported(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_PRINFO:\n\t\tretval = sctp_setsockopt_default_prinfo(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_RECONFIG_SUPPORTED:\n\t\tretval = sctp_setsockopt_reconfig_supported(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_ENABLE_STREAM_RESET:\n\t\tretval = sctp_setsockopt_enable_strreset(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_RESET_STREAMS:\n\t\tretval = sctp_setsockopt_reset_streams(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_RESET_ASSOC:\n\t\tretval = sctp_setsockopt_reset_assoc(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_ADD_STREAMS:\n\t\tretval = sctp_setsockopt_add_streams(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_STREAM_SCHEDULER:\n\t\tretval = sctp_setsockopt_scheduler(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_STREAM_SCHEDULER_VALUE:\n\t\tretval = sctp_setsockopt_scheduler_value(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_INTERLEAVING_SUPPORTED:\n\t\tretval = sctp_setsockopt_interleaving_supported(sk, kopt,\n\t\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_REUSE_PORT:\n\t\tretval = sctp_setsockopt_reuse_port(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_EVENT:\n\t\tretval = sctp_setsockopt_event(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_ASCONF_SUPPORTED:\n\t\tretval = sctp_setsockopt_asconf_supported(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_SUPPORTED:\n\t\tretval = sctp_setsockopt_auth_supported(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_ECN_SUPPORTED:\n\t\tretval = sctp_setsockopt_ecn_supported(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_EXPOSE_POTENTIALLY_FAILED_STATE:\n\t\tretval = sctp_setsockopt_pf_expose(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_REMOTE_UDP_ENCAPS_PORT:\n\t\tretval = sctp_setsockopt_encap_port(sk, kopt, optlen);\n\t\tbreak;\n\tdefault:\n\t\tretval = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\tkfree(kopt);\n\treturn retval;\n}\n\n/* API 3.1.6 connect() - UDP Style Syntax\n *\n * An application may use the connect() call in the UDP model to initiate an\n * association without sending data.\n *\n * The syntax is:\n *\n * ret = connect(int sd, const struct sockaddr *nam, socklen_t len);\n *\n * sd: the socket descriptor to have a new association added to.\n *\n * nam: the address structure (either struct sockaddr_in or struct\n *    sockaddr_in6 defined in RFC2553 [7]).\n *\n * len: the size of the address.\n */\nstatic int sctp_connect(struct sock *sk, struct sockaddr *addr,\n\t\t\tint addr_len, int flags)\n{\n\tstruct sctp_af *af;\n\tint err = -EINVAL;\n\n\tlock_sock(sk);\n\tpr_debug(\"%s: sk:%p, sockaddr:%p, addr_len:%d\\n\", __func__, sk,\n\t\t addr, addr_len);\n\n\t/* Validate addr_len before calling common connect/connectx routine. */\n\taf = sctp_get_af_specific(addr->sa_family);\n\tif (af && addr_len >= af->sockaddr_len)\n\t\terr = __sctp_connect(sk, addr, af->sockaddr_len, flags, NULL);\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nint sctp_inet_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t      int addr_len, int flags)\n{\n\tif (addr_len < sizeof(uaddr->sa_family))\n\t\treturn -EINVAL;\n\n\tif (uaddr->sa_family == AF_UNSPEC)\n\t\treturn -EOPNOTSUPP;\n\n\treturn sctp_connect(sock->sk, uaddr, addr_len, flags);\n}\n\n/* FIXME: Write comments. */\nstatic int sctp_disconnect(struct sock *sk, int flags)\n{\n\treturn -EOPNOTSUPP; /* STUB */\n}\n\n/* 4.1.4 accept() - TCP Style Syntax\n *\n * Applications use accept() call to remove an established SCTP\n * association from the accept queue of the endpoint.  A new socket\n * descriptor will be returned from accept() to represent the newly\n * formed association.\n */\nstatic struct sock *sctp_accept(struct sock *sk, int flags, int *err, bool kern)\n{\n\tstruct sctp_sock *sp;\n\tstruct sctp_endpoint *ep;\n\tstruct sock *newsk = NULL;\n\tstruct sctp_association *asoc;\n\tlong timeo;\n\tint error = 0;\n\n\tlock_sock(sk);\n\n\tsp = sctp_sk(sk);\n\tep = sp->ep;\n\n\tif (!sctp_style(sk, TCP)) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (!sctp_sstate(sk, LISTENING)) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\terror = sctp_wait_for_accept(sk, timeo);\n\tif (error)\n\t\tgoto out;\n\n\t/* We treat the list of associations on the endpoint as the accept\n\t * queue and pick the first association on the list.\n\t */\n\tasoc = list_entry(ep->asocs.next, struct sctp_association, asocs);\n\n\tnewsk = sp->pf->create_accept_sk(sk, asoc, kern);\n\tif (!newsk) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Populate the fields of the newsk from the oldsk and migrate the\n\t * asoc to the newsk.\n\t */\n\terror = sctp_sock_migrate(sk, newsk, asoc, SCTP_SOCKET_TCP);\n\tif (error) {\n\t\tsk_common_release(newsk);\n\t\tnewsk = NULL;\n\t}\n\nout:\n\trelease_sock(sk);\n\t*err = error;\n\treturn newsk;\n}\n\n/* The SCTP ioctl handler. */\nstatic int sctp_ioctl(struct sock *sk, int cmd, unsigned long arg)\n{\n\tint rc = -ENOTCONN;\n\n\tlock_sock(sk);\n\n\t/*\n\t * SEQPACKET-style sockets in LISTENING state are valid, for\n\t * SCTP, so only discard TCP-style sockets in LISTENING state.\n\t */\n\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\tgoto out;\n\n\tswitch (cmd) {\n\tcase SIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tunsigned int amount = 0;\n\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb != NULL) {\n\t\t\t/*\n\t\t\t * We will only return the amount of this packet since\n\t\t\t * that is all that will be read.\n\t\t\t */\n\t\t\tamount = skb->len;\n\t\t}\n\t\trc = put_user(amount, (int __user *)arg);\n\t\tbreak;\n\t}\n\tdefault:\n\t\trc = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n/* This is the function which gets called during socket creation to\n * initialized the SCTP-specific portion of the sock.\n * The sock structure should already be zero-filled memory.\n */\nstatic int sctp_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock *sp;\n\n\tpr_debug(\"%s: sk:%p\\n\", __func__, sk);\n\n\tsp = sctp_sk(sk);\n\n\t/* Initialize the SCTP per socket area.  */\n\tswitch (sk->sk_type) {\n\tcase SOCK_SEQPACKET:\n\t\tsp->type = SCTP_SOCKET_UDP;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tsp->type = SCTP_SOCKET_TCP;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk->sk_gso_type = SKB_GSO_SCTP;\n\n\t/* Initialize default send parameters. These parameters can be\n\t * modified with the SCTP_DEFAULT_SEND_PARAM socket option.\n\t */\n\tsp->default_stream = 0;\n\tsp->default_ppid = 0;\n\tsp->default_flags = 0;\n\tsp->default_context = 0;\n\tsp->default_timetolive = 0;\n\n\tsp->default_rcv_context = 0;\n\tsp->max_burst = net->sctp.max_burst;\n\n\tsp->sctp_hmac_alg = net->sctp.sctp_hmac_alg;\n\n\t/* Initialize default setup parameters. These parameters\n\t * can be modified with the SCTP_INITMSG socket option or\n\t * overridden by the SCTP_INIT CMSG.\n\t */\n\tsp->initmsg.sinit_num_ostreams   = sctp_max_outstreams;\n\tsp->initmsg.sinit_max_instreams  = sctp_max_instreams;\n\tsp->initmsg.sinit_max_attempts   = net->sctp.max_retrans_init;\n\tsp->initmsg.sinit_max_init_timeo = net->sctp.rto_max;\n\n\t/* Initialize default RTO related parameters.  These parameters can\n\t * be modified for with the SCTP_RTOINFO socket option.\n\t */\n\tsp->rtoinfo.srto_initial = net->sctp.rto_initial;\n\tsp->rtoinfo.srto_max     = net->sctp.rto_max;\n\tsp->rtoinfo.srto_min     = net->sctp.rto_min;\n\n\t/* Initialize default association related parameters. These parameters\n\t * can be modified with the SCTP_ASSOCINFO socket option.\n\t */\n\tsp->assocparams.sasoc_asocmaxrxt = net->sctp.max_retrans_association;\n\tsp->assocparams.sasoc_number_peer_destinations = 0;\n\tsp->assocparams.sasoc_peer_rwnd = 0;\n\tsp->assocparams.sasoc_local_rwnd = 0;\n\tsp->assocparams.sasoc_cookie_life = net->sctp.valid_cookie_life;\n\n\t/* Initialize default event subscriptions. By default, all the\n\t * options are off.\n\t */\n\tsp->subscribe = 0;\n\n\t/* Default Peer Address Parameters.  These defaults can\n\t * be modified via SCTP_PEER_ADDR_PARAMS\n\t */\n\tsp->hbinterval  = net->sctp.hb_interval;\n\tsp->udp_port    = htons(net->sctp.udp_port);\n\tsp->encap_port  = htons(net->sctp.encap_port);\n\tsp->pathmaxrxt  = net->sctp.max_retrans_path;\n\tsp->pf_retrans  = net->sctp.pf_retrans;\n\tsp->ps_retrans  = net->sctp.ps_retrans;\n\tsp->pf_expose   = net->sctp.pf_expose;\n\tsp->pathmtu     = 0; /* allow default discovery */\n\tsp->sackdelay   = net->sctp.sack_timeout;\n\tsp->sackfreq\t= 2;\n\tsp->param_flags = SPP_HB_ENABLE |\n\t\t\t  SPP_PMTUD_ENABLE |\n\t\t\t  SPP_SACKDELAY_ENABLE;\n\tsp->default_ss = SCTP_SS_DEFAULT;\n\n\t/* If enabled no SCTP message fragmentation will be performed.\n\t * Configure through SCTP_DISABLE_FRAGMENTS socket option.\n\t */\n\tsp->disable_fragments = 0;\n\n\t/* Enable Nagle algorithm by default.  */\n\tsp->nodelay           = 0;\n\n\tsp->recvrcvinfo = 0;\n\tsp->recvnxtinfo = 0;\n\n\t/* Enable by default. */\n\tsp->v4mapped          = 1;\n\n\t/* Auto-close idle associations after the configured\n\t * number of seconds.  A value of 0 disables this\n\t * feature.  Configure through the SCTP_AUTOCLOSE socket option,\n\t * for UDP-style sockets only.\n\t */\n\tsp->autoclose         = 0;\n\n\t/* User specified fragmentation limit. */\n\tsp->user_frag         = 0;\n\n\tsp->adaptation_ind = 0;\n\n\tsp->pf = sctp_get_pf_specific(sk->sk_family);\n\n\t/* Control variables for partial data delivery. */\n\tatomic_set(&sp->pd_mode, 0);\n\tskb_queue_head_init(&sp->pd_lobby);\n\tsp->frag_interleave = 0;\n\n\t/* Create a per socket endpoint structure.  Even if we\n\t * change the data structure relationships, this may still\n\t * be useful for storing pre-connect address information.\n\t */\n\tsp->ep = sctp_endpoint_new(sk, GFP_KERNEL);\n\tif (!sp->ep)\n\t\treturn -ENOMEM;\n\n\tsp->hmac = NULL;\n\n\tsk->sk_destruct = sctp_destruct_sock;\n\n\tSCTP_DBG_OBJCNT_INC(sock);\n\n\tlocal_bh_disable();\n\tsk_sockets_allocated_inc(sk);\n\tsock_prot_inuse_add(net, sk->sk_prot, 1);\n\n\t/* Nothing can fail after this block, otherwise\n\t * sctp_destroy_sock() will be called without addr_wq_lock held\n\t */\n\tif (net->sctp.default_auto_asconf) {\n\t\tspin_lock(&sock_net(sk)->sctp.addr_wq_lock);\n\t\tlist_add_tail(&sp->auto_asconf_list,\n\t\t    &net->sctp.auto_asconf_splist);\n\t\tsp->do_auto_asconf = 1;\n\t\tspin_unlock(&sock_net(sk)->sctp.addr_wq_lock);\n\t} else {\n\t\tsp->do_auto_asconf = 0;\n\t}\n\n\tlocal_bh_enable();\n\n\treturn 0;\n}\n\n/* Cleanup any SCTP per socket resources. Must be called with\n * sock_net(sk)->sctp.addr_wq_lock held if sp->do_auto_asconf is true\n */\nstatic void sctp_destroy_sock(struct sock *sk)\n{\n\tstruct sctp_sock *sp;\n\n\tpr_debug(\"%s: sk:%p\\n\", __func__, sk);\n\n\t/* Release our hold on the endpoint. */\n\tsp = sctp_sk(sk);\n\t/* This could happen during socket init, thus we bail out\n\t * early, since the rest of the below is not setup either.\n\t */\n\tif (sp->ep == NULL)\n\t\treturn;\n\n\tif (sp->do_auto_asconf) {\n\t\tsp->do_auto_asconf = 0;\n\t\tlist_del(&sp->auto_asconf_list);\n\t}\n\tsctp_endpoint_free(sp->ep);\n\tlocal_bh_disable();\n\tsk_sockets_allocated_dec(sk);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\tlocal_bh_enable();\n}\n\n/* Triggered when there are no references on the socket anymore */\nstatic void sctp_destruct_sock(struct sock *sk)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t/* Free up the HMAC transform. */\n\tcrypto_free_shash(sp->hmac);\n\n\tinet_sock_destruct(sk);\n}\n\n/* API 4.1.7 shutdown() - TCP Style Syntax\n *     int shutdown(int socket, int how);\n *\n *     sd      - the socket descriptor of the association to be closed.\n *     how     - Specifies the type of shutdown.  The  values  are\n *               as follows:\n *               SHUT_RD\n *                     Disables further receive operations. No SCTP\n *                     protocol action is taken.\n *               SHUT_WR\n *                     Disables further send operations, and initiates\n *                     the SCTP shutdown sequence.\n *               SHUT_RDWR\n *                     Disables further send  and  receive  operations\n *                     and initiates the SCTP shutdown sequence.\n */\nstatic void sctp_shutdown(struct sock *sk, int how)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_endpoint *ep;\n\n\tif (!sctp_style(sk, TCP))\n\t\treturn;\n\n\tep = sctp_sk(sk)->ep;\n\tif (how & SEND_SHUTDOWN && !list_empty(&ep->asocs)) {\n\t\tstruct sctp_association *asoc;\n\n\t\tinet_sk_set_state(sk, SCTP_SS_CLOSING);\n\t\tasoc = list_entry(ep->asocs.next,\n\t\t\t\t  struct sctp_association, asocs);\n\t\tsctp_primitive_SHUTDOWN(net, asoc, NULL);\n\t}\n}\n\nint sctp_get_sctp_info(struct sock *sk, struct sctp_association *asoc,\n\t\t       struct sctp_info *info)\n{\n\tstruct sctp_transport *prim;\n\tstruct list_head *pos;\n\tint mask;\n\n\tmemset(info, 0, sizeof(*info));\n\tif (!asoc) {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tinfo->sctpi_s_autoclose = sp->autoclose;\n\t\tinfo->sctpi_s_adaptation_ind = sp->adaptation_ind;\n\t\tinfo->sctpi_s_pd_point = sp->pd_point;\n\t\tinfo->sctpi_s_nodelay = sp->nodelay;\n\t\tinfo->sctpi_s_disable_fragments = sp->disable_fragments;\n\t\tinfo->sctpi_s_v4mapped = sp->v4mapped;\n\t\tinfo->sctpi_s_frag_interleave = sp->frag_interleave;\n\t\tinfo->sctpi_s_type = sp->type;\n\n\t\treturn 0;\n\t}\n\n\tinfo->sctpi_tag = asoc->c.my_vtag;\n\tinfo->sctpi_state = asoc->state;\n\tinfo->sctpi_rwnd = asoc->a_rwnd;\n\tinfo->sctpi_unackdata = asoc->unack_data;\n\tinfo->sctpi_penddata = sctp_tsnmap_pending(&asoc->peer.tsn_map);\n\tinfo->sctpi_instrms = asoc->stream.incnt;\n\tinfo->sctpi_outstrms = asoc->stream.outcnt;\n\tlist_for_each(pos, &asoc->base.inqueue.in_chunk_list)\n\t\tinfo->sctpi_inqueue++;\n\tlist_for_each(pos, &asoc->outqueue.out_chunk_list)\n\t\tinfo->sctpi_outqueue++;\n\tinfo->sctpi_overall_error = asoc->overall_error_count;\n\tinfo->sctpi_max_burst = asoc->max_burst;\n\tinfo->sctpi_maxseg = asoc->frag_point;\n\tinfo->sctpi_peer_rwnd = asoc->peer.rwnd;\n\tinfo->sctpi_peer_tag = asoc->c.peer_vtag;\n\n\tmask = asoc->peer.ecn_capable << 1;\n\tmask = (mask | asoc->peer.ipv4_address) << 1;\n\tmask = (mask | asoc->peer.ipv6_address) << 1;\n\tmask = (mask | asoc->peer.hostname_address) << 1;\n\tmask = (mask | asoc->peer.asconf_capable) << 1;\n\tmask = (mask | asoc->peer.prsctp_capable) << 1;\n\tmask = (mask | asoc->peer.auth_capable);\n\tinfo->sctpi_peer_capable = mask;\n\tmask = asoc->peer.sack_needed << 1;\n\tmask = (mask | asoc->peer.sack_generation) << 1;\n\tmask = (mask | asoc->peer.zero_window_announced);\n\tinfo->sctpi_peer_sack = mask;\n\n\tinfo->sctpi_isacks = asoc->stats.isacks;\n\tinfo->sctpi_osacks = asoc->stats.osacks;\n\tinfo->sctpi_opackets = asoc->stats.opackets;\n\tinfo->sctpi_ipackets = asoc->stats.ipackets;\n\tinfo->sctpi_rtxchunks = asoc->stats.rtxchunks;\n\tinfo->sctpi_outofseqtsns = asoc->stats.outofseqtsns;\n\tinfo->sctpi_idupchunks = asoc->stats.idupchunks;\n\tinfo->sctpi_gapcnt = asoc->stats.gapcnt;\n\tinfo->sctpi_ouodchunks = asoc->stats.ouodchunks;\n\tinfo->sctpi_iuodchunks = asoc->stats.iuodchunks;\n\tinfo->sctpi_oodchunks = asoc->stats.oodchunks;\n\tinfo->sctpi_iodchunks = asoc->stats.iodchunks;\n\tinfo->sctpi_octrlchunks = asoc->stats.octrlchunks;\n\tinfo->sctpi_ictrlchunks = asoc->stats.ictrlchunks;\n\n\tprim = asoc->peer.primary_path;\n\tmemcpy(&info->sctpi_p_address, &prim->ipaddr, sizeof(prim->ipaddr));\n\tinfo->sctpi_p_state = prim->state;\n\tinfo->sctpi_p_cwnd = prim->cwnd;\n\tinfo->sctpi_p_srtt = prim->srtt;\n\tinfo->sctpi_p_rto = jiffies_to_msecs(prim->rto);\n\tinfo->sctpi_p_hbinterval = prim->hbinterval;\n\tinfo->sctpi_p_pathmaxrxt = prim->pathmaxrxt;\n\tinfo->sctpi_p_sackdelay = jiffies_to_msecs(prim->sackdelay);\n\tinfo->sctpi_p_ssthresh = prim->ssthresh;\n\tinfo->sctpi_p_partial_bytes_acked = prim->partial_bytes_acked;\n\tinfo->sctpi_p_flight_size = prim->flight_size;\n\tinfo->sctpi_p_error = prim->error_count;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sctp_get_sctp_info);\n\n/* use callback to avoid exporting the core structure */\nvoid sctp_transport_walk_start(struct rhashtable_iter *iter) __acquires(RCU)\n{\n\trhltable_walk_enter(&sctp_transport_hashtable, iter);\n\n\trhashtable_walk_start(iter);\n}\n\nvoid sctp_transport_walk_stop(struct rhashtable_iter *iter) __releases(RCU)\n{\n\trhashtable_walk_stop(iter);\n\trhashtable_walk_exit(iter);\n}\n\nstruct sctp_transport *sctp_transport_get_next(struct net *net,\n\t\t\t\t\t       struct rhashtable_iter *iter)\n{\n\tstruct sctp_transport *t;\n\n\tt = rhashtable_walk_next(iter);\n\tfor (; t; t = rhashtable_walk_next(iter)) {\n\t\tif (IS_ERR(t)) {\n\t\t\tif (PTR_ERR(t) == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!sctp_transport_hold(t))\n\t\t\tcontinue;\n\n\t\tif (net_eq(t->asoc->base.net, net) &&\n\t\t    t->asoc->peer.primary_path == t)\n\t\t\tbreak;\n\n\t\tsctp_transport_put(t);\n\t}\n\n\treturn t;\n}\n\nstruct sctp_transport *sctp_transport_get_idx(struct net *net,\n\t\t\t\t\t      struct rhashtable_iter *iter,\n\t\t\t\t\t      int pos)\n{\n\tstruct sctp_transport *t;\n\n\tif (!pos)\n\t\treturn SEQ_START_TOKEN;\n\n\twhile ((t = sctp_transport_get_next(net, iter)) && !IS_ERR(t)) {\n\t\tif (!--pos)\n\t\t\tbreak;\n\t\tsctp_transport_put(t);\n\t}\n\n\treturn t;\n}\n\nint sctp_for_each_endpoint(int (*cb)(struct sctp_endpoint *, void *),\n\t\t\t   void *p) {\n\tint err = 0;\n\tint hash = 0;\n\tstruct sctp_ep_common *epb;\n\tstruct sctp_hashbucket *head;\n\n\tfor (head = sctp_ep_hashtable; hash < sctp_ep_hashsize;\n\t     hash++, head++) {\n\t\tread_lock_bh(&head->lock);\n\t\tsctp_for_each_hentry(epb, &head->chain) {\n\t\t\terr = cb(sctp_ep(epb), p);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\tread_unlock_bh(&head->lock);\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(sctp_for_each_endpoint);\n\nint sctp_transport_lookup_process(int (*cb)(struct sctp_transport *, void *),\n\t\t\t\t  struct net *net,\n\t\t\t\t  const union sctp_addr *laddr,\n\t\t\t\t  const union sctp_addr *paddr, void *p)\n{\n\tstruct sctp_transport *transport;\n\tint err;\n\n\trcu_read_lock();\n\ttransport = sctp_addrs_lookup_transport(net, laddr, paddr);\n\trcu_read_unlock();\n\tif (!transport)\n\t\treturn -ENOENT;\n\n\terr = cb(transport, p);\n\tsctp_transport_put(transport);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(sctp_transport_lookup_process);\n\nint sctp_for_each_transport(int (*cb)(struct sctp_transport *, void *),\n\t\t\t    int (*cb_done)(struct sctp_transport *, void *),\n\t\t\t    struct net *net, int *pos, void *p) {\n\tstruct rhashtable_iter hti;\n\tstruct sctp_transport *tsp;\n\tint ret;\n\nagain:\n\tret = 0;\n\tsctp_transport_walk_start(&hti);\n\n\ttsp = sctp_transport_get_idx(net, &hti, *pos + 1);\n\tfor (; !IS_ERR_OR_NULL(tsp); tsp = sctp_transport_get_next(net, &hti)) {\n\t\tret = cb(tsp, p);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t(*pos)++;\n\t\tsctp_transport_put(tsp);\n\t}\n\tsctp_transport_walk_stop(&hti);\n\n\tif (ret) {\n\t\tif (cb_done && !cb_done(tsp, p)) {\n\t\t\t(*pos)++;\n\t\t\tsctp_transport_put(tsp);\n\t\t\tgoto again;\n\t\t}\n\t\tsctp_transport_put(tsp);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sctp_for_each_transport);\n\n/* 7.2.1 Association Status (SCTP_STATUS)\n\n * Applications can retrieve current status information about an\n * association, including association state, peer receiver window size,\n * number of unacked data chunks, and number of data chunks pending\n * receipt.  This information is read-only.\n */\nstatic int sctp_getsockopt_sctp_status(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_status status;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_transport *transport;\n\tsctp_assoc_t associd;\n\tint retval = 0;\n\n\tif (len < sizeof(status)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(status);\n\tif (copy_from_user(&status, optval, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tassocid = status.sstat_assoc_id;\n\tasoc = sctp_id2assoc(sk, associd);\n\tif (!asoc) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttransport = asoc->peer.primary_path;\n\n\tstatus.sstat_assoc_id = sctp_assoc2id(asoc);\n\tstatus.sstat_state = sctp_assoc_to_state(asoc);\n\tstatus.sstat_rwnd =  asoc->peer.rwnd;\n\tstatus.sstat_unackdata = asoc->unack_data;\n\n\tstatus.sstat_penddata = sctp_tsnmap_pending(&asoc->peer.tsn_map);\n\tstatus.sstat_instrms = asoc->stream.incnt;\n\tstatus.sstat_outstrms = asoc->stream.outcnt;\n\tstatus.sstat_fragmentation_point = asoc->frag_point;\n\tstatus.sstat_primary.spinfo_assoc_id = sctp_assoc2id(transport->asoc);\n\tmemcpy(&status.sstat_primary.spinfo_address, &transport->ipaddr,\n\t\t\ttransport->af_specific->sockaddr_len);\n\t/* Map ipv4 address into v4-mapped-on-v6 address.  */\n\tsctp_get_pf_specific(sk->sk_family)->addr_to_user(sctp_sk(sk),\n\t\t(union sctp_addr *)&status.sstat_primary.spinfo_address);\n\tstatus.sstat_primary.spinfo_state = transport->state;\n\tstatus.sstat_primary.spinfo_cwnd = transport->cwnd;\n\tstatus.sstat_primary.spinfo_srtt = transport->srtt;\n\tstatus.sstat_primary.spinfo_rto = jiffies_to_msecs(transport->rto);\n\tstatus.sstat_primary.spinfo_mtu = transport->pathmtu;\n\n\tif (status.sstat_primary.spinfo_state == SCTP_UNKNOWN)\n\t\tstatus.sstat_primary.spinfo_state = SCTP_ACTIVE;\n\n\tif (put_user(len, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"%s: len:%d, state:%d, rwnd:%d, assoc_id:%d\\n\",\n\t\t __func__, len, status.sstat_state, status.sstat_rwnd,\n\t\t status.sstat_assoc_id);\n\n\tif (copy_to_user(optval, &status, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\treturn retval;\n}\n\n\n/* 7.2.2 Peer Address Information (SCTP_GET_PEER_ADDR_INFO)\n *\n * Applications can retrieve information about a specific peer address\n * of an association, including its reachability state, congestion\n * window, and retransmission timer values.  This information is\n * read-only.\n */\nstatic int sctp_getsockopt_peer_addr_info(struct sock *sk, int len,\n\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t  int __user *optlen)\n{\n\tstruct sctp_paddrinfo pinfo;\n\tstruct sctp_transport *transport;\n\tint retval = 0;\n\n\tif (len < sizeof(pinfo)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(pinfo);\n\tif (copy_from_user(&pinfo, optval, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\ttransport = sctp_addr_id2transport(sk, &pinfo.spinfo_address,\n\t\t\t\t\t   pinfo.spinfo_assoc_id);\n\tif (!transport) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (transport->state == SCTP_PF &&\n\t    transport->asoc->pf_expose == SCTP_PF_EXPOSE_DISABLE) {\n\t\tretval = -EACCES;\n\t\tgoto out;\n\t}\n\n\tpinfo.spinfo_assoc_id = sctp_assoc2id(transport->asoc);\n\tpinfo.spinfo_state = transport->state;\n\tpinfo.spinfo_cwnd = transport->cwnd;\n\tpinfo.spinfo_srtt = transport->srtt;\n\tpinfo.spinfo_rto = jiffies_to_msecs(transport->rto);\n\tpinfo.spinfo_mtu = transport->pathmtu;\n\n\tif (pinfo.spinfo_state == SCTP_UNKNOWN)\n\t\tpinfo.spinfo_state = SCTP_ACTIVE;\n\n\tif (put_user(len, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (copy_to_user(optval, &pinfo, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\treturn retval;\n}\n\n/* 7.1.12 Enable/Disable message fragmentation (SCTP_DISABLE_FRAGMENTS)\n *\n * This option is a on/off flag.  If enabled no SCTP message\n * fragmentation will be performed.  Instead if a message being sent\n * exceeds the current PMTU size, the message will NOT be sent and\n * instead a error will be indicated to the user.\n */\nstatic int sctp_getsockopt_disable_fragments(struct sock *sk, int len,\n\t\t\t\t\tchar __user *optval, int __user *optlen)\n{\n\tint val;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tval = (sctp_sk(sk)->disable_fragments == 1);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/* 7.1.15 Set notification and ancillary events (SCTP_EVENTS)\n *\n * This socket option is used to specify various notifications and\n * ancillary data the user wishes to receive.\n */\nstatic int sctp_getsockopt_events(struct sock *sk, int len, char __user *optval,\n\t\t\t\t  int __user *optlen)\n{\n\tstruct sctp_event_subscribe subscribe;\n\t__u8 *sn_type = (__u8 *)&subscribe;\n\tint i;\n\n\tif (len == 0)\n\t\treturn -EINVAL;\n\tif (len > sizeof(struct sctp_event_subscribe))\n\t\tlen = sizeof(struct sctp_event_subscribe);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < len; i++)\n\t\tsn_type[i] = sctp_ulpevent_type_enabled(sctp_sk(sk)->subscribe,\n\t\t\t\t\t\t\tSCTP_SN_TYPE_BASE + i);\n\n\tif (copy_to_user(optval, &subscribe, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/* 7.1.8 Automatic Close of associations (SCTP_AUTOCLOSE)\n *\n * This socket option is applicable to the UDP-style socket only.  When\n * set it will cause associations that are idle for more than the\n * specified number of seconds to automatically close.  An association\n * being idle is defined an association that has NOT sent or received\n * user data.  The special value of '0' indicates that no automatic\n * close of any associations should be performed.  The option expects an\n * integer defining the number of seconds of idle time before an\n * association is closed.\n */\nstatic int sctp_getsockopt_autoclose(struct sock *sk, int len, char __user *optval, int __user *optlen)\n{\n\t/* Applicable to UDP-style socket only */\n\tif (sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\tlen = sizeof(int);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(sctp_sk(sk)->autoclose, (int __user *)optval))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/* Helper routine to branch off an association to a new socket.  */\nint sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\n\t/* Do not peel off from one netns to another one. */\n\tif (!net_eq(current->nsproxy->net_ns, sock_net(sk)))\n\t\treturn -EINVAL;\n\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\t/* An association cannot be branched off from an already peeled-off\n\t * socket, nor is this supported for tcp style sockets.\n\t */\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Create a new socket.  */\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\n\t/* Make peeled-off sockets more like 1-1 accepted sockets.\n\t * Set the daddr and initialize id to something more random and also\n\t * copy over any ip options.\n\t */\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\tsp->pf->copy_ip_options(sk, sock->sk);\n\n\t/* Populate the fields of the newsk from the oldsk and migrate the\n\t * asoc to the newsk.\n\t */\n\terr = sctp_sock_migrate(sk, sock->sk, asoc,\n\t\t\t\tSCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\tif (err) {\n\t\tsock_release(sock);\n\t\tsock = NULL;\n\t}\n\n\t*sockp = sock;\n\n\treturn err;\n}\nEXPORT_SYMBOL(sctp_do_peeloff);\n\nstatic int sctp_getsockopt_peeloff_common(struct sock *sk, sctp_peeloff_arg_t *peeloff,\n\t\t\t\t\t  struct file **newfile, unsigned flags)\n{\n\tstruct socket *newsock;\n\tint retval;\n\n\tretval = sctp_do_peeloff(sk, peeloff->associd, &newsock);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* Map the socket to an unused fd that can be returned to the user.  */\n\tretval = get_unused_fd_flags(flags & SOCK_CLOEXEC);\n\tif (retval < 0) {\n\t\tsock_release(newsock);\n\t\tgoto out;\n\t}\n\n\t*newfile = sock_alloc_file(newsock, 0, NULL);\n\tif (IS_ERR(*newfile)) {\n\t\tput_unused_fd(retval);\n\t\tretval = PTR_ERR(*newfile);\n\t\t*newfile = NULL;\n\t\treturn retval;\n\t}\n\n\tpr_debug(\"%s: sk:%p, newsk:%p, sd:%d\\n\", __func__, sk, newsock->sk,\n\t\t retval);\n\n\tpeeloff->sd = retval;\n\n\tif (flags & SOCK_NONBLOCK)\n\t\t(*newfile)->f_flags |= O_NONBLOCK;\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_peeloff(struct sock *sk, int len, char __user *optval, int __user *optlen)\n{\n\tsctp_peeloff_arg_t peeloff;\n\tstruct file *newfile = NULL;\n\tint retval = 0;\n\n\tif (len < sizeof(sctp_peeloff_arg_t))\n\t\treturn -EINVAL;\n\tlen = sizeof(sctp_peeloff_arg_t);\n\tif (copy_from_user(&peeloff, optval, len))\n\t\treturn -EFAULT;\n\n\tretval = sctp_getsockopt_peeloff_common(sk, &peeloff, &newfile, 0);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* Return the fd mapped to the new socket.  */\n\tif (put_user(len, optlen)) {\n\t\tfput(newfile);\n\t\tput_unused_fd(retval);\n\t\treturn -EFAULT;\n\t}\n\n\tif (copy_to_user(optval, &peeloff, len)) {\n\t\tfput(newfile);\n\t\tput_unused_fd(retval);\n\t\treturn -EFAULT;\n\t}\n\tfd_install(retval, newfile);\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_peeloff_flags(struct sock *sk, int len,\n\t\t\t\t\t char __user *optval, int __user *optlen)\n{\n\tsctp_peeloff_flags_arg_t peeloff;\n\tstruct file *newfile = NULL;\n\tint retval = 0;\n\n\tif (len < sizeof(sctp_peeloff_flags_arg_t))\n\t\treturn -EINVAL;\n\tlen = sizeof(sctp_peeloff_flags_arg_t);\n\tif (copy_from_user(&peeloff, optval, len))\n\t\treturn -EFAULT;\n\n\tretval = sctp_getsockopt_peeloff_common(sk, &peeloff.p_arg,\n\t\t\t\t\t\t&newfile, peeloff.flags);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* Return the fd mapped to the new socket.  */\n\tif (put_user(len, optlen)) {\n\t\tfput(newfile);\n\t\tput_unused_fd(retval);\n\t\treturn -EFAULT;\n\t}\n\n\tif (copy_to_user(optval, &peeloff, len)) {\n\t\tfput(newfile);\n\t\tput_unused_fd(retval);\n\t\treturn -EFAULT;\n\t}\n\tfd_install(retval, newfile);\nout:\n\treturn retval;\n}\n\n/* 7.1.13 Peer Address Parameters (SCTP_PEER_ADDR_PARAMS)\n *\n * Applications can enable or disable heartbeats for any peer address of\n * an association, modify an address's heartbeat interval, force a\n * heartbeat to be sent immediately, and adjust the address's maximum\n * number of retransmissions sent before an address is considered\n * unreachable.  The following structure is used to access and modify an\n * address's parameters:\n *\n *  struct sctp_paddrparams {\n *     sctp_assoc_t            spp_assoc_id;\n *     struct sockaddr_storage spp_address;\n *     uint32_t                spp_hbinterval;\n *     uint16_t                spp_pathmaxrxt;\n *     uint32_t                spp_pathmtu;\n *     uint32_t                spp_sackdelay;\n *     uint32_t                spp_flags;\n * };\n *\n *   spp_assoc_id    - (one-to-many style socket) This is filled in the\n *                     application, and identifies the association for\n *                     this query.\n *   spp_address     - This specifies which address is of interest.\n *   spp_hbinterval  - This contains the value of the heartbeat interval,\n *                     in milliseconds.  If a  value of zero\n *                     is present in this field then no changes are to\n *                     be made to this parameter.\n *   spp_pathmaxrxt  - This contains the maximum number of\n *                     retransmissions before this address shall be\n *                     considered unreachable. If a  value of zero\n *                     is present in this field then no changes are to\n *                     be made to this parameter.\n *   spp_pathmtu     - When Path MTU discovery is disabled the value\n *                     specified here will be the \"fixed\" path mtu.\n *                     Note that if the spp_address field is empty\n *                     then all associations on this address will\n *                     have this fixed path mtu set upon them.\n *\n *   spp_sackdelay   - When delayed sack is enabled, this value specifies\n *                     the number of milliseconds that sacks will be delayed\n *                     for. This value will apply to all addresses of an\n *                     association if the spp_address field is empty. Note\n *                     also, that if delayed sack is enabled and this\n *                     value is set to 0, no change is made to the last\n *                     recorded delayed sack timer value.\n *\n *   spp_flags       - These flags are used to control various features\n *                     on an association. The flag field may contain\n *                     zero or more of the following options.\n *\n *                     SPP_HB_ENABLE  - Enable heartbeats on the\n *                     specified address. Note that if the address\n *                     field is empty all addresses for the association\n *                     have heartbeats enabled upon them.\n *\n *                     SPP_HB_DISABLE - Disable heartbeats on the\n *                     speicifed address. Note that if the address\n *                     field is empty all addresses for the association\n *                     will have their heartbeats disabled. Note also\n *                     that SPP_HB_ENABLE and SPP_HB_DISABLE are\n *                     mutually exclusive, only one of these two should\n *                     be specified. Enabling both fields will have\n *                     undetermined results.\n *\n *                     SPP_HB_DEMAND - Request a user initiated heartbeat\n *                     to be made immediately.\n *\n *                     SPP_PMTUD_ENABLE - This field will enable PMTU\n *                     discovery upon the specified address. Note that\n *                     if the address feild is empty then all addresses\n *                     on the association are effected.\n *\n *                     SPP_PMTUD_DISABLE - This field will disable PMTU\n *                     discovery upon the specified address. Note that\n *                     if the address feild is empty then all addresses\n *                     on the association are effected. Not also that\n *                     SPP_PMTUD_ENABLE and SPP_PMTUD_DISABLE are mutually\n *                     exclusive. Enabling both will have undetermined\n *                     results.\n *\n *                     SPP_SACKDELAY_ENABLE - Setting this flag turns\n *                     on delayed sack. The time specified in spp_sackdelay\n *                     is used to specify the sack delay for this address. Note\n *                     that if spp_address is empty then all addresses will\n *                     enable delayed sack and take on the sack delay\n *                     value specified in spp_sackdelay.\n *                     SPP_SACKDELAY_DISABLE - Setting this flag turns\n *                     off delayed sack. If the spp_address field is blank then\n *                     delayed sack is disabled for the entire association. Note\n *                     also that this field is mutually exclusive to\n *                     SPP_SACKDELAY_ENABLE, setting both will have undefined\n *                     results.\n *\n *                     SPP_IPV6_FLOWLABEL:  Setting this flag enables the\n *                     setting of the IPV6 flow label value.  The value is\n *                     contained in the spp_ipv6_flowlabel field.\n *                     Upon retrieval, this flag will be set to indicate that\n *                     the spp_ipv6_flowlabel field has a valid value returned.\n *                     If a specific destination address is set (in the\n *                     spp_address field), then the value returned is that of\n *                     the address.  If just an association is specified (and\n *                     no address), then the association's default flow label\n *                     is returned.  If neither an association nor a destination\n *                     is specified, then the socket's default flow label is\n *                     returned.  For non-IPv6 sockets, this flag will be left\n *                     cleared.\n *\n *                     SPP_DSCP:  Setting this flag enables the setting of the\n *                     Differentiated Services Code Point (DSCP) value\n *                     associated with either the association or a specific\n *                     address.  The value is obtained in the spp_dscp field.\n *                     Upon retrieval, this flag will be set to indicate that\n *                     the spp_dscp field has a valid value returned.  If a\n *                     specific destination address is set when called (in the\n *                     spp_address field), then that specific destination\n *                     address's DSCP value is returned.  If just an association\n *                     is specified, then the association's default DSCP is\n *                     returned.  If neither an association nor a destination is\n *                     specified, then the socket's default DSCP is returned.\n *\n *   spp_ipv6_flowlabel\n *                   - This field is used in conjunction with the\n *                     SPP_IPV6_FLOWLABEL flag and contains the IPv6 flow label.\n *                     The 20 least significant bits are used for the flow\n *                     label.  This setting has precedence over any IPv6-layer\n *                     setting.\n *\n *   spp_dscp        - This field is used in conjunction with the SPP_DSCP flag\n *                     and contains the DSCP.  The 6 most significant bits are\n *                     used for the DSCP.  This setting has precedence over any\n *                     IPv4- or IPv6- layer setting.\n */\nstatic int sctp_getsockopt_peer_addr_params(struct sock *sk, int len,\n\t\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_paddrparams  params;\n\tstruct sctp_transport   *trans = NULL;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_sock        *sp = sctp_sk(sk);\n\n\tif (len >= sizeof(params))\n\t\tlen = sizeof(params);\n\telse if (len >= ALIGN(offsetof(struct sctp_paddrparams,\n\t\t\t\t       spp_ipv6_flowlabel), 4))\n\t\tlen = ALIGN(offsetof(struct sctp_paddrparams,\n\t\t\t\t     spp_ipv6_flowlabel), 4);\n\telse\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&params, optval, len))\n\t\treturn -EFAULT;\n\n\t/* If an address other than INADDR_ANY is specified, and\n\t * no transport is found, then the request is invalid.\n\t */\n\tif (!sctp_is_any(sk, (union sctp_addr *)&params.spp_address)) {\n\t\ttrans = sctp_addr_id2transport(sk, &params.spp_address,\n\t\t\t\t\t       params.spp_assoc_id);\n\t\tif (!trans) {\n\t\t\tpr_debug(\"%s: failed no transport\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Get association, if assoc_id != SCTP_FUTURE_ASSOC and the\n\t * socket is a one to many style socket, and an association\n\t * was not found, then the id was invalid.\n\t */\n\tasoc = sctp_id2assoc(sk, params.spp_assoc_id);\n\tif (!asoc && params.spp_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tpr_debug(\"%s: failed no association\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (trans) {\n\t\t/* Fetch transport values. */\n\t\tparams.spp_hbinterval = jiffies_to_msecs(trans->hbinterval);\n\t\tparams.spp_pathmtu    = trans->pathmtu;\n\t\tparams.spp_pathmaxrxt = trans->pathmaxrxt;\n\t\tparams.spp_sackdelay  = jiffies_to_msecs(trans->sackdelay);\n\n\t\t/*draft-11 doesn't say what to return in spp_flags*/\n\t\tparams.spp_flags      = trans->param_flags;\n\t\tif (trans->flowlabel & SCTP_FLOWLABEL_SET_MASK) {\n\t\t\tparams.spp_ipv6_flowlabel = trans->flowlabel &\n\t\t\t\t\t\t    SCTP_FLOWLABEL_VAL_MASK;\n\t\t\tparams.spp_flags |= SPP_IPV6_FLOWLABEL;\n\t\t}\n\t\tif (trans->dscp & SCTP_DSCP_SET_MASK) {\n\t\t\tparams.spp_dscp\t= trans->dscp & SCTP_DSCP_VAL_MASK;\n\t\t\tparams.spp_flags |= SPP_DSCP;\n\t\t}\n\t} else if (asoc) {\n\t\t/* Fetch association values. */\n\t\tparams.spp_hbinterval = jiffies_to_msecs(asoc->hbinterval);\n\t\tparams.spp_pathmtu    = asoc->pathmtu;\n\t\tparams.spp_pathmaxrxt = asoc->pathmaxrxt;\n\t\tparams.spp_sackdelay  = jiffies_to_msecs(asoc->sackdelay);\n\n\t\t/*draft-11 doesn't say what to return in spp_flags*/\n\t\tparams.spp_flags      = asoc->param_flags;\n\t\tif (asoc->flowlabel & SCTP_FLOWLABEL_SET_MASK) {\n\t\t\tparams.spp_ipv6_flowlabel = asoc->flowlabel &\n\t\t\t\t\t\t    SCTP_FLOWLABEL_VAL_MASK;\n\t\t\tparams.spp_flags |= SPP_IPV6_FLOWLABEL;\n\t\t}\n\t\tif (asoc->dscp & SCTP_DSCP_SET_MASK) {\n\t\t\tparams.spp_dscp\t= asoc->dscp & SCTP_DSCP_VAL_MASK;\n\t\t\tparams.spp_flags |= SPP_DSCP;\n\t\t}\n\t} else {\n\t\t/* Fetch socket values. */\n\t\tparams.spp_hbinterval = sp->hbinterval;\n\t\tparams.spp_pathmtu    = sp->pathmtu;\n\t\tparams.spp_sackdelay  = sp->sackdelay;\n\t\tparams.spp_pathmaxrxt = sp->pathmaxrxt;\n\n\t\t/*draft-11 doesn't say what to return in spp_flags*/\n\t\tparams.spp_flags      = sp->param_flags;\n\t\tif (sp->flowlabel & SCTP_FLOWLABEL_SET_MASK) {\n\t\t\tparams.spp_ipv6_flowlabel = sp->flowlabel &\n\t\t\t\t\t\t    SCTP_FLOWLABEL_VAL_MASK;\n\t\t\tparams.spp_flags |= SPP_IPV6_FLOWLABEL;\n\t\t}\n\t\tif (sp->dscp & SCTP_DSCP_SET_MASK) {\n\t\t\tparams.spp_dscp\t= sp->dscp & SCTP_DSCP_VAL_MASK;\n\t\t\tparams.spp_flags |= SPP_DSCP;\n\t\t}\n\t}\n\n\tif (copy_to_user(optval, &params, len))\n\t\treturn -EFAULT;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 7.1.23.  Get or set delayed ack timer (SCTP_DELAYED_SACK)\n *\n * This option will effect the way delayed acks are performed.  This\n * option allows you to get or set the delayed ack time, in\n * milliseconds.  It also allows changing the delayed ack frequency.\n * Changing the frequency to 1 disables the delayed sack algorithm.  If\n * the assoc_id is 0, then this sets or gets the endpoints default\n * values.  If the assoc_id field is non-zero, then the set or get\n * effects the specified association for the one to many model (the\n * assoc_id field is ignored by the one to one model).  Note that if\n * sack_delay or sack_freq are 0 when setting this option, then the\n * current values will remain unchanged.\n *\n * struct sctp_sack_info {\n *     sctp_assoc_t            sack_assoc_id;\n *     uint32_t                sack_delay;\n *     uint32_t                sack_freq;\n * };\n *\n * sack_assoc_id -  This parameter, indicates which association the user\n *    is performing an action upon.  Note that if this field's value is\n *    zero then the endpoints default value is changed (effecting future\n *    associations only).\n *\n * sack_delay -  This parameter contains the number of milliseconds that\n *    the user is requesting the delayed ACK timer be set to.  Note that\n *    this value is defined in the standard to be between 200 and 500\n *    milliseconds.\n *\n * sack_freq -  This parameter contains the number of packets that must\n *    be received before a sack is sent without waiting for the delay\n *    timer to expire.  The default value for this is 2, setting this\n *    value to 1 will disable the delayed sack algorithm.\n */\nstatic int sctp_getsockopt_delayed_ack(struct sock *sk, int len,\n\t\t\t\t\t    char __user *optval,\n\t\t\t\t\t    int __user *optlen)\n{\n\tstruct sctp_sack_info    params;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_sock        *sp = sctp_sk(sk);\n\n\tif (len >= sizeof(struct sctp_sack_info)) {\n\t\tlen = sizeof(struct sctp_sack_info);\n\n\t\tif (copy_from_user(&params, optval, len))\n\t\t\treturn -EFAULT;\n\t} else if (len == sizeof(struct sctp_assoc_value)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of struct sctp_assoc_value in delayed_ack socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_sack_info instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tif (copy_from_user(&params, optval, len))\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EINVAL;\n\n\t/* Get association, if sack_assoc_id != SCTP_FUTURE_ASSOC and the\n\t * socket is a one to many style socket, and an association\n\t * was not found, then the id was invalid.\n\t */\n\tasoc = sctp_id2assoc(sk, params.sack_assoc_id);\n\tif (!asoc && params.sack_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\t/* Fetch association values. */\n\t\tif (asoc->param_flags & SPP_SACKDELAY_ENABLE) {\n\t\t\tparams.sack_delay = jiffies_to_msecs(asoc->sackdelay);\n\t\t\tparams.sack_freq = asoc->sackfreq;\n\n\t\t} else {\n\t\t\tparams.sack_delay = 0;\n\t\t\tparams.sack_freq = 1;\n\t\t}\n\t} else {\n\t\t/* Fetch socket values. */\n\t\tif (sp->param_flags & SPP_SACKDELAY_ENABLE) {\n\t\t\tparams.sack_delay  = sp->sackdelay;\n\t\t\tparams.sack_freq = sp->sackfreq;\n\t\t} else {\n\t\t\tparams.sack_delay  = 0;\n\t\t\tparams.sack_freq = 1;\n\t\t}\n\t}\n\n\tif (copy_to_user(optval, &params, len))\n\t\treturn -EFAULT;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/* 7.1.3 Initialization Parameters (SCTP_INITMSG)\n *\n * Applications can specify protocol parameters for the default association\n * initialization.  The option name argument to setsockopt() and getsockopt()\n * is SCTP_INITMSG.\n *\n * Setting initialization parameters is effective only on an unconnected\n * socket (for UDP-style sockets only future associations are effected\n * by the change).  With TCP-style sockets, this option is inherited by\n * sockets derived from a listener socket.\n */\nstatic int sctp_getsockopt_initmsg(struct sock *sk, int len, char __user *optval, int __user *optlen)\n{\n\tif (len < sizeof(struct sctp_initmsg))\n\t\treturn -EINVAL;\n\tlen = sizeof(struct sctp_initmsg);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &sctp_sk(sk)->initmsg, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n\nstatic int sctp_getsockopt_peer_addrs(struct sock *sk, int len,\n\t\t\t\t      char __user *optval, int __user *optlen)\n{\n\tstruct sctp_association *asoc;\n\tint cnt = 0;\n\tstruct sctp_getaddrs getaddrs;\n\tstruct sctp_transport *from;\n\tvoid __user *to;\n\tunion sctp_addr temp;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tint addrlen;\n\tsize_t space_left;\n\tint bytes_copied;\n\n\tif (len < sizeof(struct sctp_getaddrs))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&getaddrs, optval, sizeof(struct sctp_getaddrs)))\n\t\treturn -EFAULT;\n\n\t/* For UDP-style sockets, id specifies the association to query.  */\n\tasoc = sctp_id2assoc(sk, getaddrs.assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tto = optval + offsetof(struct sctp_getaddrs, addrs);\n\tspace_left = len - offsetof(struct sctp_getaddrs, addrs);\n\n\tlist_for_each_entry(from, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\tmemcpy(&temp, &from->ipaddr, sizeof(temp));\n\t\taddrlen = sctp_get_pf_specific(sk->sk_family)\n\t\t\t      ->addr_to_user(sp, &temp);\n\t\tif (space_left < addrlen)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_to_user(to, &temp, addrlen))\n\t\t\treturn -EFAULT;\n\t\tto += addrlen;\n\t\tcnt++;\n\t\tspace_left -= addrlen;\n\t}\n\n\tif (put_user(cnt, &((struct sctp_getaddrs __user *)optval)->addr_num))\n\t\treturn -EFAULT;\n\tbytes_copied = ((char __user *)to) - optval;\n\tif (put_user(bytes_copied, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_copy_laddrs(struct sock *sk, __u16 port, void *to,\n\t\t\t    size_t space_left, int *bytes_copied)\n{\n\tstruct sctp_sockaddr_entry *addr;\n\tunion sctp_addr temp;\n\tint cnt = 0;\n\tint addrlen;\n\tstruct net *net = sock_net(sk);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(addr, &net->sctp.local_addr_list, list) {\n\t\tif (!addr->valid)\n\t\t\tcontinue;\n\n\t\tif ((PF_INET == sk->sk_family) &&\n\t\t    (AF_INET6 == addr->a.sa.sa_family))\n\t\t\tcontinue;\n\t\tif ((PF_INET6 == sk->sk_family) &&\n\t\t    inet_v6_ipv6only(sk) &&\n\t\t    (AF_INET == addr->a.sa.sa_family))\n\t\t\tcontinue;\n\t\tmemcpy(&temp, &addr->a, sizeof(temp));\n\t\tif (!temp.v4.sin_port)\n\t\t\ttemp.v4.sin_port = htons(port);\n\n\t\taddrlen = sctp_get_pf_specific(sk->sk_family)\n\t\t\t      ->addr_to_user(sctp_sk(sk), &temp);\n\n\t\tif (space_left < addrlen) {\n\t\t\tcnt =  -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(to, &temp, addrlen);\n\n\t\tto += addrlen;\n\t\tcnt++;\n\t\tspace_left -= addrlen;\n\t\t*bytes_copied += addrlen;\n\t}\n\trcu_read_unlock();\n\n\treturn cnt;\n}\n\n\nstatic int sctp_getsockopt_local_addrs(struct sock *sk, int len,\n\t\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sctp_bind_addr *bp;\n\tstruct sctp_association *asoc;\n\tint cnt = 0;\n\tstruct sctp_getaddrs getaddrs;\n\tstruct sctp_sockaddr_entry *addr;\n\tvoid __user *to;\n\tunion sctp_addr temp;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tint addrlen;\n\tint err = 0;\n\tsize_t space_left;\n\tint bytes_copied = 0;\n\tvoid *addrs;\n\tvoid *buf;\n\n\tif (len < sizeof(struct sctp_getaddrs))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&getaddrs, optval, sizeof(struct sctp_getaddrs)))\n\t\treturn -EFAULT;\n\n\t/*\n\t *  For UDP-style sockets, id specifies the association to query.\n\t *  If the id field is set to the value '0' then the locally bound\n\t *  addresses are returned without regard to any particular\n\t *  association.\n\t */\n\tif (0 == getaddrs.assoc_id) {\n\t\tbp = &sctp_sk(sk)->ep->base.bind_addr;\n\t} else {\n\t\tasoc = sctp_id2assoc(sk, getaddrs.assoc_id);\n\t\tif (!asoc)\n\t\t\treturn -EINVAL;\n\t\tbp = &asoc->base.bind_addr;\n\t}\n\n\tto = optval + offsetof(struct sctp_getaddrs, addrs);\n\tspace_left = len - offsetof(struct sctp_getaddrs, addrs);\n\n\taddrs = kmalloc(space_left, GFP_USER | __GFP_NOWARN);\n\tif (!addrs)\n\t\treturn -ENOMEM;\n\n\t/* If the endpoint is bound to 0.0.0.0 or ::0, get the valid\n\t * addresses from the global local address list.\n\t */\n\tif (sctp_list_single_entry(&bp->address_list)) {\n\t\taddr = list_entry(bp->address_list.next,\n\t\t\t\t  struct sctp_sockaddr_entry, list);\n\t\tif (sctp_is_any(sk, &addr->a)) {\n\t\t\tcnt = sctp_copy_laddrs(sk, bp->port, addrs,\n\t\t\t\t\t\tspace_left, &bytes_copied);\n\t\t\tif (cnt < 0) {\n\t\t\t\terr = cnt;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto copy_getaddrs;\n\t\t}\n\t}\n\n\tbuf = addrs;\n\t/* Protection on the bound address list is not needed since\n\t * in the socket option context we hold a socket lock and\n\t * thus the bound address list can't change.\n\t */\n\tlist_for_each_entry(addr, &bp->address_list, list) {\n\t\tmemcpy(&temp, &addr->a, sizeof(temp));\n\t\taddrlen = sctp_get_pf_specific(sk->sk_family)\n\t\t\t      ->addr_to_user(sp, &temp);\n\t\tif (space_left < addrlen) {\n\t\t\terr =  -ENOMEM; /*fixme: right error?*/\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(buf, &temp, addrlen);\n\t\tbuf += addrlen;\n\t\tbytes_copied += addrlen;\n\t\tcnt++;\n\t\tspace_left -= addrlen;\n\t}\n\ncopy_getaddrs:\n\tif (copy_to_user(to, addrs, bytes_copied)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (put_user(cnt, &((struct sctp_getaddrs __user *)optval)->addr_num)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\t/* XXX: We should have accounted for sizeof(struct sctp_getaddrs) too,\n\t * but we can't change it anymore.\n\t */\n\tif (put_user(bytes_copied, optlen))\n\t\terr = -EFAULT;\nout:\n\tkfree(addrs);\n\treturn err;\n}\n\n/* 7.1.10 Set Primary Address (SCTP_PRIMARY_ADDR)\n *\n * Requests that the local SCTP stack use the enclosed peer address as\n * the association primary.  The enclosed address must be one of the\n * association peer's addresses.\n */\nstatic int sctp_getsockopt_primary_addr(struct sock *sk, int len,\n\t\t\t\t\tchar __user *optval, int __user *optlen)\n{\n\tstruct sctp_prim prim;\n\tstruct sctp_association *asoc;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (len < sizeof(struct sctp_prim))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_prim);\n\n\tif (copy_from_user(&prim, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, prim.ssp_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tif (!asoc->peer.primary_path)\n\t\treturn -ENOTCONN;\n\n\tmemcpy(&prim.ssp_addr, &asoc->peer.primary_path->ipaddr,\n\t\tasoc->peer.primary_path->af_specific->sockaddr_len);\n\n\tsctp_get_pf_specific(sk->sk_family)->addr_to_user(sp,\n\t\t\t(union sctp_addr *)&prim.ssp_addr);\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &prim, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 7.1.11  Set Adaptation Layer Indicator (SCTP_ADAPTATION_LAYER)\n *\n * Requests that the local endpoint set the specified Adaptation Layer\n * Indication parameter for all future INIT and INIT-ACK exchanges.\n */\nstatic int sctp_getsockopt_adaptation_layer(struct sock *sk, int len,\n\t\t\t\t  char __user *optval, int __user *optlen)\n{\n\tstruct sctp_setadaptation adaptation;\n\n\tif (len < sizeof(struct sctp_setadaptation))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_setadaptation);\n\n\tadaptation.ssb_adaptation_ind = sctp_sk(sk)->adaptation_ind;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &adaptation, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n *\n * 7.1.14 Set default send parameters (SCTP_DEFAULT_SEND_PARAM)\n *\n *   Applications that wish to use the sendto() system call may wish to\n *   specify a default set of parameters that would normally be supplied\n *   through the inclusion of ancillary data.  This socket option allows\n *   such an application to set the default sctp_sndrcvinfo structure.\n\n\n *   The application that wishes to use this socket option simply passes\n *   in to this call the sctp_sndrcvinfo structure defined in Section\n *   5.2.2) The input parameters accepted by this call include\n *   sinfo_stream, sinfo_flags, sinfo_ppid, sinfo_context,\n *   sinfo_timetolive.  The user must provide the sinfo_assoc_id field in\n *   to this call if the caller is using the UDP model.\n *\n *   For getsockopt, it get the default sctp_sndrcvinfo structure.\n */\nstatic int sctp_getsockopt_default_send_param(struct sock *sk,\n\t\t\t\t\tint len, char __user *optval,\n\t\t\t\t\tint __user *optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tstruct sctp_sndrcvinfo info;\n\n\tif (len < sizeof(info))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(info);\n\n\tif (copy_from_user(&info, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, info.sinfo_assoc_id);\n\tif (!asoc && info.sinfo_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tinfo.sinfo_stream = asoc->default_stream;\n\t\tinfo.sinfo_flags = asoc->default_flags;\n\t\tinfo.sinfo_ppid = asoc->default_ppid;\n\t\tinfo.sinfo_context = asoc->default_context;\n\t\tinfo.sinfo_timetolive = asoc->default_timetolive;\n\t} else {\n\t\tinfo.sinfo_stream = sp->default_stream;\n\t\tinfo.sinfo_flags = sp->default_flags;\n\t\tinfo.sinfo_ppid = sp->default_ppid;\n\t\tinfo.sinfo_context = sp->default_context;\n\t\tinfo.sinfo_timetolive = sp->default_timetolive;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &info, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/* RFC6458, Section 8.1.31. Set/get Default Send Parameters\n * (SCTP_DEFAULT_SNDINFO)\n */\nstatic int sctp_getsockopt_default_sndinfo(struct sock *sk, int len,\n\t\t\t\t\t   char __user *optval,\n\t\t\t\t\t   int __user *optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tstruct sctp_sndinfo info;\n\n\tif (len < sizeof(info))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(info);\n\n\tif (copy_from_user(&info, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, info.snd_assoc_id);\n\tif (!asoc && info.snd_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tinfo.snd_sid = asoc->default_stream;\n\t\tinfo.snd_flags = asoc->default_flags;\n\t\tinfo.snd_ppid = asoc->default_ppid;\n\t\tinfo.snd_context = asoc->default_context;\n\t} else {\n\t\tinfo.snd_sid = sp->default_stream;\n\t\tinfo.snd_flags = sp->default_flags;\n\t\tinfo.snd_ppid = sp->default_ppid;\n\t\tinfo.snd_context = sp->default_context;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &info, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n *\n * 7.1.5 SCTP_NODELAY\n *\n * Turn on/off any Nagle-like algorithm.  This means that packets are\n * generally sent as soon as possible and no unnecessary delays are\n * introduced, at the cost of more packets in the network.  Expects an\n * integer boolean flag.\n */\n\nstatic int sctp_getsockopt_nodelay(struct sock *sk, int len,\n\t\t\t\t   char __user *optval, int __user *optlen)\n{\n\tint val;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tval = (sctp_sk(sk)->nodelay == 1);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/*\n *\n * 7.1.1 SCTP_RTOINFO\n *\n * The protocol parameters used to initialize and bound retransmission\n * timeout (RTO) are tunable. sctp_rtoinfo structure is used to access\n * and modify these parameters.\n * All parameters are time values, in milliseconds.  A value of 0, when\n * modifying the parameters, indicates that the current value should not\n * be changed.\n *\n */\nstatic int sctp_getsockopt_rtoinfo(struct sock *sk, int len,\n\t\t\t\tchar __user *optval,\n\t\t\t\tint __user *optlen) {\n\tstruct sctp_rtoinfo rtoinfo;\n\tstruct sctp_association *asoc;\n\n\tif (len < sizeof (struct sctp_rtoinfo))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_rtoinfo);\n\n\tif (copy_from_user(&rtoinfo, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, rtoinfo.srto_assoc_id);\n\n\tif (!asoc && rtoinfo.srto_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Values corresponding to the specific association. */\n\tif (asoc) {\n\t\trtoinfo.srto_initial = jiffies_to_msecs(asoc->rto_initial);\n\t\trtoinfo.srto_max = jiffies_to_msecs(asoc->rto_max);\n\t\trtoinfo.srto_min = jiffies_to_msecs(asoc->rto_min);\n\t} else {\n\t\t/* Values corresponding to the endpoint. */\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\trtoinfo.srto_initial = sp->rtoinfo.srto_initial;\n\t\trtoinfo.srto_max = sp->rtoinfo.srto_max;\n\t\trtoinfo.srto_min = sp->rtoinfo.srto_min;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(optval, &rtoinfo, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n *\n * 7.1.2 SCTP_ASSOCINFO\n *\n * This option is used to tune the maximum retransmission attempts\n * of the association.\n * Returns an error if the new association retransmission value is\n * greater than the sum of the retransmission value  of the peer.\n * See [SCTP] for more information.\n *\n */\nstatic int sctp_getsockopt_associnfo(struct sock *sk, int len,\n\t\t\t\t     char __user *optval,\n\t\t\t\t     int __user *optlen)\n{\n\n\tstruct sctp_assocparams assocparams;\n\tstruct sctp_association *asoc;\n\tstruct list_head *pos;\n\tint cnt = 0;\n\n\tif (len < sizeof (struct sctp_assocparams))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_assocparams);\n\n\tif (copy_from_user(&assocparams, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, assocparams.sasoc_assoc_id);\n\n\tif (!asoc && assocparams.sasoc_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Values correspoinding to the specific association */\n\tif (asoc) {\n\t\tassocparams.sasoc_asocmaxrxt = asoc->max_retrans;\n\t\tassocparams.sasoc_peer_rwnd = asoc->peer.rwnd;\n\t\tassocparams.sasoc_local_rwnd = asoc->a_rwnd;\n\t\tassocparams.sasoc_cookie_life = ktime_to_ms(asoc->cookie_life);\n\n\t\tlist_for_each(pos, &asoc->peer.transport_addr_list) {\n\t\t\tcnt++;\n\t\t}\n\n\t\tassocparams.sasoc_number_peer_destinations = cnt;\n\t} else {\n\t\t/* Values corresponding to the endpoint */\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tassocparams.sasoc_asocmaxrxt = sp->assocparams.sasoc_asocmaxrxt;\n\t\tassocparams.sasoc_peer_rwnd = sp->assocparams.sasoc_peer_rwnd;\n\t\tassocparams.sasoc_local_rwnd = sp->assocparams.sasoc_local_rwnd;\n\t\tassocparams.sasoc_cookie_life =\n\t\t\t\t\tsp->assocparams.sasoc_cookie_life;\n\t\tassocparams.sasoc_number_peer_destinations =\n\t\t\t\t\tsp->assocparams.\n\t\t\t\t\tsasoc_number_peer_destinations;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(optval, &assocparams, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 7.1.16 Set/clear IPv4 mapped addresses (SCTP_I_WANT_MAPPED_V4_ADDR)\n *\n * This socket option is a boolean flag which turns on or off mapped V4\n * addresses.  If this option is turned on and the socket is type\n * PF_INET6, then IPv4 addresses will be mapped to V6 representation.\n * If this option is turned off, then no mapping will be done of V4\n * addresses and a user will receive both PF_INET6 and PF_INET type\n * addresses on the socket.\n */\nstatic int sctp_getsockopt_mappedv4(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tint val;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tval = sp->v4mapped;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 7.1.29.  Set or Get the default context (SCTP_CONTEXT)\n * (chapter and verse is quoted at sctp_setsockopt_context())\n */\nstatic int sctp_getsockopt_context(struct sock *sk, int len,\n\t\t\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\n\tif (len < sizeof(struct sctp_assoc_value))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_assoc_value);\n\n\tif (copy_from_user(&params, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tparams.assoc_value = asoc ? asoc->default_rcv_context\n\t\t\t\t  : sctp_sk(sk)->default_rcv_context;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &params, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 8.1.16.  Get or Set the Maximum Fragmentation Size (SCTP_MAXSEG)\n * This option will get or set the maximum size to put in any outgoing\n * SCTP DATA chunk.  If a message is larger than this size it will be\n * fragmented by SCTP into the specified size.  Note that the underlying\n * SCTP implementation may fragment into smaller sized chunks when the\n * PMTU of the underlying association is smaller than the value set by\n * the user.  The default value for this option is '0' which indicates\n * the user is NOT limiting fragmentation and only the PMTU will effect\n * SCTP's choice of DATA chunk size.  Note also that values set larger\n * than the maximum size of an IP datagram will effectively let SCTP\n * control fragmentation (i.e. the same as setting this option to 0).\n *\n * The following structure is used to access and modify this parameter:\n *\n * struct sctp_assoc_value {\n *   sctp_assoc_t assoc_id;\n *   uint32_t assoc_value;\n * };\n *\n * assoc_id:  This parameter is ignored for one-to-one style sockets.\n *    For one-to-many style sockets this parameter indicates which\n *    association the user is performing an action upon.  Note that if\n *    this field's value is zero then the endpoints default value is\n *    changed (effecting future associations only).\n * assoc_value:  This parameter specifies the maximum size in bytes.\n */\nstatic int sctp_getsockopt_maxseg(struct sock *sk, int len,\n\t\t\t\t  char __user *optval, int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\n\tif (len == sizeof(int)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of int in maxseg socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_assoc_value instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tparams.assoc_id = SCTP_FUTURE_ASSOC;\n\t} else if (len >= sizeof(struct sctp_assoc_value)) {\n\t\tlen = sizeof(struct sctp_assoc_value);\n\t\tif (copy_from_user(&params, optval, len))\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\tparams.assoc_value = asoc->frag_point;\n\telse\n\t\tparams.assoc_value = sctp_sk(sk)->user_frag;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len == sizeof(int)) {\n\t\tif (copy_to_user(optval, &params.assoc_value, len))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (copy_to_user(optval, &params, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n/*\n * 7.1.24.  Get or set fragmented interleave (SCTP_FRAGMENT_INTERLEAVE)\n * (chapter and verse is quoted at sctp_setsockopt_fragment_interleave())\n */\nstatic int sctp_getsockopt_fragment_interleave(struct sock *sk, int len,\n\t\t\t\t\t       char __user *optval, int __user *optlen)\n{\n\tint val;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\n\tval = sctp_sk(sk)->frag_interleave;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 7.1.25.  Set or Get the sctp partial delivery point\n * (chapter and verse is quoted at sctp_setsockopt_partial_delivery_point())\n */\nstatic int sctp_getsockopt_partial_delivery_point(struct sock *sk, int len,\n\t\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t\t  int __user *optlen)\n{\n\tu32 val;\n\n\tif (len < sizeof(u32))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(u32);\n\n\tval = sctp_sk(sk)->pd_point;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 7.1.28.  Set or Get the maximum burst (SCTP_MAX_BURST)\n * (chapter and verse is quoted at sctp_setsockopt_maxburst())\n */\nstatic int sctp_getsockopt_maxburst(struct sock *sk, int len,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\n\tif (len == sizeof(int)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of int in max_burst socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_assoc_value instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tparams.assoc_id = SCTP_FUTURE_ASSOC;\n\t} else if (len >= sizeof(struct sctp_assoc_value)) {\n\t\tlen = sizeof(struct sctp_assoc_value);\n\t\tif (copy_from_user(&params, optval, len))\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tparams.assoc_value = asoc ? asoc->max_burst : sctp_sk(sk)->max_burst;\n\n\tif (len == sizeof(int)) {\n\t\tif (copy_to_user(optval, &params.assoc_value, len))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (copy_to_user(optval, &params, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n\n}\n\nstatic int sctp_getsockopt_hmac_ident(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_hmacalgo  __user *p = (void __user *)optval;\n\tstruct sctp_hmac_algo_param *hmacs;\n\t__u16 data_len = 0;\n\tu32 num_idents;\n\tint i;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\thmacs = ep->auth_hmacs_list;\n\tdata_len = ntohs(hmacs->param_hdr.length) -\n\t\t   sizeof(struct sctp_paramhdr);\n\n\tif (len < sizeof(struct sctp_hmacalgo) + data_len)\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_hmacalgo) + data_len;\n\tnum_idents = data_len / sizeof(u16);\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(num_idents, &p->shmac_num_idents))\n\t\treturn -EFAULT;\n\tfor (i = 0; i < num_idents; i++) {\n\t\t__u16 hmacid = ntohs(hmacs->hmac_ids[i]);\n\n\t\tif (copy_to_user(&p->shmac_idents[i], &hmacid, sizeof(__u16)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_active_key(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_authkeyid val;\n\tstruct sctp_association *asoc;\n\n\tif (len < sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_authkeyid);\n\tif (copy_from_user(&val, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, val.scact_assoc_id);\n\tif (!asoc && val.scact_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tif (!asoc->peer.auth_capable)\n\t\t\treturn -EACCES;\n\t\tval.scact_keynumber = asoc->active_key_id;\n\t} else {\n\t\tif (!ep->auth_enable)\n\t\t\treturn -EACCES;\n\t\tval.scact_keynumber = ep->active_key_id;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_peer_auth_chunks(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_authchunks __user *p = (void __user *)optval;\n\tstruct sctp_authchunks val;\n\tstruct sctp_association *asoc;\n\tstruct sctp_chunks_param *ch;\n\tu32    num_chunks = 0;\n\tchar __user *to;\n\n\tif (len < sizeof(struct sctp_authchunks))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\treturn -EFAULT;\n\n\tto = p->gauth_chunks;\n\tasoc = sctp_id2assoc(sk, val.gauth_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tif (!asoc->peer.auth_capable)\n\t\treturn -EACCES;\n\n\tch = asoc->peer.peer_chunks;\n\tif (!ch)\n\t\tgoto num;\n\n\t/* See if the user provided enough room for all the data */\n\tnum_chunks = ntohs(ch->param_hdr.length) - sizeof(struct sctp_paramhdr);\n\tif (len < num_chunks)\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(to, ch->chunks, num_chunks))\n\t\treturn -EFAULT;\nnum:\n\tlen = sizeof(struct sctp_authchunks) + num_chunks;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(num_chunks, &p->gauth_number_of_chunks))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_local_auth_chunks(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_authchunks __user *p = (void __user *)optval;\n\tstruct sctp_authchunks val;\n\tstruct sctp_association *asoc;\n\tstruct sctp_chunks_param *ch;\n\tu32    num_chunks = 0;\n\tchar __user *to;\n\n\tif (len < sizeof(struct sctp_authchunks))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\treturn -EFAULT;\n\n\tto = p->gauth_chunks;\n\tasoc = sctp_id2assoc(sk, val.gauth_assoc_id);\n\tif (!asoc && val.gauth_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tif (!asoc->peer.auth_capable)\n\t\t\treturn -EACCES;\n\t\tch = (struct sctp_chunks_param *)asoc->c.auth_chunks;\n\t} else {\n\t\tif (!ep->auth_enable)\n\t\t\treturn -EACCES;\n\t\tch = ep->auth_chunk_list;\n\t}\n\tif (!ch)\n\t\tgoto num;\n\n\tnum_chunks = ntohs(ch->param_hdr.length) - sizeof(struct sctp_paramhdr);\n\tif (len < sizeof(struct sctp_authchunks) + num_chunks)\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(to, ch->chunks, num_chunks))\n\t\treturn -EFAULT;\nnum:\n\tlen = sizeof(struct sctp_authchunks) + num_chunks;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(num_chunks, &p->gauth_number_of_chunks))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 8.2.5.  Get the Current Number of Associations (SCTP_GET_ASSOC_NUMBER)\n * This option gets the current number of associations that are attached\n * to a one-to-many style socket.  The option value is an uint32_t.\n */\nstatic int sctp_getsockopt_assoc_number(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tu32 val = 0;\n\n\tif (sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len < sizeof(u32))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(u32);\n\n\tlist_for_each_entry(asoc, &(sp->ep->asocs), asocs) {\n\t\tval++;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 8.1.23 SCTP_AUTO_ASCONF\n * See the corresponding setsockopt entry as description\n */\nstatic int sctp_getsockopt_auto_asconf(struct sock *sk, int len,\n\t\t\t\t   char __user *optval, int __user *optlen)\n{\n\tint val = 0;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tif (sctp_sk(sk)->do_auto_asconf && sctp_is_ep_boundall(sk))\n\t\tval = 1;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/*\n * 8.2.6. Get the Current Identifiers of Associations\n *        (SCTP_GET_ASSOC_ID_LIST)\n *\n * This option gets the current list of SCTP association identifiers of\n * the SCTP associations handled by a one-to-many style socket.\n */\nstatic int sctp_getsockopt_assoc_ids(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tstruct sctp_assoc_ids *ids;\n\tu32 num = 0;\n\n\tif (sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len < sizeof(struct sctp_assoc_ids))\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(asoc, &(sp->ep->asocs), asocs) {\n\t\tnum++;\n\t}\n\n\tif (len < sizeof(struct sctp_assoc_ids) + sizeof(sctp_assoc_t) * num)\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_assoc_ids) + sizeof(sctp_assoc_t) * num;\n\n\tids = kmalloc(len, GFP_USER | __GFP_NOWARN);\n\tif (unlikely(!ids))\n\t\treturn -ENOMEM;\n\n\tids->gaids_number_of_ids = num;\n\tnum = 0;\n\tlist_for_each_entry(asoc, &(sp->ep->asocs), asocs) {\n\t\tids->gaids_assoc_id[num++] = asoc->assoc_id;\n\t}\n\n\tif (put_user(len, optlen) || copy_to_user(optval, ids, len)) {\n\t\tkfree(ids);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(ids);\n\treturn 0;\n}\n\n/*\n * SCTP_PEER_ADDR_THLDS\n *\n * This option allows us to fetch the partially failed threshold for one or all\n * transports in an association.  See Section 6.1 of:\n * http://www.ietf.org/id/draft-nishida-tsvwg-sctp-failover-05.txt\n */\nstatic int sctp_getsockopt_paddr_thresholds(struct sock *sk,\n\t\t\t\t\t    char __user *optval, int len,\n\t\t\t\t\t    int __user *optlen, bool v2)\n{\n\tstruct sctp_paddrthlds_v2 val;\n\tstruct sctp_transport *trans;\n\tstruct sctp_association *asoc;\n\tint min;\n\n\tmin = v2 ? sizeof(val) : sizeof(struct sctp_paddrthlds);\n\tif (len < min)\n\t\treturn -EINVAL;\n\tlen = min;\n\tif (copy_from_user(&val, optval, len))\n\t\treturn -EFAULT;\n\n\tif (!sctp_is_any(sk, (const union sctp_addr *)&val.spt_address)) {\n\t\ttrans = sctp_addr_id2transport(sk, &val.spt_address,\n\t\t\t\t\t       val.spt_assoc_id);\n\t\tif (!trans)\n\t\t\treturn -ENOENT;\n\n\t\tval.spt_pathmaxrxt = trans->pathmaxrxt;\n\t\tval.spt_pathpfthld = trans->pf_retrans;\n\t\tval.spt_pathcpthld = trans->ps_retrans;\n\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, val.spt_assoc_id);\n\tif (!asoc && val.spt_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tval.spt_pathpfthld = asoc->pf_retrans;\n\t\tval.spt_pathmaxrxt = asoc->pathmaxrxt;\n\t\tval.spt_pathcpthld = asoc->ps_retrans;\n\t} else {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tval.spt_pathpfthld = sp->pf_retrans;\n\t\tval.spt_pathmaxrxt = sp->pathmaxrxt;\n\t\tval.spt_pathcpthld = sp->ps_retrans;\n\t}\n\nout:\n\tif (put_user(len, optlen) || copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * SCTP_GET_ASSOC_STATS\n *\n * This option retrieves local per endpoint statistics. It is modeled\n * after OpenSolaris' implementation\n */\nstatic int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_assoc_stats sas;\n\tstruct sctp_association *asoc = NULL;\n\n\t/* User must provide at least the assoc id */\n\tif (len < sizeof(sctp_assoc_t))\n\t\treturn -EINVAL;\n\n\t/* Allow the struct to grow and fill in as much as possible */\n\tlen = min_t(size_t, len, sizeof(sas));\n\n\tif (copy_from_user(&sas, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, sas.sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tsas.sas_rtxchunks = asoc->stats.rtxchunks;\n\tsas.sas_gapcnt = asoc->stats.gapcnt;\n\tsas.sas_outofseqtsns = asoc->stats.outofseqtsns;\n\tsas.sas_osacks = asoc->stats.osacks;\n\tsas.sas_isacks = asoc->stats.isacks;\n\tsas.sas_octrlchunks = asoc->stats.octrlchunks;\n\tsas.sas_ictrlchunks = asoc->stats.ictrlchunks;\n\tsas.sas_oodchunks = asoc->stats.oodchunks;\n\tsas.sas_iodchunks = asoc->stats.iodchunks;\n\tsas.sas_ouodchunks = asoc->stats.ouodchunks;\n\tsas.sas_iuodchunks = asoc->stats.iuodchunks;\n\tsas.sas_idupchunks = asoc->stats.idupchunks;\n\tsas.sas_opackets = asoc->stats.opackets;\n\tsas.sas_ipackets = asoc->stats.ipackets;\n\n\t/* New high max rto observed, will return 0 if not a single\n\t * RTO update took place. obs_rto_ipaddr will be bogus\n\t * in such a case\n\t */\n\tsas.sas_maxrto = asoc->stats.max_obs_rto;\n\tmemcpy(&sas.sas_obs_rto_ipaddr, &asoc->stats.obs_rto_ipaddr,\n\t\tsizeof(struct sockaddr_storage));\n\n\t/* Mark beginning of a new observation period */\n\tasoc->stats.max_obs_rto = asoc->rto_min;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tpr_debug(\"%s: len:%d, assoc_id:%d\\n\", __func__, len, sas.sas_assoc_id);\n\n\tif (copy_to_user(optval, &sas, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_recvrcvinfo(struct sock *sk,\tint len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tint val = 0;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tif (sctp_sk(sk)->recvrcvinfo)\n\t\tval = 1;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_recvnxtinfo(struct sock *sk,\tint len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tint val = 0;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tif (sctp_sk(sk)->recvnxtinfo)\n\t\tval = 1;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_pr_supported(struct sock *sk, int len,\n\t\t\t\t\tchar __user *optval,\n\t\t\t\t\tint __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.assoc_value = asoc ? asoc->peer.prsctp_capable\n\t\t\t\t  : sctp_sk(sk)->ep->prsctp_enable;\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_default_prinfo(struct sock *sk, int len,\n\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t  int __user *optlen)\n{\n\tstruct sctp_default_prinfo info;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(info)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(info);\n\tif (copy_from_user(&info, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, info.pr_assoc_id);\n\tif (!asoc && info.pr_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (asoc) {\n\t\tinfo.pr_policy = SCTP_PR_POLICY(asoc->default_flags);\n\t\tinfo.pr_value = asoc->default_timetolive;\n\t} else {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tinfo.pr_policy = SCTP_PR_POLICY(sp->default_flags);\n\t\tinfo.pr_value = sp->default_timetolive;\n\t}\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &info, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_pr_assocstatus(struct sock *sk, int len,\n\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t  int __user *optlen)\n{\n\tstruct sctp_prstatus params;\n\tstruct sctp_association *asoc;\n\tint policy;\n\tint retval = -EINVAL;\n\n\tif (len < sizeof(params))\n\t\tgoto out;\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tpolicy = params.sprstat_policy;\n\tif (!policy || (policy & ~(SCTP_PR_SCTP_MASK | SCTP_PR_SCTP_ALL)) ||\n\t    ((policy & SCTP_PR_SCTP_ALL) && (policy & SCTP_PR_SCTP_MASK)))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.sprstat_assoc_id);\n\tif (!asoc)\n\t\tgoto out;\n\n\tif (policy == SCTP_PR_SCTP_ALL) {\n\t\tparams.sprstat_abandoned_unsent = 0;\n\t\tparams.sprstat_abandoned_sent = 0;\n\t\tfor (policy = 0; policy <= SCTP_PR_INDEX(MAX); policy++) {\n\t\t\tparams.sprstat_abandoned_unsent +=\n\t\t\t\tasoc->abandoned_unsent[policy];\n\t\t\tparams.sprstat_abandoned_sent +=\n\t\t\t\tasoc->abandoned_sent[policy];\n\t\t}\n\t} else {\n\t\tparams.sprstat_abandoned_unsent =\n\t\t\tasoc->abandoned_unsent[__SCTP_PR_INDEX(policy)];\n\t\tparams.sprstat_abandoned_sent =\n\t\t\tasoc->abandoned_sent[__SCTP_PR_INDEX(policy)];\n\t}\n\n\tif (put_user(len, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (copy_to_user(optval, &params, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_pr_streamstatus(struct sock *sk, int len,\n\t\t\t\t\t   char __user *optval,\n\t\t\t\t\t   int __user *optlen)\n{\n\tstruct sctp_stream_out_ext *streamoute;\n\tstruct sctp_association *asoc;\n\tstruct sctp_prstatus params;\n\tint retval = -EINVAL;\n\tint policy;\n\n\tif (len < sizeof(params))\n\t\tgoto out;\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tpolicy = params.sprstat_policy;\n\tif (!policy || (policy & ~(SCTP_PR_SCTP_MASK | SCTP_PR_SCTP_ALL)) ||\n\t    ((policy & SCTP_PR_SCTP_ALL) && (policy & SCTP_PR_SCTP_MASK)))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.sprstat_assoc_id);\n\tif (!asoc || params.sprstat_sid >= asoc->stream.outcnt)\n\t\tgoto out;\n\n\tstreamoute = SCTP_SO(&asoc->stream, params.sprstat_sid)->ext;\n\tif (!streamoute) {\n\t\t/* Not allocated yet, means all stats are 0 */\n\t\tparams.sprstat_abandoned_unsent = 0;\n\t\tparams.sprstat_abandoned_sent = 0;\n\t\tretval = 0;\n\t\tgoto out;\n\t}\n\n\tif (policy == SCTP_PR_SCTP_ALL) {\n\t\tparams.sprstat_abandoned_unsent = 0;\n\t\tparams.sprstat_abandoned_sent = 0;\n\t\tfor (policy = 0; policy <= SCTP_PR_INDEX(MAX); policy++) {\n\t\t\tparams.sprstat_abandoned_unsent +=\n\t\t\t\tstreamoute->abandoned_unsent[policy];\n\t\t\tparams.sprstat_abandoned_sent +=\n\t\t\t\tstreamoute->abandoned_sent[policy];\n\t\t}\n\t} else {\n\t\tparams.sprstat_abandoned_unsent =\n\t\t\tstreamoute->abandoned_unsent[__SCTP_PR_INDEX(policy)];\n\t\tparams.sprstat_abandoned_sent =\n\t\t\tstreamoute->abandoned_sent[__SCTP_PR_INDEX(policy)];\n\t}\n\n\tif (put_user(len, optlen) || copy_to_user(optval, &params, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_reconfig_supported(struct sock *sk, int len,\n\t\t\t\t\t      char __user *optval,\n\t\t\t\t\t      int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.assoc_value = asoc ? asoc->peer.reconf_capable\n\t\t\t\t  : sctp_sk(sk)->ep->reconf_enable;\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_enable_strreset(struct sock *sk, int len,\n\t\t\t\t\t   char __user *optval,\n\t\t\t\t\t   int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.assoc_value = asoc ? asoc->strreset_enable\n\t\t\t\t  : sctp_sk(sk)->ep->strreset_enable;\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_scheduler(struct sock *sk, int len,\n\t\t\t\t     char __user *optval,\n\t\t\t\t     int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.assoc_value = asoc ? sctp_sched_get_sched(asoc)\n\t\t\t\t  : sctp_sk(sk)->default_ss;\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_scheduler_value(struct sock *sk, int len,\n\t\t\t\t\t   char __user *optval,\n\t\t\t\t\t   int __user *optlen)\n{\n\tstruct sctp_stream_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tretval = sctp_sched_get_value(asoc, params.stream_id,\n\t\t\t\t      &params.stream_value);\n\tif (retval)\n\t\tgoto out;\n\n\tif (put_user(len, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (copy_to_user(optval, &params, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_interleaving_supported(struct sock *sk, int len,\n\t\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t\t  int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.assoc_value = asoc ? asoc->peer.intl_capable\n\t\t\t\t  : sctp_sk(sk)->ep->intl_enable;\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_reuse_port(struct sock *sk, int len,\n\t\t\t\t      char __user *optval,\n\t\t\t\t      int __user *optlen)\n{\n\tint val;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tval = sctp_sk(sk)->reuse;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_event(struct sock *sk, int len, char __user *optval,\n\t\t\t\t int __user *optlen)\n{\n\tstruct sctp_association *asoc;\n\tstruct sctp_event param;\n\t__u16 subscribe;\n\n\tif (len < sizeof(param))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(param);\n\tif (copy_from_user(&param, optval, len))\n\t\treturn -EFAULT;\n\n\tif (param.se_type < SCTP_SN_TYPE_BASE ||\n\t    param.se_type > SCTP_SN_TYPE_MAX)\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, param.se_assoc_id);\n\tif (!asoc && param.se_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tsubscribe = asoc ? asoc->subscribe : sctp_sk(sk)->subscribe;\n\tparam.se_on = sctp_ulpevent_type_enabled(subscribe, param.se_type);\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(optval, &param, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_asconf_supported(struct sock *sk, int len,\n\t\t\t\t\t    char __user *optval,\n\t\t\t\t\t    int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.assoc_value = asoc ? asoc->peer.asconf_capable\n\t\t\t\t  : sctp_sk(sk)->ep->asconf_enable;\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_auth_supported(struct sock *sk, int len,\n\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t  int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.assoc_value = asoc ? asoc->peer.auth_capable\n\t\t\t\t  : sctp_sk(sk)->ep->auth_enable;\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_ecn_supported(struct sock *sk, int len,\n\t\t\t\t\t char __user *optval,\n\t\t\t\t\t int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.assoc_value = asoc ? asoc->peer.ecn_capable\n\t\t\t\t  : sctp_sk(sk)->ep->ecn_enable;\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_pf_expose(struct sock *sk, int len,\n\t\t\t\t     char __user *optval,\n\t\t\t\t     int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.assoc_value = asoc ? asoc->pf_expose\n\t\t\t\t  : sctp_sk(sk)->pf_expose;\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_encap_port(struct sock *sk, int len,\n\t\t\t\t      char __user *optval, int __user *optlen)\n{\n\tstruct sctp_association *asoc;\n\tstruct sctp_udpencaps encap;\n\tstruct sctp_transport *t;\n\t__be16 encap_port;\n\n\tif (len < sizeof(encap))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(encap);\n\tif (copy_from_user(&encap, optval, len))\n\t\treturn -EFAULT;\n\n\t/* If an address other than INADDR_ANY is specified, and\n\t * no transport is found, then the request is invalid.\n\t */\n\tif (!sctp_is_any(sk, (union sctp_addr *)&encap.sue_address)) {\n\t\tt = sctp_addr_id2transport(sk, &encap.sue_address,\n\t\t\t\t\t   encap.sue_assoc_id);\n\t\tif (!t) {\n\t\t\tpr_debug(\"%s: failed no transport\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tencap_port = t->encap_port;\n\t\tgoto out;\n\t}\n\n\t/* Get association, if assoc_id != SCTP_FUTURE_ASSOC and the\n\t * socket is a one to many style socket, and an association\n\t * was not found, then the id was invalid.\n\t */\n\tasoc = sctp_id2assoc(sk, encap.sue_assoc_id);\n\tif (!asoc && encap.sue_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tpr_debug(\"%s: failed no association\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (asoc) {\n\t\tencap_port = asoc->encap_port;\n\t\tgoto out;\n\t}\n\n\tencap_port = sctp_sk(sk)->encap_port;\n\nout:\n\tencap.sue_port = (__force uint16_t)encap_port;\n\tif (copy_to_user(optval, &encap, len))\n\t\treturn -EFAULT;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, int __user *optlen)\n{\n\tint retval = 0;\n\tint len;\n\n\tpr_debug(\"%s: sk:%p, optname:%d\\n\", __func__, sk, optname);\n\n\t/* I can hardly begin to describe how wrong this is.  This is\n\t * so broken as to be worse than useless.  The API draft\n\t * REALLY is NOT helpful here...  I am not convinced that the\n\t * semantics of getsockopt() with a level OTHER THAN SOL_SCTP\n\t * are at all well-founded.\n\t */\n\tif (level != SOL_SCTP) {\n\t\tstruct sctp_af *af = sctp_sk(sk)->pf->af;\n\n\t\tretval = af->getsockopt(sk, level, optname, optval, optlen);\n\t\treturn retval;\n\t}\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SCTP_STATUS:\n\t\tretval = sctp_getsockopt_sctp_status(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_DISABLE_FRAGMENTS:\n\t\tretval = sctp_getsockopt_disable_fragments(sk, len, optval,\n\t\t\t\t\t\t\t   optlen);\n\t\tbreak;\n\tcase SCTP_EVENTS:\n\t\tretval = sctp_getsockopt_events(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTOCLOSE:\n\t\tretval = sctp_getsockopt_autoclose(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_SOCKOPT_PEELOFF:\n\t\tretval = sctp_getsockopt_peeloff(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_SOCKOPT_PEELOFF_FLAGS:\n\t\tretval = sctp_getsockopt_peeloff_flags(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PEER_ADDR_PARAMS:\n\t\tretval = sctp_getsockopt_peer_addr_params(sk, len, optval,\n\t\t\t\t\t\t\t  optlen);\n\t\tbreak;\n\tcase SCTP_DELAYED_SACK:\n\t\tretval = sctp_getsockopt_delayed_ack(sk, len, optval,\n\t\t\t\t\t\t\t  optlen);\n\t\tbreak;\n\tcase SCTP_INITMSG:\n\t\tretval = sctp_getsockopt_initmsg(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_GET_PEER_ADDRS:\n\t\tretval = sctp_getsockopt_peer_addrs(sk, len, optval,\n\t\t\t\t\t\t    optlen);\n\t\tbreak;\n\tcase SCTP_GET_LOCAL_ADDRS:\n\t\tretval = sctp_getsockopt_local_addrs(sk, len, optval,\n\t\t\t\t\t\t     optlen);\n\t\tbreak;\n\tcase SCTP_SOCKOPT_CONNECTX3:\n\t\tretval = sctp_getsockopt_connectx3(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_SEND_PARAM:\n\t\tretval = sctp_getsockopt_default_send_param(sk, len,\n\t\t\t\t\t\t\t    optval, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_SNDINFO:\n\t\tretval = sctp_getsockopt_default_sndinfo(sk, len,\n\t\t\t\t\t\t\t optval, optlen);\n\t\tbreak;\n\tcase SCTP_PRIMARY_ADDR:\n\t\tretval = sctp_getsockopt_primary_addr(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_NODELAY:\n\t\tretval = sctp_getsockopt_nodelay(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_RTOINFO:\n\t\tretval = sctp_getsockopt_rtoinfo(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_ASSOCINFO:\n\t\tretval = sctp_getsockopt_associnfo(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_I_WANT_MAPPED_V4_ADDR:\n\t\tretval = sctp_getsockopt_mappedv4(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_MAXSEG:\n\t\tretval = sctp_getsockopt_maxseg(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_GET_PEER_ADDR_INFO:\n\t\tretval = sctp_getsockopt_peer_addr_info(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_ADAPTATION_LAYER:\n\t\tretval = sctp_getsockopt_adaptation_layer(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_CONTEXT:\n\t\tretval = sctp_getsockopt_context(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_FRAGMENT_INTERLEAVE:\n\t\tretval = sctp_getsockopt_fragment_interleave(sk, len, optval,\n\t\t\t\t\t\t\t     optlen);\n\t\tbreak;\n\tcase SCTP_PARTIAL_DELIVERY_POINT:\n\t\tretval = sctp_getsockopt_partial_delivery_point(sk, len, optval,\n\t\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_MAX_BURST:\n\t\tretval = sctp_getsockopt_maxburst(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_KEY:\n\tcase SCTP_AUTH_CHUNK:\n\tcase SCTP_AUTH_DELETE_KEY:\n\tcase SCTP_AUTH_DEACTIVATE_KEY:\n\t\tretval = -EOPNOTSUPP;\n\t\tbreak;\n\tcase SCTP_HMAC_IDENT:\n\t\tretval = sctp_getsockopt_hmac_ident(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_ACTIVE_KEY:\n\t\tretval = sctp_getsockopt_active_key(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PEER_AUTH_CHUNKS:\n\t\tretval = sctp_getsockopt_peer_auth_chunks(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_LOCAL_AUTH_CHUNKS:\n\t\tretval = sctp_getsockopt_local_auth_chunks(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_GET_ASSOC_NUMBER:\n\t\tretval = sctp_getsockopt_assoc_number(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_GET_ASSOC_ID_LIST:\n\t\tretval = sctp_getsockopt_assoc_ids(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTO_ASCONF:\n\t\tretval = sctp_getsockopt_auto_asconf(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PEER_ADDR_THLDS:\n\t\tretval = sctp_getsockopt_paddr_thresholds(sk, optval, len,\n\t\t\t\t\t\t\t  optlen, false);\n\t\tbreak;\n\tcase SCTP_PEER_ADDR_THLDS_V2:\n\t\tretval = sctp_getsockopt_paddr_thresholds(sk, optval, len,\n\t\t\t\t\t\t\t  optlen, true);\n\t\tbreak;\n\tcase SCTP_GET_ASSOC_STATS:\n\t\tretval = sctp_getsockopt_assoc_stats(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_RECVRCVINFO:\n\t\tretval = sctp_getsockopt_recvrcvinfo(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_RECVNXTINFO:\n\t\tretval = sctp_getsockopt_recvnxtinfo(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PR_SUPPORTED:\n\t\tretval = sctp_getsockopt_pr_supported(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_PRINFO:\n\t\tretval = sctp_getsockopt_default_prinfo(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_PR_ASSOC_STATUS:\n\t\tretval = sctp_getsockopt_pr_assocstatus(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_PR_STREAM_STATUS:\n\t\tretval = sctp_getsockopt_pr_streamstatus(sk, len, optval,\n\t\t\t\t\t\t\t optlen);\n\t\tbreak;\n\tcase SCTP_RECONFIG_SUPPORTED:\n\t\tretval = sctp_getsockopt_reconfig_supported(sk, len, optval,\n\t\t\t\t\t\t\t    optlen);\n\t\tbreak;\n\tcase SCTP_ENABLE_STREAM_RESET:\n\t\tretval = sctp_getsockopt_enable_strreset(sk, len, optval,\n\t\t\t\t\t\t\t optlen);\n\t\tbreak;\n\tcase SCTP_STREAM_SCHEDULER:\n\t\tretval = sctp_getsockopt_scheduler(sk, len, optval,\n\t\t\t\t\t\t   optlen);\n\t\tbreak;\n\tcase SCTP_STREAM_SCHEDULER_VALUE:\n\t\tretval = sctp_getsockopt_scheduler_value(sk, len, optval,\n\t\t\t\t\t\t\t optlen);\n\t\tbreak;\n\tcase SCTP_INTERLEAVING_SUPPORTED:\n\t\tretval = sctp_getsockopt_interleaving_supported(sk, len, optval,\n\t\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_REUSE_PORT:\n\t\tretval = sctp_getsockopt_reuse_port(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_EVENT:\n\t\tretval = sctp_getsockopt_event(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_ASCONF_SUPPORTED:\n\t\tretval = sctp_getsockopt_asconf_supported(sk, len, optval,\n\t\t\t\t\t\t\t  optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_SUPPORTED:\n\t\tretval = sctp_getsockopt_auth_supported(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_ECN_SUPPORTED:\n\t\tretval = sctp_getsockopt_ecn_supported(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_EXPOSE_POTENTIALLY_FAILED_STATE:\n\t\tretval = sctp_getsockopt_pf_expose(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_REMOTE_UDP_ENCAPS_PORT:\n\t\tretval = sctp_getsockopt_encap_port(sk, len, optval, optlen);\n\t\tbreak;\n\tdefault:\n\t\tretval = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn retval;\n}\n\nstatic int sctp_hash(struct sock *sk)\n{\n\t/* STUB */\n\treturn 0;\n}\n\nstatic void sctp_unhash(struct sock *sk)\n{\n\t/* STUB */\n}\n\n/* Check if port is acceptable.  Possibly find first available port.\n *\n * The port hash table (contained in the 'global' SCTP protocol storage\n * returned by struct sctp_protocol *sctp_get_protocol()). The hash\n * table is an array of 4096 lists (sctp_bind_hashbucket). Each\n * list (the list number is the port number hashed out, so as you\n * would expect from a hash function, all the ports in a given list have\n * such a number that hashes out to the same list number; you were\n * expecting that, right?); so each list has a set of ports, with a\n * link to the socket (struct sock) that uses it, the port number and\n * a fastreuse flag (FIXME: NPI ipg).\n */\nstatic struct sctp_bind_bucket *sctp_bucket_create(\n\tstruct sctp_bind_hashbucket *head, struct net *, unsigned short snum);\n\nstatic int sctp_get_port_local(struct sock *sk, union sctp_addr *addr)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tbool reuse = (sk->sk_reuse || sp->reuse);\n\tstruct sctp_bind_hashbucket *head; /* hash list */\n\tstruct net *net = sock_net(sk);\n\tkuid_t uid = sock_i_uid(sk);\n\tstruct sctp_bind_bucket *pp;\n\tunsigned short snum;\n\tint ret;\n\n\tsnum = ntohs(addr->v4.sin_port);\n\n\tpr_debug(\"%s: begins, snum:%d\\n\", __func__, snum);\n\n\tif (snum == 0) {\n\t\t/* Search for an available port. */\n\t\tint low, high, remaining, index;\n\t\tunsigned int rover;\n\n\t\tinet_get_local_port_range(net, &low, &high);\n\t\tremaining = (high - low) + 1;\n\t\trover = prandom_u32() % remaining + low;\n\n\t\tdo {\n\t\t\trover++;\n\t\t\tif ((rover < low) || (rover > high))\n\t\t\t\trover = low;\n\t\t\tif (inet_is_local_reserved_port(net, rover))\n\t\t\t\tcontinue;\n\t\t\tindex = sctp_phashfn(net, rover);\n\t\t\thead = &sctp_port_hashtable[index];\n\t\t\tspin_lock_bh(&head->lock);\n\t\t\tsctp_for_each_hentry(pp, &head->chain)\n\t\t\t\tif ((pp->port == rover) &&\n\t\t\t\t    net_eq(net, pp->net))\n\t\t\t\t\tgoto next;\n\t\t\tbreak;\n\t\tnext:\n\t\t\tspin_unlock_bh(&head->lock);\n\t\t\tcond_resched();\n\t\t} while (--remaining > 0);\n\n\t\t/* Exhausted local port range during search? */\n\t\tret = 1;\n\t\tif (remaining <= 0)\n\t\t\treturn ret;\n\n\t\t/* OK, here is the one we will use.  HEAD (the port\n\t\t * hash table list entry) is non-NULL and we hold it's\n\t\t * mutex.\n\t\t */\n\t\tsnum = rover;\n\t} else {\n\t\t/* We are given an specific port number; we verify\n\t\t * that it is not being used. If it is used, we will\n\t\t * exahust the search in the hash list corresponding\n\t\t * to the port number (snum) - we detect that with the\n\t\t * port iterator, pp being NULL.\n\t\t */\n\t\thead = &sctp_port_hashtable[sctp_phashfn(net, snum)];\n\t\tspin_lock_bh(&head->lock);\n\t\tsctp_for_each_hentry(pp, &head->chain) {\n\t\t\tif ((pp->port == snum) && net_eq(pp->net, net))\n\t\t\t\tgoto pp_found;\n\t\t}\n\t}\n\tpp = NULL;\n\tgoto pp_not_found;\npp_found:\n\tif (!hlist_empty(&pp->owner)) {\n\t\t/* We had a port hash table hit - there is an\n\t\t * available port (pp != NULL) and it is being\n\t\t * used by other socket (pp->owner not empty); that other\n\t\t * socket is going to be sk2.\n\t\t */\n\t\tstruct sock *sk2;\n\n\t\tpr_debug(\"%s: found a possible match\\n\", __func__);\n\n\t\tif ((pp->fastreuse && reuse &&\n\t\t     sk->sk_state != SCTP_SS_LISTENING) ||\n\t\t    (pp->fastreuseport && sk->sk_reuseport &&\n\t\t     uid_eq(pp->fastuid, uid)))\n\t\t\tgoto success;\n\n\t\t/* Run through the list of sockets bound to the port\n\t\t * (pp->port) [via the pointers bind_next and\n\t\t * bind_pprev in the struct sock *sk2 (pp->sk)]. On each one,\n\t\t * we get the endpoint they describe and run through\n\t\t * the endpoint's list of IP (v4 or v6) addresses,\n\t\t * comparing each of the addresses with the address of\n\t\t * the socket sk. If we find a match, then that means\n\t\t * that this port/socket (sk) combination are already\n\t\t * in an endpoint.\n\t\t */\n\t\tsk_for_each_bound(sk2, &pp->owner) {\n\t\t\tstruct sctp_sock *sp2 = sctp_sk(sk2);\n\t\t\tstruct sctp_endpoint *ep2 = sp2->ep;\n\n\t\t\tif (sk == sk2 ||\n\t\t\t    (reuse && (sk2->sk_reuse || sp2->reuse) &&\n\t\t\t     sk2->sk_state != SCTP_SS_LISTENING) ||\n\t\t\t    (sk->sk_reuseport && sk2->sk_reuseport &&\n\t\t\t     uid_eq(uid, sock_i_uid(sk2))))\n\t\t\t\tcontinue;\n\n\t\t\tif (sctp_bind_addr_conflict(&ep2->base.bind_addr,\n\t\t\t\t\t\t    addr, sp2, sp)) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto fail_unlock;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"%s: found a match\\n\", __func__);\n\t}\npp_not_found:\n\t/* If there was a hash table miss, create a new port.  */\n\tret = 1;\n\tif (!pp && !(pp = sctp_bucket_create(head, net, snum)))\n\t\tgoto fail_unlock;\n\n\t/* In either case (hit or miss), make sure fastreuse is 1 only\n\t * if sk->sk_reuse is too (that is, if the caller requested\n\t * SO_REUSEADDR on this socket -sk-).\n\t */\n\tif (hlist_empty(&pp->owner)) {\n\t\tif (reuse && sk->sk_state != SCTP_SS_LISTENING)\n\t\t\tpp->fastreuse = 1;\n\t\telse\n\t\t\tpp->fastreuse = 0;\n\n\t\tif (sk->sk_reuseport) {\n\t\t\tpp->fastreuseport = 1;\n\t\t\tpp->fastuid = uid;\n\t\t} else {\n\t\t\tpp->fastreuseport = 0;\n\t\t}\n\t} else {\n\t\tif (pp->fastreuse &&\n\t\t    (!reuse || sk->sk_state == SCTP_SS_LISTENING))\n\t\t\tpp->fastreuse = 0;\n\n\t\tif (pp->fastreuseport &&\n\t\t    (!sk->sk_reuseport || !uid_eq(pp->fastuid, uid)))\n\t\t\tpp->fastreuseport = 0;\n\t}\n\n\t/* We are set, so fill up all the data in the hash table\n\t * entry, tie the socket list information with the rest of the\n\t * sockets FIXME: Blurry, NPI (ipg).\n\t */\nsuccess:\n\tif (!sp->bind_hash) {\n\t\tinet_sk(sk)->inet_num = snum;\n\t\tsk_add_bind_node(sk, &pp->owner);\n\t\tsp->bind_hash = pp;\n\t}\n\tret = 0;\n\nfail_unlock:\n\tspin_unlock_bh(&head->lock);\n\treturn ret;\n}\n\n/* Assign a 'snum' port to the socket.  If snum == 0, an ephemeral\n * port is requested.\n */\nstatic int sctp_get_port(struct sock *sk, unsigned short snum)\n{\n\tunion sctp_addr addr;\n\tstruct sctp_af *af = sctp_sk(sk)->pf->af;\n\n\t/* Set up a dummy address struct from the sk. */\n\taf->from_sk(&addr, sk);\n\taddr.v4.sin_port = htons(snum);\n\n\t/* Note: sk->sk_num gets filled in if ephemeral port request. */\n\treturn sctp_get_port_local(sk, &addr);\n}\n\n/*\n *  Move a socket to LISTENING state.\n */\nstatic int sctp_listen_start(struct sock *sk, int backlog)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tstruct crypto_shash *tfm = NULL;\n\tchar alg[32];\n\n\t/* Allocate HMAC for generating cookie. */\n\tif (!sp->hmac && sp->sctp_hmac_alg) {\n\t\tsprintf(alg, \"hmac(%s)\", sp->sctp_hmac_alg);\n\t\ttfm = crypto_alloc_shash(alg, 0, 0);\n\t\tif (IS_ERR(tfm)) {\n\t\t\tnet_info_ratelimited(\"failed to load transform for %s: %ld\\n\",\n\t\t\t\t\t     sp->sctp_hmac_alg, PTR_ERR(tfm));\n\t\t\treturn -ENOSYS;\n\t\t}\n\t\tsctp_sk(sk)->hmac = tfm;\n\t}\n\n\t/*\n\t * If a bind() or sctp_bindx() is not called prior to a listen()\n\t * call that allows new associations to be accepted, the system\n\t * picks an ephemeral port and will choose an address set equivalent\n\t * to binding with a wildcard address.\n\t *\n\t * This is not currently spelled out in the SCTP sockets\n\t * extensions draft, but follows the practice as seen in TCP\n\t * sockets.\n\t *\n\t */\n\tinet_sk_set_state(sk, SCTP_SS_LISTENING);\n\tif (!ep->base.bind_addr.port) {\n\t\tif (sctp_autobind(sk))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tif (sctp_get_port(sk, inet_sk(sk)->inet_num)) {\n\t\t\tinet_sk_set_state(sk, SCTP_SS_CLOSED);\n\t\t\treturn -EADDRINUSE;\n\t\t}\n\t}\n\n\tWRITE_ONCE(sk->sk_max_ack_backlog, backlog);\n\treturn sctp_hash_endpoint(ep);\n}\n\n/*\n * 4.1.3 / 5.1.3 listen()\n *\n *   By default, new associations are not accepted for UDP style sockets.\n *   An application uses listen() to mark a socket as being able to\n *   accept new associations.\n *\n *   On TCP style sockets, applications use listen() to ready the SCTP\n *   endpoint for accepting inbound associations.\n *\n *   On both types of endpoints a backlog of '0' disables listening.\n *\n *  Move a socket to LISTENING state.\n */\nint sctp_inet_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tint err = -EINVAL;\n\n\tif (unlikely(backlog < 0))\n\t\treturn err;\n\n\tlock_sock(sk);\n\n\t/* Peeled-off sockets are not allowed to listen().  */\n\tif (sctp_style(sk, UDP_HIGH_BANDWIDTH))\n\t\tgoto out;\n\n\tif (sock->state != SS_UNCONNECTED)\n\t\tgoto out;\n\n\tif (!sctp_sstate(sk, LISTENING) && !sctp_sstate(sk, CLOSED))\n\t\tgoto out;\n\n\t/* If backlog is zero, disable listening. */\n\tif (!backlog) {\n\t\tif (sctp_sstate(sk, CLOSED))\n\t\t\tgoto out;\n\n\t\terr = 0;\n\t\tsctp_unhash_endpoint(ep);\n\t\tsk->sk_state = SCTP_SS_CLOSED;\n\t\tif (sk->sk_reuse || sctp_sk(sk)->reuse)\n\t\t\tsctp_sk(sk)->bind_hash->fastreuse = 1;\n\t\tgoto out;\n\t}\n\n\t/* If we are already listening, just update the backlog */\n\tif (sctp_sstate(sk, LISTENING))\n\t\tWRITE_ONCE(sk->sk_max_ack_backlog, backlog);\n\telse {\n\t\terr = sctp_listen_start(sk, backlog);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = 0;\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\n/*\n * This function is done by modeling the current datagram_poll() and the\n * tcp_poll().  Note that, based on these implementations, we don't\n * lock the socket in this function, even though it seems that,\n * ideally, locking or some other mechanisms can be used to ensure\n * the integrity of the counters (sndbuf and wmem_alloc) used\n * in this place.  We assume that we don't need locks either until proven\n * otherwise.\n *\n * Another thing to note is that we include the Async I/O support\n * here, again, by modeling the current TCP/UDP code.  We don't have\n * a good way to test with it yet.\n */\n__poll_t sctp_poll(struct file *file, struct socket *sock, poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\t__poll_t mask;\n\n\tpoll_wait(file, sk_sleep(sk), wait);\n\n\tsock_rps_record_flow(sk);\n\n\t/* A TCP-style listening socket becomes readable when the accept queue\n\t * is not empty.\n\t */\n\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\treturn (!list_empty(&sp->ep->asocs)) ?\n\t\t\t(EPOLLIN | EPOLLRDNORM) : 0;\n\n\tmask = 0;\n\n\t/* Is there any exceptional events?  */\n\tif (sk->sk_err || !skb_queue_empty_lockless(&sk->sk_error_queue))\n\t\tmask |= EPOLLERR |\n\t\t\t(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? EPOLLPRI : 0);\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tmask |= EPOLLRDHUP | EPOLLIN | EPOLLRDNORM;\n\tif (sk->sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= EPOLLHUP;\n\n\t/* Is it readable?  Reconsider this code with TCP-style support.  */\n\tif (!skb_queue_empty_lockless(&sk->sk_receive_queue))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\t/* The association is either gone or not ready.  */\n\tif (!sctp_style(sk, UDP) && sctp_sstate(sk, CLOSED))\n\t\treturn mask;\n\n\t/* Is it writable?  */\n\tif (sctp_writeable(sk)) {\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\t} else {\n\t\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\t\t/*\n\t\t * Since the socket is not locked, the buffer\n\t\t * might be made available after the writeable check and\n\t\t * before the bit is set.  This could cause a lost I/O\n\t\t * signal.  tcp_poll() has a race breaker for this race\n\t\t * condition.  Based on their implementation, we put\n\t\t * in the following code to cover it as well.\n\t\t */\n\t\tif (sctp_writeable(sk))\n\t\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\t}\n\treturn mask;\n}\n\n/********************************************************************\n * 2nd Level Abstractions\n ********************************************************************/\n\nstatic struct sctp_bind_bucket *sctp_bucket_create(\n\tstruct sctp_bind_hashbucket *head, struct net *net, unsigned short snum)\n{\n\tstruct sctp_bind_bucket *pp;\n\n\tpp = kmem_cache_alloc(sctp_bucket_cachep, GFP_ATOMIC);\n\tif (pp) {\n\t\tSCTP_DBG_OBJCNT_INC(bind_bucket);\n\t\tpp->port = snum;\n\t\tpp->fastreuse = 0;\n\t\tINIT_HLIST_HEAD(&pp->owner);\n\t\tpp->net = net;\n\t\thlist_add_head(&pp->node, &head->chain);\n\t}\n\treturn pp;\n}\n\n/* Caller must hold hashbucket lock for this tb with local BH disabled */\nstatic void sctp_bucket_destroy(struct sctp_bind_bucket *pp)\n{\n\tif (pp && hlist_empty(&pp->owner)) {\n\t\t__hlist_del(&pp->node);\n\t\tkmem_cache_free(sctp_bucket_cachep, pp);\n\t\tSCTP_DBG_OBJCNT_DEC(bind_bucket);\n\t}\n}\n\n/* Release this socket's reference to a local port.  */\nstatic inline void __sctp_put_port(struct sock *sk)\n{\n\tstruct sctp_bind_hashbucket *head =\n\t\t&sctp_port_hashtable[sctp_phashfn(sock_net(sk),\n\t\t\t\t\t\t  inet_sk(sk)->inet_num)];\n\tstruct sctp_bind_bucket *pp;\n\n\tspin_lock(&head->lock);\n\tpp = sctp_sk(sk)->bind_hash;\n\t__sk_del_bind_node(sk);\n\tsctp_sk(sk)->bind_hash = NULL;\n\tinet_sk(sk)->inet_num = 0;\n\tsctp_bucket_destroy(pp);\n\tspin_unlock(&head->lock);\n}\n\nvoid sctp_put_port(struct sock *sk)\n{\n\tlocal_bh_disable();\n\t__sctp_put_port(sk);\n\tlocal_bh_enable();\n}\n\n/*\n * The system picks an ephemeral port and choose an address set equivalent\n * to binding with a wildcard address.\n * One of those addresses will be the primary address for the association.\n * This automatically enables the multihoming capability of SCTP.\n */\nstatic int sctp_autobind(struct sock *sk)\n{\n\tunion sctp_addr autoaddr;\n\tstruct sctp_af *af;\n\t__be16 port;\n\n\t/* Initialize a local sockaddr structure to INADDR_ANY. */\n\taf = sctp_sk(sk)->pf->af;\n\n\tport = htons(inet_sk(sk)->inet_num);\n\taf->inaddr_any(&autoaddr, port);\n\n\treturn sctp_do_bind(sk, &autoaddr, af->sockaddr_len);\n}\n\n/* Parse out IPPROTO_SCTP CMSG headers.  Perform only minimal validation.\n *\n * From RFC 2292\n * 4.2 The cmsghdr Structure *\n *\n * When ancillary data is sent or received, any number of ancillary data\n * objects can be specified by the msg_control and msg_controllen members of\n * the msghdr structure, because each object is preceded by\n * a cmsghdr structure defining the object's length (the cmsg_len member).\n * Historically Berkeley-derived implementations have passed only one object\n * at a time, but this API allows multiple objects to be\n * passed in a single call to sendmsg() or recvmsg(). The following example\n * shows two ancillary data objects in a control buffer.\n *\n *   |<--------------------------- msg_controllen -------------------------->|\n *   |                                                                       |\n *\n *   |<----- ancillary data object ----->|<----- ancillary data object ----->|\n *\n *   |<---------- CMSG_SPACE() --------->|<---------- CMSG_SPACE() --------->|\n *   |                                   |                                   |\n *\n *   |<---------- cmsg_len ---------->|  |<--------- cmsg_len ----------->|  |\n *\n *   |<--------- CMSG_LEN() --------->|  |<-------- CMSG_LEN() ---------->|  |\n *   |                                |  |                                |  |\n *\n *   +-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+\n *   |cmsg_|cmsg_|cmsg_|XX|           |XX|cmsg_|cmsg_|cmsg_|XX|           |XX|\n *\n *   |len  |level|type |XX|cmsg_data[]|XX|len  |level|type |XX|cmsg_data[]|XX|\n *\n *   +-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+\n *    ^\n *    |\n *\n * msg_control\n * points here\n */\nstatic int sctp_msghdr_parse(const struct msghdr *msg, struct sctp_cmsgs *cmsgs)\n{\n\tstruct msghdr *my_msg = (struct msghdr *)msg;\n\tstruct cmsghdr *cmsg;\n\n\tfor_each_cmsghdr(cmsg, my_msg) {\n\t\tif (!CMSG_OK(my_msg, cmsg))\n\t\t\treturn -EINVAL;\n\n\t\t/* Should we parse this header or ignore?  */\n\t\tif (cmsg->cmsg_level != IPPROTO_SCTP)\n\t\t\tcontinue;\n\n\t\t/* Strictly check lengths following example in SCM code.  */\n\t\tswitch (cmsg->cmsg_type) {\n\t\tcase SCTP_INIT:\n\t\t\t/* SCTP Socket API Extension\n\t\t\t * 5.3.1 SCTP Initiation Structure (SCTP_INIT)\n\t\t\t *\n\t\t\t * This cmsghdr structure provides information for\n\t\t\t * initializing new SCTP associations with sendmsg().\n\t\t\t * The SCTP_INITMSG socket option uses this same data\n\t\t\t * structure.  This structure is not used for\n\t\t\t * recvmsg().\n\t\t\t *\n\t\t\t * cmsg_level    cmsg_type      cmsg_data[]\n\t\t\t * ------------  ------------   ----------------------\n\t\t\t * IPPROTO_SCTP  SCTP_INIT      struct sctp_initmsg\n\t\t\t */\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct sctp_initmsg)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcmsgs->init = CMSG_DATA(cmsg);\n\t\t\tbreak;\n\n\t\tcase SCTP_SNDRCV:\n\t\t\t/* SCTP Socket API Extension\n\t\t\t * 5.3.2 SCTP Header Information Structure(SCTP_SNDRCV)\n\t\t\t *\n\t\t\t * This cmsghdr structure specifies SCTP options for\n\t\t\t * sendmsg() and describes SCTP header information\n\t\t\t * about a received message through recvmsg().\n\t\t\t *\n\t\t\t * cmsg_level    cmsg_type      cmsg_data[]\n\t\t\t * ------------  ------------   ----------------------\n\t\t\t * IPPROTO_SCTP  SCTP_SNDRCV    struct sctp_sndrcvinfo\n\t\t\t */\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct sctp_sndrcvinfo)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcmsgs->srinfo = CMSG_DATA(cmsg);\n\n\t\t\tif (cmsgs->srinfo->sinfo_flags &\n\t\t\t    ~(SCTP_UNORDERED | SCTP_ADDR_OVER |\n\t\t\t      SCTP_SACK_IMMEDIATELY | SCTP_SENDALL |\n\t\t\t      SCTP_PR_SCTP_MASK | SCTP_ABORT | SCTP_EOF))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tcase SCTP_SNDINFO:\n\t\t\t/* SCTP Socket API Extension\n\t\t\t * 5.3.4 SCTP Send Information Structure (SCTP_SNDINFO)\n\t\t\t *\n\t\t\t * This cmsghdr structure specifies SCTP options for\n\t\t\t * sendmsg(). This structure and SCTP_RCVINFO replaces\n\t\t\t * SCTP_SNDRCV which has been deprecated.\n\t\t\t *\n\t\t\t * cmsg_level    cmsg_type      cmsg_data[]\n\t\t\t * ------------  ------------   ---------------------\n\t\t\t * IPPROTO_SCTP  SCTP_SNDINFO    struct sctp_sndinfo\n\t\t\t */\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct sctp_sndinfo)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcmsgs->sinfo = CMSG_DATA(cmsg);\n\n\t\t\tif (cmsgs->sinfo->snd_flags &\n\t\t\t    ~(SCTP_UNORDERED | SCTP_ADDR_OVER |\n\t\t\t      SCTP_SACK_IMMEDIATELY | SCTP_SENDALL |\n\t\t\t      SCTP_PR_SCTP_MASK | SCTP_ABORT | SCTP_EOF))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase SCTP_PRINFO:\n\t\t\t/* SCTP Socket API Extension\n\t\t\t * 5.3.7 SCTP PR-SCTP Information Structure (SCTP_PRINFO)\n\t\t\t *\n\t\t\t * This cmsghdr structure specifies SCTP options for sendmsg().\n\t\t\t *\n\t\t\t * cmsg_level    cmsg_type      cmsg_data[]\n\t\t\t * ------------  ------------   ---------------------\n\t\t\t * IPPROTO_SCTP  SCTP_PRINFO    struct sctp_prinfo\n\t\t\t */\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct sctp_prinfo)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcmsgs->prinfo = CMSG_DATA(cmsg);\n\t\t\tif (cmsgs->prinfo->pr_policy & ~SCTP_PR_SCTP_MASK)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (cmsgs->prinfo->pr_policy == SCTP_PR_SCTP_NONE)\n\t\t\t\tcmsgs->prinfo->pr_value = 0;\n\t\t\tbreak;\n\t\tcase SCTP_AUTHINFO:\n\t\t\t/* SCTP Socket API Extension\n\t\t\t * 5.3.8 SCTP AUTH Information Structure (SCTP_AUTHINFO)\n\t\t\t *\n\t\t\t * This cmsghdr structure specifies SCTP options for sendmsg().\n\t\t\t *\n\t\t\t * cmsg_level    cmsg_type      cmsg_data[]\n\t\t\t * ------------  ------------   ---------------------\n\t\t\t * IPPROTO_SCTP  SCTP_AUTHINFO  struct sctp_authinfo\n\t\t\t */\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct sctp_authinfo)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcmsgs->authinfo = CMSG_DATA(cmsg);\n\t\t\tbreak;\n\t\tcase SCTP_DSTADDRV4:\n\t\tcase SCTP_DSTADDRV6:\n\t\t\t/* SCTP Socket API Extension\n\t\t\t * 5.3.9/10 SCTP Destination IPv4/6 Address Structure (SCTP_DSTADDRV4/6)\n\t\t\t *\n\t\t\t * This cmsghdr structure specifies SCTP options for sendmsg().\n\t\t\t *\n\t\t\t * cmsg_level    cmsg_type         cmsg_data[]\n\t\t\t * ------------  ------------   ---------------------\n\t\t\t * IPPROTO_SCTP  SCTP_DSTADDRV4 struct in_addr\n\t\t\t * ------------  ------------   ---------------------\n\t\t\t * IPPROTO_SCTP  SCTP_DSTADDRV6 struct in6_addr\n\t\t\t */\n\t\t\tcmsgs->addrs_msg = my_msg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * Wait for a packet..\n * Note: This function is the same function as in core/datagram.c\n * with a few modifications to make lksctp work.\n */\nstatic int sctp_wait_for_packet(struct sock *sk, int *err, long *timeo_p)\n{\n\tint error;\n\tDEFINE_WAIT(wait);\n\n\tprepare_to_wait_exclusive(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\n\t/* Socket errors? */\n\terror = sock_error(sk);\n\tif (error)\n\t\tgoto out;\n\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\tgoto ready;\n\n\t/* Socket shut down?  */\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tgoto out;\n\n\t/* Sequenced packets can come disconnected.  If so we report the\n\t * problem.\n\t */\n\terror = -ENOTCONN;\n\n\t/* Is there a good reason to think that we may receive some data?  */\n\tif (list_empty(&sctp_sk(sk)->ep->asocs) && !sctp_sstate(sk, LISTENING))\n\t\tgoto out;\n\n\t/* Handle signals.  */\n\tif (signal_pending(current))\n\t\tgoto interrupted;\n\n\t/* Let another process have a go.  Since we are going to sleep\n\t * anyway.  Note: This may cause odd behaviors if the message\n\t * does not fit in the user's buffer, but this seems to be the\n\t * only way to honor MSG_DONTWAIT realistically.\n\t */\n\trelease_sock(sk);\n\t*timeo_p = schedule_timeout(*timeo_p);\n\tlock_sock(sk);\n\nready:\n\tfinish_wait(sk_sleep(sk), &wait);\n\treturn 0;\n\ninterrupted:\n\terror = sock_intr_errno(*timeo_p);\n\nout:\n\tfinish_wait(sk_sleep(sk), &wait);\n\t*err = error;\n\treturn error;\n}\n\n/* Receive a datagram.\n * Note: This is pretty much the same routine as in core/datagram.c\n * with a few changes to make lksctp work.\n */\nstruct sk_buff *sctp_skb_recv_datagram(struct sock *sk, int flags,\n\t\t\t\t       int noblock, int *err)\n{\n\tint error;\n\tstruct sk_buff *skb;\n\tlong timeo;\n\n\ttimeo = sock_rcvtimeo(sk, noblock);\n\n\tpr_debug(\"%s: timeo:%ld, max:%ld\\n\", __func__, timeo,\n\t\t MAX_SCHEDULE_TIMEOUT);\n\n\tdo {\n\t\t/* Again only user level code calls this function,\n\t\t * so nothing interrupt level\n\t\t * will suddenly eat the receive_queue.\n\t\t *\n\t\t *  Look at current nfs client by the way...\n\t\t *  However, this function was correct in any case. 8)\n\t\t */\n\t\tif (flags & MSG_PEEK) {\n\t\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\t\tif (skb)\n\t\t\t\trefcount_inc(&skb->users);\n\t\t} else {\n\t\t\tskb = __skb_dequeue(&sk->sk_receive_queue);\n\t\t}\n\n\t\tif (skb)\n\t\t\treturn skb;\n\n\t\t/* Caller is allowed not to check sk->sk_err before calling. */\n\t\terror = sock_error(sk);\n\t\tif (error)\n\t\t\tgoto no_packet;\n\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\tbreak;\n\n\t\tif (sk_can_busy_loop(sk)) {\n\t\t\tsk_busy_loop(sk, noblock);\n\n\t\t\tif (!skb_queue_empty_lockless(&sk->sk_receive_queue))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* User doesn't want to wait.  */\n\t\terror = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto no_packet;\n\t} while (sctp_wait_for_packet(sk, err, &timeo) == 0);\n\n\treturn NULL;\n\nno_packet:\n\t*err = error;\n\treturn NULL;\n}\n\n/* If sndbuf has changed, wake up per association sndbuf waiters.  */\nstatic void __sctp_write_space(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\n\tif (sctp_wspace(asoc) <= 0)\n\t\treturn;\n\n\tif (waitqueue_active(&asoc->wait))\n\t\twake_up_interruptible(&asoc->wait);\n\n\tif (sctp_writeable(sk)) {\n\t\tstruct socket_wq *wq;\n\n\t\trcu_read_lock();\n\t\twq = rcu_dereference(sk->sk_wq);\n\t\tif (wq) {\n\t\t\tif (waitqueue_active(&wq->wait))\n\t\t\t\twake_up_interruptible(&wq->wait);\n\n\t\t\t/* Note that we try to include the Async I/O support\n\t\t\t * here by modeling from the current TCP/UDP code.\n\t\t\t * We have not tested with it yet.\n\t\t\t */\n\t\t\tif (!(sk->sk_shutdown & SEND_SHUTDOWN))\n\t\t\t\tsock_wake_async(wq, SOCK_WAKE_SPACE, POLL_OUT);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n}\n\nstatic void sctp_wake_up_waiters(struct sock *sk,\n\t\t\t\t struct sctp_association *asoc)\n{\n\tstruct sctp_association *tmp = asoc;\n\n\t/* We do accounting for the sndbuf space per association,\n\t * so we only need to wake our own association.\n\t */\n\tif (asoc->ep->sndbuf_policy)\n\t\treturn __sctp_write_space(asoc);\n\n\t/* If association goes down and is just flushing its\n\t * outq, then just normally notify others.\n\t */\n\tif (asoc->base.dead)\n\t\treturn sctp_write_space(sk);\n\n\t/* Accounting for the sndbuf space is per socket, so we\n\t * need to wake up others, try to be fair and in case of\n\t * other associations, let them have a go first instead\n\t * of just doing a sctp_write_space() call.\n\t *\n\t * Note that we reach sctp_wake_up_waiters() only when\n\t * associations free up queued chunks, thus we are under\n\t * lock and the list of associations on a socket is\n\t * guaranteed not to change.\n\t */\n\tfor (tmp = list_next_entry(tmp, asocs); 1;\n\t     tmp = list_next_entry(tmp, asocs)) {\n\t\t/* Manually skip the head element. */\n\t\tif (&tmp->asocs == &((sctp_sk(sk))->ep->asocs))\n\t\t\tcontinue;\n\t\t/* Wake up association. */\n\t\t__sctp_write_space(tmp);\n\t\t/* We've reached the end. */\n\t\tif (tmp == asoc)\n\t\t\tbreak;\n\t}\n}\n\n/* Do accounting for the sndbuf space.\n * Decrement the used sndbuf space of the corresponding association by the\n * data size which was just transmitted(freed).\n */\nstatic void sctp_wfree(struct sk_buff *skb)\n{\n\tstruct sctp_chunk *chunk = skb_shinfo(skb)->destructor_arg;\n\tstruct sctp_association *asoc = chunk->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\n\tsk_mem_uncharge(sk, skb->truesize);\n\tsk->sk_wmem_queued -= skb->truesize + sizeof(struct sctp_chunk);\n\tasoc->sndbuf_used -= skb->truesize + sizeof(struct sctp_chunk);\n\tWARN_ON(refcount_sub_and_test(sizeof(struct sctp_chunk),\n\t\t\t\t      &sk->sk_wmem_alloc));\n\n\tif (chunk->shkey) {\n\t\tstruct sctp_shared_key *shkey = chunk->shkey;\n\n\t\t/* refcnt == 2 and !list_empty mean after this release, it's\n\t\t * not being used anywhere, and it's time to notify userland\n\t\t * that this shkey can be freed if it's been deactivated.\n\t\t */\n\t\tif (shkey->deactivated && !list_empty(&shkey->key_list) &&\n\t\t    refcount_read(&shkey->refcnt) == 2) {\n\t\t\tstruct sctp_ulpevent *ev;\n\n\t\t\tev = sctp_ulpevent_make_authkey(asoc, shkey->key_id,\n\t\t\t\t\t\t\tSCTP_AUTH_FREE_KEY,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (ev)\n\t\t\t\tasoc->stream.si->enqueue_event(&asoc->ulpq, ev);\n\t\t}\n\t\tsctp_auth_shkey_release(chunk->shkey);\n\t}\n\n\tsock_wfree(skb);\n\tsctp_wake_up_waiters(sk, asoc);\n\n\tsctp_association_put(asoc);\n}\n\n/* Do accounting for the receive space on the socket.\n * Accounting for the association is done in ulpevent.c\n * We set this as a destructor for the cloned data skbs so that\n * accounting is done at the correct time.\n */\nvoid sctp_sock_rfree(struct sk_buff *skb)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct sctp_ulpevent *event = sctp_skb2event(skb);\n\n\tatomic_sub(event->rmem_len, &sk->sk_rmem_alloc);\n\n\t/*\n\t * Mimic the behavior of sock_rfree\n\t */\n\tsk_mem_uncharge(sk, event->rmem_len);\n}\n\n\n/* Helper function to wait for space in the sndbuf.  */\nstatic int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,\n\t\t\t\tsize_t msg_len)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT(wait);\n\tint err = 0;\n\n\tpr_debug(\"%s: asoc:%p, timeo:%ld, msg_len:%zu\\n\", __func__, asoc,\n\t\t *timeo_p, msg_len);\n\n\t/* Increment the association's refcnt.  */\n\tsctp_association_hold(asoc);\n\n\t/* Wait on the association specific sndbuf space. */\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (asoc->base.dead)\n\t\t\tgoto do_dead;\n\t\tif (!*timeo_p)\n\t\t\tgoto do_nonblock;\n\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING)\n\t\t\tgoto do_error;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\t\tif (sk_under_memory_pressure(sk))\n\t\t\tsk_mem_reclaim(sk);\n\t\tif ((int)msg_len <= sctp_wspace(asoc) &&\n\t\t    sk_wmem_schedule(sk, msg_len))\n\t\t\tbreak;\n\n\t\t/* Let another process have a go.  Since we are going\n\t\t * to sleep anyway.\n\t\t */\n\t\trelease_sock(sk);\n\t\tcurrent_timeo = schedule_timeout(current_timeo);\n\t\tlock_sock(sk);\n\t\tif (sk != asoc->base.sk)\n\t\t\tgoto do_error;\n\n\t\t*timeo_p = current_timeo;\n\t}\n\nout:\n\tfinish_wait(&asoc->wait, &wait);\n\n\t/* Release the association's refcnt.  */\n\tsctp_association_put(asoc);\n\n\treturn err;\n\ndo_dead:\n\terr = -ESRCH;\n\tgoto out;\n\ndo_error:\n\terr = -EPIPE;\n\tgoto out;\n\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\n\ndo_nonblock:\n\terr = -EAGAIN;\n\tgoto out;\n}\n\nvoid sctp_data_ready(struct sock *sk)\n{\n\tstruct socket_wq *wq;\n\n\trcu_read_lock();\n\twq = rcu_dereference(sk->sk_wq);\n\tif (skwq_has_sleeper(wq))\n\t\twake_up_interruptible_sync_poll(&wq->wait, EPOLLIN |\n\t\t\t\t\t\tEPOLLRDNORM | EPOLLRDBAND);\n\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\n\trcu_read_unlock();\n}\n\n/* If socket sndbuf has changed, wake up all per association waiters.  */\nvoid sctp_write_space(struct sock *sk)\n{\n\tstruct sctp_association *asoc;\n\n\t/* Wake up the tasks in each wait queue.  */\n\tlist_for_each_entry(asoc, &((sctp_sk(sk))->ep->asocs), asocs) {\n\t\t__sctp_write_space(asoc);\n\t}\n}\n\n/* Is there any sndbuf space available on the socket?\n *\n * Note that sk_wmem_alloc is the sum of the send buffers on all of the\n * associations on the same socket.  For a UDP-style socket with\n * multiple associations, it is possible for it to be \"unwriteable\"\n * prematurely.  I assume that this is acceptable because\n * a premature \"unwriteable\" is better than an accidental \"writeable\" which\n * would cause an unwanted block under certain circumstances.  For the 1-1\n * UDP-style sockets or TCP-style sockets, this code should work.\n *  - Daisy\n */\nstatic bool sctp_writeable(struct sock *sk)\n{\n\treturn sk->sk_sndbuf > sk->sk_wmem_queued;\n}\n\n/* Wait for an association to go into ESTABLISHED state. If timeout is 0,\n * returns immediately with EINPROGRESS.\n */\nstatic int sctp_wait_for_connect(struct sctp_association *asoc, long *timeo_p)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tint err = 0;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT(wait);\n\n\tpr_debug(\"%s: asoc:%p, timeo:%ld\\n\", __func__, asoc, *timeo_p);\n\n\t/* Increment the association's refcnt.  */\n\tsctp_association_hold(asoc);\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (!*timeo_p)\n\t\t\tgoto do_nonblock;\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\tbreak;\n\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||\n\t\t    asoc->base.dead)\n\t\t\tgoto do_error;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\n\t\tif (sctp_state(asoc, ESTABLISHED))\n\t\t\tbreak;\n\n\t\t/* Let another process have a go.  Since we are going\n\t\t * to sleep anyway.\n\t\t */\n\t\trelease_sock(sk);\n\t\tcurrent_timeo = schedule_timeout(current_timeo);\n\t\tlock_sock(sk);\n\n\t\t*timeo_p = current_timeo;\n\t}\n\nout:\n\tfinish_wait(&asoc->wait, &wait);\n\n\t/* Release the association's refcnt.  */\n\tsctp_association_put(asoc);\n\n\treturn err;\n\ndo_error:\n\tif (asoc->init_err_counter + 1 > asoc->max_init_attempts)\n\t\terr = -ETIMEDOUT;\n\telse\n\t\terr = -ECONNREFUSED;\n\tgoto out;\n\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\n\ndo_nonblock:\n\terr = -EINPROGRESS;\n\tgoto out;\n}\n\nstatic int sctp_wait_for_accept(struct sock *sk, long timeo)\n{\n\tstruct sctp_endpoint *ep;\n\tint err = 0;\n\tDEFINE_WAIT(wait);\n\n\tep = sctp_sk(sk)->ep;\n\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(sk_sleep(sk), &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\n\t\tif (list_empty(&ep->asocs)) {\n\t\t\trelease_sock(sk);\n\t\t\ttimeo = schedule_timeout(timeo);\n\t\t\tlock_sock(sk);\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tif (!sctp_sstate(sk, LISTENING))\n\t\t\tbreak;\n\n\t\terr = 0;\n\t\tif (!list_empty(&ep->asocs))\n\t\t\tbreak;\n\n\t\terr = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\terr = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tbreak;\n\t}\n\n\tfinish_wait(sk_sleep(sk), &wait);\n\n\treturn err;\n}\n\nstatic void sctp_wait_for_close(struct sock *sk, long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tdo {\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\tif (list_empty(&sctp_sk(sk)->ep->asocs))\n\t\t\tbreak;\n\t\trelease_sock(sk);\n\t\ttimeout = schedule_timeout(timeout);\n\t\tlock_sock(sk);\n\t} while (!signal_pending(current) && timeout);\n\n\tfinish_wait(sk_sleep(sk), &wait);\n}\n\nstatic void sctp_skb_set_owner_r_frag(struct sk_buff *skb, struct sock *sk)\n{\n\tstruct sk_buff *frag;\n\n\tif (!skb->data_len)\n\t\tgoto done;\n\n\t/* Don't forget the fragments. */\n\tskb_walk_frags(skb, frag)\n\t\tsctp_skb_set_owner_r_frag(frag, sk);\n\ndone:\n\tsctp_skb_set_owner_r(skb, sk);\n}\n\nvoid sctp_copy_sock(struct sock *newsk, struct sock *sk,\n\t\t    struct sctp_association *asoc)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct inet_sock *newinet;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\n\tnewsk->sk_type = sk->sk_type;\n\tnewsk->sk_bound_dev_if = sk->sk_bound_dev_if;\n\tnewsk->sk_flags = sk->sk_flags;\n\tnewsk->sk_tsflags = sk->sk_tsflags;\n\tnewsk->sk_no_check_tx = sk->sk_no_check_tx;\n\tnewsk->sk_no_check_rx = sk->sk_no_check_rx;\n\tnewsk->sk_reuse = sk->sk_reuse;\n\tsctp_sk(newsk)->reuse = sp->reuse;\n\n\tnewsk->sk_shutdown = sk->sk_shutdown;\n\tnewsk->sk_destruct = sctp_destruct_sock;\n\tnewsk->sk_family = sk->sk_family;\n\tnewsk->sk_protocol = IPPROTO_SCTP;\n\tnewsk->sk_backlog_rcv = sk->sk_prot->backlog_rcv;\n\tnewsk->sk_sndbuf = sk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = sk->sk_rcvbuf;\n\tnewsk->sk_lingertime = sk->sk_lingertime;\n\tnewsk->sk_rcvtimeo = sk->sk_rcvtimeo;\n\tnewsk->sk_sndtimeo = sk->sk_sndtimeo;\n\tnewsk->sk_rxhash = sk->sk_rxhash;\n\n\tnewinet = inet_sk(newsk);\n\n\t/* Initialize sk's sport, dport, rcv_saddr and daddr for\n\t * getsockname() and getpeername()\n\t */\n\tnewinet->inet_sport = inet->inet_sport;\n\tnewinet->inet_saddr = inet->inet_saddr;\n\tnewinet->inet_rcv_saddr = inet->inet_rcv_saddr;\n\tnewinet->inet_dport = htons(asoc->peer.port);\n\tnewinet->pmtudisc = inet->pmtudisc;\n\tnewinet->inet_id = prandom_u32();\n\n\tnewinet->uc_ttl = inet->uc_ttl;\n\tnewinet->mc_loop = 1;\n\tnewinet->mc_ttl = 1;\n\tnewinet->mc_index = 0;\n\tnewinet->mc_list = NULL;\n\n\tif (newsk->sk_flags & SK_FLAGS_TIMESTAMP)\n\t\tnet_enable_timestamp();\n\n\t/* Set newsk security attributes from orginal sk and connection\n\t * security attribute from ep.\n\t */\n\tsecurity_sctp_sk_clone(ep, sk, newsk);\n}\n\nstatic inline void sctp_copy_descendant(struct sock *sk_to,\n\t\t\t\t\tconst struct sock *sk_from)\n{\n\tsize_t ancestor_size = sizeof(struct inet_sock);\n\n\tancestor_size += sk_from->sk_prot->obj_size;\n\tancestor_size -= offsetof(struct sctp_sock, pd_lobby);\n\t__inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);\n}\n\n/* Populate the fields of the newsk from the oldsk and migrate the assoc\n * and its messages to the newsk.\n */\nstatic int sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,\n\t\t\t     struct sctp_association *assoc,\n\t\t\t     enum sctp_socket_type type)\n{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sctp_bind_bucket *pp; /* hash list port iterator */\n\tstruct sctp_endpoint *newep = newsp->ep;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_bind_hashbucket *head;\n\tint err;\n\n\t/* Migrate socket buffer sizes and all the socket level options to the\n\t * new socket.\n\t */\n\tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n\t/* Brute force copy old sctp opt. */\n\tsctp_copy_descendant(newsk, oldsk);\n\n\t/* Restore the ep value that was overwritten with the above structure\n\t * copy.\n\t */\n\tnewsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t/* Hook this new socket in to the bind_hash list. */\n\thead = &sctp_port_hashtable[sctp_phashfn(sock_net(oldsk),\n\t\t\t\t\t\t inet_sk(oldsk)->inet_num)];\n\tspin_lock_bh(&head->lock);\n\tpp = sctp_sk(oldsk)->bind_hash;\n\tsk_add_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->bind_hash = pp;\n\tinet_sk(newsk)->inet_num = inet_sk(oldsk)->inet_num;\n\tspin_unlock_bh(&head->lock);\n\n\t/* Copy the bind_addr list from the original endpoint to the new\n\t * endpoint so that we can handle restarts properly\n\t */\n\terr = sctp_bind_addr_dup(&newsp->ep->base.bind_addr,\n\t\t\t\t &oldsp->ep->base.bind_addr, GFP_KERNEL);\n\tif (err)\n\t\treturn err;\n\n\t/* New ep's auth_hmacs should be set if old ep's is set, in case\n\t * that net->sctp.auth_enable has been changed to 0 by users and\n\t * new ep's auth_hmacs couldn't be set in sctp_endpoint_init().\n\t */\n\tif (oldsp->ep->auth_hmacs) {\n\t\terr = sctp_auth_init_hmacs(newsp->ep, GFP_KERNEL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n\tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n\t\tevent = sctp_skb2event(skb);\n\t\tif (event->asoc == assoc) {\n\t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n\t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t}\n\t}\n\n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tatomic_set(&sctp_sk(newsk)->pd_mode, assoc->ulpq.pd_mode);\n\n\tif (atomic_read(&sctp_sk(oldsk)->pd_mode)) {\n\t\tstruct sk_buff_head *queue;\n\n\t\t/* Decide which queue to move pd_lobby skbs to. */\n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n\t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n\t\t\tevent = sctp_skb2event(skb);\n\t\t\tif (event->asoc == assoc) {\n\t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n\t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t\t}\n\t\t}\n\n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk, NULL);\n\n\t}\n\n\tsctp_for_each_rx_skb(assoc, newsk, sctp_skb_set_owner_r_frag);\n\n\t/* Set the type of socket to indicate that it is peeled off from the\n\t * original UDP-style socket or created with the accept() call on a\n\t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are\n\t * queued to the backlog.  This prevents a potential race between\n\t * backlog processing on the old socket and new-packet processing\n\t * on the new socket.\n\t *\n\t * The caller has just allocated newsk so we can guarantee that other\n\t * paths won't try to lock it and then oldsk.\n\t */\n\tlock_sock_nested(newsk, SINGLE_DEPTH_NESTING);\n\tsctp_for_each_tx_datachunk(assoc, true, sctp_clear_owner_w);\n\tsctp_assoc_migrate(assoc, newsk);\n\tsctp_for_each_tx_datachunk(assoc, false, sctp_set_owner_w);\n\n\t/* If the association on the newsk is already closed before accept()\n\t * is called, set RCV_SHUTDOWN flag.\n\t */\n\tif (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP)) {\n\t\tinet_sk_set_state(newsk, SCTP_SS_CLOSED);\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;\n\t} else {\n\t\tinet_sk_set_state(newsk, SCTP_SS_ESTABLISHED);\n\t}\n\n\trelease_sock(newsk);\n\n\treturn 0;\n}\n\n\n/* This proto struct describes the ULP interface for SCTP.  */\nstruct proto sctp_prot = {\n\t.name        =\t\"SCTP\",\n\t.owner       =\tTHIS_MODULE,\n\t.close       =\tsctp_close,\n\t.disconnect  =\tsctp_disconnect,\n\t.accept      =\tsctp_accept,\n\t.ioctl       =\tsctp_ioctl,\n\t.init        =\tsctp_init_sock,\n\t.destroy     =\tsctp_destroy_sock,\n\t.shutdown    =\tsctp_shutdown,\n\t.setsockopt  =\tsctp_setsockopt,\n\t.getsockopt  =\tsctp_getsockopt,\n\t.sendmsg     =\tsctp_sendmsg,\n\t.recvmsg     =\tsctp_recvmsg,\n\t.bind        =\tsctp_bind,\n\t.bind_add    =  sctp_bind_add,\n\t.backlog_rcv =\tsctp_backlog_rcv,\n\t.hash        =\tsctp_hash,\n\t.unhash      =\tsctp_unhash,\n\t.no_autobind =\ttrue,\n\t.obj_size    =  sizeof(struct sctp_sock),\n\t.useroffset  =  offsetof(struct sctp_sock, subscribe),\n\t.usersize    =  offsetof(struct sctp_sock, initmsg) -\n\t\t\t\toffsetof(struct sctp_sock, subscribe) +\n\t\t\t\tsizeof_field(struct sctp_sock, initmsg),\n\t.sysctl_mem  =  sysctl_sctp_mem,\n\t.sysctl_rmem =  sysctl_sctp_rmem,\n\t.sysctl_wmem =  sysctl_sctp_wmem,\n\t.memory_pressure = &sctp_memory_pressure,\n\t.enter_memory_pressure = sctp_enter_memory_pressure,\n\t.memory_allocated = &sctp_memory_allocated,\n\t.sockets_allocated = &sctp_sockets_allocated,\n};\n\n#if IS_ENABLED(CONFIG_IPV6)\n\n#include <net/transp_v6.h>\nstatic void sctp_v6_destroy_sock(struct sock *sk)\n{\n\tsctp_destroy_sock(sk);\n\tinet6_destroy_sock(sk);\n}\n\nstruct proto sctpv6_prot = {\n\t.name\t\t= \"SCTPv6\",\n\t.owner\t\t= THIS_MODULE,\n\t.close\t\t= sctp_close,\n\t.disconnect\t= sctp_disconnect,\n\t.accept\t\t= sctp_accept,\n\t.ioctl\t\t= sctp_ioctl,\n\t.init\t\t= sctp_init_sock,\n\t.destroy\t= sctp_v6_destroy_sock,\n\t.shutdown\t= sctp_shutdown,\n\t.setsockopt\t= sctp_setsockopt,\n\t.getsockopt\t= sctp_getsockopt,\n\t.sendmsg\t= sctp_sendmsg,\n\t.recvmsg\t= sctp_recvmsg,\n\t.bind\t\t= sctp_bind,\n\t.bind_add\t= sctp_bind_add,\n\t.backlog_rcv\t= sctp_backlog_rcv,\n\t.hash\t\t= sctp_hash,\n\t.unhash\t\t= sctp_unhash,\n\t.no_autobind\t= true,\n\t.obj_size\t= sizeof(struct sctp6_sock),\n\t.useroffset\t= offsetof(struct sctp6_sock, sctp.subscribe),\n\t.usersize\t= offsetof(struct sctp6_sock, sctp.initmsg) -\n\t\t\t\toffsetof(struct sctp6_sock, sctp.subscribe) +\n\t\t\t\tsizeof_field(struct sctp6_sock, sctp.initmsg),\n\t.sysctl_mem\t= sysctl_sctp_mem,\n\t.sysctl_rmem\t= sysctl_sctp_rmem,\n\t.sysctl_wmem\t= sysctl_sctp_wmem,\n\t.memory_pressure = &sctp_memory_pressure,\n\t.enter_memory_pressure = sctp_enter_memory_pressure,\n\t.memory_allocated = &sctp_memory_allocated,\n\t.sockets_allocated = &sctp_sockets_allocated,\n};\n#endif /* IS_ENABLED(CONFIG_IPV6) */\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 7353}, "message": "warn: potential spectre issue 'asoc->abandoned_unsent' [r]"}], "macros": [], "notes": [], "path": "/src/net/sctp/socket.c", "reportHash": "c5119334677433b029f08b9586cdf086", "checkerName": "smatch.check_spectre", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 7355}, "message": "warn: potential spectre issue 'asoc->abandoned_sent' [r]"}], "macros": [], "notes": [], "path": "/src/net/sctp/socket.c", "reportHash": "0a2fa96b61ec45a8070a905fe621b9c5", "checkerName": "smatch.check_spectre", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 7422}, "message": "warn: potential spectre issue 'streamoute->abandoned_unsent' [r]"}], "macros": [], "notes": [], "path": "/src/net/sctp/socket.c", "reportHash": "b95443395ad287e47710db67190f5115", "checkerName": "smatch.check_spectre", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 7424}, "message": "warn: potential spectre issue 'streamoute->abandoned_sent' [r]"}], "macros": [], "notes": [], "path": "/src/net/sctp/socket.c", "reportHash": "13bf9065e7a794aa293828656eef9073", "checkerName": "smatch.check_spectre", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 8224}, "message": "warn: potential spectre issue 'sctp_globals.port_hashtable' [r]"}], "macros": [], "notes": [], "path": "/src/net/sctp/socket.c", "reportHash": "e408a08ea4d124b3e6aec070407b89ef", "checkerName": "smatch.check_spectre", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
