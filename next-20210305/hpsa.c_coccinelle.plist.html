<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/scsi/hpsa.c", "content": "/*\n *    Disk Array driver for HP Smart Array SAS controllers\n *    Copyright (c) 2019-2020 Microchip Technology Inc. and its subsidiaries\n *    Copyright 2016 Microsemi Corporation\n *    Copyright 2014-2015 PMC-Sierra, Inc.\n *    Copyright 2000,2009-2015 Hewlett-Packard Development Company, L.P.\n *\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; version 2 of the License.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or\n *    NON INFRINGEMENT.  See the GNU General Public License for more details.\n *\n *    Questions/Comments/Bugfixes to esc.storagedev@microsemi.com\n *\n */\n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/timer.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/compat.h>\n#include <linux/blktrace_api.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n#include <linux/dma-mapping.h>\n#include <linux/completion.h>\n#include <linux/moduleparam.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_transport_sas.h>\n#include <scsi/scsi_dbg.h>\n#include <linux/cciss_ioctl.h>\n#include <linux/string.h>\n#include <linux/bitmap.h>\n#include <linux/atomic.h>\n#include <linux/jiffies.h>\n#include <linux/percpu-defs.h>\n#include <linux/percpu.h>\n#include <asm/unaligned.h>\n#include <asm/div64.h>\n#include \"hpsa_cmd.h\"\n#include \"hpsa.h\"\n\n/*\n * HPSA_DRIVER_VERSION must be 3 byte values (0-255) separated by '.'\n * with an optional trailing '-' followed by a byte value (0-255).\n */\n#define HPSA_DRIVER_VERSION \"3.4.20-200\"\n#define DRIVER_NAME \"HP HPSA Driver (v \" HPSA_DRIVER_VERSION \")\"\n#define HPSA \"hpsa\"\n\n/* How long to wait for CISS doorbell communication */\n#define CLEAR_EVENT_WAIT_INTERVAL 20\t/* ms for each msleep() call */\n#define MODE_CHANGE_WAIT_INTERVAL 10\t/* ms for each msleep() call */\n#define MAX_CLEAR_EVENT_WAIT 30000\t/* times 20 ms = 600 s */\n#define MAX_MODE_CHANGE_WAIT 2000\t/* times 10 ms = 20 s */\n#define MAX_IOCTL_CONFIG_WAIT 1000\n\n/*define how many times we will try a command because of bus resets */\n#define MAX_CMD_RETRIES 3\n/* How long to wait before giving up on a command */\n#define HPSA_EH_PTRAID_TIMEOUT (240 * HZ)\n\n/* Embedded module documentation macros - see modules.h */\nMODULE_AUTHOR(\"Hewlett-Packard Company\");\nMODULE_DESCRIPTION(\"Driver for HP Smart Array Controller version \" \\\n\tHPSA_DRIVER_VERSION);\nMODULE_SUPPORTED_DEVICE(\"HP Smart Array Controllers\");\nMODULE_VERSION(HPSA_DRIVER_VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"cciss\");\n\nstatic int hpsa_simple_mode;\nmodule_param(hpsa_simple_mode, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(hpsa_simple_mode,\n\t\"Use 'simple mode' rather than 'performant mode'\");\n\n/* define the PCI info for the cards we can control */\nstatic const struct pci_device_id hpsa_pci_device_id[] = {\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSE,     0x103C, 0x3241},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSE,     0x103C, 0x3243},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSE,     0x103C, 0x3245},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSE,     0x103C, 0x3247},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSE,     0x103C, 0x3249},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSE,     0x103C, 0x324A},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSE,     0x103C, 0x324B},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSE,     0x103C, 0x3233},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSF,     0x103C, 0x3350},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSF,     0x103C, 0x3351},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSF,     0x103C, 0x3352},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSF,     0x103C, 0x3353},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSF,     0x103C, 0x3354},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSF,     0x103C, 0x3355},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSF,     0x103C, 0x3356},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSH,     0x103c, 0x1920},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSH,     0x103C, 0x1921},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSH,     0x103C, 0x1922},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSH,     0x103C, 0x1923},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSH,     0x103C, 0x1924},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSH,     0x103c, 0x1925},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSH,     0x103C, 0x1926},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSH,     0x103C, 0x1928},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSH,     0x103C, 0x1929},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSI,     0x103C, 0x21BD},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSI,     0x103C, 0x21BE},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSI,     0x103C, 0x21BF},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSI,     0x103C, 0x21C0},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSI,     0x103C, 0x21C1},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSI,     0x103C, 0x21C2},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSI,     0x103C, 0x21C3},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSI,     0x103C, 0x21C4},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSI,     0x103C, 0x21C5},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSI,     0x103C, 0x21C6},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSI,     0x103C, 0x21C7},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSI,     0x103C, 0x21C8},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSI,     0x103C, 0x21C9},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSI,     0x103C, 0x21CA},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSI,     0x103C, 0x21CB},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSI,     0x103C, 0x21CC},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSI,     0x103C, 0x21CD},\n\t{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSI,     0x103C, 0x21CE},\n\t{PCI_VENDOR_ID_ADAPTEC2, 0x0290, 0x9005, 0x0580},\n\t{PCI_VENDOR_ID_ADAPTEC2, 0x0290, 0x9005, 0x0581},\n\t{PCI_VENDOR_ID_ADAPTEC2, 0x0290, 0x9005, 0x0582},\n\t{PCI_VENDOR_ID_ADAPTEC2, 0x0290, 0x9005, 0x0583},\n\t{PCI_VENDOR_ID_ADAPTEC2, 0x0290, 0x9005, 0x0584},\n\t{PCI_VENDOR_ID_ADAPTEC2, 0x0290, 0x9005, 0x0585},\n\t{PCI_VENDOR_ID_HP_3PAR, 0x0075, 0x1590, 0x0076},\n\t{PCI_VENDOR_ID_HP_3PAR, 0x0075, 0x1590, 0x0087},\n\t{PCI_VENDOR_ID_HP_3PAR, 0x0075, 0x1590, 0x007D},\n\t{PCI_VENDOR_ID_HP_3PAR, 0x0075, 0x1590, 0x0088},\n\t{PCI_VENDOR_ID_HP, 0x333f, 0x103c, 0x333f},\n\t{PCI_VENDOR_ID_HP,     PCI_ANY_ID,\tPCI_ANY_ID, PCI_ANY_ID,\n\t\tPCI_CLASS_STORAGE_RAID << 8, 0xffff << 8, 0},\n\t{PCI_VENDOR_ID_COMPAQ,     PCI_ANY_ID,\tPCI_ANY_ID, PCI_ANY_ID,\n\t\tPCI_CLASS_STORAGE_RAID << 8, 0xffff << 8, 0},\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, hpsa_pci_device_id);\n\n/*  board_id = Subsystem Device ID & Vendor ID\n *  product = Marketing Name for the board\n *  access = Address of the struct of function pointers\n */\nstatic struct board_type products[] = {\n\t{0x40700E11, \"Smart Array 5300\", &SA5A_access},\n\t{0x40800E11, \"Smart Array 5i\", &SA5B_access},\n\t{0x40820E11, \"Smart Array 532\", &SA5B_access},\n\t{0x40830E11, \"Smart Array 5312\", &SA5B_access},\n\t{0x409A0E11, \"Smart Array 641\", &SA5A_access},\n\t{0x409B0E11, \"Smart Array 642\", &SA5A_access},\n\t{0x409C0E11, \"Smart Array 6400\", &SA5A_access},\n\t{0x409D0E11, \"Smart Array 6400 EM\", &SA5A_access},\n\t{0x40910E11, \"Smart Array 6i\", &SA5A_access},\n\t{0x3225103C, \"Smart Array P600\", &SA5A_access},\n\t{0x3223103C, \"Smart Array P800\", &SA5A_access},\n\t{0x3234103C, \"Smart Array P400\", &SA5A_access},\n\t{0x3235103C, \"Smart Array P400i\", &SA5A_access},\n\t{0x3211103C, \"Smart Array E200i\", &SA5A_access},\n\t{0x3212103C, \"Smart Array E200\", &SA5A_access},\n\t{0x3213103C, \"Smart Array E200i\", &SA5A_access},\n\t{0x3214103C, \"Smart Array E200i\", &SA5A_access},\n\t{0x3215103C, \"Smart Array E200i\", &SA5A_access},\n\t{0x3237103C, \"Smart Array E500\", &SA5A_access},\n\t{0x323D103C, \"Smart Array P700m\", &SA5A_access},\n\t{0x3241103C, \"Smart Array P212\", &SA5_access},\n\t{0x3243103C, \"Smart Array P410\", &SA5_access},\n\t{0x3245103C, \"Smart Array P410i\", &SA5_access},\n\t{0x3247103C, \"Smart Array P411\", &SA5_access},\n\t{0x3249103C, \"Smart Array P812\", &SA5_access},\n\t{0x324A103C, \"Smart Array P712m\", &SA5_access},\n\t{0x324B103C, \"Smart Array P711m\", &SA5_access},\n\t{0x3233103C, \"HP StorageWorks 1210m\", &SA5_access}, /* alias of 333f */\n\t{0x3350103C, \"Smart Array P222\", &SA5_access},\n\t{0x3351103C, \"Smart Array P420\", &SA5_access},\n\t{0x3352103C, \"Smart Array P421\", &SA5_access},\n\t{0x3353103C, \"Smart Array P822\", &SA5_access},\n\t{0x3354103C, \"Smart Array P420i\", &SA5_access},\n\t{0x3355103C, \"Smart Array P220i\", &SA5_access},\n\t{0x3356103C, \"Smart Array P721m\", &SA5_access},\n\t{0x1920103C, \"Smart Array P430i\", &SA5_access},\n\t{0x1921103C, \"Smart Array P830i\", &SA5_access},\n\t{0x1922103C, \"Smart Array P430\", &SA5_access},\n\t{0x1923103C, \"Smart Array P431\", &SA5_access},\n\t{0x1924103C, \"Smart Array P830\", &SA5_access},\n\t{0x1925103C, \"Smart Array P831\", &SA5_access},\n\t{0x1926103C, \"Smart Array P731m\", &SA5_access},\n\t{0x1928103C, \"Smart Array P230i\", &SA5_access},\n\t{0x1929103C, \"Smart Array P530\", &SA5_access},\n\t{0x21BD103C, \"Smart Array P244br\", &SA5_access},\n\t{0x21BE103C, \"Smart Array P741m\", &SA5_access},\n\t{0x21BF103C, \"Smart HBA H240ar\", &SA5_access},\n\t{0x21C0103C, \"Smart Array P440ar\", &SA5_access},\n\t{0x21C1103C, \"Smart Array P840ar\", &SA5_access},\n\t{0x21C2103C, \"Smart Array P440\", &SA5_access},\n\t{0x21C3103C, \"Smart Array P441\", &SA5_access},\n\t{0x21C4103C, \"Smart Array\", &SA5_access},\n\t{0x21C5103C, \"Smart Array P841\", &SA5_access},\n\t{0x21C6103C, \"Smart HBA H244br\", &SA5_access},\n\t{0x21C7103C, \"Smart HBA H240\", &SA5_access},\n\t{0x21C8103C, \"Smart HBA H241\", &SA5_access},\n\t{0x21C9103C, \"Smart Array\", &SA5_access},\n\t{0x21CA103C, \"Smart Array P246br\", &SA5_access},\n\t{0x21CB103C, \"Smart Array P840\", &SA5_access},\n\t{0x21CC103C, \"Smart Array\", &SA5_access},\n\t{0x21CD103C, \"Smart Array\", &SA5_access},\n\t{0x21CE103C, \"Smart HBA\", &SA5_access},\n\t{0x05809005, \"SmartHBA-SA\", &SA5_access},\n\t{0x05819005, \"SmartHBA-SA 8i\", &SA5_access},\n\t{0x05829005, \"SmartHBA-SA 8i8e\", &SA5_access},\n\t{0x05839005, \"SmartHBA-SA 8e\", &SA5_access},\n\t{0x05849005, \"SmartHBA-SA 16i\", &SA5_access},\n\t{0x05859005, \"SmartHBA-SA 4i4e\", &SA5_access},\n\t{0x00761590, \"HP Storage P1224 Array Controller\", &SA5_access},\n\t{0x00871590, \"HP Storage P1224e Array Controller\", &SA5_access},\n\t{0x007D1590, \"HP Storage P1228 Array Controller\", &SA5_access},\n\t{0x00881590, \"HP Storage P1228e Array Controller\", &SA5_access},\n\t{0x333f103c, \"HP StorageWorks 1210m Array Controller\", &SA5_access},\n\t{0xFFFF103C, \"Unknown Smart Array\", &SA5_access},\n};\n\nstatic struct scsi_transport_template *hpsa_sas_transport_template;\nstatic int hpsa_add_sas_host(struct ctlr_info *h);\nstatic void hpsa_delete_sas_host(struct ctlr_info *h);\nstatic int hpsa_add_sas_device(struct hpsa_sas_node *hpsa_sas_node,\n\t\t\tstruct hpsa_scsi_dev_t *device);\nstatic void hpsa_remove_sas_device(struct hpsa_scsi_dev_t *device);\nstatic struct hpsa_scsi_dev_t\n\t*hpsa_find_device_by_sas_rphy(struct ctlr_info *h,\n\t\tstruct sas_rphy *rphy);\n\n#define SCSI_CMD_BUSY ((struct scsi_cmnd *)&hpsa_cmd_busy)\nstatic const struct scsi_cmnd hpsa_cmd_busy;\n#define SCSI_CMD_IDLE ((struct scsi_cmnd *)&hpsa_cmd_idle)\nstatic const struct scsi_cmnd hpsa_cmd_idle;\nstatic int number_of_controllers;\n\nstatic irqreturn_t do_hpsa_intr_intx(int irq, void *dev_id);\nstatic irqreturn_t do_hpsa_intr_msi(int irq, void *dev_id);\nstatic int hpsa_ioctl(struct scsi_device *dev, unsigned int cmd,\n\t\t      void __user *arg);\nstatic int hpsa_passthru_ioctl(struct ctlr_info *h,\n\t\t\t       IOCTL_Command_struct *iocommand);\nstatic int hpsa_big_passthru_ioctl(struct ctlr_info *h,\n\t\t\t\t   BIG_IOCTL_Command_struct *ioc);\n\n#ifdef CONFIG_COMPAT\nstatic int hpsa_compat_ioctl(struct scsi_device *dev, unsigned int cmd,\n\tvoid __user *arg);\n#endif\n\nstatic void cmd_free(struct ctlr_info *h, struct CommandList *c);\nstatic struct CommandList *cmd_alloc(struct ctlr_info *h);\nstatic void cmd_tagged_free(struct ctlr_info *h, struct CommandList *c);\nstatic struct CommandList *cmd_tagged_alloc(struct ctlr_info *h,\n\t\t\t\t\t    struct scsi_cmnd *scmd);\nstatic int fill_cmd(struct CommandList *c, u8 cmd, struct ctlr_info *h,\n\tvoid *buff, size_t size, u16 page_code, unsigned char *scsi3addr,\n\tint cmd_type);\nstatic void hpsa_free_cmd_pool(struct ctlr_info *h);\n#define VPD_PAGE (1 << 8)\n#define HPSA_SIMPLE_ERROR_BITS 0x03\n\nstatic int hpsa_scsi_queue_command(struct Scsi_Host *h, struct scsi_cmnd *cmd);\nstatic void hpsa_scan_start(struct Scsi_Host *);\nstatic int hpsa_scan_finished(struct Scsi_Host *sh,\n\tunsigned long elapsed_time);\nstatic int hpsa_change_queue_depth(struct scsi_device *sdev, int qdepth);\n\nstatic int hpsa_eh_device_reset_handler(struct scsi_cmnd *scsicmd);\nstatic int hpsa_slave_alloc(struct scsi_device *sdev);\nstatic int hpsa_slave_configure(struct scsi_device *sdev);\nstatic void hpsa_slave_destroy(struct scsi_device *sdev);\n\nstatic void hpsa_update_scsi_devices(struct ctlr_info *h);\nstatic int check_for_unit_attention(struct ctlr_info *h,\n\tstruct CommandList *c);\nstatic void check_ioctl_unit_attention(struct ctlr_info *h,\n\tstruct CommandList *c);\n/* performant mode helper functions */\nstatic void calc_bucket_map(int *bucket, int num_buckets,\n\tint nsgs, int min_blocks, u32 *bucket_map);\nstatic void hpsa_free_performant_mode(struct ctlr_info *h);\nstatic int hpsa_put_ctlr_into_performant_mode(struct ctlr_info *h);\nstatic inline u32 next_command(struct ctlr_info *h, u8 q);\nstatic int hpsa_find_cfg_addrs(struct pci_dev *pdev, void __iomem *vaddr,\n\t\t\t       u32 *cfg_base_addr, u64 *cfg_base_addr_index,\n\t\t\t       u64 *cfg_offset);\nstatic int hpsa_pci_find_memory_BAR(struct pci_dev *pdev,\n\t\t\t\t    unsigned long *memory_bar);\nstatic int hpsa_lookup_board_id(struct pci_dev *pdev, u32 *board_id,\n\t\t\t\tbool *legacy_board);\nstatic int wait_for_device_to_become_ready(struct ctlr_info *h,\n\t\t\t\t\t   unsigned char lunaddr[],\n\t\t\t\t\t   int reply_queue);\nstatic int hpsa_wait_for_board_state(struct pci_dev *pdev, void __iomem *vaddr,\n\t\t\t\t     int wait_for_ready);\nstatic inline void finish_cmd(struct CommandList *c);\nstatic int hpsa_wait_for_mode_change_ack(struct ctlr_info *h);\n#define BOARD_NOT_READY 0\n#define BOARD_READY 1\nstatic void hpsa_drain_accel_commands(struct ctlr_info *h);\nstatic void hpsa_flush_cache(struct ctlr_info *h);\nstatic int hpsa_scsi_ioaccel_queue_command(struct ctlr_info *h,\n\tstruct CommandList *c, u32 ioaccel_handle, u8 *cdb, int cdb_len,\n\tu8 *scsi3addr, struct hpsa_scsi_dev_t *phys_disk);\nstatic void hpsa_command_resubmit_worker(struct work_struct *work);\nstatic u32 lockup_detected(struct ctlr_info *h);\nstatic int detect_controller_lockup(struct ctlr_info *h);\nstatic void hpsa_disable_rld_caching(struct ctlr_info *h);\nstatic inline int hpsa_scsi_do_report_phys_luns(struct ctlr_info *h,\n\tstruct ReportExtendedLUNdata *buf, int bufsize);\nstatic bool hpsa_vpd_page_supported(struct ctlr_info *h,\n\tunsigned char scsi3addr[], u8 page);\nstatic int hpsa_luns_changed(struct ctlr_info *h);\nstatic bool hpsa_cmd_dev_match(struct ctlr_info *h, struct CommandList *c,\n\t\t\t       struct hpsa_scsi_dev_t *dev,\n\t\t\t       unsigned char *scsi3addr);\n\nstatic inline struct ctlr_info *sdev_to_hba(struct scsi_device *sdev)\n{\n\tunsigned long *priv = shost_priv(sdev->host);\n\treturn (struct ctlr_info *) *priv;\n}\n\nstatic inline struct ctlr_info *shost_to_hba(struct Scsi_Host *sh)\n{\n\tunsigned long *priv = shost_priv(sh);\n\treturn (struct ctlr_info *) *priv;\n}\n\nstatic inline bool hpsa_is_cmd_idle(struct CommandList *c)\n{\n\treturn c->scsi_cmd == SCSI_CMD_IDLE;\n}\n\n/* extract sense key, asc, and ascq from sense data.  -1 means invalid. */\nstatic void decode_sense_data(const u8 *sense_data, int sense_data_len,\n\t\t\tu8 *sense_key, u8 *asc, u8 *ascq)\n{\n\tstruct scsi_sense_hdr sshdr;\n\tbool rc;\n\n\t*sense_key = -1;\n\t*asc = -1;\n\t*ascq = -1;\n\n\tif (sense_data_len < 1)\n\t\treturn;\n\n\trc = scsi_normalize_sense(sense_data, sense_data_len, &sshdr);\n\tif (rc) {\n\t\t*sense_key = sshdr.sense_key;\n\t\t*asc = sshdr.asc;\n\t\t*ascq = sshdr.ascq;\n\t}\n}\n\nstatic int check_for_unit_attention(struct ctlr_info *h,\n\tstruct CommandList *c)\n{\n\tu8 sense_key, asc, ascq;\n\tint sense_len;\n\n\tif (c->err_info->SenseLen > sizeof(c->err_info->SenseInfo))\n\t\tsense_len = sizeof(c->err_info->SenseInfo);\n\telse\n\t\tsense_len = c->err_info->SenseLen;\n\n\tdecode_sense_data(c->err_info->SenseInfo, sense_len,\n\t\t\t\t&sense_key, &asc, &ascq);\n\tif (sense_key != UNIT_ATTENTION || asc == 0xff)\n\t\treturn 0;\n\n\tswitch (asc) {\n\tcase STATE_CHANGED:\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t\"%s: a state change detected, command retried\\n\",\n\t\t\th->devname);\n\t\tbreak;\n\tcase LUN_FAILED:\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t\"%s: LUN failure detected\\n\", h->devname);\n\t\tbreak;\n\tcase REPORT_LUNS_CHANGED:\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t\"%s: report LUN data changed\\n\", h->devname);\n\t/*\n\t * Note: this REPORT_LUNS_CHANGED condition only occurs on the external\n\t * target (array) devices.\n\t */\n\t\tbreak;\n\tcase POWER_OR_RESET:\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t\"%s: a power on or device reset detected\\n\",\n\t\t\th->devname);\n\t\tbreak;\n\tcase UNIT_ATTENTION_CLEARED:\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t\"%s: unit attention cleared by another initiator\\n\",\n\t\t\th->devname);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t\"%s: unknown unit attention detected\\n\",\n\t\t\th->devname);\n\t\tbreak;\n\t}\n\treturn 1;\n}\n\nstatic int check_for_busy(struct ctlr_info *h, struct CommandList *c)\n{\n\tif (c->err_info->CommandStatus != CMD_TARGET_STATUS ||\n\t\t(c->err_info->ScsiStatus != SAM_STAT_BUSY &&\n\t\t c->err_info->ScsiStatus != SAM_STAT_TASK_SET_FULL))\n\t\treturn 0;\n\tdev_warn(&h->pdev->dev, HPSA \"device busy\");\n\treturn 1;\n}\n\nstatic u32 lockup_detected(struct ctlr_info *h);\nstatic ssize_t host_show_lockup_detected(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tint ld;\n\tstruct ctlr_info *h;\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\n\th = shost_to_hba(shost);\n\tld = lockup_detected(h);\n\n\treturn sprintf(buf, \"ld=%d\\n\", ld);\n}\n\nstatic ssize_t host_store_hp_ssd_smart_path_status(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tint status, len;\n\tstruct ctlr_info *h;\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tchar tmpbuf[10];\n\n\tif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\n\t\treturn -EACCES;\n\tlen = count > sizeof(tmpbuf) - 1 ? sizeof(tmpbuf) - 1 : count;\n\tstrncpy(tmpbuf, buf, len);\n\ttmpbuf[len] = '\\0';\n\tif (sscanf(tmpbuf, \"%d\", &status) != 1)\n\t\treturn -EINVAL;\n\th = shost_to_hba(shost);\n\th->acciopath_status = !!status;\n\tdev_warn(&h->pdev->dev,\n\t\t\"hpsa: HP SSD Smart Path %s via sysfs update.\\n\",\n\t\th->acciopath_status ? \"enabled\" : \"disabled\");\n\treturn count;\n}\n\nstatic ssize_t host_store_raid_offload_debug(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tint debug_level, len;\n\tstruct ctlr_info *h;\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tchar tmpbuf[10];\n\n\tif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\n\t\treturn -EACCES;\n\tlen = count > sizeof(tmpbuf) - 1 ? sizeof(tmpbuf) - 1 : count;\n\tstrncpy(tmpbuf, buf, len);\n\ttmpbuf[len] = '\\0';\n\tif (sscanf(tmpbuf, \"%d\", &debug_level) != 1)\n\t\treturn -EINVAL;\n\tif (debug_level < 0)\n\t\tdebug_level = 0;\n\th = shost_to_hba(shost);\n\th->raid_offload_debug = debug_level;\n\tdev_warn(&h->pdev->dev, \"hpsa: Set raid_offload_debug level = %d\\n\",\n\t\th->raid_offload_debug);\n\treturn count;\n}\n\nstatic ssize_t host_store_rescan(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct ctlr_info *h;\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\th = shost_to_hba(shost);\n\thpsa_scan_start(h->scsi_host);\n\treturn count;\n}\n\nstatic void hpsa_turn_off_ioaccel_for_device(struct hpsa_scsi_dev_t *device)\n{\n\tdevice->offload_enabled = 0;\n\tdevice->offload_to_be_enabled = 0;\n}\n\nstatic ssize_t host_show_firmware_revision(struct device *dev,\n\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ctlr_info *h;\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tunsigned char *fwrev;\n\n\th = shost_to_hba(shost);\n\tif (!h->hba_inquiry_data)\n\t\treturn 0;\n\tfwrev = &h->hba_inquiry_data[32];\n\treturn snprintf(buf, 20, \"%c%c%c%c\\n\",\n\t\tfwrev[0], fwrev[1], fwrev[2], fwrev[3]);\n}\n\nstatic ssize_t host_show_commands_outstanding(struct device *dev,\n\t     struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ctlr_info *h = shost_to_hba(shost);\n\n\treturn snprintf(buf, 20, \"%d\\n\",\n\t\t\tatomic_read(&h->commands_outstanding));\n}\n\nstatic ssize_t host_show_transport_mode(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ctlr_info *h;\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\n\th = shost_to_hba(shost);\n\treturn snprintf(buf, 20, \"%s\\n\",\n\t\th->transMethod & CFGTBL_Trans_Performant ?\n\t\t\t\"performant\" : \"simple\");\n}\n\nstatic ssize_t host_show_hp_ssd_smart_path_status(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ctlr_info *h;\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\n\th = shost_to_hba(shost);\n\treturn snprintf(buf, 30, \"HP SSD Smart Path %s\\n\",\n\t\t(h->acciopath_status == 1) ?  \"enabled\" : \"disabled\");\n}\n\n/* List of controllers which cannot be hard reset on kexec with reset_devices */\nstatic u32 unresettable_controller[] = {\n\t0x324a103C, /* Smart Array P712m */\n\t0x324b103C, /* Smart Array P711m */\n\t0x3223103C, /* Smart Array P800 */\n\t0x3234103C, /* Smart Array P400 */\n\t0x3235103C, /* Smart Array P400i */\n\t0x3211103C, /* Smart Array E200i */\n\t0x3212103C, /* Smart Array E200 */\n\t0x3213103C, /* Smart Array E200i */\n\t0x3214103C, /* Smart Array E200i */\n\t0x3215103C, /* Smart Array E200i */\n\t0x3237103C, /* Smart Array E500 */\n\t0x323D103C, /* Smart Array P700m */\n\t0x40800E11, /* Smart Array 5i */\n\t0x409C0E11, /* Smart Array 6400 */\n\t0x409D0E11, /* Smart Array 6400 EM */\n\t0x40700E11, /* Smart Array 5300 */\n\t0x40820E11, /* Smart Array 532 */\n\t0x40830E11, /* Smart Array 5312 */\n\t0x409A0E11, /* Smart Array 641 */\n\t0x409B0E11, /* Smart Array 642 */\n\t0x40910E11, /* Smart Array 6i */\n};\n\n/* List of controllers which cannot even be soft reset */\nstatic u32 soft_unresettable_controller[] = {\n\t0x40800E11, /* Smart Array 5i */\n\t0x40700E11, /* Smart Array 5300 */\n\t0x40820E11, /* Smart Array 532 */\n\t0x40830E11, /* Smart Array 5312 */\n\t0x409A0E11, /* Smart Array 641 */\n\t0x409B0E11, /* Smart Array 642 */\n\t0x40910E11, /* Smart Array 6i */\n\t/* Exclude 640x boards.  These are two pci devices in one slot\n\t * which share a battery backed cache module.  One controls the\n\t * cache, the other accesses the cache through the one that controls\n\t * it.  If we reset the one controlling the cache, the other will\n\t * likely not be happy.  Just forbid resetting this conjoined mess.\n\t * The 640x isn't really supported by hpsa anyway.\n\t */\n\t0x409C0E11, /* Smart Array 6400 */\n\t0x409D0E11, /* Smart Array 6400 EM */\n};\n\nstatic int board_id_in_array(u32 a[], int nelems, u32 board_id)\n{\n\tint i;\n\n\tfor (i = 0; i < nelems; i++)\n\t\tif (a[i] == board_id)\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic int ctlr_is_hard_resettable(u32 board_id)\n{\n\treturn !board_id_in_array(unresettable_controller,\n\t\t\tARRAY_SIZE(unresettable_controller), board_id);\n}\n\nstatic int ctlr_is_soft_resettable(u32 board_id)\n{\n\treturn !board_id_in_array(soft_unresettable_controller,\n\t\t\tARRAY_SIZE(soft_unresettable_controller), board_id);\n}\n\nstatic int ctlr_is_resettable(u32 board_id)\n{\n\treturn ctlr_is_hard_resettable(board_id) ||\n\t\tctlr_is_soft_resettable(board_id);\n}\n\nstatic ssize_t host_show_resettable(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ctlr_info *h;\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\n\th = shost_to_hba(shost);\n\treturn snprintf(buf, 20, \"%d\\n\", ctlr_is_resettable(h->board_id));\n}\n\nstatic inline int is_logical_dev_addr_mode(unsigned char scsi3addr[])\n{\n\treturn (scsi3addr[3] & 0xC0) == 0x40;\n}\n\nstatic const char * const raid_label[] = { \"0\", \"4\", \"1(+0)\", \"5\", \"5+1\", \"6\",\n\t\"1(+0)ADM\", \"UNKNOWN\", \"PHYS DRV\"\n};\n#define HPSA_RAID_0\t0\n#define HPSA_RAID_4\t1\n#define HPSA_RAID_1\t2\t/* also used for RAID 10 */\n#define HPSA_RAID_5\t3\t/* also used for RAID 50 */\n#define HPSA_RAID_51\t4\n#define HPSA_RAID_6\t5\t/* also used for RAID 60 */\n#define HPSA_RAID_ADM\t6\t/* also used for RAID 1+0 ADM */\n#define RAID_UNKNOWN (ARRAY_SIZE(raid_label) - 2)\n#define PHYSICAL_DRIVE (ARRAY_SIZE(raid_label) - 1)\n\nstatic inline bool is_logical_device(struct hpsa_scsi_dev_t *device)\n{\n\treturn !device->physical_device;\n}\n\nstatic ssize_t raid_level_show(struct device *dev,\n\t     struct device_attribute *attr, char *buf)\n{\n\tssize_t l = 0;\n\tunsigned char rlevel;\n\tstruct ctlr_info *h;\n\tstruct scsi_device *sdev;\n\tstruct hpsa_scsi_dev_t *hdev;\n\tunsigned long flags;\n\n\tsdev = to_scsi_device(dev);\n\th = sdev_to_hba(sdev);\n\tspin_lock_irqsave(&h->lock, flags);\n\thdev = sdev->hostdata;\n\tif (!hdev) {\n\t\tspin_unlock_irqrestore(&h->lock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\t/* Is this even a logical drive? */\n\tif (!is_logical_device(hdev)) {\n\t\tspin_unlock_irqrestore(&h->lock, flags);\n\t\tl = snprintf(buf, PAGE_SIZE, \"N/A\\n\");\n\t\treturn l;\n\t}\n\n\trlevel = hdev->raid_level;\n\tspin_unlock_irqrestore(&h->lock, flags);\n\tif (rlevel > RAID_UNKNOWN)\n\t\trlevel = RAID_UNKNOWN;\n\tl = snprintf(buf, PAGE_SIZE, \"RAID %s\\n\", raid_label[rlevel]);\n\treturn l;\n}\n\nstatic ssize_t lunid_show(struct device *dev,\n\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ctlr_info *h;\n\tstruct scsi_device *sdev;\n\tstruct hpsa_scsi_dev_t *hdev;\n\tunsigned long flags;\n\tunsigned char lunid[8];\n\n\tsdev = to_scsi_device(dev);\n\th = sdev_to_hba(sdev);\n\tspin_lock_irqsave(&h->lock, flags);\n\thdev = sdev->hostdata;\n\tif (!hdev) {\n\t\tspin_unlock_irqrestore(&h->lock, flags);\n\t\treturn -ENODEV;\n\t}\n\tmemcpy(lunid, hdev->scsi3addr, sizeof(lunid));\n\tspin_unlock_irqrestore(&h->lock, flags);\n\treturn snprintf(buf, 20, \"0x%8phN\\n\", lunid);\n}\n\nstatic ssize_t unique_id_show(struct device *dev,\n\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ctlr_info *h;\n\tstruct scsi_device *sdev;\n\tstruct hpsa_scsi_dev_t *hdev;\n\tunsigned long flags;\n\tunsigned char sn[16];\n\n\tsdev = to_scsi_device(dev);\n\th = sdev_to_hba(sdev);\n\tspin_lock_irqsave(&h->lock, flags);\n\thdev = sdev->hostdata;\n\tif (!hdev) {\n\t\tspin_unlock_irqrestore(&h->lock, flags);\n\t\treturn -ENODEV;\n\t}\n\tmemcpy(sn, hdev->device_id, sizeof(sn));\n\tspin_unlock_irqrestore(&h->lock, flags);\n\treturn snprintf(buf, 16 * 2 + 2,\n\t\t\t\"%02X%02X%02X%02X%02X%02X%02X%02X\"\n\t\t\t\"%02X%02X%02X%02X%02X%02X%02X%02X\\n\",\n\t\t\tsn[0], sn[1], sn[2], sn[3],\n\t\t\tsn[4], sn[5], sn[6], sn[7],\n\t\t\tsn[8], sn[9], sn[10], sn[11],\n\t\t\tsn[12], sn[13], sn[14], sn[15]);\n}\n\nstatic ssize_t sas_address_show(struct device *dev,\n\t      struct device_attribute *attr, char *buf)\n{\n\tstruct ctlr_info *h;\n\tstruct scsi_device *sdev;\n\tstruct hpsa_scsi_dev_t *hdev;\n\tunsigned long flags;\n\tu64 sas_address;\n\n\tsdev = to_scsi_device(dev);\n\th = sdev_to_hba(sdev);\n\tspin_lock_irqsave(&h->lock, flags);\n\thdev = sdev->hostdata;\n\tif (!hdev || is_logical_device(hdev) || !hdev->expose_device) {\n\t\tspin_unlock_irqrestore(&h->lock, flags);\n\t\treturn -ENODEV;\n\t}\n\tsas_address = hdev->sas_address;\n\tspin_unlock_irqrestore(&h->lock, flags);\n\n\treturn snprintf(buf, PAGE_SIZE, \"0x%016llx\\n\", sas_address);\n}\n\nstatic ssize_t host_show_hp_ssd_smart_path_enabled(struct device *dev,\n\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ctlr_info *h;\n\tstruct scsi_device *sdev;\n\tstruct hpsa_scsi_dev_t *hdev;\n\tunsigned long flags;\n\tint offload_enabled;\n\n\tsdev = to_scsi_device(dev);\n\th = sdev_to_hba(sdev);\n\tspin_lock_irqsave(&h->lock, flags);\n\thdev = sdev->hostdata;\n\tif (!hdev) {\n\t\tspin_unlock_irqrestore(&h->lock, flags);\n\t\treturn -ENODEV;\n\t}\n\toffload_enabled = hdev->offload_enabled;\n\tspin_unlock_irqrestore(&h->lock, flags);\n\n\tif (hdev->devtype == TYPE_DISK || hdev->devtype == TYPE_ZBC)\n\t\treturn snprintf(buf, 20, \"%d\\n\", offload_enabled);\n\telse\n\t\treturn snprintf(buf, 40, \"%s\\n\",\n\t\t\t\t\"Not applicable for a controller\");\n}\n\n#define MAX_PATHS 8\nstatic ssize_t path_info_show(struct device *dev,\n\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ctlr_info *h;\n\tstruct scsi_device *sdev;\n\tstruct hpsa_scsi_dev_t *hdev;\n\tunsigned long flags;\n\tint i;\n\tint output_len = 0;\n\tu8 box;\n\tu8 bay;\n\tu8 path_map_index = 0;\n\tchar *active;\n\tunsigned char phys_connector[2];\n\n\tsdev = to_scsi_device(dev);\n\th = sdev_to_hba(sdev);\n\tspin_lock_irqsave(&h->devlock, flags);\n\thdev = sdev->hostdata;\n\tif (!hdev) {\n\t\tspin_unlock_irqrestore(&h->devlock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\tbay = hdev->bay;\n\tfor (i = 0; i < MAX_PATHS; i++) {\n\t\tpath_map_index = 1<<i;\n\t\tif (i == hdev->active_path_index)\n\t\t\tactive = \"Active\";\n\t\telse if (hdev->path_map & path_map_index)\n\t\t\tactive = \"Inactive\";\n\t\telse\n\t\t\tcontinue;\n\n\t\toutput_len += scnprintf(buf + output_len,\n\t\t\t\tPAGE_SIZE - output_len,\n\t\t\t\t\"[%d:%d:%d:%d] %20.20s \",\n\t\t\t\th->scsi_host->host_no,\n\t\t\t\thdev->bus, hdev->target, hdev->lun,\n\t\t\t\tscsi_device_type(hdev->devtype));\n\n\t\tif (hdev->devtype == TYPE_RAID || is_logical_device(hdev)) {\n\t\t\toutput_len += scnprintf(buf + output_len,\n\t\t\t\t\t\tPAGE_SIZE - output_len,\n\t\t\t\t\t\t\"%s\\n\", active);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbox = hdev->box[i];\n\t\tmemcpy(&phys_connector, &hdev->phys_connector[i],\n\t\t\tsizeof(phys_connector));\n\t\tif (phys_connector[0] < '0')\n\t\t\tphys_connector[0] = '0';\n\t\tif (phys_connector[1] < '0')\n\t\t\tphys_connector[1] = '0';\n\t\toutput_len += scnprintf(buf + output_len,\n\t\t\t\tPAGE_SIZE - output_len,\n\t\t\t\t\"PORT: %.2s \",\n\t\t\t\tphys_connector);\n\t\tif ((hdev->devtype == TYPE_DISK || hdev->devtype == TYPE_ZBC) &&\n\t\t\thdev->expose_device) {\n\t\t\tif (box == 0 || box == 0xFF) {\n\t\t\t\toutput_len += scnprintf(buf + output_len,\n\t\t\t\t\tPAGE_SIZE - output_len,\n\t\t\t\t\t\"BAY: %hhu %s\\n\",\n\t\t\t\t\tbay, active);\n\t\t\t} else {\n\t\t\t\toutput_len += scnprintf(buf + output_len,\n\t\t\t\t\tPAGE_SIZE - output_len,\n\t\t\t\t\t\"BOX: %hhu BAY: %hhu %s\\n\",\n\t\t\t\t\tbox, bay, active);\n\t\t\t}\n\t\t} else if (box != 0 && box != 0xFF) {\n\t\t\toutput_len += scnprintf(buf + output_len,\n\t\t\t\tPAGE_SIZE - output_len, \"BOX: %hhu %s\\n\",\n\t\t\t\tbox, active);\n\t\t} else\n\t\t\toutput_len += scnprintf(buf + output_len,\n\t\t\t\tPAGE_SIZE - output_len, \"%s\\n\", active);\n\t}\n\n\tspin_unlock_irqrestore(&h->devlock, flags);\n\treturn output_len;\n}\n\nstatic ssize_t host_show_ctlr_num(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ctlr_info *h;\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\n\th = shost_to_hba(shost);\n\treturn snprintf(buf, 20, \"%d\\n\", h->ctlr);\n}\n\nstatic ssize_t host_show_legacy_board(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ctlr_info *h;\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\n\th = shost_to_hba(shost);\n\treturn snprintf(buf, 20, \"%d\\n\", h->legacy_board ? 1 : 0);\n}\n\nstatic DEVICE_ATTR_RO(raid_level);\nstatic DEVICE_ATTR_RO(lunid);\nstatic DEVICE_ATTR_RO(unique_id);\nstatic DEVICE_ATTR(rescan, S_IWUSR, NULL, host_store_rescan);\nstatic DEVICE_ATTR_RO(sas_address);\nstatic DEVICE_ATTR(hp_ssd_smart_path_enabled, S_IRUGO,\n\t\t\thost_show_hp_ssd_smart_path_enabled, NULL);\nstatic DEVICE_ATTR_RO(path_info);\nstatic DEVICE_ATTR(hp_ssd_smart_path_status, S_IWUSR|S_IRUGO|S_IROTH,\n\t\thost_show_hp_ssd_smart_path_status,\n\t\thost_store_hp_ssd_smart_path_status);\nstatic DEVICE_ATTR(raid_offload_debug, S_IWUSR, NULL,\n\t\t\thost_store_raid_offload_debug);\nstatic DEVICE_ATTR(firmware_revision, S_IRUGO,\n\thost_show_firmware_revision, NULL);\nstatic DEVICE_ATTR(commands_outstanding, S_IRUGO,\n\thost_show_commands_outstanding, NULL);\nstatic DEVICE_ATTR(transport_mode, S_IRUGO,\n\thost_show_transport_mode, NULL);\nstatic DEVICE_ATTR(resettable, S_IRUGO,\n\thost_show_resettable, NULL);\nstatic DEVICE_ATTR(lockup_detected, S_IRUGO,\n\thost_show_lockup_detected, NULL);\nstatic DEVICE_ATTR(ctlr_num, S_IRUGO,\n\thost_show_ctlr_num, NULL);\nstatic DEVICE_ATTR(legacy_board, S_IRUGO,\n\thost_show_legacy_board, NULL);\n\nstatic struct device_attribute *hpsa_sdev_attrs[] = {\n\t&dev_attr_raid_level,\n\t&dev_attr_lunid,\n\t&dev_attr_unique_id,\n\t&dev_attr_hp_ssd_smart_path_enabled,\n\t&dev_attr_path_info,\n\t&dev_attr_sas_address,\n\tNULL,\n};\n\nstatic struct device_attribute *hpsa_shost_attrs[] = {\n\t&dev_attr_rescan,\n\t&dev_attr_firmware_revision,\n\t&dev_attr_commands_outstanding,\n\t&dev_attr_transport_mode,\n\t&dev_attr_resettable,\n\t&dev_attr_hp_ssd_smart_path_status,\n\t&dev_attr_raid_offload_debug,\n\t&dev_attr_lockup_detected,\n\t&dev_attr_ctlr_num,\n\t&dev_attr_legacy_board,\n\tNULL,\n};\n\n#define HPSA_NRESERVED_CMDS\t(HPSA_CMDS_RESERVED_FOR_DRIVER +\\\n\t\t\t\t HPSA_MAX_CONCURRENT_PASSTHRUS)\n\nstatic struct scsi_host_template hpsa_driver_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= HPSA,\n\t.proc_name\t\t= HPSA,\n\t.queuecommand\t\t= hpsa_scsi_queue_command,\n\t.scan_start\t\t= hpsa_scan_start,\n\t.scan_finished\t\t= hpsa_scan_finished,\n\t.change_queue_depth\t= hpsa_change_queue_depth,\n\t.this_id\t\t= -1,\n\t.eh_device_reset_handler = hpsa_eh_device_reset_handler,\n\t.ioctl\t\t\t= hpsa_ioctl,\n\t.slave_alloc\t\t= hpsa_slave_alloc,\n\t.slave_configure\t= hpsa_slave_configure,\n\t.slave_destroy\t\t= hpsa_slave_destroy,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= hpsa_compat_ioctl,\n#endif\n\t.sdev_attrs = hpsa_sdev_attrs,\n\t.shost_attrs = hpsa_shost_attrs,\n\t.max_sectors = 2048,\n\t.no_write_same = 1,\n};\n\nstatic inline u32 next_command(struct ctlr_info *h, u8 q)\n{\n\tu32 a;\n\tstruct reply_queue_buffer *rq = &h->reply_queue[q];\n\n\tif (h->transMethod & CFGTBL_Trans_io_accel1)\n\t\treturn h->access.command_completed(h, q);\n\n\tif (unlikely(!(h->transMethod & CFGTBL_Trans_Performant)))\n\t\treturn h->access.command_completed(h, q);\n\n\tif ((rq->head[rq->current_entry] & 1) == rq->wraparound) {\n\t\ta = rq->head[rq->current_entry];\n\t\trq->current_entry++;\n\t\tatomic_dec(&h->commands_outstanding);\n\t} else {\n\t\ta = FIFO_EMPTY;\n\t}\n\t/* Check for wraparound */\n\tif (rq->current_entry == h->max_commands) {\n\t\trq->current_entry = 0;\n\t\trq->wraparound ^= 1;\n\t}\n\treturn a;\n}\n\n/*\n * There are some special bits in the bus address of the\n * command that we have to set for the controller to know\n * how to process the command:\n *\n * Normal performant mode:\n * bit 0: 1 means performant mode, 0 means simple mode.\n * bits 1-3 = block fetch table entry\n * bits 4-6 = command type (== 0)\n *\n * ioaccel1 mode:\n * bit 0 = \"performant mode\" bit.\n * bits 1-3 = block fetch table entry\n * bits 4-6 = command type (== 110)\n * (command type is needed because ioaccel1 mode\n * commands are submitted through the same register as normal\n * mode commands, so this is how the controller knows whether\n * the command is normal mode or ioaccel1 mode.)\n *\n * ioaccel2 mode:\n * bit 0 = \"performant mode\" bit.\n * bits 1-4 = block fetch table entry (note extra bit)\n * bits 4-6 = not needed, because ioaccel2 mode has\n * a separate special register for submitting commands.\n */\n\n/*\n * set_performant_mode: Modify the tag for cciss performant\n * set bit 0 for pull model, bits 3-1 for block fetch\n * register number\n */\n#define DEFAULT_REPLY_QUEUE (-1)\nstatic void set_performant_mode(struct ctlr_info *h, struct CommandList *c,\n\t\t\t\t\tint reply_queue)\n{\n\tif (likely(h->transMethod & CFGTBL_Trans_Performant)) {\n\t\tc->busaddr |= 1 | (h->blockFetchTable[c->Header.SGList] << 1);\n\t\tif (unlikely(!h->msix_vectors))\n\t\t\treturn;\n\t\tc->Header.ReplyQueue = reply_queue;\n\t}\n}\n\nstatic void set_ioaccel1_performant_mode(struct ctlr_info *h,\n\t\t\t\t\t\tstruct CommandList *c,\n\t\t\t\t\t\tint reply_queue)\n{\n\tstruct io_accel1_cmd *cp = &h->ioaccel_cmd_pool[c->cmdindex];\n\n\t/*\n\t * Tell the controller to post the reply to the queue for this\n\t * processor.  This seems to give the best I/O throughput.\n\t */\n\tcp->ReplyQueue = reply_queue;\n\t/*\n\t * Set the bits in the address sent down to include:\n\t *  - performant mode bit (bit 0)\n\t *  - pull count (bits 1-3)\n\t *  - command type (bits 4-6)\n\t */\n\tc->busaddr |= 1 | (h->ioaccel1_blockFetchTable[c->Header.SGList] << 1) |\n\t\t\t\t\tIOACCEL1_BUSADDR_CMDTYPE;\n}\n\nstatic void set_ioaccel2_tmf_performant_mode(struct ctlr_info *h,\n\t\t\t\t\t\tstruct CommandList *c,\n\t\t\t\t\t\tint reply_queue)\n{\n\tstruct hpsa_tmf_struct *cp = (struct hpsa_tmf_struct *)\n\t\t&h->ioaccel2_cmd_pool[c->cmdindex];\n\n\t/* Tell the controller to post the reply to the queue for this\n\t * processor.  This seems to give the best I/O throughput.\n\t */\n\tcp->reply_queue = reply_queue;\n\t/* Set the bits in the address sent down to include:\n\t *  - performant mode bit not used in ioaccel mode 2\n\t *  - pull count (bits 0-3)\n\t *  - command type isn't needed for ioaccel2\n\t */\n\tc->busaddr |= h->ioaccel2_blockFetchTable[0];\n}\n\nstatic void set_ioaccel2_performant_mode(struct ctlr_info *h,\n\t\t\t\t\t\tstruct CommandList *c,\n\t\t\t\t\t\tint reply_queue)\n{\n\tstruct io_accel2_cmd *cp = &h->ioaccel2_cmd_pool[c->cmdindex];\n\n\t/*\n\t * Tell the controller to post the reply to the queue for this\n\t * processor.  This seems to give the best I/O throughput.\n\t */\n\tcp->reply_queue = reply_queue;\n\t/*\n\t * Set the bits in the address sent down to include:\n\t *  - performant mode bit not used in ioaccel mode 2\n\t *  - pull count (bits 0-3)\n\t *  - command type isn't needed for ioaccel2\n\t */\n\tc->busaddr |= (h->ioaccel2_blockFetchTable[cp->sg_count]);\n}\n\nstatic int is_firmware_flash_cmd(u8 *cdb)\n{\n\treturn cdb[0] == BMIC_WRITE && cdb[6] == BMIC_FLASH_FIRMWARE;\n}\n\n/*\n * During firmware flash, the heartbeat register may not update as frequently\n * as it should.  So we dial down lockup detection during firmware flash. and\n * dial it back up when firmware flash completes.\n */\n#define HEARTBEAT_SAMPLE_INTERVAL_DURING_FLASH (240 * HZ)\n#define HEARTBEAT_SAMPLE_INTERVAL (30 * HZ)\n#define HPSA_EVENT_MONITOR_INTERVAL (15 * HZ)\nstatic void dial_down_lockup_detection_during_fw_flash(struct ctlr_info *h,\n\t\tstruct CommandList *c)\n{\n\tif (!is_firmware_flash_cmd(c->Request.CDB))\n\t\treturn;\n\tatomic_inc(&h->firmware_flash_in_progress);\n\th->heartbeat_sample_interval = HEARTBEAT_SAMPLE_INTERVAL_DURING_FLASH;\n}\n\nstatic void dial_up_lockup_detection_on_fw_flash_complete(struct ctlr_info *h,\n\t\tstruct CommandList *c)\n{\n\tif (is_firmware_flash_cmd(c->Request.CDB) &&\n\t\tatomic_dec_and_test(&h->firmware_flash_in_progress))\n\t\th->heartbeat_sample_interval = HEARTBEAT_SAMPLE_INTERVAL;\n}\n\nstatic void __enqueue_cmd_and_start_io(struct ctlr_info *h,\n\tstruct CommandList *c, int reply_queue)\n{\n\tdial_down_lockup_detection_during_fw_flash(h, c);\n\tatomic_inc(&h->commands_outstanding);\n\t/*\n\t * Check to see if the command is being retried.\n\t */\n\tif (c->device && !c->retry_pending)\n\t\tatomic_inc(&c->device->commands_outstanding);\n\n\treply_queue = h->reply_map[raw_smp_processor_id()];\n\tswitch (c->cmd_type) {\n\tcase CMD_IOACCEL1:\n\t\tset_ioaccel1_performant_mode(h, c, reply_queue);\n\t\twritel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);\n\t\tbreak;\n\tcase CMD_IOACCEL2:\n\t\tset_ioaccel2_performant_mode(h, c, reply_queue);\n\t\twritel(c->busaddr, h->vaddr + IOACCEL2_INBOUND_POSTQ_32);\n\t\tbreak;\n\tcase IOACCEL2_TMF:\n\t\tset_ioaccel2_tmf_performant_mode(h, c, reply_queue);\n\t\twritel(c->busaddr, h->vaddr + IOACCEL2_INBOUND_POSTQ_32);\n\t\tbreak;\n\tdefault:\n\t\tset_performant_mode(h, c, reply_queue);\n\t\th->access.submit_command(h, c);\n\t}\n}\n\nstatic void enqueue_cmd_and_start_io(struct ctlr_info *h, struct CommandList *c)\n{\n\t__enqueue_cmd_and_start_io(h, c, DEFAULT_REPLY_QUEUE);\n}\n\nstatic inline int is_hba_lunid(unsigned char scsi3addr[])\n{\n\treturn memcmp(scsi3addr, RAID_CTLR_LUNID, 8) == 0;\n}\n\nstatic inline int is_scsi_rev_5(struct ctlr_info *h)\n{\n\tif (!h->hba_inquiry_data)\n\t\treturn 0;\n\tif ((h->hba_inquiry_data[2] & 0x07) == 5)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int hpsa_find_target_lun(struct ctlr_info *h,\n\tunsigned char scsi3addr[], int bus, int *target, int *lun)\n{\n\t/* finds an unused bus, target, lun for a new physical device\n\t * assumes h->devlock is held\n\t */\n\tint i, found = 0;\n\tDECLARE_BITMAP(lun_taken, HPSA_MAX_DEVICES);\n\n\tbitmap_zero(lun_taken, HPSA_MAX_DEVICES);\n\n\tfor (i = 0; i < h->ndevices; i++) {\n\t\tif (h->dev[i]->bus == bus && h->dev[i]->target != -1)\n\t\t\t__set_bit(h->dev[i]->target, lun_taken);\n\t}\n\n\ti = find_first_zero_bit(lun_taken, HPSA_MAX_DEVICES);\n\tif (i < HPSA_MAX_DEVICES) {\n\t\t/* *bus = 1; */\n\t\t*target = i;\n\t\t*lun = 0;\n\t\tfound = 1;\n\t}\n\treturn !found;\n}\n\nstatic void hpsa_show_dev_msg(const char *level, struct ctlr_info *h,\n\tstruct hpsa_scsi_dev_t *dev, char *description)\n{\n#define LABEL_SIZE 25\n\tchar label[LABEL_SIZE];\n\n\tif (h == NULL || h->pdev == NULL || h->scsi_host == NULL)\n\t\treturn;\n\n\tswitch (dev->devtype) {\n\tcase TYPE_RAID:\n\t\tsnprintf(label, LABEL_SIZE, \"controller\");\n\t\tbreak;\n\tcase TYPE_ENCLOSURE:\n\t\tsnprintf(label, LABEL_SIZE, \"enclosure\");\n\t\tbreak;\n\tcase TYPE_DISK:\n\tcase TYPE_ZBC:\n\t\tif (dev->external)\n\t\t\tsnprintf(label, LABEL_SIZE, \"external\");\n\t\telse if (!is_logical_dev_addr_mode(dev->scsi3addr))\n\t\t\tsnprintf(label, LABEL_SIZE, \"%s\",\n\t\t\t\traid_label[PHYSICAL_DRIVE]);\n\t\telse\n\t\t\tsnprintf(label, LABEL_SIZE, \"RAID-%s\",\n\t\t\t\tdev->raid_level > RAID_UNKNOWN ? \"?\" :\n\t\t\t\traid_label[dev->raid_level]);\n\t\tbreak;\n\tcase TYPE_ROM:\n\t\tsnprintf(label, LABEL_SIZE, \"rom\");\n\t\tbreak;\n\tcase TYPE_TAPE:\n\t\tsnprintf(label, LABEL_SIZE, \"tape\");\n\t\tbreak;\n\tcase TYPE_MEDIUM_CHANGER:\n\t\tsnprintf(label, LABEL_SIZE, \"changer\");\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(label, LABEL_SIZE, \"UNKNOWN\");\n\t\tbreak;\n\t}\n\n\tdev_printk(level, &h->pdev->dev,\n\t\t\t\"scsi %d:%d:%d:%d: %s %s %.8s %.16s %s SSDSmartPathCap%c En%c Exp=%d\\n\",\n\t\t\th->scsi_host->host_no, dev->bus, dev->target, dev->lun,\n\t\t\tdescription,\n\t\t\tscsi_device_type(dev->devtype),\n\t\t\tdev->vendor,\n\t\t\tdev->model,\n\t\t\tlabel,\n\t\t\tdev->offload_config ? '+' : '-',\n\t\t\tdev->offload_to_be_enabled ? '+' : '-',\n\t\t\tdev->expose_device);\n}\n\n/* Add an entry into h->dev[] array. */\nstatic int hpsa_scsi_add_entry(struct ctlr_info *h,\n\t\tstruct hpsa_scsi_dev_t *device,\n\t\tstruct hpsa_scsi_dev_t *added[], int *nadded)\n{\n\t/* assumes h->devlock is held */\n\tint n = h->ndevices;\n\tint i;\n\tunsigned char addr1[8], addr2[8];\n\tstruct hpsa_scsi_dev_t *sd;\n\n\tif (n >= HPSA_MAX_DEVICES) {\n\t\tdev_err(&h->pdev->dev, \"too many devices, some will be \"\n\t\t\t\"inaccessible.\\n\");\n\t\treturn -1;\n\t}\n\n\t/* physical devices do not have lun or target assigned until now. */\n\tif (device->lun != -1)\n\t\t/* Logical device, lun is already assigned. */\n\t\tgoto lun_assigned;\n\n\t/* If this device a non-zero lun of a multi-lun device\n\t * byte 4 of the 8-byte LUN addr will contain the logical\n\t * unit no, zero otherwise.\n\t */\n\tif (device->scsi3addr[4] == 0) {\n\t\t/* This is not a non-zero lun of a multi-lun device */\n\t\tif (hpsa_find_target_lun(h, device->scsi3addr,\n\t\t\tdevice->bus, &device->target, &device->lun) != 0)\n\t\t\treturn -1;\n\t\tgoto lun_assigned;\n\t}\n\n\t/* This is a non-zero lun of a multi-lun device.\n\t * Search through our list and find the device which\n\t * has the same 8 byte LUN address, excepting byte 4 and 5.\n\t * Assign the same bus and target for this new LUN.\n\t * Use the logical unit number from the firmware.\n\t */\n\tmemcpy(addr1, device->scsi3addr, 8);\n\taddr1[4] = 0;\n\taddr1[5] = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tsd = h->dev[i];\n\t\tmemcpy(addr2, sd->scsi3addr, 8);\n\t\taddr2[4] = 0;\n\t\taddr2[5] = 0;\n\t\t/* differ only in byte 4 and 5? */\n\t\tif (memcmp(addr1, addr2, 8) == 0) {\n\t\t\tdevice->bus = sd->bus;\n\t\t\tdevice->target = sd->target;\n\t\t\tdevice->lun = device->scsi3addr[4];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (device->lun == -1) {\n\t\tdev_warn(&h->pdev->dev, \"physical device with no LUN=0,\"\n\t\t\t\" suspect firmware bug or unsupported hardware \"\n\t\t\t\"configuration.\\n\");\n\t\treturn -1;\n\t}\n\nlun_assigned:\n\n\th->dev[n] = device;\n\th->ndevices++;\n\tadded[*nadded] = device;\n\t(*nadded)++;\n\thpsa_show_dev_msg(KERN_INFO, h, device,\n\t\tdevice->expose_device ? \"added\" : \"masked\");\n\treturn 0;\n}\n\n/*\n * Called during a scan operation.\n *\n * Update an entry in h->dev[] array.\n */\nstatic void hpsa_scsi_update_entry(struct ctlr_info *h,\n\tint entry, struct hpsa_scsi_dev_t *new_entry)\n{\n\t/* assumes h->devlock is held */\n\tBUG_ON(entry < 0 || entry >= HPSA_MAX_DEVICES);\n\n\t/* Raid level changed. */\n\th->dev[entry]->raid_level = new_entry->raid_level;\n\n\t/*\n\t * ioacccel_handle may have changed for a dual domain disk\n\t */\n\th->dev[entry]->ioaccel_handle = new_entry->ioaccel_handle;\n\n\t/* Raid offload parameters changed.  Careful about the ordering. */\n\tif (new_entry->offload_config && new_entry->offload_to_be_enabled) {\n\t\t/*\n\t\t * if drive is newly offload_enabled, we want to copy the\n\t\t * raid map data first.  If previously offload_enabled and\n\t\t * offload_config were set, raid map data had better be\n\t\t * the same as it was before. If raid map data has changed\n\t\t * then it had better be the case that\n\t\t * h->dev[entry]->offload_enabled is currently 0.\n\t\t */\n\t\th->dev[entry]->raid_map = new_entry->raid_map;\n\t\th->dev[entry]->ioaccel_handle = new_entry->ioaccel_handle;\n\t}\n\tif (new_entry->offload_to_be_enabled) {\n\t\th->dev[entry]->ioaccel_handle = new_entry->ioaccel_handle;\n\t\twmb(); /* set ioaccel_handle *before* hba_ioaccel_enabled */\n\t}\n\th->dev[entry]->hba_ioaccel_enabled = new_entry->hba_ioaccel_enabled;\n\th->dev[entry]->offload_config = new_entry->offload_config;\n\th->dev[entry]->offload_to_mirror = new_entry->offload_to_mirror;\n\th->dev[entry]->queue_depth = new_entry->queue_depth;\n\n\t/*\n\t * We can turn off ioaccel offload now, but need to delay turning\n\t * ioaccel on until we can update h->dev[entry]->phys_disk[], but we\n\t * can't do that until all the devices are updated.\n\t */\n\th->dev[entry]->offload_to_be_enabled = new_entry->offload_to_be_enabled;\n\n\t/*\n\t * turn ioaccel off immediately if told to do so.\n\t */\n\tif (!new_entry->offload_to_be_enabled)\n\t\th->dev[entry]->offload_enabled = 0;\n\n\thpsa_show_dev_msg(KERN_INFO, h, h->dev[entry], \"updated\");\n}\n\n/* Replace an entry from h->dev[] array. */\nstatic void hpsa_scsi_replace_entry(struct ctlr_info *h,\n\tint entry, struct hpsa_scsi_dev_t *new_entry,\n\tstruct hpsa_scsi_dev_t *added[], int *nadded,\n\tstruct hpsa_scsi_dev_t *removed[], int *nremoved)\n{\n\t/* assumes h->devlock is held */\n\tBUG_ON(entry < 0 || entry >= HPSA_MAX_DEVICES);\n\tremoved[*nremoved] = h->dev[entry];\n\t(*nremoved)++;\n\n\t/*\n\t * New physical devices won't have target/lun assigned yet\n\t * so we need to preserve the values in the slot we are replacing.\n\t */\n\tif (new_entry->target == -1) {\n\t\tnew_entry->target = h->dev[entry]->target;\n\t\tnew_entry->lun = h->dev[entry]->lun;\n\t}\n\n\th->dev[entry] = new_entry;\n\tadded[*nadded] = new_entry;\n\t(*nadded)++;\n\n\thpsa_show_dev_msg(KERN_INFO, h, new_entry, \"replaced\");\n}\n\n/* Remove an entry from h->dev[] array. */\nstatic void hpsa_scsi_remove_entry(struct ctlr_info *h, int entry,\n\tstruct hpsa_scsi_dev_t *removed[], int *nremoved)\n{\n\t/* assumes h->devlock is held */\n\tint i;\n\tstruct hpsa_scsi_dev_t *sd;\n\n\tBUG_ON(entry < 0 || entry >= HPSA_MAX_DEVICES);\n\n\tsd = h->dev[entry];\n\tremoved[*nremoved] = h->dev[entry];\n\t(*nremoved)++;\n\n\tfor (i = entry; i < h->ndevices-1; i++)\n\t\th->dev[i] = h->dev[i+1];\n\th->ndevices--;\n\thpsa_show_dev_msg(KERN_INFO, h, sd, \"removed\");\n}\n\n#define SCSI3ADDR_EQ(a, b) ( \\\n\t(a)[7] == (b)[7] && \\\n\t(a)[6] == (b)[6] && \\\n\t(a)[5] == (b)[5] && \\\n\t(a)[4] == (b)[4] && \\\n\t(a)[3] == (b)[3] && \\\n\t(a)[2] == (b)[2] && \\\n\t(a)[1] == (b)[1] && \\\n\t(a)[0] == (b)[0])\n\nstatic void fixup_botched_add(struct ctlr_info *h,\n\tstruct hpsa_scsi_dev_t *added)\n{\n\t/* called when scsi_add_device fails in order to re-adjust\n\t * h->dev[] to match the mid layer's view.\n\t */\n\tunsigned long flags;\n\tint i, j;\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tfor (i = 0; i < h->ndevices; i++) {\n\t\tif (h->dev[i] == added) {\n\t\t\tfor (j = i; j < h->ndevices-1; j++)\n\t\t\t\th->dev[j] = h->dev[j+1];\n\t\t\th->ndevices--;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&h->lock, flags);\n\tkfree(added);\n}\n\nstatic inline int device_is_the_same(struct hpsa_scsi_dev_t *dev1,\n\tstruct hpsa_scsi_dev_t *dev2)\n{\n\t/* we compare everything except lun and target as these\n\t * are not yet assigned.  Compare parts likely\n\t * to differ first\n\t */\n\tif (memcmp(dev1->scsi3addr, dev2->scsi3addr,\n\t\tsizeof(dev1->scsi3addr)) != 0)\n\t\treturn 0;\n\tif (memcmp(dev1->device_id, dev2->device_id,\n\t\tsizeof(dev1->device_id)) != 0)\n\t\treturn 0;\n\tif (memcmp(dev1->model, dev2->model, sizeof(dev1->model)) != 0)\n\t\treturn 0;\n\tif (memcmp(dev1->vendor, dev2->vendor, sizeof(dev1->vendor)) != 0)\n\t\treturn 0;\n\tif (dev1->devtype != dev2->devtype)\n\t\treturn 0;\n\tif (dev1->bus != dev2->bus)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic inline int device_updated(struct hpsa_scsi_dev_t *dev1,\n\tstruct hpsa_scsi_dev_t *dev2)\n{\n\t/* Device attributes that can change, but don't mean\n\t * that the device is a different device, nor that the OS\n\t * needs to be told anything about the change.\n\t */\n\tif (dev1->raid_level != dev2->raid_level)\n\t\treturn 1;\n\tif (dev1->offload_config != dev2->offload_config)\n\t\treturn 1;\n\tif (dev1->offload_to_be_enabled != dev2->offload_to_be_enabled)\n\t\treturn 1;\n\tif (!is_logical_dev_addr_mode(dev1->scsi3addr))\n\t\tif (dev1->queue_depth != dev2->queue_depth)\n\t\t\treturn 1;\n\t/*\n\t * This can happen for dual domain devices. An active\n\t * path change causes the ioaccel handle to change\n\t *\n\t * for example note the handle differences between p0 and p1\n\t * Device                    WWN               ,WWN hash,Handle\n\t * D016 p0|0x3 [02]P2E:01:01,0x5000C5005FC4DACA,0x9B5616,0x01030003\n\t *\tp1                   0x5000C5005FC4DAC9,0x6798C0,0x00040004\n\t */\n\tif (dev1->ioaccel_handle != dev2->ioaccel_handle)\n\t\treturn 1;\n\treturn 0;\n}\n\n/* Find needle in haystack.  If exact match found, return DEVICE_SAME,\n * and return needle location in *index.  If scsi3addr matches, but not\n * vendor, model, serial num, etc. return DEVICE_CHANGED, and return needle\n * location in *index.\n * In the case of a minor device attribute change, such as RAID level, just\n * return DEVICE_UPDATED, along with the updated device's location in index.\n * If needle not found, return DEVICE_NOT_FOUND.\n */\nstatic int hpsa_scsi_find_entry(struct hpsa_scsi_dev_t *needle,\n\tstruct hpsa_scsi_dev_t *haystack[], int haystack_size,\n\tint *index)\n{\n\tint i;\n#define DEVICE_NOT_FOUND 0\n#define DEVICE_CHANGED 1\n#define DEVICE_SAME 2\n#define DEVICE_UPDATED 3\n\tif (needle == NULL)\n\t\treturn DEVICE_NOT_FOUND;\n\n\tfor (i = 0; i < haystack_size; i++) {\n\t\tif (haystack[i] == NULL) /* previously removed. */\n\t\t\tcontinue;\n\t\tif (SCSI3ADDR_EQ(needle->scsi3addr, haystack[i]->scsi3addr)) {\n\t\t\t*index = i;\n\t\t\tif (device_is_the_same(needle, haystack[i])) {\n\t\t\t\tif (device_updated(needle, haystack[i]))\n\t\t\t\t\treturn DEVICE_UPDATED;\n\t\t\t\treturn DEVICE_SAME;\n\t\t\t} else {\n\t\t\t\t/* Keep offline devices offline */\n\t\t\t\tif (needle->volume_offline)\n\t\t\t\t\treturn DEVICE_NOT_FOUND;\n\t\t\t\treturn DEVICE_CHANGED;\n\t\t\t}\n\t\t}\n\t}\n\t*index = -1;\n\treturn DEVICE_NOT_FOUND;\n}\n\nstatic void hpsa_monitor_offline_device(struct ctlr_info *h,\n\t\t\t\t\tunsigned char scsi3addr[])\n{\n\tstruct offline_device_entry *device;\n\tunsigned long flags;\n\n\t/* Check to see if device is already on the list */\n\tspin_lock_irqsave(&h->offline_device_lock, flags);\n\tlist_for_each_entry(device, &h->offline_device_list, offline_list) {\n\t\tif (memcmp(device->scsi3addr, scsi3addr,\n\t\t\tsizeof(device->scsi3addr)) == 0) {\n\t\t\tspin_unlock_irqrestore(&h->offline_device_lock, flags);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&h->offline_device_lock, flags);\n\n\t/* Device is not on the list, add it. */\n\tdevice = kmalloc(sizeof(*device), GFP_KERNEL);\n\tif (!device)\n\t\treturn;\n\n\tmemcpy(device->scsi3addr, scsi3addr, sizeof(device->scsi3addr));\n\tspin_lock_irqsave(&h->offline_device_lock, flags);\n\tlist_add_tail(&device->offline_list, &h->offline_device_list);\n\tspin_unlock_irqrestore(&h->offline_device_lock, flags);\n}\n\n/* Print a message explaining various offline volume states */\nstatic void hpsa_show_volume_status(struct ctlr_info *h,\n\tstruct hpsa_scsi_dev_t *sd)\n{\n\tif (sd->volume_offline == HPSA_VPD_LV_STATUS_UNSUPPORTED)\n\t\tdev_info(&h->pdev->dev,\n\t\t\t\"C%d:B%d:T%d:L%d Volume status is not available through vital product data pages.\\n\",\n\t\t\th->scsi_host->host_no,\n\t\t\tsd->bus, sd->target, sd->lun);\n\tswitch (sd->volume_offline) {\n\tcase HPSA_LV_OK:\n\t\tbreak;\n\tcase HPSA_LV_UNDERGOING_ERASE:\n\t\tdev_info(&h->pdev->dev,\n\t\t\t\"C%d:B%d:T%d:L%d Volume is undergoing background erase process.\\n\",\n\t\t\th->scsi_host->host_no,\n\t\t\tsd->bus, sd->target, sd->lun);\n\t\tbreak;\n\tcase HPSA_LV_NOT_AVAILABLE:\n\t\tdev_info(&h->pdev->dev,\n\t\t\t\"C%d:B%d:T%d:L%d Volume is waiting for transforming volume.\\n\",\n\t\t\th->scsi_host->host_no,\n\t\t\tsd->bus, sd->target, sd->lun);\n\t\tbreak;\n\tcase HPSA_LV_UNDERGOING_RPI:\n\t\tdev_info(&h->pdev->dev,\n\t\t\t\"C%d:B%d:T%d:L%d Volume is undergoing rapid parity init.\\n\",\n\t\t\th->scsi_host->host_no,\n\t\t\tsd->bus, sd->target, sd->lun);\n\t\tbreak;\n\tcase HPSA_LV_PENDING_RPI:\n\t\tdev_info(&h->pdev->dev,\n\t\t\t\"C%d:B%d:T%d:L%d Volume is queued for rapid parity initialization process.\\n\",\n\t\t\th->scsi_host->host_no,\n\t\t\tsd->bus, sd->target, sd->lun);\n\t\tbreak;\n\tcase HPSA_LV_ENCRYPTED_NO_KEY:\n\t\tdev_info(&h->pdev->dev,\n\t\t\t\"C%d:B%d:T%d:L%d Volume is encrypted and cannot be accessed because key is not present.\\n\",\n\t\t\th->scsi_host->host_no,\n\t\t\tsd->bus, sd->target, sd->lun);\n\t\tbreak;\n\tcase HPSA_LV_PLAINTEXT_IN_ENCRYPT_ONLY_CONTROLLER:\n\t\tdev_info(&h->pdev->dev,\n\t\t\t\"C%d:B%d:T%d:L%d Volume is not encrypted and cannot be accessed because controller is in encryption-only mode.\\n\",\n\t\t\th->scsi_host->host_no,\n\t\t\tsd->bus, sd->target, sd->lun);\n\t\tbreak;\n\tcase HPSA_LV_UNDERGOING_ENCRYPTION:\n\t\tdev_info(&h->pdev->dev,\n\t\t\t\"C%d:B%d:T%d:L%d Volume is undergoing encryption process.\\n\",\n\t\t\th->scsi_host->host_no,\n\t\t\tsd->bus, sd->target, sd->lun);\n\t\tbreak;\n\tcase HPSA_LV_UNDERGOING_ENCRYPTION_REKEYING:\n\t\tdev_info(&h->pdev->dev,\n\t\t\t\"C%d:B%d:T%d:L%d Volume is undergoing encryption re-keying process.\\n\",\n\t\t\th->scsi_host->host_no,\n\t\t\tsd->bus, sd->target, sd->lun);\n\t\tbreak;\n\tcase HPSA_LV_ENCRYPTED_IN_NON_ENCRYPTED_CONTROLLER:\n\t\tdev_info(&h->pdev->dev,\n\t\t\t\"C%d:B%d:T%d:L%d Volume is encrypted and cannot be accessed because controller does not have encryption enabled.\\n\",\n\t\t\th->scsi_host->host_no,\n\t\t\tsd->bus, sd->target, sd->lun);\n\t\tbreak;\n\tcase HPSA_LV_PENDING_ENCRYPTION:\n\t\tdev_info(&h->pdev->dev,\n\t\t\t\"C%d:B%d:T%d:L%d Volume is pending migration to encrypted state, but process has not started.\\n\",\n\t\t\th->scsi_host->host_no,\n\t\t\tsd->bus, sd->target, sd->lun);\n\t\tbreak;\n\tcase HPSA_LV_PENDING_ENCRYPTION_REKEYING:\n\t\tdev_info(&h->pdev->dev,\n\t\t\t\"C%d:B%d:T%d:L%d Volume is encrypted and is pending encryption rekeying.\\n\",\n\t\t\th->scsi_host->host_no,\n\t\t\tsd->bus, sd->target, sd->lun);\n\t\tbreak;\n\t}\n}\n\n/*\n * Figure the list of physical drive pointers for a logical drive with\n * raid offload configured.\n */\nstatic void hpsa_figure_phys_disk_ptrs(struct ctlr_info *h,\n\t\t\t\tstruct hpsa_scsi_dev_t *dev[], int ndevices,\n\t\t\t\tstruct hpsa_scsi_dev_t *logical_drive)\n{\n\tstruct raid_map_data *map = &logical_drive->raid_map;\n\tstruct raid_map_disk_data *dd = &map->data[0];\n\tint i, j;\n\tint total_disks_per_row = le16_to_cpu(map->data_disks_per_row) +\n\t\t\t\tle16_to_cpu(map->metadata_disks_per_row);\n\tint nraid_map_entries = le16_to_cpu(map->row_cnt) *\n\t\t\t\tle16_to_cpu(map->layout_map_count) *\n\t\t\t\ttotal_disks_per_row;\n\tint nphys_disk = le16_to_cpu(map->layout_map_count) *\n\t\t\t\ttotal_disks_per_row;\n\tint qdepth;\n\n\tif (nraid_map_entries > RAID_MAP_MAX_ENTRIES)\n\t\tnraid_map_entries = RAID_MAP_MAX_ENTRIES;\n\n\tlogical_drive->nphysical_disks = nraid_map_entries;\n\n\tqdepth = 0;\n\tfor (i = 0; i < nraid_map_entries; i++) {\n\t\tlogical_drive->phys_disk[i] = NULL;\n\t\tif (!logical_drive->offload_config)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < ndevices; j++) {\n\t\t\tif (dev[j] == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (dev[j]->devtype != TYPE_DISK &&\n\t\t\t    dev[j]->devtype != TYPE_ZBC)\n\t\t\t\tcontinue;\n\t\t\tif (is_logical_device(dev[j]))\n\t\t\t\tcontinue;\n\t\t\tif (dev[j]->ioaccel_handle != dd[i].ioaccel_handle)\n\t\t\t\tcontinue;\n\n\t\t\tlogical_drive->phys_disk[i] = dev[j];\n\t\t\tif (i < nphys_disk)\n\t\t\t\tqdepth = min(h->nr_cmds, qdepth +\n\t\t\t\t    logical_drive->phys_disk[i]->queue_depth);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * This can happen if a physical drive is removed and\n\t\t * the logical drive is degraded.  In that case, the RAID\n\t\t * map data will refer to a physical disk which isn't actually\n\t\t * present.  And in that case offload_enabled should already\n\t\t * be 0, but we'll turn it off here just in case\n\t\t */\n\t\tif (!logical_drive->phys_disk[i]) {\n\t\t\tdev_warn(&h->pdev->dev,\n\t\t\t\t\"%s: [%d:%d:%d:%d] A phys disk component of LV is missing, turning off offload_enabled for LV.\\n\",\n\t\t\t\t__func__,\n\t\t\t\th->scsi_host->host_no, logical_drive->bus,\n\t\t\t\tlogical_drive->target, logical_drive->lun);\n\t\t\thpsa_turn_off_ioaccel_for_device(logical_drive);\n\t\t\tlogical_drive->queue_depth = 8;\n\t\t}\n\t}\n\tif (nraid_map_entries)\n\t\t/*\n\t\t * This is correct for reads, too high for full stripe writes,\n\t\t * way too high for partial stripe writes\n\t\t */\n\t\tlogical_drive->queue_depth = qdepth;\n\telse {\n\t\tif (logical_drive->external)\n\t\t\tlogical_drive->queue_depth = EXTERNAL_QD;\n\t\telse\n\t\t\tlogical_drive->queue_depth = h->nr_cmds;\n\t}\n}\n\nstatic void hpsa_update_log_drive_phys_drive_ptrs(struct ctlr_info *h,\n\t\t\t\tstruct hpsa_scsi_dev_t *dev[], int ndevices)\n{\n\tint i;\n\n\tfor (i = 0; i < ndevices; i++) {\n\t\tif (dev[i] == NULL)\n\t\t\tcontinue;\n\t\tif (dev[i]->devtype != TYPE_DISK &&\n\t\t    dev[i]->devtype != TYPE_ZBC)\n\t\t\tcontinue;\n\t\tif (!is_logical_device(dev[i]))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If offload is currently enabled, the RAID map and\n\t\t * phys_disk[] assignment *better* not be changing\n\t\t * because we would be changing ioaccel phsy_disk[] pointers\n\t\t * on a ioaccel volume processing I/O requests.\n\t\t *\n\t\t * If an ioaccel volume status changed, initially because it was\n\t\t * re-configured and thus underwent a transformation, or\n\t\t * a drive failed, we would have received a state change\n\t\t * request and ioaccel should have been turned off. When the\n\t\t * transformation completes, we get another state change\n\t\t * request to turn ioaccel back on. In this case, we need\n\t\t * to update the ioaccel information.\n\t\t *\n\t\t * Thus: If it is not currently enabled, but will be after\n\t\t * the scan completes, make sure the ioaccel pointers\n\t\t * are up to date.\n\t\t */\n\n\t\tif (!dev[i]->offload_enabled && dev[i]->offload_to_be_enabled)\n\t\t\thpsa_figure_phys_disk_ptrs(h, dev, ndevices, dev[i]);\n\t}\n}\n\nstatic int hpsa_add_device(struct ctlr_info *h, struct hpsa_scsi_dev_t *device)\n{\n\tint rc = 0;\n\n\tif (!h->scsi_host)\n\t\treturn 1;\n\n\tif (is_logical_device(device)) /* RAID */\n\t\trc = scsi_add_device(h->scsi_host, device->bus,\n\t\t\t\t\tdevice->target, device->lun);\n\telse /* HBA */\n\t\trc = hpsa_add_sas_device(h->sas_host, device);\n\n\treturn rc;\n}\n\nstatic int hpsa_find_outstanding_commands_for_dev(struct ctlr_info *h,\n\t\t\t\t\t\tstruct hpsa_scsi_dev_t *dev)\n{\n\tint i;\n\tint count = 0;\n\n\tfor (i = 0; i < h->nr_cmds; i++) {\n\t\tstruct CommandList *c = h->cmd_pool + i;\n\t\tint refcount = atomic_inc_return(&c->refcount);\n\n\t\tif (refcount > 1 && hpsa_cmd_dev_match(h, c, dev,\n\t\t\t\tdev->scsi3addr)) {\n\t\t\tunsigned long flags;\n\n\t\t\tspin_lock_irqsave(&h->lock, flags);\t/* Implied MB */\n\t\t\tif (!hpsa_is_cmd_idle(c))\n\t\t\t\t++count;\n\t\t\tspin_unlock_irqrestore(&h->lock, flags);\n\t\t}\n\n\t\tcmd_free(h, c);\n\t}\n\n\treturn count;\n}\n\n#define NUM_WAIT 20\nstatic void hpsa_wait_for_outstanding_commands_for_dev(struct ctlr_info *h,\n\t\t\t\t\t\tstruct hpsa_scsi_dev_t *device)\n{\n\tint cmds = 0;\n\tint waits = 0;\n\tint num_wait = NUM_WAIT;\n\n\tif (device->external)\n\t\tnum_wait = HPSA_EH_PTRAID_TIMEOUT;\n\n\twhile (1) {\n\t\tcmds = hpsa_find_outstanding_commands_for_dev(h, device);\n\t\tif (cmds == 0)\n\t\t\tbreak;\n\t\tif (++waits > num_wait)\n\t\t\tbreak;\n\t\tmsleep(1000);\n\t}\n\n\tif (waits > num_wait) {\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t\"%s: removing device [%d:%d:%d:%d] with %d outstanding commands!\\n\",\n\t\t\t__func__,\n\t\t\th->scsi_host->host_no,\n\t\t\tdevice->bus, device->target, device->lun, cmds);\n\t}\n}\n\nstatic void hpsa_remove_device(struct ctlr_info *h,\n\t\t\tstruct hpsa_scsi_dev_t *device)\n{\n\tstruct scsi_device *sdev = NULL;\n\n\tif (!h->scsi_host)\n\t\treturn;\n\n\t/*\n\t * Allow for commands to drain\n\t */\n\tdevice->removed = 1;\n\thpsa_wait_for_outstanding_commands_for_dev(h, device);\n\n\tif (is_logical_device(device)) { /* RAID */\n\t\tsdev = scsi_device_lookup(h->scsi_host, device->bus,\n\t\t\t\t\t\tdevice->target, device->lun);\n\t\tif (sdev) {\n\t\t\tscsi_remove_device(sdev);\n\t\t\tscsi_device_put(sdev);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We don't expect to get here.  Future commands\n\t\t\t * to this device will get a selection timeout as\n\t\t\t * if the device were gone.\n\t\t\t */\n\t\t\thpsa_show_dev_msg(KERN_WARNING, h, device,\n\t\t\t\t\t\"didn't find device for removal.\");\n\t\t}\n\t} else { /* HBA */\n\n\t\thpsa_remove_sas_device(device);\n\t}\n}\n\nstatic void adjust_hpsa_scsi_table(struct ctlr_info *h,\n\tstruct hpsa_scsi_dev_t *sd[], int nsds)\n{\n\t/* sd contains scsi3 addresses and devtypes, and inquiry\n\t * data.  This function takes what's in sd to be the current\n\t * reality and updates h->dev[] to reflect that reality.\n\t */\n\tint i, entry, device_change, changes = 0;\n\tstruct hpsa_scsi_dev_t *csd;\n\tunsigned long flags;\n\tstruct hpsa_scsi_dev_t **added, **removed;\n\tint nadded, nremoved;\n\n\t/*\n\t * A reset can cause a device status to change\n\t * re-schedule the scan to see what happened.\n\t */\n\tspin_lock_irqsave(&h->reset_lock, flags);\n\tif (h->reset_in_progress) {\n\t\th->drv_req_rescan = 1;\n\t\tspin_unlock_irqrestore(&h->reset_lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&h->reset_lock, flags);\n\n\tadded = kcalloc(HPSA_MAX_DEVICES, sizeof(*added), GFP_KERNEL);\n\tremoved = kcalloc(HPSA_MAX_DEVICES, sizeof(*removed), GFP_KERNEL);\n\n\tif (!added || !removed) {\n\t\tdev_warn(&h->pdev->dev, \"out of memory in \"\n\t\t\t\"adjust_hpsa_scsi_table\\n\");\n\t\tgoto free_and_out;\n\t}\n\n\tspin_lock_irqsave(&h->devlock, flags);\n\n\t/* find any devices in h->dev[] that are not in\n\t * sd[] and remove them from h->dev[], and for any\n\t * devices which have changed, remove the old device\n\t * info and add the new device info.\n\t * If minor device attributes change, just update\n\t * the existing device structure.\n\t */\n\ti = 0;\n\tnremoved = 0;\n\tnadded = 0;\n\twhile (i < h->ndevices) {\n\t\tcsd = h->dev[i];\n\t\tdevice_change = hpsa_scsi_find_entry(csd, sd, nsds, &entry);\n\t\tif (device_change == DEVICE_NOT_FOUND) {\n\t\t\tchanges++;\n\t\t\thpsa_scsi_remove_entry(h, i, removed, &nremoved);\n\t\t\tcontinue; /* remove ^^^, hence i not incremented */\n\t\t} else if (device_change == DEVICE_CHANGED) {\n\t\t\tchanges++;\n\t\t\thpsa_scsi_replace_entry(h, i, sd[entry],\n\t\t\t\tadded, &nadded, removed, &nremoved);\n\t\t\t/* Set it to NULL to prevent it from being freed\n\t\t\t * at the bottom of hpsa_update_scsi_devices()\n\t\t\t */\n\t\t\tsd[entry] = NULL;\n\t\t} else if (device_change == DEVICE_UPDATED) {\n\t\t\thpsa_scsi_update_entry(h, i, sd[entry]);\n\t\t}\n\t\ti++;\n\t}\n\n\t/* Now, make sure every device listed in sd[] is also\n\t * listed in h->dev[], adding them if they aren't found\n\t */\n\n\tfor (i = 0; i < nsds; i++) {\n\t\tif (!sd[i]) /* if already added above. */\n\t\t\tcontinue;\n\n\t\t/* Don't add devices which are NOT READY, FORMAT IN PROGRESS\n\t\t * as the SCSI mid-layer does not handle such devices well.\n\t\t * It relentlessly loops sending TUR at 3Hz, then READ(10)\n\t\t * at 160Hz, and prevents the system from coming up.\n\t\t */\n\t\tif (sd[i]->volume_offline) {\n\t\t\thpsa_show_volume_status(h, sd[i]);\n\t\t\thpsa_show_dev_msg(KERN_INFO, h, sd[i], \"offline\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tdevice_change = hpsa_scsi_find_entry(sd[i], h->dev,\n\t\t\t\t\th->ndevices, &entry);\n\t\tif (device_change == DEVICE_NOT_FOUND) {\n\t\t\tchanges++;\n\t\t\tif (hpsa_scsi_add_entry(h, sd[i], added, &nadded) != 0)\n\t\t\t\tbreak;\n\t\t\tsd[i] = NULL; /* prevent from being freed later. */\n\t\t} else if (device_change == DEVICE_CHANGED) {\n\t\t\t/* should never happen... */\n\t\t\tchanges++;\n\t\t\tdev_warn(&h->pdev->dev,\n\t\t\t\t\"device unexpectedly changed.\\n\");\n\t\t\t/* but if it does happen, we just ignore that device */\n\t\t}\n\t}\n\thpsa_update_log_drive_phys_drive_ptrs(h, h->dev, h->ndevices);\n\n\t/*\n\t * Now that h->dev[]->phys_disk[] is coherent, we can enable\n\t * any logical drives that need it enabled.\n\t *\n\t * The raid map should be current by now.\n\t *\n\t * We are updating the device list used for I/O requests.\n\t */\n\tfor (i = 0; i < h->ndevices; i++) {\n\t\tif (h->dev[i] == NULL)\n\t\t\tcontinue;\n\t\th->dev[i]->offload_enabled = h->dev[i]->offload_to_be_enabled;\n\t}\n\n\tspin_unlock_irqrestore(&h->devlock, flags);\n\n\t/* Monitor devices which are in one of several NOT READY states to be\n\t * brought online later. This must be done without holding h->devlock,\n\t * so don't touch h->dev[]\n\t */\n\tfor (i = 0; i < nsds; i++) {\n\t\tif (!sd[i]) /* if already added above. */\n\t\t\tcontinue;\n\t\tif (sd[i]->volume_offline)\n\t\t\thpsa_monitor_offline_device(h, sd[i]->scsi3addr);\n\t}\n\n\t/* Don't notify scsi mid layer of any changes the first time through\n\t * (or if there are no changes) scsi_scan_host will do it later the\n\t * first time through.\n\t */\n\tif (!changes)\n\t\tgoto free_and_out;\n\n\t/* Notify scsi mid layer of any removed devices */\n\tfor (i = 0; i < nremoved; i++) {\n\t\tif (removed[i] == NULL)\n\t\t\tcontinue;\n\t\tif (removed[i]->expose_device)\n\t\t\thpsa_remove_device(h, removed[i]);\n\t\tkfree(removed[i]);\n\t\tremoved[i] = NULL;\n\t}\n\n\t/* Notify scsi mid layer of any added devices */\n\tfor (i = 0; i < nadded; i++) {\n\t\tint rc = 0;\n\n\t\tif (added[i] == NULL)\n\t\t\tcontinue;\n\t\tif (!(added[i]->expose_device))\n\t\t\tcontinue;\n\t\trc = hpsa_add_device(h, added[i]);\n\t\tif (!rc)\n\t\t\tcontinue;\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t\"addition failed %d, device not added.\", rc);\n\t\t/* now we have to remove it from h->dev,\n\t\t * since it didn't get added to scsi mid layer\n\t\t */\n\t\tfixup_botched_add(h, added[i]);\n\t\th->drv_req_rescan = 1;\n\t}\n\nfree_and_out:\n\tkfree(added);\n\tkfree(removed);\n}\n\n/*\n * Lookup bus/target/lun and return corresponding struct hpsa_scsi_dev_t *\n * Assume's h->devlock is held.\n */\nstatic struct hpsa_scsi_dev_t *lookup_hpsa_scsi_dev(struct ctlr_info *h,\n\tint bus, int target, int lun)\n{\n\tint i;\n\tstruct hpsa_scsi_dev_t *sd;\n\n\tfor (i = 0; i < h->ndevices; i++) {\n\t\tsd = h->dev[i];\n\t\tif (sd->bus == bus && sd->target == target && sd->lun == lun)\n\t\t\treturn sd;\n\t}\n\treturn NULL;\n}\n\nstatic int hpsa_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct hpsa_scsi_dev_t *sd = NULL;\n\tunsigned long flags;\n\tstruct ctlr_info *h;\n\n\th = sdev_to_hba(sdev);\n\tspin_lock_irqsave(&h->devlock, flags);\n\tif (sdev_channel(sdev) == HPSA_PHYSICAL_DEVICE_BUS) {\n\t\tstruct scsi_target *starget;\n\t\tstruct sas_rphy *rphy;\n\n\t\tstarget = scsi_target(sdev);\n\t\trphy = target_to_rphy(starget);\n\t\tsd = hpsa_find_device_by_sas_rphy(h, rphy);\n\t\tif (sd) {\n\t\t\tsd->target = sdev_id(sdev);\n\t\t\tsd->lun = sdev->lun;\n\t\t}\n\t}\n\tif (!sd)\n\t\tsd = lookup_hpsa_scsi_dev(h, sdev_channel(sdev),\n\t\t\t\t\tsdev_id(sdev), sdev->lun);\n\n\tif (sd && sd->expose_device) {\n\t\tatomic_set(&sd->ioaccel_cmds_out, 0);\n\t\tsdev->hostdata = sd;\n\t} else\n\t\tsdev->hostdata = NULL;\n\tspin_unlock_irqrestore(&h->devlock, flags);\n\treturn 0;\n}\n\n/* configure scsi device based on internal per-device structure */\n#define CTLR_TIMEOUT (120 * HZ)\nstatic int hpsa_slave_configure(struct scsi_device *sdev)\n{\n\tstruct hpsa_scsi_dev_t *sd;\n\tint queue_depth;\n\n\tsd = sdev->hostdata;\n\tsdev->no_uld_attach = !sd || !sd->expose_device;\n\n\tif (sd) {\n\t\tsd->was_removed = 0;\n\t\tqueue_depth = sd->queue_depth != 0 ?\n\t\t\t\tsd->queue_depth : sdev->host->can_queue;\n\t\tif (sd->external) {\n\t\t\tqueue_depth = EXTERNAL_QD;\n\t\t\tsdev->eh_timeout = HPSA_EH_PTRAID_TIMEOUT;\n\t\t\tblk_queue_rq_timeout(sdev->request_queue,\n\t\t\t\t\t\tHPSA_EH_PTRAID_TIMEOUT);\n\t\t}\n\t\tif (is_hba_lunid(sd->scsi3addr)) {\n\t\t\tsdev->eh_timeout = CTLR_TIMEOUT;\n\t\t\tblk_queue_rq_timeout(sdev->request_queue, CTLR_TIMEOUT);\n\t\t}\n\t} else {\n\t\tqueue_depth = sdev->host->can_queue;\n\t}\n\n\tscsi_change_queue_depth(sdev, queue_depth);\n\n\treturn 0;\n}\n\nstatic void hpsa_slave_destroy(struct scsi_device *sdev)\n{\n\tstruct hpsa_scsi_dev_t *hdev = NULL;\n\n\thdev = sdev->hostdata;\n\n\tif (hdev)\n\t\thdev->was_removed = 1;\n}\n\nstatic void hpsa_free_ioaccel2_sg_chain_blocks(struct ctlr_info *h)\n{\n\tint i;\n\n\tif (!h->ioaccel2_cmd_sg_list)\n\t\treturn;\n\tfor (i = 0; i < h->nr_cmds; i++) {\n\t\tkfree(h->ioaccel2_cmd_sg_list[i]);\n\t\th->ioaccel2_cmd_sg_list[i] = NULL;\n\t}\n\tkfree(h->ioaccel2_cmd_sg_list);\n\th->ioaccel2_cmd_sg_list = NULL;\n}\n\nstatic int hpsa_allocate_ioaccel2_sg_chain_blocks(struct ctlr_info *h)\n{\n\tint i;\n\n\tif (h->chainsize <= 0)\n\t\treturn 0;\n\n\th->ioaccel2_cmd_sg_list =\n\t\tkcalloc(h->nr_cmds, sizeof(*h->ioaccel2_cmd_sg_list),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!h->ioaccel2_cmd_sg_list)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < h->nr_cmds; i++) {\n\t\th->ioaccel2_cmd_sg_list[i] =\n\t\t\tkmalloc_array(h->maxsgentries,\n\t\t\t\t      sizeof(*h->ioaccel2_cmd_sg_list[i]),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!h->ioaccel2_cmd_sg_list[i])\n\t\t\tgoto clean;\n\t}\n\treturn 0;\n\nclean:\n\thpsa_free_ioaccel2_sg_chain_blocks(h);\n\treturn -ENOMEM;\n}\n\nstatic void hpsa_free_sg_chain_blocks(struct ctlr_info *h)\n{\n\tint i;\n\n\tif (!h->cmd_sg_list)\n\t\treturn;\n\tfor (i = 0; i < h->nr_cmds; i++) {\n\t\tkfree(h->cmd_sg_list[i]);\n\t\th->cmd_sg_list[i] = NULL;\n\t}\n\tkfree(h->cmd_sg_list);\n\th->cmd_sg_list = NULL;\n}\n\nstatic int hpsa_alloc_sg_chain_blocks(struct ctlr_info *h)\n{\n\tint i;\n\n\tif (h->chainsize <= 0)\n\t\treturn 0;\n\n\th->cmd_sg_list = kcalloc(h->nr_cmds, sizeof(*h->cmd_sg_list),\n\t\t\t\t GFP_KERNEL);\n\tif (!h->cmd_sg_list)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < h->nr_cmds; i++) {\n\t\th->cmd_sg_list[i] = kmalloc_array(h->chainsize,\n\t\t\t\t\t\t  sizeof(*h->cmd_sg_list[i]),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!h->cmd_sg_list[i])\n\t\t\tgoto clean;\n\n\t}\n\treturn 0;\n\nclean:\n\thpsa_free_sg_chain_blocks(h);\n\treturn -ENOMEM;\n}\n\nstatic int hpsa_map_ioaccel2_sg_chain_block(struct ctlr_info *h,\n\tstruct io_accel2_cmd *cp, struct CommandList *c)\n{\n\tstruct ioaccel2_sg_element *chain_block;\n\tu64 temp64;\n\tu32 chain_size;\n\n\tchain_block = h->ioaccel2_cmd_sg_list[c->cmdindex];\n\tchain_size = le32_to_cpu(cp->sg[0].length);\n\ttemp64 = dma_map_single(&h->pdev->dev, chain_block, chain_size,\n\t\t\t\tDMA_TO_DEVICE);\n\tif (dma_mapping_error(&h->pdev->dev, temp64)) {\n\t\t/* prevent subsequent unmapping */\n\t\tcp->sg->address = 0;\n\t\treturn -1;\n\t}\n\tcp->sg->address = cpu_to_le64(temp64);\n\treturn 0;\n}\n\nstatic void hpsa_unmap_ioaccel2_sg_chain_block(struct ctlr_info *h,\n\tstruct io_accel2_cmd *cp)\n{\n\tstruct ioaccel2_sg_element *chain_sg;\n\tu64 temp64;\n\tu32 chain_size;\n\n\tchain_sg = cp->sg;\n\ttemp64 = le64_to_cpu(chain_sg->address);\n\tchain_size = le32_to_cpu(cp->sg[0].length);\n\tdma_unmap_single(&h->pdev->dev, temp64, chain_size, DMA_TO_DEVICE);\n}\n\nstatic int hpsa_map_sg_chain_block(struct ctlr_info *h,\n\tstruct CommandList *c)\n{\n\tstruct SGDescriptor *chain_sg, *chain_block;\n\tu64 temp64;\n\tu32 chain_len;\n\n\tchain_sg = &c->SG[h->max_cmd_sg_entries - 1];\n\tchain_block = h->cmd_sg_list[c->cmdindex];\n\tchain_sg->Ext = cpu_to_le32(HPSA_SG_CHAIN);\n\tchain_len = sizeof(*chain_sg) *\n\t\t(le16_to_cpu(c->Header.SGTotal) - h->max_cmd_sg_entries);\n\tchain_sg->Len = cpu_to_le32(chain_len);\n\ttemp64 = dma_map_single(&h->pdev->dev, chain_block, chain_len,\n\t\t\t\tDMA_TO_DEVICE);\n\tif (dma_mapping_error(&h->pdev->dev, temp64)) {\n\t\t/* prevent subsequent unmapping */\n\t\tchain_sg->Addr = cpu_to_le64(0);\n\t\treturn -1;\n\t}\n\tchain_sg->Addr = cpu_to_le64(temp64);\n\treturn 0;\n}\n\nstatic void hpsa_unmap_sg_chain_block(struct ctlr_info *h,\n\tstruct CommandList *c)\n{\n\tstruct SGDescriptor *chain_sg;\n\n\tif (le16_to_cpu(c->Header.SGTotal) <= h->max_cmd_sg_entries)\n\t\treturn;\n\n\tchain_sg = &c->SG[h->max_cmd_sg_entries - 1];\n\tdma_unmap_single(&h->pdev->dev, le64_to_cpu(chain_sg->Addr),\n\t\t\tle32_to_cpu(chain_sg->Len), DMA_TO_DEVICE);\n}\n\n\n/* Decode the various types of errors on ioaccel2 path.\n * Return 1 for any error that should generate a RAID path retry.\n * Return 0 for errors that don't require a RAID path retry.\n */\nstatic int handle_ioaccel_mode2_error(struct ctlr_info *h,\n\t\t\t\t\tstruct CommandList *c,\n\t\t\t\t\tstruct scsi_cmnd *cmd,\n\t\t\t\t\tstruct io_accel2_cmd *c2,\n\t\t\t\t\tstruct hpsa_scsi_dev_t *dev)\n{\n\tint data_len;\n\tint retry = 0;\n\tu32 ioaccel2_resid = 0;\n\n\tswitch (c2->error_data.serv_response) {\n\tcase IOACCEL2_SERV_RESPONSE_COMPLETE:\n\t\tswitch (c2->error_data.status) {\n\t\tcase IOACCEL2_STATUS_SR_TASK_COMP_GOOD:\n\t\t\tif (cmd)\n\t\t\t\tcmd->result = 0;\n\t\t\tbreak;\n\t\tcase IOACCEL2_STATUS_SR_TASK_COMP_CHK_COND:\n\t\t\tcmd->result |= SAM_STAT_CHECK_CONDITION;\n\t\t\tif (c2->error_data.data_present !=\n\t\t\t\t\tIOACCEL2_SENSE_DATA_PRESENT) {\n\t\t\t\tmemset(cmd->sense_buffer, 0,\n\t\t\t\t\tSCSI_SENSE_BUFFERSIZE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* copy the sense data */\n\t\t\tdata_len = c2->error_data.sense_data_len;\n\t\t\tif (data_len > SCSI_SENSE_BUFFERSIZE)\n\t\t\t\tdata_len = SCSI_SENSE_BUFFERSIZE;\n\t\t\tif (data_len > sizeof(c2->error_data.sense_data_buff))\n\t\t\t\tdata_len =\n\t\t\t\t\tsizeof(c2->error_data.sense_data_buff);\n\t\t\tmemcpy(cmd->sense_buffer,\n\t\t\t\tc2->error_data.sense_data_buff, data_len);\n\t\t\tretry = 1;\n\t\t\tbreak;\n\t\tcase IOACCEL2_STATUS_SR_TASK_COMP_BUSY:\n\t\t\tretry = 1;\n\t\t\tbreak;\n\t\tcase IOACCEL2_STATUS_SR_TASK_COMP_RES_CON:\n\t\t\tretry = 1;\n\t\t\tbreak;\n\t\tcase IOACCEL2_STATUS_SR_TASK_COMP_SET_FULL:\n\t\t\tretry = 1;\n\t\t\tbreak;\n\t\tcase IOACCEL2_STATUS_SR_TASK_COMP_ABORTED:\n\t\t\tretry = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tretry = 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IOACCEL2_SERV_RESPONSE_FAILURE:\n\t\tswitch (c2->error_data.status) {\n\t\tcase IOACCEL2_STATUS_SR_IO_ERROR:\n\t\tcase IOACCEL2_STATUS_SR_IO_ABORTED:\n\t\tcase IOACCEL2_STATUS_SR_OVERRUN:\n\t\t\tretry = 1;\n\t\t\tbreak;\n\t\tcase IOACCEL2_STATUS_SR_UNDERRUN:\n\t\t\tcmd->result = (DID_OK << 16);\t\t/* host byte */\n\t\t\tioaccel2_resid = get_unaligned_le32(\n\t\t\t\t\t\t&c2->error_data.resid_cnt[0]);\n\t\t\tscsi_set_resid(cmd, ioaccel2_resid);\n\t\t\tbreak;\n\t\tcase IOACCEL2_STATUS_SR_NO_PATH_TO_DEVICE:\n\t\tcase IOACCEL2_STATUS_SR_INVALID_DEVICE:\n\t\tcase IOACCEL2_STATUS_SR_IOACCEL_DISABLED:\n\t\t\t/*\n\t\t\t * Did an HBA disk disappear? We will eventually\n\t\t\t * get a state change event from the controller but\n\t\t\t * in the meantime, we need to tell the OS that the\n\t\t\t * HBA disk is no longer there and stop I/O\n\t\t\t * from going down. This allows the potential re-insert\n\t\t\t * of the disk to get the same device node.\n\t\t\t */\n\t\t\tif (dev->physical_device && dev->expose_device) {\n\t\t\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\t\t\tdev->removed = 1;\n\t\t\t\th->drv_req_rescan = 1;\n\t\t\t\tdev_warn(&h->pdev->dev,\n\t\t\t\t\t\"%s: device is gone!\\n\", __func__);\n\t\t\t} else\n\t\t\t\t/*\n\t\t\t\t * Retry by sending down the RAID path.\n\t\t\t\t * We will get an event from ctlr to\n\t\t\t\t * trigger rescan regardless.\n\t\t\t\t */\n\t\t\t\tretry = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tretry = 1;\n\t\t}\n\t\tbreak;\n\tcase IOACCEL2_SERV_RESPONSE_TMF_COMPLETE:\n\t\tbreak;\n\tcase IOACCEL2_SERV_RESPONSE_TMF_SUCCESS:\n\t\tbreak;\n\tcase IOACCEL2_SERV_RESPONSE_TMF_REJECTED:\n\t\tretry = 1;\n\t\tbreak;\n\tcase IOACCEL2_SERV_RESPONSE_TMF_WRONG_LUN:\n\t\tbreak;\n\tdefault:\n\t\tretry = 1;\n\t\tbreak;\n\t}\n\n\tif (dev->in_reset)\n\t\tretry = 0;\n\n\treturn retry;\t/* retry on raid path? */\n}\n\nstatic void hpsa_cmd_resolve_events(struct ctlr_info *h,\n\t\tstruct CommandList *c)\n{\n\tstruct hpsa_scsi_dev_t *dev = c->device;\n\n\t/*\n\t * Reset c->scsi_cmd here so that the reset handler will know\n\t * this command has completed.  Then, check to see if the handler is\n\t * waiting for this command, and, if so, wake it.\n\t */\n\tc->scsi_cmd = SCSI_CMD_IDLE;\n\tmb();\t/* Declare command idle before checking for pending events. */\n\tif (dev) {\n\t\tatomic_dec(&dev->commands_outstanding);\n\t\tif (dev->in_reset &&\n\t\t\tatomic_read(&dev->commands_outstanding) <= 0)\n\t\t\twake_up_all(&h->event_sync_wait_queue);\n\t}\n}\n\nstatic void hpsa_cmd_resolve_and_free(struct ctlr_info *h,\n\t\t\t\t      struct CommandList *c)\n{\n\thpsa_cmd_resolve_events(h, c);\n\tcmd_tagged_free(h, c);\n}\n\nstatic void hpsa_cmd_free_and_done(struct ctlr_info *h,\n\t\tstruct CommandList *c, struct scsi_cmnd *cmd)\n{\n\thpsa_cmd_resolve_and_free(h, c);\n\tif (cmd && cmd->scsi_done)\n\t\tcmd->scsi_done(cmd);\n}\n\nstatic void hpsa_retry_cmd(struct ctlr_info *h, struct CommandList *c)\n{\n\tINIT_WORK(&c->work, hpsa_command_resubmit_worker);\n\tqueue_work_on(raw_smp_processor_id(), h->resubmit_wq, &c->work);\n}\n\nstatic void process_ioaccel2_completion(struct ctlr_info *h,\n\t\tstruct CommandList *c, struct scsi_cmnd *cmd,\n\t\tstruct hpsa_scsi_dev_t *dev)\n{\n\tstruct io_accel2_cmd *c2 = &h->ioaccel2_cmd_pool[c->cmdindex];\n\n\t/* check for good status */\n\tif (likely(c2->error_data.serv_response == 0 &&\n\t\t\tc2->error_data.status == 0)) {\n\t\tcmd->result = 0;\n\t\treturn hpsa_cmd_free_and_done(h, c, cmd);\n\t}\n\n\t/*\n\t * Any RAID offload error results in retry which will use\n\t * the normal I/O path so the controller can handle whatever is\n\t * wrong.\n\t */\n\tif (is_logical_device(dev) &&\n\t\tc2->error_data.serv_response ==\n\t\t\tIOACCEL2_SERV_RESPONSE_FAILURE) {\n\t\tif (c2->error_data.status ==\n\t\t\tIOACCEL2_STATUS_SR_IOACCEL_DISABLED) {\n\t\t\thpsa_turn_off_ioaccel_for_device(dev);\n\t\t}\n\n\t\tif (dev->in_reset) {\n\t\t\tcmd->result = DID_RESET << 16;\n\t\t\treturn hpsa_cmd_free_and_done(h, c, cmd);\n\t\t}\n\n\t\treturn hpsa_retry_cmd(h, c);\n\t}\n\n\tif (handle_ioaccel_mode2_error(h, c, cmd, c2, dev))\n\t\treturn hpsa_retry_cmd(h, c);\n\n\treturn hpsa_cmd_free_and_done(h, c, cmd);\n}\n\n/* Returns 0 on success, < 0 otherwise. */\nstatic int hpsa_evaluate_tmf_status(struct ctlr_info *h,\n\t\t\t\t\tstruct CommandList *cp)\n{\n\tu8 tmf_status = cp->err_info->ScsiStatus;\n\n\tswitch (tmf_status) {\n\tcase CISS_TMF_COMPLETE:\n\t\t/*\n\t\t * CISS_TMF_COMPLETE never happens, instead,\n\t\t * ei->CommandStatus == 0 for this case.\n\t\t */\n\tcase CISS_TMF_SUCCESS:\n\t\treturn 0;\n\tcase CISS_TMF_INVALID_FRAME:\n\tcase CISS_TMF_NOT_SUPPORTED:\n\tcase CISS_TMF_FAILED:\n\tcase CISS_TMF_WRONG_LUN:\n\tcase CISS_TMF_OVERLAPPED_TAG:\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&h->pdev->dev, \"Unknown TMF status: 0x%02x\\n\",\n\t\t\t\ttmf_status);\n\t\tbreak;\n\t}\n\treturn -tmf_status;\n}\n\nstatic void complete_scsi_command(struct CommandList *cp)\n{\n\tstruct scsi_cmnd *cmd;\n\tstruct ctlr_info *h;\n\tstruct ErrorInfo *ei;\n\tstruct hpsa_scsi_dev_t *dev;\n\tstruct io_accel2_cmd *c2;\n\n\tu8 sense_key;\n\tu8 asc;      /* additional sense code */\n\tu8 ascq;     /* additional sense code qualifier */\n\tunsigned long sense_data_size;\n\n\tei = cp->err_info;\n\tcmd = cp->scsi_cmd;\n\th = cp->h;\n\n\tif (!cmd->device) {\n\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\treturn hpsa_cmd_free_and_done(h, cp, cmd);\n\t}\n\n\tdev = cmd->device->hostdata;\n\tif (!dev) {\n\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\treturn hpsa_cmd_free_and_done(h, cp, cmd);\n\t}\n\tc2 = &h->ioaccel2_cmd_pool[cp->cmdindex];\n\n\tscsi_dma_unmap(cmd); /* undo the DMA mappings */\n\tif ((cp->cmd_type == CMD_SCSI) &&\n\t\t(le16_to_cpu(cp->Header.SGTotal) > h->max_cmd_sg_entries))\n\t\thpsa_unmap_sg_chain_block(h, cp);\n\n\tif ((cp->cmd_type == CMD_IOACCEL2) &&\n\t\t(c2->sg[0].chain_indicator == IOACCEL2_CHAIN))\n\t\thpsa_unmap_ioaccel2_sg_chain_block(h, c2);\n\n\tcmd->result = (DID_OK << 16);\t\t/* host byte */\n\n\t/* SCSI command has already been cleaned up in SML */\n\tif (dev->was_removed) {\n\t\thpsa_cmd_resolve_and_free(h, cp);\n\t\treturn;\n\t}\n\n\tif (cp->cmd_type == CMD_IOACCEL2 || cp->cmd_type == CMD_IOACCEL1) {\n\t\tif (dev->physical_device && dev->expose_device &&\n\t\t\tdev->removed) {\n\t\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\t\treturn hpsa_cmd_free_and_done(h, cp, cmd);\n\t\t}\n\t\tif (likely(cp->phys_disk != NULL))\n\t\t\tatomic_dec(&cp->phys_disk->ioaccel_cmds_out);\n\t}\n\n\t/*\n\t * We check for lockup status here as it may be set for\n\t * CMD_SCSI, CMD_IOACCEL1 and CMD_IOACCEL2 commands by\n\t * fail_all_oustanding_cmds()\n\t */\n\tif (unlikely(ei->CommandStatus == CMD_CTLR_LOCKUP)) {\n\t\t/* DID_NO_CONNECT will prevent a retry */\n\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\treturn hpsa_cmd_free_and_done(h, cp, cmd);\n\t}\n\n\tif (cp->cmd_type == CMD_IOACCEL2)\n\t\treturn process_ioaccel2_completion(h, cp, cmd, dev);\n\n\tscsi_set_resid(cmd, ei->ResidualCnt);\n\tif (ei->CommandStatus == 0)\n\t\treturn hpsa_cmd_free_and_done(h, cp, cmd);\n\n\t/* For I/O accelerator commands, copy over some fields to the normal\n\t * CISS header used below for error handling.\n\t */\n\tif (cp->cmd_type == CMD_IOACCEL1) {\n\t\tstruct io_accel1_cmd *c = &h->ioaccel_cmd_pool[cp->cmdindex];\n\t\tcp->Header.SGList = scsi_sg_count(cmd);\n\t\tcp->Header.SGTotal = cpu_to_le16(cp->Header.SGList);\n\t\tcp->Request.CDBLen = le16_to_cpu(c->io_flags) &\n\t\t\tIOACCEL1_IOFLAGS_CDBLEN_MASK;\n\t\tcp->Header.tag = c->tag;\n\t\tmemcpy(cp->Header.LUN.LunAddrBytes, c->CISS_LUN, 8);\n\t\tmemcpy(cp->Request.CDB, c->CDB, cp->Request.CDBLen);\n\n\t\t/* Any RAID offload error results in retry which will use\n\t\t * the normal I/O path so the controller can handle whatever's\n\t\t * wrong.\n\t\t */\n\t\tif (is_logical_device(dev)) {\n\t\t\tif (ei->CommandStatus == CMD_IOACCEL_DISABLED)\n\t\t\t\tdev->offload_enabled = 0;\n\t\t\treturn hpsa_retry_cmd(h, cp);\n\t\t}\n\t}\n\n\t/* an error has occurred */\n\tswitch (ei->CommandStatus) {\n\n\tcase CMD_TARGET_STATUS:\n\t\tcmd->result |= ei->ScsiStatus;\n\t\t/* copy the sense data */\n\t\tif (SCSI_SENSE_BUFFERSIZE < sizeof(ei->SenseInfo))\n\t\t\tsense_data_size = SCSI_SENSE_BUFFERSIZE;\n\t\telse\n\t\t\tsense_data_size = sizeof(ei->SenseInfo);\n\t\tif (ei->SenseLen < sense_data_size)\n\t\t\tsense_data_size = ei->SenseLen;\n\t\tmemcpy(cmd->sense_buffer, ei->SenseInfo, sense_data_size);\n\t\tif (ei->ScsiStatus)\n\t\t\tdecode_sense_data(ei->SenseInfo, sense_data_size,\n\t\t\t\t&sense_key, &asc, &ascq);\n\t\tif (ei->ScsiStatus == SAM_STAT_CHECK_CONDITION) {\n\t\t\tswitch (sense_key) {\n\t\t\tcase ABORTED_COMMAND:\n\t\t\t\tcmd->result |= DID_SOFT_ERROR << 16;\n\t\t\t\tbreak;\n\t\t\tcase UNIT_ATTENTION:\n\t\t\t\tif (asc == 0x3F && ascq == 0x0E)\n\t\t\t\t\th->drv_req_rescan = 1;\n\t\t\t\tbreak;\n\t\t\tcase ILLEGAL_REQUEST:\n\t\t\t\tif (asc == 0x25 && ascq == 0x00) {\n\t\t\t\t\tdev->removed = 1;\n\t\t\t\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t/* Problem was not a check condition\n\t\t * Pass it up to the upper layers...\n\t\t */\n\t\tif (ei->ScsiStatus) {\n\t\t\tdev_warn(&h->pdev->dev, \"cp %p has status 0x%x \"\n\t\t\t\t\"Sense: 0x%x, ASC: 0x%x, ASCQ: 0x%x, \"\n\t\t\t\t\"Returning result: 0x%x\\n\",\n\t\t\t\tcp, ei->ScsiStatus,\n\t\t\t\tsense_key, asc, ascq,\n\t\t\t\tcmd->result);\n\t\t} else {  /* scsi status is zero??? How??? */\n\t\t\tdev_warn(&h->pdev->dev, \"cp %p SCSI status was 0. \"\n\t\t\t\t\"Returning no connection.\\n\", cp),\n\n\t\t\t/* Ordinarily, this case should never happen,\n\t\t\t * but there is a bug in some released firmware\n\t\t\t * revisions that allows it to happen if, for\n\t\t\t * example, a 4100 backplane loses power and\n\t\t\t * the tape drive is in it.  We assume that\n\t\t\t * it's a fatal error of some kind because we\n\t\t\t * can't show that it wasn't. We will make it\n\t\t\t * look like selection timeout since that is\n\t\t\t * the most common reason for this to occur,\n\t\t\t * and it's severe enough.\n\t\t\t */\n\n\t\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\t}\n\t\tbreak;\n\n\tcase CMD_DATA_UNDERRUN: /* let mid layer handle it. */\n\t\tbreak;\n\tcase CMD_DATA_OVERRUN:\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t\"CDB %16phN data overrun\\n\", cp->Request.CDB);\n\t\tbreak;\n\tcase CMD_INVALID: {\n\t\t/* print_bytes(cp, sizeof(*cp), 1, 0);\n\t\tprint_cmd(cp); */\n\t\t/* We get CMD_INVALID if you address a non-existent device\n\t\t * instead of a selection timeout (no response).  You will\n\t\t * see this if you yank out a drive, then try to access it.\n\t\t * This is kind of a shame because it means that any other\n\t\t * CMD_INVALID (e.g. driver bug) will get interpreted as a\n\t\t * missing target. */\n\t\tcmd->result = DID_NO_CONNECT << 16;\n\t}\n\t\tbreak;\n\tcase CMD_PROTOCOL_ERR:\n\t\tcmd->result = DID_ERROR << 16;\n\t\tdev_warn(&h->pdev->dev, \"CDB %16phN : protocol error\\n\",\n\t\t\t\tcp->Request.CDB);\n\t\tbreak;\n\tcase CMD_HARDWARE_ERR:\n\t\tcmd->result = DID_ERROR << 16;\n\t\tdev_warn(&h->pdev->dev, \"CDB %16phN : hardware error\\n\",\n\t\t\tcp->Request.CDB);\n\t\tbreak;\n\tcase CMD_CONNECTION_LOST:\n\t\tcmd->result = DID_ERROR << 16;\n\t\tdev_warn(&h->pdev->dev, \"CDB %16phN : connection lost\\n\",\n\t\t\tcp->Request.CDB);\n\t\tbreak;\n\tcase CMD_ABORTED:\n\t\tcmd->result = DID_ABORT << 16;\n\t\tbreak;\n\tcase CMD_ABORT_FAILED:\n\t\tcmd->result = DID_ERROR << 16;\n\t\tdev_warn(&h->pdev->dev, \"CDB %16phN : abort failed\\n\",\n\t\t\tcp->Request.CDB);\n\t\tbreak;\n\tcase CMD_UNSOLICITED_ABORT:\n\t\tcmd->result = DID_SOFT_ERROR << 16; /* retry the command */\n\t\tdev_warn(&h->pdev->dev, \"CDB %16phN : unsolicited abort\\n\",\n\t\t\tcp->Request.CDB);\n\t\tbreak;\n\tcase CMD_TIMEOUT:\n\t\tcmd->result = DID_TIME_OUT << 16;\n\t\tdev_warn(&h->pdev->dev, \"CDB %16phN timed out\\n\",\n\t\t\tcp->Request.CDB);\n\t\tbreak;\n\tcase CMD_UNABORTABLE:\n\t\tcmd->result = DID_ERROR << 16;\n\t\tdev_warn(&h->pdev->dev, \"Command unabortable\\n\");\n\t\tbreak;\n\tcase CMD_TMF_STATUS:\n\t\tif (hpsa_evaluate_tmf_status(h, cp)) /* TMF failed? */\n\t\t\tcmd->result = DID_ERROR << 16;\n\t\tbreak;\n\tcase CMD_IOACCEL_DISABLED:\n\t\t/* This only handles the direct pass-through case since RAID\n\t\t * offload is handled above.  Just attempt a retry.\n\t\t */\n\t\tcmd->result = DID_SOFT_ERROR << 16;\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t\t\"cp %p had HP SSD Smart Path error\\n\", cp);\n\t\tbreak;\n\tdefault:\n\t\tcmd->result = DID_ERROR << 16;\n\t\tdev_warn(&h->pdev->dev, \"cp %p returned unknown status %x\\n\",\n\t\t\t\tcp, ei->CommandStatus);\n\t}\n\n\treturn hpsa_cmd_free_and_done(h, cp, cmd);\n}\n\nstatic void hpsa_pci_unmap(struct pci_dev *pdev, struct CommandList *c,\n\t\tint sg_used, enum dma_data_direction data_direction)\n{\n\tint i;\n\n\tfor (i = 0; i < sg_used; i++)\n\t\tdma_unmap_single(&pdev->dev, le64_to_cpu(c->SG[i].Addr),\n\t\t\t\tle32_to_cpu(c->SG[i].Len),\n\t\t\t\tdata_direction);\n}\n\nstatic int hpsa_map_one(struct pci_dev *pdev,\n\t\tstruct CommandList *cp,\n\t\tunsigned char *buf,\n\t\tsize_t buflen,\n\t\tenum dma_data_direction data_direction)\n{\n\tu64 addr64;\n\n\tif (buflen == 0 || data_direction == DMA_NONE) {\n\t\tcp->Header.SGList = 0;\n\t\tcp->Header.SGTotal = cpu_to_le16(0);\n\t\treturn 0;\n\t}\n\n\taddr64 = dma_map_single(&pdev->dev, buf, buflen, data_direction);\n\tif (dma_mapping_error(&pdev->dev, addr64)) {\n\t\t/* Prevent subsequent unmap of something never mapped */\n\t\tcp->Header.SGList = 0;\n\t\tcp->Header.SGTotal = cpu_to_le16(0);\n\t\treturn -1;\n\t}\n\tcp->SG[0].Addr = cpu_to_le64(addr64);\n\tcp->SG[0].Len = cpu_to_le32(buflen);\n\tcp->SG[0].Ext = cpu_to_le32(HPSA_SG_LAST); /* we are not chaining */\n\tcp->Header.SGList = 1;   /* no. SGs contig in this cmd */\n\tcp->Header.SGTotal = cpu_to_le16(1); /* total sgs in cmd list */\n\treturn 0;\n}\n\n#define NO_TIMEOUT ((unsigned long) -1)\n#define DEFAULT_TIMEOUT 30000 /* milliseconds */\nstatic int hpsa_scsi_do_simple_cmd_core(struct ctlr_info *h,\n\tstruct CommandList *c, int reply_queue, unsigned long timeout_msecs)\n{\n\tDECLARE_COMPLETION_ONSTACK(wait);\n\n\tc->waiting = &wait;\n\t__enqueue_cmd_and_start_io(h, c, reply_queue);\n\tif (timeout_msecs == NO_TIMEOUT) {\n\t\t/* TODO: get rid of this no-timeout thing */\n\t\twait_for_completion_io(&wait);\n\t\treturn IO_OK;\n\t}\n\tif (!wait_for_completion_io_timeout(&wait,\n\t\t\t\t\tmsecs_to_jiffies(timeout_msecs))) {\n\t\tdev_warn(&h->pdev->dev, \"Command timed out.\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn IO_OK;\n}\n\nstatic int hpsa_scsi_do_simple_cmd(struct ctlr_info *h, struct CommandList *c,\n\t\t\t\t   int reply_queue, unsigned long timeout_msecs)\n{\n\tif (unlikely(lockup_detected(h))) {\n\t\tc->err_info->CommandStatus = CMD_CTLR_LOCKUP;\n\t\treturn IO_OK;\n\t}\n\treturn hpsa_scsi_do_simple_cmd_core(h, c, reply_queue, timeout_msecs);\n}\n\nstatic u32 lockup_detected(struct ctlr_info *h)\n{\n\tint cpu;\n\tu32 rc, *lockup_detected;\n\n\tcpu = get_cpu();\n\tlockup_detected = per_cpu_ptr(h->lockup_detected, cpu);\n\trc = *lockup_detected;\n\tput_cpu();\n\treturn rc;\n}\n\n#define MAX_DRIVER_CMD_RETRIES 25\nstatic int hpsa_scsi_do_simple_cmd_with_retry(struct ctlr_info *h,\n\t\tstruct CommandList *c, enum dma_data_direction data_direction,\n\t\tunsigned long timeout_msecs)\n{\n\tint backoff_time = 10, retry_count = 0;\n\tint rc;\n\n\tdo {\n\t\tmemset(c->err_info, 0, sizeof(*c->err_info));\n\t\trc = hpsa_scsi_do_simple_cmd(h, c, DEFAULT_REPLY_QUEUE,\n\t\t\t\t\t\t  timeout_msecs);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tretry_count++;\n\t\tif (retry_count > 3) {\n\t\t\tmsleep(backoff_time);\n\t\t\tif (backoff_time < 1000)\n\t\t\t\tbackoff_time *= 2;\n\t\t}\n\t} while ((check_for_unit_attention(h, c) ||\n\t\t\tcheck_for_busy(h, c)) &&\n\t\t\tretry_count <= MAX_DRIVER_CMD_RETRIES);\n\thpsa_pci_unmap(h->pdev, c, 1, data_direction);\n\tif (retry_count > MAX_DRIVER_CMD_RETRIES)\n\t\trc = -EIO;\n\treturn rc;\n}\n\nstatic void hpsa_print_cmd(struct ctlr_info *h, char *txt,\n\t\t\t\tstruct CommandList *c)\n{\n\tconst u8 *cdb = c->Request.CDB;\n\tconst u8 *lun = c->Header.LUN.LunAddrBytes;\n\n\tdev_warn(&h->pdev->dev, \"%s: LUN:%8phN CDB:%16phN\\n\",\n\t\t txt, lun, cdb);\n}\n\nstatic void hpsa_scsi_interpret_error(struct ctlr_info *h,\n\t\t\tstruct CommandList *cp)\n{\n\tconst struct ErrorInfo *ei = cp->err_info;\n\tstruct device *d = &cp->h->pdev->dev;\n\tu8 sense_key, asc, ascq;\n\tint sense_len;\n\n\tswitch (ei->CommandStatus) {\n\tcase CMD_TARGET_STATUS:\n\t\tif (ei->SenseLen > sizeof(ei->SenseInfo))\n\t\t\tsense_len = sizeof(ei->SenseInfo);\n\t\telse\n\t\t\tsense_len = ei->SenseLen;\n\t\tdecode_sense_data(ei->SenseInfo, sense_len,\n\t\t\t\t\t&sense_key, &asc, &ascq);\n\t\thpsa_print_cmd(h, \"SCSI status\", cp);\n\t\tif (ei->ScsiStatus == SAM_STAT_CHECK_CONDITION)\n\t\t\tdev_warn(d, \"SCSI Status = 02, Sense key = 0x%02x, ASC = 0x%02x, ASCQ = 0x%02x\\n\",\n\t\t\t\tsense_key, asc, ascq);\n\t\telse\n\t\t\tdev_warn(d, \"SCSI Status = 0x%02x\\n\", ei->ScsiStatus);\n\t\tif (ei->ScsiStatus == 0)\n\t\t\tdev_warn(d, \"SCSI status is abnormally zero.  \"\n\t\t\t\"(probably indicates selection timeout \"\n\t\t\t\"reported incorrectly due to a known \"\n\t\t\t\"firmware bug, circa July, 2001.)\\n\");\n\t\tbreak;\n\tcase CMD_DATA_UNDERRUN: /* let mid layer handle it. */\n\t\tbreak;\n\tcase CMD_DATA_OVERRUN:\n\t\thpsa_print_cmd(h, \"overrun condition\", cp);\n\t\tbreak;\n\tcase CMD_INVALID: {\n\t\t/* controller unfortunately reports SCSI passthru's\n\t\t * to non-existent targets as invalid commands.\n\t\t */\n\t\thpsa_print_cmd(h, \"invalid command\", cp);\n\t\tdev_warn(d, \"probably means device no longer present\\n\");\n\t\t}\n\t\tbreak;\n\tcase CMD_PROTOCOL_ERR:\n\t\thpsa_print_cmd(h, \"protocol error\", cp);\n\t\tbreak;\n\tcase CMD_HARDWARE_ERR:\n\t\thpsa_print_cmd(h, \"hardware error\", cp);\n\t\tbreak;\n\tcase CMD_CONNECTION_LOST:\n\t\thpsa_print_cmd(h, \"connection lost\", cp);\n\t\tbreak;\n\tcase CMD_ABORTED:\n\t\thpsa_print_cmd(h, \"aborted\", cp);\n\t\tbreak;\n\tcase CMD_ABORT_FAILED:\n\t\thpsa_print_cmd(h, \"abort failed\", cp);\n\t\tbreak;\n\tcase CMD_UNSOLICITED_ABORT:\n\t\thpsa_print_cmd(h, \"unsolicited abort\", cp);\n\t\tbreak;\n\tcase CMD_TIMEOUT:\n\t\thpsa_print_cmd(h, \"timed out\", cp);\n\t\tbreak;\n\tcase CMD_UNABORTABLE:\n\t\thpsa_print_cmd(h, \"unabortable\", cp);\n\t\tbreak;\n\tcase CMD_CTLR_LOCKUP:\n\t\thpsa_print_cmd(h, \"controller lockup detected\", cp);\n\t\tbreak;\n\tdefault:\n\t\thpsa_print_cmd(h, \"unknown status\", cp);\n\t\tdev_warn(d, \"Unknown command status %x\\n\",\n\t\t\t\tei->CommandStatus);\n\t}\n}\n\nstatic int hpsa_do_receive_diagnostic(struct ctlr_info *h, u8 *scsi3addr,\n\t\t\t\t\tu8 page, u8 *buf, size_t bufsize)\n{\n\tint rc = IO_OK;\n\tstruct CommandList *c;\n\tstruct ErrorInfo *ei;\n\n\tc = cmd_alloc(h);\n\tif (fill_cmd(c, RECEIVE_DIAGNOSTIC, h, buf, bufsize,\n\t\t\tpage, scsi3addr, TYPE_CMD)) {\n\t\trc = -1;\n\t\tgoto out;\n\t}\n\trc = hpsa_scsi_do_simple_cmd_with_retry(h, c, DMA_FROM_DEVICE,\n\t\t\tNO_TIMEOUT);\n\tif (rc)\n\t\tgoto out;\n\tei = c->err_info;\n\tif (ei->CommandStatus != 0 && ei->CommandStatus != CMD_DATA_UNDERRUN) {\n\t\thpsa_scsi_interpret_error(h, c);\n\t\trc = -1;\n\t}\nout:\n\tcmd_free(h, c);\n\treturn rc;\n}\n\nstatic u64 hpsa_get_enclosure_logical_identifier(struct ctlr_info *h,\n\t\t\t\t\t\tu8 *scsi3addr)\n{\n\tu8 *buf;\n\tu64 sa = 0;\n\tint rc = 0;\n\n\tbuf = kzalloc(1024, GFP_KERNEL);\n\tif (!buf)\n\t\treturn 0;\n\n\trc = hpsa_do_receive_diagnostic(h, scsi3addr, RECEIVE_DIAGNOSTIC,\n\t\t\t\t\tbuf, 1024);\n\n\tif (rc)\n\t\tgoto out;\n\n\tsa = get_unaligned_be64(buf+12);\n\nout:\n\tkfree(buf);\n\treturn sa;\n}\n\nstatic int hpsa_scsi_do_inquiry(struct ctlr_info *h, unsigned char *scsi3addr,\n\t\t\tu16 page, unsigned char *buf,\n\t\t\tunsigned char bufsize)\n{\n\tint rc = IO_OK;\n\tstruct CommandList *c;\n\tstruct ErrorInfo *ei;\n\n\tc = cmd_alloc(h);\n\n\tif (fill_cmd(c, HPSA_INQUIRY, h, buf, bufsize,\n\t\t\tpage, scsi3addr, TYPE_CMD)) {\n\t\trc = -1;\n\t\tgoto out;\n\t}\n\trc = hpsa_scsi_do_simple_cmd_with_retry(h, c, DMA_FROM_DEVICE,\n\t\t\tNO_TIMEOUT);\n\tif (rc)\n\t\tgoto out;\n\tei = c->err_info;\n\tif (ei->CommandStatus != 0 && ei->CommandStatus != CMD_DATA_UNDERRUN) {\n\t\thpsa_scsi_interpret_error(h, c);\n\t\trc = -1;\n\t}\nout:\n\tcmd_free(h, c);\n\treturn rc;\n}\n\nstatic int hpsa_send_reset(struct ctlr_info *h, struct hpsa_scsi_dev_t *dev,\n\tu8 reset_type, int reply_queue)\n{\n\tint rc = IO_OK;\n\tstruct CommandList *c;\n\tstruct ErrorInfo *ei;\n\n\tc = cmd_alloc(h);\n\tc->device = dev;\n\n\t/* fill_cmd can't fail here, no data buffer to map. */\n\t(void) fill_cmd(c, reset_type, h, NULL, 0, 0, dev->scsi3addr, TYPE_MSG);\n\trc = hpsa_scsi_do_simple_cmd(h, c, reply_queue, NO_TIMEOUT);\n\tif (rc) {\n\t\tdev_warn(&h->pdev->dev, \"Failed to send reset command\\n\");\n\t\tgoto out;\n\t}\n\t/* no unmap needed here because no data xfer. */\n\n\tei = c->err_info;\n\tif (ei->CommandStatus != 0) {\n\t\thpsa_scsi_interpret_error(h, c);\n\t\trc = -1;\n\t}\nout:\n\tcmd_free(h, c);\n\treturn rc;\n}\n\nstatic bool hpsa_cmd_dev_match(struct ctlr_info *h, struct CommandList *c,\n\t\t\t       struct hpsa_scsi_dev_t *dev,\n\t\t\t       unsigned char *scsi3addr)\n{\n\tint i;\n\tbool match = false;\n\tstruct io_accel2_cmd *c2 = &h->ioaccel2_cmd_pool[c->cmdindex];\n\tstruct hpsa_tmf_struct *ac = (struct hpsa_tmf_struct *) c2;\n\n\tif (hpsa_is_cmd_idle(c))\n\t\treturn false;\n\n\tswitch (c->cmd_type) {\n\tcase CMD_SCSI:\n\tcase CMD_IOCTL_PEND:\n\t\tmatch = !memcmp(scsi3addr, &c->Header.LUN.LunAddrBytes,\n\t\t\t\tsizeof(c->Header.LUN.LunAddrBytes));\n\t\tbreak;\n\n\tcase CMD_IOACCEL1:\n\tcase CMD_IOACCEL2:\n\t\tif (c->phys_disk == dev) {\n\t\t\t/* HBA mode match */\n\t\t\tmatch = true;\n\t\t} else {\n\t\t\t/* Possible RAID mode -- check each phys dev. */\n\t\t\t/* FIXME:  Do we need to take out a lock here?  If\n\t\t\t * so, we could just call hpsa_get_pdisk_of_ioaccel2()\n\t\t\t * instead. */\n\t\t\tfor (i = 0; i < dev->nphysical_disks && !match; i++) {\n\t\t\t\t/* FIXME: an alternate test might be\n\t\t\t\t *\n\t\t\t\t * match = dev->phys_disk[i]->ioaccel_handle\n\t\t\t\t *              == c2->scsi_nexus;      */\n\t\t\t\tmatch = dev->phys_disk[i] == c->phys_disk;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IOACCEL2_TMF:\n\t\tfor (i = 0; i < dev->nphysical_disks && !match; i++) {\n\t\t\tmatch = dev->phys_disk[i]->ioaccel_handle ==\n\t\t\t\t\tle32_to_cpu(ac->it_nexus);\n\t\t}\n\t\tbreak;\n\n\tcase 0:\t\t/* The command is in the middle of being initialized. */\n\t\tmatch = false;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&h->pdev->dev, \"unexpected cmd_type: %d\\n\",\n\t\t\tc->cmd_type);\n\t\tBUG();\n\t}\n\n\treturn match;\n}\n\nstatic int hpsa_do_reset(struct ctlr_info *h, struct hpsa_scsi_dev_t *dev,\n\tu8 reset_type, int reply_queue)\n{\n\tint rc = 0;\n\n\t/* We can really only handle one reset at a time */\n\tif (mutex_lock_interruptible(&h->reset_mutex) == -EINTR) {\n\t\tdev_warn(&h->pdev->dev, \"concurrent reset wait interrupted.\\n\");\n\t\treturn -EINTR;\n\t}\n\n\trc = hpsa_send_reset(h, dev, reset_type, reply_queue);\n\tif (!rc) {\n\t\t/* incremented by sending the reset request */\n\t\tatomic_dec(&dev->commands_outstanding);\n\t\twait_event(h->event_sync_wait_queue,\n\t\t\tatomic_read(&dev->commands_outstanding) <= 0 ||\n\t\t\tlockup_detected(h));\n\t}\n\n\tif (unlikely(lockup_detected(h))) {\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t \"Controller lockup detected during reset wait\\n\");\n\t\trc = -ENODEV;\n\t}\n\n\tif (!rc)\n\t\trc = wait_for_device_to_become_ready(h, dev->scsi3addr, 0);\n\n\tmutex_unlock(&h->reset_mutex);\n\treturn rc;\n}\n\nstatic void hpsa_get_raid_level(struct ctlr_info *h,\n\tunsigned char *scsi3addr, unsigned char *raid_level)\n{\n\tint rc;\n\tunsigned char *buf;\n\n\t*raid_level = RAID_UNKNOWN;\n\tbuf = kzalloc(64, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tif (!hpsa_vpd_page_supported(h, scsi3addr,\n\t\tHPSA_VPD_LV_DEVICE_GEOMETRY))\n\t\tgoto exit;\n\n\trc = hpsa_scsi_do_inquiry(h, scsi3addr, VPD_PAGE |\n\t\tHPSA_VPD_LV_DEVICE_GEOMETRY, buf, 64);\n\n\tif (rc == 0)\n\t\t*raid_level = buf[8];\n\tif (*raid_level > RAID_UNKNOWN)\n\t\t*raid_level = RAID_UNKNOWN;\nexit:\n\tkfree(buf);\n\treturn;\n}\n\n#define HPSA_MAP_DEBUG\n#ifdef HPSA_MAP_DEBUG\nstatic void hpsa_debug_map_buff(struct ctlr_info *h, int rc,\n\t\t\t\tstruct raid_map_data *map_buff)\n{\n\tstruct raid_map_disk_data *dd = &map_buff->data[0];\n\tint map, row, col;\n\tu16 map_cnt, row_cnt, disks_per_row;\n\n\tif (rc != 0)\n\t\treturn;\n\n\t/* Show details only if debugging has been activated. */\n\tif (h->raid_offload_debug < 2)\n\t\treturn;\n\n\tdev_info(&h->pdev->dev, \"structure_size = %u\\n\",\n\t\t\t\tle32_to_cpu(map_buff->structure_size));\n\tdev_info(&h->pdev->dev, \"volume_blk_size = %u\\n\",\n\t\t\tle32_to_cpu(map_buff->volume_blk_size));\n\tdev_info(&h->pdev->dev, \"volume_blk_cnt = 0x%llx\\n\",\n\t\t\tle64_to_cpu(map_buff->volume_blk_cnt));\n\tdev_info(&h->pdev->dev, \"physicalBlockShift = %u\\n\",\n\t\t\tmap_buff->phys_blk_shift);\n\tdev_info(&h->pdev->dev, \"parity_rotation_shift = %u\\n\",\n\t\t\tmap_buff->parity_rotation_shift);\n\tdev_info(&h->pdev->dev, \"strip_size = %u\\n\",\n\t\t\tle16_to_cpu(map_buff->strip_size));\n\tdev_info(&h->pdev->dev, \"disk_starting_blk = 0x%llx\\n\",\n\t\t\tle64_to_cpu(map_buff->disk_starting_blk));\n\tdev_info(&h->pdev->dev, \"disk_blk_cnt = 0x%llx\\n\",\n\t\t\tle64_to_cpu(map_buff->disk_blk_cnt));\n\tdev_info(&h->pdev->dev, \"data_disks_per_row = %u\\n\",\n\t\t\tle16_to_cpu(map_buff->data_disks_per_row));\n\tdev_info(&h->pdev->dev, \"metadata_disks_per_row = %u\\n\",\n\t\t\tle16_to_cpu(map_buff->metadata_disks_per_row));\n\tdev_info(&h->pdev->dev, \"row_cnt = %u\\n\",\n\t\t\tle16_to_cpu(map_buff->row_cnt));\n\tdev_info(&h->pdev->dev, \"layout_map_count = %u\\n\",\n\t\t\tle16_to_cpu(map_buff->layout_map_count));\n\tdev_info(&h->pdev->dev, \"flags = 0x%x\\n\",\n\t\t\tle16_to_cpu(map_buff->flags));\n\tdev_info(&h->pdev->dev, \"encryption = %s\\n\",\n\t\t\tle16_to_cpu(map_buff->flags) &\n\t\t\tRAID_MAP_FLAG_ENCRYPT_ON ?  \"ON\" : \"OFF\");\n\tdev_info(&h->pdev->dev, \"dekindex = %u\\n\",\n\t\t\tle16_to_cpu(map_buff->dekindex));\n\tmap_cnt = le16_to_cpu(map_buff->layout_map_count);\n\tfor (map = 0; map < map_cnt; map++) {\n\t\tdev_info(&h->pdev->dev, \"Map%u:\\n\", map);\n\t\trow_cnt = le16_to_cpu(map_buff->row_cnt);\n\t\tfor (row = 0; row < row_cnt; row++) {\n\t\t\tdev_info(&h->pdev->dev, \"  Row%u:\\n\", row);\n\t\t\tdisks_per_row =\n\t\t\t\tle16_to_cpu(map_buff->data_disks_per_row);\n\t\t\tfor (col = 0; col < disks_per_row; col++, dd++)\n\t\t\t\tdev_info(&h->pdev->dev,\n\t\t\t\t\t\"    D%02u: h=0x%04x xor=%u,%u\\n\",\n\t\t\t\t\tcol, dd->ioaccel_handle,\n\t\t\t\t\tdd->xor_mult[0], dd->xor_mult[1]);\n\t\t\tdisks_per_row =\n\t\t\t\tle16_to_cpu(map_buff->metadata_disks_per_row);\n\t\t\tfor (col = 0; col < disks_per_row; col++, dd++)\n\t\t\t\tdev_info(&h->pdev->dev,\n\t\t\t\t\t\"    M%02u: h=0x%04x xor=%u,%u\\n\",\n\t\t\t\t\tcol, dd->ioaccel_handle,\n\t\t\t\t\tdd->xor_mult[0], dd->xor_mult[1]);\n\t\t}\n\t}\n}\n#else\nstatic void hpsa_debug_map_buff(__attribute__((unused)) struct ctlr_info *h,\n\t\t\t__attribute__((unused)) int rc,\n\t\t\t__attribute__((unused)) struct raid_map_data *map_buff)\n{\n}\n#endif\n\nstatic int hpsa_get_raid_map(struct ctlr_info *h,\n\tunsigned char *scsi3addr, struct hpsa_scsi_dev_t *this_device)\n{\n\tint rc = 0;\n\tstruct CommandList *c;\n\tstruct ErrorInfo *ei;\n\n\tc = cmd_alloc(h);\n\n\tif (fill_cmd(c, HPSA_GET_RAID_MAP, h, &this_device->raid_map,\n\t\t\tsizeof(this_device->raid_map), 0,\n\t\t\tscsi3addr, TYPE_CMD)) {\n\t\tdev_warn(&h->pdev->dev, \"hpsa_get_raid_map fill_cmd failed\\n\");\n\t\tcmd_free(h, c);\n\t\treturn -1;\n\t}\n\trc = hpsa_scsi_do_simple_cmd_with_retry(h, c, DMA_FROM_DEVICE,\n\t\t\tNO_TIMEOUT);\n\tif (rc)\n\t\tgoto out;\n\tei = c->err_info;\n\tif (ei->CommandStatus != 0 && ei->CommandStatus != CMD_DATA_UNDERRUN) {\n\t\thpsa_scsi_interpret_error(h, c);\n\t\trc = -1;\n\t\tgoto out;\n\t}\n\tcmd_free(h, c);\n\n\t/* @todo in the future, dynamically allocate RAID map memory */\n\tif (le32_to_cpu(this_device->raid_map.structure_size) >\n\t\t\t\tsizeof(this_device->raid_map)) {\n\t\tdev_warn(&h->pdev->dev, \"RAID map size is too large!\\n\");\n\t\trc = -1;\n\t}\n\thpsa_debug_map_buff(h, rc, &this_device->raid_map);\n\treturn rc;\nout:\n\tcmd_free(h, c);\n\treturn rc;\n}\n\nstatic int hpsa_bmic_sense_subsystem_information(struct ctlr_info *h,\n\t\tunsigned char scsi3addr[], u16 bmic_device_index,\n\t\tstruct bmic_sense_subsystem_info *buf, size_t bufsize)\n{\n\tint rc = IO_OK;\n\tstruct CommandList *c;\n\tstruct ErrorInfo *ei;\n\n\tc = cmd_alloc(h);\n\n\trc = fill_cmd(c, BMIC_SENSE_SUBSYSTEM_INFORMATION, h, buf, bufsize,\n\t\t0, RAID_CTLR_LUNID, TYPE_CMD);\n\tif (rc)\n\t\tgoto out;\n\n\tc->Request.CDB[2] = bmic_device_index & 0xff;\n\tc->Request.CDB[9] = (bmic_device_index >> 8) & 0xff;\n\n\trc = hpsa_scsi_do_simple_cmd_with_retry(h, c, DMA_FROM_DEVICE,\n\t\t\tNO_TIMEOUT);\n\tif (rc)\n\t\tgoto out;\n\tei = c->err_info;\n\tif (ei->CommandStatus != 0 && ei->CommandStatus != CMD_DATA_UNDERRUN) {\n\t\thpsa_scsi_interpret_error(h, c);\n\t\trc = -1;\n\t}\nout:\n\tcmd_free(h, c);\n\treturn rc;\n}\n\nstatic int hpsa_bmic_id_controller(struct ctlr_info *h,\n\tstruct bmic_identify_controller *buf, size_t bufsize)\n{\n\tint rc = IO_OK;\n\tstruct CommandList *c;\n\tstruct ErrorInfo *ei;\n\n\tc = cmd_alloc(h);\n\n\trc = fill_cmd(c, BMIC_IDENTIFY_CONTROLLER, h, buf, bufsize,\n\t\t0, RAID_CTLR_LUNID, TYPE_CMD);\n\tif (rc)\n\t\tgoto out;\n\n\trc = hpsa_scsi_do_simple_cmd_with_retry(h, c, DMA_FROM_DEVICE,\n\t\t\tNO_TIMEOUT);\n\tif (rc)\n\t\tgoto out;\n\tei = c->err_info;\n\tif (ei->CommandStatus != 0 && ei->CommandStatus != CMD_DATA_UNDERRUN) {\n\t\thpsa_scsi_interpret_error(h, c);\n\t\trc = -1;\n\t}\nout:\n\tcmd_free(h, c);\n\treturn rc;\n}\n\nstatic int hpsa_bmic_id_physical_device(struct ctlr_info *h,\n\t\tunsigned char scsi3addr[], u16 bmic_device_index,\n\t\tstruct bmic_identify_physical_device *buf, size_t bufsize)\n{\n\tint rc = IO_OK;\n\tstruct CommandList *c;\n\tstruct ErrorInfo *ei;\n\n\tc = cmd_alloc(h);\n\trc = fill_cmd(c, BMIC_IDENTIFY_PHYSICAL_DEVICE, h, buf, bufsize,\n\t\t0, RAID_CTLR_LUNID, TYPE_CMD);\n\tif (rc)\n\t\tgoto out;\n\n\tc->Request.CDB[2] = bmic_device_index & 0xff;\n\tc->Request.CDB[9] = (bmic_device_index >> 8) & 0xff;\n\n\thpsa_scsi_do_simple_cmd_with_retry(h, c, DMA_FROM_DEVICE,\n\t\t\t\t\t\tNO_TIMEOUT);\n\tei = c->err_info;\n\tif (ei->CommandStatus != 0 && ei->CommandStatus != CMD_DATA_UNDERRUN) {\n\t\thpsa_scsi_interpret_error(h, c);\n\t\trc = -1;\n\t}\nout:\n\tcmd_free(h, c);\n\n\treturn rc;\n}\n\n/*\n * get enclosure information\n * struct ReportExtendedLUNdata *rlep - Used for BMIC drive number\n * struct hpsa_scsi_dev_t *encl_dev - device entry for enclosure\n * Uses id_physical_device to determine the box_index.\n */\nstatic void hpsa_get_enclosure_info(struct ctlr_info *h,\n\t\t\tunsigned char *scsi3addr,\n\t\t\tstruct ReportExtendedLUNdata *rlep, int rle_index,\n\t\t\tstruct hpsa_scsi_dev_t *encl_dev)\n{\n\tint rc = -1;\n\tstruct CommandList *c = NULL;\n\tstruct ErrorInfo *ei = NULL;\n\tstruct bmic_sense_storage_box_params *bssbp = NULL;\n\tstruct bmic_identify_physical_device *id_phys = NULL;\n\tstruct ext_report_lun_entry *rle;\n\tu16 bmic_device_index = 0;\n\n\tif (rle_index < 0 || rle_index >= HPSA_MAX_PHYS_LUN)\n\t\treturn;\n\n\trle = &rlep->LUN[rle_index];\n\n\tencl_dev->eli =\n\t\thpsa_get_enclosure_logical_identifier(h, scsi3addr);\n\n\tbmic_device_index = GET_BMIC_DRIVE_NUMBER(&rle->lunid[0]);\n\n\tif (encl_dev->target == -1 || encl_dev->lun == -1) {\n\t\trc = IO_OK;\n\t\tgoto out;\n\t}\n\n\tif (bmic_device_index == 0xFF00 || MASKED_DEVICE(&rle->lunid[0])) {\n\t\trc = IO_OK;\n\t\tgoto out;\n\t}\n\n\tbssbp = kzalloc(sizeof(*bssbp), GFP_KERNEL);\n\tif (!bssbp)\n\t\tgoto out;\n\n\tid_phys = kzalloc(sizeof(*id_phys), GFP_KERNEL);\n\tif (!id_phys)\n\t\tgoto out;\n\n\trc = hpsa_bmic_id_physical_device(h, scsi3addr, bmic_device_index,\n\t\t\t\t\t\tid_phys, sizeof(*id_phys));\n\tif (rc) {\n\t\tdev_warn(&h->pdev->dev, \"%s: id_phys failed %d bdi[0x%x]\\n\",\n\t\t\t__func__, encl_dev->external, bmic_device_index);\n\t\tgoto out;\n\t}\n\n\tc = cmd_alloc(h);\n\n\trc = fill_cmd(c, BMIC_SENSE_STORAGE_BOX_PARAMS, h, bssbp,\n\t\t\tsizeof(*bssbp), 0, RAID_CTLR_LUNID, TYPE_CMD);\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (id_phys->phys_connector[1] == 'E')\n\t\tc->Request.CDB[5] = id_phys->box_index;\n\telse\n\t\tc->Request.CDB[5] = 0;\n\n\trc = hpsa_scsi_do_simple_cmd_with_retry(h, c, DMA_FROM_DEVICE,\n\t\t\t\t\t\tNO_TIMEOUT);\n\tif (rc)\n\t\tgoto out;\n\n\tei = c->err_info;\n\tif (ei->CommandStatus != 0 && ei->CommandStatus != CMD_DATA_UNDERRUN) {\n\t\trc = -1;\n\t\tgoto out;\n\t}\n\n\tencl_dev->box[id_phys->active_path_number] = bssbp->phys_box_on_port;\n\tmemcpy(&encl_dev->phys_connector[id_phys->active_path_number],\n\t\tbssbp->phys_connector, sizeof(bssbp->phys_connector));\n\n\trc = IO_OK;\nout:\n\tkfree(bssbp);\n\tkfree(id_phys);\n\n\tif (c)\n\t\tcmd_free(h, c);\n\n\tif (rc != IO_OK)\n\t\thpsa_show_dev_msg(KERN_INFO, h, encl_dev,\n\t\t\t\"Error, could not get enclosure information\");\n}\n\nstatic u64 hpsa_get_sas_address_from_report_physical(struct ctlr_info *h,\n\t\t\t\t\t\tunsigned char *scsi3addr)\n{\n\tstruct ReportExtendedLUNdata *physdev;\n\tu32 nphysicals;\n\tu64 sa = 0;\n\tint i;\n\n\tphysdev = kzalloc(sizeof(*physdev), GFP_KERNEL);\n\tif (!physdev)\n\t\treturn 0;\n\n\tif (hpsa_scsi_do_report_phys_luns(h, physdev, sizeof(*physdev))) {\n\t\tdev_err(&h->pdev->dev, \"report physical LUNs failed.\\n\");\n\t\tkfree(physdev);\n\t\treturn 0;\n\t}\n\tnphysicals = get_unaligned_be32(physdev->LUNListLength) / 24;\n\n\tfor (i = 0; i < nphysicals; i++)\n\t\tif (!memcmp(&physdev->LUN[i].lunid[0], scsi3addr, 8)) {\n\t\t\tsa = get_unaligned_be64(&physdev->LUN[i].wwid[0]);\n\t\t\tbreak;\n\t\t}\n\n\tkfree(physdev);\n\n\treturn sa;\n}\n\nstatic void hpsa_get_sas_address(struct ctlr_info *h, unsigned char *scsi3addr,\n\t\t\t\t\tstruct hpsa_scsi_dev_t *dev)\n{\n\tint rc;\n\tu64 sa = 0;\n\n\tif (is_hba_lunid(scsi3addr)) {\n\t\tstruct bmic_sense_subsystem_info *ssi;\n\n\t\tssi = kzalloc(sizeof(*ssi), GFP_KERNEL);\n\t\tif (!ssi)\n\t\t\treturn;\n\n\t\trc = hpsa_bmic_sense_subsystem_information(h,\n\t\t\t\t\tscsi3addr, 0, ssi, sizeof(*ssi));\n\t\tif (rc == 0) {\n\t\t\tsa = get_unaligned_be64(ssi->primary_world_wide_id);\n\t\t\th->sas_address = sa;\n\t\t}\n\n\t\tkfree(ssi);\n\t} else\n\t\tsa = hpsa_get_sas_address_from_report_physical(h, scsi3addr);\n\n\tdev->sas_address = sa;\n}\n\nstatic void hpsa_ext_ctrl_present(struct ctlr_info *h,\n\tstruct ReportExtendedLUNdata *physdev)\n{\n\tu32 nphysicals;\n\tint i;\n\n\tif (h->discovery_polling)\n\t\treturn;\n\n\tnphysicals = (get_unaligned_be32(physdev->LUNListLength) / 24) + 1;\n\n\tfor (i = 0; i < nphysicals; i++) {\n\t\tif (physdev->LUN[i].device_type ==\n\t\t\tBMIC_DEVICE_TYPE_CONTROLLER\n\t\t\t&& !is_hba_lunid(physdev->LUN[i].lunid)) {\n\t\t\tdev_info(&h->pdev->dev,\n\t\t\t\t\"External controller present, activate discovery polling and disable rld caching\\n\");\n\t\t\thpsa_disable_rld_caching(h);\n\t\t\th->discovery_polling = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Get a device id from inquiry page 0x83 */\nstatic bool hpsa_vpd_page_supported(struct ctlr_info *h,\n\tunsigned char scsi3addr[], u8 page)\n{\n\tint rc;\n\tint i;\n\tint pages;\n\tunsigned char *buf, bufsize;\n\n\tbuf = kzalloc(256, GFP_KERNEL);\n\tif (!buf)\n\t\treturn false;\n\n\t/* Get the size of the page list first */\n\trc = hpsa_scsi_do_inquiry(h, scsi3addr,\n\t\t\t\tVPD_PAGE | HPSA_VPD_SUPPORTED_PAGES,\n\t\t\t\tbuf, HPSA_VPD_HEADER_SZ);\n\tif (rc != 0)\n\t\tgoto exit_unsupported;\n\tpages = buf[3];\n\tif ((pages + HPSA_VPD_HEADER_SZ) <= 255)\n\t\tbufsize = pages + HPSA_VPD_HEADER_SZ;\n\telse\n\t\tbufsize = 255;\n\n\t/* Get the whole VPD page list */\n\trc = hpsa_scsi_do_inquiry(h, scsi3addr,\n\t\t\t\tVPD_PAGE | HPSA_VPD_SUPPORTED_PAGES,\n\t\t\t\tbuf, bufsize);\n\tif (rc != 0)\n\t\tgoto exit_unsupported;\n\n\tpages = buf[3];\n\tfor (i = 1; i <= pages; i++)\n\t\tif (buf[3 + i] == page)\n\t\t\tgoto exit_supported;\nexit_unsupported:\n\tkfree(buf);\n\treturn false;\nexit_supported:\n\tkfree(buf);\n\treturn true;\n}\n\n/*\n * Called during a scan operation.\n * Sets ioaccel status on the new device list, not the existing device list\n *\n * The device list used during I/O will be updated later in\n * adjust_hpsa_scsi_table.\n */\nstatic void hpsa_get_ioaccel_status(struct ctlr_info *h,\n\tunsigned char *scsi3addr, struct hpsa_scsi_dev_t *this_device)\n{\n\tint rc;\n\tunsigned char *buf;\n\tu8 ioaccel_status;\n\n\tthis_device->offload_config = 0;\n\tthis_device->offload_enabled = 0;\n\tthis_device->offload_to_be_enabled = 0;\n\n\tbuf = kzalloc(64, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\tif (!hpsa_vpd_page_supported(h, scsi3addr, HPSA_VPD_LV_IOACCEL_STATUS))\n\t\tgoto out;\n\trc = hpsa_scsi_do_inquiry(h, scsi3addr,\n\t\t\tVPD_PAGE | HPSA_VPD_LV_IOACCEL_STATUS, buf, 64);\n\tif (rc != 0)\n\t\tgoto out;\n\n#define IOACCEL_STATUS_BYTE 4\n#define OFFLOAD_CONFIGURED_BIT 0x01\n#define OFFLOAD_ENABLED_BIT 0x02\n\tioaccel_status = buf[IOACCEL_STATUS_BYTE];\n\tthis_device->offload_config =\n\t\t!!(ioaccel_status & OFFLOAD_CONFIGURED_BIT);\n\tif (this_device->offload_config) {\n\t\tbool offload_enabled =\n\t\t\t!!(ioaccel_status & OFFLOAD_ENABLED_BIT);\n\t\t/*\n\t\t * Check to see if offload can be enabled.\n\t\t */\n\t\tif (offload_enabled) {\n\t\t\trc = hpsa_get_raid_map(h, scsi3addr, this_device);\n\t\t\tif (rc) /* could not load raid_map */\n\t\t\t\tgoto out;\n\t\t\tthis_device->offload_to_be_enabled = 1;\n\t\t}\n\t}\n\nout:\n\tkfree(buf);\n\treturn;\n}\n\n/* Get the device id from inquiry page 0x83 */\nstatic int hpsa_get_device_id(struct ctlr_info *h, unsigned char *scsi3addr,\n\tunsigned char *device_id, int index, int buflen)\n{\n\tint rc;\n\tunsigned char *buf;\n\n\t/* Does controller have VPD for device id? */\n\tif (!hpsa_vpd_page_supported(h, scsi3addr, HPSA_VPD_LV_DEVICE_ID))\n\t\treturn 1; /* not supported */\n\n\tbuf = kzalloc(64, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\trc = hpsa_scsi_do_inquiry(h, scsi3addr, VPD_PAGE |\n\t\t\t\t\tHPSA_VPD_LV_DEVICE_ID, buf, 64);\n\tif (rc == 0) {\n\t\tif (buflen > 16)\n\t\t\tbuflen = 16;\n\t\tmemcpy(device_id, &buf[8], buflen);\n\t}\n\n\tkfree(buf);\n\n\treturn rc; /*0 - got id,  otherwise, didn't */\n}\n\nstatic int hpsa_scsi_do_report_luns(struct ctlr_info *h, int logical,\n\t\tvoid *buf, int bufsize,\n\t\tint extended_response)\n{\n\tint rc = IO_OK;\n\tstruct CommandList *c;\n\tunsigned char scsi3addr[8];\n\tstruct ErrorInfo *ei;\n\n\tc = cmd_alloc(h);\n\n\t/* address the controller */\n\tmemset(scsi3addr, 0, sizeof(scsi3addr));\n\tif (fill_cmd(c, logical ? HPSA_REPORT_LOG : HPSA_REPORT_PHYS, h,\n\t\tbuf, bufsize, 0, scsi3addr, TYPE_CMD)) {\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\tif (extended_response)\n\t\tc->Request.CDB[1] = extended_response;\n\trc = hpsa_scsi_do_simple_cmd_with_retry(h, c, DMA_FROM_DEVICE,\n\t\t\tNO_TIMEOUT);\n\tif (rc)\n\t\tgoto out;\n\tei = c->err_info;\n\tif (ei->CommandStatus != 0 &&\n\t    ei->CommandStatus != CMD_DATA_UNDERRUN) {\n\t\thpsa_scsi_interpret_error(h, c);\n\t\trc = -EIO;\n\t} else {\n\t\tstruct ReportLUNdata *rld = buf;\n\n\t\tif (rld->extended_response_flag != extended_response) {\n\t\t\tif (!h->legacy_board) {\n\t\t\t\tdev_err(&h->pdev->dev,\n\t\t\t\t\t\"report luns requested format %u, got %u\\n\",\n\t\t\t\t\textended_response,\n\t\t\t\t\trld->extended_response_flag);\n\t\t\t\trc = -EINVAL;\n\t\t\t} else\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t}\nout:\n\tcmd_free(h, c);\n\treturn rc;\n}\n\nstatic inline int hpsa_scsi_do_report_phys_luns(struct ctlr_info *h,\n\t\tstruct ReportExtendedLUNdata *buf, int bufsize)\n{\n\tint rc;\n\tstruct ReportLUNdata *lbuf;\n\n\trc = hpsa_scsi_do_report_luns(h, 0, buf, bufsize,\n\t\t\t\t      HPSA_REPORT_PHYS_EXTENDED);\n\tif (!rc || rc != -EOPNOTSUPP)\n\t\treturn rc;\n\n\t/* REPORT PHYS EXTENDED is not supported */\n\tlbuf = kzalloc(sizeof(*lbuf), GFP_KERNEL);\n\tif (!lbuf)\n\t\treturn -ENOMEM;\n\n\trc = hpsa_scsi_do_report_luns(h, 0, lbuf, sizeof(*lbuf), 0);\n\tif (!rc) {\n\t\tint i;\n\t\tu32 nphys;\n\n\t\t/* Copy ReportLUNdata header */\n\t\tmemcpy(buf, lbuf, 8);\n\t\tnphys = be32_to_cpu(*((__be32 *)lbuf->LUNListLength)) / 8;\n\t\tfor (i = 0; i < nphys; i++)\n\t\t\tmemcpy(buf->LUN[i].lunid, lbuf->LUN[i], 8);\n\t}\n\tkfree(lbuf);\n\treturn rc;\n}\n\nstatic inline int hpsa_scsi_do_report_log_luns(struct ctlr_info *h,\n\t\tstruct ReportLUNdata *buf, int bufsize)\n{\n\treturn hpsa_scsi_do_report_luns(h, 1, buf, bufsize, 0);\n}\n\nstatic inline void hpsa_set_bus_target_lun(struct hpsa_scsi_dev_t *device,\n\tint bus, int target, int lun)\n{\n\tdevice->bus = bus;\n\tdevice->target = target;\n\tdevice->lun = lun;\n}\n\n/* Use VPD inquiry to get details of volume status */\nstatic int hpsa_get_volume_status(struct ctlr_info *h,\n\t\t\t\t\tunsigned char scsi3addr[])\n{\n\tint rc;\n\tint status;\n\tint size;\n\tunsigned char *buf;\n\n\tbuf = kzalloc(64, GFP_KERNEL);\n\tif (!buf)\n\t\treturn HPSA_VPD_LV_STATUS_UNSUPPORTED;\n\n\t/* Does controller have VPD for logical volume status? */\n\tif (!hpsa_vpd_page_supported(h, scsi3addr, HPSA_VPD_LV_STATUS))\n\t\tgoto exit_failed;\n\n\t/* Get the size of the VPD return buffer */\n\trc = hpsa_scsi_do_inquiry(h, scsi3addr, VPD_PAGE | HPSA_VPD_LV_STATUS,\n\t\t\t\t\tbuf, HPSA_VPD_HEADER_SZ);\n\tif (rc != 0)\n\t\tgoto exit_failed;\n\tsize = buf[3];\n\n\t/* Now get the whole VPD buffer */\n\trc = hpsa_scsi_do_inquiry(h, scsi3addr, VPD_PAGE | HPSA_VPD_LV_STATUS,\n\t\t\t\t\tbuf, size + HPSA_VPD_HEADER_SZ);\n\tif (rc != 0)\n\t\tgoto exit_failed;\n\tstatus = buf[4]; /* status byte */\n\n\tkfree(buf);\n\treturn status;\nexit_failed:\n\tkfree(buf);\n\treturn HPSA_VPD_LV_STATUS_UNSUPPORTED;\n}\n\n/* Determine offline status of a volume.\n * Return either:\n *  0 (not offline)\n *  0xff (offline for unknown reasons)\n *  # (integer code indicating one of several NOT READY states\n *     describing why a volume is to be kept offline)\n */\nstatic unsigned char hpsa_volume_offline(struct ctlr_info *h,\n\t\t\t\t\tunsigned char scsi3addr[])\n{\n\tstruct CommandList *c;\n\tunsigned char *sense;\n\tu8 sense_key, asc, ascq;\n\tint sense_len;\n\tint rc, ldstat = 0;\n#define ASC_LUN_NOT_READY 0x04\n#define ASCQ_LUN_NOT_READY_FORMAT_IN_PROGRESS 0x04\n#define ASCQ_LUN_NOT_READY_INITIALIZING_CMD_REQ 0x02\n\n\tc = cmd_alloc(h);\n\n\t(void) fill_cmd(c, TEST_UNIT_READY, h, NULL, 0, 0, scsi3addr, TYPE_CMD);\n\trc = hpsa_scsi_do_simple_cmd(h, c, DEFAULT_REPLY_QUEUE,\n\t\t\t\t\tNO_TIMEOUT);\n\tif (rc) {\n\t\tcmd_free(h, c);\n\t\treturn HPSA_VPD_LV_STATUS_UNSUPPORTED;\n\t}\n\tsense = c->err_info->SenseInfo;\n\tif (c->err_info->SenseLen > sizeof(c->err_info->SenseInfo))\n\t\tsense_len = sizeof(c->err_info->SenseInfo);\n\telse\n\t\tsense_len = c->err_info->SenseLen;\n\tdecode_sense_data(sense, sense_len, &sense_key, &asc, &ascq);\n\tcmd_free(h, c);\n\n\t/* Determine the reason for not ready state */\n\tldstat = hpsa_get_volume_status(h, scsi3addr);\n\n\t/* Keep volume offline in certain cases: */\n\tswitch (ldstat) {\n\tcase HPSA_LV_FAILED:\n\tcase HPSA_LV_UNDERGOING_ERASE:\n\tcase HPSA_LV_NOT_AVAILABLE:\n\tcase HPSA_LV_UNDERGOING_RPI:\n\tcase HPSA_LV_PENDING_RPI:\n\tcase HPSA_LV_ENCRYPTED_NO_KEY:\n\tcase HPSA_LV_PLAINTEXT_IN_ENCRYPT_ONLY_CONTROLLER:\n\tcase HPSA_LV_UNDERGOING_ENCRYPTION:\n\tcase HPSA_LV_UNDERGOING_ENCRYPTION_REKEYING:\n\tcase HPSA_LV_ENCRYPTED_IN_NON_ENCRYPTED_CONTROLLER:\n\t\treturn ldstat;\n\tcase HPSA_VPD_LV_STATUS_UNSUPPORTED:\n\t\t/* If VPD status page isn't available,\n\t\t * use ASC/ASCQ to determine state\n\t\t */\n\t\tif ((ascq == ASCQ_LUN_NOT_READY_FORMAT_IN_PROGRESS) ||\n\t\t\t(ascq == ASCQ_LUN_NOT_READY_INITIALIZING_CMD_REQ))\n\t\t\treturn ldstat;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn HPSA_LV_OK;\n}\n\nstatic int hpsa_update_device_info(struct ctlr_info *h,\n\tunsigned char scsi3addr[], struct hpsa_scsi_dev_t *this_device,\n\tunsigned char *is_OBDR_device)\n{\n\n#define OBDR_SIG_OFFSET 43\n#define OBDR_TAPE_SIG \"$DR-10\"\n#define OBDR_SIG_LEN (sizeof(OBDR_TAPE_SIG) - 1)\n#define OBDR_TAPE_INQ_SIZE (OBDR_SIG_OFFSET + OBDR_SIG_LEN)\n\n\tunsigned char *inq_buff;\n\tunsigned char *obdr_sig;\n\tint rc = 0;\n\n\tinq_buff = kzalloc(OBDR_TAPE_INQ_SIZE, GFP_KERNEL);\n\tif (!inq_buff) {\n\t\trc = -ENOMEM;\n\t\tgoto bail_out;\n\t}\n\n\t/* Do an inquiry to the device to see what it is. */\n\tif (hpsa_scsi_do_inquiry(h, scsi3addr, 0, inq_buff,\n\t\t(unsigned char) OBDR_TAPE_INQ_SIZE) != 0) {\n\t\tdev_err(&h->pdev->dev,\n\t\t\t\"%s: inquiry failed, device will be skipped.\\n\",\n\t\t\t__func__);\n\t\trc = HPSA_INQUIRY_FAILED;\n\t\tgoto bail_out;\n\t}\n\n\tscsi_sanitize_inquiry_string(&inq_buff[8], 8);\n\tscsi_sanitize_inquiry_string(&inq_buff[16], 16);\n\n\tthis_device->devtype = (inq_buff[0] & 0x1f);\n\tmemcpy(this_device->scsi3addr, scsi3addr, 8);\n\tmemcpy(this_device->vendor, &inq_buff[8],\n\t\tsizeof(this_device->vendor));\n\tmemcpy(this_device->model, &inq_buff[16],\n\t\tsizeof(this_device->model));\n\tthis_device->rev = inq_buff[2];\n\tmemset(this_device->device_id, 0,\n\t\tsizeof(this_device->device_id));\n\tif (hpsa_get_device_id(h, scsi3addr, this_device->device_id, 8,\n\t\tsizeof(this_device->device_id)) < 0) {\n\t\tdev_err(&h->pdev->dev,\n\t\t\t\"hpsa%d: %s: can't get device id for [%d:%d:%d:%d]\\t%s\\t%.16s\\n\",\n\t\t\th->ctlr, __func__,\n\t\t\th->scsi_host->host_no,\n\t\t\tthis_device->bus, this_device->target,\n\t\t\tthis_device->lun,\n\t\t\tscsi_device_type(this_device->devtype),\n\t\t\tthis_device->model);\n\t\trc = HPSA_LV_FAILED;\n\t\tgoto bail_out;\n\t}\n\n\tif ((this_device->devtype == TYPE_DISK ||\n\t\tthis_device->devtype == TYPE_ZBC) &&\n\t\tis_logical_dev_addr_mode(scsi3addr)) {\n\t\tunsigned char volume_offline;\n\n\t\thpsa_get_raid_level(h, scsi3addr, &this_device->raid_level);\n\t\tif (h->fw_support & MISC_FW_RAID_OFFLOAD_BASIC)\n\t\t\thpsa_get_ioaccel_status(h, scsi3addr, this_device);\n\t\tvolume_offline = hpsa_volume_offline(h, scsi3addr);\n\t\tif (volume_offline == HPSA_VPD_LV_STATUS_UNSUPPORTED &&\n\t\t    h->legacy_board) {\n\t\t\t/*\n\t\t\t * Legacy boards might not support volume status\n\t\t\t */\n\t\t\tdev_info(&h->pdev->dev,\n\t\t\t\t \"C0:T%d:L%d Volume status not available, assuming online.\\n\",\n\t\t\t\t this_device->target, this_device->lun);\n\t\t\tvolume_offline = 0;\n\t\t}\n\t\tthis_device->volume_offline = volume_offline;\n\t\tif (volume_offline == HPSA_LV_FAILED) {\n\t\t\trc = HPSA_LV_FAILED;\n\t\t\tdev_err(&h->pdev->dev,\n\t\t\t\t\"%s: LV failed, device will be skipped.\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto bail_out;\n\t\t}\n\t} else {\n\t\tthis_device->raid_level = RAID_UNKNOWN;\n\t\tthis_device->offload_config = 0;\n\t\thpsa_turn_off_ioaccel_for_device(this_device);\n\t\tthis_device->hba_ioaccel_enabled = 0;\n\t\tthis_device->volume_offline = 0;\n\t\tthis_device->queue_depth = h->nr_cmds;\n\t}\n\n\tif (this_device->external)\n\t\tthis_device->queue_depth = EXTERNAL_QD;\n\n\tif (is_OBDR_device) {\n\t\t/* See if this is a One-Button-Disaster-Recovery device\n\t\t * by looking for \"$DR-10\" at offset 43 in inquiry data.\n\t\t */\n\t\tobdr_sig = &inq_buff[OBDR_SIG_OFFSET];\n\t\t*is_OBDR_device = (this_device->devtype == TYPE_ROM &&\n\t\t\t\t\tstrncmp(obdr_sig, OBDR_TAPE_SIG,\n\t\t\t\t\t\tOBDR_SIG_LEN) == 0);\n\t}\n\tkfree(inq_buff);\n\treturn 0;\n\nbail_out:\n\tkfree(inq_buff);\n\treturn rc;\n}\n\n/*\n * Helper function to assign bus, target, lun mapping of devices.\n * Logical drive target and lun are assigned at this time, but\n * physical device lun and target assignment are deferred (assigned\n * in hpsa_find_target_lun, called by hpsa_scsi_add_entry.)\n*/\nstatic void figure_bus_target_lun(struct ctlr_info *h,\n\tu8 *lunaddrbytes, struct hpsa_scsi_dev_t *device)\n{\n\tu32 lunid = get_unaligned_le32(lunaddrbytes);\n\n\tif (!is_logical_dev_addr_mode(lunaddrbytes)) {\n\t\t/* physical device, target and lun filled in later */\n\t\tif (is_hba_lunid(lunaddrbytes)) {\n\t\t\tint bus = HPSA_HBA_BUS;\n\n\t\t\tif (!device->rev)\n\t\t\t\tbus = HPSA_LEGACY_HBA_BUS;\n\t\t\thpsa_set_bus_target_lun(device,\n\t\t\t\t\tbus, 0, lunid & 0x3fff);\n\t\t} else\n\t\t\t/* defer target, lun assignment for physical devices */\n\t\t\thpsa_set_bus_target_lun(device,\n\t\t\t\t\tHPSA_PHYSICAL_DEVICE_BUS, -1, -1);\n\t\treturn;\n\t}\n\t/* It's a logical device */\n\tif (device->external) {\n\t\thpsa_set_bus_target_lun(device,\n\t\t\tHPSA_EXTERNAL_RAID_VOLUME_BUS, (lunid >> 16) & 0x3fff,\n\t\t\tlunid & 0x00ff);\n\t\treturn;\n\t}\n\thpsa_set_bus_target_lun(device, HPSA_RAID_VOLUME_BUS,\n\t\t\t\t0, lunid & 0x3fff);\n}\n\nstatic int  figure_external_status(struct ctlr_info *h, int raid_ctlr_position,\n\tint i, int nphysicals, int nlocal_logicals)\n{\n\t/* In report logicals, local logicals are listed first,\n\t* then any externals.\n\t*/\n\tint logicals_start = nphysicals + (raid_ctlr_position == 0);\n\n\tif (i == raid_ctlr_position)\n\t\treturn 0;\n\n\tif (i < logicals_start)\n\t\treturn 0;\n\n\t/* i is in logicals range, but still within local logicals */\n\tif ((i - nphysicals - (raid_ctlr_position == 0)) < nlocal_logicals)\n\t\treturn 0;\n\n\treturn 1; /* it's an external lun */\n}\n\n/*\n * Do CISS_REPORT_PHYS and CISS_REPORT_LOG.  Data is returned in physdev,\n * logdev.  The number of luns in physdev and logdev are returned in\n * *nphysicals and *nlogicals, respectively.\n * Returns 0 on success, -1 otherwise.\n */\nstatic int hpsa_gather_lun_info(struct ctlr_info *h,\n\tstruct ReportExtendedLUNdata *physdev, u32 *nphysicals,\n\tstruct ReportLUNdata *logdev, u32 *nlogicals)\n{\n\tif (hpsa_scsi_do_report_phys_luns(h, physdev, sizeof(*physdev))) {\n\t\tdev_err(&h->pdev->dev, \"report physical LUNs failed.\\n\");\n\t\treturn -1;\n\t}\n\t*nphysicals = be32_to_cpu(*((__be32 *)physdev->LUNListLength)) / 24;\n\tif (*nphysicals > HPSA_MAX_PHYS_LUN) {\n\t\tdev_warn(&h->pdev->dev, \"maximum physical LUNs (%d) exceeded. %d LUNs ignored.\\n\",\n\t\t\tHPSA_MAX_PHYS_LUN, *nphysicals - HPSA_MAX_PHYS_LUN);\n\t\t*nphysicals = HPSA_MAX_PHYS_LUN;\n\t}\n\tif (hpsa_scsi_do_report_log_luns(h, logdev, sizeof(*logdev))) {\n\t\tdev_err(&h->pdev->dev, \"report logical LUNs failed.\\n\");\n\t\treturn -1;\n\t}\n\t*nlogicals = be32_to_cpu(*((__be32 *) logdev->LUNListLength)) / 8;\n\t/* Reject Logicals in excess of our max capability. */\n\tif (*nlogicals > HPSA_MAX_LUN) {\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t\"maximum logical LUNs (%d) exceeded.  \"\n\t\t\t\"%d LUNs ignored.\\n\", HPSA_MAX_LUN,\n\t\t\t*nlogicals - HPSA_MAX_LUN);\n\t\t*nlogicals = HPSA_MAX_LUN;\n\t}\n\tif (*nlogicals + *nphysicals > HPSA_MAX_PHYS_LUN) {\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t\"maximum logical + physical LUNs (%d) exceeded. \"\n\t\t\t\"%d LUNs ignored.\\n\", HPSA_MAX_PHYS_LUN,\n\t\t\t*nphysicals + *nlogicals - HPSA_MAX_PHYS_LUN);\n\t\t*nlogicals = HPSA_MAX_PHYS_LUN - *nphysicals;\n\t}\n\treturn 0;\n}\n\nstatic u8 *figure_lunaddrbytes(struct ctlr_info *h, int raid_ctlr_position,\n\tint i, int nphysicals, int nlogicals,\n\tstruct ReportExtendedLUNdata *physdev_list,\n\tstruct ReportLUNdata *logdev_list)\n{\n\t/* Helper function, figure out where the LUN ID info is coming from\n\t * given index i, lists of physical and logical devices, where in\n\t * the list the raid controller is supposed to appear (first or last)\n\t */\n\n\tint logicals_start = nphysicals + (raid_ctlr_position == 0);\n\tint last_device = nphysicals + nlogicals + (raid_ctlr_position == 0);\n\n\tif (i == raid_ctlr_position)\n\t\treturn RAID_CTLR_LUNID;\n\n\tif (i < logicals_start)\n\t\treturn &physdev_list->LUN[i -\n\t\t\t\t(raid_ctlr_position == 0)].lunid[0];\n\n\tif (i < last_device)\n\t\treturn &logdev_list->LUN[i - nphysicals -\n\t\t\t(raid_ctlr_position == 0)][0];\n\tBUG();\n\treturn NULL;\n}\n\n/* get physical drive ioaccel handle and queue depth */\nstatic void hpsa_get_ioaccel_drive_info(struct ctlr_info *h,\n\t\tstruct hpsa_scsi_dev_t *dev,\n\t\tstruct ReportExtendedLUNdata *rlep, int rle_index,\n\t\tstruct bmic_identify_physical_device *id_phys)\n{\n\tint rc;\n\tstruct ext_report_lun_entry *rle;\n\n\tif (rle_index < 0 || rle_index >= HPSA_MAX_PHYS_LUN)\n\t\treturn;\n\n\trle = &rlep->LUN[rle_index];\n\n\tdev->ioaccel_handle = rle->ioaccel_handle;\n\tif ((rle->device_flags & 0x08) && dev->ioaccel_handle)\n\t\tdev->hba_ioaccel_enabled = 1;\n\tmemset(id_phys, 0, sizeof(*id_phys));\n\trc = hpsa_bmic_id_physical_device(h, &rle->lunid[0],\n\t\t\tGET_BMIC_DRIVE_NUMBER(&rle->lunid[0]), id_phys,\n\t\t\tsizeof(*id_phys));\n\tif (!rc)\n\t\t/* Reserve space for FW operations */\n#define DRIVE_CMDS_RESERVED_FOR_FW 2\n#define DRIVE_QUEUE_DEPTH 7\n\t\tdev->queue_depth =\n\t\t\tle16_to_cpu(id_phys->current_queue_depth_limit) -\n\t\t\t\tDRIVE_CMDS_RESERVED_FOR_FW;\n\telse\n\t\tdev->queue_depth = DRIVE_QUEUE_DEPTH; /* conservative */\n}\n\nstatic void hpsa_get_path_info(struct hpsa_scsi_dev_t *this_device,\n\tstruct ReportExtendedLUNdata *rlep, int rle_index,\n\tstruct bmic_identify_physical_device *id_phys)\n{\n\tstruct ext_report_lun_entry *rle;\n\n\tif (rle_index < 0 || rle_index >= HPSA_MAX_PHYS_LUN)\n\t\treturn;\n\n\trle = &rlep->LUN[rle_index];\n\n\tif ((rle->device_flags & 0x08) && this_device->ioaccel_handle)\n\t\tthis_device->hba_ioaccel_enabled = 1;\n\n\tmemcpy(&this_device->active_path_index,\n\t\t&id_phys->active_path_number,\n\t\tsizeof(this_device->active_path_index));\n\tmemcpy(&this_device->path_map,\n\t\t&id_phys->redundant_path_present_map,\n\t\tsizeof(this_device->path_map));\n\tmemcpy(&this_device->box,\n\t\t&id_phys->alternate_paths_phys_box_on_port,\n\t\tsizeof(this_device->box));\n\tmemcpy(&this_device->phys_connector,\n\t\t&id_phys->alternate_paths_phys_connector,\n\t\tsizeof(this_device->phys_connector));\n\tmemcpy(&this_device->bay,\n\t\t&id_phys->phys_bay_in_box,\n\t\tsizeof(this_device->bay));\n}\n\n/* get number of local logical disks. */\nstatic int hpsa_set_local_logical_count(struct ctlr_info *h,\n\tstruct bmic_identify_controller *id_ctlr,\n\tu32 *nlocals)\n{\n\tint rc;\n\n\tif (!id_ctlr) {\n\t\tdev_warn(&h->pdev->dev, \"%s: id_ctlr buffer is NULL.\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\tmemset(id_ctlr, 0, sizeof(*id_ctlr));\n\trc = hpsa_bmic_id_controller(h, id_ctlr, sizeof(*id_ctlr));\n\tif (!rc)\n\t\tif (id_ctlr->configured_logical_drive_count < 255)\n\t\t\t*nlocals = id_ctlr->configured_logical_drive_count;\n\t\telse\n\t\t\t*nlocals = le16_to_cpu(\n\t\t\t\t\tid_ctlr->extended_logical_unit_count);\n\telse\n\t\t*nlocals = -1;\n\treturn rc;\n}\n\nstatic bool hpsa_is_disk_spare(struct ctlr_info *h, u8 *lunaddrbytes)\n{\n\tstruct bmic_identify_physical_device *id_phys;\n\tbool is_spare = false;\n\tint rc;\n\n\tid_phys = kzalloc(sizeof(*id_phys), GFP_KERNEL);\n\tif (!id_phys)\n\t\treturn false;\n\n\trc = hpsa_bmic_id_physical_device(h,\n\t\t\t\t\tlunaddrbytes,\n\t\t\t\t\tGET_BMIC_DRIVE_NUMBER(lunaddrbytes),\n\t\t\t\t\tid_phys, sizeof(*id_phys));\n\tif (rc == 0)\n\t\tis_spare = (id_phys->more_flags >> 6) & 0x01;\n\n\tkfree(id_phys);\n\treturn is_spare;\n}\n\n#define RPL_DEV_FLAG_NON_DISK                           0x1\n#define RPL_DEV_FLAG_UNCONFIG_DISK_REPORTING_SUPPORTED  0x2\n#define RPL_DEV_FLAG_UNCONFIG_DISK                      0x4\n\n#define BMIC_DEVICE_TYPE_ENCLOSURE  6\n\nstatic bool hpsa_skip_device(struct ctlr_info *h, u8 *lunaddrbytes,\n\t\t\t\tstruct ext_report_lun_entry *rle)\n{\n\tu8 device_flags;\n\tu8 device_type;\n\n\tif (!MASKED_DEVICE(lunaddrbytes))\n\t\treturn false;\n\n\tdevice_flags = rle->device_flags;\n\tdevice_type = rle->device_type;\n\n\tif (device_flags & RPL_DEV_FLAG_NON_DISK) {\n\t\tif (device_type == BMIC_DEVICE_TYPE_ENCLOSURE)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tif (!(device_flags & RPL_DEV_FLAG_UNCONFIG_DISK_REPORTING_SUPPORTED))\n\t\treturn false;\n\n\tif (device_flags & RPL_DEV_FLAG_UNCONFIG_DISK)\n\t\treturn false;\n\n\t/*\n\t * Spares may be spun down, we do not want to\n\t * do an Inquiry to a RAID set spare drive as\n\t * that would have them spun up, that is a\n\t * performance hit because I/O to the RAID device\n\t * stops while the spin up occurs which can take\n\t * over 50 seconds.\n\t */\n\tif (hpsa_is_disk_spare(h, lunaddrbytes))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void hpsa_update_scsi_devices(struct ctlr_info *h)\n{\n\t/* the idea here is we could get notified\n\t * that some devices have changed, so we do a report\n\t * physical luns and report logical luns cmd, and adjust\n\t * our list of devices accordingly.\n\t *\n\t * The scsi3addr's of devices won't change so long as the\n\t * adapter is not reset.  That means we can rescan and\n\t * tell which devices we already know about, vs. new\n\t * devices, vs.  disappearing devices.\n\t */\n\tstruct ReportExtendedLUNdata *physdev_list = NULL;\n\tstruct ReportLUNdata *logdev_list = NULL;\n\tstruct bmic_identify_physical_device *id_phys = NULL;\n\tstruct bmic_identify_controller *id_ctlr = NULL;\n\tu32 nphysicals = 0;\n\tu32 nlogicals = 0;\n\tu32 nlocal_logicals = 0;\n\tu32 ndev_allocated = 0;\n\tstruct hpsa_scsi_dev_t **currentsd, *this_device, *tmpdevice;\n\tint ncurrent = 0;\n\tint i, ndevs_to_allocate;\n\tint raid_ctlr_position;\n\tbool physical_device;\n\tDECLARE_BITMAP(lunzerobits, MAX_EXT_TARGETS);\n\n\tcurrentsd = kcalloc(HPSA_MAX_DEVICES, sizeof(*currentsd), GFP_KERNEL);\n\tphysdev_list = kzalloc(sizeof(*physdev_list), GFP_KERNEL);\n\tlogdev_list = kzalloc(sizeof(*logdev_list), GFP_KERNEL);\n\ttmpdevice = kzalloc(sizeof(*tmpdevice), GFP_KERNEL);\n\tid_phys = kzalloc(sizeof(*id_phys), GFP_KERNEL);\n\tid_ctlr = kzalloc(sizeof(*id_ctlr), GFP_KERNEL);\n\n\tif (!currentsd || !physdev_list || !logdev_list ||\n\t\t!tmpdevice || !id_phys || !id_ctlr) {\n\t\tdev_err(&h->pdev->dev, \"out of memory\\n\");\n\t\tgoto out;\n\t}\n\tmemset(lunzerobits, 0, sizeof(lunzerobits));\n\n\th->drv_req_rescan = 0; /* cancel scheduled rescan - we're doing it. */\n\n\tif (hpsa_gather_lun_info(h, physdev_list, &nphysicals,\n\t\t\tlogdev_list, &nlogicals)) {\n\t\th->drv_req_rescan = 1;\n\t\tgoto out;\n\t}\n\n\t/* Set number of local logicals (non PTRAID) */\n\tif (hpsa_set_local_logical_count(h, id_ctlr, &nlocal_logicals)) {\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t\"%s: Can't determine number of local logical devices.\\n\",\n\t\t\t__func__);\n\t}\n\n\t/* We might see up to the maximum number of logical and physical disks\n\t * plus external target devices, and a device for the local RAID\n\t * controller.\n\t */\n\tndevs_to_allocate = nphysicals + nlogicals + MAX_EXT_TARGETS + 1;\n\n\thpsa_ext_ctrl_present(h, physdev_list);\n\n\t/* Allocate the per device structures */\n\tfor (i = 0; i < ndevs_to_allocate; i++) {\n\t\tif (i >= HPSA_MAX_DEVICES) {\n\t\t\tdev_warn(&h->pdev->dev, \"maximum devices (%d) exceeded.\"\n\t\t\t\t\"  %d devices ignored.\\n\", HPSA_MAX_DEVICES,\n\t\t\t\tndevs_to_allocate - HPSA_MAX_DEVICES);\n\t\t\tbreak;\n\t\t}\n\n\t\tcurrentsd[i] = kzalloc(sizeof(*currentsd[i]), GFP_KERNEL);\n\t\tif (!currentsd[i]) {\n\t\t\th->drv_req_rescan = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tndev_allocated++;\n\t}\n\n\tif (is_scsi_rev_5(h))\n\t\traid_ctlr_position = 0;\n\telse\n\t\traid_ctlr_position = nphysicals + nlogicals;\n\n\t/* adjust our table of devices */\n\tfor (i = 0; i < nphysicals + nlogicals + 1; i++) {\n\t\tu8 *lunaddrbytes, is_OBDR = 0;\n\t\tint rc = 0;\n\t\tint phys_dev_index = i - (raid_ctlr_position == 0);\n\t\tbool skip_device = false;\n\n\t\tmemset(tmpdevice, 0, sizeof(*tmpdevice));\n\n\t\tphysical_device = i < nphysicals + (raid_ctlr_position == 0);\n\n\t\t/* Figure out where the LUN ID info is coming from */\n\t\tlunaddrbytes = figure_lunaddrbytes(h, raid_ctlr_position,\n\t\t\ti, nphysicals, nlogicals, physdev_list, logdev_list);\n\n\t\t/* Determine if this is a lun from an external target array */\n\t\ttmpdevice->external =\n\t\t\tfigure_external_status(h, raid_ctlr_position, i,\n\t\t\t\t\t\tnphysicals, nlocal_logicals);\n\n\t\t/*\n\t\t * Skip over some devices such as a spare.\n\t\t */\n\t\tif (phys_dev_index >= 0 && !tmpdevice->external &&\n\t\t\tphysical_device) {\n\t\t\tskip_device = hpsa_skip_device(h, lunaddrbytes,\n\t\t\t\t\t&physdev_list->LUN[phys_dev_index]);\n\t\t\tif (skip_device)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get device type, vendor, model, device id, raid_map */\n\t\trc = hpsa_update_device_info(h, lunaddrbytes, tmpdevice,\n\t\t\t\t\t\t\t&is_OBDR);\n\t\tif (rc == -ENOMEM) {\n\t\t\tdev_warn(&h->pdev->dev,\n\t\t\t\t\"Out of memory, rescan deferred.\\n\");\n\t\t\th->drv_req_rescan = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (rc) {\n\t\t\th->drv_req_rescan = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfigure_bus_target_lun(h, lunaddrbytes, tmpdevice);\n\t\tthis_device = currentsd[ncurrent];\n\n\t\t*this_device = *tmpdevice;\n\t\tthis_device->physical_device = physical_device;\n\n\t\t/*\n\t\t * Expose all devices except for physical devices that\n\t\t * are masked.\n\t\t */\n\t\tif (MASKED_DEVICE(lunaddrbytes) && this_device->physical_device)\n\t\t\tthis_device->expose_device = 0;\n\t\telse\n\t\t\tthis_device->expose_device = 1;\n\n\n\t\t/*\n\t\t * Get the SAS address for physical devices that are exposed.\n\t\t */\n\t\tif (this_device->physical_device && this_device->expose_device)\n\t\t\thpsa_get_sas_address(h, lunaddrbytes, this_device);\n\n\t\tswitch (this_device->devtype) {\n\t\tcase TYPE_ROM:\n\t\t\t/* We don't *really* support actual CD-ROM devices,\n\t\t\t * just \"One Button Disaster Recovery\" tape drive\n\t\t\t * which temporarily pretends to be a CD-ROM drive.\n\t\t\t * So we check that the device is really an OBDR tape\n\t\t\t * device by checking for \"$DR-10\" in bytes 43-48 of\n\t\t\t * the inquiry data.\n\t\t\t */\n\t\t\tif (is_OBDR)\n\t\t\t\tncurrent++;\n\t\t\tbreak;\n\t\tcase TYPE_DISK:\n\t\tcase TYPE_ZBC:\n\t\t\tif (this_device->physical_device) {\n\t\t\t\t/* The disk is in HBA mode. */\n\t\t\t\t/* Never use RAID mapper in HBA mode. */\n\t\t\t\tthis_device->offload_enabled = 0;\n\t\t\t\thpsa_get_ioaccel_drive_info(h, this_device,\n\t\t\t\t\tphysdev_list, phys_dev_index, id_phys);\n\t\t\t\thpsa_get_path_info(this_device,\n\t\t\t\t\tphysdev_list, phys_dev_index, id_phys);\n\t\t\t}\n\t\t\tncurrent++;\n\t\t\tbreak;\n\t\tcase TYPE_TAPE:\n\t\tcase TYPE_MEDIUM_CHANGER:\n\t\t\tncurrent++;\n\t\t\tbreak;\n\t\tcase TYPE_ENCLOSURE:\n\t\t\tif (!this_device->external)\n\t\t\t\thpsa_get_enclosure_info(h, lunaddrbytes,\n\t\t\t\t\t\tphysdev_list, phys_dev_index,\n\t\t\t\t\t\tthis_device);\n\t\t\tncurrent++;\n\t\t\tbreak;\n\t\tcase TYPE_RAID:\n\t\t\t/* Only present the Smartarray HBA as a RAID controller.\n\t\t\t * If it's a RAID controller other than the HBA itself\n\t\t\t * (an external RAID controller, MSA500 or similar)\n\t\t\t * don't present it.\n\t\t\t */\n\t\t\tif (!is_hba_lunid(lunaddrbytes))\n\t\t\t\tbreak;\n\t\t\tncurrent++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (ncurrent >= HPSA_MAX_DEVICES)\n\t\t\tbreak;\n\t}\n\n\tif (h->sas_host == NULL) {\n\t\tint rc = 0;\n\n\t\trc = hpsa_add_sas_host(h);\n\t\tif (rc) {\n\t\t\tdev_warn(&h->pdev->dev,\n\t\t\t\t\"Could not add sas host %d\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tadjust_hpsa_scsi_table(h, currentsd, ncurrent);\nout:\n\tkfree(tmpdevice);\n\tfor (i = 0; i < ndev_allocated; i++)\n\t\tkfree(currentsd[i]);\n\tkfree(currentsd);\n\tkfree(physdev_list);\n\tkfree(logdev_list);\n\tkfree(id_ctlr);\n\tkfree(id_phys);\n}\n\nstatic void hpsa_set_sg_descriptor(struct SGDescriptor *desc,\n\t\t\t\t   struct scatterlist *sg)\n{\n\tu64 addr64 = (u64) sg_dma_address(sg);\n\tunsigned int len = sg_dma_len(sg);\n\n\tdesc->Addr = cpu_to_le64(addr64);\n\tdesc->Len = cpu_to_le32(len);\n\tdesc->Ext = 0;\n}\n\n/*\n * hpsa_scatter_gather takes a struct scsi_cmnd, (cmd), and does the pci\n * dma mapping  and fills in the scatter gather entries of the\n * hpsa command, cp.\n */\nstatic int hpsa_scatter_gather(struct ctlr_info *h,\n\t\tstruct CommandList *cp,\n\t\tstruct scsi_cmnd *cmd)\n{\n\tstruct scatterlist *sg;\n\tint use_sg, i, sg_limit, chained;\n\tstruct SGDescriptor *curr_sg;\n\n\tBUG_ON(scsi_sg_count(cmd) > h->maxsgentries);\n\n\tuse_sg = scsi_dma_map(cmd);\n\tif (use_sg < 0)\n\t\treturn use_sg;\n\n\tif (!use_sg)\n\t\tgoto sglist_finished;\n\n\t/*\n\t * If the number of entries is greater than the max for a single list,\n\t * then we have a chained list; we will set up all but one entry in the\n\t * first list (the last entry is saved for link information);\n\t * otherwise, we don't have a chained list and we'll set up at each of\n\t * the entries in the one list.\n\t */\n\tcurr_sg = cp->SG;\n\tchained = use_sg > h->max_cmd_sg_entries;\n\tsg_limit = chained ? h->max_cmd_sg_entries - 1 : use_sg;\n\tscsi_for_each_sg(cmd, sg, sg_limit, i) {\n\t\thpsa_set_sg_descriptor(curr_sg, sg);\n\t\tcurr_sg++;\n\t}\n\n\tif (chained) {\n\t\t/*\n\t\t * Continue with the chained list.  Set curr_sg to the chained\n\t\t * list.  Modify the limit to the total count less the entries\n\t\t * we've already set up.  Resume the scan at the list entry\n\t\t * where the previous loop left off.\n\t\t */\n\t\tcurr_sg = h->cmd_sg_list[cp->cmdindex];\n\t\tsg_limit = use_sg - sg_limit;\n\t\tfor_each_sg(sg, sg, sg_limit, i) {\n\t\t\thpsa_set_sg_descriptor(curr_sg, sg);\n\t\t\tcurr_sg++;\n\t\t}\n\t}\n\n\t/* Back the pointer up to the last entry and mark it as \"last\". */\n\t(curr_sg - 1)->Ext = cpu_to_le32(HPSA_SG_LAST);\n\n\tif (use_sg + chained > h->maxSG)\n\t\th->maxSG = use_sg + chained;\n\n\tif (chained) {\n\t\tcp->Header.SGList = h->max_cmd_sg_entries;\n\t\tcp->Header.SGTotal = cpu_to_le16(use_sg + 1);\n\t\tif (hpsa_map_sg_chain_block(h, cp)) {\n\t\t\tscsi_dma_unmap(cmd);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\nsglist_finished:\n\n\tcp->Header.SGList = (u8) use_sg;   /* no. SGs contig in this cmd */\n\tcp->Header.SGTotal = cpu_to_le16(use_sg); /* total sgs in cmd list */\n\treturn 0;\n}\n\nstatic inline void warn_zero_length_transfer(struct ctlr_info *h,\n\t\t\t\t\t\tu8 *cdb, int cdb_len,\n\t\t\t\t\t\tconst char *func)\n{\n\tdev_warn(&h->pdev->dev,\n\t\t \"%s: Blocking zero-length request: CDB:%*phN\\n\",\n\t\t func, cdb_len, cdb);\n}\n\n#define IO_ACCEL_INELIGIBLE 1\n/* zero-length transfers trigger hardware errors. */\nstatic bool is_zero_length_transfer(u8 *cdb)\n{\n\tu32 block_cnt;\n\n\t/* Block zero-length transfer sizes on certain commands. */\n\tswitch (cdb[0]) {\n\tcase READ_10:\n\tcase WRITE_10:\n\tcase VERIFY:\t\t/* 0x2F */\n\tcase WRITE_VERIFY:\t/* 0x2E */\n\t\tblock_cnt = get_unaligned_be16(&cdb[7]);\n\t\tbreak;\n\tcase READ_12:\n\tcase WRITE_12:\n\tcase VERIFY_12: /* 0xAF */\n\tcase WRITE_VERIFY_12:\t/* 0xAE */\n\t\tblock_cnt = get_unaligned_be32(&cdb[6]);\n\t\tbreak;\n\tcase READ_16:\n\tcase WRITE_16:\n\tcase VERIFY_16:\t\t/* 0x8F */\n\t\tblock_cnt = get_unaligned_be32(&cdb[10]);\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn block_cnt == 0;\n}\n\nstatic int fixup_ioaccel_cdb(u8 *cdb, int *cdb_len)\n{\n\tint is_write = 0;\n\tu32 block;\n\tu32 block_cnt;\n\n\t/* Perform some CDB fixups if needed using 10 byte reads/writes only */\n\tswitch (cdb[0]) {\n\tcase WRITE_6:\n\tcase WRITE_12:\n\t\tis_write = 1;\n\t\tfallthrough;\n\tcase READ_6:\n\tcase READ_12:\n\t\tif (*cdb_len == 6) {\n\t\t\tblock = (((cdb[1] & 0x1F) << 16) |\n\t\t\t\t(cdb[2] << 8) |\n\t\t\t\tcdb[3]);\n\t\t\tblock_cnt = cdb[4];\n\t\t\tif (block_cnt == 0)\n\t\t\t\tblock_cnt = 256;\n\t\t} else {\n\t\t\tBUG_ON(*cdb_len != 12);\n\t\t\tblock = get_unaligned_be32(&cdb[2]);\n\t\t\tblock_cnt = get_unaligned_be32(&cdb[6]);\n\t\t}\n\t\tif (block_cnt > 0xffff)\n\t\t\treturn IO_ACCEL_INELIGIBLE;\n\n\t\tcdb[0] = is_write ? WRITE_10 : READ_10;\n\t\tcdb[1] = 0;\n\t\tcdb[2] = (u8) (block >> 24);\n\t\tcdb[3] = (u8) (block >> 16);\n\t\tcdb[4] = (u8) (block >> 8);\n\t\tcdb[5] = (u8) (block);\n\t\tcdb[6] = 0;\n\t\tcdb[7] = (u8) (block_cnt >> 8);\n\t\tcdb[8] = (u8) (block_cnt);\n\t\tcdb[9] = 0;\n\t\t*cdb_len = 10;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int hpsa_scsi_ioaccel1_queue_command(struct ctlr_info *h,\n\tstruct CommandList *c, u32 ioaccel_handle, u8 *cdb, int cdb_len,\n\tu8 *scsi3addr, struct hpsa_scsi_dev_t *phys_disk)\n{\n\tstruct scsi_cmnd *cmd = c->scsi_cmd;\n\tstruct io_accel1_cmd *cp = &h->ioaccel_cmd_pool[c->cmdindex];\n\tunsigned int len;\n\tunsigned int total_len = 0;\n\tstruct scatterlist *sg;\n\tu64 addr64;\n\tint use_sg, i;\n\tstruct SGDescriptor *curr_sg;\n\tu32 control = IOACCEL1_CONTROL_SIMPLEQUEUE;\n\n\t/* TODO: implement chaining support */\n\tif (scsi_sg_count(cmd) > h->ioaccel_maxsg) {\n\t\tatomic_dec(&phys_disk->ioaccel_cmds_out);\n\t\treturn IO_ACCEL_INELIGIBLE;\n\t}\n\n\tBUG_ON(cmd->cmd_len > IOACCEL1_IOFLAGS_CDBLEN_MAX);\n\n\tif (is_zero_length_transfer(cdb)) {\n\t\twarn_zero_length_transfer(h, cdb, cdb_len, __func__);\n\t\tatomic_dec(&phys_disk->ioaccel_cmds_out);\n\t\treturn IO_ACCEL_INELIGIBLE;\n\t}\n\n\tif (fixup_ioaccel_cdb(cdb, &cdb_len)) {\n\t\tatomic_dec(&phys_disk->ioaccel_cmds_out);\n\t\treturn IO_ACCEL_INELIGIBLE;\n\t}\n\n\tc->cmd_type = CMD_IOACCEL1;\n\n\t/* Adjust the DMA address to point to the accelerated command buffer */\n\tc->busaddr = (u32) h->ioaccel_cmd_pool_dhandle +\n\t\t\t\t(c->cmdindex * sizeof(*cp));\n\tBUG_ON(c->busaddr & 0x0000007F);\n\n\tuse_sg = scsi_dma_map(cmd);\n\tif (use_sg < 0) {\n\t\tatomic_dec(&phys_disk->ioaccel_cmds_out);\n\t\treturn use_sg;\n\t}\n\n\tif (use_sg) {\n\t\tcurr_sg = cp->SG;\n\t\tscsi_for_each_sg(cmd, sg, use_sg, i) {\n\t\t\taddr64 = (u64) sg_dma_address(sg);\n\t\t\tlen  = sg_dma_len(sg);\n\t\t\ttotal_len += len;\n\t\t\tcurr_sg->Addr = cpu_to_le64(addr64);\n\t\t\tcurr_sg->Len = cpu_to_le32(len);\n\t\t\tcurr_sg->Ext = cpu_to_le32(0);\n\t\t\tcurr_sg++;\n\t\t}\n\t\t(--curr_sg)->Ext = cpu_to_le32(HPSA_SG_LAST);\n\n\t\tswitch (cmd->sc_data_direction) {\n\t\tcase DMA_TO_DEVICE:\n\t\t\tcontrol |= IOACCEL1_CONTROL_DATA_OUT;\n\t\t\tbreak;\n\t\tcase DMA_FROM_DEVICE:\n\t\t\tcontrol |= IOACCEL1_CONTROL_DATA_IN;\n\t\t\tbreak;\n\t\tcase DMA_NONE:\n\t\t\tcontrol |= IOACCEL1_CONTROL_NODATAXFER;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&h->pdev->dev, \"unknown data direction: %d\\n\",\n\t\t\tcmd->sc_data_direction);\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tcontrol |= IOACCEL1_CONTROL_NODATAXFER;\n\t}\n\n\tc->Header.SGList = use_sg;\n\t/* Fill out the command structure to submit */\n\tcp->dev_handle = cpu_to_le16(ioaccel_handle & 0xFFFF);\n\tcp->transfer_len = cpu_to_le32(total_len);\n\tcp->io_flags = cpu_to_le16(IOACCEL1_IOFLAGS_IO_REQ |\n\t\t\t(cdb_len & IOACCEL1_IOFLAGS_CDBLEN_MASK));\n\tcp->control = cpu_to_le32(control);\n\tmemcpy(cp->CDB, cdb, cdb_len);\n\tmemcpy(cp->CISS_LUN, scsi3addr, 8);\n\t/* Tag was already set at init time. */\n\tenqueue_cmd_and_start_io(h, c);\n\treturn 0;\n}\n\n/*\n * Queue a command directly to a device behind the controller using the\n * I/O accelerator path.\n */\nstatic int hpsa_scsi_ioaccel_direct_map(struct ctlr_info *h,\n\tstruct CommandList *c)\n{\n\tstruct scsi_cmnd *cmd = c->scsi_cmd;\n\tstruct hpsa_scsi_dev_t *dev = cmd->device->hostdata;\n\n\tif (!dev)\n\t\treturn -1;\n\n\tc->phys_disk = dev;\n\n\tif (dev->in_reset)\n\t\treturn -1;\n\n\treturn hpsa_scsi_ioaccel_queue_command(h, c, dev->ioaccel_handle,\n\t\tcmd->cmnd, cmd->cmd_len, dev->scsi3addr, dev);\n}\n\n/*\n * Set encryption parameters for the ioaccel2 request\n */\nstatic void set_encrypt_ioaccel2(struct ctlr_info *h,\n\tstruct CommandList *c, struct io_accel2_cmd *cp)\n{\n\tstruct scsi_cmnd *cmd = c->scsi_cmd;\n\tstruct hpsa_scsi_dev_t *dev = cmd->device->hostdata;\n\tstruct raid_map_data *map = &dev->raid_map;\n\tu64 first_block;\n\n\t/* Are we doing encryption on this device */\n\tif (!(le16_to_cpu(map->flags) & RAID_MAP_FLAG_ENCRYPT_ON))\n\t\treturn;\n\t/* Set the data encryption key index. */\n\tcp->dekindex = map->dekindex;\n\n\t/* Set the encryption enable flag, encoded into direction field. */\n\tcp->direction |= IOACCEL2_DIRECTION_ENCRYPT_MASK;\n\n\t/* Set encryption tweak values based on logical block address\n\t * If block size is 512, tweak value is LBA.\n\t * For other block sizes, tweak is (LBA * block size)/ 512)\n\t */\n\tswitch (cmd->cmnd[0]) {\n\t/* Required? 6-byte cdbs eliminated by fixup_ioaccel_cdb */\n\tcase READ_6:\n\tcase WRITE_6:\n\t\tfirst_block = (((cmd->cmnd[1] & 0x1F) << 16) |\n\t\t\t\t(cmd->cmnd[2] << 8) |\n\t\t\t\tcmd->cmnd[3]);\n\t\tbreak;\n\tcase WRITE_10:\n\tcase READ_10:\n\t/* Required? 12-byte cdbs eliminated by fixup_ioaccel_cdb */\n\tcase WRITE_12:\n\tcase READ_12:\n\t\tfirst_block = get_unaligned_be32(&cmd->cmnd[2]);\n\t\tbreak;\n\tcase WRITE_16:\n\tcase READ_16:\n\t\tfirst_block = get_unaligned_be64(&cmd->cmnd[2]);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&h->pdev->dev,\n\t\t\t\"ERROR: %s: size (0x%x) not supported for encryption\\n\",\n\t\t\t__func__, cmd->cmnd[0]);\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tif (le32_to_cpu(map->volume_blk_size) != 512)\n\t\tfirst_block = first_block *\n\t\t\t\tle32_to_cpu(map->volume_blk_size)/512;\n\n\tcp->tweak_lower = cpu_to_le32(first_block);\n\tcp->tweak_upper = cpu_to_le32(first_block >> 32);\n}\n\nstatic int hpsa_scsi_ioaccel2_queue_command(struct ctlr_info *h,\n\tstruct CommandList *c, u32 ioaccel_handle, u8 *cdb, int cdb_len,\n\tu8 *scsi3addr, struct hpsa_scsi_dev_t *phys_disk)\n{\n\tstruct scsi_cmnd *cmd = c->scsi_cmd;\n\tstruct io_accel2_cmd *cp = &h->ioaccel2_cmd_pool[c->cmdindex];\n\tstruct ioaccel2_sg_element *curr_sg;\n\tint use_sg, i;\n\tstruct scatterlist *sg;\n\tu64 addr64;\n\tu32 len;\n\tu32 total_len = 0;\n\n\tif (!cmd->device)\n\t\treturn -1;\n\n\tif (!cmd->device->hostdata)\n\t\treturn -1;\n\n\tBUG_ON(scsi_sg_count(cmd) > h->maxsgentries);\n\n\tif (is_zero_length_transfer(cdb)) {\n\t\twarn_zero_length_transfer(h, cdb, cdb_len, __func__);\n\t\tatomic_dec(&phys_disk->ioaccel_cmds_out);\n\t\treturn IO_ACCEL_INELIGIBLE;\n\t}\n\n\tif (fixup_ioaccel_cdb(cdb, &cdb_len)) {\n\t\tatomic_dec(&phys_disk->ioaccel_cmds_out);\n\t\treturn IO_ACCEL_INELIGIBLE;\n\t}\n\n\tc->cmd_type = CMD_IOACCEL2;\n\t/* Adjust the DMA address to point to the accelerated command buffer */\n\tc->busaddr = (u32) h->ioaccel2_cmd_pool_dhandle +\n\t\t\t\t(c->cmdindex * sizeof(*cp));\n\tBUG_ON(c->busaddr & 0x0000007F);\n\n\tmemset(cp, 0, sizeof(*cp));\n\tcp->IU_type = IOACCEL2_IU_TYPE;\n\n\tuse_sg = scsi_dma_map(cmd);\n\tif (use_sg < 0) {\n\t\tatomic_dec(&phys_disk->ioaccel_cmds_out);\n\t\treturn use_sg;\n\t}\n\n\tif (use_sg) {\n\t\tcurr_sg = cp->sg;\n\t\tif (use_sg > h->ioaccel_maxsg) {\n\t\t\taddr64 = le64_to_cpu(\n\t\t\t\th->ioaccel2_cmd_sg_list[c->cmdindex]->address);\n\t\t\tcurr_sg->address = cpu_to_le64(addr64);\n\t\t\tcurr_sg->length = 0;\n\t\t\tcurr_sg->reserved[0] = 0;\n\t\t\tcurr_sg->reserved[1] = 0;\n\t\t\tcurr_sg->reserved[2] = 0;\n\t\t\tcurr_sg->chain_indicator = IOACCEL2_CHAIN;\n\n\t\t\tcurr_sg = h->ioaccel2_cmd_sg_list[c->cmdindex];\n\t\t}\n\t\tscsi_for_each_sg(cmd, sg, use_sg, i) {\n\t\t\taddr64 = (u64) sg_dma_address(sg);\n\t\t\tlen  = sg_dma_len(sg);\n\t\t\ttotal_len += len;\n\t\t\tcurr_sg->address = cpu_to_le64(addr64);\n\t\t\tcurr_sg->length = cpu_to_le32(len);\n\t\t\tcurr_sg->reserved[0] = 0;\n\t\t\tcurr_sg->reserved[1] = 0;\n\t\t\tcurr_sg->reserved[2] = 0;\n\t\t\tcurr_sg->chain_indicator = 0;\n\t\t\tcurr_sg++;\n\t\t}\n\n\t\t/*\n\t\t * Set the last s/g element bit\n\t\t */\n\t\t(curr_sg - 1)->chain_indicator = IOACCEL2_LAST_SG;\n\n\t\tswitch (cmd->sc_data_direction) {\n\t\tcase DMA_TO_DEVICE:\n\t\t\tcp->direction &= ~IOACCEL2_DIRECTION_MASK;\n\t\t\tcp->direction |= IOACCEL2_DIR_DATA_OUT;\n\t\t\tbreak;\n\t\tcase DMA_FROM_DEVICE:\n\t\t\tcp->direction &= ~IOACCEL2_DIRECTION_MASK;\n\t\t\tcp->direction |= IOACCEL2_DIR_DATA_IN;\n\t\t\tbreak;\n\t\tcase DMA_NONE:\n\t\t\tcp->direction &= ~IOACCEL2_DIRECTION_MASK;\n\t\t\tcp->direction |= IOACCEL2_DIR_NO_DATA;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&h->pdev->dev, \"unknown data direction: %d\\n\",\n\t\t\t\tcmd->sc_data_direction);\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tcp->direction &= ~IOACCEL2_DIRECTION_MASK;\n\t\tcp->direction |= IOACCEL2_DIR_NO_DATA;\n\t}\n\n\t/* Set encryption parameters, if necessary */\n\tset_encrypt_ioaccel2(h, c, cp);\n\n\tcp->scsi_nexus = cpu_to_le32(ioaccel_handle);\n\tcp->Tag = cpu_to_le32(c->cmdindex << DIRECT_LOOKUP_SHIFT);\n\tmemcpy(cp->cdb, cdb, sizeof(cp->cdb));\n\n\tcp->data_len = cpu_to_le32(total_len);\n\tcp->err_ptr = cpu_to_le64(c->busaddr +\n\t\t\toffsetof(struct io_accel2_cmd, error_data));\n\tcp->err_len = cpu_to_le32(sizeof(cp->error_data));\n\n\t/* fill in sg elements */\n\tif (use_sg > h->ioaccel_maxsg) {\n\t\tcp->sg_count = 1;\n\t\tcp->sg[0].length = cpu_to_le32(use_sg * sizeof(cp->sg[0]));\n\t\tif (hpsa_map_ioaccel2_sg_chain_block(h, cp, c)) {\n\t\t\tatomic_dec(&phys_disk->ioaccel_cmds_out);\n\t\t\tscsi_dma_unmap(cmd);\n\t\t\treturn -1;\n\t\t}\n\t} else\n\t\tcp->sg_count = (u8) use_sg;\n\n\tif (phys_disk->in_reset) {\n\t\tcmd->result = DID_RESET << 16;\n\t\treturn -1;\n\t}\n\n\tenqueue_cmd_and_start_io(h, c);\n\treturn 0;\n}\n\n/*\n * Queue a command to the correct I/O accelerator path.\n */\nstatic int hpsa_scsi_ioaccel_queue_command(struct ctlr_info *h,\n\tstruct CommandList *c, u32 ioaccel_handle, u8 *cdb, int cdb_len,\n\tu8 *scsi3addr, struct hpsa_scsi_dev_t *phys_disk)\n{\n\tif (!c->scsi_cmd->device)\n\t\treturn -1;\n\n\tif (!c->scsi_cmd->device->hostdata)\n\t\treturn -1;\n\n\tif (phys_disk->in_reset)\n\t\treturn -1;\n\n\t/* Try to honor the device's queue depth */\n\tif (atomic_inc_return(&phys_disk->ioaccel_cmds_out) >\n\t\t\t\t\tphys_disk->queue_depth) {\n\t\tatomic_dec(&phys_disk->ioaccel_cmds_out);\n\t\treturn IO_ACCEL_INELIGIBLE;\n\t}\n\tif (h->transMethod & CFGTBL_Trans_io_accel1)\n\t\treturn hpsa_scsi_ioaccel1_queue_command(h, c, ioaccel_handle,\n\t\t\t\t\t\tcdb, cdb_len, scsi3addr,\n\t\t\t\t\t\tphys_disk);\n\telse\n\t\treturn hpsa_scsi_ioaccel2_queue_command(h, c, ioaccel_handle,\n\t\t\t\t\t\tcdb, cdb_len, scsi3addr,\n\t\t\t\t\t\tphys_disk);\n}\n\nstatic void raid_map_helper(struct raid_map_data *map,\n\t\tint offload_to_mirror, u32 *map_index, u32 *current_group)\n{\n\tif (offload_to_mirror == 0)  {\n\t\t/* use physical disk in the first mirrored group. */\n\t\t*map_index %= le16_to_cpu(map->data_disks_per_row);\n\t\treturn;\n\t}\n\tdo {\n\t\t/* determine mirror group that *map_index indicates */\n\t\t*current_group = *map_index /\n\t\t\tle16_to_cpu(map->data_disks_per_row);\n\t\tif (offload_to_mirror == *current_group)\n\t\t\tcontinue;\n\t\tif (*current_group < le16_to_cpu(map->layout_map_count) - 1) {\n\t\t\t/* select map index from next group */\n\t\t\t*map_index += le16_to_cpu(map->data_disks_per_row);\n\t\t\t(*current_group)++;\n\t\t} else {\n\t\t\t/* select map index from first group */\n\t\t\t*map_index %= le16_to_cpu(map->data_disks_per_row);\n\t\t\t*current_group = 0;\n\t\t}\n\t} while (offload_to_mirror != *current_group);\n}\n\n/*\n * Attempt to perform offload RAID mapping for a logical volume I/O.\n */\nstatic int hpsa_scsi_ioaccel_raid_map(struct ctlr_info *h,\n\tstruct CommandList *c)\n{\n\tstruct scsi_cmnd *cmd = c->scsi_cmd;\n\tstruct hpsa_scsi_dev_t *dev = cmd->device->hostdata;\n\tstruct raid_map_data *map = &dev->raid_map;\n\tstruct raid_map_disk_data *dd = &map->data[0];\n\tint is_write = 0;\n\tu32 map_index;\n\tu64 first_block, last_block;\n\tu32 block_cnt;\n\tu32 blocks_per_row;\n\tu64 first_row, last_row;\n\tu32 first_row_offset, last_row_offset;\n\tu32 first_column, last_column;\n\tu64 r0_first_row, r0_last_row;\n\tu32 r5or6_blocks_per_row;\n\tu64 r5or6_first_row, r5or6_last_row;\n\tu32 r5or6_first_row_offset, r5or6_last_row_offset;\n\tu32 r5or6_first_column, r5or6_last_column;\n\tu32 total_disks_per_row;\n\tu32 stripesize;\n\tu32 first_group, last_group, current_group;\n\tu32 map_row;\n\tu32 disk_handle;\n\tu64 disk_block;\n\tu32 disk_block_cnt;\n\tu8 cdb[16];\n\tu8 cdb_len;\n\tu16 strip_size;\n#if BITS_PER_LONG == 32\n\tu64 tmpdiv;\n#endif\n\tint offload_to_mirror;\n\n\tif (!dev)\n\t\treturn -1;\n\n\tif (dev->in_reset)\n\t\treturn -1;\n\n\t/* check for valid opcode, get LBA and block count */\n\tswitch (cmd->cmnd[0]) {\n\tcase WRITE_6:\n\t\tis_write = 1;\n\t\tfallthrough;\n\tcase READ_6:\n\t\tfirst_block = (((cmd->cmnd[1] & 0x1F) << 16) |\n\t\t\t\t(cmd->cmnd[2] << 8) |\n\t\t\t\tcmd->cmnd[3]);\n\t\tblock_cnt = cmd->cmnd[4];\n\t\tif (block_cnt == 0)\n\t\t\tblock_cnt = 256;\n\t\tbreak;\n\tcase WRITE_10:\n\t\tis_write = 1;\n\t\tfallthrough;\n\tcase READ_10:\n\t\tfirst_block =\n\t\t\t(((u64) cmd->cmnd[2]) << 24) |\n\t\t\t(((u64) cmd->cmnd[3]) << 16) |\n\t\t\t(((u64) cmd->cmnd[4]) << 8) |\n\t\t\tcmd->cmnd[5];\n\t\tblock_cnt =\n\t\t\t(((u32) cmd->cmnd[7]) << 8) |\n\t\t\tcmd->cmnd[8];\n\t\tbreak;\n\tcase WRITE_12:\n\t\tis_write = 1;\n\t\tfallthrough;\n\tcase READ_12:\n\t\tfirst_block =\n\t\t\t(((u64) cmd->cmnd[2]) << 24) |\n\t\t\t(((u64) cmd->cmnd[3]) << 16) |\n\t\t\t(((u64) cmd->cmnd[4]) << 8) |\n\t\t\tcmd->cmnd[5];\n\t\tblock_cnt =\n\t\t\t(((u32) cmd->cmnd[6]) << 24) |\n\t\t\t(((u32) cmd->cmnd[7]) << 16) |\n\t\t\t(((u32) cmd->cmnd[8]) << 8) |\n\t\tcmd->cmnd[9];\n\t\tbreak;\n\tcase WRITE_16:\n\t\tis_write = 1;\n\t\tfallthrough;\n\tcase READ_16:\n\t\tfirst_block =\n\t\t\t(((u64) cmd->cmnd[2]) << 56) |\n\t\t\t(((u64) cmd->cmnd[3]) << 48) |\n\t\t\t(((u64) cmd->cmnd[4]) << 40) |\n\t\t\t(((u64) cmd->cmnd[5]) << 32) |\n\t\t\t(((u64) cmd->cmnd[6]) << 24) |\n\t\t\t(((u64) cmd->cmnd[7]) << 16) |\n\t\t\t(((u64) cmd->cmnd[8]) << 8) |\n\t\t\tcmd->cmnd[9];\n\t\tblock_cnt =\n\t\t\t(((u32) cmd->cmnd[10]) << 24) |\n\t\t\t(((u32) cmd->cmnd[11]) << 16) |\n\t\t\t(((u32) cmd->cmnd[12]) << 8) |\n\t\t\tcmd->cmnd[13];\n\t\tbreak;\n\tdefault:\n\t\treturn IO_ACCEL_INELIGIBLE; /* process via normal I/O path */\n\t}\n\tlast_block = first_block + block_cnt - 1;\n\n\t/* check for write to non-RAID-0 */\n\tif (is_write && dev->raid_level != 0)\n\t\treturn IO_ACCEL_INELIGIBLE;\n\n\t/* check for invalid block or wraparound */\n\tif (last_block >= le64_to_cpu(map->volume_blk_cnt) ||\n\t\tlast_block < first_block)\n\t\treturn IO_ACCEL_INELIGIBLE;\n\n\t/* calculate stripe information for the request */\n\tblocks_per_row = le16_to_cpu(map->data_disks_per_row) *\n\t\t\t\tle16_to_cpu(map->strip_size);\n\tstrip_size = le16_to_cpu(map->strip_size);\n#if BITS_PER_LONG == 32\n\ttmpdiv = first_block;\n\t(void) do_div(tmpdiv, blocks_per_row);\n\tfirst_row = tmpdiv;\n\ttmpdiv = last_block;\n\t(void) do_div(tmpdiv, blocks_per_row);\n\tlast_row = tmpdiv;\n\tfirst_row_offset = (u32) (first_block - (first_row * blocks_per_row));\n\tlast_row_offset = (u32) (last_block - (last_row * blocks_per_row));\n\ttmpdiv = first_row_offset;\n\t(void) do_div(tmpdiv, strip_size);\n\tfirst_column = tmpdiv;\n\ttmpdiv = last_row_offset;\n\t(void) do_div(tmpdiv, strip_size);\n\tlast_column = tmpdiv;\n#else\n\tfirst_row = first_block / blocks_per_row;\n\tlast_row = last_block / blocks_per_row;\n\tfirst_row_offset = (u32) (first_block - (first_row * blocks_per_row));\n\tlast_row_offset = (u32) (last_block - (last_row * blocks_per_row));\n\tfirst_column = first_row_offset / strip_size;\n\tlast_column = last_row_offset / strip_size;\n#endif\n\n\t/* if this isn't a single row/column then give to the controller */\n\tif ((first_row != last_row) || (first_column != last_column))\n\t\treturn IO_ACCEL_INELIGIBLE;\n\n\t/* proceeding with driver mapping */\n\ttotal_disks_per_row = le16_to_cpu(map->data_disks_per_row) +\n\t\t\t\tle16_to_cpu(map->metadata_disks_per_row);\n\tmap_row = ((u32)(first_row >> map->parity_rotation_shift)) %\n\t\t\t\tle16_to_cpu(map->row_cnt);\n\tmap_index = (map_row * total_disks_per_row) + first_column;\n\n\tswitch (dev->raid_level) {\n\tcase HPSA_RAID_0:\n\t\tbreak; /* nothing special to do */\n\tcase HPSA_RAID_1:\n\t\t/* Handles load balance across RAID 1 members.\n\t\t * (2-drive R1 and R10 with even # of drives.)\n\t\t * Appropriate for SSDs, not optimal for HDDs\n\t\t * Ensure we have the correct raid_map.\n\t\t */\n\t\tif (le16_to_cpu(map->layout_map_count) != 2) {\n\t\t\thpsa_turn_off_ioaccel_for_device(dev);\n\t\t\treturn IO_ACCEL_INELIGIBLE;\n\t\t}\n\t\tif (dev->offload_to_mirror)\n\t\t\tmap_index += le16_to_cpu(map->data_disks_per_row);\n\t\tdev->offload_to_mirror = !dev->offload_to_mirror;\n\t\tbreak;\n\tcase HPSA_RAID_ADM:\n\t\t/* Handles N-way mirrors  (R1-ADM)\n\t\t * and R10 with # of drives divisible by 3.)\n\t\t * Ensure we have the correct raid_map.\n\t\t */\n\t\tif (le16_to_cpu(map->layout_map_count) != 3) {\n\t\t\thpsa_turn_off_ioaccel_for_device(dev);\n\t\t\treturn IO_ACCEL_INELIGIBLE;\n\t\t}\n\n\t\toffload_to_mirror = dev->offload_to_mirror;\n\t\traid_map_helper(map, offload_to_mirror,\n\t\t\t\t&map_index, &current_group);\n\t\t/* set mirror group to use next time */\n\t\toffload_to_mirror =\n\t\t\t(offload_to_mirror >=\n\t\t\tle16_to_cpu(map->layout_map_count) - 1)\n\t\t\t? 0 : offload_to_mirror + 1;\n\t\tdev->offload_to_mirror = offload_to_mirror;\n\t\t/* Avoid direct use of dev->offload_to_mirror within this\n\t\t * function since multiple threads might simultaneously\n\t\t * increment it beyond the range of dev->layout_map_count -1.\n\t\t */\n\t\tbreak;\n\tcase HPSA_RAID_5:\n\tcase HPSA_RAID_6:\n\t\tif (le16_to_cpu(map->layout_map_count) <= 1)\n\t\t\tbreak;\n\n\t\t/* Verify first and last block are in same RAID group */\n\t\tr5or6_blocks_per_row =\n\t\t\tle16_to_cpu(map->strip_size) *\n\t\t\tle16_to_cpu(map->data_disks_per_row);\n\t\tif (r5or6_blocks_per_row == 0) {\n\t\t\thpsa_turn_off_ioaccel_for_device(dev);\n\t\t\treturn IO_ACCEL_INELIGIBLE;\n\t\t}\n\t\tstripesize = r5or6_blocks_per_row *\n\t\t\tle16_to_cpu(map->layout_map_count);\n#if BITS_PER_LONG == 32\n\t\ttmpdiv = first_block;\n\t\tfirst_group = do_div(tmpdiv, stripesize);\n\t\ttmpdiv = first_group;\n\t\t(void) do_div(tmpdiv, r5or6_blocks_per_row);\n\t\tfirst_group = tmpdiv;\n\t\ttmpdiv = last_block;\n\t\tlast_group = do_div(tmpdiv, stripesize);\n\t\ttmpdiv = last_group;\n\t\t(void) do_div(tmpdiv, r5or6_blocks_per_row);\n\t\tlast_group = tmpdiv;\n#else\n\t\tfirst_group = (first_block % stripesize) / r5or6_blocks_per_row;\n\t\tlast_group = (last_block % stripesize) / r5or6_blocks_per_row;\n#endif\n\t\tif (first_group != last_group)\n\t\t\treturn IO_ACCEL_INELIGIBLE;\n\n\t\t/* Verify request is in a single row of RAID 5/6 */\n#if BITS_PER_LONG == 32\n\t\ttmpdiv = first_block;\n\t\t(void) do_div(tmpdiv, stripesize);\n\t\tfirst_row = r5or6_first_row = r0_first_row = tmpdiv;\n\t\ttmpdiv = last_block;\n\t\t(void) do_div(tmpdiv, stripesize);\n\t\tr5or6_last_row = r0_last_row = tmpdiv;\n#else\n\t\tfirst_row = r5or6_first_row = r0_first_row =\n\t\t\t\t\t\tfirst_block / stripesize;\n\t\tr5or6_last_row = r0_last_row = last_block / stripesize;\n#endif\n\t\tif (r5or6_first_row != r5or6_last_row)\n\t\t\treturn IO_ACCEL_INELIGIBLE;\n\n\n\t\t/* Verify request is in a single column */\n#if BITS_PER_LONG == 32\n\t\ttmpdiv = first_block;\n\t\tfirst_row_offset = do_div(tmpdiv, stripesize);\n\t\ttmpdiv = first_row_offset;\n\t\tfirst_row_offset = (u32) do_div(tmpdiv, r5or6_blocks_per_row);\n\t\tr5or6_first_row_offset = first_row_offset;\n\t\ttmpdiv = last_block;\n\t\tr5or6_last_row_offset = do_div(tmpdiv, stripesize);\n\t\ttmpdiv = r5or6_last_row_offset;\n\t\tr5or6_last_row_offset = do_div(tmpdiv, r5or6_blocks_per_row);\n\t\ttmpdiv = r5or6_first_row_offset;\n\t\t(void) do_div(tmpdiv, map->strip_size);\n\t\tfirst_column = r5or6_first_column = tmpdiv;\n\t\ttmpdiv = r5or6_last_row_offset;\n\t\t(void) do_div(tmpdiv, map->strip_size);\n\t\tr5or6_last_column = tmpdiv;\n#else\n\t\tfirst_row_offset = r5or6_first_row_offset =\n\t\t\t(u32)((first_block % stripesize) %\n\t\t\t\t\t\tr5or6_blocks_per_row);\n\n\t\tr5or6_last_row_offset =\n\t\t\t(u32)((last_block % stripesize) %\n\t\t\t\t\t\tr5or6_blocks_per_row);\n\n\t\tfirst_column = r5or6_first_column =\n\t\t\tr5or6_first_row_offset / le16_to_cpu(map->strip_size);\n\t\tr5or6_last_column =\n\t\t\tr5or6_last_row_offset / le16_to_cpu(map->strip_size);\n#endif\n\t\tif (r5or6_first_column != r5or6_last_column)\n\t\t\treturn IO_ACCEL_INELIGIBLE;\n\n\t\t/* Request is eligible */\n\t\tmap_row = ((u32)(first_row >> map->parity_rotation_shift)) %\n\t\t\tle16_to_cpu(map->row_cnt);\n\n\t\tmap_index = (first_group *\n\t\t\t(le16_to_cpu(map->row_cnt) * total_disks_per_row)) +\n\t\t\t(map_row * total_disks_per_row) + first_column;\n\t\tbreak;\n\tdefault:\n\t\treturn IO_ACCEL_INELIGIBLE;\n\t}\n\n\tif (unlikely(map_index >= RAID_MAP_MAX_ENTRIES))\n\t\treturn IO_ACCEL_INELIGIBLE;\n\n\tc->phys_disk = dev->phys_disk[map_index];\n\tif (!c->phys_disk)\n\t\treturn IO_ACCEL_INELIGIBLE;\n\n\tdisk_handle = dd[map_index].ioaccel_handle;\n\tdisk_block = le64_to_cpu(map->disk_starting_blk) +\n\t\t\tfirst_row * le16_to_cpu(map->strip_size) +\n\t\t\t(first_row_offset - first_column *\n\t\t\tle16_to_cpu(map->strip_size));\n\tdisk_block_cnt = block_cnt;\n\n\t/* handle differing logical/physical block sizes */\n\tif (map->phys_blk_shift) {\n\t\tdisk_block <<= map->phys_blk_shift;\n\t\tdisk_block_cnt <<= map->phys_blk_shift;\n\t}\n\tBUG_ON(disk_block_cnt > 0xffff);\n\n\t/* build the new CDB for the physical disk I/O */\n\tif (disk_block > 0xffffffff) {\n\t\tcdb[0] = is_write ? WRITE_16 : READ_16;\n\t\tcdb[1] = 0;\n\t\tcdb[2] = (u8) (disk_block >> 56);\n\t\tcdb[3] = (u8) (disk_block >> 48);\n\t\tcdb[4] = (u8) (disk_block >> 40);\n\t\tcdb[5] = (u8) (disk_block >> 32);\n\t\tcdb[6] = (u8) (disk_block >> 24);\n\t\tcdb[7] = (u8) (disk_block >> 16);\n\t\tcdb[8] = (u8) (disk_block >> 8);\n\t\tcdb[9] = (u8) (disk_block);\n\t\tcdb[10] = (u8) (disk_block_cnt >> 24);\n\t\tcdb[11] = (u8) (disk_block_cnt >> 16);\n\t\tcdb[12] = (u8) (disk_block_cnt >> 8);\n\t\tcdb[13] = (u8) (disk_block_cnt);\n\t\tcdb[14] = 0;\n\t\tcdb[15] = 0;\n\t\tcdb_len = 16;\n\t} else {\n\t\tcdb[0] = is_write ? WRITE_10 : READ_10;\n\t\tcdb[1] = 0;\n\t\tcdb[2] = (u8) (disk_block >> 24);\n\t\tcdb[3] = (u8) (disk_block >> 16);\n\t\tcdb[4] = (u8) (disk_block >> 8);\n\t\tcdb[5] = (u8) (disk_block);\n\t\tcdb[6] = 0;\n\t\tcdb[7] = (u8) (disk_block_cnt >> 8);\n\t\tcdb[8] = (u8) (disk_block_cnt);\n\t\tcdb[9] = 0;\n\t\tcdb_len = 10;\n\t}\n\treturn hpsa_scsi_ioaccel_queue_command(h, c, disk_handle, cdb, cdb_len,\n\t\t\t\t\t\tdev->scsi3addr,\n\t\t\t\t\t\tdev->phys_disk[map_index]);\n}\n\n/*\n * Submit commands down the \"normal\" RAID stack path\n * All callers to hpsa_ciss_submit must check lockup_detected\n * beforehand, before (opt.) and after calling cmd_alloc\n */\nstatic int hpsa_ciss_submit(struct ctlr_info *h,\n\tstruct CommandList *c, struct scsi_cmnd *cmd,\n\tstruct hpsa_scsi_dev_t *dev)\n{\n\tcmd->host_scribble = (unsigned char *) c;\n\tc->cmd_type = CMD_SCSI;\n\tc->scsi_cmd = cmd;\n\tc->Header.ReplyQueue = 0;  /* unused in simple mode */\n\tmemcpy(&c->Header.LUN.LunAddrBytes[0], &dev->scsi3addr[0], 8);\n\tc->Header.tag = cpu_to_le64((c->cmdindex << DIRECT_LOOKUP_SHIFT));\n\n\t/* Fill in the request block... */\n\n\tc->Request.Timeout = 0;\n\tBUG_ON(cmd->cmd_len > sizeof(c->Request.CDB));\n\tc->Request.CDBLen = cmd->cmd_len;\n\tmemcpy(c->Request.CDB, cmd->cmnd, cmd->cmd_len);\n\tswitch (cmd->sc_data_direction) {\n\tcase DMA_TO_DEVICE:\n\t\tc->Request.type_attr_dir =\n\t\t\tTYPE_ATTR_DIR(TYPE_CMD, ATTR_SIMPLE, XFER_WRITE);\n\t\tbreak;\n\tcase DMA_FROM_DEVICE:\n\t\tc->Request.type_attr_dir =\n\t\t\tTYPE_ATTR_DIR(TYPE_CMD, ATTR_SIMPLE, XFER_READ);\n\t\tbreak;\n\tcase DMA_NONE:\n\t\tc->Request.type_attr_dir =\n\t\t\tTYPE_ATTR_DIR(TYPE_CMD, ATTR_SIMPLE, XFER_NONE);\n\t\tbreak;\n\tcase DMA_BIDIRECTIONAL:\n\t\t/* This can happen if a buggy application does a scsi passthru\n\t\t * and sets both inlen and outlen to non-zero. ( see\n\t\t * ../scsi/scsi_ioctl.c:scsi_ioctl_send_command() )\n\t\t */\n\n\t\tc->Request.type_attr_dir =\n\t\t\tTYPE_ATTR_DIR(TYPE_CMD, ATTR_SIMPLE, XFER_RSVD);\n\t\t/* This is technically wrong, and hpsa controllers should\n\t\t * reject it with CMD_INVALID, which is the most correct\n\t\t * response, but non-fibre backends appear to let it\n\t\t * slide by, and give the same results as if this field\n\t\t * were set correctly.  Either way is acceptable for\n\t\t * our purposes here.\n\t\t */\n\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&h->pdev->dev, \"unknown data direction: %d\\n\",\n\t\t\tcmd->sc_data_direction);\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tif (hpsa_scatter_gather(h, c, cmd) < 0) { /* Fill SG list */\n\t\thpsa_cmd_resolve_and_free(h, c);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tif (dev->in_reset) {\n\t\thpsa_cmd_resolve_and_free(h, c);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tc->device = dev;\n\n\tenqueue_cmd_and_start_io(h, c);\n\t/* the cmd'll come back via intr handler in complete_scsi_command()  */\n\treturn 0;\n}\n\nstatic void hpsa_cmd_init(struct ctlr_info *h, int index,\n\t\t\t\tstruct CommandList *c)\n{\n\tdma_addr_t cmd_dma_handle, err_dma_handle;\n\n\t/* Zero out all of commandlist except the last field, refcount */\n\tmemset(c, 0, offsetof(struct CommandList, refcount));\n\tc->Header.tag = cpu_to_le64((u64) (index << DIRECT_LOOKUP_SHIFT));\n\tcmd_dma_handle = h->cmd_pool_dhandle + index * sizeof(*c);\n\tc->err_info = h->errinfo_pool + index;\n\tmemset(c->err_info, 0, sizeof(*c->err_info));\n\terr_dma_handle = h->errinfo_pool_dhandle\n\t    + index * sizeof(*c->err_info);\n\tc->cmdindex = index;\n\tc->busaddr = (u32) cmd_dma_handle;\n\tc->ErrDesc.Addr = cpu_to_le64((u64) err_dma_handle);\n\tc->ErrDesc.Len = cpu_to_le32((u32) sizeof(*c->err_info));\n\tc->h = h;\n\tc->scsi_cmd = SCSI_CMD_IDLE;\n}\n\nstatic void hpsa_preinitialize_commands(struct ctlr_info *h)\n{\n\tint i;\n\n\tfor (i = 0; i < h->nr_cmds; i++) {\n\t\tstruct CommandList *c = h->cmd_pool + i;\n\n\t\thpsa_cmd_init(h, i, c);\n\t\tatomic_set(&c->refcount, 0);\n\t}\n}\n\nstatic inline void hpsa_cmd_partial_init(struct ctlr_info *h, int index,\n\t\t\t\tstruct CommandList *c)\n{\n\tdma_addr_t cmd_dma_handle = h->cmd_pool_dhandle + index * sizeof(*c);\n\n\tBUG_ON(c->cmdindex != index);\n\n\tmemset(c->Request.CDB, 0, sizeof(c->Request.CDB));\n\tmemset(c->err_info, 0, sizeof(*c->err_info));\n\tc->busaddr = (u32) cmd_dma_handle;\n}\n\nstatic int hpsa_ioaccel_submit(struct ctlr_info *h,\n\t\tstruct CommandList *c, struct scsi_cmnd *cmd,\n\t\tbool retry)\n{\n\tstruct hpsa_scsi_dev_t *dev = cmd->device->hostdata;\n\tint rc = IO_ACCEL_INELIGIBLE;\n\n\tif (!dev)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\tif (dev->in_reset)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\tif (hpsa_simple_mode)\n\t\treturn IO_ACCEL_INELIGIBLE;\n\n\tcmd->host_scribble = (unsigned char *) c;\n\n\tif (dev->offload_enabled) {\n\t\thpsa_cmd_init(h, c->cmdindex, c); /* Zeroes out all fields */\n\t\tc->cmd_type = CMD_SCSI;\n\t\tc->scsi_cmd = cmd;\n\t\tc->device = dev;\n\t\tif (retry) /* Resubmit but do not increment device->commands_outstanding. */\n\t\t\tc->retry_pending = true;\n\t\trc = hpsa_scsi_ioaccel_raid_map(h, c);\n\t\tif (rc < 0)     /* scsi_dma_map failed. */\n\t\t\trc = SCSI_MLQUEUE_HOST_BUSY;\n\t} else if (dev->hba_ioaccel_enabled) {\n\t\thpsa_cmd_init(h, c->cmdindex, c); /* Zeroes out all fields */\n\t\tc->cmd_type = CMD_SCSI;\n\t\tc->scsi_cmd = cmd;\n\t\tc->device = dev;\n\t\tif (retry) /* Resubmit but do not increment device->commands_outstanding. */\n\t\t\tc->retry_pending = true;\n\t\trc = hpsa_scsi_ioaccel_direct_map(h, c);\n\t\tif (rc < 0)     /* scsi_dma_map failed. */\n\t\t\trc = SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\treturn rc;\n}\n\nstatic void hpsa_command_resubmit_worker(struct work_struct *work)\n{\n\tstruct scsi_cmnd *cmd;\n\tstruct hpsa_scsi_dev_t *dev;\n\tstruct CommandList *c = container_of(work, struct CommandList, work);\n\n\tcmd = c->scsi_cmd;\n\tdev = cmd->device->hostdata;\n\tif (!dev) {\n\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\treturn hpsa_cmd_free_and_done(c->h, c, cmd);\n\t}\n\n\tif (dev->in_reset) {\n\t\tcmd->result = DID_RESET << 16;\n\t\treturn hpsa_cmd_free_and_done(c->h, c, cmd);\n\t}\n\n\tif (c->cmd_type == CMD_IOACCEL2) {\n\t\tstruct ctlr_info *h = c->h;\n\t\tstruct io_accel2_cmd *c2 = &h->ioaccel2_cmd_pool[c->cmdindex];\n\t\tint rc;\n\n\t\tif (c2->error_data.serv_response ==\n\t\t\t\tIOACCEL2_STATUS_SR_TASK_COMP_SET_FULL) {\n\t\t\t/* Resubmit with the retry_pending flag set. */\n\t\t\trc = hpsa_ioaccel_submit(h, c, cmd, true);\n\t\t\tif (rc == 0)\n\t\t\t\treturn;\n\t\t\tif (rc == SCSI_MLQUEUE_HOST_BUSY) {\n\t\t\t\t/*\n\t\t\t\t * If we get here, it means dma mapping failed.\n\t\t\t\t * Try again via scsi mid layer, which will\n\t\t\t\t * then get SCSI_MLQUEUE_HOST_BUSY.\n\t\t\t\t */\n\t\t\t\tcmd->result = DID_IMM_RETRY << 16;\n\t\t\t\treturn hpsa_cmd_free_and_done(h, c, cmd);\n\t\t\t}\n\t\t\t/* else, fall thru and resubmit down CISS path */\n\t\t}\n\t}\n\thpsa_cmd_partial_init(c->h, c->cmdindex, c);\n\t/*\n\t * Here we have not come in though queue_command, so we\n\t * can set the retry_pending flag to true for a driver initiated\n\t * retry attempt (I.E. not a SML retry).\n\t * I.E. We are submitting a driver initiated retry.\n\t * Note: hpsa_ciss_submit does not zero out the command fields like\n\t *       ioaccel submit does.\n\t */\n\tc->retry_pending = true;\n\tif (hpsa_ciss_submit(c->h, c, cmd, dev)) {\n\t\t/*\n\t\t * If we get here, it means dma mapping failed. Try\n\t\t * again via scsi mid layer, which will then get\n\t\t * SCSI_MLQUEUE_HOST_BUSY.\n\t\t *\n\t\t * hpsa_ciss_submit will have already freed c\n\t\t * if it encountered a dma mapping failure.\n\t\t */\n\t\tcmd->result = DID_IMM_RETRY << 16;\n\t\tcmd->scsi_done(cmd);\n\t}\n}\n\n/* Running in struct Scsi_Host->host_lock less mode */\nstatic int hpsa_scsi_queue_command(struct Scsi_Host *sh, struct scsi_cmnd *cmd)\n{\n\tstruct ctlr_info *h;\n\tstruct hpsa_scsi_dev_t *dev;\n\tstruct CommandList *c;\n\tint rc = 0;\n\n\t/* Get the ptr to our adapter structure out of cmd->host. */\n\th = sdev_to_hba(cmd->device);\n\n\tBUG_ON(cmd->request->tag < 0);\n\n\tdev = cmd->device->hostdata;\n\tif (!dev) {\n\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\tcmd->scsi_done(cmd);\n\t\treturn 0;\n\t}\n\n\tif (dev->removed) {\n\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\tcmd->scsi_done(cmd);\n\t\treturn 0;\n\t}\n\n\tif (unlikely(lockup_detected(h))) {\n\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\tcmd->scsi_done(cmd);\n\t\treturn 0;\n\t}\n\n\tif (dev->in_reset)\n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\n\tc = cmd_tagged_alloc(h, cmd);\n\tif (c == NULL)\n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\n\t/*\n\t * This is necessary because the SML doesn't zero out this field during\n\t * error recovery.\n\t */\n\tcmd->result = 0;\n\n\t/*\n\t * Call alternate submit routine for I/O accelerated commands.\n\t * Retries always go down the normal I/O path.\n\t * Note: If cmd->retries is non-zero, then this is a SML\n\t *       initiated retry and not a driver initiated retry.\n\t *       This command has been obtained from cmd_tagged_alloc\n\t *       and is therefore a brand-new command.\n\t */\n\tif (likely(cmd->retries == 0 &&\n\t\t\t!blk_rq_is_passthrough(cmd->request) &&\n\t\t\th->acciopath_status)) {\n\t\t/* Submit with the retry_pending flag unset. */\n\t\trc = hpsa_ioaccel_submit(h, c, cmd, false);\n\t\tif (rc == 0)\n\t\t\treturn 0;\n\t\tif (rc == SCSI_MLQUEUE_HOST_BUSY) {\n\t\t\thpsa_cmd_resolve_and_free(h, c);\n\t\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t\t}\n\t}\n\treturn hpsa_ciss_submit(h, c, cmd, dev);\n}\n\nstatic void hpsa_scan_complete(struct ctlr_info *h)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&h->scan_lock, flags);\n\th->scan_finished = 1;\n\twake_up(&h->scan_wait_queue);\n\tspin_unlock_irqrestore(&h->scan_lock, flags);\n}\n\nstatic void hpsa_scan_start(struct Scsi_Host *sh)\n{\n\tstruct ctlr_info *h = shost_to_hba(sh);\n\tunsigned long flags;\n\n\t/*\n\t * Don't let rescans be initiated on a controller known to be locked\n\t * up.  If the controller locks up *during* a rescan, that thread is\n\t * probably hosed, but at least we can prevent new rescan threads from\n\t * piling up on a locked up controller.\n\t */\n\tif (unlikely(lockup_detected(h)))\n\t\treturn hpsa_scan_complete(h);\n\n\t/*\n\t * If a scan is already waiting to run, no need to add another\n\t */\n\tspin_lock_irqsave(&h->scan_lock, flags);\n\tif (h->scan_waiting) {\n\t\tspin_unlock_irqrestore(&h->scan_lock, flags);\n\t\treturn;\n\t}\n\n\tspin_unlock_irqrestore(&h->scan_lock, flags);\n\n\t/* wait until any scan already in progress is finished. */\n\twhile (1) {\n\t\tspin_lock_irqsave(&h->scan_lock, flags);\n\t\tif (h->scan_finished)\n\t\t\tbreak;\n\t\th->scan_waiting = 1;\n\t\tspin_unlock_irqrestore(&h->scan_lock, flags);\n\t\twait_event(h->scan_wait_queue, h->scan_finished);\n\t\t/* Note: We don't need to worry about a race between this\n\t\t * thread and driver unload because the midlayer will\n\t\t * have incremented the reference count, so unload won't\n\t\t * happen if we're in here.\n\t\t */\n\t}\n\th->scan_finished = 0; /* mark scan as in progress */\n\th->scan_waiting = 0;\n\tspin_unlock_irqrestore(&h->scan_lock, flags);\n\n\tif (unlikely(lockup_detected(h)))\n\t\treturn hpsa_scan_complete(h);\n\n\t/*\n\t * Do the scan after a reset completion\n\t */\n\tspin_lock_irqsave(&h->reset_lock, flags);\n\tif (h->reset_in_progress) {\n\t\th->drv_req_rescan = 1;\n\t\tspin_unlock_irqrestore(&h->reset_lock, flags);\n\t\thpsa_scan_complete(h);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&h->reset_lock, flags);\n\n\thpsa_update_scsi_devices(h);\n\n\thpsa_scan_complete(h);\n}\n\nstatic int hpsa_change_queue_depth(struct scsi_device *sdev, int qdepth)\n{\n\tstruct hpsa_scsi_dev_t *logical_drive = sdev->hostdata;\n\n\tif (!logical_drive)\n\t\treturn -ENODEV;\n\n\tif (qdepth < 1)\n\t\tqdepth = 1;\n\telse if (qdepth > logical_drive->queue_depth)\n\t\tqdepth = logical_drive->queue_depth;\n\n\treturn scsi_change_queue_depth(sdev, qdepth);\n}\n\nstatic int hpsa_scan_finished(struct Scsi_Host *sh,\n\tunsigned long elapsed_time)\n{\n\tstruct ctlr_info *h = shost_to_hba(sh);\n\tunsigned long flags;\n\tint finished;\n\n\tspin_lock_irqsave(&h->scan_lock, flags);\n\tfinished = h->scan_finished;\n\tspin_unlock_irqrestore(&h->scan_lock, flags);\n\treturn finished;\n}\n\nstatic int hpsa_scsi_host_alloc(struct ctlr_info *h)\n{\n\tstruct Scsi_Host *sh;\n\n\tsh = scsi_host_alloc(&hpsa_driver_template, sizeof(h));\n\tif (sh == NULL) {\n\t\tdev_err(&h->pdev->dev, \"scsi_host_alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsh->io_port = 0;\n\tsh->n_io_port = 0;\n\tsh->this_id = -1;\n\tsh->max_channel = 3;\n\tsh->max_cmd_len = MAX_COMMAND_SIZE;\n\tsh->max_lun = HPSA_MAX_LUN;\n\tsh->max_id = HPSA_MAX_LUN;\n\tsh->can_queue = h->nr_cmds - HPSA_NRESERVED_CMDS;\n\tsh->cmd_per_lun = sh->can_queue;\n\tsh->sg_tablesize = h->maxsgentries;\n\tsh->transportt = hpsa_sas_transport_template;\n\tsh->hostdata[0] = (unsigned long) h;\n\tsh->irq = pci_irq_vector(h->pdev, 0);\n\tsh->unique_id = sh->irq;\n\n\th->scsi_host = sh;\n\treturn 0;\n}\n\nstatic int hpsa_scsi_add_host(struct ctlr_info *h)\n{\n\tint rv;\n\n\trv = scsi_add_host(h->scsi_host, &h->pdev->dev);\n\tif (rv) {\n\t\tdev_err(&h->pdev->dev, \"scsi_add_host failed\\n\");\n\t\treturn rv;\n\t}\n\tscsi_scan_host(h->scsi_host);\n\treturn 0;\n}\n\n/*\n * The block layer has already gone to the trouble of picking out a unique,\n * small-integer tag for this request.  We use an offset from that value as\n * an index to select our command block.  (The offset allows us to reserve the\n * low-numbered entries for our own uses.)\n */\nstatic int hpsa_get_cmd_index(struct scsi_cmnd *scmd)\n{\n\tint idx = scmd->request->tag;\n\n\tif (idx < 0)\n\t\treturn idx;\n\n\t/* Offset to leave space for internal cmds. */\n\treturn idx += HPSA_NRESERVED_CMDS;\n}\n\n/*\n * Send a TEST_UNIT_READY command to the specified LUN using the specified\n * reply queue; returns zero if the unit is ready, and non-zero otherwise.\n */\nstatic int hpsa_send_test_unit_ready(struct ctlr_info *h,\n\t\t\t\tstruct CommandList *c, unsigned char lunaddr[],\n\t\t\t\tint reply_queue)\n{\n\tint rc;\n\n\t/* Send the Test Unit Ready, fill_cmd can't fail, no mapping */\n\t(void) fill_cmd(c, TEST_UNIT_READY, h,\n\t\t\tNULL, 0, 0, lunaddr, TYPE_CMD);\n\trc = hpsa_scsi_do_simple_cmd(h, c, reply_queue, NO_TIMEOUT);\n\tif (rc)\n\t\treturn rc;\n\t/* no unmap needed here because no data xfer. */\n\n\t/* Check if the unit is already ready. */\n\tif (c->err_info->CommandStatus == CMD_SUCCESS)\n\t\treturn 0;\n\n\t/*\n\t * The first command sent after reset will receive \"unit attention\" to\n\t * indicate that the LUN has been reset...this is actually what we're\n\t * looking for (but, success is good too).\n\t */\n\tif (c->err_info->CommandStatus == CMD_TARGET_STATUS &&\n\t\tc->err_info->ScsiStatus == SAM_STAT_CHECK_CONDITION &&\n\t\t\t(c->err_info->SenseInfo[2] == NO_SENSE ||\n\t\t\t c->err_info->SenseInfo[2] == UNIT_ATTENTION))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/*\n * Wait for a TEST_UNIT_READY command to complete, retrying as necessary;\n * returns zero when the unit is ready, and non-zero when giving up.\n */\nstatic int hpsa_wait_for_test_unit_ready(struct ctlr_info *h,\n\t\t\t\tstruct CommandList *c,\n\t\t\t\tunsigned char lunaddr[], int reply_queue)\n{\n\tint rc;\n\tint count = 0;\n\tint waittime = 1; /* seconds */\n\n\t/* Send test unit ready until device ready, or give up. */\n\tfor (count = 0; count < HPSA_TUR_RETRY_LIMIT; count++) {\n\n\t\t/*\n\t\t * Wait for a bit.  do this first, because if we send\n\t\t * the TUR right away, the reset will just abort it.\n\t\t */\n\t\tmsleep(1000 * waittime);\n\n\t\trc = hpsa_send_test_unit_ready(h, c, lunaddr, reply_queue);\n\t\tif (!rc)\n\t\t\tbreak;\n\n\t\t/* Increase wait time with each try, up to a point. */\n\t\tif (waittime < HPSA_MAX_WAIT_INTERVAL_SECS)\n\t\t\twaittime *= 2;\n\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t \"waiting %d secs for device to become ready.\\n\",\n\t\t\t waittime);\n\t}\n\n\treturn rc;\n}\n\nstatic int wait_for_device_to_become_ready(struct ctlr_info *h,\n\t\t\t\t\t   unsigned char lunaddr[],\n\t\t\t\t\t   int reply_queue)\n{\n\tint first_queue;\n\tint last_queue;\n\tint rq;\n\tint rc = 0;\n\tstruct CommandList *c;\n\n\tc = cmd_alloc(h);\n\n\t/*\n\t * If no specific reply queue was requested, then send the TUR\n\t * repeatedly, requesting a reply on each reply queue; otherwise execute\n\t * the loop exactly once using only the specified queue.\n\t */\n\tif (reply_queue == DEFAULT_REPLY_QUEUE) {\n\t\tfirst_queue = 0;\n\t\tlast_queue = h->nreply_queues - 1;\n\t} else {\n\t\tfirst_queue = reply_queue;\n\t\tlast_queue = reply_queue;\n\t}\n\n\tfor (rq = first_queue; rq <= last_queue; rq++) {\n\t\trc = hpsa_wait_for_test_unit_ready(h, c, lunaddr, rq);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tdev_warn(&h->pdev->dev, \"giving up on device.\\n\");\n\telse\n\t\tdev_warn(&h->pdev->dev, \"device is ready.\\n\");\n\n\tcmd_free(h, c);\n\treturn rc;\n}\n\n/* Need at least one of these error handlers to keep ../scsi/hosts.c from\n * complaining.  Doing a host- or bus-reset can't do anything good here.\n */\nstatic int hpsa_eh_device_reset_handler(struct scsi_cmnd *scsicmd)\n{\n\tint rc = SUCCESS;\n\tint i;\n\tstruct ctlr_info *h;\n\tstruct hpsa_scsi_dev_t *dev = NULL;\n\tu8 reset_type;\n\tchar msg[48];\n\tunsigned long flags;\n\n\t/* find the controller to which the command to be aborted was sent */\n\th = sdev_to_hba(scsicmd->device);\n\tif (h == NULL) /* paranoia */\n\t\treturn FAILED;\n\n\tspin_lock_irqsave(&h->reset_lock, flags);\n\th->reset_in_progress = 1;\n\tspin_unlock_irqrestore(&h->reset_lock, flags);\n\n\tif (lockup_detected(h)) {\n\t\trc = FAILED;\n\t\tgoto return_reset_status;\n\t}\n\n\tdev = scsicmd->device->hostdata;\n\tif (!dev) {\n\t\tdev_err(&h->pdev->dev, \"%s: device lookup failed\\n\", __func__);\n\t\trc = FAILED;\n\t\tgoto return_reset_status;\n\t}\n\n\tif (dev->devtype == TYPE_ENCLOSURE) {\n\t\trc = SUCCESS;\n\t\tgoto return_reset_status;\n\t}\n\n\t/* if controller locked up, we can guarantee command won't complete */\n\tif (lockup_detected(h)) {\n\t\tsnprintf(msg, sizeof(msg),\n\t\t\t \"cmd %d RESET FAILED, lockup detected\",\n\t\t\t hpsa_get_cmd_index(scsicmd));\n\t\thpsa_show_dev_msg(KERN_WARNING, h, dev, msg);\n\t\trc = FAILED;\n\t\tgoto return_reset_status;\n\t}\n\n\t/* this reset request might be the result of a lockup; check */\n\tif (detect_controller_lockup(h)) {\n\t\tsnprintf(msg, sizeof(msg),\n\t\t\t \"cmd %d RESET FAILED, new lockup detected\",\n\t\t\t hpsa_get_cmd_index(scsicmd));\n\t\thpsa_show_dev_msg(KERN_WARNING, h, dev, msg);\n\t\trc = FAILED;\n\t\tgoto return_reset_status;\n\t}\n\n\t/* Do not attempt on controller */\n\tif (is_hba_lunid(dev->scsi3addr)) {\n\t\trc = SUCCESS;\n\t\tgoto return_reset_status;\n\t}\n\n\tif (is_logical_dev_addr_mode(dev->scsi3addr))\n\t\treset_type = HPSA_DEVICE_RESET_MSG;\n\telse\n\t\treset_type = HPSA_PHYS_TARGET_RESET;\n\n\tsprintf(msg, \"resetting %s\",\n\t\treset_type == HPSA_DEVICE_RESET_MSG ? \"logical \" : \"physical \");\n\thpsa_show_dev_msg(KERN_WARNING, h, dev, msg);\n\n\t/*\n\t * wait to see if any commands will complete before sending reset\n\t */\n\tdev->in_reset = true; /* block any new cmds from OS for this device */\n\tfor (i = 0; i < 10; i++) {\n\t\tif (atomic_read(&dev->commands_outstanding) > 0)\n\t\t\tmsleep(1000);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\t/* send a reset to the SCSI LUN which the command was sent to */\n\trc = hpsa_do_reset(h, dev, reset_type, DEFAULT_REPLY_QUEUE);\n\tif (rc == 0)\n\t\trc = SUCCESS;\n\telse\n\t\trc = FAILED;\n\n\tsprintf(msg, \"reset %s %s\",\n\t\treset_type == HPSA_DEVICE_RESET_MSG ? \"logical \" : \"physical \",\n\t\trc == SUCCESS ? \"completed successfully\" : \"failed\");\n\thpsa_show_dev_msg(KERN_WARNING, h, dev, msg);\n\nreturn_reset_status:\n\tspin_lock_irqsave(&h->reset_lock, flags);\n\th->reset_in_progress = 0;\n\tif (dev)\n\t\tdev->in_reset = false;\n\tspin_unlock_irqrestore(&h->reset_lock, flags);\n\treturn rc;\n}\n\n/*\n * For operations with an associated SCSI command, a command block is allocated\n * at init, and managed by cmd_tagged_alloc() and cmd_tagged_free() using the\n * block request tag as an index into a table of entries.  cmd_tagged_free() is\n * the complement, although cmd_free() may be called instead.\n * This function is only called for new requests from queue_command.\n */\nstatic struct CommandList *cmd_tagged_alloc(struct ctlr_info *h,\n\t\t\t\t\t    struct scsi_cmnd *scmd)\n{\n\tint idx = hpsa_get_cmd_index(scmd);\n\tstruct CommandList *c = h->cmd_pool + idx;\n\n\tif (idx < HPSA_NRESERVED_CMDS || idx >= h->nr_cmds) {\n\t\tdev_err(&h->pdev->dev, \"Bad block tag: %d not in [%d..%d]\\n\",\n\t\t\tidx, HPSA_NRESERVED_CMDS, h->nr_cmds - 1);\n\t\t/* The index value comes from the block layer, so if it's out of\n\t\t * bounds, it's probably not our bug.\n\t\t */\n\t\tBUG();\n\t}\n\n\tif (unlikely(!hpsa_is_cmd_idle(c))) {\n\t\t/*\n\t\t * We expect that the SCSI layer will hand us a unique tag\n\t\t * value.  Thus, there should never be a collision here between\n\t\t * two requests...because if the selected command isn't idle\n\t\t * then someone is going to be very disappointed.\n\t\t */\n\t\tif (idx != h->last_collision_tag) { /* Print once per tag */\n\t\t\tdev_warn(&h->pdev->dev,\n\t\t\t\t\"%s: tag collision (tag=%d)\\n\", __func__, idx);\n\t\t\tif (scmd)\n\t\t\t\tscsi_print_command(scmd);\n\t\t\th->last_collision_tag = idx;\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tatomic_inc(&c->refcount);\n\thpsa_cmd_partial_init(h, idx, c);\n\n\t/*\n\t * This is a new command obtained from queue_command so\n\t * there have not been any driver initiated retry attempts.\n\t */\n\tc->retry_pending = false;\n\n\treturn c;\n}\n\nstatic void cmd_tagged_free(struct ctlr_info *h, struct CommandList *c)\n{\n\t/*\n\t * Release our reference to the block.  We don't need to do anything\n\t * else to free it, because it is accessed by index.\n\t */\n\t(void)atomic_dec(&c->refcount);\n}\n\n/*\n * For operations that cannot sleep, a command block is allocated at init,\n * and managed by cmd_alloc() and cmd_free() using a simple bitmap to track\n * which ones are free or in use.  Lock must be held when calling this.\n * cmd_free() is the complement.\n * This function never gives up and returns NULL.  If it hangs,\n * another thread must call cmd_free() to free some tags.\n */\n\nstatic struct CommandList *cmd_alloc(struct ctlr_info *h)\n{\n\tstruct CommandList *c;\n\tint refcount, i;\n\tint offset = 0;\n\n\t/*\n\t * There is some *extremely* small but non-zero chance that that\n\t * multiple threads could get in here, and one thread could\n\t * be scanning through the list of bits looking for a free\n\t * one, but the free ones are always behind him, and other\n\t * threads sneak in behind him and eat them before he can\n\t * get to them, so that while there is always a free one, a\n\t * very unlucky thread might be starved anyway, never able to\n\t * beat the other threads.  In reality, this happens so\n\t * infrequently as to be indistinguishable from never.\n\t *\n\t * Note that we start allocating commands before the SCSI host structure\n\t * is initialized.  Since the search starts at bit zero, this\n\t * all works, since we have at least one command structure available;\n\t * however, it means that the structures with the low indexes have to be\n\t * reserved for driver-initiated requests, while requests from the block\n\t * layer will use the higher indexes.\n\t */\n\n\tfor (;;) {\n\t\ti = find_next_zero_bit(h->cmd_pool_bits,\n\t\t\t\t\tHPSA_NRESERVED_CMDS,\n\t\t\t\t\toffset);\n\t\tif (unlikely(i >= HPSA_NRESERVED_CMDS)) {\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tc = h->cmd_pool + i;\n\t\trefcount = atomic_inc_return(&c->refcount);\n\t\tif (unlikely(refcount > 1)) {\n\t\t\tcmd_free(h, c); /* already in use */\n\t\t\toffset = (i + 1) % HPSA_NRESERVED_CMDS;\n\t\t\tcontinue;\n\t\t}\n\t\tset_bit(i & (BITS_PER_LONG - 1),\n\t\t\th->cmd_pool_bits + (i / BITS_PER_LONG));\n\t\tbreak; /* it's ours now. */\n\t}\n\thpsa_cmd_partial_init(h, i, c);\n\tc->device = NULL;\n\n\t/*\n\t * cmd_alloc is for \"internal\" commands and they are never\n\t * retried.\n\t */\n\tc->retry_pending = false;\n\n\treturn c;\n}\n\n/*\n * This is the complementary operation to cmd_alloc().  Note, however, in some\n * corner cases it may also be used to free blocks allocated by\n * cmd_tagged_alloc() in which case the ref-count decrement does the trick and\n * the clear-bit is harmless.\n */\nstatic void cmd_free(struct ctlr_info *h, struct CommandList *c)\n{\n\tif (atomic_dec_and_test(&c->refcount)) {\n\t\tint i;\n\n\t\ti = c - h->cmd_pool;\n\t\tclear_bit(i & (BITS_PER_LONG - 1),\n\t\t\t  h->cmd_pool_bits + (i / BITS_PER_LONG));\n\t}\n}\n\n#ifdef CONFIG_COMPAT\n\nstatic int hpsa_ioctl32_passthru(struct scsi_device *dev, unsigned int cmd,\n\tvoid __user *arg)\n{\n\tstruct ctlr_info *h = sdev_to_hba(dev);\n\tIOCTL32_Command_struct __user *arg32 = arg;\n\tIOCTL_Command_struct arg64;\n\tint err;\n\tu32 cp;\n\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\tmemset(&arg64, 0, sizeof(arg64));\n\tif (copy_from_user(&arg64, arg32, offsetof(IOCTL_Command_struct, buf)))\n\t\treturn -EFAULT;\n\tif (get_user(cp, &arg32->buf))\n\t\treturn -EFAULT;\n\targ64.buf = compat_ptr(cp);\n\n\tif (atomic_dec_if_positive(&h->passthru_cmds_avail) < 0)\n\t\treturn -EAGAIN;\n\terr = hpsa_passthru_ioctl(h, &arg64);\n\tatomic_inc(&h->passthru_cmds_avail);\n\tif (err)\n\t\treturn err;\n\tif (copy_to_user(&arg32->error_info, &arg64.error_info,\n\t\t\t sizeof(arg32->error_info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int hpsa_ioctl32_big_passthru(struct scsi_device *dev,\n\tunsigned int cmd, void __user *arg)\n{\n\tstruct ctlr_info *h = sdev_to_hba(dev);\n\tBIG_IOCTL32_Command_struct __user *arg32 = arg;\n\tBIG_IOCTL_Command_struct arg64;\n\tint err;\n\tu32 cp;\n\n\tif (!arg)\n\t\treturn -EINVAL;\n\tmemset(&arg64, 0, sizeof(arg64));\n\tif (copy_from_user(&arg64, arg32,\n\t\t\t   offsetof(BIG_IOCTL32_Command_struct, buf)))\n\t\treturn -EFAULT;\n\tif (get_user(cp, &arg32->buf))\n\t\treturn -EFAULT;\n\targ64.buf = compat_ptr(cp);\n\n\tif (atomic_dec_if_positive(&h->passthru_cmds_avail) < 0)\n\t\treturn -EAGAIN;\n\terr = hpsa_big_passthru_ioctl(h, &arg64);\n\tatomic_inc(&h->passthru_cmds_avail);\n\tif (err)\n\t\treturn err;\n\tif (copy_to_user(&arg32->error_info, &arg64.error_info,\n\t\t\t sizeof(arg32->error_info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int hpsa_compat_ioctl(struct scsi_device *dev, unsigned int cmd,\n\t\t\t     void __user *arg)\n{\n\tswitch (cmd) {\n\tcase CCISS_GETPCIINFO:\n\tcase CCISS_GETINTINFO:\n\tcase CCISS_SETINTINFO:\n\tcase CCISS_GETNODENAME:\n\tcase CCISS_SETNODENAME:\n\tcase CCISS_GETHEARTBEAT:\n\tcase CCISS_GETBUSTYPES:\n\tcase CCISS_GETFIRMVER:\n\tcase CCISS_GETDRIVVER:\n\tcase CCISS_REVALIDVOLS:\n\tcase CCISS_DEREGDISK:\n\tcase CCISS_REGNEWDISK:\n\tcase CCISS_REGNEWD:\n\tcase CCISS_RESCANDISK:\n\tcase CCISS_GETLUNINFO:\n\t\treturn hpsa_ioctl(dev, cmd, arg);\n\n\tcase CCISS_PASSTHRU32:\n\t\treturn hpsa_ioctl32_passthru(dev, cmd, arg);\n\tcase CCISS_BIG_PASSTHRU32:\n\t\treturn hpsa_ioctl32_big_passthru(dev, cmd, arg);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n#endif\n\nstatic int hpsa_getpciinfo_ioctl(struct ctlr_info *h, void __user *argp)\n{\n\tstruct hpsa_pci_info pciinfo;\n\n\tif (!argp)\n\t\treturn -EINVAL;\n\tpciinfo.domain = pci_domain_nr(h->pdev->bus);\n\tpciinfo.bus = h->pdev->bus->number;\n\tpciinfo.dev_fn = h->pdev->devfn;\n\tpciinfo.board_id = h->board_id;\n\tif (copy_to_user(argp, &pciinfo, sizeof(pciinfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int hpsa_getdrivver_ioctl(struct ctlr_info *h, void __user *argp)\n{\n\tDriverVer_type DriverVer;\n\tunsigned char vmaj, vmin, vsubmin;\n\tint rc;\n\n\trc = sscanf(HPSA_DRIVER_VERSION, \"%hhu.%hhu.%hhu\",\n\t\t&vmaj, &vmin, &vsubmin);\n\tif (rc != 3) {\n\t\tdev_info(&h->pdev->dev, \"driver version string '%s' \"\n\t\t\t\"unrecognized.\", HPSA_DRIVER_VERSION);\n\t\tvmaj = 0;\n\t\tvmin = 0;\n\t\tvsubmin = 0;\n\t}\n\tDriverVer = (vmaj << 16) | (vmin << 8) | vsubmin;\n\tif (!argp)\n\t\treturn -EINVAL;\n\tif (copy_to_user(argp, &DriverVer, sizeof(DriverVer_type)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int hpsa_passthru_ioctl(struct ctlr_info *h,\n\t\t\t       IOCTL_Command_struct *iocommand)\n{\n\tstruct CommandList *c;\n\tchar *buff = NULL;\n\tu64 temp64;\n\tint rc = 0;\n\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\tif ((iocommand->buf_size < 1) &&\n\t    (iocommand->Request.Type.Direction != XFER_NONE)) {\n\t\treturn -EINVAL;\n\t}\n\tif (iocommand->buf_size > 0) {\n\t\tbuff = kmalloc(iocommand->buf_size, GFP_KERNEL);\n\t\tif (buff == NULL)\n\t\t\treturn -ENOMEM;\n\t\tif (iocommand->Request.Type.Direction & XFER_WRITE) {\n\t\t\t/* Copy the data into the buffer we created */\n\t\t\tif (copy_from_user(buff, iocommand->buf,\n\t\t\t\tiocommand->buf_size)) {\n\t\t\t\trc = -EFAULT;\n\t\t\t\tgoto out_kfree;\n\t\t\t}\n\t\t} else {\n\t\t\tmemset(buff, 0, iocommand->buf_size);\n\t\t}\n\t}\n\tc = cmd_alloc(h);\n\n\t/* Fill in the command type */\n\tc->cmd_type = CMD_IOCTL_PEND;\n\tc->scsi_cmd = SCSI_CMD_BUSY;\n\t/* Fill in Command Header */\n\tc->Header.ReplyQueue = 0; /* unused in simple mode */\n\tif (iocommand->buf_size > 0) {\t/* buffer to fill */\n\t\tc->Header.SGList = 1;\n\t\tc->Header.SGTotal = cpu_to_le16(1);\n\t} else\t{ /* no buffers to fill */\n\t\tc->Header.SGList = 0;\n\t\tc->Header.SGTotal = cpu_to_le16(0);\n\t}\n\tmemcpy(&c->Header.LUN, &iocommand->LUN_info, sizeof(c->Header.LUN));\n\n\t/* Fill in Request block */\n\tmemcpy(&c->Request, &iocommand->Request,\n\t\tsizeof(c->Request));\n\n\t/* Fill in the scatter gather information */\n\tif (iocommand->buf_size > 0) {\n\t\ttemp64 = dma_map_single(&h->pdev->dev, buff,\n\t\t\tiocommand->buf_size, DMA_BIDIRECTIONAL);\n\t\tif (dma_mapping_error(&h->pdev->dev, (dma_addr_t) temp64)) {\n\t\t\tc->SG[0].Addr = cpu_to_le64(0);\n\t\t\tc->SG[0].Len = cpu_to_le32(0);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tc->SG[0].Addr = cpu_to_le64(temp64);\n\t\tc->SG[0].Len = cpu_to_le32(iocommand->buf_size);\n\t\tc->SG[0].Ext = cpu_to_le32(HPSA_SG_LAST); /* not chaining */\n\t}\n\trc = hpsa_scsi_do_simple_cmd(h, c, DEFAULT_REPLY_QUEUE,\n\t\t\t\t\tNO_TIMEOUT);\n\tif (iocommand->buf_size > 0)\n\t\thpsa_pci_unmap(h->pdev, c, 1, DMA_BIDIRECTIONAL);\n\tcheck_ioctl_unit_attention(h, c);\n\tif (rc) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t/* Copy the error information out */\n\tmemcpy(&iocommand->error_info, c->err_info,\n\t\tsizeof(iocommand->error_info));\n\tif ((iocommand->Request.Type.Direction & XFER_READ) &&\n\t\tiocommand->buf_size > 0) {\n\t\t/* Copy the data out of the buffer we created */\n\t\tif (copy_to_user(iocommand->buf, buff, iocommand->buf_size)) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tcmd_free(h, c);\nout_kfree:\n\tkfree(buff);\n\treturn rc;\n}\n\nstatic int hpsa_big_passthru_ioctl(struct ctlr_info *h,\n\t\t\t\t   BIG_IOCTL_Command_struct *ioc)\n{\n\tstruct CommandList *c;\n\tunsigned char **buff = NULL;\n\tint *buff_size = NULL;\n\tu64 temp64;\n\tBYTE sg_used = 0;\n\tint status = 0;\n\tu32 left;\n\tu32 sz;\n\tBYTE __user *data_ptr;\n\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\n\tif ((ioc->buf_size < 1) &&\n\t    (ioc->Request.Type.Direction != XFER_NONE))\n\t\treturn -EINVAL;\n\t/* Check kmalloc limits  using all SGs */\n\tif (ioc->malloc_size > MAX_KMALLOC_SIZE)\n\t\treturn -EINVAL;\n\tif (ioc->buf_size > ioc->malloc_size * SG_ENTRIES_IN_CMD)\n\t\treturn -EINVAL;\n\tbuff = kcalloc(SG_ENTRIES_IN_CMD, sizeof(char *), GFP_KERNEL);\n\tif (!buff) {\n\t\tstatus = -ENOMEM;\n\t\tgoto cleanup1;\n\t}\n\tbuff_size = kmalloc_array(SG_ENTRIES_IN_CMD, sizeof(int), GFP_KERNEL);\n\tif (!buff_size) {\n\t\tstatus = -ENOMEM;\n\t\tgoto cleanup1;\n\t}\n\tleft = ioc->buf_size;\n\tdata_ptr = ioc->buf;\n\twhile (left) {\n\t\tsz = (left > ioc->malloc_size) ? ioc->malloc_size : left;\n\t\tbuff_size[sg_used] = sz;\n\t\tbuff[sg_used] = kmalloc(sz, GFP_KERNEL);\n\t\tif (buff[sg_used] == NULL) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto cleanup1;\n\t\t}\n\t\tif (ioc->Request.Type.Direction & XFER_WRITE) {\n\t\t\tif (copy_from_user(buff[sg_used], data_ptr, sz)) {\n\t\t\t\tstatus = -EFAULT;\n\t\t\t\tgoto cleanup1;\n\t\t\t}\n\t\t} else\n\t\t\tmemset(buff[sg_used], 0, sz);\n\t\tleft -= sz;\n\t\tdata_ptr += sz;\n\t\tsg_used++;\n\t}\n\tc = cmd_alloc(h);\n\n\tc->cmd_type = CMD_IOCTL_PEND;\n\tc->scsi_cmd = SCSI_CMD_BUSY;\n\tc->Header.ReplyQueue = 0;\n\tc->Header.SGList = (u8) sg_used;\n\tc->Header.SGTotal = cpu_to_le16(sg_used);\n\tmemcpy(&c->Header.LUN, &ioc->LUN_info, sizeof(c->Header.LUN));\n\tmemcpy(&c->Request, &ioc->Request, sizeof(c->Request));\n\tif (ioc->buf_size > 0) {\n\t\tint i;\n\t\tfor (i = 0; i < sg_used; i++) {\n\t\t\ttemp64 = dma_map_single(&h->pdev->dev, buff[i],\n\t\t\t\t    buff_size[i], DMA_BIDIRECTIONAL);\n\t\t\tif (dma_mapping_error(&h->pdev->dev,\n\t\t\t\t\t\t\t(dma_addr_t) temp64)) {\n\t\t\t\tc->SG[i].Addr = cpu_to_le64(0);\n\t\t\t\tc->SG[i].Len = cpu_to_le32(0);\n\t\t\t\thpsa_pci_unmap(h->pdev, c, i,\n\t\t\t\t\tDMA_BIDIRECTIONAL);\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tgoto cleanup0;\n\t\t\t}\n\t\t\tc->SG[i].Addr = cpu_to_le64(temp64);\n\t\t\tc->SG[i].Len = cpu_to_le32(buff_size[i]);\n\t\t\tc->SG[i].Ext = cpu_to_le32(0);\n\t\t}\n\t\tc->SG[--i].Ext = cpu_to_le32(HPSA_SG_LAST);\n\t}\n\tstatus = hpsa_scsi_do_simple_cmd(h, c, DEFAULT_REPLY_QUEUE,\n\t\t\t\t\t\tNO_TIMEOUT);\n\tif (sg_used)\n\t\thpsa_pci_unmap(h->pdev, c, sg_used, DMA_BIDIRECTIONAL);\n\tcheck_ioctl_unit_attention(h, c);\n\tif (status) {\n\t\tstatus = -EIO;\n\t\tgoto cleanup0;\n\t}\n\n\t/* Copy the error information out */\n\tmemcpy(&ioc->error_info, c->err_info, sizeof(ioc->error_info));\n\tif ((ioc->Request.Type.Direction & XFER_READ) && ioc->buf_size > 0) {\n\t\tint i;\n\n\t\t/* Copy the data out of the buffer we created */\n\t\tBYTE __user *ptr = ioc->buf;\n\t\tfor (i = 0; i < sg_used; i++) {\n\t\t\tif (copy_to_user(ptr, buff[i], buff_size[i])) {\n\t\t\t\tstatus = -EFAULT;\n\t\t\t\tgoto cleanup0;\n\t\t\t}\n\t\t\tptr += buff_size[i];\n\t\t}\n\t}\n\tstatus = 0;\ncleanup0:\n\tcmd_free(h, c);\ncleanup1:\n\tif (buff) {\n\t\tint i;\n\n\t\tfor (i = 0; i < sg_used; i++)\n\t\t\tkfree(buff[i]);\n\t\tkfree(buff);\n\t}\n\tkfree(buff_size);\n\treturn status;\n}\n\nstatic void check_ioctl_unit_attention(struct ctlr_info *h,\n\tstruct CommandList *c)\n{\n\tif (c->err_info->CommandStatus == CMD_TARGET_STATUS &&\n\t\t\tc->err_info->ScsiStatus != SAM_STAT_CHECK_CONDITION)\n\t\t(void) check_for_unit_attention(h, c);\n}\n\n/*\n * ioctl\n */\nstatic int hpsa_ioctl(struct scsi_device *dev, unsigned int cmd,\n\t\t      void __user *argp)\n{\n\tstruct ctlr_info *h = sdev_to_hba(dev);\n\tint rc;\n\n\tswitch (cmd) {\n\tcase CCISS_DEREGDISK:\n\tcase CCISS_REGNEWDISK:\n\tcase CCISS_REGNEWD:\n\t\thpsa_scan_start(h->scsi_host);\n\t\treturn 0;\n\tcase CCISS_GETPCIINFO:\n\t\treturn hpsa_getpciinfo_ioctl(h, argp);\n\tcase CCISS_GETDRIVVER:\n\t\treturn hpsa_getdrivver_ioctl(h, argp);\n\tcase CCISS_PASSTHRU: {\n\t\tIOCTL_Command_struct iocommand;\n\n\t\tif (!argp)\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&iocommand, argp, sizeof(iocommand)))\n\t\t\treturn -EFAULT;\n\t\tif (atomic_dec_if_positive(&h->passthru_cmds_avail) < 0)\n\t\t\treturn -EAGAIN;\n\t\trc = hpsa_passthru_ioctl(h, &iocommand);\n\t\tatomic_inc(&h->passthru_cmds_avail);\n\t\tif (!rc && copy_to_user(argp, &iocommand, sizeof(iocommand)))\n\t\t\trc = -EFAULT;\n\t\treturn rc;\n\t}\n\tcase CCISS_BIG_PASSTHRU: {\n\t\tBIG_IOCTL_Command_struct ioc;\n\t\tif (!argp)\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&ioc, argp, sizeof(ioc)))\n\t\t\treturn -EFAULT;\n\t\tif (atomic_dec_if_positive(&h->passthru_cmds_avail) < 0)\n\t\t\treturn -EAGAIN;\n\t\trc = hpsa_big_passthru_ioctl(h, &ioc);\n\t\tatomic_inc(&h->passthru_cmds_avail);\n\t\tif (!rc && copy_to_user(argp, &ioc, sizeof(ioc)))\n\t\t\trc = -EFAULT;\n\t\treturn rc;\n\t}\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic void hpsa_send_host_reset(struct ctlr_info *h, u8 reset_type)\n{\n\tstruct CommandList *c;\n\n\tc = cmd_alloc(h);\n\n\t/* fill_cmd can't fail here, no data buffer to map */\n\t(void) fill_cmd(c, HPSA_DEVICE_RESET_MSG, h, NULL, 0, 0,\n\t\tRAID_CTLR_LUNID, TYPE_MSG);\n\tc->Request.CDB[1] = reset_type; /* fill_cmd defaults to target reset */\n\tc->waiting = NULL;\n\tenqueue_cmd_and_start_io(h, c);\n\t/* Don't wait for completion, the reset won't complete.  Don't free\n\t * the command either.  This is the last command we will send before\n\t * re-initializing everything, so it doesn't matter and won't leak.\n\t */\n\treturn;\n}\n\nstatic int fill_cmd(struct CommandList *c, u8 cmd, struct ctlr_info *h,\n\tvoid *buff, size_t size, u16 page_code, unsigned char *scsi3addr,\n\tint cmd_type)\n{\n\tenum dma_data_direction dir = DMA_NONE;\n\n\tc->cmd_type = CMD_IOCTL_PEND;\n\tc->scsi_cmd = SCSI_CMD_BUSY;\n\tc->Header.ReplyQueue = 0;\n\tif (buff != NULL && size > 0) {\n\t\tc->Header.SGList = 1;\n\t\tc->Header.SGTotal = cpu_to_le16(1);\n\t} else {\n\t\tc->Header.SGList = 0;\n\t\tc->Header.SGTotal = cpu_to_le16(0);\n\t}\n\tmemcpy(c->Header.LUN.LunAddrBytes, scsi3addr, 8);\n\n\tif (cmd_type == TYPE_CMD) {\n\t\tswitch (cmd) {\n\t\tcase HPSA_INQUIRY:\n\t\t\t/* are we trying to read a vital product page */\n\t\t\tif (page_code & VPD_PAGE) {\n\t\t\t\tc->Request.CDB[1] = 0x01;\n\t\t\t\tc->Request.CDB[2] = (page_code & 0xff);\n\t\t\t}\n\t\t\tc->Request.CDBLen = 6;\n\t\t\tc->Request.type_attr_dir =\n\t\t\t\tTYPE_ATTR_DIR(cmd_type, ATTR_SIMPLE, XFER_READ);\n\t\t\tc->Request.Timeout = 0;\n\t\t\tc->Request.CDB[0] = HPSA_INQUIRY;\n\t\t\tc->Request.CDB[4] = size & 0xFF;\n\t\t\tbreak;\n\t\tcase RECEIVE_DIAGNOSTIC:\n\t\t\tc->Request.CDBLen = 6;\n\t\t\tc->Request.type_attr_dir =\n\t\t\t\tTYPE_ATTR_DIR(cmd_type, ATTR_SIMPLE, XFER_READ);\n\t\t\tc->Request.Timeout = 0;\n\t\t\tc->Request.CDB[0] = cmd;\n\t\t\tc->Request.CDB[1] = 1;\n\t\t\tc->Request.CDB[2] = 1;\n\t\t\tc->Request.CDB[3] = (size >> 8) & 0xFF;\n\t\t\tc->Request.CDB[4] = size & 0xFF;\n\t\t\tbreak;\n\t\tcase HPSA_REPORT_LOG:\n\t\tcase HPSA_REPORT_PHYS:\n\t\t\t/* Talking to controller so It's a physical command\n\t\t\t   mode = 00 target = 0.  Nothing to write.\n\t\t\t */\n\t\t\tc->Request.CDBLen = 12;\n\t\t\tc->Request.type_attr_dir =\n\t\t\t\tTYPE_ATTR_DIR(cmd_type, ATTR_SIMPLE, XFER_READ);\n\t\t\tc->Request.Timeout = 0;\n\t\t\tc->Request.CDB[0] = cmd;\n\t\t\tc->Request.CDB[6] = (size >> 24) & 0xFF; /* MSB */\n\t\t\tc->Request.CDB[7] = (size >> 16) & 0xFF;\n\t\t\tc->Request.CDB[8] = (size >> 8) & 0xFF;\n\t\t\tc->Request.CDB[9] = size & 0xFF;\n\t\t\tbreak;\n\t\tcase BMIC_SENSE_DIAG_OPTIONS:\n\t\t\tc->Request.CDBLen = 16;\n\t\t\tc->Request.type_attr_dir =\n\t\t\t\tTYPE_ATTR_DIR(cmd_type, ATTR_SIMPLE, XFER_READ);\n\t\t\tc->Request.Timeout = 0;\n\t\t\t/* Spec says this should be BMIC_WRITE */\n\t\t\tc->Request.CDB[0] = BMIC_READ;\n\t\t\tc->Request.CDB[6] = BMIC_SENSE_DIAG_OPTIONS;\n\t\t\tbreak;\n\t\tcase BMIC_SET_DIAG_OPTIONS:\n\t\t\tc->Request.CDBLen = 16;\n\t\t\tc->Request.type_attr_dir =\n\t\t\t\t\tTYPE_ATTR_DIR(cmd_type,\n\t\t\t\t\t\tATTR_SIMPLE, XFER_WRITE);\n\t\t\tc->Request.Timeout = 0;\n\t\t\tc->Request.CDB[0] = BMIC_WRITE;\n\t\t\tc->Request.CDB[6] = BMIC_SET_DIAG_OPTIONS;\n\t\t\tbreak;\n\t\tcase HPSA_CACHE_FLUSH:\n\t\t\tc->Request.CDBLen = 12;\n\t\t\tc->Request.type_attr_dir =\n\t\t\t\t\tTYPE_ATTR_DIR(cmd_type,\n\t\t\t\t\t\tATTR_SIMPLE, XFER_WRITE);\n\t\t\tc->Request.Timeout = 0;\n\t\t\tc->Request.CDB[0] = BMIC_WRITE;\n\t\t\tc->Request.CDB[6] = BMIC_CACHE_FLUSH;\n\t\t\tc->Request.CDB[7] = (size >> 8) & 0xFF;\n\t\t\tc->Request.CDB[8] = size & 0xFF;\n\t\t\tbreak;\n\t\tcase TEST_UNIT_READY:\n\t\t\tc->Request.CDBLen = 6;\n\t\t\tc->Request.type_attr_dir =\n\t\t\t\tTYPE_ATTR_DIR(cmd_type, ATTR_SIMPLE, XFER_NONE);\n\t\t\tc->Request.Timeout = 0;\n\t\t\tbreak;\n\t\tcase HPSA_GET_RAID_MAP:\n\t\t\tc->Request.CDBLen = 12;\n\t\t\tc->Request.type_attr_dir =\n\t\t\t\tTYPE_ATTR_DIR(cmd_type, ATTR_SIMPLE, XFER_READ);\n\t\t\tc->Request.Timeout = 0;\n\t\t\tc->Request.CDB[0] = HPSA_CISS_READ;\n\t\t\tc->Request.CDB[1] = cmd;\n\t\t\tc->Request.CDB[6] = (size >> 24) & 0xFF; /* MSB */\n\t\t\tc->Request.CDB[7] = (size >> 16) & 0xFF;\n\t\t\tc->Request.CDB[8] = (size >> 8) & 0xFF;\n\t\t\tc->Request.CDB[9] = size & 0xFF;\n\t\t\tbreak;\n\t\tcase BMIC_SENSE_CONTROLLER_PARAMETERS:\n\t\t\tc->Request.CDBLen = 10;\n\t\t\tc->Request.type_attr_dir =\n\t\t\t\tTYPE_ATTR_DIR(cmd_type, ATTR_SIMPLE, XFER_READ);\n\t\t\tc->Request.Timeout = 0;\n\t\t\tc->Request.CDB[0] = BMIC_READ;\n\t\t\tc->Request.CDB[6] = BMIC_SENSE_CONTROLLER_PARAMETERS;\n\t\t\tc->Request.CDB[7] = (size >> 16) & 0xFF;\n\t\t\tc->Request.CDB[8] = (size >> 8) & 0xFF;\n\t\t\tbreak;\n\t\tcase BMIC_IDENTIFY_PHYSICAL_DEVICE:\n\t\t\tc->Request.CDBLen = 10;\n\t\t\tc->Request.type_attr_dir =\n\t\t\t\tTYPE_ATTR_DIR(cmd_type, ATTR_SIMPLE, XFER_READ);\n\t\t\tc->Request.Timeout = 0;\n\t\t\tc->Request.CDB[0] = BMIC_READ;\n\t\t\tc->Request.CDB[6] = BMIC_IDENTIFY_PHYSICAL_DEVICE;\n\t\t\tc->Request.CDB[7] = (size >> 16) & 0xFF;\n\t\t\tc->Request.CDB[8] = (size >> 8) & 0XFF;\n\t\t\tbreak;\n\t\tcase BMIC_SENSE_SUBSYSTEM_INFORMATION:\n\t\t\tc->Request.CDBLen = 10;\n\t\t\tc->Request.type_attr_dir =\n\t\t\t\tTYPE_ATTR_DIR(cmd_type, ATTR_SIMPLE, XFER_READ);\n\t\t\tc->Request.Timeout = 0;\n\t\t\tc->Request.CDB[0] = BMIC_READ;\n\t\t\tc->Request.CDB[6] = BMIC_SENSE_SUBSYSTEM_INFORMATION;\n\t\t\tc->Request.CDB[7] = (size >> 16) & 0xFF;\n\t\t\tc->Request.CDB[8] = (size >> 8) & 0XFF;\n\t\t\tbreak;\n\t\tcase BMIC_SENSE_STORAGE_BOX_PARAMS:\n\t\t\tc->Request.CDBLen = 10;\n\t\t\tc->Request.type_attr_dir =\n\t\t\t\tTYPE_ATTR_DIR(cmd_type, ATTR_SIMPLE, XFER_READ);\n\t\t\tc->Request.Timeout = 0;\n\t\t\tc->Request.CDB[0] = BMIC_READ;\n\t\t\tc->Request.CDB[6] = BMIC_SENSE_STORAGE_BOX_PARAMS;\n\t\t\tc->Request.CDB[7] = (size >> 16) & 0xFF;\n\t\t\tc->Request.CDB[8] = (size >> 8) & 0XFF;\n\t\t\tbreak;\n\t\tcase BMIC_IDENTIFY_CONTROLLER:\n\t\t\tc->Request.CDBLen = 10;\n\t\t\tc->Request.type_attr_dir =\n\t\t\t\tTYPE_ATTR_DIR(cmd_type, ATTR_SIMPLE, XFER_READ);\n\t\t\tc->Request.Timeout = 0;\n\t\t\tc->Request.CDB[0] = BMIC_READ;\n\t\t\tc->Request.CDB[1] = 0;\n\t\t\tc->Request.CDB[2] = 0;\n\t\t\tc->Request.CDB[3] = 0;\n\t\t\tc->Request.CDB[4] = 0;\n\t\t\tc->Request.CDB[5] = 0;\n\t\t\tc->Request.CDB[6] = BMIC_IDENTIFY_CONTROLLER;\n\t\t\tc->Request.CDB[7] = (size >> 16) & 0xFF;\n\t\t\tc->Request.CDB[8] = (size >> 8) & 0XFF;\n\t\t\tc->Request.CDB[9] = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&h->pdev->dev, \"unknown command 0x%c\\n\", cmd);\n\t\t\tBUG();\n\t\t}\n\t} else if (cmd_type == TYPE_MSG) {\n\t\tswitch (cmd) {\n\n\t\tcase  HPSA_PHYS_TARGET_RESET:\n\t\t\tc->Request.CDBLen = 16;\n\t\t\tc->Request.type_attr_dir =\n\t\t\t\tTYPE_ATTR_DIR(cmd_type, ATTR_SIMPLE, XFER_NONE);\n\t\t\tc->Request.Timeout = 0; /* Don't time out */\n\t\t\tmemset(&c->Request.CDB[0], 0, sizeof(c->Request.CDB));\n\t\t\tc->Request.CDB[0] = HPSA_RESET;\n\t\t\tc->Request.CDB[1] = HPSA_TARGET_RESET_TYPE;\n\t\t\t/* Physical target reset needs no control bytes 4-7*/\n\t\t\tc->Request.CDB[4] = 0x00;\n\t\t\tc->Request.CDB[5] = 0x00;\n\t\t\tc->Request.CDB[6] = 0x00;\n\t\t\tc->Request.CDB[7] = 0x00;\n\t\t\tbreak;\n\t\tcase  HPSA_DEVICE_RESET_MSG:\n\t\t\tc->Request.CDBLen = 16;\n\t\t\tc->Request.type_attr_dir =\n\t\t\t\tTYPE_ATTR_DIR(cmd_type, ATTR_SIMPLE, XFER_NONE);\n\t\t\tc->Request.Timeout = 0; /* Don't time out */\n\t\t\tmemset(&c->Request.CDB[0], 0, sizeof(c->Request.CDB));\n\t\t\tc->Request.CDB[0] =  cmd;\n\t\t\tc->Request.CDB[1] = HPSA_RESET_TYPE_LUN;\n\t\t\t/* If bytes 4-7 are zero, it means reset the */\n\t\t\t/* LunID device */\n\t\t\tc->Request.CDB[4] = 0x00;\n\t\t\tc->Request.CDB[5] = 0x00;\n\t\t\tc->Request.CDB[6] = 0x00;\n\t\t\tc->Request.CDB[7] = 0x00;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&h->pdev->dev, \"unknown message type %d\\n\",\n\t\t\t\tcmd);\n\t\t\tBUG();\n\t\t}\n\t} else {\n\t\tdev_warn(&h->pdev->dev, \"unknown command type %d\\n\", cmd_type);\n\t\tBUG();\n\t}\n\n\tswitch (GET_DIR(c->Request.type_attr_dir)) {\n\tcase XFER_READ:\n\t\tdir = DMA_FROM_DEVICE;\n\t\tbreak;\n\tcase XFER_WRITE:\n\t\tdir = DMA_TO_DEVICE;\n\t\tbreak;\n\tcase XFER_NONE:\n\t\tdir = DMA_NONE;\n\t\tbreak;\n\tdefault:\n\t\tdir = DMA_BIDIRECTIONAL;\n\t}\n\tif (hpsa_map_one(h->pdev, c, buff, size, dir))\n\t\treturn -1;\n\treturn 0;\n}\n\n/*\n * Map (physical) PCI mem into (virtual) kernel space\n */\nstatic void __iomem *remap_pci_mem(ulong base, ulong size)\n{\n\tulong page_base = ((ulong) base) & PAGE_MASK;\n\tulong page_offs = ((ulong) base) - page_base;\n\tvoid __iomem *page_remapped = ioremap(page_base,\n\t\tpage_offs + size);\n\n\treturn page_remapped ? (page_remapped + page_offs) : NULL;\n}\n\nstatic inline unsigned long get_next_completion(struct ctlr_info *h, u8 q)\n{\n\treturn h->access.command_completed(h, q);\n}\n\nstatic inline bool interrupt_pending(struct ctlr_info *h)\n{\n\treturn h->access.intr_pending(h);\n}\n\nstatic inline long interrupt_not_for_us(struct ctlr_info *h)\n{\n\treturn (h->access.intr_pending(h) == 0) ||\n\t\t(h->interrupts_enabled == 0);\n}\n\nstatic inline int bad_tag(struct ctlr_info *h, u32 tag_index,\n\tu32 raw_tag)\n{\n\tif (unlikely(tag_index >= h->nr_cmds)) {\n\t\tdev_warn(&h->pdev->dev, \"bad tag 0x%08x ignored.\\n\", raw_tag);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline void finish_cmd(struct CommandList *c)\n{\n\tdial_up_lockup_detection_on_fw_flash_complete(c->h, c);\n\tif (likely(c->cmd_type == CMD_IOACCEL1 || c->cmd_type == CMD_SCSI\n\t\t\t|| c->cmd_type == CMD_IOACCEL2))\n\t\tcomplete_scsi_command(c);\n\telse if (c->cmd_type == CMD_IOCTL_PEND || c->cmd_type == IOACCEL2_TMF)\n\t\tcomplete(c->waiting);\n}\n\n/* process completion of an indexed (\"direct lookup\") command */\nstatic inline void process_indexed_cmd(struct ctlr_info *h,\n\tu32 raw_tag)\n{\n\tu32 tag_index;\n\tstruct CommandList *c;\n\n\ttag_index = raw_tag >> DIRECT_LOOKUP_SHIFT;\n\tif (!bad_tag(h, tag_index, raw_tag)) {\n\t\tc = h->cmd_pool + tag_index;\n\t\tfinish_cmd(c);\n\t}\n}\n\n/* Some controllers, like p400, will give us one interrupt\n * after a soft reset, even if we turned interrupts off.\n * Only need to check for this in the hpsa_xxx_discard_completions\n * functions.\n */\nstatic int ignore_bogus_interrupt(struct ctlr_info *h)\n{\n\tif (likely(!reset_devices))\n\t\treturn 0;\n\n\tif (likely(h->interrupts_enabled))\n\t\treturn 0;\n\n\tdev_info(&h->pdev->dev, \"Received interrupt while interrupts disabled \"\n\t\t\"(known firmware bug.)  Ignoring.\\n\");\n\n\treturn 1;\n}\n\n/*\n * Convert &h->q[x] (passed to interrupt handlers) back to h.\n * Relies on (h-q[x] == x) being true for x such that\n * 0 <= x < MAX_REPLY_QUEUES.\n */\nstatic struct ctlr_info *queue_to_hba(u8 *queue)\n{\n\treturn container_of((queue - *queue), struct ctlr_info, q[0]);\n}\n\nstatic irqreturn_t hpsa_intx_discard_completions(int irq, void *queue)\n{\n\tstruct ctlr_info *h = queue_to_hba(queue);\n\tu8 q = *(u8 *) queue;\n\tu32 raw_tag;\n\n\tif (ignore_bogus_interrupt(h))\n\t\treturn IRQ_NONE;\n\n\tif (interrupt_not_for_us(h))\n\t\treturn IRQ_NONE;\n\th->last_intr_timestamp = get_jiffies_64();\n\twhile (interrupt_pending(h)) {\n\t\traw_tag = get_next_completion(h, q);\n\t\twhile (raw_tag != FIFO_EMPTY)\n\t\t\traw_tag = next_command(h, q);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t hpsa_msix_discard_completions(int irq, void *queue)\n{\n\tstruct ctlr_info *h = queue_to_hba(queue);\n\tu32 raw_tag;\n\tu8 q = *(u8 *) queue;\n\n\tif (ignore_bogus_interrupt(h))\n\t\treturn IRQ_NONE;\n\n\th->last_intr_timestamp = get_jiffies_64();\n\traw_tag = get_next_completion(h, q);\n\twhile (raw_tag != FIFO_EMPTY)\n\t\traw_tag = next_command(h, q);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t do_hpsa_intr_intx(int irq, void *queue)\n{\n\tstruct ctlr_info *h = queue_to_hba((u8 *) queue);\n\tu32 raw_tag;\n\tu8 q = *(u8 *) queue;\n\n\tif (interrupt_not_for_us(h))\n\t\treturn IRQ_NONE;\n\th->last_intr_timestamp = get_jiffies_64();\n\twhile (interrupt_pending(h)) {\n\t\traw_tag = get_next_completion(h, q);\n\t\twhile (raw_tag != FIFO_EMPTY) {\n\t\t\tprocess_indexed_cmd(h, raw_tag);\n\t\t\traw_tag = next_command(h, q);\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t do_hpsa_intr_msi(int irq, void *queue)\n{\n\tstruct ctlr_info *h = queue_to_hba(queue);\n\tu32 raw_tag;\n\tu8 q = *(u8 *) queue;\n\n\th->last_intr_timestamp = get_jiffies_64();\n\traw_tag = get_next_completion(h, q);\n\twhile (raw_tag != FIFO_EMPTY) {\n\t\tprocess_indexed_cmd(h, raw_tag);\n\t\traw_tag = next_command(h, q);\n\t}\n\treturn IRQ_HANDLED;\n}\n\n/* Send a message CDB to the firmware. Careful, this only works\n * in simple mode, not performant mode due to the tag lookup.\n * We only ever use this immediately after a controller reset.\n */\nstatic int hpsa_message(struct pci_dev *pdev, unsigned char opcode,\n\t\t\tunsigned char type)\n{\n\tstruct Command {\n\t\tstruct CommandListHeader CommandHeader;\n\t\tstruct RequestBlock Request;\n\t\tstruct ErrDescriptor ErrorDescriptor;\n\t};\n\tstruct Command *cmd;\n\tstatic const size_t cmd_sz = sizeof(*cmd) +\n\t\t\t\t\tsizeof(cmd->ErrorDescriptor);\n\tdma_addr_t paddr64;\n\t__le32 paddr32;\n\tu32 tag;\n\tvoid __iomem *vaddr;\n\tint i, err;\n\n\tvaddr = pci_ioremap_bar(pdev, 0);\n\tif (vaddr == NULL)\n\t\treturn -ENOMEM;\n\n\t/* The Inbound Post Queue only accepts 32-bit physical addresses for the\n\t * CCISS commands, so they must be allocated from the lower 4GiB of\n\t * memory.\n\t */\n\terr = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tiounmap(vaddr);\n\t\treturn err;\n\t}\n\n\tcmd = dma_alloc_coherent(&pdev->dev, cmd_sz, &paddr64, GFP_KERNEL);\n\tif (cmd == NULL) {\n\t\tiounmap(vaddr);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* This must fit, because of the 32-bit consistent DMA mask.  Also,\n\t * although there's no guarantee, we assume that the address is at\n\t * least 4-byte aligned (most likely, it's page-aligned).\n\t */\n\tpaddr32 = cpu_to_le32(paddr64);\n\n\tcmd->CommandHeader.ReplyQueue = 0;\n\tcmd->CommandHeader.SGList = 0;\n\tcmd->CommandHeader.SGTotal = cpu_to_le16(0);\n\tcmd->CommandHeader.tag = cpu_to_le64(paddr64);\n\tmemset(&cmd->CommandHeader.LUN.LunAddrBytes, 0, 8);\n\n\tcmd->Request.CDBLen = 16;\n\tcmd->Request.type_attr_dir =\n\t\t\tTYPE_ATTR_DIR(TYPE_MSG, ATTR_HEADOFQUEUE, XFER_NONE);\n\tcmd->Request.Timeout = 0; /* Don't time out */\n\tcmd->Request.CDB[0] = opcode;\n\tcmd->Request.CDB[1] = type;\n\tmemset(&cmd->Request.CDB[2], 0, 14); /* rest of the CDB is reserved */\n\tcmd->ErrorDescriptor.Addr =\n\t\t\tcpu_to_le64((le32_to_cpu(paddr32) + sizeof(*cmd)));\n\tcmd->ErrorDescriptor.Len = cpu_to_le32(sizeof(struct ErrorInfo));\n\n\twritel(le32_to_cpu(paddr32), vaddr + SA5_REQUEST_PORT_OFFSET);\n\n\tfor (i = 0; i < HPSA_MSG_SEND_RETRY_LIMIT; i++) {\n\t\ttag = readl(vaddr + SA5_REPLY_PORT_OFFSET);\n\t\tif ((tag & ~HPSA_SIMPLE_ERROR_BITS) == paddr64)\n\t\t\tbreak;\n\t\tmsleep(HPSA_MSG_SEND_RETRY_INTERVAL_MSECS);\n\t}\n\n\tiounmap(vaddr);\n\n\t/* we leak the DMA buffer here ... no choice since the controller could\n\t *  still complete the command.\n\t */\n\tif (i == HPSA_MSG_SEND_RETRY_LIMIT) {\n\t\tdev_err(&pdev->dev, \"controller message %02x:%02x timed out\\n\",\n\t\t\topcode, type);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tdma_free_coherent(&pdev->dev, cmd_sz, cmd, paddr64);\n\n\tif (tag & HPSA_ERROR_BIT) {\n\t\tdev_err(&pdev->dev, \"controller message %02x:%02x failed\\n\",\n\t\t\topcode, type);\n\t\treturn -EIO;\n\t}\n\n\tdev_info(&pdev->dev, \"controller message %02x:%02x succeeded\\n\",\n\t\topcode, type);\n\treturn 0;\n}\n\n#define hpsa_noop(p) hpsa_message(p, 3, 0)\n\nstatic int hpsa_controller_hard_reset(struct pci_dev *pdev,\n\tvoid __iomem *vaddr, u32 use_doorbell)\n{\n\n\tif (use_doorbell) {\n\t\t/* For everything after the P600, the PCI power state method\n\t\t * of resetting the controller doesn't work, so we have this\n\t\t * other way using the doorbell register.\n\t\t */\n\t\tdev_info(&pdev->dev, \"using doorbell to reset controller\\n\");\n\t\twritel(use_doorbell, vaddr + SA5_DOORBELL);\n\n\t\t/* PMC hardware guys tell us we need a 10 second delay after\n\t\t * doorbell reset and before any attempt to talk to the board\n\t\t * at all to ensure that this actually works and doesn't fall\n\t\t * over in some weird corner cases.\n\t\t */\n\t\tmsleep(10000);\n\t} else { /* Try to do it the PCI power state way */\n\n\t\t/* Quoting from the Open CISS Specification: \"The Power\n\t\t * Management Control/Status Register (CSR) controls the power\n\t\t * state of the device.  The normal operating state is D0,\n\t\t * CSR=00h.  The software off state is D3, CSR=03h.  To reset\n\t\t * the controller, place the interface device in D3 then to D0,\n\t\t * this causes a secondary PCI reset which will reset the\n\t\t * controller.\" */\n\n\t\tint rc = 0;\n\n\t\tdev_info(&pdev->dev, \"using PCI PM to reset controller\\n\");\n\n\t\t/* enter the D3hot power management state */\n\t\trc = pci_set_power_state(pdev, PCI_D3hot);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tmsleep(500);\n\n\t\t/* enter the D0 power management state */\n\t\trc = pci_set_power_state(pdev, PCI_D0);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * The P600 requires a small delay when changing states.\n\t\t * Otherwise we may think the board did not reset and we bail.\n\t\t * This for kdump only and is particular to the P600.\n\t\t */\n\t\tmsleep(500);\n\t}\n\treturn 0;\n}\n\nstatic void init_driver_version(char *driver_version, int len)\n{\n\tmemset(driver_version, 0, len);\n\tstrncpy(driver_version, HPSA \" \" HPSA_DRIVER_VERSION, len - 1);\n}\n\nstatic int write_driver_ver_to_cfgtable(struct CfgTable __iomem *cfgtable)\n{\n\tchar *driver_version;\n\tint i, size = sizeof(cfgtable->driver_version);\n\n\tdriver_version = kmalloc(size, GFP_KERNEL);\n\tif (!driver_version)\n\t\treturn -ENOMEM;\n\n\tinit_driver_version(driver_version, size);\n\tfor (i = 0; i < size; i++)\n\t\twriteb(driver_version[i], &cfgtable->driver_version[i]);\n\tkfree(driver_version);\n\treturn 0;\n}\n\nstatic void read_driver_ver_from_cfgtable(struct CfgTable __iomem *cfgtable,\n\t\t\t\t\t  unsigned char *driver_ver)\n{\n\tint i;\n\n\tfor (i = 0; i < sizeof(cfgtable->driver_version); i++)\n\t\tdriver_ver[i] = readb(&cfgtable->driver_version[i]);\n}\n\nstatic int controller_reset_failed(struct CfgTable __iomem *cfgtable)\n{\n\n\tchar *driver_ver, *old_driver_ver;\n\tint rc, size = sizeof(cfgtable->driver_version);\n\n\told_driver_ver = kmalloc_array(2, size, GFP_KERNEL);\n\tif (!old_driver_ver)\n\t\treturn -ENOMEM;\n\tdriver_ver = old_driver_ver + size;\n\n\t/* After a reset, the 32 bytes of \"driver version\" in the cfgtable\n\t * should have been changed, otherwise we know the reset failed.\n\t */\n\tinit_driver_version(old_driver_ver, size);\n\tread_driver_ver_from_cfgtable(cfgtable, driver_ver);\n\trc = !memcmp(driver_ver, old_driver_ver, size);\n\tkfree(old_driver_ver);\n\treturn rc;\n}\n/* This does a hard reset of the controller using PCI power management\n * states or the using the doorbell register.\n */\nstatic int hpsa_kdump_hard_reset_controller(struct pci_dev *pdev, u32 board_id)\n{\n\tu64 cfg_offset;\n\tu32 cfg_base_addr;\n\tu64 cfg_base_addr_index;\n\tvoid __iomem *vaddr;\n\tunsigned long paddr;\n\tu32 misc_fw_support;\n\tint rc;\n\tstruct CfgTable __iomem *cfgtable;\n\tu32 use_doorbell;\n\tu16 command_register;\n\n\t/* For controllers as old as the P600, this is very nearly\n\t * the same thing as\n\t *\n\t * pci_save_state(pci_dev);\n\t * pci_set_power_state(pci_dev, PCI_D3hot);\n\t * pci_set_power_state(pci_dev, PCI_D0);\n\t * pci_restore_state(pci_dev);\n\t *\n\t * For controllers newer than the P600, the pci power state\n\t * method of resetting doesn't work so we have another way\n\t * using the doorbell register.\n\t */\n\n\tif (!ctlr_is_resettable(board_id)) {\n\t\tdev_warn(&pdev->dev, \"Controller not resettable\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t/* if controller is soft- but not hard resettable... */\n\tif (!ctlr_is_hard_resettable(board_id))\n\t\treturn -ENOTSUPP; /* try soft reset later. */\n\n\t/* Save the PCI command register */\n\tpci_read_config_word(pdev, 4, &command_register);\n\tpci_save_state(pdev);\n\n\t/* find the first memory BAR, so we can find the cfg table */\n\trc = hpsa_pci_find_memory_BAR(pdev, &paddr);\n\tif (rc)\n\t\treturn rc;\n\tvaddr = remap_pci_mem(paddr, 0x250);\n\tif (!vaddr)\n\t\treturn -ENOMEM;\n\n\t/* find cfgtable in order to check if reset via doorbell is supported */\n\trc = hpsa_find_cfg_addrs(pdev, vaddr, &cfg_base_addr,\n\t\t\t\t\t&cfg_base_addr_index, &cfg_offset);\n\tif (rc)\n\t\tgoto unmap_vaddr;\n\tcfgtable = remap_pci_mem(pci_resource_start(pdev,\n\t\t       cfg_base_addr_index) + cfg_offset, sizeof(*cfgtable));\n\tif (!cfgtable) {\n\t\trc = -ENOMEM;\n\t\tgoto unmap_vaddr;\n\t}\n\trc = write_driver_ver_to_cfgtable(cfgtable);\n\tif (rc)\n\t\tgoto unmap_cfgtable;\n\n\t/* If reset via doorbell register is supported, use that.\n\t * There are two such methods.  Favor the newest method.\n\t */\n\tmisc_fw_support = readl(&cfgtable->misc_fw_support);\n\tuse_doorbell = misc_fw_support & MISC_FW_DOORBELL_RESET2;\n\tif (use_doorbell) {\n\t\tuse_doorbell = DOORBELL_CTLR_RESET2;\n\t} else {\n\t\tuse_doorbell = misc_fw_support & MISC_FW_DOORBELL_RESET;\n\t\tif (use_doorbell) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\"Soft reset not supported. Firmware update is required.\\n\");\n\t\t\trc = -ENOTSUPP; /* try soft reset */\n\t\t\tgoto unmap_cfgtable;\n\t\t}\n\t}\n\n\trc = hpsa_controller_hard_reset(pdev, vaddr, use_doorbell);\n\tif (rc)\n\t\tgoto unmap_cfgtable;\n\n\tpci_restore_state(pdev);\n\tpci_write_config_word(pdev, 4, command_register);\n\n\t/* Some devices (notably the HP Smart Array 5i Controller)\n\t   need a little pause here */\n\tmsleep(HPSA_POST_RESET_PAUSE_MSECS);\n\n\trc = hpsa_wait_for_board_state(pdev, vaddr, BOARD_READY);\n\tif (rc) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t\"Failed waiting for board to become ready after hard reset\\n\");\n\t\tgoto unmap_cfgtable;\n\t}\n\n\trc = controller_reset_failed(vaddr);\n\tif (rc < 0)\n\t\tgoto unmap_cfgtable;\n\tif (rc) {\n\t\tdev_warn(&pdev->dev, \"Unable to successfully reset \"\n\t\t\t\"controller. Will try soft reset.\\n\");\n\t\trc = -ENOTSUPP;\n\t} else {\n\t\tdev_info(&pdev->dev, \"board ready after hard reset.\\n\");\n\t}\n\nunmap_cfgtable:\n\tiounmap(cfgtable);\n\nunmap_vaddr:\n\tiounmap(vaddr);\n\treturn rc;\n}\n\n/*\n *  We cannot read the structure directly, for portability we must use\n *   the io functions.\n *   This is for debug only.\n */\nstatic void print_cfg_table(struct device *dev, struct CfgTable __iomem *tb)\n{\n#ifdef HPSA_DEBUG\n\tint i;\n\tchar temp_name[17];\n\n\tdev_info(dev, \"Controller Configuration information\\n\");\n\tdev_info(dev, \"------------------------------------\\n\");\n\tfor (i = 0; i < 4; i++)\n\t\ttemp_name[i] = readb(&(tb->Signature[i]));\n\ttemp_name[4] = '\\0';\n\tdev_info(dev, \"   Signature = %s\\n\", temp_name);\n\tdev_info(dev, \"   Spec Number = %d\\n\", readl(&(tb->SpecValence)));\n\tdev_info(dev, \"   Transport methods supported = 0x%x\\n\",\n\t       readl(&(tb->TransportSupport)));\n\tdev_info(dev, \"   Transport methods active = 0x%x\\n\",\n\t       readl(&(tb->TransportActive)));\n\tdev_info(dev, \"   Requested transport Method = 0x%x\\n\",\n\t       readl(&(tb->HostWrite.TransportRequest)));\n\tdev_info(dev, \"   Coalesce Interrupt Delay = 0x%x\\n\",\n\t       readl(&(tb->HostWrite.CoalIntDelay)));\n\tdev_info(dev, \"   Coalesce Interrupt Count = 0x%x\\n\",\n\t       readl(&(tb->HostWrite.CoalIntCount)));\n\tdev_info(dev, \"   Max outstanding commands = %d\\n\",\n\t       readl(&(tb->CmdsOutMax)));\n\tdev_info(dev, \"   Bus Types = 0x%x\\n\", readl(&(tb->BusTypes)));\n\tfor (i = 0; i < 16; i++)\n\t\ttemp_name[i] = readb(&(tb->ServerName[i]));\n\ttemp_name[16] = '\\0';\n\tdev_info(dev, \"   Server Name = %s\\n\", temp_name);\n\tdev_info(dev, \"   Heartbeat Counter = 0x%x\\n\\n\\n\",\n\t\treadl(&(tb->HeartBeat)));\n#endif\t\t\t\t/* HPSA_DEBUG */\n}\n\nstatic int find_PCI_BAR_index(struct pci_dev *pdev, unsigned long pci_bar_addr)\n{\n\tint i, offset, mem_type, bar_type;\n\n\tif (pci_bar_addr == PCI_BASE_ADDRESS_0)\t/* looking for BAR zero? */\n\t\treturn 0;\n\toffset = 0;\n\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\n\t\tbar_type = pci_resource_flags(pdev, i) & PCI_BASE_ADDRESS_SPACE;\n\t\tif (bar_type == PCI_BASE_ADDRESS_SPACE_IO)\n\t\t\toffset += 4;\n\t\telse {\n\t\t\tmem_type = pci_resource_flags(pdev, i) &\n\t\t\t    PCI_BASE_ADDRESS_MEM_TYPE_MASK;\n\t\t\tswitch (mem_type) {\n\t\t\tcase PCI_BASE_ADDRESS_MEM_TYPE_32:\n\t\t\tcase PCI_BASE_ADDRESS_MEM_TYPE_1M:\n\t\t\t\toffset += 4;\t/* 32 bit */\n\t\t\t\tbreak;\n\t\t\tcase PCI_BASE_ADDRESS_MEM_TYPE_64:\n\t\t\t\toffset += 8;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* reserved in PCI 2.2 */\n\t\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t       \"base address is invalid\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (offset == pci_bar_addr - PCI_BASE_ADDRESS_0)\n\t\t\treturn i + 1;\n\t}\n\treturn -1;\n}\n\nstatic void hpsa_disable_interrupt_mode(struct ctlr_info *h)\n{\n\tpci_free_irq_vectors(h->pdev);\n\th->msix_vectors = 0;\n}\n\nstatic void hpsa_setup_reply_map(struct ctlr_info *h)\n{\n\tconst struct cpumask *mask;\n\tunsigned int queue, cpu;\n\n\tfor (queue = 0; queue < h->msix_vectors; queue++) {\n\t\tmask = pci_irq_get_affinity(h->pdev, queue);\n\t\tif (!mask)\n\t\t\tgoto fallback;\n\n\t\tfor_each_cpu(cpu, mask)\n\t\t\th->reply_map[cpu] = queue;\n\t}\n\treturn;\n\nfallback:\n\tfor_each_possible_cpu(cpu)\n\t\th->reply_map[cpu] = 0;\n}\n\n/* If MSI/MSI-X is supported by the kernel we will try to enable it on\n * controllers that are capable. If not, we use legacy INTx mode.\n */\nstatic int hpsa_interrupt_mode(struct ctlr_info *h)\n{\n\tunsigned int flags = PCI_IRQ_LEGACY;\n\tint ret;\n\n\t/* Some boards advertise MSI but don't really support it */\n\tswitch (h->board_id) {\n\tcase 0x40700E11:\n\tcase 0x40800E11:\n\tcase 0x40820E11:\n\tcase 0x40830E11:\n\t\tbreak;\n\tdefault:\n\t\tret = pci_alloc_irq_vectors(h->pdev, 1, MAX_REPLY_QUEUES,\n\t\t\t\tPCI_IRQ_MSIX | PCI_IRQ_AFFINITY);\n\t\tif (ret > 0) {\n\t\t\th->msix_vectors = ret;\n\t\t\treturn 0;\n\t\t}\n\n\t\tflags |= PCI_IRQ_MSI;\n\t\tbreak;\n\t}\n\n\tret = pci_alloc_irq_vectors(h->pdev, 1, 1, flags);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic int hpsa_lookup_board_id(struct pci_dev *pdev, u32 *board_id,\n\t\t\t\tbool *legacy_board)\n{\n\tint i;\n\tu32 subsystem_vendor_id, subsystem_device_id;\n\n\tsubsystem_vendor_id = pdev->subsystem_vendor;\n\tsubsystem_device_id = pdev->subsystem_device;\n\t*board_id = ((subsystem_device_id << 16) & 0xffff0000) |\n\t\t    subsystem_vendor_id;\n\n\tif (legacy_board)\n\t\t*legacy_board = false;\n\tfor (i = 0; i < ARRAY_SIZE(products); i++)\n\t\tif (*board_id == products[i].board_id) {\n\t\t\tif (products[i].access != &SA5A_access &&\n\t\t\t    products[i].access != &SA5B_access)\n\t\t\t\treturn i;\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"legacy board ID: 0x%08x\\n\",\n\t\t\t\t *board_id);\n\t\t\tif (legacy_board)\n\t\t\t    *legacy_board = true;\n\t\t\treturn i;\n\t\t}\n\n\tdev_warn(&pdev->dev, \"unrecognized board ID: 0x%08x\\n\", *board_id);\n\tif (legacy_board)\n\t\t*legacy_board = true;\n\treturn ARRAY_SIZE(products) - 1; /* generic unknown smart array */\n}\n\nstatic int hpsa_pci_find_memory_BAR(struct pci_dev *pdev,\n\t\t\t\t    unsigned long *memory_bar)\n{\n\tint i;\n\n\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++)\n\t\tif (pci_resource_flags(pdev, i) & IORESOURCE_MEM) {\n\t\t\t/* addressing mode bits already removed */\n\t\t\t*memory_bar = pci_resource_start(pdev, i);\n\t\t\tdev_dbg(&pdev->dev, \"memory BAR = %lx\\n\",\n\t\t\t\t*memory_bar);\n\t\t\treturn 0;\n\t\t}\n\tdev_warn(&pdev->dev, \"no memory BAR found\\n\");\n\treturn -ENODEV;\n}\n\nstatic int hpsa_wait_for_board_state(struct pci_dev *pdev, void __iomem *vaddr,\n\t\t\t\t     int wait_for_ready)\n{\n\tint i, iterations;\n\tu32 scratchpad;\n\tif (wait_for_ready)\n\t\titerations = HPSA_BOARD_READY_ITERATIONS;\n\telse\n\t\titerations = HPSA_BOARD_NOT_READY_ITERATIONS;\n\n\tfor (i = 0; i < iterations; i++) {\n\t\tscratchpad = readl(vaddr + SA5_SCRATCHPAD_OFFSET);\n\t\tif (wait_for_ready) {\n\t\t\tif (scratchpad == HPSA_FIRMWARE_READY)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (scratchpad != HPSA_FIRMWARE_READY)\n\t\t\t\treturn 0;\n\t\t}\n\t\tmsleep(HPSA_BOARD_READY_POLL_INTERVAL_MSECS);\n\t}\n\tdev_warn(&pdev->dev, \"board not ready, timed out.\\n\");\n\treturn -ENODEV;\n}\n\nstatic int hpsa_find_cfg_addrs(struct pci_dev *pdev, void __iomem *vaddr,\n\t\t\t       u32 *cfg_base_addr, u64 *cfg_base_addr_index,\n\t\t\t       u64 *cfg_offset)\n{\n\t*cfg_base_addr = readl(vaddr + SA5_CTCFG_OFFSET);\n\t*cfg_offset = readl(vaddr + SA5_CTMEM_OFFSET);\n\t*cfg_base_addr &= (u32) 0x0000ffff;\n\t*cfg_base_addr_index = find_PCI_BAR_index(pdev, *cfg_base_addr);\n\tif (*cfg_base_addr_index == -1) {\n\t\tdev_warn(&pdev->dev, \"cannot find cfg_base_addr_index\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic void hpsa_free_cfgtables(struct ctlr_info *h)\n{\n\tif (h->transtable) {\n\t\tiounmap(h->transtable);\n\t\th->transtable = NULL;\n\t}\n\tif (h->cfgtable) {\n\t\tiounmap(h->cfgtable);\n\t\th->cfgtable = NULL;\n\t}\n}\n\n/* Find and map CISS config table and transfer table\n+ * several items must be unmapped (freed) later\n+ * */\nstatic int hpsa_find_cfgtables(struct ctlr_info *h)\n{\n\tu64 cfg_offset;\n\tu32 cfg_base_addr;\n\tu64 cfg_base_addr_index;\n\tu32 trans_offset;\n\tint rc;\n\n\trc = hpsa_find_cfg_addrs(h->pdev, h->vaddr, &cfg_base_addr,\n\t\t&cfg_base_addr_index, &cfg_offset);\n\tif (rc)\n\t\treturn rc;\n\th->cfgtable = remap_pci_mem(pci_resource_start(h->pdev,\n\t\t       cfg_base_addr_index) + cfg_offset, sizeof(*h->cfgtable));\n\tif (!h->cfgtable) {\n\t\tdev_err(&h->pdev->dev, \"Failed mapping cfgtable\\n\");\n\t\treturn -ENOMEM;\n\t}\n\trc = write_driver_ver_to_cfgtable(h->cfgtable);\n\tif (rc)\n\t\treturn rc;\n\t/* Find performant mode table. */\n\ttrans_offset = readl(&h->cfgtable->TransMethodOffset);\n\th->transtable = remap_pci_mem(pci_resource_start(h->pdev,\n\t\t\t\tcfg_base_addr_index)+cfg_offset+trans_offset,\n\t\t\t\tsizeof(*h->transtable));\n\tif (!h->transtable) {\n\t\tdev_err(&h->pdev->dev, \"Failed mapping transfer table\\n\");\n\t\thpsa_free_cfgtables(h);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic void hpsa_get_max_perf_mode_cmds(struct ctlr_info *h)\n{\n#define MIN_MAX_COMMANDS 16\n\tBUILD_BUG_ON(MIN_MAX_COMMANDS <= HPSA_NRESERVED_CMDS);\n\n\th->max_commands = readl(&h->cfgtable->MaxPerformantModeCommands);\n\n\t/* Limit commands in memory limited kdump scenario. */\n\tif (reset_devices && h->max_commands > 32)\n\t\th->max_commands = 32;\n\n\tif (h->max_commands < MIN_MAX_COMMANDS) {\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t\"Controller reports max supported commands of %d Using %d instead. Ensure that firmware is up to date.\\n\",\n\t\t\th->max_commands,\n\t\t\tMIN_MAX_COMMANDS);\n\t\th->max_commands = MIN_MAX_COMMANDS;\n\t}\n}\n\n/* If the controller reports that the total max sg entries is greater than 512,\n * then we know that chained SG blocks work.  (Original smart arrays did not\n * support chained SG blocks and would return zero for max sg entries.)\n */\nstatic int hpsa_supports_chained_sg_blocks(struct ctlr_info *h)\n{\n\treturn h->maxsgentries > 512;\n}\n\n/* Interrogate the hardware for some limits:\n * max commands, max SG elements without chaining, and with chaining,\n * SG chain block size, etc.\n */\nstatic void hpsa_find_board_params(struct ctlr_info *h)\n{\n\thpsa_get_max_perf_mode_cmds(h);\n\th->nr_cmds = h->max_commands;\n\th->maxsgentries = readl(&(h->cfgtable->MaxScatterGatherElements));\n\th->fw_support = readl(&(h->cfgtable->misc_fw_support));\n\tif (hpsa_supports_chained_sg_blocks(h)) {\n\t\t/* Limit in-command s/g elements to 32 save dma'able memory. */\n\t\th->max_cmd_sg_entries = 32;\n\t\th->chainsize = h->maxsgentries - h->max_cmd_sg_entries;\n\t\th->maxsgentries--; /* save one for chain pointer */\n\t} else {\n\t\t/*\n\t\t * Original smart arrays supported at most 31 s/g entries\n\t\t * embedded inline in the command (trying to use more\n\t\t * would lock up the controller)\n\t\t */\n\t\th->max_cmd_sg_entries = 31;\n\t\th->maxsgentries = 31; /* default to traditional values */\n\t\th->chainsize = 0;\n\t}\n\n\t/* Find out what task management functions are supported and cache */\n\th->TMFSupportFlags = readl(&(h->cfgtable->TMFSupportFlags));\n\tif (!(HPSATMF_PHYS_TASK_ABORT & h->TMFSupportFlags))\n\t\tdev_warn(&h->pdev->dev, \"Physical aborts not supported\\n\");\n\tif (!(HPSATMF_LOG_TASK_ABORT & h->TMFSupportFlags))\n\t\tdev_warn(&h->pdev->dev, \"Logical aborts not supported\\n\");\n\tif (!(HPSATMF_IOACCEL_ENABLED & h->TMFSupportFlags))\n\t\tdev_warn(&h->pdev->dev, \"HP SSD Smart Path aborts not supported\\n\");\n}\n\nstatic inline bool hpsa_CISS_signature_present(struct ctlr_info *h)\n{\n\tif (!check_signature(h->cfgtable->Signature, \"CISS\", 4)) {\n\t\tdev_err(&h->pdev->dev, \"not a valid CISS config table\\n\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic inline void hpsa_set_driver_support_bits(struct ctlr_info *h)\n{\n\tu32 driver_support;\n\n\tdriver_support = readl(&(h->cfgtable->driver_support));\n\t/* Need to enable prefetch in the SCSI core for 6400 in x86 */\n#ifdef CONFIG_X86\n\tdriver_support |= ENABLE_SCSI_PREFETCH;\n#endif\n\tdriver_support |= ENABLE_UNIT_ATTN;\n\twritel(driver_support, &(h->cfgtable->driver_support));\n}\n\n/* Disable DMA prefetch for the P600.  Otherwise an ASIC bug may result\n * in a prefetch beyond physical memory.\n */\nstatic inline void hpsa_p600_dma_prefetch_quirk(struct ctlr_info *h)\n{\n\tu32 dma_prefetch;\n\n\tif (h->board_id != 0x3225103C)\n\t\treturn;\n\tdma_prefetch = readl(h->vaddr + I2O_DMA1_CFG);\n\tdma_prefetch |= 0x8000;\n\twritel(dma_prefetch, h->vaddr + I2O_DMA1_CFG);\n}\n\nstatic int hpsa_wait_for_clear_event_notify_ack(struct ctlr_info *h)\n{\n\tint i;\n\tu32 doorbell_value;\n\tunsigned long flags;\n\t/* wait until the clear_event_notify bit 6 is cleared by controller. */\n\tfor (i = 0; i < MAX_CLEAR_EVENT_WAIT; i++) {\n\t\tspin_lock_irqsave(&h->lock, flags);\n\t\tdoorbell_value = readl(h->vaddr + SA5_DOORBELL);\n\t\tspin_unlock_irqrestore(&h->lock, flags);\n\t\tif (!(doorbell_value & DOORBELL_CLEAR_EVENTS))\n\t\t\tgoto done;\n\t\t/* delay and try again */\n\t\tmsleep(CLEAR_EVENT_WAIT_INTERVAL);\n\t}\n\treturn -ENODEV;\ndone:\n\treturn 0;\n}\n\nstatic int hpsa_wait_for_mode_change_ack(struct ctlr_info *h)\n{\n\tint i;\n\tu32 doorbell_value;\n\tunsigned long flags;\n\n\t/* under certain very rare conditions, this can take awhile.\n\t * (e.g.: hot replace a failed 144GB drive in a RAID 5 set right\n\t * as we enter this code.)\n\t */\n\tfor (i = 0; i < MAX_MODE_CHANGE_WAIT; i++) {\n\t\tif (h->remove_in_progress)\n\t\t\tgoto done;\n\t\tspin_lock_irqsave(&h->lock, flags);\n\t\tdoorbell_value = readl(h->vaddr + SA5_DOORBELL);\n\t\tspin_unlock_irqrestore(&h->lock, flags);\n\t\tif (!(doorbell_value & CFGTBL_ChangeReq))\n\t\t\tgoto done;\n\t\t/* delay and try again */\n\t\tmsleep(MODE_CHANGE_WAIT_INTERVAL);\n\t}\n\treturn -ENODEV;\ndone:\n\treturn 0;\n}\n\n/* return -ENODEV or other reason on error, 0 on success */\nstatic int hpsa_enter_simple_mode(struct ctlr_info *h)\n{\n\tu32 trans_support;\n\n\ttrans_support = readl(&(h->cfgtable->TransportSupport));\n\tif (!(trans_support & SIMPLE_MODE))\n\t\treturn -ENOTSUPP;\n\n\th->max_commands = readl(&(h->cfgtable->CmdsOutMax));\n\n\t/* Update the field, and then ring the doorbell */\n\twritel(CFGTBL_Trans_Simple, &(h->cfgtable->HostWrite.TransportRequest));\n\twritel(0, &h->cfgtable->HostWrite.command_pool_addr_hi);\n\twritel(CFGTBL_ChangeReq, h->vaddr + SA5_DOORBELL);\n\tif (hpsa_wait_for_mode_change_ack(h))\n\t\tgoto error;\n\tprint_cfg_table(&h->pdev->dev, h->cfgtable);\n\tif (!(readl(&(h->cfgtable->TransportActive)) & CFGTBL_Trans_Simple))\n\t\tgoto error;\n\th->transMethod = CFGTBL_Trans_Simple;\n\treturn 0;\nerror:\n\tdev_err(&h->pdev->dev, \"failed to enter simple mode\\n\");\n\treturn -ENODEV;\n}\n\n/* free items allocated or mapped by hpsa_pci_init */\nstatic void hpsa_free_pci_init(struct ctlr_info *h)\n{\n\thpsa_free_cfgtables(h);\t\t\t/* pci_init 4 */\n\tiounmap(h->vaddr);\t\t\t/* pci_init 3 */\n\th->vaddr = NULL;\n\thpsa_disable_interrupt_mode(h);\t\t/* pci_init 2 */\n\t/*\n\t * call pci_disable_device before pci_release_regions per\n\t * Documentation/driver-api/pci/pci.rst\n\t */\n\tpci_disable_device(h->pdev);\t\t/* pci_init 1 */\n\tpci_release_regions(h->pdev);\t\t/* pci_init 2 */\n}\n\n/* several items must be freed later */\nstatic int hpsa_pci_init(struct ctlr_info *h)\n{\n\tint prod_index, err;\n\tbool legacy_board;\n\n\tprod_index = hpsa_lookup_board_id(h->pdev, &h->board_id, &legacy_board);\n\tif (prod_index < 0)\n\t\treturn prod_index;\n\th->product_name = products[prod_index].product_name;\n\th->access = *(products[prod_index].access);\n\th->legacy_board = legacy_board;\n\tpci_disable_link_state(h->pdev, PCIE_LINK_STATE_L0S |\n\t\t\t       PCIE_LINK_STATE_L1 | PCIE_LINK_STATE_CLKPM);\n\n\terr = pci_enable_device(h->pdev);\n\tif (err) {\n\t\tdev_err(&h->pdev->dev, \"failed to enable PCI device\\n\");\n\t\tpci_disable_device(h->pdev);\n\t\treturn err;\n\t}\n\n\terr = pci_request_regions(h->pdev, HPSA);\n\tif (err) {\n\t\tdev_err(&h->pdev->dev,\n\t\t\t\"failed to obtain PCI resources\\n\");\n\t\tpci_disable_device(h->pdev);\n\t\treturn err;\n\t}\n\n\tpci_set_master(h->pdev);\n\n\terr = hpsa_interrupt_mode(h);\n\tif (err)\n\t\tgoto clean1;\n\n\t/* setup mapping between CPU and reply queue */\n\thpsa_setup_reply_map(h);\n\n\terr = hpsa_pci_find_memory_BAR(h->pdev, &h->paddr);\n\tif (err)\n\t\tgoto clean2;\t/* intmode+region, pci */\n\th->vaddr = remap_pci_mem(h->paddr, 0x250);\n\tif (!h->vaddr) {\n\t\tdev_err(&h->pdev->dev, \"failed to remap PCI mem\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto clean2;\t/* intmode+region, pci */\n\t}\n\terr = hpsa_wait_for_board_state(h->pdev, h->vaddr, BOARD_READY);\n\tif (err)\n\t\tgoto clean3;\t/* vaddr, intmode+region, pci */\n\terr = hpsa_find_cfgtables(h);\n\tif (err)\n\t\tgoto clean3;\t/* vaddr, intmode+region, pci */\n\thpsa_find_board_params(h);\n\n\tif (!hpsa_CISS_signature_present(h)) {\n\t\terr = -ENODEV;\n\t\tgoto clean4;\t/* cfgtables, vaddr, intmode+region, pci */\n\t}\n\thpsa_set_driver_support_bits(h);\n\thpsa_p600_dma_prefetch_quirk(h);\n\terr = hpsa_enter_simple_mode(h);\n\tif (err)\n\t\tgoto clean4;\t/* cfgtables, vaddr, intmode+region, pci */\n\treturn 0;\n\nclean4:\t/* cfgtables, vaddr, intmode+region, pci */\n\thpsa_free_cfgtables(h);\nclean3:\t/* vaddr, intmode+region, pci */\n\tiounmap(h->vaddr);\n\th->vaddr = NULL;\nclean2:\t/* intmode+region, pci */\n\thpsa_disable_interrupt_mode(h);\nclean1:\n\t/*\n\t * call pci_disable_device before pci_release_regions per\n\t * Documentation/driver-api/pci/pci.rst\n\t */\n\tpci_disable_device(h->pdev);\n\tpci_release_regions(h->pdev);\n\treturn err;\n}\n\nstatic void hpsa_hba_inquiry(struct ctlr_info *h)\n{\n\tint rc;\n\n#define HBA_INQUIRY_BYTE_COUNT 64\n\th->hba_inquiry_data = kmalloc(HBA_INQUIRY_BYTE_COUNT, GFP_KERNEL);\n\tif (!h->hba_inquiry_data)\n\t\treturn;\n\trc = hpsa_scsi_do_inquiry(h, RAID_CTLR_LUNID, 0,\n\t\th->hba_inquiry_data, HBA_INQUIRY_BYTE_COUNT);\n\tif (rc != 0) {\n\t\tkfree(h->hba_inquiry_data);\n\t\th->hba_inquiry_data = NULL;\n\t}\n}\n\nstatic int hpsa_init_reset_devices(struct pci_dev *pdev, u32 board_id)\n{\n\tint rc, i;\n\tvoid __iomem *vaddr;\n\n\tif (!reset_devices)\n\t\treturn 0;\n\n\t/* kdump kernel is loading, we don't know in which state is\n\t * the pci interface. The dev->enable_cnt is equal zero\n\t * so we call enable+disable, wait a while and switch it on.\n\t */\n\trc = pci_enable_device(pdev);\n\tif (rc) {\n\t\tdev_warn(&pdev->dev, \"Failed to enable PCI device\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpci_disable_device(pdev);\n\tmsleep(260);\t\t\t/* a randomly chosen number */\n\trc = pci_enable_device(pdev);\n\tif (rc) {\n\t\tdev_warn(&pdev->dev, \"failed to enable device.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpci_set_master(pdev);\n\n\tvaddr = pci_ioremap_bar(pdev, 0);\n\tif (vaddr == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out_disable;\n\t}\n\twritel(SA5_INTR_OFF, vaddr + SA5_REPLY_INTR_MASK_OFFSET);\n\tiounmap(vaddr);\n\n\t/* Reset the controller with a PCI power-cycle or via doorbell */\n\trc = hpsa_kdump_hard_reset_controller(pdev, board_id);\n\n\t/* -ENOTSUPP here means we cannot reset the controller\n\t * but it's already (and still) up and running in\n\t * \"performant mode\".  Or, it might be 640x, which can't reset\n\t * due to concerns about shared bbwc between 6402/6404 pair.\n\t */\n\tif (rc)\n\t\tgoto out_disable;\n\n\t/* Now try to get the controller to respond to a no-op */\n\tdev_info(&pdev->dev, \"Waiting for controller to respond to no-op\\n\");\n\tfor (i = 0; i < HPSA_POST_RESET_NOOP_RETRIES; i++) {\n\t\tif (hpsa_noop(pdev) == 0)\n\t\t\tbreak;\n\t\telse\n\t\t\tdev_warn(&pdev->dev, \"no-op failed%s\\n\",\n\t\t\t\t\t(i < 11 ? \"; re-trying\" : \"\"));\n\t}\n\nout_disable:\n\n\tpci_disable_device(pdev);\n\treturn rc;\n}\n\nstatic void hpsa_free_cmd_pool(struct ctlr_info *h)\n{\n\tkfree(h->cmd_pool_bits);\n\th->cmd_pool_bits = NULL;\n\tif (h->cmd_pool) {\n\t\tdma_free_coherent(&h->pdev->dev,\n\t\t\t\th->nr_cmds * sizeof(struct CommandList),\n\t\t\t\th->cmd_pool,\n\t\t\t\th->cmd_pool_dhandle);\n\t\th->cmd_pool = NULL;\n\t\th->cmd_pool_dhandle = 0;\n\t}\n\tif (h->errinfo_pool) {\n\t\tdma_free_coherent(&h->pdev->dev,\n\t\t\t\th->nr_cmds * sizeof(struct ErrorInfo),\n\t\t\t\th->errinfo_pool,\n\t\t\t\th->errinfo_pool_dhandle);\n\t\th->errinfo_pool = NULL;\n\t\th->errinfo_pool_dhandle = 0;\n\t}\n}\n\nstatic int hpsa_alloc_cmd_pool(struct ctlr_info *h)\n{\n\th->cmd_pool_bits = kcalloc(DIV_ROUND_UP(h->nr_cmds, BITS_PER_LONG),\n\t\t\t\t   sizeof(unsigned long),\n\t\t\t\t   GFP_KERNEL);\n\th->cmd_pool = dma_alloc_coherent(&h->pdev->dev,\n\t\t    h->nr_cmds * sizeof(*h->cmd_pool),\n\t\t    &h->cmd_pool_dhandle, GFP_KERNEL);\n\th->errinfo_pool = dma_alloc_coherent(&h->pdev->dev,\n\t\t    h->nr_cmds * sizeof(*h->errinfo_pool),\n\t\t    &h->errinfo_pool_dhandle, GFP_KERNEL);\n\tif ((h->cmd_pool_bits == NULL)\n\t    || (h->cmd_pool == NULL)\n\t    || (h->errinfo_pool == NULL)) {\n\t\tdev_err(&h->pdev->dev, \"out of memory in %s\", __func__);\n\t\tgoto clean_up;\n\t}\n\thpsa_preinitialize_commands(h);\n\treturn 0;\nclean_up:\n\thpsa_free_cmd_pool(h);\n\treturn -ENOMEM;\n}\n\n/* clear affinity hints and free MSI-X, MSI, or legacy INTx vectors */\nstatic void hpsa_free_irqs(struct ctlr_info *h)\n{\n\tint i;\n\tint irq_vector = 0;\n\n\tif (hpsa_simple_mode)\n\t\tirq_vector = h->intr_mode;\n\n\tif (!h->msix_vectors || h->intr_mode != PERF_MODE_INT) {\n\t\t/* Single reply queue, only one irq to free */\n\t\tfree_irq(pci_irq_vector(h->pdev, irq_vector),\n\t\t\t\t&h->q[h->intr_mode]);\n\t\th->q[h->intr_mode] = 0;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < h->msix_vectors; i++) {\n\t\tfree_irq(pci_irq_vector(h->pdev, i), &h->q[i]);\n\t\th->q[i] = 0;\n\t}\n\tfor (; i < MAX_REPLY_QUEUES; i++)\n\t\th->q[i] = 0;\n}\n\n/* returns 0 on success; cleans up and returns -Enn on error */\nstatic int hpsa_request_irqs(struct ctlr_info *h,\n\tirqreturn_t (*msixhandler)(int, void *),\n\tirqreturn_t (*intxhandler)(int, void *))\n{\n\tint rc, i;\n\tint irq_vector = 0;\n\n\tif (hpsa_simple_mode)\n\t\tirq_vector = h->intr_mode;\n\n\t/*\n\t * initialize h->q[x] = x so that interrupt handlers know which\n\t * queue to process.\n\t */\n\tfor (i = 0; i < MAX_REPLY_QUEUES; i++)\n\t\th->q[i] = (u8) i;\n\n\tif (h->intr_mode == PERF_MODE_INT && h->msix_vectors > 0) {\n\t\t/* If performant mode and MSI-X, use multiple reply queues */\n\t\tfor (i = 0; i < h->msix_vectors; i++) {\n\t\t\tsprintf(h->intrname[i], \"%s-msix%d\", h->devname, i);\n\t\t\trc = request_irq(pci_irq_vector(h->pdev, i), msixhandler,\n\t\t\t\t\t0, h->intrname[i],\n\t\t\t\t\t&h->q[i]);\n\t\t\tif (rc) {\n\t\t\t\tint j;\n\n\t\t\t\tdev_err(&h->pdev->dev,\n\t\t\t\t\t\"failed to get irq %d for %s\\n\",\n\t\t\t\t       pci_irq_vector(h->pdev, i), h->devname);\n\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\tfree_irq(pci_irq_vector(h->pdev, j), &h->q[j]);\n\t\t\t\t\th->q[j] = 0;\n\t\t\t\t}\n\t\t\t\tfor (; j < MAX_REPLY_QUEUES; j++)\n\t\t\t\t\th->q[j] = 0;\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Use single reply pool */\n\t\tif (h->msix_vectors > 0 || h->pdev->msi_enabled) {\n\t\t\tsprintf(h->intrname[0], \"%s-msi%s\", h->devname,\n\t\t\t\th->msix_vectors ? \"x\" : \"\");\n\t\t\trc = request_irq(pci_irq_vector(h->pdev, irq_vector),\n\t\t\t\tmsixhandler, 0,\n\t\t\t\th->intrname[0],\n\t\t\t\t&h->q[h->intr_mode]);\n\t\t} else {\n\t\t\tsprintf(h->intrname[h->intr_mode],\n\t\t\t\t\"%s-intx\", h->devname);\n\t\t\trc = request_irq(pci_irq_vector(h->pdev, irq_vector),\n\t\t\t\tintxhandler, IRQF_SHARED,\n\t\t\t\th->intrname[0],\n\t\t\t\t&h->q[h->intr_mode]);\n\t\t}\n\t}\n\tif (rc) {\n\t\tdev_err(&h->pdev->dev, \"failed to get irq %d for %s\\n\",\n\t\t       pci_irq_vector(h->pdev, irq_vector), h->devname);\n\t\thpsa_free_irqs(h);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int hpsa_kdump_soft_reset(struct ctlr_info *h)\n{\n\tint rc;\n\thpsa_send_host_reset(h, HPSA_RESET_TYPE_CONTROLLER);\n\n\tdev_info(&h->pdev->dev, \"Waiting for board to soft reset.\\n\");\n\trc = hpsa_wait_for_board_state(h->pdev, h->vaddr, BOARD_NOT_READY);\n\tif (rc) {\n\t\tdev_warn(&h->pdev->dev, \"Soft reset had no effect.\\n\");\n\t\treturn rc;\n\t}\n\n\tdev_info(&h->pdev->dev, \"Board reset, awaiting READY status.\\n\");\n\trc = hpsa_wait_for_board_state(h->pdev, h->vaddr, BOARD_READY);\n\tif (rc) {\n\t\tdev_warn(&h->pdev->dev, \"Board failed to become ready \"\n\t\t\t\"after soft reset.\\n\");\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void hpsa_free_reply_queues(struct ctlr_info *h)\n{\n\tint i;\n\n\tfor (i = 0; i < h->nreply_queues; i++) {\n\t\tif (!h->reply_queue[i].head)\n\t\t\tcontinue;\n\t\tdma_free_coherent(&h->pdev->dev,\n\t\t\t\t\th->reply_queue_size,\n\t\t\t\t\th->reply_queue[i].head,\n\t\t\t\t\th->reply_queue[i].busaddr);\n\t\th->reply_queue[i].head = NULL;\n\t\th->reply_queue[i].busaddr = 0;\n\t}\n\th->reply_queue_size = 0;\n}\n\nstatic void hpsa_undo_allocations_after_kdump_soft_reset(struct ctlr_info *h)\n{\n\thpsa_free_performant_mode(h);\t\t/* init_one 7 */\n\thpsa_free_sg_chain_blocks(h);\t\t/* init_one 6 */\n\thpsa_free_cmd_pool(h);\t\t\t/* init_one 5 */\n\thpsa_free_irqs(h);\t\t\t/* init_one 4 */\n\tscsi_host_put(h->scsi_host);\t\t/* init_one 3 */\n\th->scsi_host = NULL;\t\t\t/* init_one 3 */\n\thpsa_free_pci_init(h);\t\t\t/* init_one 2_5 */\n\tfree_percpu(h->lockup_detected);\t/* init_one 2 */\n\th->lockup_detected = NULL;\t\t/* init_one 2 */\n\tif (h->resubmit_wq) {\n\t\tdestroy_workqueue(h->resubmit_wq);\t/* init_one 1 */\n\t\th->resubmit_wq = NULL;\n\t}\n\tif (h->rescan_ctlr_wq) {\n\t\tdestroy_workqueue(h->rescan_ctlr_wq);\n\t\th->rescan_ctlr_wq = NULL;\n\t}\n\tif (h->monitor_ctlr_wq) {\n\t\tdestroy_workqueue(h->monitor_ctlr_wq);\n\t\th->monitor_ctlr_wq = NULL;\n\t}\n\n\tkfree(h);\t\t\t\t/* init_one 1 */\n}\n\n/* Called when controller lockup detected. */\nstatic void fail_all_outstanding_cmds(struct ctlr_info *h)\n{\n\tint i, refcount;\n\tstruct CommandList *c;\n\tint failcount = 0;\n\n\tflush_workqueue(h->resubmit_wq); /* ensure all cmds are fully built */\n\tfor (i = 0; i < h->nr_cmds; i++) {\n\t\tc = h->cmd_pool + i;\n\t\trefcount = atomic_inc_return(&c->refcount);\n\t\tif (refcount > 1) {\n\t\t\tc->err_info->CommandStatus = CMD_CTLR_LOCKUP;\n\t\t\tfinish_cmd(c);\n\t\t\tatomic_dec(&h->commands_outstanding);\n\t\t\tfailcount++;\n\t\t}\n\t\tcmd_free(h, c);\n\t}\n\tdev_warn(&h->pdev->dev,\n\t\t\"failed %d commands in fail_all\\n\", failcount);\n}\n\nstatic void set_lockup_detected_for_all_cpus(struct ctlr_info *h, u32 value)\n{\n\tint cpu;\n\n\tfor_each_online_cpu(cpu) {\n\t\tu32 *lockup_detected;\n\t\tlockup_detected = per_cpu_ptr(h->lockup_detected, cpu);\n\t\t*lockup_detected = value;\n\t}\n\twmb(); /* be sure the per-cpu variables are out to memory */\n}\n\nstatic void controller_lockup_detected(struct ctlr_info *h)\n{\n\tunsigned long flags;\n\tu32 lockup_detected;\n\n\th->access.set_intr_mask(h, HPSA_INTR_OFF);\n\tspin_lock_irqsave(&h->lock, flags);\n\tlockup_detected = readl(h->vaddr + SA5_SCRATCHPAD_OFFSET);\n\tif (!lockup_detected) {\n\t\t/* no heartbeat, but controller gave us a zero. */\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t\"lockup detected after %d but scratchpad register is zero\\n\",\n\t\t\th->heartbeat_sample_interval / HZ);\n\t\tlockup_detected = 0xffffffff;\n\t}\n\tset_lockup_detected_for_all_cpus(h, lockup_detected);\n\tspin_unlock_irqrestore(&h->lock, flags);\n\tdev_warn(&h->pdev->dev, \"Controller lockup detected: 0x%08x after %d\\n\",\n\t\t\tlockup_detected, h->heartbeat_sample_interval / HZ);\n\tif (lockup_detected == 0xffff0000) {\n\t\tdev_warn(&h->pdev->dev, \"Telling controller to do a CHKPT\\n\");\n\t\twritel(DOORBELL_GENERATE_CHKPT, h->vaddr + SA5_DOORBELL);\n\t}\n\tpci_disable_device(h->pdev);\n\tfail_all_outstanding_cmds(h);\n}\n\nstatic int detect_controller_lockup(struct ctlr_info *h)\n{\n\tu64 now;\n\tu32 heartbeat;\n\tunsigned long flags;\n\n\tnow = get_jiffies_64();\n\t/* If we've received an interrupt recently, we're ok. */\n\tif (time_after64(h->last_intr_timestamp +\n\t\t\t\t(h->heartbeat_sample_interval), now))\n\t\treturn false;\n\n\t/*\n\t * If we've already checked the heartbeat recently, we're ok.\n\t * This could happen if someone sends us a signal. We\n\t * otherwise don't care about signals in this thread.\n\t */\n\tif (time_after64(h->last_heartbeat_timestamp +\n\t\t\t\t(h->heartbeat_sample_interval), now))\n\t\treturn false;\n\n\t/* If heartbeat has not changed since we last looked, we're not ok. */\n\tspin_lock_irqsave(&h->lock, flags);\n\theartbeat = readl(&h->cfgtable->HeartBeat);\n\tspin_unlock_irqrestore(&h->lock, flags);\n\tif (h->last_heartbeat == heartbeat) {\n\t\tcontroller_lockup_detected(h);\n\t\treturn true;\n\t}\n\n\t/* We're ok. */\n\th->last_heartbeat = heartbeat;\n\th->last_heartbeat_timestamp = now;\n\treturn false;\n}\n\n/*\n * Set ioaccel status for all ioaccel volumes.\n *\n * Called from monitor controller worker (hpsa_event_monitor_worker)\n *\n * A Volume (or Volumes that comprise an Array set) may be undergoing a\n * transformation, so we will be turning off ioaccel for all volumes that\n * make up the Array.\n */\nstatic void hpsa_set_ioaccel_status(struct ctlr_info *h)\n{\n\tint rc;\n\tint i;\n\tu8 ioaccel_status;\n\tunsigned char *buf;\n\tstruct hpsa_scsi_dev_t *device;\n\n\tif (!h)\n\t\treturn;\n\n\tbuf = kmalloc(64, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\t/*\n\t * Run through current device list used during I/O requests.\n\t */\n\tfor (i = 0; i < h->ndevices; i++) {\n\t\tint offload_to_be_enabled = 0;\n\t\tint offload_config = 0;\n\n\t\tdevice = h->dev[i];\n\n\t\tif (!device)\n\t\t\tcontinue;\n\t\tif (!hpsa_vpd_page_supported(h, device->scsi3addr,\n\t\t\t\t\t\tHPSA_VPD_LV_IOACCEL_STATUS))\n\t\t\tcontinue;\n\n\t\tmemset(buf, 0, 64);\n\n\t\trc = hpsa_scsi_do_inquiry(h, device->scsi3addr,\n\t\t\t\t\tVPD_PAGE | HPSA_VPD_LV_IOACCEL_STATUS,\n\t\t\t\t\tbuf, 64);\n\t\tif (rc != 0)\n\t\t\tcontinue;\n\n\t\tioaccel_status = buf[IOACCEL_STATUS_BYTE];\n\n\t\t/*\n\t\t * Check if offload is still configured on\n\t\t */\n\t\toffload_config =\n\t\t\t\t!!(ioaccel_status & OFFLOAD_CONFIGURED_BIT);\n\t\t/*\n\t\t * If offload is configured on, check to see if ioaccel\n\t\t * needs to be enabled.\n\t\t */\n\t\tif (offload_config)\n\t\t\toffload_to_be_enabled =\n\t\t\t\t!!(ioaccel_status & OFFLOAD_ENABLED_BIT);\n\n\t\t/*\n\t\t * If ioaccel is to be re-enabled, re-enable later during the\n\t\t * scan operation so the driver can get a fresh raidmap\n\t\t * before turning ioaccel back on.\n\t\t */\n\t\tif (offload_to_be_enabled)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Immediately turn off ioaccel for any volume the\n\t\t * controller tells us to. Some of the reasons could be:\n\t\t *    transformation - change to the LVs of an Array.\n\t\t *    degraded volume - component failure\n\t\t */\n\t\thpsa_turn_off_ioaccel_for_device(device);\n\t}\n\n\tkfree(buf);\n}\n\nstatic void hpsa_ack_ctlr_events(struct ctlr_info *h)\n{\n\tchar *event_type;\n\n\tif (!(h->fw_support & MISC_FW_EVENT_NOTIFY))\n\t\treturn;\n\n\t/* Ask the controller to clear the events we're handling. */\n\tif ((h->transMethod & (CFGTBL_Trans_io_accel1\n\t\t\t| CFGTBL_Trans_io_accel2)) &&\n\t\t(h->events & HPSA_EVENT_NOTIFY_ACCEL_IO_PATH_STATE_CHANGE ||\n\t\t h->events & HPSA_EVENT_NOTIFY_ACCEL_IO_PATH_CONFIG_CHANGE)) {\n\n\t\tif (h->events & HPSA_EVENT_NOTIFY_ACCEL_IO_PATH_STATE_CHANGE)\n\t\t\tevent_type = \"state change\";\n\t\tif (h->events & HPSA_EVENT_NOTIFY_ACCEL_IO_PATH_CONFIG_CHANGE)\n\t\t\tevent_type = \"configuration change\";\n\t\t/* Stop sending new RAID offload reqs via the IO accelerator */\n\t\tscsi_block_requests(h->scsi_host);\n\t\thpsa_set_ioaccel_status(h);\n\t\thpsa_drain_accel_commands(h);\n\t\t/* Set 'accelerator path config change' bit */\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t\"Acknowledging event: 0x%08x (HP SSD Smart Path %s)\\n\",\n\t\t\th->events, event_type);\n\t\twritel(h->events, &(h->cfgtable->clear_event_notify));\n\t\t/* Set the \"clear event notify field update\" bit 6 */\n\t\twritel(DOORBELL_CLEAR_EVENTS, h->vaddr + SA5_DOORBELL);\n\t\t/* Wait until ctlr clears 'clear event notify field', bit 6 */\n\t\thpsa_wait_for_clear_event_notify_ack(h);\n\t\tscsi_unblock_requests(h->scsi_host);\n\t} else {\n\t\t/* Acknowledge controller notification events. */\n\t\twritel(h->events, &(h->cfgtable->clear_event_notify));\n\t\twritel(DOORBELL_CLEAR_EVENTS, h->vaddr + SA5_DOORBELL);\n\t\thpsa_wait_for_clear_event_notify_ack(h);\n\t}\n\treturn;\n}\n\n/* Check a register on the controller to see if there are configuration\n * changes (added/changed/removed logical drives, etc.) which mean that\n * we should rescan the controller for devices.\n * Also check flag for driver-initiated rescan.\n */\nstatic int hpsa_ctlr_needs_rescan(struct ctlr_info *h)\n{\n\tif (h->drv_req_rescan) {\n\t\th->drv_req_rescan = 0;\n\t\treturn 1;\n\t}\n\n\tif (!(h->fw_support & MISC_FW_EVENT_NOTIFY))\n\t\treturn 0;\n\n\th->events = readl(&(h->cfgtable->event_notify));\n\treturn h->events & RESCAN_REQUIRED_EVENT_BITS;\n}\n\n/*\n * Check if any of the offline devices have become ready\n */\nstatic int hpsa_offline_devices_ready(struct ctlr_info *h)\n{\n\tunsigned long flags;\n\tstruct offline_device_entry *d;\n\tstruct list_head *this, *tmp;\n\n\tspin_lock_irqsave(&h->offline_device_lock, flags);\n\tlist_for_each_safe(this, tmp, &h->offline_device_list) {\n\t\td = list_entry(this, struct offline_device_entry,\n\t\t\t\toffline_list);\n\t\tspin_unlock_irqrestore(&h->offline_device_lock, flags);\n\t\tif (!hpsa_volume_offline(h, d->scsi3addr)) {\n\t\t\tspin_lock_irqsave(&h->offline_device_lock, flags);\n\t\t\tlist_del(&d->offline_list);\n\t\t\tspin_unlock_irqrestore(&h->offline_device_lock, flags);\n\t\t\treturn 1;\n\t\t}\n\t\tspin_lock_irqsave(&h->offline_device_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&h->offline_device_lock, flags);\n\treturn 0;\n}\n\nstatic int hpsa_luns_changed(struct ctlr_info *h)\n{\n\tint rc = 1; /* assume there are changes */\n\tstruct ReportLUNdata *logdev = NULL;\n\n\t/* if we can't find out if lun data has changed,\n\t * assume that it has.\n\t */\n\n\tif (!h->lastlogicals)\n\t\treturn rc;\n\n\tlogdev = kzalloc(sizeof(*logdev), GFP_KERNEL);\n\tif (!logdev)\n\t\treturn rc;\n\n\tif (hpsa_scsi_do_report_luns(h, 1, logdev, sizeof(*logdev), 0)) {\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t\"report luns failed, can't track lun changes.\\n\");\n\t\tgoto out;\n\t}\n\tif (memcmp(logdev, h->lastlogicals, sizeof(*logdev))) {\n\t\tdev_info(&h->pdev->dev,\n\t\t\t\"Lun changes detected.\\n\");\n\t\tmemcpy(h->lastlogicals, logdev, sizeof(*logdev));\n\t\tgoto out;\n\t} else\n\t\trc = 0; /* no changes detected. */\nout:\n\tkfree(logdev);\n\treturn rc;\n}\n\nstatic void hpsa_perform_rescan(struct ctlr_info *h)\n{\n\tstruct Scsi_Host *sh = NULL;\n\tunsigned long flags;\n\n\t/*\n\t * Do the scan after the reset\n\t */\n\tspin_lock_irqsave(&h->reset_lock, flags);\n\tif (h->reset_in_progress) {\n\t\th->drv_req_rescan = 1;\n\t\tspin_unlock_irqrestore(&h->reset_lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&h->reset_lock, flags);\n\n\tsh = scsi_host_get(h->scsi_host);\n\tif (sh != NULL) {\n\t\thpsa_scan_start(sh);\n\t\tscsi_host_put(sh);\n\t\th->drv_req_rescan = 0;\n\t}\n}\n\n/*\n * watch for controller events\n */\nstatic void hpsa_event_monitor_worker(struct work_struct *work)\n{\n\tstruct ctlr_info *h = container_of(to_delayed_work(work),\n\t\t\t\t\tstruct ctlr_info, event_monitor_work);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tif (h->remove_in_progress) {\n\t\tspin_unlock_irqrestore(&h->lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&h->lock, flags);\n\n\tif (hpsa_ctlr_needs_rescan(h)) {\n\t\thpsa_ack_ctlr_events(h);\n\t\thpsa_perform_rescan(h);\n\t}\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tif (!h->remove_in_progress)\n\t\tqueue_delayed_work(h->monitor_ctlr_wq, &h->event_monitor_work,\n\t\t\t\tHPSA_EVENT_MONITOR_INTERVAL);\n\tspin_unlock_irqrestore(&h->lock, flags);\n}\n\nstatic void hpsa_rescan_ctlr_worker(struct work_struct *work)\n{\n\tunsigned long flags;\n\tstruct ctlr_info *h = container_of(to_delayed_work(work),\n\t\t\t\t\tstruct ctlr_info, rescan_ctlr_work);\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tif (h->remove_in_progress) {\n\t\tspin_unlock_irqrestore(&h->lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&h->lock, flags);\n\n\tif (h->drv_req_rescan || hpsa_offline_devices_ready(h)) {\n\t\thpsa_perform_rescan(h);\n\t} else if (h->discovery_polling) {\n\t\tif (hpsa_luns_changed(h)) {\n\t\t\tdev_info(&h->pdev->dev,\n\t\t\t\t\"driver discovery polling rescan.\\n\");\n\t\t\thpsa_perform_rescan(h);\n\t\t}\n\t}\n\tspin_lock_irqsave(&h->lock, flags);\n\tif (!h->remove_in_progress)\n\t\tqueue_delayed_work(h->rescan_ctlr_wq, &h->rescan_ctlr_work,\n\t\t\t\th->heartbeat_sample_interval);\n\tspin_unlock_irqrestore(&h->lock, flags);\n}\n\nstatic void hpsa_monitor_ctlr_worker(struct work_struct *work)\n{\n\tunsigned long flags;\n\tstruct ctlr_info *h = container_of(to_delayed_work(work),\n\t\t\t\t\tstruct ctlr_info, monitor_ctlr_work);\n\n\tdetect_controller_lockup(h);\n\tif (lockup_detected(h))\n\t\treturn;\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tif (!h->remove_in_progress)\n\t\tqueue_delayed_work(h->monitor_ctlr_wq, &h->monitor_ctlr_work,\n\t\t\t\th->heartbeat_sample_interval);\n\tspin_unlock_irqrestore(&h->lock, flags);\n}\n\nstatic struct workqueue_struct *hpsa_create_controller_wq(struct ctlr_info *h,\n\t\t\t\t\t\tchar *name)\n{\n\tstruct workqueue_struct *wq = NULL;\n\n\twq = alloc_ordered_workqueue(\"%s_%d_hpsa\", 0, name, h->ctlr);\n\tif (!wq)\n\t\tdev_err(&h->pdev->dev, \"failed to create %s workqueue\\n\", name);\n\n\treturn wq;\n}\n\nstatic void hpda_free_ctlr_info(struct ctlr_info *h)\n{\n\tkfree(h->reply_map);\n\tkfree(h);\n}\n\nstatic struct ctlr_info *hpda_alloc_ctlr_info(void)\n{\n\tstruct ctlr_info *h;\n\n\th = kzalloc(sizeof(*h), GFP_KERNEL);\n\tif (!h)\n\t\treturn NULL;\n\n\th->reply_map = kcalloc(nr_cpu_ids, sizeof(*h->reply_map), GFP_KERNEL);\n\tif (!h->reply_map) {\n\t\tkfree(h);\n\t\treturn NULL;\n\t}\n\treturn h;\n}\n\nstatic int hpsa_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint rc;\n\tstruct ctlr_info *h;\n\tint try_soft_reset = 0;\n\tunsigned long flags;\n\tu32 board_id;\n\n\tif (number_of_controllers == 0)\n\t\tprintk(KERN_INFO DRIVER_NAME \"\\n\");\n\n\trc = hpsa_lookup_board_id(pdev, &board_id, NULL);\n\tif (rc < 0) {\n\t\tdev_warn(&pdev->dev, \"Board ID not found\\n\");\n\t\treturn rc;\n\t}\n\n\trc = hpsa_init_reset_devices(pdev, board_id);\n\tif (rc) {\n\t\tif (rc != -ENOTSUPP)\n\t\t\treturn rc;\n\t\t/* If the reset fails in a particular way (it has no way to do\n\t\t * a proper hard reset, so returns -ENOTSUPP) we can try to do\n\t\t * a soft reset once we get the controller configured up to the\n\t\t * point that it can accept a command.\n\t\t */\n\t\ttry_soft_reset = 1;\n\t\trc = 0;\n\t}\n\nreinit_after_soft_reset:\n\n\t/* Command structures must be aligned on a 32-byte boundary because\n\t * the 5 lower bits of the address are used by the hardware. and by\n\t * the driver.  See comments in hpsa.h for more info.\n\t */\n\tBUILD_BUG_ON(sizeof(struct CommandList) % COMMANDLIST_ALIGNMENT);\n\th = hpda_alloc_ctlr_info();\n\tif (!h) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate controller head\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\th->pdev = pdev;\n\n\th->intr_mode = hpsa_simple_mode ? SIMPLE_MODE_INT : PERF_MODE_INT;\n\tINIT_LIST_HEAD(&h->offline_device_list);\n\tspin_lock_init(&h->lock);\n\tspin_lock_init(&h->offline_device_lock);\n\tspin_lock_init(&h->scan_lock);\n\tspin_lock_init(&h->reset_lock);\n\tatomic_set(&h->passthru_cmds_avail, HPSA_MAX_CONCURRENT_PASSTHRUS);\n\n\t/* Allocate and clear per-cpu variable lockup_detected */\n\th->lockup_detected = alloc_percpu(u32);\n\tif (!h->lockup_detected) {\n\t\tdev_err(&h->pdev->dev, \"Failed to allocate lockup detector\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto clean1;\t/* aer/h */\n\t}\n\tset_lockup_detected_for_all_cpus(h, 0);\n\n\trc = hpsa_pci_init(h);\n\tif (rc)\n\t\tgoto clean2;\t/* lu, aer/h */\n\n\t/* relies on h-> settings made by hpsa_pci_init, including\n\t * interrupt_mode h->intr */\n\trc = hpsa_scsi_host_alloc(h);\n\tif (rc)\n\t\tgoto clean2_5;\t/* pci, lu, aer/h */\n\n\tsprintf(h->devname, HPSA \"%d\", h->scsi_host->host_no);\n\th->ctlr = number_of_controllers;\n\tnumber_of_controllers++;\n\n\t/* configure PCI DMA stuff */\n\trc = dma_set_mask(&pdev->dev, DMA_BIT_MASK(64));\n\tif (rc != 0) {\n\t\trc = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (rc != 0) {\n\t\t\tdev_err(&pdev->dev, \"no suitable DMA available\\n\");\n\t\t\tgoto clean3;\t/* shost, pci, lu, aer/h */\n\t\t}\n\t}\n\n\t/* make sure the board interrupts are off */\n\th->access.set_intr_mask(h, HPSA_INTR_OFF);\n\n\trc = hpsa_request_irqs(h, do_hpsa_intr_msi, do_hpsa_intr_intx);\n\tif (rc)\n\t\tgoto clean3;\t/* shost, pci, lu, aer/h */\n\trc = hpsa_alloc_cmd_pool(h);\n\tif (rc)\n\t\tgoto clean4;\t/* irq, shost, pci, lu, aer/h */\n\trc = hpsa_alloc_sg_chain_blocks(h);\n\tif (rc)\n\t\tgoto clean5;\t/* cmd, irq, shost, pci, lu, aer/h */\n\tinit_waitqueue_head(&h->scan_wait_queue);\n\tinit_waitqueue_head(&h->event_sync_wait_queue);\n\tmutex_init(&h->reset_mutex);\n\th->scan_finished = 1; /* no scan currently in progress */\n\th->scan_waiting = 0;\n\n\tpci_set_drvdata(pdev, h);\n\th->ndevices = 0;\n\n\tspin_lock_init(&h->devlock);\n\trc = hpsa_put_ctlr_into_performant_mode(h);\n\tif (rc)\n\t\tgoto clean6; /* sg, cmd, irq, shost, pci, lu, aer/h */\n\n\t/* create the resubmit workqueue */\n\th->rescan_ctlr_wq = hpsa_create_controller_wq(h, \"rescan\");\n\tif (!h->rescan_ctlr_wq) {\n\t\trc = -ENOMEM;\n\t\tgoto clean7;\n\t}\n\n\th->resubmit_wq = hpsa_create_controller_wq(h, \"resubmit\");\n\tif (!h->resubmit_wq) {\n\t\trc = -ENOMEM;\n\t\tgoto clean7;\t/* aer/h */\n\t}\n\n\th->monitor_ctlr_wq = hpsa_create_controller_wq(h, \"monitor\");\n\tif (!h->monitor_ctlr_wq) {\n\t\trc = -ENOMEM;\n\t\tgoto clean7;\n\t}\n\n\t/*\n\t * At this point, the controller is ready to take commands.\n\t * Now, if reset_devices and the hard reset didn't work, try\n\t * the soft reset and see if that works.\n\t */\n\tif (try_soft_reset) {\n\n\t\t/* This is kind of gross.  We may or may not get a completion\n\t\t * from the soft reset command, and if we do, then the value\n\t\t * from the fifo may or may not be valid.  So, we wait 10 secs\n\t\t * after the reset throwing away any completions we get during\n\t\t * that time.  Unregister the interrupt handler and register\n\t\t * fake ones to scoop up any residual completions.\n\t\t */\n\t\tspin_lock_irqsave(&h->lock, flags);\n\t\th->access.set_intr_mask(h, HPSA_INTR_OFF);\n\t\tspin_unlock_irqrestore(&h->lock, flags);\n\t\thpsa_free_irqs(h);\n\t\trc = hpsa_request_irqs(h, hpsa_msix_discard_completions,\n\t\t\t\t\thpsa_intx_discard_completions);\n\t\tif (rc) {\n\t\t\tdev_warn(&h->pdev->dev,\n\t\t\t\t\"Failed to request_irq after soft reset.\\n\");\n\t\t\t/*\n\t\t\t * cannot goto clean7 or free_irqs will be called\n\t\t\t * again. Instead, do its work\n\t\t\t */\n\t\t\thpsa_free_performant_mode(h);\t/* clean7 */\n\t\t\thpsa_free_sg_chain_blocks(h);\t/* clean6 */\n\t\t\thpsa_free_cmd_pool(h);\t\t/* clean5 */\n\t\t\t/*\n\t\t\t * skip hpsa_free_irqs(h) clean4 since that\n\t\t\t * was just called before request_irqs failed\n\t\t\t */\n\t\t\tgoto clean3;\n\t\t}\n\n\t\trc = hpsa_kdump_soft_reset(h);\n\t\tif (rc)\n\t\t\t/* Neither hard nor soft reset worked, we're hosed. */\n\t\t\tgoto clean7;\n\n\t\tdev_info(&h->pdev->dev, \"Board READY.\\n\");\n\t\tdev_info(&h->pdev->dev,\n\t\t\t\"Waiting for stale completions to drain.\\n\");\n\t\th->access.set_intr_mask(h, HPSA_INTR_ON);\n\t\tmsleep(10000);\n\t\th->access.set_intr_mask(h, HPSA_INTR_OFF);\n\n\t\trc = controller_reset_failed(h->cfgtable);\n\t\tif (rc)\n\t\t\tdev_info(&h->pdev->dev,\n\t\t\t\t\"Soft reset appears to have failed.\\n\");\n\n\t\t/* since the controller's reset, we have to go back and re-init\n\t\t * everything.  Easiest to just forget what we've done and do it\n\t\t * all over again.\n\t\t */\n\t\thpsa_undo_allocations_after_kdump_soft_reset(h);\n\t\ttry_soft_reset = 0;\n\t\tif (rc)\n\t\t\t/* don't goto clean, we already unallocated */\n\t\t\treturn -ENODEV;\n\n\t\tgoto reinit_after_soft_reset;\n\t}\n\n\t/* Enable Accelerated IO path at driver layer */\n\th->acciopath_status = 1;\n\t/* Disable discovery polling.*/\n\th->discovery_polling = 0;\n\n\n\t/* Turn the interrupts on so we can service requests */\n\th->access.set_intr_mask(h, HPSA_INTR_ON);\n\n\thpsa_hba_inquiry(h);\n\n\th->lastlogicals = kzalloc(sizeof(*(h->lastlogicals)), GFP_KERNEL);\n\tif (!h->lastlogicals)\n\t\tdev_info(&h->pdev->dev,\n\t\t\t\"Can't track change to report lun data\\n\");\n\n\t/* hook into SCSI subsystem */\n\trc = hpsa_scsi_add_host(h);\n\tif (rc)\n\t\tgoto clean8; /* lastlogicals, perf, sg, cmd, irq, shost, pci, lu, aer/h */\n\n\t/* Monitor the controller for firmware lockups */\n\th->heartbeat_sample_interval = HEARTBEAT_SAMPLE_INTERVAL;\n\tINIT_DELAYED_WORK(&h->monitor_ctlr_work, hpsa_monitor_ctlr_worker);\n\tschedule_delayed_work(&h->monitor_ctlr_work,\n\t\t\t\th->heartbeat_sample_interval);\n\tINIT_DELAYED_WORK(&h->rescan_ctlr_work, hpsa_rescan_ctlr_worker);\n\tqueue_delayed_work(h->rescan_ctlr_wq, &h->rescan_ctlr_work,\n\t\t\t\th->heartbeat_sample_interval);\n\tINIT_DELAYED_WORK(&h->event_monitor_work, hpsa_event_monitor_worker);\n\tschedule_delayed_work(&h->event_monitor_work,\n\t\t\t\tHPSA_EVENT_MONITOR_INTERVAL);\n\treturn 0;\n\nclean8: /* lastlogicals, perf, sg, cmd, irq, shost, pci, lu, aer/h */\n\tkfree(h->lastlogicals);\nclean7: /* perf, sg, cmd, irq, shost, pci, lu, aer/h */\n\thpsa_free_performant_mode(h);\n\th->access.set_intr_mask(h, HPSA_INTR_OFF);\nclean6: /* sg, cmd, irq, pci, lockup, wq/aer/h */\n\thpsa_free_sg_chain_blocks(h);\nclean5: /* cmd, irq, shost, pci, lu, aer/h */\n\thpsa_free_cmd_pool(h);\nclean4: /* irq, shost, pci, lu, aer/h */\n\thpsa_free_irqs(h);\nclean3: /* shost, pci, lu, aer/h */\n\tscsi_host_put(h->scsi_host);\n\th->scsi_host = NULL;\nclean2_5: /* pci, lu, aer/h */\n\thpsa_free_pci_init(h);\nclean2: /* lu, aer/h */\n\tif (h->lockup_detected) {\n\t\tfree_percpu(h->lockup_detected);\n\t\th->lockup_detected = NULL;\n\t}\nclean1:\t/* wq/aer/h */\n\tif (h->resubmit_wq) {\n\t\tdestroy_workqueue(h->resubmit_wq);\n\t\th->resubmit_wq = NULL;\n\t}\n\tif (h->rescan_ctlr_wq) {\n\t\tdestroy_workqueue(h->rescan_ctlr_wq);\n\t\th->rescan_ctlr_wq = NULL;\n\t}\n\tif (h->monitor_ctlr_wq) {\n\t\tdestroy_workqueue(h->monitor_ctlr_wq);\n\t\th->monitor_ctlr_wq = NULL;\n\t}\n\tkfree(h);\n\treturn rc;\n}\n\nstatic void hpsa_flush_cache(struct ctlr_info *h)\n{\n\tchar *flush_buf;\n\tstruct CommandList *c;\n\tint rc;\n\n\tif (unlikely(lockup_detected(h)))\n\t\treturn;\n\tflush_buf = kzalloc(4, GFP_KERNEL);\n\tif (!flush_buf)\n\t\treturn;\n\n\tc = cmd_alloc(h);\n\n\tif (fill_cmd(c, HPSA_CACHE_FLUSH, h, flush_buf, 4, 0,\n\t\tRAID_CTLR_LUNID, TYPE_CMD)) {\n\t\tgoto out;\n\t}\n\trc = hpsa_scsi_do_simple_cmd_with_retry(h, c, DMA_TO_DEVICE,\n\t\t\tDEFAULT_TIMEOUT);\n\tif (rc)\n\t\tgoto out;\n\tif (c->err_info->CommandStatus != 0)\nout:\n\t\tdev_warn(&h->pdev->dev,\n\t\t\t\"error flushing cache on controller\\n\");\n\tcmd_free(h, c);\n\tkfree(flush_buf);\n}\n\n/* Make controller gather fresh report lun data each time we\n * send down a report luns request\n */\nstatic void hpsa_disable_rld_caching(struct ctlr_info *h)\n{\n\tu32 *options;\n\tstruct CommandList *c;\n\tint rc;\n\n\t/* Don't bother trying to set diag options if locked up */\n\tif (unlikely(h->lockup_detected))\n\t\treturn;\n\n\toptions = kzalloc(sizeof(*options), GFP_KERNEL);\n\tif (!options)\n\t\treturn;\n\n\tc = cmd_alloc(h);\n\n\t/* first, get the current diag options settings */\n\tif (fill_cmd(c, BMIC_SENSE_DIAG_OPTIONS, h, options, 4, 0,\n\t\tRAID_CTLR_LUNID, TYPE_CMD))\n\t\tgoto errout;\n\n\trc = hpsa_scsi_do_simple_cmd_with_retry(h, c, DMA_FROM_DEVICE,\n\t\t\tNO_TIMEOUT);\n\tif ((rc != 0) || (c->err_info->CommandStatus != 0))\n\t\tgoto errout;\n\n\t/* Now, set the bit for disabling the RLD caching */\n\t*options |= HPSA_DIAG_OPTS_DISABLE_RLD_CACHING;\n\n\tif (fill_cmd(c, BMIC_SET_DIAG_OPTIONS, h, options, 4, 0,\n\t\tRAID_CTLR_LUNID, TYPE_CMD))\n\t\tgoto errout;\n\n\trc = hpsa_scsi_do_simple_cmd_with_retry(h, c, DMA_TO_DEVICE,\n\t\t\tNO_TIMEOUT);\n\tif ((rc != 0)  || (c->err_info->CommandStatus != 0))\n\t\tgoto errout;\n\n\t/* Now verify that it got set: */\n\tif (fill_cmd(c, BMIC_SENSE_DIAG_OPTIONS, h, options, 4, 0,\n\t\tRAID_CTLR_LUNID, TYPE_CMD))\n\t\tgoto errout;\n\n\trc = hpsa_scsi_do_simple_cmd_with_retry(h, c, DMA_FROM_DEVICE,\n\t\t\tNO_TIMEOUT);\n\tif ((rc != 0)  || (c->err_info->CommandStatus != 0))\n\t\tgoto errout;\n\n\tif (*options & HPSA_DIAG_OPTS_DISABLE_RLD_CACHING)\n\t\tgoto out;\n\nerrout:\n\tdev_err(&h->pdev->dev,\n\t\t\t\"Error: failed to disable report lun data caching.\\n\");\nout:\n\tcmd_free(h, c);\n\tkfree(options);\n}\n\nstatic void __hpsa_shutdown(struct pci_dev *pdev)\n{\n\tstruct ctlr_info *h;\n\n\th = pci_get_drvdata(pdev);\n\t/* Turn board interrupts off  and send the flush cache command\n\t * sendcmd will turn off interrupt, and send the flush...\n\t * To write all data in the battery backed cache to disks\n\t */\n\thpsa_flush_cache(h);\n\th->access.set_intr_mask(h, HPSA_INTR_OFF);\n\thpsa_free_irqs(h);\t\t\t/* init_one 4 */\n\thpsa_disable_interrupt_mode(h);\t\t/* pci_init 2 */\n}\n\nstatic void hpsa_shutdown(struct pci_dev *pdev)\n{\n\t__hpsa_shutdown(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic void hpsa_free_device_info(struct ctlr_info *h)\n{\n\tint i;\n\n\tfor (i = 0; i < h->ndevices; i++) {\n\t\tkfree(h->dev[i]);\n\t\th->dev[i] = NULL;\n\t}\n}\n\nstatic void hpsa_remove_one(struct pci_dev *pdev)\n{\n\tstruct ctlr_info *h;\n\tunsigned long flags;\n\n\tif (pci_get_drvdata(pdev) == NULL) {\n\t\tdev_err(&pdev->dev, \"unable to remove device\\n\");\n\t\treturn;\n\t}\n\th = pci_get_drvdata(pdev);\n\n\t/* Get rid of any controller monitoring work items */\n\tspin_lock_irqsave(&h->lock, flags);\n\th->remove_in_progress = 1;\n\tspin_unlock_irqrestore(&h->lock, flags);\n\tcancel_delayed_work_sync(&h->monitor_ctlr_work);\n\tcancel_delayed_work_sync(&h->rescan_ctlr_work);\n\tcancel_delayed_work_sync(&h->event_monitor_work);\n\tdestroy_workqueue(h->rescan_ctlr_wq);\n\tdestroy_workqueue(h->resubmit_wq);\n\tdestroy_workqueue(h->monitor_ctlr_wq);\n\n\thpsa_delete_sas_host(h);\n\n\t/*\n\t * Call before disabling interrupts.\n\t * scsi_remove_host can trigger I/O operations especially\n\t * when multipath is enabled. There can be SYNCHRONIZE CACHE\n\t * operations which cannot complete and will hang the system.\n\t */\n\tif (h->scsi_host)\n\t\tscsi_remove_host(h->scsi_host);\t\t/* init_one 8 */\n\t/* includes hpsa_free_irqs - init_one 4 */\n\t/* includes hpsa_disable_interrupt_mode - pci_init 2 */\n\t__hpsa_shutdown(pdev);\n\n\thpsa_free_device_info(h);\t\t/* scan */\n\n\tkfree(h->hba_inquiry_data);\t\t\t/* init_one 10 */\n\th->hba_inquiry_data = NULL;\t\t\t/* init_one 10 */\n\thpsa_free_ioaccel2_sg_chain_blocks(h);\n\thpsa_free_performant_mode(h);\t\t\t/* init_one 7 */\n\thpsa_free_sg_chain_blocks(h);\t\t\t/* init_one 6 */\n\thpsa_free_cmd_pool(h);\t\t\t\t/* init_one 5 */\n\tkfree(h->lastlogicals);\n\n\t/* hpsa_free_irqs already called via hpsa_shutdown init_one 4 */\n\n\tscsi_host_put(h->scsi_host);\t\t\t/* init_one 3 */\n\th->scsi_host = NULL;\t\t\t\t/* init_one 3 */\n\n\t/* includes hpsa_disable_interrupt_mode - pci_init 2 */\n\thpsa_free_pci_init(h);\t\t\t\t/* init_one 2.5 */\n\n\tfree_percpu(h->lockup_detected);\t\t/* init_one 2 */\n\th->lockup_detected = NULL;\t\t\t/* init_one 2 */\n\t/* (void) pci_disable_pcie_error_reporting(pdev); */\t/* init_one 1 */\n\n\thpda_free_ctlr_info(h);\t\t\t\t/* init_one 1 */\n}\n\nstatic int __maybe_unused hpsa_suspend(\n\t__attribute__((unused)) struct device *dev)\n{\n\treturn -ENOSYS;\n}\n\nstatic int __maybe_unused hpsa_resume\n\t(__attribute__((unused)) struct device *dev)\n{\n\treturn -ENOSYS;\n}\n\nstatic SIMPLE_DEV_PM_OPS(hpsa_pm_ops, hpsa_suspend, hpsa_resume);\n\nstatic struct pci_driver hpsa_pci_driver = {\n\t.name = HPSA,\n\t.probe = hpsa_init_one,\n\t.remove = hpsa_remove_one,\n\t.id_table = hpsa_pci_device_id,\t/* id_table */\n\t.shutdown = hpsa_shutdown,\n\t.driver.pm = &hpsa_pm_ops,\n};\n\n/* Fill in bucket_map[], given nsgs (the max number of\n * scatter gather elements supported) and bucket[],\n * which is an array of 8 integers.  The bucket[] array\n * contains 8 different DMA transfer sizes (in 16\n * byte increments) which the controller uses to fetch\n * commands.  This function fills in bucket_map[], which\n * maps a given number of scatter gather elements to one of\n * the 8 DMA transfer sizes.  The point of it is to allow the\n * controller to only do as much DMA as needed to fetch the\n * command, with the DMA transfer size encoded in the lower\n * bits of the command address.\n */\nstatic void  calc_bucket_map(int bucket[], int num_buckets,\n\tint nsgs, int min_blocks, u32 *bucket_map)\n{\n\tint i, j, b, size;\n\n\t/* Note, bucket_map must have nsgs+1 entries. */\n\tfor (i = 0; i <= nsgs; i++) {\n\t\t/* Compute size of a command with i SG entries */\n\t\tsize = i + min_blocks;\n\t\tb = num_buckets; /* Assume the biggest bucket */\n\t\t/* Find the bucket that is just big enough */\n\t\tfor (j = 0; j < num_buckets; j++) {\n\t\t\tif (bucket[j] >= size) {\n\t\t\t\tb = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* for a command with i SG entries, use bucket b. */\n\t\tbucket_map[i] = b;\n\t}\n}\n\n/*\n * return -ENODEV on err, 0 on success (or no action)\n * allocates numerous items that must be freed later\n */\nstatic int hpsa_enter_performant_mode(struct ctlr_info *h, u32 trans_support)\n{\n\tint i;\n\tunsigned long register_value;\n\tunsigned long transMethod = CFGTBL_Trans_Performant |\n\t\t\t(trans_support & CFGTBL_Trans_use_short_tags) |\n\t\t\t\tCFGTBL_Trans_enable_directed_msix |\n\t\t\t(trans_support & (CFGTBL_Trans_io_accel1 |\n\t\t\t\tCFGTBL_Trans_io_accel2));\n\tstruct access_method access = SA5_performant_access;\n\n\t/* This is a bit complicated.  There are 8 registers on\n\t * the controller which we write to to tell it 8 different\n\t * sizes of commands which there may be.  It's a way of\n\t * reducing the DMA done to fetch each command.  Encoded into\n\t * each command's tag are 3 bits which communicate to the controller\n\t * which of the eight sizes that command fits within.  The size of\n\t * each command depends on how many scatter gather entries there are.\n\t * Each SG entry requires 16 bytes.  The eight registers are programmed\n\t * with the number of 16-byte blocks a command of that size requires.\n\t * The smallest command possible requires 5 such 16 byte blocks.\n\t * the largest command possible requires SG_ENTRIES_IN_CMD + 4 16-byte\n\t * blocks.  Note, this only extends to the SG entries contained\n\t * within the command block, and does not extend to chained blocks\n\t * of SG elements.   bft[] contains the eight values we write to\n\t * the registers.  They are not evenly distributed, but have more\n\t * sizes for small commands, and fewer sizes for larger commands.\n\t */\n\tint bft[8] = {5, 6, 8, 10, 12, 20, 28, SG_ENTRIES_IN_CMD + 4};\n#define MIN_IOACCEL2_BFT_ENTRY 5\n#define HPSA_IOACCEL2_HEADER_SZ 4\n\tint bft2[16] = {MIN_IOACCEL2_BFT_ENTRY, 6, 7, 8, 9, 10, 11, 12,\n\t\t\t13, 14, 15, 16, 17, 18, 19,\n\t\t\tHPSA_IOACCEL2_HEADER_SZ + IOACCEL2_MAXSGENTRIES};\n\tBUILD_BUG_ON(ARRAY_SIZE(bft2) != 16);\n\tBUILD_BUG_ON(ARRAY_SIZE(bft) != 8);\n\tBUILD_BUG_ON(offsetof(struct io_accel2_cmd, sg) >\n\t\t\t\t 16 * MIN_IOACCEL2_BFT_ENTRY);\n\tBUILD_BUG_ON(sizeof(struct ioaccel2_sg_element) != 16);\n\tBUILD_BUG_ON(28 > SG_ENTRIES_IN_CMD + 4);\n\t/*  5 = 1 s/g entry or 4k\n\t *  6 = 2 s/g entry or 8k\n\t *  8 = 4 s/g entry or 16k\n\t * 10 = 6 s/g entry or 24k\n\t */\n\n\t/* If the controller supports either ioaccel method then\n\t * we can also use the RAID stack submit path that does not\n\t * perform the superfluous readl() after each command submission.\n\t */\n\tif (trans_support & (CFGTBL_Trans_io_accel1 | CFGTBL_Trans_io_accel2))\n\t\taccess = SA5_performant_access_no_read;\n\n\t/* Controller spec: zero out this buffer. */\n\tfor (i = 0; i < h->nreply_queues; i++)\n\t\tmemset(h->reply_queue[i].head, 0, h->reply_queue_size);\n\n\tbft[7] = SG_ENTRIES_IN_CMD + 4;\n\tcalc_bucket_map(bft, ARRAY_SIZE(bft),\n\t\t\t\tSG_ENTRIES_IN_CMD, 4, h->blockFetchTable);\n\tfor (i = 0; i < 8; i++)\n\t\twritel(bft[i], &h->transtable->BlockFetch[i]);\n\n\t/* size of controller ring buffer */\n\twritel(h->max_commands, &h->transtable->RepQSize);\n\twritel(h->nreply_queues, &h->transtable->RepQCount);\n\twritel(0, &h->transtable->RepQCtrAddrLow32);\n\twritel(0, &h->transtable->RepQCtrAddrHigh32);\n\n\tfor (i = 0; i < h->nreply_queues; i++) {\n\t\twritel(0, &h->transtable->RepQAddr[i].upper);\n\t\twritel(h->reply_queue[i].busaddr,\n\t\t\t&h->transtable->RepQAddr[i].lower);\n\t}\n\n\twritel(0, &h->cfgtable->HostWrite.command_pool_addr_hi);\n\twritel(transMethod, &(h->cfgtable->HostWrite.TransportRequest));\n\t/*\n\t * enable outbound interrupt coalescing in accelerator mode;\n\t */\n\tif (trans_support & CFGTBL_Trans_io_accel1) {\n\t\taccess = SA5_ioaccel_mode1_access;\n\t\twritel(10, &h->cfgtable->HostWrite.CoalIntDelay);\n\t\twritel(4, &h->cfgtable->HostWrite.CoalIntCount);\n\t} else\n\t\tif (trans_support & CFGTBL_Trans_io_accel2)\n\t\t\taccess = SA5_ioaccel_mode2_access;\n\twritel(CFGTBL_ChangeReq, h->vaddr + SA5_DOORBELL);\n\tif (hpsa_wait_for_mode_change_ack(h)) {\n\t\tdev_err(&h->pdev->dev,\n\t\t\t\"performant mode problem - doorbell timeout\\n\");\n\t\treturn -ENODEV;\n\t}\n\tregister_value = readl(&(h->cfgtable->TransportActive));\n\tif (!(register_value & CFGTBL_Trans_Performant)) {\n\t\tdev_err(&h->pdev->dev,\n\t\t\t\"performant mode problem - transport not active\\n\");\n\t\treturn -ENODEV;\n\t}\n\t/* Change the access methods to the performant access methods */\n\th->access = access;\n\th->transMethod = transMethod;\n\n\tif (!((trans_support & CFGTBL_Trans_io_accel1) ||\n\t\t(trans_support & CFGTBL_Trans_io_accel2)))\n\t\treturn 0;\n\n\tif (trans_support & CFGTBL_Trans_io_accel1) {\n\t\t/* Set up I/O accelerator mode */\n\t\tfor (i = 0; i < h->nreply_queues; i++) {\n\t\t\twritel(i, h->vaddr + IOACCEL_MODE1_REPLY_QUEUE_INDEX);\n\t\t\th->reply_queue[i].current_entry =\n\t\t\t\treadl(h->vaddr + IOACCEL_MODE1_PRODUCER_INDEX);\n\t\t}\n\t\tbft[7] = h->ioaccel_maxsg + 8;\n\t\tcalc_bucket_map(bft, ARRAY_SIZE(bft), h->ioaccel_maxsg, 8,\n\t\t\t\th->ioaccel1_blockFetchTable);\n\n\t\t/* initialize all reply queue entries to unused */\n\t\tfor (i = 0; i < h->nreply_queues; i++)\n\t\t\tmemset(h->reply_queue[i].head,\n\t\t\t\t(u8) IOACCEL_MODE1_REPLY_UNUSED,\n\t\t\t\th->reply_queue_size);\n\n\t\t/* set all the constant fields in the accelerator command\n\t\t * frames once at init time to save CPU cycles later.\n\t\t */\n\t\tfor (i = 0; i < h->nr_cmds; i++) {\n\t\t\tstruct io_accel1_cmd *cp = &h->ioaccel_cmd_pool[i];\n\n\t\t\tcp->function = IOACCEL1_FUNCTION_SCSIIO;\n\t\t\tcp->err_info = (u32) (h->errinfo_pool_dhandle +\n\t\t\t\t\t(i * sizeof(struct ErrorInfo)));\n\t\t\tcp->err_info_len = sizeof(struct ErrorInfo);\n\t\t\tcp->sgl_offset = IOACCEL1_SGLOFFSET;\n\t\t\tcp->host_context_flags =\n\t\t\t\tcpu_to_le16(IOACCEL1_HCFLAGS_CISS_FORMAT);\n\t\t\tcp->timeout_sec = 0;\n\t\t\tcp->ReplyQueue = 0;\n\t\t\tcp->tag =\n\t\t\t\tcpu_to_le64((i << DIRECT_LOOKUP_SHIFT));\n\t\t\tcp->host_addr =\n\t\t\t\tcpu_to_le64(h->ioaccel_cmd_pool_dhandle +\n\t\t\t\t\t(i * sizeof(struct io_accel1_cmd)));\n\t\t}\n\t} else if (trans_support & CFGTBL_Trans_io_accel2) {\n\t\tu64 cfg_offset, cfg_base_addr_index;\n\t\tu32 bft2_offset, cfg_base_addr;\n\n\t\thpsa_find_cfg_addrs(h->pdev, h->vaddr, &cfg_base_addr,\n\t\t\t\t    &cfg_base_addr_index, &cfg_offset);\n\t\tBUILD_BUG_ON(offsetof(struct io_accel2_cmd, sg) != 64);\n\t\tbft2[15] = h->ioaccel_maxsg + HPSA_IOACCEL2_HEADER_SZ;\n\t\tcalc_bucket_map(bft2, ARRAY_SIZE(bft2), h->ioaccel_maxsg,\n\t\t\t\t4, h->ioaccel2_blockFetchTable);\n\t\tbft2_offset = readl(&h->cfgtable->io_accel_request_size_offset);\n\t\tBUILD_BUG_ON(offsetof(struct CfgTable,\n\t\t\t\tio_accel_request_size_offset) != 0xb8);\n\t\th->ioaccel2_bft2_regs =\n\t\t\tremap_pci_mem(pci_resource_start(h->pdev,\n\t\t\t\t\tcfg_base_addr_index) +\n\t\t\t\t\tcfg_offset + bft2_offset,\n\t\t\t\t\tARRAY_SIZE(bft2) *\n\t\t\t\t\tsizeof(*h->ioaccel2_bft2_regs));\n\t\tfor (i = 0; i < ARRAY_SIZE(bft2); i++)\n\t\t\twritel(bft2[i], &h->ioaccel2_bft2_regs[i]);\n\t}\n\twritel(CFGTBL_ChangeReq, h->vaddr + SA5_DOORBELL);\n\tif (hpsa_wait_for_mode_change_ack(h)) {\n\t\tdev_err(&h->pdev->dev,\n\t\t\t\"performant mode problem - enabling ioaccel mode\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\n/* Free ioaccel1 mode command blocks and block fetch table */\nstatic void hpsa_free_ioaccel1_cmd_and_bft(struct ctlr_info *h)\n{\n\tif (h->ioaccel_cmd_pool) {\n\t\tdma_free_coherent(&h->pdev->dev,\n\t\t\t\t  h->nr_cmds * sizeof(*h->ioaccel_cmd_pool),\n\t\t\t\t  h->ioaccel_cmd_pool,\n\t\t\t\t  h->ioaccel_cmd_pool_dhandle);\n\t\th->ioaccel_cmd_pool = NULL;\n\t\th->ioaccel_cmd_pool_dhandle = 0;\n\t}\n\tkfree(h->ioaccel1_blockFetchTable);\n\th->ioaccel1_blockFetchTable = NULL;\n}\n\n/* Allocate ioaccel1 mode command blocks and block fetch table */\nstatic int hpsa_alloc_ioaccel1_cmd_and_bft(struct ctlr_info *h)\n{\n\th->ioaccel_maxsg =\n\t\treadl(&(h->cfgtable->io_accel_max_embedded_sg_count));\n\tif (h->ioaccel_maxsg > IOACCEL1_MAXSGENTRIES)\n\t\th->ioaccel_maxsg = IOACCEL1_MAXSGENTRIES;\n\n\t/* Command structures must be aligned on a 128-byte boundary\n\t * because the 7 lower bits of the address are used by the\n\t * hardware.\n\t */\n\tBUILD_BUG_ON(sizeof(struct io_accel1_cmd) %\n\t\t\tIOACCEL1_COMMANDLIST_ALIGNMENT);\n\th->ioaccel_cmd_pool =\n\t\tdma_alloc_coherent(&h->pdev->dev,\n\t\t\th->nr_cmds * sizeof(*h->ioaccel_cmd_pool),\n\t\t\t&h->ioaccel_cmd_pool_dhandle, GFP_KERNEL);\n\n\th->ioaccel1_blockFetchTable =\n\t\tkmalloc(((h->ioaccel_maxsg + 1) *\n\t\t\t\tsizeof(u32)), GFP_KERNEL);\n\n\tif ((h->ioaccel_cmd_pool == NULL) ||\n\t\t(h->ioaccel1_blockFetchTable == NULL))\n\t\tgoto clean_up;\n\n\tmemset(h->ioaccel_cmd_pool, 0,\n\t\th->nr_cmds * sizeof(*h->ioaccel_cmd_pool));\n\treturn 0;\n\nclean_up:\n\thpsa_free_ioaccel1_cmd_and_bft(h);\n\treturn -ENOMEM;\n}\n\n/* Free ioaccel2 mode command blocks and block fetch table */\nstatic void hpsa_free_ioaccel2_cmd_and_bft(struct ctlr_info *h)\n{\n\thpsa_free_ioaccel2_sg_chain_blocks(h);\n\n\tif (h->ioaccel2_cmd_pool) {\n\t\tdma_free_coherent(&h->pdev->dev,\n\t\t\t\t  h->nr_cmds * sizeof(*h->ioaccel2_cmd_pool),\n\t\t\t\t  h->ioaccel2_cmd_pool,\n\t\t\t\t  h->ioaccel2_cmd_pool_dhandle);\n\t\th->ioaccel2_cmd_pool = NULL;\n\t\th->ioaccel2_cmd_pool_dhandle = 0;\n\t}\n\tkfree(h->ioaccel2_blockFetchTable);\n\th->ioaccel2_blockFetchTable = NULL;\n}\n\n/* Allocate ioaccel2 mode command blocks and block fetch table */\nstatic int hpsa_alloc_ioaccel2_cmd_and_bft(struct ctlr_info *h)\n{\n\tint rc;\n\n\t/* Allocate ioaccel2 mode command blocks and block fetch table */\n\n\th->ioaccel_maxsg =\n\t\treadl(&(h->cfgtable->io_accel_max_embedded_sg_count));\n\tif (h->ioaccel_maxsg > IOACCEL2_MAXSGENTRIES)\n\t\th->ioaccel_maxsg = IOACCEL2_MAXSGENTRIES;\n\n\tBUILD_BUG_ON(sizeof(struct io_accel2_cmd) %\n\t\t\tIOACCEL2_COMMANDLIST_ALIGNMENT);\n\th->ioaccel2_cmd_pool =\n\t\tdma_alloc_coherent(&h->pdev->dev,\n\t\t\th->nr_cmds * sizeof(*h->ioaccel2_cmd_pool),\n\t\t\t&h->ioaccel2_cmd_pool_dhandle, GFP_KERNEL);\n\n\th->ioaccel2_blockFetchTable =\n\t\tkmalloc(((h->ioaccel_maxsg + 1) *\n\t\t\t\tsizeof(u32)), GFP_KERNEL);\n\n\tif ((h->ioaccel2_cmd_pool == NULL) ||\n\t\t(h->ioaccel2_blockFetchTable == NULL)) {\n\t\trc = -ENOMEM;\n\t\tgoto clean_up;\n\t}\n\n\trc = hpsa_allocate_ioaccel2_sg_chain_blocks(h);\n\tif (rc)\n\t\tgoto clean_up;\n\n\tmemset(h->ioaccel2_cmd_pool, 0,\n\t\th->nr_cmds * sizeof(*h->ioaccel2_cmd_pool));\n\treturn 0;\n\nclean_up:\n\thpsa_free_ioaccel2_cmd_and_bft(h);\n\treturn rc;\n}\n\n/* Free items allocated by hpsa_put_ctlr_into_performant_mode */\nstatic void hpsa_free_performant_mode(struct ctlr_info *h)\n{\n\tkfree(h->blockFetchTable);\n\th->blockFetchTable = NULL;\n\thpsa_free_reply_queues(h);\n\thpsa_free_ioaccel1_cmd_and_bft(h);\n\thpsa_free_ioaccel2_cmd_and_bft(h);\n}\n\n/* return -ENODEV on error, 0 on success (or no action)\n * allocates numerous items that must be freed later\n */\nstatic int hpsa_put_ctlr_into_performant_mode(struct ctlr_info *h)\n{\n\tu32 trans_support;\n\tunsigned long transMethod = CFGTBL_Trans_Performant |\n\t\t\t\t\tCFGTBL_Trans_use_short_tags;\n\tint i, rc;\n\n\tif (hpsa_simple_mode)\n\t\treturn 0;\n\n\ttrans_support = readl(&(h->cfgtable->TransportSupport));\n\tif (!(trans_support & PERFORMANT_MODE))\n\t\treturn 0;\n\n\t/* Check for I/O accelerator mode support */\n\tif (trans_support & CFGTBL_Trans_io_accel1) {\n\t\ttransMethod |= CFGTBL_Trans_io_accel1 |\n\t\t\t\tCFGTBL_Trans_enable_directed_msix;\n\t\trc = hpsa_alloc_ioaccel1_cmd_and_bft(h);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else if (trans_support & CFGTBL_Trans_io_accel2) {\n\t\ttransMethod |= CFGTBL_Trans_io_accel2 |\n\t\t\t\tCFGTBL_Trans_enable_directed_msix;\n\t\trc = hpsa_alloc_ioaccel2_cmd_and_bft(h);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\th->nreply_queues = h->msix_vectors > 0 ? h->msix_vectors : 1;\n\thpsa_get_max_perf_mode_cmds(h);\n\t/* Performant mode ring buffer and supporting data structures */\n\th->reply_queue_size = h->max_commands * sizeof(u64);\n\n\tfor (i = 0; i < h->nreply_queues; i++) {\n\t\th->reply_queue[i].head = dma_alloc_coherent(&h->pdev->dev,\n\t\t\t\t\t\th->reply_queue_size,\n\t\t\t\t\t\t&h->reply_queue[i].busaddr,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!h->reply_queue[i].head) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto clean1;\t/* rq, ioaccel */\n\t\t}\n\t\th->reply_queue[i].size = h->max_commands;\n\t\th->reply_queue[i].wraparound = 1;  /* spec: init to 1 */\n\t\th->reply_queue[i].current_entry = 0;\n\t}\n\n\t/* Need a block fetch table for performant mode */\n\th->blockFetchTable = kmalloc(((SG_ENTRIES_IN_CMD + 1) *\n\t\t\t\tsizeof(u32)), GFP_KERNEL);\n\tif (!h->blockFetchTable) {\n\t\trc = -ENOMEM;\n\t\tgoto clean1;\t/* rq, ioaccel */\n\t}\n\n\trc = hpsa_enter_performant_mode(h, trans_support);\n\tif (rc)\n\t\tgoto clean2;\t/* bft, rq, ioaccel */\n\treturn 0;\n\nclean2:\t/* bft, rq, ioaccel */\n\tkfree(h->blockFetchTable);\n\th->blockFetchTable = NULL;\nclean1:\t/* rq, ioaccel */\n\thpsa_free_reply_queues(h);\n\thpsa_free_ioaccel1_cmd_and_bft(h);\n\thpsa_free_ioaccel2_cmd_and_bft(h);\n\treturn rc;\n}\n\nstatic int is_accelerated_cmd(struct CommandList *c)\n{\n\treturn c->cmd_type == CMD_IOACCEL1 || c->cmd_type == CMD_IOACCEL2;\n}\n\nstatic void hpsa_drain_accel_commands(struct ctlr_info *h)\n{\n\tstruct CommandList *c = NULL;\n\tint i, accel_cmds_out;\n\tint refcount;\n\n\tdo { /* wait for all outstanding ioaccel commands to drain out */\n\t\taccel_cmds_out = 0;\n\t\tfor (i = 0; i < h->nr_cmds; i++) {\n\t\t\tc = h->cmd_pool + i;\n\t\t\trefcount = atomic_inc_return(&c->refcount);\n\t\t\tif (refcount > 1) /* Command is allocated */\n\t\t\t\taccel_cmds_out += is_accelerated_cmd(c);\n\t\t\tcmd_free(h, c);\n\t\t}\n\t\tif (accel_cmds_out <= 0)\n\t\t\tbreak;\n\t\tmsleep(100);\n\t} while (1);\n}\n\nstatic struct hpsa_sas_phy *hpsa_alloc_sas_phy(\n\t\t\t\tstruct hpsa_sas_port *hpsa_sas_port)\n{\n\tstruct hpsa_sas_phy *hpsa_sas_phy;\n\tstruct sas_phy *phy;\n\n\thpsa_sas_phy = kzalloc(sizeof(*hpsa_sas_phy), GFP_KERNEL);\n\tif (!hpsa_sas_phy)\n\t\treturn NULL;\n\n\tphy = sas_phy_alloc(hpsa_sas_port->parent_node->parent_dev,\n\t\thpsa_sas_port->next_phy_index);\n\tif (!phy) {\n\t\tkfree(hpsa_sas_phy);\n\t\treturn NULL;\n\t}\n\n\thpsa_sas_port->next_phy_index++;\n\thpsa_sas_phy->phy = phy;\n\thpsa_sas_phy->parent_port = hpsa_sas_port;\n\n\treturn hpsa_sas_phy;\n}\n\nstatic void hpsa_free_sas_phy(struct hpsa_sas_phy *hpsa_sas_phy)\n{\n\tstruct sas_phy *phy = hpsa_sas_phy->phy;\n\n\tsas_port_delete_phy(hpsa_sas_phy->parent_port->port, phy);\n\tif (hpsa_sas_phy->added_to_port)\n\t\tlist_del(&hpsa_sas_phy->phy_list_entry);\n\tsas_phy_delete(phy);\n\tkfree(hpsa_sas_phy);\n}\n\nstatic int hpsa_sas_port_add_phy(struct hpsa_sas_phy *hpsa_sas_phy)\n{\n\tint rc;\n\tstruct hpsa_sas_port *hpsa_sas_port;\n\tstruct sas_phy *phy;\n\tstruct sas_identify *identify;\n\n\thpsa_sas_port = hpsa_sas_phy->parent_port;\n\tphy = hpsa_sas_phy->phy;\n\n\tidentify = &phy->identify;\n\tmemset(identify, 0, sizeof(*identify));\n\tidentify->sas_address = hpsa_sas_port->sas_address;\n\tidentify->device_type = SAS_END_DEVICE;\n\tidentify->initiator_port_protocols = SAS_PROTOCOL_STP;\n\tidentify->target_port_protocols = SAS_PROTOCOL_STP;\n\tphy->minimum_linkrate_hw = SAS_LINK_RATE_UNKNOWN;\n\tphy->maximum_linkrate_hw = SAS_LINK_RATE_UNKNOWN;\n\tphy->minimum_linkrate = SAS_LINK_RATE_UNKNOWN;\n\tphy->maximum_linkrate = SAS_LINK_RATE_UNKNOWN;\n\tphy->negotiated_linkrate = SAS_LINK_RATE_UNKNOWN;\n\n\trc = sas_phy_add(hpsa_sas_phy->phy);\n\tif (rc)\n\t\treturn rc;\n\n\tsas_port_add_phy(hpsa_sas_port->port, hpsa_sas_phy->phy);\n\tlist_add_tail(&hpsa_sas_phy->phy_list_entry,\n\t\t\t&hpsa_sas_port->phy_list_head);\n\thpsa_sas_phy->added_to_port = true;\n\n\treturn 0;\n}\n\nstatic int\n\thpsa_sas_port_add_rphy(struct hpsa_sas_port *hpsa_sas_port,\n\t\t\t\tstruct sas_rphy *rphy)\n{\n\tstruct sas_identify *identify;\n\n\tidentify = &rphy->identify;\n\tidentify->sas_address = hpsa_sas_port->sas_address;\n\tidentify->initiator_port_protocols = SAS_PROTOCOL_STP;\n\tidentify->target_port_protocols = SAS_PROTOCOL_STP;\n\n\treturn sas_rphy_add(rphy);\n}\n\nstatic struct hpsa_sas_port\n\t*hpsa_alloc_sas_port(struct hpsa_sas_node *hpsa_sas_node,\n\t\t\t\tu64 sas_address)\n{\n\tint rc;\n\tstruct hpsa_sas_port *hpsa_sas_port;\n\tstruct sas_port *port;\n\n\thpsa_sas_port = kzalloc(sizeof(*hpsa_sas_port), GFP_KERNEL);\n\tif (!hpsa_sas_port)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&hpsa_sas_port->phy_list_head);\n\thpsa_sas_port->parent_node = hpsa_sas_node;\n\n\tport = sas_port_alloc_num(hpsa_sas_node->parent_dev);\n\tif (!port)\n\t\tgoto free_hpsa_port;\n\n\trc = sas_port_add(port);\n\tif (rc)\n\t\tgoto free_sas_port;\n\n\thpsa_sas_port->port = port;\n\thpsa_sas_port->sas_address = sas_address;\n\tlist_add_tail(&hpsa_sas_port->port_list_entry,\n\t\t\t&hpsa_sas_node->port_list_head);\n\n\treturn hpsa_sas_port;\n\nfree_sas_port:\n\tsas_port_free(port);\nfree_hpsa_port:\n\tkfree(hpsa_sas_port);\n\n\treturn NULL;\n}\n\nstatic void hpsa_free_sas_port(struct hpsa_sas_port *hpsa_sas_port)\n{\n\tstruct hpsa_sas_phy *hpsa_sas_phy;\n\tstruct hpsa_sas_phy *next;\n\n\tlist_for_each_entry_safe(hpsa_sas_phy, next,\n\t\t\t&hpsa_sas_port->phy_list_head, phy_list_entry)\n\t\thpsa_free_sas_phy(hpsa_sas_phy);\n\n\tsas_port_delete(hpsa_sas_port->port);\n\tlist_del(&hpsa_sas_port->port_list_entry);\n\tkfree(hpsa_sas_port);\n}\n\nstatic struct hpsa_sas_node *hpsa_alloc_sas_node(struct device *parent_dev)\n{\n\tstruct hpsa_sas_node *hpsa_sas_node;\n\n\thpsa_sas_node = kzalloc(sizeof(*hpsa_sas_node), GFP_KERNEL);\n\tif (hpsa_sas_node) {\n\t\thpsa_sas_node->parent_dev = parent_dev;\n\t\tINIT_LIST_HEAD(&hpsa_sas_node->port_list_head);\n\t}\n\n\treturn hpsa_sas_node;\n}\n\nstatic void hpsa_free_sas_node(struct hpsa_sas_node *hpsa_sas_node)\n{\n\tstruct hpsa_sas_port *hpsa_sas_port;\n\tstruct hpsa_sas_port *next;\n\n\tif (!hpsa_sas_node)\n\t\treturn;\n\n\tlist_for_each_entry_safe(hpsa_sas_port, next,\n\t\t\t&hpsa_sas_node->port_list_head, port_list_entry)\n\t\thpsa_free_sas_port(hpsa_sas_port);\n\n\tkfree(hpsa_sas_node);\n}\n\nstatic struct hpsa_scsi_dev_t\n\t*hpsa_find_device_by_sas_rphy(struct ctlr_info *h,\n\t\t\t\t\tstruct sas_rphy *rphy)\n{\n\tint i;\n\tstruct hpsa_scsi_dev_t *device;\n\n\tfor (i = 0; i < h->ndevices; i++) {\n\t\tdevice = h->dev[i];\n\t\tif (!device->sas_port)\n\t\t\tcontinue;\n\t\tif (device->sas_port->rphy == rphy)\n\t\t\treturn device;\n\t}\n\n\treturn NULL;\n}\n\nstatic int hpsa_add_sas_host(struct ctlr_info *h)\n{\n\tint rc;\n\tstruct device *parent_dev;\n\tstruct hpsa_sas_node *hpsa_sas_node;\n\tstruct hpsa_sas_port *hpsa_sas_port;\n\tstruct hpsa_sas_phy *hpsa_sas_phy;\n\n\tparent_dev = &h->scsi_host->shost_dev;\n\n\thpsa_sas_node = hpsa_alloc_sas_node(parent_dev);\n\tif (!hpsa_sas_node)\n\t\treturn -ENOMEM;\n\n\thpsa_sas_port = hpsa_alloc_sas_port(hpsa_sas_node, h->sas_address);\n\tif (!hpsa_sas_port) {\n\t\trc = -ENODEV;\n\t\tgoto free_sas_node;\n\t}\n\n\thpsa_sas_phy = hpsa_alloc_sas_phy(hpsa_sas_port);\n\tif (!hpsa_sas_phy) {\n\t\trc = -ENODEV;\n\t\tgoto free_sas_port;\n\t}\n\n\trc = hpsa_sas_port_add_phy(hpsa_sas_phy);\n\tif (rc)\n\t\tgoto free_sas_phy;\n\n\th->sas_host = hpsa_sas_node;\n\n\treturn 0;\n\nfree_sas_phy:\n\thpsa_free_sas_phy(hpsa_sas_phy);\nfree_sas_port:\n\thpsa_free_sas_port(hpsa_sas_port);\nfree_sas_node:\n\thpsa_free_sas_node(hpsa_sas_node);\n\n\treturn rc;\n}\n\nstatic void hpsa_delete_sas_host(struct ctlr_info *h)\n{\n\thpsa_free_sas_node(h->sas_host);\n}\n\nstatic int hpsa_add_sas_device(struct hpsa_sas_node *hpsa_sas_node,\n\t\t\t\tstruct hpsa_scsi_dev_t *device)\n{\n\tint rc;\n\tstruct hpsa_sas_port *hpsa_sas_port;\n\tstruct sas_rphy *rphy;\n\n\thpsa_sas_port = hpsa_alloc_sas_port(hpsa_sas_node, device->sas_address);\n\tif (!hpsa_sas_port)\n\t\treturn -ENOMEM;\n\n\trphy = sas_end_device_alloc(hpsa_sas_port->port);\n\tif (!rphy) {\n\t\trc = -ENODEV;\n\t\tgoto free_sas_port;\n\t}\n\n\thpsa_sas_port->rphy = rphy;\n\tdevice->sas_port = hpsa_sas_port;\n\n\trc = hpsa_sas_port_add_rphy(hpsa_sas_port, rphy);\n\tif (rc)\n\t\tgoto free_sas_port;\n\n\treturn 0;\n\nfree_sas_port:\n\thpsa_free_sas_port(hpsa_sas_port);\n\tdevice->sas_port = NULL;\n\n\treturn rc;\n}\n\nstatic void hpsa_remove_sas_device(struct hpsa_scsi_dev_t *device)\n{\n\tif (device->sas_port) {\n\t\thpsa_free_sas_port(device->sas_port);\n\t\tdevice->sas_port = NULL;\n\t}\n}\n\nstatic int\nhpsa_sas_get_linkerrors(struct sas_phy *phy)\n{\n\treturn 0;\n}\n\nstatic int\nhpsa_sas_get_enclosure_identifier(struct sas_rphy *rphy, u64 *identifier)\n{\n\tstruct Scsi_Host *shost = phy_to_shost(rphy);\n\tstruct ctlr_info *h;\n\tstruct hpsa_scsi_dev_t *sd;\n\n\tif (!shost)\n\t\treturn -ENXIO;\n\n\th = shost_to_hba(shost);\n\n\tif (!h)\n\t\treturn -ENXIO;\n\n\tsd = hpsa_find_device_by_sas_rphy(h, rphy);\n\tif (!sd)\n\t\treturn -ENXIO;\n\n\t*identifier = sd->eli;\n\n\treturn 0;\n}\n\nstatic int\nhpsa_sas_get_bay_identifier(struct sas_rphy *rphy)\n{\n\treturn -ENXIO;\n}\n\nstatic int\nhpsa_sas_phy_reset(struct sas_phy *phy, int hard_reset)\n{\n\treturn 0;\n}\n\nstatic int\nhpsa_sas_phy_enable(struct sas_phy *phy, int enable)\n{\n\treturn 0;\n}\n\nstatic int\nhpsa_sas_phy_setup(struct sas_phy *phy)\n{\n\treturn 0;\n}\n\nstatic void\nhpsa_sas_phy_release(struct sas_phy *phy)\n{\n}\n\nstatic int\nhpsa_sas_phy_speed(struct sas_phy *phy, struct sas_phy_linkrates *rates)\n{\n\treturn -EINVAL;\n}\n\nstatic struct sas_function_template hpsa_sas_transport_functions = {\n\t.get_linkerrors = hpsa_sas_get_linkerrors,\n\t.get_enclosure_identifier = hpsa_sas_get_enclosure_identifier,\n\t.get_bay_identifier = hpsa_sas_get_bay_identifier,\n\t.phy_reset = hpsa_sas_phy_reset,\n\t.phy_enable = hpsa_sas_phy_enable,\n\t.phy_setup = hpsa_sas_phy_setup,\n\t.phy_release = hpsa_sas_phy_release,\n\t.set_phy_speed = hpsa_sas_phy_speed,\n};\n\n/*\n *  This is it.  Register the PCI driver information for the cards we control\n *  the OS will call our registered routines when it finds one of our cards.\n */\nstatic int __init hpsa_init(void)\n{\n\tint rc;\n\n\thpsa_sas_transport_template =\n\t\tsas_attach_transport(&hpsa_sas_transport_functions);\n\tif (!hpsa_sas_transport_template)\n\t\treturn -ENODEV;\n\n\trc = pci_register_driver(&hpsa_pci_driver);\n\n\tif (rc)\n\t\tsas_release_transport(hpsa_sas_transport_template);\n\n\treturn rc;\n}\n\nstatic void __exit hpsa_cleanup(void)\n{\n\tpci_unregister_driver(&hpsa_pci_driver);\n\tsas_release_transport(hpsa_sas_transport_template);\n}\n\nstatic void __attribute__((unused)) verify_offsets(void)\n{\n#define VERIFY_OFFSET(member, offset) \\\n\tBUILD_BUG_ON(offsetof(struct raid_map_data, member) != offset)\n\n\tVERIFY_OFFSET(structure_size, 0);\n\tVERIFY_OFFSET(volume_blk_size, 4);\n\tVERIFY_OFFSET(volume_blk_cnt, 8);\n\tVERIFY_OFFSET(phys_blk_shift, 16);\n\tVERIFY_OFFSET(parity_rotation_shift, 17);\n\tVERIFY_OFFSET(strip_size, 18);\n\tVERIFY_OFFSET(disk_starting_blk, 20);\n\tVERIFY_OFFSET(disk_blk_cnt, 28);\n\tVERIFY_OFFSET(data_disks_per_row, 36);\n\tVERIFY_OFFSET(metadata_disks_per_row, 38);\n\tVERIFY_OFFSET(row_cnt, 40);\n\tVERIFY_OFFSET(layout_map_count, 42);\n\tVERIFY_OFFSET(flags, 44);\n\tVERIFY_OFFSET(dekindex, 46);\n\t/* VERIFY_OFFSET(reserved, 48 */\n\tVERIFY_OFFSET(data, 64);\n\n#undef VERIFY_OFFSET\n\n#define VERIFY_OFFSET(member, offset) \\\n\tBUILD_BUG_ON(offsetof(struct io_accel2_cmd, member) != offset)\n\n\tVERIFY_OFFSET(IU_type, 0);\n\tVERIFY_OFFSET(direction, 1);\n\tVERIFY_OFFSET(reply_queue, 2);\n\t/* VERIFY_OFFSET(reserved1, 3);  */\n\tVERIFY_OFFSET(scsi_nexus, 4);\n\tVERIFY_OFFSET(Tag, 8);\n\tVERIFY_OFFSET(cdb, 16);\n\tVERIFY_OFFSET(cciss_lun, 32);\n\tVERIFY_OFFSET(data_len, 40);\n\tVERIFY_OFFSET(cmd_priority_task_attr, 44);\n\tVERIFY_OFFSET(sg_count, 45);\n\t/* VERIFY_OFFSET(reserved3 */\n\tVERIFY_OFFSET(err_ptr, 48);\n\tVERIFY_OFFSET(err_len, 56);\n\t/* VERIFY_OFFSET(reserved4  */\n\tVERIFY_OFFSET(sg, 64);\n\n#undef VERIFY_OFFSET\n\n#define VERIFY_OFFSET(member, offset) \\\n\tBUILD_BUG_ON(offsetof(struct io_accel1_cmd, member) != offset)\n\n\tVERIFY_OFFSET(dev_handle, 0x00);\n\tVERIFY_OFFSET(reserved1, 0x02);\n\tVERIFY_OFFSET(function, 0x03);\n\tVERIFY_OFFSET(reserved2, 0x04);\n\tVERIFY_OFFSET(err_info, 0x0C);\n\tVERIFY_OFFSET(reserved3, 0x10);\n\tVERIFY_OFFSET(err_info_len, 0x12);\n\tVERIFY_OFFSET(reserved4, 0x13);\n\tVERIFY_OFFSET(sgl_offset, 0x14);\n\tVERIFY_OFFSET(reserved5, 0x15);\n\tVERIFY_OFFSET(transfer_len, 0x1C);\n\tVERIFY_OFFSET(reserved6, 0x20);\n\tVERIFY_OFFSET(io_flags, 0x24);\n\tVERIFY_OFFSET(reserved7, 0x26);\n\tVERIFY_OFFSET(LUN, 0x34);\n\tVERIFY_OFFSET(control, 0x3C);\n\tVERIFY_OFFSET(CDB, 0x40);\n\tVERIFY_OFFSET(reserved8, 0x50);\n\tVERIFY_OFFSET(host_context_flags, 0x60);\n\tVERIFY_OFFSET(timeout_sec, 0x62);\n\tVERIFY_OFFSET(ReplyQueue, 0x64);\n\tVERIFY_OFFSET(reserved9, 0x65);\n\tVERIFY_OFFSET(tag, 0x68);\n\tVERIFY_OFFSET(host_addr, 0x70);\n\tVERIFY_OFFSET(CISS_LUN, 0x78);\n\tVERIFY_OFFSET(SG, 0x78 + 8);\n#undef VERIFY_OFFSET\n}\n\nmodule_init(hpsa_init);\nmodule_exit(hpsa_cleanup);\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 0, "line": 539}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/hpsa.c", "reportHash": "710ec000c470f6466960dca0626d0ee3", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 899}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/hpsa.c", "reportHash": "823273e4d41c46a0fc23348028351af6", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 529}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/hpsa.c", "reportHash": "6effb92b19eed45a341026e444129df9", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 0, "line": 800}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/hpsa.c", "reportHash": "0ec93414aa7e4842928d5c6ff8c70592", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 562}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/hpsa.c", "reportHash": "74128054467bd22f7c3527dd2e0d3a15", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 909}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/hpsa.c", "reportHash": "93694910a20913fe319933999ad55233", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 646}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/hpsa.c", "reportHash": "1dd34f9bfd9d3b7adc95d877d30469f4", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 550}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/hpsa.c", "reportHash": "2f58f7605857bdd9d643d04d433d0553", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 725}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/hpsa.c", "reportHash": "6a999f960cf75e43953a0068de6a2b0c", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 776}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/hpsa.c", "reportHash": "41c91599945e86c1a88d5a972304f620", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 747}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/hpsa.c", "reportHash": "f752edf8eb73815b60d8ee8f26bb7de7", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
