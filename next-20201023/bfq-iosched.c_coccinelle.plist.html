<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/block/bfq-iosched.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Budget Fair Queueing (BFQ) I/O scheduler.\n *\n * Based on ideas and code from CFQ:\n * Copyright (C) 2003 Jens Axboe <axboe@kernel.dk>\n *\n * Copyright (C) 2008 Fabio Checconi <fabio@gandalf.sssup.it>\n *\t\t      Paolo Valente <paolo.valente@unimore.it>\n *\n * Copyright (C) 2010 Paolo Valente <paolo.valente@unimore.it>\n *                    Arianna Avanzini <avanzini@google.com>\n *\n * Copyright (C) 2017 Paolo Valente <paolo.valente@linaro.org>\n *\n * BFQ is a proportional-share I/O scheduler, with some extra\n * low-latency capabilities. BFQ also supports full hierarchical\n * scheduling through cgroups. Next paragraphs provide an introduction\n * on BFQ inner workings. Details on BFQ benefits, usage and\n * limitations can be found in Documentation/block/bfq-iosched.rst.\n *\n * BFQ is a proportional-share storage-I/O scheduling algorithm based\n * on the slice-by-slice service scheme of CFQ. But BFQ assigns\n * budgets, measured in number of sectors, to processes instead of\n * time slices. The device is not granted to the in-service process\n * for a given time slice, but until it has exhausted its assigned\n * budget. This change from the time to the service domain enables BFQ\n * to distribute the device throughput among processes as desired,\n * without any distortion due to throughput fluctuations, or to device\n * internal queueing. BFQ uses an ad hoc internal scheduler, called\n * B-WF2Q+, to schedule processes according to their budgets. More\n * precisely, BFQ schedules queues associated with processes. Each\n * process/queue is assigned a user-configurable weight, and B-WF2Q+\n * guarantees that each queue receives a fraction of the throughput\n * proportional to its weight. Thanks to the accurate policy of\n * B-WF2Q+, BFQ can afford to assign high budgets to I/O-bound\n * processes issuing sequential requests (to boost the throughput),\n * and yet guarantee a low latency to interactive and soft real-time\n * applications.\n *\n * In particular, to provide these low-latency guarantees, BFQ\n * explicitly privileges the I/O of two classes of time-sensitive\n * applications: interactive and soft real-time. In more detail, BFQ\n * behaves this way if the low_latency parameter is set (default\n * configuration). This feature enables BFQ to provide applications in\n * these classes with a very low latency.\n *\n * To implement this feature, BFQ constantly tries to detect whether\n * the I/O requests in a bfq_queue come from an interactive or a soft\n * real-time application. For brevity, in these cases, the queue is\n * said to be interactive or soft real-time. In both cases, BFQ\n * privileges the service of the queue, over that of non-interactive\n * and non-soft-real-time queues. This privileging is performed,\n * mainly, by raising the weight of the queue. So, for brevity, we\n * call just weight-raising periods the time periods during which a\n * queue is privileged, because deemed interactive or soft real-time.\n *\n * The detection of soft real-time queues/applications is described in\n * detail in the comments on the function\n * bfq_bfqq_softrt_next_start. On the other hand, the detection of an\n * interactive queue works as follows: a queue is deemed interactive\n * if it is constantly non empty only for a limited time interval,\n * after which it does become empty. The queue may be deemed\n * interactive again (for a limited time), if it restarts being\n * constantly non empty, provided that this happens only after the\n * queue has remained empty for a given minimum idle time.\n *\n * By default, BFQ computes automatically the above maximum time\n * interval, i.e., the time interval after which a constantly\n * non-empty queue stops being deemed interactive. Since a queue is\n * weight-raised while it is deemed interactive, this maximum time\n * interval happens to coincide with the (maximum) duration of the\n * weight-raising for interactive queues.\n *\n * Finally, BFQ also features additional heuristics for\n * preserving both a low latency and a high throughput on NCQ-capable,\n * rotational or flash-based devices, and to get the job done quickly\n * for applications consisting in many I/O-bound processes.\n *\n * NOTE: if the main or only goal, with a given device, is to achieve\n * the maximum-possible throughput at all times, then do switch off\n * all low-latency heuristics for that device, by setting low_latency\n * to 0.\n *\n * BFQ is described in [1], where also a reference to the initial,\n * more theoretical paper on BFQ can be found. The interested reader\n * can find in the latter paper full details on the main algorithm, as\n * well as formulas of the guarantees and formal proofs of all the\n * properties.  With respect to the version of BFQ presented in these\n * papers, this implementation adds a few more heuristics, such as the\n * ones that guarantee a low latency to interactive and soft real-time\n * applications, and a hierarchical extension based on H-WF2Q+.\n *\n * B-WF2Q+ is based on WF2Q+, which is described in [2], together with\n * H-WF2Q+, while the augmented tree used here to implement B-WF2Q+\n * with O(log N) complexity derives from the one introduced with EEVDF\n * in [3].\n *\n * [1] P. Valente, A. Avanzini, \"Evolution of the BFQ Storage I/O\n *     Scheduler\", Proceedings of the First Workshop on Mobile System\n *     Technologies (MST-2015), May 2015.\n *     http://algogroup.unimore.it/people/paolo/disk_sched/mst-2015.pdf\n *\n * [2] Jon C.R. Bennett and H. Zhang, \"Hierarchical Packet Fair Queueing\n *     Algorithms\", IEEE/ACM Transactions on Networking, 5(5):675-689,\n *     Oct 1997.\n *\n * http://www.cs.cmu.edu/~hzhang/papers/TON-97-Oct.ps.gz\n *\n * [3] I. Stoica and H. Abdel-Wahab, \"Earliest Eligible Virtual Deadline\n *     First: A Flexible and Accurate Mechanism for Proportional Share\n *     Resource Allocation\", technical report.\n *\n * http://www.cs.berkeley.edu/~istoica/papers/eevdf-tr-95.pdf\n */\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/cgroup.h>\n#include <linux/elevator.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/ioprio.h>\n#include <linux/sbitmap.h>\n#include <linux/delay.h>\n#include <linux/backing-dev.h>\n\n#include \"blk.h\"\n#include \"blk-mq.h\"\n#include \"blk-mq-tag.h\"\n#include \"blk-mq-sched.h\"\n#include \"bfq-iosched.h\"\n#include \"blk-wbt.h\"\n\n#define BFQ_BFQQ_FNS(name)\t\t\t\t\t\t\\\nvoid bfq_mark_bfqq_##name(struct bfq_queue *bfqq)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t__set_bit(BFQQF_##name, &(bfqq)->flags);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nvoid bfq_clear_bfqq_##name(struct bfq_queue *bfqq)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t__clear_bit(BFQQF_##name, &(bfqq)->flags);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nint bfq_bfqq_##name(const struct bfq_queue *bfqq)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn test_bit(BFQQF_##name, &(bfqq)->flags);\t\t\\\n}\n\nBFQ_BFQQ_FNS(just_created);\nBFQ_BFQQ_FNS(busy);\nBFQ_BFQQ_FNS(wait_request);\nBFQ_BFQQ_FNS(non_blocking_wait_rq);\nBFQ_BFQQ_FNS(fifo_expire);\nBFQ_BFQQ_FNS(has_short_ttime);\nBFQ_BFQQ_FNS(sync);\nBFQ_BFQQ_FNS(IO_bound);\nBFQ_BFQQ_FNS(in_large_burst);\nBFQ_BFQQ_FNS(coop);\nBFQ_BFQQ_FNS(split_coop);\nBFQ_BFQQ_FNS(softrt_update);\nBFQ_BFQQ_FNS(has_waker);\n#undef BFQ_BFQQ_FNS\t\t\t\t\t\t\\\n\n/* Expiration time of sync (0) and async (1) requests, in ns. */\nstatic const u64 bfq_fifo_expire[2] = { NSEC_PER_SEC / 4, NSEC_PER_SEC / 8 };\n\n/* Maximum backwards seek (magic number lifted from CFQ), in KiB. */\nstatic const int bfq_back_max = 16 * 1024;\n\n/* Penalty of a backwards seek, in number of sectors. */\nstatic const int bfq_back_penalty = 2;\n\n/* Idling period duration, in ns. */\nstatic u64 bfq_slice_idle = NSEC_PER_SEC / 125;\n\n/* Minimum number of assigned budgets for which stats are safe to compute. */\nstatic const int bfq_stats_min_budgets = 194;\n\n/* Default maximum budget values, in sectors and number of requests. */\nstatic const int bfq_default_max_budget = 16 * 1024;\n\n/*\n * When a sync request is dispatched, the queue that contains that\n * request, and all the ancestor entities of that queue, are charged\n * with the number of sectors of the request. In contrast, if the\n * request is async, then the queue and its ancestor entities are\n * charged with the number of sectors of the request, multiplied by\n * the factor below. This throttles the bandwidth for async I/O,\n * w.r.t. to sync I/O, and it is done to counter the tendency of async\n * writes to steal I/O throughput to reads.\n *\n * The current value of this parameter is the result of a tuning with\n * several hardware and software configurations. We tried to find the\n * lowest value for which writes do not cause noticeable problems to\n * reads. In fact, the lower this parameter, the stabler I/O control,\n * in the following respect.  The lower this parameter is, the less\n * the bandwidth enjoyed by a group decreases\n * - when the group does writes, w.r.t. to when it does reads;\n * - when other groups do reads, w.r.t. to when they do writes.\n */\nstatic const int bfq_async_charge_factor = 3;\n\n/* Default timeout values, in jiffies, approximating CFQ defaults. */\nconst int bfq_timeout = HZ / 8;\n\n/*\n * Time limit for merging (see comments in bfq_setup_cooperator). Set\n * to the slowest value that, in our tests, proved to be effective in\n * removing false positives, while not causing true positives to miss\n * queue merging.\n *\n * As can be deduced from the low time limit below, queue merging, if\n * successful, happens at the very beginning of the I/O of the involved\n * cooperating processes, as a consequence of the arrival of the very\n * first requests from each cooperator.  After that, there is very\n * little chance to find cooperators.\n */\nstatic const unsigned long bfq_merge_time_limit = HZ/10;\n\nstatic struct kmem_cache *bfq_pool;\n\n/* Below this threshold (in ns), we consider thinktime immediate. */\n#define BFQ_MIN_TT\t\t(2 * NSEC_PER_MSEC)\n\n/* hw_tag detection: parallel requests threshold and min samples needed. */\n#define BFQ_HW_QUEUE_THRESHOLD\t3\n#define BFQ_HW_QUEUE_SAMPLES\t32\n\n#define BFQQ_SEEK_THR\t\t(sector_t)(8 * 100)\n#define BFQQ_SECT_THR_NONROT\t(sector_t)(2 * 32)\n#define BFQ_RQ_SEEKY(bfqd, last_pos, rq) \\\n\t(get_sdist(last_pos, rq) >\t\t\t\\\n\t BFQQ_SEEK_THR &&\t\t\t\t\\\n\t (!blk_queue_nonrot(bfqd->queue) ||\t\t\\\n\t  blk_rq_sectors(rq) < BFQQ_SECT_THR_NONROT))\n#define BFQQ_CLOSE_THR\t\t(sector_t)(8 * 1024)\n#define BFQQ_SEEKY(bfqq)\t(hweight32(bfqq->seek_history) > 19)\n/*\n * Sync random I/O is likely to be confused with soft real-time I/O,\n * because it is characterized by limited throughput and apparently\n * isochronous arrival pattern. To avoid false positives, queues\n * containing only random (seeky) I/O are prevented from being tagged\n * as soft real-time.\n */\n#define BFQQ_TOTALLY_SEEKY(bfqq)\t(bfqq->seek_history == -1)\n\n/* Min number of samples required to perform peak-rate update */\n#define BFQ_RATE_MIN_SAMPLES\t32\n/* Min observation time interval required to perform a peak-rate update (ns) */\n#define BFQ_RATE_MIN_INTERVAL\t(300*NSEC_PER_MSEC)\n/* Target observation time interval for a peak-rate update (ns) */\n#define BFQ_RATE_REF_INTERVAL\tNSEC_PER_SEC\n\n/*\n * Shift used for peak-rate fixed precision calculations.\n * With\n * - the current shift: 16 positions\n * - the current type used to store rate: u32\n * - the current unit of measure for rate: [sectors/usec], or, more precisely,\n *   [(sectors/usec) / 2^BFQ_RATE_SHIFT] to take into account the shift,\n * the range of rates that can be stored is\n * [1 / 2^BFQ_RATE_SHIFT, 2^(32 - BFQ_RATE_SHIFT)] sectors/usec =\n * [1 / 2^16, 2^16] sectors/usec = [15e-6, 65536] sectors/usec =\n * [15, 65G] sectors/sec\n * Which, assuming a sector size of 512B, corresponds to a range of\n * [7.5K, 33T] B/sec\n */\n#define BFQ_RATE_SHIFT\t\t16\n\n/*\n * When configured for computing the duration of the weight-raising\n * for interactive queues automatically (see the comments at the\n * beginning of this file), BFQ does it using the following formula:\n * duration = (ref_rate / r) * ref_wr_duration,\n * where r is the peak rate of the device, and ref_rate and\n * ref_wr_duration are two reference parameters.  In particular,\n * ref_rate is the peak rate of the reference storage device (see\n * below), and ref_wr_duration is about the maximum time needed, with\n * BFQ and while reading two files in parallel, to load typical large\n * applications on the reference device (see the comments on\n * max_service_from_wr below, for more details on how ref_wr_duration\n * is obtained).  In practice, the slower/faster the device at hand\n * is, the more/less it takes to load applications with respect to the\n * reference device.  Accordingly, the longer/shorter BFQ grants\n * weight raising to interactive applications.\n *\n * BFQ uses two different reference pairs (ref_rate, ref_wr_duration),\n * depending on whether the device is rotational or non-rotational.\n *\n * In the following definitions, ref_rate[0] and ref_wr_duration[0]\n * are the reference values for a rotational device, whereas\n * ref_rate[1] and ref_wr_duration[1] are the reference values for a\n * non-rotational device. The reference rates are not the actual peak\n * rates of the devices used as a reference, but slightly lower\n * values. The reason for using slightly lower values is that the\n * peak-rate estimator tends to yield slightly lower values than the\n * actual peak rate (it can yield the actual peak rate only if there\n * is only one process doing I/O, and the process does sequential\n * I/O).\n *\n * The reference peak rates are measured in sectors/usec, left-shifted\n * by BFQ_RATE_SHIFT.\n */\nstatic int ref_rate[2] = {14000, 33000};\n/*\n * To improve readability, a conversion function is used to initialize\n * the following array, which entails that the array can be\n * initialized only in a function.\n */\nstatic int ref_wr_duration[2];\n\n/*\n * BFQ uses the above-detailed, time-based weight-raising mechanism to\n * privilege interactive tasks. This mechanism is vulnerable to the\n * following false positives: I/O-bound applications that will go on\n * doing I/O for much longer than the duration of weight\n * raising. These applications have basically no benefit from being\n * weight-raised at the beginning of their I/O. On the opposite end,\n * while being weight-raised, these applications\n * a) unjustly steal throughput to applications that may actually need\n * low latency;\n * b) make BFQ uselessly perform device idling; device idling results\n * in loss of device throughput with most flash-based storage, and may\n * increase latencies when used purposelessly.\n *\n * BFQ tries to reduce these problems, by adopting the following\n * countermeasure. To introduce this countermeasure, we need first to\n * finish explaining how the duration of weight-raising for\n * interactive tasks is computed.\n *\n * For a bfq_queue deemed as interactive, the duration of weight\n * raising is dynamically adjusted, as a function of the estimated\n * peak rate of the device, so as to be equal to the time needed to\n * execute the 'largest' interactive task we benchmarked so far. By\n * largest task, we mean the task for which each involved process has\n * to do more I/O than for any of the other tasks we benchmarked. This\n * reference interactive task is the start-up of LibreOffice Writer,\n * and in this task each process/bfq_queue needs to have at most ~110K\n * sectors transferred.\n *\n * This last piece of information enables BFQ to reduce the actual\n * duration of weight-raising for at least one class of I/O-bound\n * applications: those doing sequential or quasi-sequential I/O. An\n * example is file copy. In fact, once started, the main I/O-bound\n * processes of these applications usually consume the above 110K\n * sectors in much less time than the processes of an application that\n * is starting, because these I/O-bound processes will greedily devote\n * almost all their CPU cycles only to their target,\n * throughput-friendly I/O operations. This is even more true if BFQ\n * happens to be underestimating the device peak rate, and thus\n * overestimating the duration of weight raising. But, according to\n * our measurements, once transferred 110K sectors, these processes\n * have no right to be weight-raised any longer.\n *\n * Basing on the last consideration, BFQ ends weight-raising for a\n * bfq_queue if the latter happens to have received an amount of\n * service at least equal to the following constant. The constant is\n * set to slightly more than 110K, to have a minimum safety margin.\n *\n * This early ending of weight-raising reduces the amount of time\n * during which interactive false positives cause the two problems\n * described at the beginning of these comments.\n */\nstatic const unsigned long max_service_from_wr = 120000;\n\n#define RQ_BIC(rq)\t\ticq_to_bic((rq)->elv.priv[0])\n#define RQ_BFQQ(rq)\t\t((rq)->elv.priv[1])\n\nstruct bfq_queue *bic_to_bfqq(struct bfq_io_cq *bic, bool is_sync)\n{\n\treturn bic->bfqq[is_sync];\n}\n\nvoid bic_set_bfqq(struct bfq_io_cq *bic, struct bfq_queue *bfqq, bool is_sync)\n{\n\tbic->bfqq[is_sync] = bfqq;\n}\n\nstruct bfq_data *bic_to_bfqd(struct bfq_io_cq *bic)\n{\n\treturn bic->icq.q->elevator->elevator_data;\n}\n\n/**\n * icq_to_bic - convert iocontext queue structure to bfq_io_cq.\n * @icq: the iocontext queue.\n */\nstatic struct bfq_io_cq *icq_to_bic(struct io_cq *icq)\n{\n\t/* bic->icq is the first member, %NULL will convert to %NULL */\n\treturn container_of(icq, struct bfq_io_cq, icq);\n}\n\n/**\n * bfq_bic_lookup - search into @ioc a bic associated to @bfqd.\n * @bfqd: the lookup key.\n * @ioc: the io_context of the process doing I/O.\n * @q: the request queue.\n */\nstatic struct bfq_io_cq *bfq_bic_lookup(struct bfq_data *bfqd,\n\t\t\t\t\tstruct io_context *ioc,\n\t\t\t\t\tstruct request_queue *q)\n{\n\tif (ioc) {\n\t\tunsigned long flags;\n\t\tstruct bfq_io_cq *icq;\n\n\t\tspin_lock_irqsave(&q->queue_lock, flags);\n\t\ticq = icq_to_bic(ioc_lookup_icq(ioc, q));\n\t\tspin_unlock_irqrestore(&q->queue_lock, flags);\n\n\t\treturn icq;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * Scheduler run of queue, if there are requests pending and no one in the\n * driver that will restart queueing.\n */\nvoid bfq_schedule_dispatch(struct bfq_data *bfqd)\n{\n\tif (bfqd->queued != 0) {\n\t\tbfq_log(bfqd, \"schedule dispatch\");\n\t\tblk_mq_run_hw_queues(bfqd->queue, true);\n\t}\n}\n\n#define bfq_class_idle(bfqq)\t((bfqq)->ioprio_class == IOPRIO_CLASS_IDLE)\n\n#define bfq_sample_valid(samples)\t((samples) > 80)\n\n/*\n * Lifted from AS - choose which of rq1 and rq2 that is best served now.\n * We choose the request that is closer to the head right now.  Distance\n * behind the head is penalized and only allowed to a certain extent.\n */\nstatic struct request *bfq_choose_req(struct bfq_data *bfqd,\n\t\t\t\t      struct request *rq1,\n\t\t\t\t      struct request *rq2,\n\t\t\t\t      sector_t last)\n{\n\tsector_t s1, s2, d1 = 0, d2 = 0;\n\tunsigned long back_max;\n#define BFQ_RQ1_WRAP\t0x01 /* request 1 wraps */\n#define BFQ_RQ2_WRAP\t0x02 /* request 2 wraps */\n\tunsigned int wrap = 0; /* bit mask: requests behind the disk head? */\n\n\tif (!rq1 || rq1 == rq2)\n\t\treturn rq2;\n\tif (!rq2)\n\t\treturn rq1;\n\n\tif (rq_is_sync(rq1) && !rq_is_sync(rq2))\n\t\treturn rq1;\n\telse if (rq_is_sync(rq2) && !rq_is_sync(rq1))\n\t\treturn rq2;\n\tif ((rq1->cmd_flags & REQ_META) && !(rq2->cmd_flags & REQ_META))\n\t\treturn rq1;\n\telse if ((rq2->cmd_flags & REQ_META) && !(rq1->cmd_flags & REQ_META))\n\t\treturn rq2;\n\n\ts1 = blk_rq_pos(rq1);\n\ts2 = blk_rq_pos(rq2);\n\n\t/*\n\t * By definition, 1KiB is 2 sectors.\n\t */\n\tback_max = bfqd->bfq_back_max * 2;\n\n\t/*\n\t * Strict one way elevator _except_ in the case where we allow\n\t * short backward seeks which are biased as twice the cost of a\n\t * similar forward seek.\n\t */\n\tif (s1 >= last)\n\t\td1 = s1 - last;\n\telse if (s1 + back_max >= last)\n\t\td1 = (last - s1) * bfqd->bfq_back_penalty;\n\telse\n\t\twrap |= BFQ_RQ1_WRAP;\n\n\tif (s2 >= last)\n\t\td2 = s2 - last;\n\telse if (s2 + back_max >= last)\n\t\td2 = (last - s2) * bfqd->bfq_back_penalty;\n\telse\n\t\twrap |= BFQ_RQ2_WRAP;\n\n\t/* Found required data */\n\n\t/*\n\t * By doing switch() on the bit mask \"wrap\" we avoid having to\n\t * check two variables for all permutations: --> faster!\n\t */\n\tswitch (wrap) {\n\tcase 0: /* common case for CFQ: rq1 and rq2 not wrapped */\n\t\tif (d1 < d2)\n\t\t\treturn rq1;\n\t\telse if (d2 < d1)\n\t\t\treturn rq2;\n\n\t\tif (s1 >= s2)\n\t\t\treturn rq1;\n\t\telse\n\t\t\treturn rq2;\n\n\tcase BFQ_RQ2_WRAP:\n\t\treturn rq1;\n\tcase BFQ_RQ1_WRAP:\n\t\treturn rq2;\n\tcase BFQ_RQ1_WRAP|BFQ_RQ2_WRAP: /* both rqs wrapped */\n\tdefault:\n\t\t/*\n\t\t * Since both rqs are wrapped,\n\t\t * start with the one that's further behind head\n\t\t * (--> only *one* back seek required),\n\t\t * since back seek takes more time than forward.\n\t\t */\n\t\tif (s1 <= s2)\n\t\t\treturn rq1;\n\t\telse\n\t\t\treturn rq2;\n\t}\n}\n\n/*\n * Async I/O can easily starve sync I/O (both sync reads and sync\n * writes), by consuming all tags. Similarly, storms of sync writes,\n * such as those that sync(2) may trigger, can starve sync reads.\n * Limit depths of async I/O and sync writes so as to counter both\n * problems.\n */\nstatic void bfq_limit_depth(unsigned int op, struct blk_mq_alloc_data *data)\n{\n\tstruct bfq_data *bfqd = data->q->elevator->elevator_data;\n\n\tif (op_is_sync(op) && !op_is_write(op))\n\t\treturn;\n\n\tdata->shallow_depth =\n\t\tbfqd->word_depths[!!bfqd->wr_busy_queues][op_is_sync(op)];\n\n\tbfq_log(bfqd, \"[%s] wr_busy %d sync %d depth %u\",\n\t\t\t__func__, bfqd->wr_busy_queues, op_is_sync(op),\n\t\t\tdata->shallow_depth);\n}\n\nstatic struct bfq_queue *\nbfq_rq_pos_tree_lookup(struct bfq_data *bfqd, struct rb_root *root,\n\t\t     sector_t sector, struct rb_node **ret_parent,\n\t\t     struct rb_node ***rb_link)\n{\n\tstruct rb_node **p, *parent;\n\tstruct bfq_queue *bfqq = NULL;\n\n\tparent = NULL;\n\tp = &root->rb_node;\n\twhile (*p) {\n\t\tstruct rb_node **n;\n\n\t\tparent = *p;\n\t\tbfqq = rb_entry(parent, struct bfq_queue, pos_node);\n\n\t\t/*\n\t\t * Sort strictly based on sector. Smallest to the left,\n\t\t * largest to the right.\n\t\t */\n\t\tif (sector > blk_rq_pos(bfqq->next_rq))\n\t\t\tn = &(*p)->rb_right;\n\t\telse if (sector < blk_rq_pos(bfqq->next_rq))\n\t\t\tn = &(*p)->rb_left;\n\t\telse\n\t\t\tbreak;\n\t\tp = n;\n\t\tbfqq = NULL;\n\t}\n\n\t*ret_parent = parent;\n\tif (rb_link)\n\t\t*rb_link = p;\n\n\tbfq_log(bfqd, \"rq_pos_tree_lookup %llu: returning %d\",\n\t\t(unsigned long long)sector,\n\t\tbfqq ? bfqq->pid : 0);\n\n\treturn bfqq;\n}\n\nstatic bool bfq_too_late_for_merging(struct bfq_queue *bfqq)\n{\n\treturn bfqq->service_from_backlogged > 0 &&\n\t\ttime_is_before_jiffies(bfqq->first_IO_time +\n\t\t\t\t       bfq_merge_time_limit);\n}\n\n/*\n * The following function is not marked as __cold because it is\n * actually cold, but for the same performance goal described in the\n * comments on the likely() at the beginning of\n * bfq_setup_cooperator(). Unexpectedly, to reach an even lower\n * execution time for the case where this function is not invoked, we\n * had to add an unlikely() in each involved if().\n */\nvoid __cold\nbfq_pos_tree_add_move(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\tstruct rb_node **p, *parent;\n\tstruct bfq_queue *__bfqq;\n\n\tif (bfqq->pos_root) {\n\t\trb_erase(&bfqq->pos_node, bfqq->pos_root);\n\t\tbfqq->pos_root = NULL;\n\t}\n\n\t/* oom_bfqq does not participate in queue merging */\n\tif (bfqq == &bfqd->oom_bfqq)\n\t\treturn;\n\n\t/*\n\t * bfqq cannot be merged any longer (see comments in\n\t * bfq_setup_cooperator): no point in adding bfqq into the\n\t * position tree.\n\t */\n\tif (bfq_too_late_for_merging(bfqq))\n\t\treturn;\n\n\tif (bfq_class_idle(bfqq))\n\t\treturn;\n\tif (!bfqq->next_rq)\n\t\treturn;\n\n\tbfqq->pos_root = &bfq_bfqq_to_bfqg(bfqq)->rq_pos_tree;\n\t__bfqq = bfq_rq_pos_tree_lookup(bfqd, bfqq->pos_root,\n\t\t\tblk_rq_pos(bfqq->next_rq), &parent, &p);\n\tif (!__bfqq) {\n\t\trb_link_node(&bfqq->pos_node, parent, p);\n\t\trb_insert_color(&bfqq->pos_node, bfqq->pos_root);\n\t} else\n\t\tbfqq->pos_root = NULL;\n}\n\n/*\n * The following function returns false either if every active queue\n * must receive the same share of the throughput (symmetric scenario),\n * or, as a special case, if bfqq must receive a share of the\n * throughput lower than or equal to the share that every other active\n * queue must receive.  If bfqq does sync I/O, then these are the only\n * two cases where bfqq happens to be guaranteed its share of the\n * throughput even if I/O dispatching is not plugged when bfqq remains\n * temporarily empty (for more details, see the comments in the\n * function bfq_better_to_idle()). For this reason, the return value\n * of this function is used to check whether I/O-dispatch plugging can\n * be avoided.\n *\n * The above first case (symmetric scenario) occurs when:\n * 1) all active queues have the same weight,\n * 2) all active queues belong to the same I/O-priority class,\n * 3) all active groups at the same level in the groups tree have the same\n *    weight,\n * 4) all active groups at the same level in the groups tree have the same\n *    number of children.\n *\n * Unfortunately, keeping the necessary state for evaluating exactly\n * the last two symmetry sub-conditions above would be quite complex\n * and time consuming. Therefore this function evaluates, instead,\n * only the following stronger three sub-conditions, for which it is\n * much easier to maintain the needed state:\n * 1) all active queues have the same weight,\n * 2) all active queues belong to the same I/O-priority class,\n * 3) there are no active groups.\n * In particular, the last condition is always true if hierarchical\n * support or the cgroups interface are not enabled, thus no state\n * needs to be maintained in this case.\n */\nstatic bool bfq_asymmetric_scenario(struct bfq_data *bfqd,\n\t\t\t\t   struct bfq_queue *bfqq)\n{\n\tbool smallest_weight = bfqq &&\n\t\tbfqq->weight_counter &&\n\t\tbfqq->weight_counter ==\n\t\tcontainer_of(\n\t\t\trb_first_cached(&bfqd->queue_weights_tree),\n\t\t\tstruct bfq_weight_counter,\n\t\t\tweights_node);\n\n\t/*\n\t * For queue weights to differ, queue_weights_tree must contain\n\t * at least two nodes.\n\t */\n\tbool varied_queue_weights = !smallest_weight &&\n\t\t!RB_EMPTY_ROOT(&bfqd->queue_weights_tree.rb_root) &&\n\t\t(bfqd->queue_weights_tree.rb_root.rb_node->rb_left ||\n\t\t bfqd->queue_weights_tree.rb_root.rb_node->rb_right);\n\n\tbool multiple_classes_busy =\n\t\t(bfqd->busy_queues[0] && bfqd->busy_queues[1]) ||\n\t\t(bfqd->busy_queues[0] && bfqd->busy_queues[2]) ||\n\t\t(bfqd->busy_queues[1] && bfqd->busy_queues[2]);\n\n\treturn varied_queue_weights || multiple_classes_busy\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\t       || bfqd->num_groups_with_pending_reqs > 0\n#endif\n\t\t;\n}\n\n/*\n * If the weight-counter tree passed as input contains no counter for\n * the weight of the input queue, then add that counter; otherwise just\n * increment the existing counter.\n *\n * Note that weight-counter trees contain few nodes in mostly symmetric\n * scenarios. For example, if all queues have the same weight, then the\n * weight-counter tree for the queues may contain at most one node.\n * This holds even if low_latency is on, because weight-raised queues\n * are not inserted in the tree.\n * In most scenarios, the rate at which nodes are created/destroyed\n * should be low too.\n */\nvoid bfq_weights_tree_add(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t\t  struct rb_root_cached *root)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\tstruct rb_node **new = &(root->rb_root.rb_node), *parent = NULL;\n\tbool leftmost = true;\n\n\t/*\n\t * Do not insert if the queue is already associated with a\n\t * counter, which happens if:\n\t *   1) a request arrival has caused the queue to become both\n\t *      non-weight-raised, and hence change its weight, and\n\t *      backlogged; in this respect, each of the two events\n\t *      causes an invocation of this function,\n\t *   2) this is the invocation of this function caused by the\n\t *      second event. This second invocation is actually useless,\n\t *      and we handle this fact by exiting immediately. More\n\t *      efficient or clearer solutions might possibly be adopted.\n\t */\n\tif (bfqq->weight_counter)\n\t\treturn;\n\n\twhile (*new) {\n\t\tstruct bfq_weight_counter *__counter = container_of(*new,\n\t\t\t\t\t\tstruct bfq_weight_counter,\n\t\t\t\t\t\tweights_node);\n\t\tparent = *new;\n\n\t\tif (entity->weight == __counter->weight) {\n\t\t\tbfqq->weight_counter = __counter;\n\t\t\tgoto inc_counter;\n\t\t}\n\t\tif (entity->weight < __counter->weight)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse {\n\t\t\tnew = &((*new)->rb_right);\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\n\tbfqq->weight_counter = kzalloc(sizeof(struct bfq_weight_counter),\n\t\t\t\t       GFP_ATOMIC);\n\n\t/*\n\t * In the unlucky event of an allocation failure, we just\n\t * exit. This will cause the weight of queue to not be\n\t * considered in bfq_asymmetric_scenario, which, in its turn,\n\t * causes the scenario to be deemed wrongly symmetric in case\n\t * bfqq's weight would have been the only weight making the\n\t * scenario asymmetric.  On the bright side, no unbalance will\n\t * however occur when bfqq becomes inactive again (the\n\t * invocation of this function is triggered by an activation\n\t * of queue).  In fact, bfq_weights_tree_remove does nothing\n\t * if !bfqq->weight_counter.\n\t */\n\tif (unlikely(!bfqq->weight_counter))\n\t\treturn;\n\n\tbfqq->weight_counter->weight = entity->weight;\n\trb_link_node(&bfqq->weight_counter->weights_node, parent, new);\n\trb_insert_color_cached(&bfqq->weight_counter->weights_node, root,\n\t\t\t\tleftmost);\n\ninc_counter:\n\tbfqq->weight_counter->num_active++;\n\tbfqq->ref++;\n}\n\n/*\n * Decrement the weight counter associated with the queue, and, if the\n * counter reaches 0, remove the counter from the tree.\n * See the comments to the function bfq_weights_tree_add() for considerations\n * about overhead.\n */\nvoid __bfq_weights_tree_remove(struct bfq_data *bfqd,\n\t\t\t       struct bfq_queue *bfqq,\n\t\t\t       struct rb_root_cached *root)\n{\n\tif (!bfqq->weight_counter)\n\t\treturn;\n\n\tbfqq->weight_counter->num_active--;\n\tif (bfqq->weight_counter->num_active > 0)\n\t\tgoto reset_entity_pointer;\n\n\trb_erase_cached(&bfqq->weight_counter->weights_node, root);\n\tkfree(bfqq->weight_counter);\n\nreset_entity_pointer:\n\tbfqq->weight_counter = NULL;\n\tbfq_put_queue(bfqq);\n}\n\n/*\n * Invoke __bfq_weights_tree_remove on bfqq and decrement the number\n * of active groups for each queue's inactive parent entity.\n */\nvoid bfq_weights_tree_remove(struct bfq_data *bfqd,\n\t\t\t     struct bfq_queue *bfqq)\n{\n\tstruct bfq_entity *entity = bfqq->entity.parent;\n\n\tfor_each_entity(entity) {\n\t\tstruct bfq_sched_data *sd = entity->my_sched_data;\n\n\t\tif (sd->next_in_service || sd->in_service_entity) {\n\t\t\t/*\n\t\t\t * entity is still active, because either\n\t\t\t * next_in_service or in_service_entity is not\n\t\t\t * NULL (see the comments on the definition of\n\t\t\t * next_in_service for details on why\n\t\t\t * in_service_entity must be checked too).\n\t\t\t *\n\t\t\t * As a consequence, its parent entities are\n\t\t\t * active as well, and thus this loop must\n\t\t\t * stop here.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * The decrement of num_groups_with_pending_reqs is\n\t\t * not performed immediately upon the deactivation of\n\t\t * entity, but it is delayed to when it also happens\n\t\t * that the first leaf descendant bfqq of entity gets\n\t\t * all its pending requests completed. The following\n\t\t * instructions perform this delayed decrement, if\n\t\t * needed. See the comments on\n\t\t * num_groups_with_pending_reqs for details.\n\t\t */\n\t\tif (entity->in_groups_with_pending_reqs) {\n\t\t\tentity->in_groups_with_pending_reqs = false;\n\t\t\tbfqd->num_groups_with_pending_reqs--;\n\t\t}\n\t}\n\n\t/*\n\t * Next function is invoked last, because it causes bfqq to be\n\t * freed if the following holds: bfqq is not in service and\n\t * has no dispatched request. DO NOT use bfqq after the next\n\t * function invocation.\n\t */\n\t__bfq_weights_tree_remove(bfqd, bfqq,\n\t\t\t\t  &bfqd->queue_weights_tree);\n}\n\n/*\n * Return expired entry, or NULL to just start from scratch in rbtree.\n */\nstatic struct request *bfq_check_fifo(struct bfq_queue *bfqq,\n\t\t\t\t      struct request *last)\n{\n\tstruct request *rq;\n\n\tif (bfq_bfqq_fifo_expire(bfqq))\n\t\treturn NULL;\n\n\tbfq_mark_bfqq_fifo_expire(bfqq);\n\n\trq = rq_entry_fifo(bfqq->fifo.next);\n\n\tif (rq == last || ktime_get_ns() < rq->fifo_time)\n\t\treturn NULL;\n\n\tbfq_log_bfqq(bfqq->bfqd, bfqq, \"check_fifo: returned %p\", rq);\n\treturn rq;\n}\n\nstatic struct request *bfq_find_next_rq(struct bfq_data *bfqd,\n\t\t\t\t\tstruct bfq_queue *bfqq,\n\t\t\t\t\tstruct request *last)\n{\n\tstruct rb_node *rbnext = rb_next(&last->rb_node);\n\tstruct rb_node *rbprev = rb_prev(&last->rb_node);\n\tstruct request *next, *prev = NULL;\n\n\t/* Follow expired path, else get first next available. */\n\tnext = bfq_check_fifo(bfqq, last);\n\tif (next)\n\t\treturn next;\n\n\tif (rbprev)\n\t\tprev = rb_entry_rq(rbprev);\n\n\tif (rbnext)\n\t\tnext = rb_entry_rq(rbnext);\n\telse {\n\t\trbnext = rb_first(&bfqq->sort_list);\n\t\tif (rbnext && rbnext != &last->rb_node)\n\t\t\tnext = rb_entry_rq(rbnext);\n\t}\n\n\treturn bfq_choose_req(bfqd, next, prev, blk_rq_pos(last));\n}\n\n/* see the definition of bfq_async_charge_factor for details */\nstatic unsigned long bfq_serv_to_charge(struct request *rq,\n\t\t\t\t\tstruct bfq_queue *bfqq)\n{\n\tif (bfq_bfqq_sync(bfqq) || bfqq->wr_coeff > 1 ||\n\t    bfq_asymmetric_scenario(bfqq->bfqd, bfqq))\n\t\treturn blk_rq_sectors(rq);\n\n\treturn blk_rq_sectors(rq) * bfq_async_charge_factor;\n}\n\n/**\n * bfq_updated_next_req - update the queue after a new next_rq selection.\n * @bfqd: the device data the queue belongs to.\n * @bfqq: the queue to update.\n *\n * If the first request of a queue changes we make sure that the queue\n * has enough budget to serve at least its first request (if the\n * request has grown).  We do this because if the queue has not enough\n * budget for its first request, it has to go through two dispatch\n * rounds to actually get it dispatched.\n */\nstatic void bfq_updated_next_req(struct bfq_data *bfqd,\n\t\t\t\t struct bfq_queue *bfqq)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\tstruct request *next_rq = bfqq->next_rq;\n\tunsigned long new_budget;\n\n\tif (!next_rq)\n\t\treturn;\n\n\tif (bfqq == bfqd->in_service_queue)\n\t\t/*\n\t\t * In order not to break guarantees, budgets cannot be\n\t\t * changed after an entity has been selected.\n\t\t */\n\t\treturn;\n\n\tnew_budget = max_t(unsigned long,\n\t\t\t   max_t(unsigned long, bfqq->max_budget,\n\t\t\t\t bfq_serv_to_charge(next_rq, bfqq)),\n\t\t\t   entity->service);\n\tif (entity->budget != new_budget) {\n\t\tentity->budget = new_budget;\n\t\tbfq_log_bfqq(bfqd, bfqq, \"updated next rq: new budget %lu\",\n\t\t\t\t\t new_budget);\n\t\tbfq_requeue_bfqq(bfqd, bfqq, false);\n\t}\n}\n\nstatic unsigned int bfq_wr_duration(struct bfq_data *bfqd)\n{\n\tu64 dur;\n\n\tif (bfqd->bfq_wr_max_time > 0)\n\t\treturn bfqd->bfq_wr_max_time;\n\n\tdur = bfqd->rate_dur_prod;\n\tdo_div(dur, bfqd->peak_rate);\n\n\t/*\n\t * Limit duration between 3 and 25 seconds. The upper limit\n\t * has been conservatively set after the following worst case:\n\t * on a QEMU/KVM virtual machine\n\t * - running in a slow PC\n\t * - with a virtual disk stacked on a slow low-end 5400rpm HDD\n\t * - serving a heavy I/O workload, such as the sequential reading\n\t *   of several files\n\t * mplayer took 23 seconds to start, if constantly weight-raised.\n\t *\n\t * As for higher values than that accommodating the above bad\n\t * scenario, tests show that higher values would often yield\n\t * the opposite of the desired result, i.e., would worsen\n\t * responsiveness by allowing non-interactive applications to\n\t * preserve weight raising for too long.\n\t *\n\t * On the other end, lower values than 3 seconds make it\n\t * difficult for most interactive tasks to complete their jobs\n\t * before weight-raising finishes.\n\t */\n\treturn clamp_val(dur, msecs_to_jiffies(3000), msecs_to_jiffies(25000));\n}\n\n/* switch back from soft real-time to interactive weight raising */\nstatic void switch_back_to_interactive_wr(struct bfq_queue *bfqq,\n\t\t\t\t\t  struct bfq_data *bfqd)\n{\n\tbfqq->wr_coeff = bfqd->bfq_wr_coeff;\n\tbfqq->wr_cur_max_time = bfq_wr_duration(bfqd);\n\tbfqq->last_wr_start_finish = bfqq->wr_start_at_switch_to_srt;\n}\n\nstatic void\nbfq_bfqq_resume_state(struct bfq_queue *bfqq, struct bfq_data *bfqd,\n\t\t      struct bfq_io_cq *bic, bool bfq_already_existing)\n{\n\tunsigned int old_wr_coeff = bfqq->wr_coeff;\n\tbool busy = bfq_already_existing && bfq_bfqq_busy(bfqq);\n\n\tif (bic->saved_has_short_ttime)\n\t\tbfq_mark_bfqq_has_short_ttime(bfqq);\n\telse\n\t\tbfq_clear_bfqq_has_short_ttime(bfqq);\n\n\tif (bic->saved_IO_bound)\n\t\tbfq_mark_bfqq_IO_bound(bfqq);\n\telse\n\t\tbfq_clear_bfqq_IO_bound(bfqq);\n\n\tbfqq->entity.new_weight = bic->saved_weight;\n\tbfqq->ttime = bic->saved_ttime;\n\tbfqq->wr_coeff = bic->saved_wr_coeff;\n\tbfqq->wr_start_at_switch_to_srt = bic->saved_wr_start_at_switch_to_srt;\n\tbfqq->last_wr_start_finish = bic->saved_last_wr_start_finish;\n\tbfqq->wr_cur_max_time = bic->saved_wr_cur_max_time;\n\n\tif (bfqq->wr_coeff > 1 && (bfq_bfqq_in_large_burst(bfqq) ||\n\t    time_is_before_jiffies(bfqq->last_wr_start_finish +\n\t\t\t\t   bfqq->wr_cur_max_time))) {\n\t\tif (bfqq->wr_cur_max_time == bfqd->bfq_wr_rt_max_time &&\n\t\t    !bfq_bfqq_in_large_burst(bfqq) &&\n\t\t    time_is_after_eq_jiffies(bfqq->wr_start_at_switch_to_srt +\n\t\t\t\t\t     bfq_wr_duration(bfqd))) {\n\t\t\tswitch_back_to_interactive_wr(bfqq, bfqd);\n\t\t} else {\n\t\t\tbfqq->wr_coeff = 1;\n\t\t\tbfq_log_bfqq(bfqq->bfqd, bfqq,\n\t\t\t\t     \"resume state: switching off wr\");\n\t\t}\n\t}\n\n\t/* make sure weight will be updated, however we got here */\n\tbfqq->entity.prio_changed = 1;\n\n\tif (likely(!busy))\n\t\treturn;\n\n\tif (old_wr_coeff == 1 && bfqq->wr_coeff > 1)\n\t\tbfqd->wr_busy_queues++;\n\telse if (old_wr_coeff > 1 && bfqq->wr_coeff == 1)\n\t\tbfqd->wr_busy_queues--;\n}\n\nstatic int bfqq_process_refs(struct bfq_queue *bfqq)\n{\n\treturn bfqq->ref - bfqq->allocated - bfqq->entity.on_st_or_in_serv -\n\t\t(bfqq->weight_counter != NULL);\n}\n\n/* Empty burst list and add just bfqq (see comments on bfq_handle_burst) */\nstatic void bfq_reset_burst_list(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\tstruct bfq_queue *item;\n\tstruct hlist_node *n;\n\n\thlist_for_each_entry_safe(item, n, &bfqd->burst_list, burst_list_node)\n\t\thlist_del_init(&item->burst_list_node);\n\n\t/*\n\t * Start the creation of a new burst list only if there is no\n\t * active queue. See comments on the conditional invocation of\n\t * bfq_handle_burst().\n\t */\n\tif (bfq_tot_busy_queues(bfqd) == 0) {\n\t\thlist_add_head(&bfqq->burst_list_node, &bfqd->burst_list);\n\t\tbfqd->burst_size = 1;\n\t} else\n\t\tbfqd->burst_size = 0;\n\n\tbfqd->burst_parent_entity = bfqq->entity.parent;\n}\n\n/* Add bfqq to the list of queues in current burst (see bfq_handle_burst) */\nstatic void bfq_add_to_burst(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\t/* Increment burst size to take into account also bfqq */\n\tbfqd->burst_size++;\n\n\tif (bfqd->burst_size == bfqd->bfq_large_burst_thresh) {\n\t\tstruct bfq_queue *pos, *bfqq_item;\n\t\tstruct hlist_node *n;\n\n\t\t/*\n\t\t * Enough queues have been activated shortly after each\n\t\t * other to consider this burst as large.\n\t\t */\n\t\tbfqd->large_burst = true;\n\n\t\t/*\n\t\t * We can now mark all queues in the burst list as\n\t\t * belonging to a large burst.\n\t\t */\n\t\thlist_for_each_entry(bfqq_item, &bfqd->burst_list,\n\t\t\t\t     burst_list_node)\n\t\t\tbfq_mark_bfqq_in_large_burst(bfqq_item);\n\t\tbfq_mark_bfqq_in_large_burst(bfqq);\n\n\t\t/*\n\t\t * From now on, and until the current burst finishes, any\n\t\t * new queue being activated shortly after the last queue\n\t\t * was inserted in the burst can be immediately marked as\n\t\t * belonging to a large burst. So the burst list is not\n\t\t * needed any more. Remove it.\n\t\t */\n\t\thlist_for_each_entry_safe(pos, n, &bfqd->burst_list,\n\t\t\t\t\t  burst_list_node)\n\t\t\thlist_del_init(&pos->burst_list_node);\n\t} else /*\n\t\t* Burst not yet large: add bfqq to the burst list. Do\n\t\t* not increment the ref counter for bfqq, because bfqq\n\t\t* is removed from the burst list before freeing bfqq\n\t\t* in put_queue.\n\t\t*/\n\t\thlist_add_head(&bfqq->burst_list_node, &bfqd->burst_list);\n}\n\n/*\n * If many queues belonging to the same group happen to be created\n * shortly after each other, then the processes associated with these\n * queues have typically a common goal. In particular, bursts of queue\n * creations are usually caused by services or applications that spawn\n * many parallel threads/processes. Examples are systemd during boot,\n * or git grep. To help these processes get their job done as soon as\n * possible, it is usually better to not grant either weight-raising\n * or device idling to their queues, unless these queues must be\n * protected from the I/O flowing through other active queues.\n *\n * In this comment we describe, firstly, the reasons why this fact\n * holds, and, secondly, the next function, which implements the main\n * steps needed to properly mark these queues so that they can then be\n * treated in a different way.\n *\n * The above services or applications benefit mostly from a high\n * throughput: the quicker the requests of the activated queues are\n * cumulatively served, the sooner the target job of these queues gets\n * completed. As a consequence, weight-raising any of these queues,\n * which also implies idling the device for it, is almost always\n * counterproductive, unless there are other active queues to isolate\n * these new queues from. If there no other active queues, then\n * weight-raising these new queues just lowers throughput in most\n * cases.\n *\n * On the other hand, a burst of queue creations may be caused also by\n * the start of an application that does not consist of a lot of\n * parallel I/O-bound threads. In fact, with a complex application,\n * several short processes may need to be executed to start-up the\n * application. In this respect, to start an application as quickly as\n * possible, the best thing to do is in any case to privilege the I/O\n * related to the application with respect to all other\n * I/O. Therefore, the best strategy to start as quickly as possible\n * an application that causes a burst of queue creations is to\n * weight-raise all the queues created during the burst. This is the\n * exact opposite of the best strategy for the other type of bursts.\n *\n * In the end, to take the best action for each of the two cases, the\n * two types of bursts need to be distinguished. Fortunately, this\n * seems relatively easy, by looking at the sizes of the bursts. In\n * particular, we found a threshold such that only bursts with a\n * larger size than that threshold are apparently caused by\n * services or commands such as systemd or git grep. For brevity,\n * hereafter we call just 'large' these bursts. BFQ *does not*\n * weight-raise queues whose creation occurs in a large burst. In\n * addition, for each of these queues BFQ performs or does not perform\n * idling depending on which choice boosts the throughput more. The\n * exact choice depends on the device and request pattern at\n * hand.\n *\n * Unfortunately, false positives may occur while an interactive task\n * is starting (e.g., an application is being started). The\n * consequence is that the queues associated with the task do not\n * enjoy weight raising as expected. Fortunately these false positives\n * are very rare. They typically occur if some service happens to\n * start doing I/O exactly when the interactive task starts.\n *\n * Turning back to the next function, it is invoked only if there are\n * no active queues (apart from active queues that would belong to the\n * same, possible burst bfqq would belong to), and it implements all\n * the steps needed to detect the occurrence of a large burst and to\n * properly mark all the queues belonging to it (so that they can then\n * be treated in a different way). This goal is achieved by\n * maintaining a \"burst list\" that holds, temporarily, the queues that\n * belong to the burst in progress. The list is then used to mark\n * these queues as belonging to a large burst if the burst does become\n * large. The main steps are the following.\n *\n * . when the very first queue is created, the queue is inserted into the\n *   list (as it could be the first queue in a possible burst)\n *\n * . if the current burst has not yet become large, and a queue Q that does\n *   not yet belong to the burst is activated shortly after the last time\n *   at which a new queue entered the burst list, then the function appends\n *   Q to the burst list\n *\n * . if, as a consequence of the previous step, the burst size reaches\n *   the large-burst threshold, then\n *\n *     . all the queues in the burst list are marked as belonging to a\n *       large burst\n *\n *     . the burst list is deleted; in fact, the burst list already served\n *       its purpose (keeping temporarily track of the queues in a burst,\n *       so as to be able to mark them as belonging to a large burst in the\n *       previous sub-step), and now is not needed any more\n *\n *     . the device enters a large-burst mode\n *\n * . if a queue Q that does not belong to the burst is created while\n *   the device is in large-burst mode and shortly after the last time\n *   at which a queue either entered the burst list or was marked as\n *   belonging to the current large burst, then Q is immediately marked\n *   as belonging to a large burst.\n *\n * . if a queue Q that does not belong to the burst is created a while\n *   later, i.e., not shortly after, than the last time at which a queue\n *   either entered the burst list or was marked as belonging to the\n *   current large burst, then the current burst is deemed as finished and:\n *\n *        . the large-burst mode is reset if set\n *\n *        . the burst list is emptied\n *\n *        . Q is inserted in the burst list, as Q may be the first queue\n *          in a possible new burst (then the burst list contains just Q\n *          after this step).\n */\nstatic void bfq_handle_burst(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\t/*\n\t * If bfqq is already in the burst list or is part of a large\n\t * burst, or finally has just been split, then there is\n\t * nothing else to do.\n\t */\n\tif (!hlist_unhashed(&bfqq->burst_list_node) ||\n\t    bfq_bfqq_in_large_burst(bfqq) ||\n\t    time_is_after_eq_jiffies(bfqq->split_time +\n\t\t\t\t     msecs_to_jiffies(10)))\n\t\treturn;\n\n\t/*\n\t * If bfqq's creation happens late enough, or bfqq belongs to\n\t * a different group than the burst group, then the current\n\t * burst is finished, and related data structures must be\n\t * reset.\n\t *\n\t * In this respect, consider the special case where bfqq is\n\t * the very first queue created after BFQ is selected for this\n\t * device. In this case, last_ins_in_burst and\n\t * burst_parent_entity are not yet significant when we get\n\t * here. But it is easy to verify that, whether or not the\n\t * following condition is true, bfqq will end up being\n\t * inserted into the burst list. In particular the list will\n\t * happen to contain only bfqq. And this is exactly what has\n\t * to happen, as bfqq may be the first queue of the first\n\t * burst.\n\t */\n\tif (time_is_before_jiffies(bfqd->last_ins_in_burst +\n\t    bfqd->bfq_burst_interval) ||\n\t    bfqq->entity.parent != bfqd->burst_parent_entity) {\n\t\tbfqd->large_burst = false;\n\t\tbfq_reset_burst_list(bfqd, bfqq);\n\t\tgoto end;\n\t}\n\n\t/*\n\t * If we get here, then bfqq is being activated shortly after the\n\t * last queue. So, if the current burst is also large, we can mark\n\t * bfqq as belonging to this large burst immediately.\n\t */\n\tif (bfqd->large_burst) {\n\t\tbfq_mark_bfqq_in_large_burst(bfqq);\n\t\tgoto end;\n\t}\n\n\t/*\n\t * If we get here, then a large-burst state has not yet been\n\t * reached, but bfqq is being activated shortly after the last\n\t * queue. Then we add bfqq to the burst.\n\t */\n\tbfq_add_to_burst(bfqd, bfqq);\nend:\n\t/*\n\t * At this point, bfqq either has been added to the current\n\t * burst or has caused the current burst to terminate and a\n\t * possible new burst to start. In particular, in the second\n\t * case, bfqq has become the first queue in the possible new\n\t * burst.  In both cases last_ins_in_burst needs to be moved\n\t * forward.\n\t */\n\tbfqd->last_ins_in_burst = jiffies;\n}\n\nstatic int bfq_bfqq_budget_left(struct bfq_queue *bfqq)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\n\treturn entity->budget - entity->service;\n}\n\n/*\n * If enough samples have been computed, return the current max budget\n * stored in bfqd, which is dynamically updated according to the\n * estimated disk peak rate; otherwise return the default max budget\n */\nstatic int bfq_max_budget(struct bfq_data *bfqd)\n{\n\tif (bfqd->budgets_assigned < bfq_stats_min_budgets)\n\t\treturn bfq_default_max_budget;\n\telse\n\t\treturn bfqd->bfq_max_budget;\n}\n\n/*\n * Return min budget, which is a fraction of the current or default\n * max budget (trying with 1/32)\n */\nstatic int bfq_min_budget(struct bfq_data *bfqd)\n{\n\tif (bfqd->budgets_assigned < bfq_stats_min_budgets)\n\t\treturn bfq_default_max_budget / 32;\n\telse\n\t\treturn bfqd->bfq_max_budget / 32;\n}\n\n/*\n * The next function, invoked after the input queue bfqq switches from\n * idle to busy, updates the budget of bfqq. The function also tells\n * whether the in-service queue should be expired, by returning\n * true. The purpose of expiring the in-service queue is to give bfqq\n * the chance to possibly preempt the in-service queue, and the reason\n * for preempting the in-service queue is to achieve one of the two\n * goals below.\n *\n * 1. Guarantee to bfqq its reserved bandwidth even if bfqq has\n * expired because it has remained idle. In particular, bfqq may have\n * expired for one of the following two reasons:\n *\n * - BFQQE_NO_MORE_REQUESTS bfqq did not enjoy any device idling\n *   and did not make it to issue a new request before its last\n *   request was served;\n *\n * - BFQQE_TOO_IDLE bfqq did enjoy device idling, but did not issue\n *   a new request before the expiration of the idling-time.\n *\n * Even if bfqq has expired for one of the above reasons, the process\n * associated with the queue may be however issuing requests greedily,\n * and thus be sensitive to the bandwidth it receives (bfqq may have\n * remained idle for other reasons: CPU high load, bfqq not enjoying\n * idling, I/O throttling somewhere in the path from the process to\n * the I/O scheduler, ...). But if, after every expiration for one of\n * the above two reasons, bfqq has to wait for the service of at least\n * one full budget of another queue before being served again, then\n * bfqq is likely to get a much lower bandwidth or resource time than\n * its reserved ones. To address this issue, two countermeasures need\n * to be taken.\n *\n * First, the budget and the timestamps of bfqq need to be updated in\n * a special way on bfqq reactivation: they need to be updated as if\n * bfqq did not remain idle and did not expire. In fact, if they are\n * computed as if bfqq expired and remained idle until reactivation,\n * then the process associated with bfqq is treated as if, instead of\n * being greedy, it stopped issuing requests when bfqq remained idle,\n * and restarts issuing requests only on this reactivation. In other\n * words, the scheduler does not help the process recover the \"service\n * hole\" between bfqq expiration and reactivation. As a consequence,\n * the process receives a lower bandwidth than its reserved one. In\n * contrast, to recover this hole, the budget must be updated as if\n * bfqq was not expired at all before this reactivation, i.e., it must\n * be set to the value of the remaining budget when bfqq was\n * expired. Along the same line, timestamps need to be assigned the\n * value they had the last time bfqq was selected for service, i.e.,\n * before last expiration. Thus timestamps need to be back-shifted\n * with respect to their normal computation (see [1] for more details\n * on this tricky aspect).\n *\n * Secondly, to allow the process to recover the hole, the in-service\n * queue must be expired too, to give bfqq the chance to preempt it\n * immediately. In fact, if bfqq has to wait for a full budget of the\n * in-service queue to be completed, then it may become impossible to\n * let the process recover the hole, even if the back-shifted\n * timestamps of bfqq are lower than those of the in-service queue. If\n * this happens for most or all of the holes, then the process may not\n * receive its reserved bandwidth. In this respect, it is worth noting\n * that, being the service of outstanding requests unpreemptible, a\n * little fraction of the holes may however be unrecoverable, thereby\n * causing a little loss of bandwidth.\n *\n * The last important point is detecting whether bfqq does need this\n * bandwidth recovery. In this respect, the next function deems the\n * process associated with bfqq greedy, and thus allows it to recover\n * the hole, if: 1) the process is waiting for the arrival of a new\n * request (which implies that bfqq expired for one of the above two\n * reasons), and 2) such a request has arrived soon. The first\n * condition is controlled through the flag non_blocking_wait_rq,\n * while the second through the flag arrived_in_time. If both\n * conditions hold, then the function computes the budget in the\n * above-described special way, and signals that the in-service queue\n * should be expired. Timestamp back-shifting is done later in\n * __bfq_activate_entity.\n *\n * 2. Reduce latency. Even if timestamps are not backshifted to let\n * the process associated with bfqq recover a service hole, bfqq may\n * however happen to have, after being (re)activated, a lower finish\n * timestamp than the in-service queue.\t That is, the next budget of\n * bfqq may have to be completed before the one of the in-service\n * queue. If this is the case, then preempting the in-service queue\n * allows this goal to be achieved, apart from the unpreemptible,\n * outstanding requests mentioned above.\n *\n * Unfortunately, regardless of which of the above two goals one wants\n * to achieve, service trees need first to be updated to know whether\n * the in-service queue must be preempted. To have service trees\n * correctly updated, the in-service queue must be expired and\n * rescheduled, and bfqq must be scheduled too. This is one of the\n * most costly operations (in future versions, the scheduling\n * mechanism may be re-designed in such a way to make it possible to\n * know whether preemption is needed without needing to update service\n * trees). In addition, queue preemptions almost always cause random\n * I/O, which may in turn cause loss of throughput. Finally, there may\n * even be no in-service queue when the next function is invoked (so,\n * no queue to compare timestamps with). Because of these facts, the\n * next function adopts the following simple scheme to avoid costly\n * operations, too frequent preemptions and too many dependencies on\n * the state of the scheduler: it requests the expiration of the\n * in-service queue (unconditionally) only for queues that need to\n * recover a hole. Then it delegates to other parts of the code the\n * responsibility of handling the above case 2.\n */\nstatic bool bfq_bfqq_update_budg_for_activation(struct bfq_data *bfqd,\n\t\t\t\t\t\tstruct bfq_queue *bfqq,\n\t\t\t\t\t\tbool arrived_in_time)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\n\t/*\n\t * In the next compound condition, we check also whether there\n\t * is some budget left, because otherwise there is no point in\n\t * trying to go on serving bfqq with this same budget: bfqq\n\t * would be expired immediately after being selected for\n\t * service. This would only cause useless overhead.\n\t */\n\tif (bfq_bfqq_non_blocking_wait_rq(bfqq) && arrived_in_time &&\n\t    bfq_bfqq_budget_left(bfqq) > 0) {\n\t\t/*\n\t\t * We do not clear the flag non_blocking_wait_rq here, as\n\t\t * the latter is used in bfq_activate_bfqq to signal\n\t\t * that timestamps need to be back-shifted (and is\n\t\t * cleared right after).\n\t\t */\n\n\t\t/*\n\t\t * In next assignment we rely on that either\n\t\t * entity->service or entity->budget are not updated\n\t\t * on expiration if bfqq is empty (see\n\t\t * __bfq_bfqq_recalc_budget). Thus both quantities\n\t\t * remain unchanged after such an expiration, and the\n\t\t * following statement therefore assigns to\n\t\t * entity->budget the remaining budget on such an\n\t\t * expiration.\n\t\t */\n\t\tentity->budget = min_t(unsigned long,\n\t\t\t\t       bfq_bfqq_budget_left(bfqq),\n\t\t\t\t       bfqq->max_budget);\n\n\t\t/*\n\t\t * At this point, we have used entity->service to get\n\t\t * the budget left (needed for updating\n\t\t * entity->budget). Thus we finally can, and have to,\n\t\t * reset entity->service. The latter must be reset\n\t\t * because bfqq would otherwise be charged again for\n\t\t * the service it has received during its previous\n\t\t * service slot(s).\n\t\t */\n\t\tentity->service = 0;\n\n\t\treturn true;\n\t}\n\n\t/*\n\t * We can finally complete expiration, by setting service to 0.\n\t */\n\tentity->service = 0;\n\tentity->budget = max_t(unsigned long, bfqq->max_budget,\n\t\t\t       bfq_serv_to_charge(bfqq->next_rq, bfqq));\n\tbfq_clear_bfqq_non_blocking_wait_rq(bfqq);\n\treturn false;\n}\n\n/*\n * Return the farthest past time instant according to jiffies\n * macros.\n */\nstatic unsigned long bfq_smallest_from_now(void)\n{\n\treturn jiffies - MAX_JIFFY_OFFSET;\n}\n\nstatic void bfq_update_bfqq_wr_on_rq_arrival(struct bfq_data *bfqd,\n\t\t\t\t\t     struct bfq_queue *bfqq,\n\t\t\t\t\t     unsigned int old_wr_coeff,\n\t\t\t\t\t     bool wr_or_deserves_wr,\n\t\t\t\t\t     bool interactive,\n\t\t\t\t\t     bool in_burst,\n\t\t\t\t\t     bool soft_rt)\n{\n\tif (old_wr_coeff == 1 && wr_or_deserves_wr) {\n\t\t/* start a weight-raising period */\n\t\tif (interactive) {\n\t\t\tbfqq->service_from_wr = 0;\n\t\t\tbfqq->wr_coeff = bfqd->bfq_wr_coeff;\n\t\t\tbfqq->wr_cur_max_time = bfq_wr_duration(bfqd);\n\t\t} else {\n\t\t\t/*\n\t\t\t * No interactive weight raising in progress\n\t\t\t * here: assign minus infinity to\n\t\t\t * wr_start_at_switch_to_srt, to make sure\n\t\t\t * that, at the end of the soft-real-time\n\t\t\t * weight raising periods that is starting\n\t\t\t * now, no interactive weight-raising period\n\t\t\t * may be wrongly considered as still in\n\t\t\t * progress (and thus actually started by\n\t\t\t * mistake).\n\t\t\t */\n\t\t\tbfqq->wr_start_at_switch_to_srt =\n\t\t\t\tbfq_smallest_from_now();\n\t\t\tbfqq->wr_coeff = bfqd->bfq_wr_coeff *\n\t\t\t\tBFQ_SOFTRT_WEIGHT_FACTOR;\n\t\t\tbfqq->wr_cur_max_time =\n\t\t\t\tbfqd->bfq_wr_rt_max_time;\n\t\t}\n\n\t\t/*\n\t\t * If needed, further reduce budget to make sure it is\n\t\t * close to bfqq's backlog, so as to reduce the\n\t\t * scheduling-error component due to a too large\n\t\t * budget. Do not care about throughput consequences,\n\t\t * but only about latency. Finally, do not assign a\n\t\t * too small budget either, to avoid increasing\n\t\t * latency by causing too frequent expirations.\n\t\t */\n\t\tbfqq->entity.budget = min_t(unsigned long,\n\t\t\t\t\t    bfqq->entity.budget,\n\t\t\t\t\t    2 * bfq_min_budget(bfqd));\n\t} else if (old_wr_coeff > 1) {\n\t\tif (interactive) { /* update wr coeff and duration */\n\t\t\tbfqq->wr_coeff = bfqd->bfq_wr_coeff;\n\t\t\tbfqq->wr_cur_max_time = bfq_wr_duration(bfqd);\n\t\t} else if (in_burst)\n\t\t\tbfqq->wr_coeff = 1;\n\t\telse if (soft_rt) {\n\t\t\t/*\n\t\t\t * The application is now or still meeting the\n\t\t\t * requirements for being deemed soft rt.  We\n\t\t\t * can then correctly and safely (re)charge\n\t\t\t * the weight-raising duration for the\n\t\t\t * application with the weight-raising\n\t\t\t * duration for soft rt applications.\n\t\t\t *\n\t\t\t * In particular, doing this recharge now, i.e.,\n\t\t\t * before the weight-raising period for the\n\t\t\t * application finishes, reduces the probability\n\t\t\t * of the following negative scenario:\n\t\t\t * 1) the weight of a soft rt application is\n\t\t\t *    raised at startup (as for any newly\n\t\t\t *    created application),\n\t\t\t * 2) since the application is not interactive,\n\t\t\t *    at a certain time weight-raising is\n\t\t\t *    stopped for the application,\n\t\t\t * 3) at that time the application happens to\n\t\t\t *    still have pending requests, and hence\n\t\t\t *    is destined to not have a chance to be\n\t\t\t *    deemed soft rt before these requests are\n\t\t\t *    completed (see the comments to the\n\t\t\t *    function bfq_bfqq_softrt_next_start()\n\t\t\t *    for details on soft rt detection),\n\t\t\t * 4) these pending requests experience a high\n\t\t\t *    latency because the application is not\n\t\t\t *    weight-raised while they are pending.\n\t\t\t */\n\t\t\tif (bfqq->wr_cur_max_time !=\n\t\t\t\tbfqd->bfq_wr_rt_max_time) {\n\t\t\t\tbfqq->wr_start_at_switch_to_srt =\n\t\t\t\t\tbfqq->last_wr_start_finish;\n\n\t\t\t\tbfqq->wr_cur_max_time =\n\t\t\t\t\tbfqd->bfq_wr_rt_max_time;\n\t\t\t\tbfqq->wr_coeff = bfqd->bfq_wr_coeff *\n\t\t\t\t\tBFQ_SOFTRT_WEIGHT_FACTOR;\n\t\t\t}\n\t\t\tbfqq->last_wr_start_finish = jiffies;\n\t\t}\n\t}\n}\n\nstatic bool bfq_bfqq_idle_for_long_time(struct bfq_data *bfqd,\n\t\t\t\t\tstruct bfq_queue *bfqq)\n{\n\treturn bfqq->dispatched == 0 &&\n\t\ttime_is_before_jiffies(\n\t\t\tbfqq->budget_timeout +\n\t\t\tbfqd->bfq_wr_min_idle_time);\n}\n\n\n/*\n * Return true if bfqq is in a higher priority class, or has a higher\n * weight than the in-service queue.\n */\nstatic bool bfq_bfqq_higher_class_or_weight(struct bfq_queue *bfqq,\n\t\t\t\t\t    struct bfq_queue *in_serv_bfqq)\n{\n\tint bfqq_weight, in_serv_weight;\n\n\tif (bfqq->ioprio_class < in_serv_bfqq->ioprio_class)\n\t\treturn true;\n\n\tif (in_serv_bfqq->entity.parent == bfqq->entity.parent) {\n\t\tbfqq_weight = bfqq->entity.weight;\n\t\tin_serv_weight = in_serv_bfqq->entity.weight;\n\t} else {\n\t\tif (bfqq->entity.parent)\n\t\t\tbfqq_weight = bfqq->entity.parent->weight;\n\t\telse\n\t\t\tbfqq_weight = bfqq->entity.weight;\n\t\tif (in_serv_bfqq->entity.parent)\n\t\t\tin_serv_weight = in_serv_bfqq->entity.parent->weight;\n\t\telse\n\t\t\tin_serv_weight = in_serv_bfqq->entity.weight;\n\t}\n\n\treturn bfqq_weight > in_serv_weight;\n}\n\nstatic void bfq_bfqq_handle_idle_busy_switch(struct bfq_data *bfqd,\n\t\t\t\t\t     struct bfq_queue *bfqq,\n\t\t\t\t\t     int old_wr_coeff,\n\t\t\t\t\t     struct request *rq,\n\t\t\t\t\t     bool *interactive)\n{\n\tbool soft_rt, in_burst,\twr_or_deserves_wr,\n\t\tbfqq_wants_to_preempt,\n\t\tidle_for_long_time = bfq_bfqq_idle_for_long_time(bfqd, bfqq),\n\t\t/*\n\t\t * See the comments on\n\t\t * bfq_bfqq_update_budg_for_activation for\n\t\t * details on the usage of the next variable.\n\t\t */\n\t\tarrived_in_time =  ktime_get_ns() <=\n\t\t\tbfqq->ttime.last_end_request +\n\t\t\tbfqd->bfq_slice_idle * 3;\n\n\n\t/*\n\t * bfqq deserves to be weight-raised if:\n\t * - it is sync,\n\t * - it does not belong to a large burst,\n\t * - it has been idle for enough time or is soft real-time,\n\t * - is linked to a bfq_io_cq (it is not shared in any sense).\n\t */\n\tin_burst = bfq_bfqq_in_large_burst(bfqq);\n\tsoft_rt = bfqd->bfq_wr_max_softrt_rate > 0 &&\n\t\t!BFQQ_TOTALLY_SEEKY(bfqq) &&\n\t\t!in_burst &&\n\t\ttime_is_before_jiffies(bfqq->soft_rt_next_start) &&\n\t\tbfqq->dispatched == 0;\n\t*interactive = !in_burst && idle_for_long_time;\n\twr_or_deserves_wr = bfqd->low_latency &&\n\t\t(bfqq->wr_coeff > 1 ||\n\t\t (bfq_bfqq_sync(bfqq) &&\n\t\t  bfqq->bic && (*interactive || soft_rt)));\n\n\t/*\n\t * Using the last flag, update budget and check whether bfqq\n\t * may want to preempt the in-service queue.\n\t */\n\tbfqq_wants_to_preempt =\n\t\tbfq_bfqq_update_budg_for_activation(bfqd, bfqq,\n\t\t\t\t\t\t    arrived_in_time);\n\n\t/*\n\t * If bfqq happened to be activated in a burst, but has been\n\t * idle for much more than an interactive queue, then we\n\t * assume that, in the overall I/O initiated in the burst, the\n\t * I/O associated with bfqq is finished. So bfqq does not need\n\t * to be treated as a queue belonging to a burst\n\t * anymore. Accordingly, we reset bfqq's in_large_burst flag\n\t * if set, and remove bfqq from the burst list if it's\n\t * there. We do not decrement burst_size, because the fact\n\t * that bfqq does not need to belong to the burst list any\n\t * more does not invalidate the fact that bfqq was created in\n\t * a burst.\n\t */\n\tif (likely(!bfq_bfqq_just_created(bfqq)) &&\n\t    idle_for_long_time &&\n\t    time_is_before_jiffies(\n\t\t    bfqq->budget_timeout +\n\t\t    msecs_to_jiffies(10000))) {\n\t\thlist_del_init(&bfqq->burst_list_node);\n\t\tbfq_clear_bfqq_in_large_burst(bfqq);\n\t}\n\n\tbfq_clear_bfqq_just_created(bfqq);\n\n\n\tif (!bfq_bfqq_IO_bound(bfqq)) {\n\t\tif (arrived_in_time) {\n\t\t\tbfqq->requests_within_timer++;\n\t\t\tif (bfqq->requests_within_timer >=\n\t\t\t    bfqd->bfq_requests_within_timer)\n\t\t\t\tbfq_mark_bfqq_IO_bound(bfqq);\n\t\t} else\n\t\t\tbfqq->requests_within_timer = 0;\n\t}\n\n\tif (bfqd->low_latency) {\n\t\tif (unlikely(time_is_after_jiffies(bfqq->split_time)))\n\t\t\t/* wraparound */\n\t\t\tbfqq->split_time =\n\t\t\t\tjiffies - bfqd->bfq_wr_min_idle_time - 1;\n\n\t\tif (time_is_before_jiffies(bfqq->split_time +\n\t\t\t\t\t   bfqd->bfq_wr_min_idle_time)) {\n\t\t\tbfq_update_bfqq_wr_on_rq_arrival(bfqd, bfqq,\n\t\t\t\t\t\t\t old_wr_coeff,\n\t\t\t\t\t\t\t wr_or_deserves_wr,\n\t\t\t\t\t\t\t *interactive,\n\t\t\t\t\t\t\t in_burst,\n\t\t\t\t\t\t\t soft_rt);\n\n\t\t\tif (old_wr_coeff != bfqq->wr_coeff)\n\t\t\t\tbfqq->entity.prio_changed = 1;\n\t\t}\n\t}\n\n\tbfqq->last_idle_bklogged = jiffies;\n\tbfqq->service_from_backlogged = 0;\n\tbfq_clear_bfqq_softrt_update(bfqq);\n\n\tbfq_add_bfqq_busy(bfqd, bfqq);\n\n\t/*\n\t * Expire in-service queue only if preemption may be needed\n\t * for guarantees. In particular, we care only about two\n\t * cases. The first is that bfqq has to recover a service\n\t * hole, as explained in the comments on\n\t * bfq_bfqq_update_budg_for_activation(), i.e., that\n\t * bfqq_wants_to_preempt is true. However, if bfqq does not\n\t * carry time-critical I/O, then bfqq's bandwidth is less\n\t * important than that of queues that carry time-critical I/O.\n\t * So, as a further constraint, we consider this case only if\n\t * bfqq is at least as weight-raised, i.e., at least as time\n\t * critical, as the in-service queue.\n\t *\n\t * The second case is that bfqq is in a higher priority class,\n\t * or has a higher weight than the in-service queue. If this\n\t * condition does not hold, we don't care because, even if\n\t * bfqq does not start to be served immediately, the resulting\n\t * delay for bfqq's I/O is however lower or much lower than\n\t * the ideal completion time to be guaranteed to bfqq's I/O.\n\t *\n\t * In both cases, preemption is needed only if, according to\n\t * the timestamps of both bfqq and of the in-service queue,\n\t * bfqq actually is the next queue to serve. So, to reduce\n\t * useless preemptions, the return value of\n\t * next_queue_may_preempt() is considered in the next compound\n\t * condition too. Yet next_queue_may_preempt() just checks a\n\t * simple, necessary condition for bfqq to be the next queue\n\t * to serve. In fact, to evaluate a sufficient condition, the\n\t * timestamps of the in-service queue would need to be\n\t * updated, and this operation is quite costly (see the\n\t * comments on bfq_bfqq_update_budg_for_activation()).\n\t */\n\tif (bfqd->in_service_queue &&\n\t    ((bfqq_wants_to_preempt &&\n\t      bfqq->wr_coeff >= bfqd->in_service_queue->wr_coeff) ||\n\t     bfq_bfqq_higher_class_or_weight(bfqq, bfqd->in_service_queue)) &&\n\t    next_queue_may_preempt(bfqd))\n\t\tbfq_bfqq_expire(bfqd, bfqd->in_service_queue,\n\t\t\t\tfalse, BFQQE_PREEMPTED);\n}\n\nstatic void bfq_reset_inject_limit(struct bfq_data *bfqd,\n\t\t\t\t   struct bfq_queue *bfqq)\n{\n\t/* invalidate baseline total service time */\n\tbfqq->last_serv_time_ns = 0;\n\n\t/*\n\t * Reset pointer in case we are waiting for\n\t * some request completion.\n\t */\n\tbfqd->waited_rq = NULL;\n\n\t/*\n\t * If bfqq has a short think time, then start by setting the\n\t * inject limit to 0 prudentially, because the service time of\n\t * an injected I/O request may be higher than the think time\n\t * of bfqq, and therefore, if one request was injected when\n\t * bfqq remains empty, this injected request might delay the\n\t * service of the next I/O request for bfqq significantly. In\n\t * case bfqq can actually tolerate some injection, then the\n\t * adaptive update will however raise the limit soon. This\n\t * lucky circumstance holds exactly because bfqq has a short\n\t * think time, and thus, after remaining empty, is likely to\n\t * get new I/O enqueued---and then completed---before being\n\t * expired. This is the very pattern that gives the\n\t * limit-update algorithm the chance to measure the effect of\n\t * injection on request service times, and then to update the\n\t * limit accordingly.\n\t *\n\t * However, in the following special case, the inject limit is\n\t * left to 1 even if the think time is short: bfqq's I/O is\n\t * synchronized with that of some other queue, i.e., bfqq may\n\t * receive new I/O only after the I/O of the other queue is\n\t * completed. Keeping the inject limit to 1 allows the\n\t * blocking I/O to be served while bfqq is in service. And\n\t * this is very convenient both for bfqq and for overall\n\t * throughput, as explained in detail in the comments in\n\t * bfq_update_has_short_ttime().\n\t *\n\t * On the opposite end, if bfqq has a long think time, then\n\t * start directly by 1, because:\n\t * a) on the bright side, keeping at most one request in\n\t * service in the drive is unlikely to cause any harm to the\n\t * latency of bfqq's requests, as the service time of a single\n\t * request is likely to be lower than the think time of bfqq;\n\t * b) on the downside, after becoming empty, bfqq is likely to\n\t * expire before getting its next request. With this request\n\t * arrival pattern, it is very hard to sample total service\n\t * times and update the inject limit accordingly (see comments\n\t * on bfq_update_inject_limit()). So the limit is likely to be\n\t * never, or at least seldom, updated.  As a consequence, by\n\t * setting the limit to 1, we avoid that no injection ever\n\t * occurs with bfqq. On the downside, this proactive step\n\t * further reduces chances to actually compute the baseline\n\t * total service time. Thus it reduces chances to execute the\n\t * limit-update algorithm and possibly raise the limit to more\n\t * than 1.\n\t */\n\tif (bfq_bfqq_has_short_ttime(bfqq))\n\t\tbfqq->inject_limit = 0;\n\telse\n\t\tbfqq->inject_limit = 1;\n\n\tbfqq->decrease_time_jif = jiffies;\n}\n\nstatic void bfq_add_request(struct request *rq)\n{\n\tstruct bfq_queue *bfqq = RQ_BFQQ(rq);\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tstruct request *next_rq, *prev;\n\tunsigned int old_wr_coeff = bfqq->wr_coeff;\n\tbool interactive = false;\n\n\tbfq_log_bfqq(bfqd, bfqq, \"add_request %d\", rq_is_sync(rq));\n\tbfqq->queued[rq_is_sync(rq)]++;\n\tbfqd->queued++;\n\n\tif (RB_EMPTY_ROOT(&bfqq->sort_list) && bfq_bfqq_sync(bfqq)) {\n\t\t/*\n\t\t * Detect whether bfqq's I/O seems synchronized with\n\t\t * that of some other queue, i.e., whether bfqq, after\n\t\t * remaining empty, happens to receive new I/O only\n\t\t * right after some I/O request of the other queue has\n\t\t * been completed. We call waker queue the other\n\t\t * queue, and we assume, for simplicity, that bfqq may\n\t\t * have at most one waker queue.\n\t\t *\n\t\t * A remarkable throughput boost can be reached by\n\t\t * unconditionally injecting the I/O of the waker\n\t\t * queue, every time a new bfq_dispatch_request\n\t\t * happens to be invoked while I/O is being plugged\n\t\t * for bfqq.  In addition to boosting throughput, this\n\t\t * unblocks bfqq's I/O, thereby improving bandwidth\n\t\t * and latency for bfqq. Note that these same results\n\t\t * may be achieved with the general injection\n\t\t * mechanism, but less effectively. For details on\n\t\t * this aspect, see the comments on the choice of the\n\t\t * queue for injection in bfq_select_queue().\n\t\t *\n\t\t * Turning back to the detection of a waker queue, a\n\t\t * queue Q is deemed as a waker queue for bfqq if, for\n\t\t * two consecutive times, bfqq happens to become non\n\t\t * empty right after a request of Q has been\n\t\t * completed. In particular, on the first time, Q is\n\t\t * tentatively set as a candidate waker queue, while\n\t\t * on the second time, the flag\n\t\t * bfq_bfqq_has_waker(bfqq) is set to confirm that Q\n\t\t * is a waker queue for bfqq. These detection steps\n\t\t * are performed only if bfqq has a long think time,\n\t\t * so as to make it more likely that bfqq's I/O is\n\t\t * actually being blocked by a synchronization. This\n\t\t * last filter, plus the above two-times requirement,\n\t\t * make false positives less likely.\n\t\t *\n\t\t * NOTE\n\t\t *\n\t\t * The sooner a waker queue is detected, the sooner\n\t\t * throughput can be boosted by injecting I/O from the\n\t\t * waker queue. Fortunately, detection is likely to be\n\t\t * actually fast, for the following reasons. While\n\t\t * blocked by synchronization, bfqq has a long think\n\t\t * time. This implies that bfqq's inject limit is at\n\t\t * least equal to 1 (see the comments in\n\t\t * bfq_update_inject_limit()). So, thanks to\n\t\t * injection, the waker queue is likely to be served\n\t\t * during the very first I/O-plugging time interval\n\t\t * for bfqq. This triggers the first step of the\n\t\t * detection mechanism. Thanks again to injection, the\n\t\t * candidate waker queue is then likely to be\n\t\t * confirmed no later than during the next\n\t\t * I/O-plugging interval for bfqq.\n\t\t */\n\t\tif (bfqd->last_completed_rq_bfqq &&\n\t\t    !bfq_bfqq_has_short_ttime(bfqq) &&\n\t\t    ktime_get_ns() - bfqd->last_completion <\n\t\t    200 * NSEC_PER_USEC) {\n\t\t\tif (bfqd->last_completed_rq_bfqq != bfqq &&\n\t\t\t    bfqd->last_completed_rq_bfqq !=\n\t\t\t    bfqq->waker_bfqq) {\n\t\t\t\t/*\n\t\t\t\t * First synchronization detected with\n\t\t\t\t * a candidate waker queue, or with a\n\t\t\t\t * different candidate waker queue\n\t\t\t\t * from the current one.\n\t\t\t\t */\n\t\t\t\tbfqq->waker_bfqq = bfqd->last_completed_rq_bfqq;\n\n\t\t\t\t/*\n\t\t\t\t * If the waker queue disappears, then\n\t\t\t\t * bfqq->waker_bfqq must be reset. To\n\t\t\t\t * this goal, we maintain in each\n\t\t\t\t * waker queue a list, woken_list, of\n\t\t\t\t * all the queues that reference the\n\t\t\t\t * waker queue through their\n\t\t\t\t * waker_bfqq pointer. When the waker\n\t\t\t\t * queue exits, the waker_bfqq pointer\n\t\t\t\t * of all the queues in the woken_list\n\t\t\t\t * is reset.\n\t\t\t\t *\n\t\t\t\t * In addition, if bfqq is already in\n\t\t\t\t * the woken_list of a waker queue,\n\t\t\t\t * then, before being inserted into\n\t\t\t\t * the woken_list of a new waker\n\t\t\t\t * queue, bfqq must be removed from\n\t\t\t\t * the woken_list of the old waker\n\t\t\t\t * queue.\n\t\t\t\t */\n\t\t\t\tif (!hlist_unhashed(&bfqq->woken_list_node))\n\t\t\t\t\thlist_del_init(&bfqq->woken_list_node);\n\t\t\t\thlist_add_head(&bfqq->woken_list_node,\n\t\t\t\t    &bfqd->last_completed_rq_bfqq->woken_list);\n\n\t\t\t\tbfq_clear_bfqq_has_waker(bfqq);\n\t\t\t} else if (bfqd->last_completed_rq_bfqq ==\n\t\t\t\t   bfqq->waker_bfqq &&\n\t\t\t\t   !bfq_bfqq_has_waker(bfqq)) {\n\t\t\t\t/*\n\t\t\t\t * synchronization with waker_bfqq\n\t\t\t\t * seen for the second time\n\t\t\t\t */\n\t\t\t\tbfq_mark_bfqq_has_waker(bfqq);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Periodically reset inject limit, to make sure that\n\t\t * the latter eventually drops in case workload\n\t\t * changes, see step (3) in the comments on\n\t\t * bfq_update_inject_limit().\n\t\t */\n\t\tif (time_is_before_eq_jiffies(bfqq->decrease_time_jif +\n\t\t\t\t\t     msecs_to_jiffies(1000)))\n\t\t\tbfq_reset_inject_limit(bfqd, bfqq);\n\n\t\t/*\n\t\t * The following conditions must hold to setup a new\n\t\t * sampling of total service time, and then a new\n\t\t * update of the inject limit:\n\t\t * - bfqq is in service, because the total service\n\t\t *   time is evaluated only for the I/O requests of\n\t\t *   the queues in service;\n\t\t * - this is the right occasion to compute or to\n\t\t *   lower the baseline total service time, because\n\t\t *   there are actually no requests in the drive,\n\t\t *   or\n\t\t *   the baseline total service time is available, and\n\t\t *   this is the right occasion to compute the other\n\t\t *   quantity needed to update the inject limit, i.e.,\n\t\t *   the total service time caused by the amount of\n\t\t *   injection allowed by the current value of the\n\t\t *   limit. It is the right occasion because injection\n\t\t *   has actually been performed during the service\n\t\t *   hole, and there are still in-flight requests,\n\t\t *   which are very likely to be exactly the injected\n\t\t *   requests, or part of them;\n\t\t * - the minimum interval for sampling the total\n\t\t *   service time and updating the inject limit has\n\t\t *   elapsed.\n\t\t */\n\t\tif (bfqq == bfqd->in_service_queue &&\n\t\t    (bfqd->rq_in_driver == 0 ||\n\t\t     (bfqq->last_serv_time_ns > 0 &&\n\t\t      bfqd->rqs_injected && bfqd->rq_in_driver > 0)) &&\n\t\t    time_is_before_eq_jiffies(bfqq->decrease_time_jif +\n\t\t\t\t\t      msecs_to_jiffies(10))) {\n\t\t\tbfqd->last_empty_occupied_ns = ktime_get_ns();\n\t\t\t/*\n\t\t\t * Start the state machine for measuring the\n\t\t\t * total service time of rq: setting\n\t\t\t * wait_dispatch will cause bfqd->waited_rq to\n\t\t\t * be set when rq will be dispatched.\n\t\t\t */\n\t\t\tbfqd->wait_dispatch = true;\n\t\t\t/*\n\t\t\t * If there is no I/O in service in the drive,\n\t\t\t * then possible injection occurred before the\n\t\t\t * arrival of rq will not affect the total\n\t\t\t * service time of rq. So the injection limit\n\t\t\t * must not be updated as a function of such\n\t\t\t * total service time, unless new injection\n\t\t\t * occurs before rq is completed. To have the\n\t\t\t * injection limit updated only in the latter\n\t\t\t * case, reset rqs_injected here (rqs_injected\n\t\t\t * will be set in case injection is performed\n\t\t\t * on bfqq before rq is completed).\n\t\t\t */\n\t\t\tif (bfqd->rq_in_driver == 0)\n\t\t\t\tbfqd->rqs_injected = false;\n\t\t}\n\t}\n\n\telv_rb_add(&bfqq->sort_list, rq);\n\n\t/*\n\t * Check if this request is a better next-serve candidate.\n\t */\n\tprev = bfqq->next_rq;\n\tnext_rq = bfq_choose_req(bfqd, bfqq->next_rq, rq, bfqd->last_position);\n\tbfqq->next_rq = next_rq;\n\n\t/*\n\t * Adjust priority tree position, if next_rq changes.\n\t * See comments on bfq_pos_tree_add_move() for the unlikely().\n\t */\n\tif (unlikely(!bfqd->nonrot_with_queueing && prev != bfqq->next_rq))\n\t\tbfq_pos_tree_add_move(bfqd, bfqq);\n\n\tif (!bfq_bfqq_busy(bfqq)) /* switching to busy ... */\n\t\tbfq_bfqq_handle_idle_busy_switch(bfqd, bfqq, old_wr_coeff,\n\t\t\t\t\t\t rq, &interactive);\n\telse {\n\t\tif (bfqd->low_latency && old_wr_coeff == 1 && !rq_is_sync(rq) &&\n\t\t    time_is_before_jiffies(\n\t\t\t\tbfqq->last_wr_start_finish +\n\t\t\t\tbfqd->bfq_wr_min_inter_arr_async)) {\n\t\t\tbfqq->wr_coeff = bfqd->bfq_wr_coeff;\n\t\t\tbfqq->wr_cur_max_time = bfq_wr_duration(bfqd);\n\n\t\t\tbfqd->wr_busy_queues++;\n\t\t\tbfqq->entity.prio_changed = 1;\n\t\t}\n\t\tif (prev != bfqq->next_rq)\n\t\t\tbfq_updated_next_req(bfqd, bfqq);\n\t}\n\n\t/*\n\t * Assign jiffies to last_wr_start_finish in the following\n\t * cases:\n\t *\n\t * . if bfqq is not going to be weight-raised, because, for\n\t *   non weight-raised queues, last_wr_start_finish stores the\n\t *   arrival time of the last request; as of now, this piece\n\t *   of information is used only for deciding whether to\n\t *   weight-raise async queues\n\t *\n\t * . if bfqq is not weight-raised, because, if bfqq is now\n\t *   switching to weight-raised, then last_wr_start_finish\n\t *   stores the time when weight-raising starts\n\t *\n\t * . if bfqq is interactive, because, regardless of whether\n\t *   bfqq is currently weight-raised, the weight-raising\n\t *   period must start or restart (this case is considered\n\t *   separately because it is not detected by the above\n\t *   conditions, if bfqq is already weight-raised)\n\t *\n\t * last_wr_start_finish has to be updated also if bfqq is soft\n\t * real-time, because the weight-raising period is constantly\n\t * restarted on idle-to-busy transitions for these queues, but\n\t * this is already done in bfq_bfqq_handle_idle_busy_switch if\n\t * needed.\n\t */\n\tif (bfqd->low_latency &&\n\t\t(old_wr_coeff == 1 || bfqq->wr_coeff == 1 || interactive))\n\t\tbfqq->last_wr_start_finish = jiffies;\n}\n\nstatic struct request *bfq_find_rq_fmerge(struct bfq_data *bfqd,\n\t\t\t\t\t  struct bio *bio,\n\t\t\t\t\t  struct request_queue *q)\n{\n\tstruct bfq_queue *bfqq = bfqd->bio_bfqq;\n\n\n\tif (bfqq)\n\t\treturn elv_rb_find(&bfqq->sort_list, bio_end_sector(bio));\n\n\treturn NULL;\n}\n\nstatic sector_t get_sdist(sector_t last_pos, struct request *rq)\n{\n\tif (last_pos)\n\t\treturn abs(blk_rq_pos(rq) - last_pos);\n\n\treturn 0;\n}\n\n#if 0 /* Still not clear if we can do without next two functions */\nstatic void bfq_activate_request(struct request_queue *q, struct request *rq)\n{\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\n\tbfqd->rq_in_driver++;\n}\n\nstatic void bfq_deactivate_request(struct request_queue *q, struct request *rq)\n{\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\n\tbfqd->rq_in_driver--;\n}\n#endif\n\nstatic void bfq_remove_request(struct request_queue *q,\n\t\t\t       struct request *rq)\n{\n\tstruct bfq_queue *bfqq = RQ_BFQQ(rq);\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tconst int sync = rq_is_sync(rq);\n\n\tif (bfqq->next_rq == rq) {\n\t\tbfqq->next_rq = bfq_find_next_rq(bfqd, bfqq, rq);\n\t\tbfq_updated_next_req(bfqd, bfqq);\n\t}\n\n\tif (rq->queuelist.prev != &rq->queuelist)\n\t\tlist_del_init(&rq->queuelist);\n\tbfqq->queued[sync]--;\n\tbfqd->queued--;\n\telv_rb_del(&bfqq->sort_list, rq);\n\n\telv_rqhash_del(q, rq);\n\tif (q->last_merge == rq)\n\t\tq->last_merge = NULL;\n\n\tif (RB_EMPTY_ROOT(&bfqq->sort_list)) {\n\t\tbfqq->next_rq = NULL;\n\n\t\tif (bfq_bfqq_busy(bfqq) && bfqq != bfqd->in_service_queue) {\n\t\t\tbfq_del_bfqq_busy(bfqd, bfqq, false);\n\t\t\t/*\n\t\t\t * bfqq emptied. In normal operation, when\n\t\t\t * bfqq is empty, bfqq->entity.service and\n\t\t\t * bfqq->entity.budget must contain,\n\t\t\t * respectively, the service received and the\n\t\t\t * budget used last time bfqq emptied. These\n\t\t\t * facts do not hold in this case, as at least\n\t\t\t * this last removal occurred while bfqq is\n\t\t\t * not in service. To avoid inconsistencies,\n\t\t\t * reset both bfqq->entity.service and\n\t\t\t * bfqq->entity.budget, if bfqq has still a\n\t\t\t * process that may issue I/O requests to it.\n\t\t\t */\n\t\t\tbfqq->entity.budget = bfqq->entity.service = 0;\n\t\t}\n\n\t\t/*\n\t\t * Remove queue from request-position tree as it is empty.\n\t\t */\n\t\tif (bfqq->pos_root) {\n\t\t\trb_erase(&bfqq->pos_node, bfqq->pos_root);\n\t\t\tbfqq->pos_root = NULL;\n\t\t}\n\t} else {\n\t\t/* see comments on bfq_pos_tree_add_move() for the unlikely() */\n\t\tif (unlikely(!bfqd->nonrot_with_queueing))\n\t\t\tbfq_pos_tree_add_move(bfqd, bfqq);\n\t}\n\n\tif (rq->cmd_flags & REQ_META)\n\t\tbfqq->meta_pending--;\n\n}\n\nstatic bool bfq_bio_merge(struct blk_mq_hw_ctx *hctx, struct bio *bio,\n\t\tunsigned int nr_segs)\n{\n\tstruct request_queue *q = hctx->queue;\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\tstruct request *free = NULL;\n\t/*\n\t * bfq_bic_lookup grabs the queue_lock: invoke it now and\n\t * store its return value for later use, to avoid nesting\n\t * queue_lock inside the bfqd->lock. We assume that the bic\n\t * returned by bfq_bic_lookup does not go away before\n\t * bfqd->lock is taken.\n\t */\n\tstruct bfq_io_cq *bic = bfq_bic_lookup(bfqd, current->io_context, q);\n\tbool ret;\n\n\tspin_lock_irq(&bfqd->lock);\n\n\tif (bic)\n\t\tbfqd->bio_bfqq = bic_to_bfqq(bic, op_is_sync(bio->bi_opf));\n\telse\n\t\tbfqd->bio_bfqq = NULL;\n\tbfqd->bio_bic = bic;\n\n\tret = blk_mq_sched_try_merge(q, bio, nr_segs, &free);\n\n\tif (free)\n\t\tblk_mq_free_request(free);\n\tspin_unlock_irq(&bfqd->lock);\n\n\treturn ret;\n}\n\nstatic int bfq_request_merge(struct request_queue *q, struct request **req,\n\t\t\t     struct bio *bio)\n{\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\tstruct request *__rq;\n\n\t__rq = bfq_find_rq_fmerge(bfqd, bio, q);\n\tif (__rq && elv_bio_merge_ok(__rq, bio)) {\n\t\t*req = __rq;\n\t\treturn ELEVATOR_FRONT_MERGE;\n\t}\n\n\treturn ELEVATOR_NO_MERGE;\n}\n\nstatic struct bfq_queue *bfq_init_rq(struct request *rq);\n\nstatic void bfq_request_merged(struct request_queue *q, struct request *req,\n\t\t\t       enum elv_merge type)\n{\n\tif (type == ELEVATOR_FRONT_MERGE &&\n\t    rb_prev(&req->rb_node) &&\n\t    blk_rq_pos(req) <\n\t    blk_rq_pos(container_of(rb_prev(&req->rb_node),\n\t\t\t\t    struct request, rb_node))) {\n\t\tstruct bfq_queue *bfqq = bfq_init_rq(req);\n\t\tstruct bfq_data *bfqd;\n\t\tstruct request *prev, *next_rq;\n\n\t\tif (!bfqq)\n\t\t\treturn;\n\n\t\tbfqd = bfqq->bfqd;\n\n\t\t/* Reposition request in its sort_list */\n\t\telv_rb_del(&bfqq->sort_list, req);\n\t\telv_rb_add(&bfqq->sort_list, req);\n\n\t\t/* Choose next request to be served for bfqq */\n\t\tprev = bfqq->next_rq;\n\t\tnext_rq = bfq_choose_req(bfqd, bfqq->next_rq, req,\n\t\t\t\t\t bfqd->last_position);\n\t\tbfqq->next_rq = next_rq;\n\t\t/*\n\t\t * If next_rq changes, update both the queue's budget to\n\t\t * fit the new request and the queue's position in its\n\t\t * rq_pos_tree.\n\t\t */\n\t\tif (prev != bfqq->next_rq) {\n\t\t\tbfq_updated_next_req(bfqd, bfqq);\n\t\t\t/*\n\t\t\t * See comments on bfq_pos_tree_add_move() for\n\t\t\t * the unlikely().\n\t\t\t */\n\t\t\tif (unlikely(!bfqd->nonrot_with_queueing))\n\t\t\t\tbfq_pos_tree_add_move(bfqd, bfqq);\n\t\t}\n\t}\n}\n\n/*\n * This function is called to notify the scheduler that the requests\n * rq and 'next' have been merged, with 'next' going away.  BFQ\n * exploits this hook to address the following issue: if 'next' has a\n * fifo_time lower that rq, then the fifo_time of rq must be set to\n * the value of 'next', to not forget the greater age of 'next'.\n *\n * NOTE: in this function we assume that rq is in a bfq_queue, basing\n * on that rq is picked from the hash table q->elevator->hash, which,\n * in its turn, is filled only with I/O requests present in\n * bfq_queues, while BFQ is in use for the request queue q. In fact,\n * the function that fills this hash table (elv_rqhash_add) is called\n * only by bfq_insert_request.\n */\nstatic void bfq_requests_merged(struct request_queue *q, struct request *rq,\n\t\t\t\tstruct request *next)\n{\n\tstruct bfq_queue *bfqq = bfq_init_rq(rq),\n\t\t*next_bfqq = bfq_init_rq(next);\n\n\tif (!bfqq)\n\t\treturn;\n\n\t/*\n\t * If next and rq belong to the same bfq_queue and next is older\n\t * than rq, then reposition rq in the fifo (by substituting next\n\t * with rq). Otherwise, if next and rq belong to different\n\t * bfq_queues, never reposition rq: in fact, we would have to\n\t * reposition it with respect to next's position in its own fifo,\n\t * which would most certainly be too expensive with respect to\n\t * the benefits.\n\t */\n\tif (bfqq == next_bfqq &&\n\t    !list_empty(&rq->queuelist) && !list_empty(&next->queuelist) &&\n\t    next->fifo_time < rq->fifo_time) {\n\t\tlist_del_init(&rq->queuelist);\n\t\tlist_replace_init(&next->queuelist, &rq->queuelist);\n\t\trq->fifo_time = next->fifo_time;\n\t}\n\n\tif (bfqq->next_rq == next)\n\t\tbfqq->next_rq = rq;\n\n\tbfqg_stats_update_io_merged(bfqq_group(bfqq), next->cmd_flags);\n}\n\n/* Must be called with bfqq != NULL */\nstatic void bfq_bfqq_end_wr(struct bfq_queue *bfqq)\n{\n\tif (bfq_bfqq_busy(bfqq))\n\t\tbfqq->bfqd->wr_busy_queues--;\n\tbfqq->wr_coeff = 1;\n\tbfqq->wr_cur_max_time = 0;\n\tbfqq->last_wr_start_finish = jiffies;\n\t/*\n\t * Trigger a weight change on the next invocation of\n\t * __bfq_entity_update_weight_prio.\n\t */\n\tbfqq->entity.prio_changed = 1;\n}\n\nvoid bfq_end_wr_async_queues(struct bfq_data *bfqd,\n\t\t\t     struct bfq_group *bfqg)\n{\n\tint i, j;\n\n\tfor (i = 0; i < 2; i++)\n\t\tfor (j = 0; j < IOPRIO_BE_NR; j++)\n\t\t\tif (bfqg->async_bfqq[i][j])\n\t\t\t\tbfq_bfqq_end_wr(bfqg->async_bfqq[i][j]);\n\tif (bfqg->async_idle_bfqq)\n\t\tbfq_bfqq_end_wr(bfqg->async_idle_bfqq);\n}\n\nstatic void bfq_end_wr(struct bfq_data *bfqd)\n{\n\tstruct bfq_queue *bfqq;\n\n\tspin_lock_irq(&bfqd->lock);\n\n\tlist_for_each_entry(bfqq, &bfqd->active_list, bfqq_list)\n\t\tbfq_bfqq_end_wr(bfqq);\n\tlist_for_each_entry(bfqq, &bfqd->idle_list, bfqq_list)\n\t\tbfq_bfqq_end_wr(bfqq);\n\tbfq_end_wr_async(bfqd);\n\n\tspin_unlock_irq(&bfqd->lock);\n}\n\nstatic sector_t bfq_io_struct_pos(void *io_struct, bool request)\n{\n\tif (request)\n\t\treturn blk_rq_pos(io_struct);\n\telse\n\t\treturn ((struct bio *)io_struct)->bi_iter.bi_sector;\n}\n\nstatic int bfq_rq_close_to_sector(void *io_struct, bool request,\n\t\t\t\t  sector_t sector)\n{\n\treturn abs(bfq_io_struct_pos(io_struct, request) - sector) <=\n\t       BFQQ_CLOSE_THR;\n}\n\nstatic struct bfq_queue *bfqq_find_close(struct bfq_data *bfqd,\n\t\t\t\t\t struct bfq_queue *bfqq,\n\t\t\t\t\t sector_t sector)\n{\n\tstruct rb_root *root = &bfq_bfqq_to_bfqg(bfqq)->rq_pos_tree;\n\tstruct rb_node *parent, *node;\n\tstruct bfq_queue *__bfqq;\n\n\tif (RB_EMPTY_ROOT(root))\n\t\treturn NULL;\n\n\t/*\n\t * First, if we find a request starting at the end of the last\n\t * request, choose it.\n\t */\n\t__bfqq = bfq_rq_pos_tree_lookup(bfqd, root, sector, &parent, NULL);\n\tif (__bfqq)\n\t\treturn __bfqq;\n\n\t/*\n\t * If the exact sector wasn't found, the parent of the NULL leaf\n\t * will contain the closest sector (rq_pos_tree sorted by\n\t * next_request position).\n\t */\n\t__bfqq = rb_entry(parent, struct bfq_queue, pos_node);\n\tif (bfq_rq_close_to_sector(__bfqq->next_rq, true, sector))\n\t\treturn __bfqq;\n\n\tif (blk_rq_pos(__bfqq->next_rq) < sector)\n\t\tnode = rb_next(&__bfqq->pos_node);\n\telse\n\t\tnode = rb_prev(&__bfqq->pos_node);\n\tif (!node)\n\t\treturn NULL;\n\n\t__bfqq = rb_entry(node, struct bfq_queue, pos_node);\n\tif (bfq_rq_close_to_sector(__bfqq->next_rq, true, sector))\n\t\treturn __bfqq;\n\n\treturn NULL;\n}\n\nstatic struct bfq_queue *bfq_find_close_cooperator(struct bfq_data *bfqd,\n\t\t\t\t\t\t   struct bfq_queue *cur_bfqq,\n\t\t\t\t\t\t   sector_t sector)\n{\n\tstruct bfq_queue *bfqq;\n\n\t/*\n\t * We shall notice if some of the queues are cooperating,\n\t * e.g., working closely on the same area of the device. In\n\t * that case, we can group them together and: 1) don't waste\n\t * time idling, and 2) serve the union of their requests in\n\t * the best possible order for throughput.\n\t */\n\tbfqq = bfqq_find_close(bfqd, cur_bfqq, sector);\n\tif (!bfqq || bfqq == cur_bfqq)\n\t\treturn NULL;\n\n\treturn bfqq;\n}\n\nstatic struct bfq_queue *\nbfq_setup_merge(struct bfq_queue *bfqq, struct bfq_queue *new_bfqq)\n{\n\tint process_refs, new_process_refs;\n\tstruct bfq_queue *__bfqq;\n\n\t/*\n\t * If there are no process references on the new_bfqq, then it is\n\t * unsafe to follow the ->new_bfqq chain as other bfqq's in the chain\n\t * may have dropped their last reference (not just their last process\n\t * reference).\n\t */\n\tif (!bfqq_process_refs(new_bfqq))\n\t\treturn NULL;\n\n\t/* Avoid a circular list and skip interim queue merges. */\n\twhile ((__bfqq = new_bfqq->new_bfqq)) {\n\t\tif (__bfqq == bfqq)\n\t\t\treturn NULL;\n\t\tnew_bfqq = __bfqq;\n\t}\n\n\tprocess_refs = bfqq_process_refs(bfqq);\n\tnew_process_refs = bfqq_process_refs(new_bfqq);\n\t/*\n\t * If the process for the bfqq has gone away, there is no\n\t * sense in merging the queues.\n\t */\n\tif (process_refs == 0 || new_process_refs == 0)\n\t\treturn NULL;\n\n\tbfq_log_bfqq(bfqq->bfqd, bfqq, \"scheduling merge with queue %d\",\n\t\tnew_bfqq->pid);\n\n\t/*\n\t * Merging is just a redirection: the requests of the process\n\t * owning one of the two queues are redirected to the other queue.\n\t * The latter queue, in its turn, is set as shared if this is the\n\t * first time that the requests of some process are redirected to\n\t * it.\n\t *\n\t * We redirect bfqq to new_bfqq and not the opposite, because\n\t * we are in the context of the process owning bfqq, thus we\n\t * have the io_cq of this process. So we can immediately\n\t * configure this io_cq to redirect the requests of the\n\t * process to new_bfqq. In contrast, the io_cq of new_bfqq is\n\t * not available any more (new_bfqq->bic == NULL).\n\t *\n\t * Anyway, even in case new_bfqq coincides with the in-service\n\t * queue, redirecting requests the in-service queue is the\n\t * best option, as we feed the in-service queue with new\n\t * requests close to the last request served and, by doing so,\n\t * are likely to increase the throughput.\n\t */\n\tbfqq->new_bfqq = new_bfqq;\n\tnew_bfqq->ref += process_refs;\n\treturn new_bfqq;\n}\n\nstatic bool bfq_may_be_close_cooperator(struct bfq_queue *bfqq,\n\t\t\t\t\tstruct bfq_queue *new_bfqq)\n{\n\tif (bfq_too_late_for_merging(new_bfqq))\n\t\treturn false;\n\n\tif (bfq_class_idle(bfqq) || bfq_class_idle(new_bfqq) ||\n\t    (bfqq->ioprio_class != new_bfqq->ioprio_class))\n\t\treturn false;\n\n\t/*\n\t * If either of the queues has already been detected as seeky,\n\t * then merging it with the other queue is unlikely to lead to\n\t * sequential I/O.\n\t */\n\tif (BFQQ_SEEKY(bfqq) || BFQQ_SEEKY(new_bfqq))\n\t\treturn false;\n\n\t/*\n\t * Interleaved I/O is known to be done by (some) applications\n\t * only for reads, so it does not make sense to merge async\n\t * queues.\n\t */\n\tif (!bfq_bfqq_sync(bfqq) || !bfq_bfqq_sync(new_bfqq))\n\t\treturn false;\n\n\treturn true;\n}\n\n/*\n * Attempt to schedule a merge of bfqq with the currently in-service\n * queue or with a close queue among the scheduled queues.  Return\n * NULL if no merge was scheduled, a pointer to the shared bfq_queue\n * structure otherwise.\n *\n * The OOM queue is not allowed to participate to cooperation: in fact, since\n * the requests temporarily redirected to the OOM queue could be redirected\n * again to dedicated queues at any time, the state needed to correctly\n * handle merging with the OOM queue would be quite complex and expensive\n * to maintain. Besides, in such a critical condition as an out of memory,\n * the benefits of queue merging may be little relevant, or even negligible.\n *\n * WARNING: queue merging may impair fairness among non-weight raised\n * queues, for at least two reasons: 1) the original weight of a\n * merged queue may change during the merged state, 2) even being the\n * weight the same, a merged queue may be bloated with many more\n * requests than the ones produced by its originally-associated\n * process.\n */\nstatic struct bfq_queue *\nbfq_setup_cooperator(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t     void *io_struct, bool request)\n{\n\tstruct bfq_queue *in_service_bfqq, *new_bfqq;\n\n\t/*\n\t * Do not perform queue merging if the device is non\n\t * rotational and performs internal queueing. In fact, such a\n\t * device reaches a high speed through internal parallelism\n\t * and pipelining. This means that, to reach a high\n\t * throughput, it must have many requests enqueued at the same\n\t * time. But, in this configuration, the internal scheduling\n\t * algorithm of the device does exactly the job of queue\n\t * merging: it reorders requests so as to obtain as much as\n\t * possible a sequential I/O pattern. As a consequence, with\n\t * the workload generated by processes doing interleaved I/O,\n\t * the throughput reached by the device is likely to be the\n\t * same, with and without queue merging.\n\t *\n\t * Disabling merging also provides a remarkable benefit in\n\t * terms of throughput. Merging tends to make many workloads\n\t * artificially more uneven, because of shared queues\n\t * remaining non empty for incomparably more time than\n\t * non-merged queues. This may accentuate workload\n\t * asymmetries. For example, if one of the queues in a set of\n\t * merged queues has a higher weight than a normal queue, then\n\t * the shared queue may inherit such a high weight and, by\n\t * staying almost always active, may force BFQ to perform I/O\n\t * plugging most of the time. This evidently makes it harder\n\t * for BFQ to let the device reach a high throughput.\n\t *\n\t * Finally, the likely() macro below is not used because one\n\t * of the two branches is more likely than the other, but to\n\t * have the code path after the following if() executed as\n\t * fast as possible for the case of a non rotational device\n\t * with queueing. We want it because this is the fastest kind\n\t * of device. On the opposite end, the likely() may lengthen\n\t * the execution time of BFQ for the case of slower devices\n\t * (rotational or at least without queueing). But in this case\n\t * the execution time of BFQ matters very little, if not at\n\t * all.\n\t */\n\tif (likely(bfqd->nonrot_with_queueing))\n\t\treturn NULL;\n\n\t/*\n\t * Prevent bfqq from being merged if it has been created too\n\t * long ago. The idea is that true cooperating processes, and\n\t * thus their associated bfq_queues, are supposed to be\n\t * created shortly after each other. This is the case, e.g.,\n\t * for KVM/QEMU and dump I/O threads. Basing on this\n\t * assumption, the following filtering greatly reduces the\n\t * probability that two non-cooperating processes, which just\n\t * happen to do close I/O for some short time interval, have\n\t * their queues merged by mistake.\n\t */\n\tif (bfq_too_late_for_merging(bfqq))\n\t\treturn NULL;\n\n\tif (bfqq->new_bfqq)\n\t\treturn bfqq->new_bfqq;\n\n\tif (!io_struct || unlikely(bfqq == &bfqd->oom_bfqq))\n\t\treturn NULL;\n\n\t/* If there is only one backlogged queue, don't search. */\n\tif (bfq_tot_busy_queues(bfqd) == 1)\n\t\treturn NULL;\n\n\tin_service_bfqq = bfqd->in_service_queue;\n\n\tif (in_service_bfqq && in_service_bfqq != bfqq &&\n\t    likely(in_service_bfqq != &bfqd->oom_bfqq) &&\n\t    bfq_rq_close_to_sector(io_struct, request,\n\t\t\t\t   bfqd->in_serv_last_pos) &&\n\t    bfqq->entity.parent == in_service_bfqq->entity.parent &&\n\t    bfq_may_be_close_cooperator(bfqq, in_service_bfqq)) {\n\t\tnew_bfqq = bfq_setup_merge(bfqq, in_service_bfqq);\n\t\tif (new_bfqq)\n\t\t\treturn new_bfqq;\n\t}\n\t/*\n\t * Check whether there is a cooperator among currently scheduled\n\t * queues. The only thing we need is that the bio/request is not\n\t * NULL, as we need it to establish whether a cooperator exists.\n\t */\n\tnew_bfqq = bfq_find_close_cooperator(bfqd, bfqq,\n\t\t\tbfq_io_struct_pos(io_struct, request));\n\n\tif (new_bfqq && likely(new_bfqq != &bfqd->oom_bfqq) &&\n\t    bfq_may_be_close_cooperator(bfqq, new_bfqq))\n\t\treturn bfq_setup_merge(bfqq, new_bfqq);\n\n\treturn NULL;\n}\n\nstatic void bfq_bfqq_save_state(struct bfq_queue *bfqq)\n{\n\tstruct bfq_io_cq *bic = bfqq->bic;\n\n\t/*\n\t * If !bfqq->bic, the queue is already shared or its requests\n\t * have already been redirected to a shared queue; both idle window\n\t * and weight raising state have already been saved. Do nothing.\n\t */\n\tif (!bic)\n\t\treturn;\n\n\tbic->saved_weight = bfqq->entity.orig_weight;\n\tbic->saved_ttime = bfqq->ttime;\n\tbic->saved_has_short_ttime = bfq_bfqq_has_short_ttime(bfqq);\n\tbic->saved_IO_bound = bfq_bfqq_IO_bound(bfqq);\n\tbic->saved_in_large_burst = bfq_bfqq_in_large_burst(bfqq);\n\tbic->was_in_burst_list = !hlist_unhashed(&bfqq->burst_list_node);\n\tif (unlikely(bfq_bfqq_just_created(bfqq) &&\n\t\t     !bfq_bfqq_in_large_burst(bfqq) &&\n\t\t     bfqq->bfqd->low_latency)) {\n\t\t/*\n\t\t * bfqq being merged right after being created: bfqq\n\t\t * would have deserved interactive weight raising, but\n\t\t * did not make it to be set in a weight-raised state,\n\t\t * because of this early merge.\tStore directly the\n\t\t * weight-raising state that would have been assigned\n\t\t * to bfqq, so that to avoid that bfqq unjustly fails\n\t\t * to enjoy weight raising if split soon.\n\t\t */\n\t\tbic->saved_wr_coeff = bfqq->bfqd->bfq_wr_coeff;\n\t\tbic->saved_wr_start_at_switch_to_srt = bfq_smallest_from_now();\n\t\tbic->saved_wr_cur_max_time = bfq_wr_duration(bfqq->bfqd);\n\t\tbic->saved_last_wr_start_finish = jiffies;\n\t} else {\n\t\tbic->saved_wr_coeff = bfqq->wr_coeff;\n\t\tbic->saved_wr_start_at_switch_to_srt =\n\t\t\tbfqq->wr_start_at_switch_to_srt;\n\t\tbic->saved_last_wr_start_finish = bfqq->last_wr_start_finish;\n\t\tbic->saved_wr_cur_max_time = bfqq->wr_cur_max_time;\n\t}\n}\n\nvoid bfq_release_process_ref(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\t/*\n\t * To prevent bfqq's service guarantees from being violated,\n\t * bfqq may be left busy, i.e., queued for service, even if\n\t * empty (see comments in __bfq_bfqq_expire() for\n\t * details). But, if no process will send requests to bfqq any\n\t * longer, then there is no point in keeping bfqq queued for\n\t * service. In addition, keeping bfqq queued for service, but\n\t * with no process ref any longer, may have caused bfqq to be\n\t * freed when dequeued from service. But this is assumed to\n\t * never happen.\n\t */\n\tif (bfq_bfqq_busy(bfqq) && RB_EMPTY_ROOT(&bfqq->sort_list) &&\n\t    bfqq != bfqd->in_service_queue)\n\t\tbfq_del_bfqq_busy(bfqd, bfqq, false);\n\n\tbfq_put_queue(bfqq);\n}\n\nstatic void\nbfq_merge_bfqqs(struct bfq_data *bfqd, struct bfq_io_cq *bic,\n\t\tstruct bfq_queue *bfqq, struct bfq_queue *new_bfqq)\n{\n\tbfq_log_bfqq(bfqd, bfqq, \"merging with queue %lu\",\n\t\t(unsigned long)new_bfqq->pid);\n\t/* Save weight raising and idle window of the merged queues */\n\tbfq_bfqq_save_state(bfqq);\n\tbfq_bfqq_save_state(new_bfqq);\n\tif (bfq_bfqq_IO_bound(bfqq))\n\t\tbfq_mark_bfqq_IO_bound(new_bfqq);\n\tbfq_clear_bfqq_IO_bound(bfqq);\n\n\t/*\n\t * If bfqq is weight-raised, then let new_bfqq inherit\n\t * weight-raising. To reduce false positives, neglect the case\n\t * where bfqq has just been created, but has not yet made it\n\t * to be weight-raised (which may happen because EQM may merge\n\t * bfqq even before bfq_add_request is executed for the first\n\t * time for bfqq). Handling this case would however be very\n\t * easy, thanks to the flag just_created.\n\t */\n\tif (new_bfqq->wr_coeff == 1 && bfqq->wr_coeff > 1) {\n\t\tnew_bfqq->wr_coeff = bfqq->wr_coeff;\n\t\tnew_bfqq->wr_cur_max_time = bfqq->wr_cur_max_time;\n\t\tnew_bfqq->last_wr_start_finish = bfqq->last_wr_start_finish;\n\t\tnew_bfqq->wr_start_at_switch_to_srt =\n\t\t\tbfqq->wr_start_at_switch_to_srt;\n\t\tif (bfq_bfqq_busy(new_bfqq))\n\t\t\tbfqd->wr_busy_queues++;\n\t\tnew_bfqq->entity.prio_changed = 1;\n\t}\n\n\tif (bfqq->wr_coeff > 1) { /* bfqq has given its wr to new_bfqq */\n\t\tbfqq->wr_coeff = 1;\n\t\tbfqq->entity.prio_changed = 1;\n\t\tif (bfq_bfqq_busy(bfqq))\n\t\t\tbfqd->wr_busy_queues--;\n\t}\n\n\tbfq_log_bfqq(bfqd, new_bfqq, \"merge_bfqqs: wr_busy %d\",\n\t\t     bfqd->wr_busy_queues);\n\n\t/*\n\t * Merge queues (that is, let bic redirect its requests to new_bfqq)\n\t */\n\tbic_set_bfqq(bic, new_bfqq, 1);\n\tbfq_mark_bfqq_coop(new_bfqq);\n\t/*\n\t * new_bfqq now belongs to at least two bics (it is a shared queue):\n\t * set new_bfqq->bic to NULL. bfqq either:\n\t * - does not belong to any bic any more, and hence bfqq->bic must\n\t *   be set to NULL, or\n\t * - is a queue whose owning bics have already been redirected to a\n\t *   different queue, hence the queue is destined to not belong to\n\t *   any bic soon and bfqq->bic is already NULL (therefore the next\n\t *   assignment causes no harm).\n\t */\n\tnew_bfqq->bic = NULL;\n\t/*\n\t * If the queue is shared, the pid is the pid of one of the associated\n\t * processes. Which pid depends on the exact sequence of merge events\n\t * the queue underwent. So printing such a pid is useless and confusing\n\t * because it reports a random pid between those of the associated\n\t * processes.\n\t * We mark such a queue with a pid -1, and then print SHARED instead of\n\t * a pid in logging messages.\n\t */\n\tnew_bfqq->pid = -1;\n\tbfqq->bic = NULL;\n\tbfq_release_process_ref(bfqd, bfqq);\n}\n\nstatic bool bfq_allow_bio_merge(struct request_queue *q, struct request *rq,\n\t\t\t\tstruct bio *bio)\n{\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\tbool is_sync = op_is_sync(bio->bi_opf);\n\tstruct bfq_queue *bfqq = bfqd->bio_bfqq, *new_bfqq;\n\n\t/*\n\t * Disallow merge of a sync bio into an async request.\n\t */\n\tif (is_sync && !rq_is_sync(rq))\n\t\treturn false;\n\n\t/*\n\t * Lookup the bfqq that this bio will be queued with. Allow\n\t * merge only if rq is queued there.\n\t */\n\tif (!bfqq)\n\t\treturn false;\n\n\t/*\n\t * We take advantage of this function to perform an early merge\n\t * of the queues of possible cooperating processes.\n\t */\n\tnew_bfqq = bfq_setup_cooperator(bfqd, bfqq, bio, false);\n\tif (new_bfqq) {\n\t\t/*\n\t\t * bic still points to bfqq, then it has not yet been\n\t\t * redirected to some other bfq_queue, and a queue\n\t\t * merge between bfqq and new_bfqq can be safely\n\t\t * fulfilled, i.e., bic can be redirected to new_bfqq\n\t\t * and bfqq can be put.\n\t\t */\n\t\tbfq_merge_bfqqs(bfqd, bfqd->bio_bic, bfqq,\n\t\t\t\tnew_bfqq);\n\t\t/*\n\t\t * If we get here, bio will be queued into new_queue,\n\t\t * so use new_bfqq to decide whether bio and rq can be\n\t\t * merged.\n\t\t */\n\t\tbfqq = new_bfqq;\n\n\t\t/*\n\t\t * Change also bqfd->bio_bfqq, as\n\t\t * bfqd->bio_bic now points to new_bfqq, and\n\t\t * this function may be invoked again (and then may\n\t\t * use again bqfd->bio_bfqq).\n\t\t */\n\t\tbfqd->bio_bfqq = bfqq;\n\t}\n\n\treturn bfqq == RQ_BFQQ(rq);\n}\n\n/*\n * Set the maximum time for the in-service queue to consume its\n * budget. This prevents seeky processes from lowering the throughput.\n * In practice, a time-slice service scheme is used with seeky\n * processes.\n */\nstatic void bfq_set_budget_timeout(struct bfq_data *bfqd,\n\t\t\t\t   struct bfq_queue *bfqq)\n{\n\tunsigned int timeout_coeff;\n\n\tif (bfqq->wr_cur_max_time == bfqd->bfq_wr_rt_max_time)\n\t\ttimeout_coeff = 1;\n\telse\n\t\ttimeout_coeff = bfqq->entity.weight / bfqq->entity.orig_weight;\n\n\tbfqd->last_budget_start = ktime_get();\n\n\tbfqq->budget_timeout = jiffies +\n\t\tbfqd->bfq_timeout * timeout_coeff;\n}\n\nstatic void __bfq_set_in_service_queue(struct bfq_data *bfqd,\n\t\t\t\t       struct bfq_queue *bfqq)\n{\n\tif (bfqq) {\n\t\tbfq_clear_bfqq_fifo_expire(bfqq);\n\n\t\tbfqd->budgets_assigned = (bfqd->budgets_assigned * 7 + 256) / 8;\n\n\t\tif (time_is_before_jiffies(bfqq->last_wr_start_finish) &&\n\t\t    bfqq->wr_coeff > 1 &&\n\t\t    bfqq->wr_cur_max_time == bfqd->bfq_wr_rt_max_time &&\n\t\t    time_is_before_jiffies(bfqq->budget_timeout)) {\n\t\t\t/*\n\t\t\t * For soft real-time queues, move the start\n\t\t\t * of the weight-raising period forward by the\n\t\t\t * time the queue has not received any\n\t\t\t * service. Otherwise, a relatively long\n\t\t\t * service delay is likely to cause the\n\t\t\t * weight-raising period of the queue to end,\n\t\t\t * because of the short duration of the\n\t\t\t * weight-raising period of a soft real-time\n\t\t\t * queue.  It is worth noting that this move\n\t\t\t * is not so dangerous for the other queues,\n\t\t\t * because soft real-time queues are not\n\t\t\t * greedy.\n\t\t\t *\n\t\t\t * To not add a further variable, we use the\n\t\t\t * overloaded field budget_timeout to\n\t\t\t * determine for how long the queue has not\n\t\t\t * received service, i.e., how much time has\n\t\t\t * elapsed since the queue expired. However,\n\t\t\t * this is a little imprecise, because\n\t\t\t * budget_timeout is set to jiffies if bfqq\n\t\t\t * not only expires, but also remains with no\n\t\t\t * request.\n\t\t\t */\n\t\t\tif (time_after(bfqq->budget_timeout,\n\t\t\t\t       bfqq->last_wr_start_finish))\n\t\t\t\tbfqq->last_wr_start_finish +=\n\t\t\t\t\tjiffies - bfqq->budget_timeout;\n\t\t\telse\n\t\t\t\tbfqq->last_wr_start_finish = jiffies;\n\t\t}\n\n\t\tbfq_set_budget_timeout(bfqd, bfqq);\n\t\tbfq_log_bfqq(bfqd, bfqq,\n\t\t\t     \"set_in_service_queue, cur-budget = %d\",\n\t\t\t     bfqq->entity.budget);\n\t}\n\n\tbfqd->in_service_queue = bfqq;\n}\n\n/*\n * Get and set a new queue for service.\n */\nstatic struct bfq_queue *bfq_set_in_service_queue(struct bfq_data *bfqd)\n{\n\tstruct bfq_queue *bfqq = bfq_get_next_queue(bfqd);\n\n\t__bfq_set_in_service_queue(bfqd, bfqq);\n\treturn bfqq;\n}\n\nstatic void bfq_arm_slice_timer(struct bfq_data *bfqd)\n{\n\tstruct bfq_queue *bfqq = bfqd->in_service_queue;\n\tu32 sl;\n\n\tbfq_mark_bfqq_wait_request(bfqq);\n\n\t/*\n\t * We don't want to idle for seeks, but we do want to allow\n\t * fair distribution of slice time for a process doing back-to-back\n\t * seeks. So allow a little bit of time for him to submit a new rq.\n\t */\n\tsl = bfqd->bfq_slice_idle;\n\t/*\n\t * Unless the queue is being weight-raised or the scenario is\n\t * asymmetric, grant only minimum idle time if the queue\n\t * is seeky. A long idling is preserved for a weight-raised\n\t * queue, or, more in general, in an asymmetric scenario,\n\t * because a long idling is needed for guaranteeing to a queue\n\t * its reserved share of the throughput (in particular, it is\n\t * needed if the queue has a higher weight than some other\n\t * queue).\n\t */\n\tif (BFQQ_SEEKY(bfqq) && bfqq->wr_coeff == 1 &&\n\t    !bfq_asymmetric_scenario(bfqd, bfqq))\n\t\tsl = min_t(u64, sl, BFQ_MIN_TT);\n\telse if (bfqq->wr_coeff > 1)\n\t\tsl = max_t(u32, sl, 20ULL * NSEC_PER_MSEC);\n\n\tbfqd->last_idling_start = ktime_get();\n\tbfqd->last_idling_start_jiffies = jiffies;\n\n\thrtimer_start(&bfqd->idle_slice_timer, ns_to_ktime(sl),\n\t\t      HRTIMER_MODE_REL);\n\tbfqg_stats_set_start_idle_time(bfqq_group(bfqq));\n}\n\n/*\n * In autotuning mode, max_budget is dynamically recomputed as the\n * amount of sectors transferred in timeout at the estimated peak\n * rate. This enables BFQ to utilize a full timeslice with a full\n * budget, even if the in-service queue is served at peak rate. And\n * this maximises throughput with sequential workloads.\n */\nstatic unsigned long bfq_calc_max_budget(struct bfq_data *bfqd)\n{\n\treturn (u64)bfqd->peak_rate * USEC_PER_MSEC *\n\t\tjiffies_to_msecs(bfqd->bfq_timeout)>>BFQ_RATE_SHIFT;\n}\n\n/*\n * Update parameters related to throughput and responsiveness, as a\n * function of the estimated peak rate. See comments on\n * bfq_calc_max_budget(), and on the ref_wr_duration array.\n */\nstatic void update_thr_responsiveness_params(struct bfq_data *bfqd)\n{\n\tif (bfqd->bfq_user_max_budget == 0) {\n\t\tbfqd->bfq_max_budget =\n\t\t\tbfq_calc_max_budget(bfqd);\n\t\tbfq_log(bfqd, \"new max_budget = %d\", bfqd->bfq_max_budget);\n\t}\n}\n\nstatic void bfq_reset_rate_computation(struct bfq_data *bfqd,\n\t\t\t\t       struct request *rq)\n{\n\tif (rq != NULL) { /* new rq dispatch now, reset accordingly */\n\t\tbfqd->last_dispatch = bfqd->first_dispatch = ktime_get_ns();\n\t\tbfqd->peak_rate_samples = 1;\n\t\tbfqd->sequential_samples = 0;\n\t\tbfqd->tot_sectors_dispatched = bfqd->last_rq_max_size =\n\t\t\tblk_rq_sectors(rq);\n\t} else /* no new rq dispatched, just reset the number of samples */\n\t\tbfqd->peak_rate_samples = 0; /* full re-init on next disp. */\n\n\tbfq_log(bfqd,\n\t\t\"reset_rate_computation at end, sample %u/%u tot_sects %llu\",\n\t\tbfqd->peak_rate_samples, bfqd->sequential_samples,\n\t\tbfqd->tot_sectors_dispatched);\n}\n\nstatic void bfq_update_rate_reset(struct bfq_data *bfqd, struct request *rq)\n{\n\tu32 rate, weight, divisor;\n\n\t/*\n\t * For the convergence property to hold (see comments on\n\t * bfq_update_peak_rate()) and for the assessment to be\n\t * reliable, a minimum number of samples must be present, and\n\t * a minimum amount of time must have elapsed. If not so, do\n\t * not compute new rate. Just reset parameters, to get ready\n\t * for a new evaluation attempt.\n\t */\n\tif (bfqd->peak_rate_samples < BFQ_RATE_MIN_SAMPLES ||\n\t    bfqd->delta_from_first < BFQ_RATE_MIN_INTERVAL)\n\t\tgoto reset_computation;\n\n\t/*\n\t * If a new request completion has occurred after last\n\t * dispatch, then, to approximate the rate at which requests\n\t * have been served by the device, it is more precise to\n\t * extend the observation interval to the last completion.\n\t */\n\tbfqd->delta_from_first =\n\t\tmax_t(u64, bfqd->delta_from_first,\n\t\t      bfqd->last_completion - bfqd->first_dispatch);\n\n\t/*\n\t * Rate computed in sects/usec, and not sects/nsec, for\n\t * precision issues.\n\t */\n\trate = div64_ul(bfqd->tot_sectors_dispatched<<BFQ_RATE_SHIFT,\n\t\t\tdiv_u64(bfqd->delta_from_first, NSEC_PER_USEC));\n\n\t/*\n\t * Peak rate not updated if:\n\t * - the percentage of sequential dispatches is below 3/4 of the\n\t *   total, and rate is below the current estimated peak rate\n\t * - rate is unreasonably high (> 20M sectors/sec)\n\t */\n\tif ((bfqd->sequential_samples < (3 * bfqd->peak_rate_samples)>>2 &&\n\t     rate <= bfqd->peak_rate) ||\n\t\trate > 20<<BFQ_RATE_SHIFT)\n\t\tgoto reset_computation;\n\n\t/*\n\t * We have to update the peak rate, at last! To this purpose,\n\t * we use a low-pass filter. We compute the smoothing constant\n\t * of the filter as a function of the 'weight' of the new\n\t * measured rate.\n\t *\n\t * As can be seen in next formulas, we define this weight as a\n\t * quantity proportional to how sequential the workload is,\n\t * and to how long the observation time interval is.\n\t *\n\t * The weight runs from 0 to 8. The maximum value of the\n\t * weight, 8, yields the minimum value for the smoothing\n\t * constant. At this minimum value for the smoothing constant,\n\t * the measured rate contributes for half of the next value of\n\t * the estimated peak rate.\n\t *\n\t * So, the first step is to compute the weight as a function\n\t * of how sequential the workload is. Note that the weight\n\t * cannot reach 9, because bfqd->sequential_samples cannot\n\t * become equal to bfqd->peak_rate_samples, which, in its\n\t * turn, holds true because bfqd->sequential_samples is not\n\t * incremented for the first sample.\n\t */\n\tweight = (9 * bfqd->sequential_samples) / bfqd->peak_rate_samples;\n\n\t/*\n\t * Second step: further refine the weight as a function of the\n\t * duration of the observation interval.\n\t */\n\tweight = min_t(u32, 8,\n\t\t       div_u64(weight * bfqd->delta_from_first,\n\t\t\t       BFQ_RATE_REF_INTERVAL));\n\n\t/*\n\t * Divisor ranging from 10, for minimum weight, to 2, for\n\t * maximum weight.\n\t */\n\tdivisor = 10 - weight;\n\n\t/*\n\t * Finally, update peak rate:\n\t *\n\t * peak_rate = peak_rate * (divisor-1) / divisor  +  rate / divisor\n\t */\n\tbfqd->peak_rate *= divisor-1;\n\tbfqd->peak_rate /= divisor;\n\trate /= divisor; /* smoothing constant alpha = 1/divisor */\n\n\tbfqd->peak_rate += rate;\n\n\t/*\n\t * For a very slow device, bfqd->peak_rate can reach 0 (see\n\t * the minimum representable values reported in the comments\n\t * on BFQ_RATE_SHIFT). Push to 1 if this happens, to avoid\n\t * divisions by zero where bfqd->peak_rate is used as a\n\t * divisor.\n\t */\n\tbfqd->peak_rate = max_t(u32, 1, bfqd->peak_rate);\n\n\tupdate_thr_responsiveness_params(bfqd);\n\nreset_computation:\n\tbfq_reset_rate_computation(bfqd, rq);\n}\n\n/*\n * Update the read/write peak rate (the main quantity used for\n * auto-tuning, see update_thr_responsiveness_params()).\n *\n * It is not trivial to estimate the peak rate (correctly): because of\n * the presence of sw and hw queues between the scheduler and the\n * device components that finally serve I/O requests, it is hard to\n * say exactly when a given dispatched request is served inside the\n * device, and for how long. As a consequence, it is hard to know\n * precisely at what rate a given set of requests is actually served\n * by the device.\n *\n * On the opposite end, the dispatch time of any request is trivially\n * available, and, from this piece of information, the \"dispatch rate\"\n * of requests can be immediately computed. So, the idea in the next\n * function is to use what is known, namely request dispatch times\n * (plus, when useful, request completion times), to estimate what is\n * unknown, namely in-device request service rate.\n *\n * The main issue is that, because of the above facts, the rate at\n * which a certain set of requests is dispatched over a certain time\n * interval can vary greatly with respect to the rate at which the\n * same requests are then served. But, since the size of any\n * intermediate queue is limited, and the service scheme is lossless\n * (no request is silently dropped), the following obvious convergence\n * property holds: the number of requests dispatched MUST become\n * closer and closer to the number of requests completed as the\n * observation interval grows. This is the key property used in\n * the next function to estimate the peak service rate as a function\n * of the observed dispatch rate. The function assumes to be invoked\n * on every request dispatch.\n */\nstatic void bfq_update_peak_rate(struct bfq_data *bfqd, struct request *rq)\n{\n\tu64 now_ns = ktime_get_ns();\n\n\tif (bfqd->peak_rate_samples == 0) { /* first dispatch */\n\t\tbfq_log(bfqd, \"update_peak_rate: goto reset, samples %d\",\n\t\t\tbfqd->peak_rate_samples);\n\t\tbfq_reset_rate_computation(bfqd, rq);\n\t\tgoto update_last_values; /* will add one sample */\n\t}\n\n\t/*\n\t * Device idle for very long: the observation interval lasting\n\t * up to this dispatch cannot be a valid observation interval\n\t * for computing a new peak rate (similarly to the late-\n\t * completion event in bfq_completed_request()). Go to\n\t * update_rate_and_reset to have the following three steps\n\t * taken:\n\t * - close the observation interval at the last (previous)\n\t *   request dispatch or completion\n\t * - compute rate, if possible, for that observation interval\n\t * - start a new observation interval with this dispatch\n\t */\n\tif (now_ns - bfqd->last_dispatch > 100*NSEC_PER_MSEC &&\n\t    bfqd->rq_in_driver == 0)\n\t\tgoto update_rate_and_reset;\n\n\t/* Update sampling information */\n\tbfqd->peak_rate_samples++;\n\n\tif ((bfqd->rq_in_driver > 0 ||\n\t\tnow_ns - bfqd->last_completion < BFQ_MIN_TT)\n\t    && !BFQ_RQ_SEEKY(bfqd, bfqd->last_position, rq))\n\t\tbfqd->sequential_samples++;\n\n\tbfqd->tot_sectors_dispatched += blk_rq_sectors(rq);\n\n\t/* Reset max observed rq size every 32 dispatches */\n\tif (likely(bfqd->peak_rate_samples % 32))\n\t\tbfqd->last_rq_max_size =\n\t\t\tmax_t(u32, blk_rq_sectors(rq), bfqd->last_rq_max_size);\n\telse\n\t\tbfqd->last_rq_max_size = blk_rq_sectors(rq);\n\n\tbfqd->delta_from_first = now_ns - bfqd->first_dispatch;\n\n\t/* Target observation interval not yet reached, go on sampling */\n\tif (bfqd->delta_from_first < BFQ_RATE_REF_INTERVAL)\n\t\tgoto update_last_values;\n\nupdate_rate_and_reset:\n\tbfq_update_rate_reset(bfqd, rq);\nupdate_last_values:\n\tbfqd->last_position = blk_rq_pos(rq) + blk_rq_sectors(rq);\n\tif (RQ_BFQQ(rq) == bfqd->in_service_queue)\n\t\tbfqd->in_serv_last_pos = bfqd->last_position;\n\tbfqd->last_dispatch = now_ns;\n}\n\n/*\n * Remove request from internal lists.\n */\nstatic void bfq_dispatch_remove(struct request_queue *q, struct request *rq)\n{\n\tstruct bfq_queue *bfqq = RQ_BFQQ(rq);\n\n\t/*\n\t * For consistency, the next instruction should have been\n\t * executed after removing the request from the queue and\n\t * dispatching it.  We execute instead this instruction before\n\t * bfq_remove_request() (and hence introduce a temporary\n\t * inconsistency), for efficiency.  In fact, should this\n\t * dispatch occur for a non in-service bfqq, this anticipated\n\t * increment prevents two counters related to bfqq->dispatched\n\t * from risking to be, first, uselessly decremented, and then\n\t * incremented again when the (new) value of bfqq->dispatched\n\t * happens to be taken into account.\n\t */\n\tbfqq->dispatched++;\n\tbfq_update_peak_rate(q->elevator->elevator_data, rq);\n\n\tbfq_remove_request(q, rq);\n}\n\n/*\n * There is a case where idling does not have to be performed for\n * throughput concerns, but to preserve the throughput share of\n * the process associated with bfqq.\n *\n * To introduce this case, we can note that allowing the drive\n * to enqueue more than one request at a time, and hence\n * delegating de facto final scheduling decisions to the\n * drive's internal scheduler, entails loss of control on the\n * actual request service order. In particular, the critical\n * situation is when requests from different processes happen\n * to be present, at the same time, in the internal queue(s)\n * of the drive. In such a situation, the drive, by deciding\n * the service order of the internally-queued requests, does\n * determine also the actual throughput distribution among\n * these processes. But the drive typically has no notion or\n * concern about per-process throughput distribution, and\n * makes its decisions only on a per-request basis. Therefore,\n * the service distribution enforced by the drive's internal\n * scheduler is likely to coincide with the desired throughput\n * distribution only in a completely symmetric, or favorably\n * skewed scenario where:\n * (i-a) each of these processes must get the same throughput as\n *\t the others,\n * (i-b) in case (i-a) does not hold, it holds that the process\n *       associated with bfqq must receive a lower or equal\n *\t throughput than any of the other processes;\n * (ii)  the I/O of each process has the same properties, in\n *       terms of locality (sequential or random), direction\n *       (reads or writes), request sizes, greediness\n *       (from I/O-bound to sporadic), and so on;\n\n * In fact, in such a scenario, the drive tends to treat the requests\n * of each process in about the same way as the requests of the\n * others, and thus to provide each of these processes with about the\n * same throughput.  This is exactly the desired throughput\n * distribution if (i-a) holds, or, if (i-b) holds instead, this is an\n * even more convenient distribution for (the process associated with)\n * bfqq.\n *\n * In contrast, in any asymmetric or unfavorable scenario, device\n * idling (I/O-dispatch plugging) is certainly needed to guarantee\n * that bfqq receives its assigned fraction of the device throughput\n * (see [1] for details).\n *\n * The problem is that idling may significantly reduce throughput with\n * certain combinations of types of I/O and devices. An important\n * example is sync random I/O on flash storage with command\n * queueing. So, unless bfqq falls in cases where idling also boosts\n * throughput, it is important to check conditions (i-a), i(-b) and\n * (ii) accurately, so as to avoid idling when not strictly needed for\n * service guarantees.\n *\n * Unfortunately, it is extremely difficult to thoroughly check\n * condition (ii). And, in case there are active groups, it becomes\n * very difficult to check conditions (i-a) and (i-b) too.  In fact,\n * if there are active groups, then, for conditions (i-a) or (i-b) to\n * become false 'indirectly', it is enough that an active group\n * contains more active processes or sub-groups than some other active\n * group. More precisely, for conditions (i-a) or (i-b) to become\n * false because of such a group, it is not even necessary that the\n * group is (still) active: it is sufficient that, even if the group\n * has become inactive, some of its descendant processes still have\n * some request already dispatched but still waiting for\n * completion. In fact, requests have still to be guaranteed their\n * share of the throughput even after being dispatched. In this\n * respect, it is easy to show that, if a group frequently becomes\n * inactive while still having in-flight requests, and if, when this\n * happens, the group is not considered in the calculation of whether\n * the scenario is asymmetric, then the group may fail to be\n * guaranteed its fair share of the throughput (basically because\n * idling may not be performed for the descendant processes of the\n * group, but it had to be).  We address this issue with the following\n * bi-modal behavior, implemented in the function\n * bfq_asymmetric_scenario().\n *\n * If there are groups with requests waiting for completion\n * (as commented above, some of these groups may even be\n * already inactive), then the scenario is tagged as\n * asymmetric, conservatively, without checking any of the\n * conditions (i-a), (i-b) or (ii). So the device is idled for bfqq.\n * This behavior matches also the fact that groups are created\n * exactly if controlling I/O is a primary concern (to\n * preserve bandwidth and latency guarantees).\n *\n * On the opposite end, if there are no groups with requests waiting\n * for completion, then only conditions (i-a) and (i-b) are actually\n * controlled, i.e., provided that conditions (i-a) or (i-b) holds,\n * idling is not performed, regardless of whether condition (ii)\n * holds.  In other words, only if conditions (i-a) and (i-b) do not\n * hold, then idling is allowed, and the device tends to be prevented\n * from queueing many requests, possibly of several processes. Since\n * there are no groups with requests waiting for completion, then, to\n * control conditions (i-a) and (i-b) it is enough to check just\n * whether all the queues with requests waiting for completion also\n * have the same weight.\n *\n * Not checking condition (ii) evidently exposes bfqq to the\n * risk of getting less throughput than its fair share.\n * However, for queues with the same weight, a further\n * mechanism, preemption, mitigates or even eliminates this\n * problem. And it does so without consequences on overall\n * throughput. This mechanism and its benefits are explained\n * in the next three paragraphs.\n *\n * Even if a queue, say Q, is expired when it remains idle, Q\n * can still preempt the new in-service queue if the next\n * request of Q arrives soon (see the comments on\n * bfq_bfqq_update_budg_for_activation). If all queues and\n * groups have the same weight, this form of preemption,\n * combined with the hole-recovery heuristic described in the\n * comments on function bfq_bfqq_update_budg_for_activation,\n * are enough to preserve a correct bandwidth distribution in\n * the mid term, even without idling. In fact, even if not\n * idling allows the internal queues of the device to contain\n * many requests, and thus to reorder requests, we can rather\n * safely assume that the internal scheduler still preserves a\n * minimum of mid-term fairness.\n *\n * More precisely, this preemption-based, idleless approach\n * provides fairness in terms of IOPS, and not sectors per\n * second. This can be seen with a simple example. Suppose\n * that there are two queues with the same weight, but that\n * the first queue receives requests of 8 sectors, while the\n * second queue receives requests of 1024 sectors. In\n * addition, suppose that each of the two queues contains at\n * most one request at a time, which implies that each queue\n * always remains idle after it is served. Finally, after\n * remaining idle, each queue receives very quickly a new\n * request. It follows that the two queues are served\n * alternatively, preempting each other if needed. This\n * implies that, although both queues have the same weight,\n * the queue with large requests receives a service that is\n * 1024/8 times as high as the service received by the other\n * queue.\n *\n * The motivation for using preemption instead of idling (for\n * queues with the same weight) is that, by not idling,\n * service guarantees are preserved (completely or at least in\n * part) without minimally sacrificing throughput. And, if\n * there is no active group, then the primary expectation for\n * this device is probably a high throughput.\n *\n * We are now left only with explaining the two sub-conditions in the\n * additional compound condition that is checked below for deciding\n * whether the scenario is asymmetric. To explain the first\n * sub-condition, we need to add that the function\n * bfq_asymmetric_scenario checks the weights of only\n * non-weight-raised queues, for efficiency reasons (see comments on\n * bfq_weights_tree_add()). Then the fact that bfqq is weight-raised\n * is checked explicitly here. More precisely, the compound condition\n * below takes into account also the fact that, even if bfqq is being\n * weight-raised, the scenario is still symmetric if all queues with\n * requests waiting for completion happen to be\n * weight-raised. Actually, we should be even more precise here, and\n * differentiate between interactive weight raising and soft real-time\n * weight raising.\n *\n * The second sub-condition checked in the compound condition is\n * whether there is a fair amount of already in-flight I/O not\n * belonging to bfqq. If so, I/O dispatching is to be plugged, for the\n * following reason. The drive may decide to serve in-flight\n * non-bfqq's I/O requests before bfqq's ones, thereby delaying the\n * arrival of new I/O requests for bfqq (recall that bfqq is sync). If\n * I/O-dispatching is not plugged, then, while bfqq remains empty, a\n * basically uncontrolled amount of I/O from other queues may be\n * dispatched too, possibly causing the service of bfqq's I/O to be\n * delayed even longer in the drive. This problem gets more and more\n * serious as the speed and the queue depth of the drive grow,\n * because, as these two quantities grow, the probability to find no\n * queue busy but many requests in flight grows too. By contrast,\n * plugging I/O dispatching minimizes the delay induced by already\n * in-flight I/O, and enables bfqq to recover the bandwidth it may\n * lose because of this delay.\n *\n * As a side note, it is worth considering that the above\n * device-idling countermeasures may however fail in the following\n * unlucky scenario: if I/O-dispatch plugging is (correctly) disabled\n * in a time period during which all symmetry sub-conditions hold, and\n * therefore the device is allowed to enqueue many requests, but at\n * some later point in time some sub-condition stops to hold, then it\n * may become impossible to make requests be served in the desired\n * order until all the requests already queued in the device have been\n * served. The last sub-condition commented above somewhat mitigates\n * this problem for weight-raised queues.\n */\nstatic bool idling_needed_for_service_guarantees(struct bfq_data *bfqd,\n\t\t\t\t\t\t struct bfq_queue *bfqq)\n{\n\t/* No point in idling for bfqq if it won't get requests any longer */\n\tif (unlikely(!bfqq_process_refs(bfqq)))\n\t\treturn false;\n\n\treturn (bfqq->wr_coeff > 1 &&\n\t\t(bfqd->wr_busy_queues <\n\t\t bfq_tot_busy_queues(bfqd) ||\n\t\t bfqd->rq_in_driver >=\n\t\t bfqq->dispatched + 4)) ||\n\t\tbfq_asymmetric_scenario(bfqd, bfqq);\n}\n\nstatic bool __bfq_bfqq_expire(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t\t      enum bfqq_expiration reason)\n{\n\t/*\n\t * If this bfqq is shared between multiple processes, check\n\t * to make sure that those processes are still issuing I/Os\n\t * within the mean seek distance. If not, it may be time to\n\t * break the queues apart again.\n\t */\n\tif (bfq_bfqq_coop(bfqq) && BFQQ_SEEKY(bfqq))\n\t\tbfq_mark_bfqq_split_coop(bfqq);\n\n\t/*\n\t * Consider queues with a higher finish virtual time than\n\t * bfqq. If idling_needed_for_service_guarantees(bfqq) returns\n\t * true, then bfqq's bandwidth would be violated if an\n\t * uncontrolled amount of I/O from these queues were\n\t * dispatched while bfqq is waiting for its new I/O to\n\t * arrive. This is exactly what may happen if this is a forced\n\t * expiration caused by a preemption attempt, and if bfqq is\n\t * not re-scheduled. To prevent this from happening, re-queue\n\t * bfqq if it needs I/O-dispatch plugging, even if it is\n\t * empty. By doing so, bfqq is granted to be served before the\n\t * above queues (provided that bfqq is of course eligible).\n\t */\n\tif (RB_EMPTY_ROOT(&bfqq->sort_list) &&\n\t    !(reason == BFQQE_PREEMPTED &&\n\t      idling_needed_for_service_guarantees(bfqd, bfqq))) {\n\t\tif (bfqq->dispatched == 0)\n\t\t\t/*\n\t\t\t * Overloading budget_timeout field to store\n\t\t\t * the time at which the queue remains with no\n\t\t\t * backlog and no outstanding request; used by\n\t\t\t * the weight-raising mechanism.\n\t\t\t */\n\t\t\tbfqq->budget_timeout = jiffies;\n\n\t\tbfq_del_bfqq_busy(bfqd, bfqq, true);\n\t} else {\n\t\tbfq_requeue_bfqq(bfqd, bfqq, true);\n\t\t/*\n\t\t * Resort priority tree of potential close cooperators.\n\t\t * See comments on bfq_pos_tree_add_move() for the unlikely().\n\t\t */\n\t\tif (unlikely(!bfqd->nonrot_with_queueing &&\n\t\t\t     !RB_EMPTY_ROOT(&bfqq->sort_list)))\n\t\t\tbfq_pos_tree_add_move(bfqd, bfqq);\n\t}\n\n\t/*\n\t * All in-service entities must have been properly deactivated\n\t * or requeued before executing the next function, which\n\t * resets all in-service entities as no more in service. This\n\t * may cause bfqq to be freed. If this happens, the next\n\t * function returns true.\n\t */\n\treturn __bfq_bfqd_reset_in_service(bfqd);\n}\n\n/**\n * __bfq_bfqq_recalc_budget - try to adapt the budget to the @bfqq behavior.\n * @bfqd: device data.\n * @bfqq: queue to update.\n * @reason: reason for expiration.\n *\n * Handle the feedback on @bfqq budget at queue expiration.\n * See the body for detailed comments.\n */\nstatic void __bfq_bfqq_recalc_budget(struct bfq_data *bfqd,\n\t\t\t\t     struct bfq_queue *bfqq,\n\t\t\t\t     enum bfqq_expiration reason)\n{\n\tstruct request *next_rq;\n\tint budget, min_budget;\n\n\tmin_budget = bfq_min_budget(bfqd);\n\n\tif (bfqq->wr_coeff == 1)\n\t\tbudget = bfqq->max_budget;\n\telse /*\n\t      * Use a constant, low budget for weight-raised queues,\n\t      * to help achieve a low latency. Keep it slightly higher\n\t      * than the minimum possible budget, to cause a little\n\t      * bit fewer expirations.\n\t      */\n\t\tbudget = 2 * min_budget;\n\n\tbfq_log_bfqq(bfqd, bfqq, \"recalc_budg: last budg %d, budg left %d\",\n\t\tbfqq->entity.budget, bfq_bfqq_budget_left(bfqq));\n\tbfq_log_bfqq(bfqd, bfqq, \"recalc_budg: last max_budg %d, min budg %d\",\n\t\tbudget, bfq_min_budget(bfqd));\n\tbfq_log_bfqq(bfqd, bfqq, \"recalc_budg: sync %d, seeky %d\",\n\t\tbfq_bfqq_sync(bfqq), BFQQ_SEEKY(bfqd->in_service_queue));\n\n\tif (bfq_bfqq_sync(bfqq) && bfqq->wr_coeff == 1) {\n\t\tswitch (reason) {\n\t\t/*\n\t\t * Caveat: in all the following cases we trade latency\n\t\t * for throughput.\n\t\t */\n\t\tcase BFQQE_TOO_IDLE:\n\t\t\t/*\n\t\t\t * This is the only case where we may reduce\n\t\t\t * the budget: if there is no request of the\n\t\t\t * process still waiting for completion, then\n\t\t\t * we assume (tentatively) that the timer has\n\t\t\t * expired because the batch of requests of\n\t\t\t * the process could have been served with a\n\t\t\t * smaller budget.  Hence, betting that\n\t\t\t * process will behave in the same way when it\n\t\t\t * becomes backlogged again, we reduce its\n\t\t\t * next budget.  As long as we guess right,\n\t\t\t * this budget cut reduces the latency\n\t\t\t * experienced by the process.\n\t\t\t *\n\t\t\t * However, if there are still outstanding\n\t\t\t * requests, then the process may have not yet\n\t\t\t * issued its next request just because it is\n\t\t\t * still waiting for the completion of some of\n\t\t\t * the still outstanding ones.  So in this\n\t\t\t * subcase we do not reduce its budget, on the\n\t\t\t * contrary we increase it to possibly boost\n\t\t\t * the throughput, as discussed in the\n\t\t\t * comments to the BUDGET_TIMEOUT case.\n\t\t\t */\n\t\t\tif (bfqq->dispatched > 0) /* still outstanding reqs */\n\t\t\t\tbudget = min(budget * 2, bfqd->bfq_max_budget);\n\t\t\telse {\n\t\t\t\tif (budget > 5 * min_budget)\n\t\t\t\t\tbudget -= 4 * min_budget;\n\t\t\t\telse\n\t\t\t\t\tbudget = min_budget;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BFQQE_BUDGET_TIMEOUT:\n\t\t\t/*\n\t\t\t * We double the budget here because it gives\n\t\t\t * the chance to boost the throughput if this\n\t\t\t * is not a seeky process (and has bumped into\n\t\t\t * this timeout because of, e.g., ZBR).\n\t\t\t */\n\t\t\tbudget = min(budget * 2, bfqd->bfq_max_budget);\n\t\t\tbreak;\n\t\tcase BFQQE_BUDGET_EXHAUSTED:\n\t\t\t/*\n\t\t\t * The process still has backlog, and did not\n\t\t\t * let either the budget timeout or the disk\n\t\t\t * idling timeout expire. Hence it is not\n\t\t\t * seeky, has a short thinktime and may be\n\t\t\t * happy with a higher budget too. So\n\t\t\t * definitely increase the budget of this good\n\t\t\t * candidate to boost the disk throughput.\n\t\t\t */\n\t\t\tbudget = min(budget * 4, bfqd->bfq_max_budget);\n\t\t\tbreak;\n\t\tcase BFQQE_NO_MORE_REQUESTS:\n\t\t\t/*\n\t\t\t * For queues that expire for this reason, it\n\t\t\t * is particularly important to keep the\n\t\t\t * budget close to the actual service they\n\t\t\t * need. Doing so reduces the timestamp\n\t\t\t * misalignment problem described in the\n\t\t\t * comments in the body of\n\t\t\t * __bfq_activate_entity. In fact, suppose\n\t\t\t * that a queue systematically expires for\n\t\t\t * BFQQE_NO_MORE_REQUESTS and presents a\n\t\t\t * new request in time to enjoy timestamp\n\t\t\t * back-shifting. The larger the budget of the\n\t\t\t * queue is with respect to the service the\n\t\t\t * queue actually requests in each service\n\t\t\t * slot, the more times the queue can be\n\t\t\t * reactivated with the same virtual finish\n\t\t\t * time. It follows that, even if this finish\n\t\t\t * time is pushed to the system virtual time\n\t\t\t * to reduce the consequent timestamp\n\t\t\t * misalignment, the queue unjustly enjoys for\n\t\t\t * many re-activations a lower finish time\n\t\t\t * than all newly activated queues.\n\t\t\t *\n\t\t\t * The service needed by bfqq is measured\n\t\t\t * quite precisely by bfqq->entity.service.\n\t\t\t * Since bfqq does not enjoy device idling,\n\t\t\t * bfqq->entity.service is equal to the number\n\t\t\t * of sectors that the process associated with\n\t\t\t * bfqq requested to read/write before waiting\n\t\t\t * for request completions, or blocking for\n\t\t\t * other reasons.\n\t\t\t */\n\t\t\tbudget = max_t(int, bfqq->entity.service, min_budget);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t} else if (!bfq_bfqq_sync(bfqq)) {\n\t\t/*\n\t\t * Async queues get always the maximum possible\n\t\t * budget, as for them we do not care about latency\n\t\t * (in addition, their ability to dispatch is limited\n\t\t * by the charging factor).\n\t\t */\n\t\tbudget = bfqd->bfq_max_budget;\n\t}\n\n\tbfqq->max_budget = budget;\n\n\tif (bfqd->budgets_assigned >= bfq_stats_min_budgets &&\n\t    !bfqd->bfq_user_max_budget)\n\t\tbfqq->max_budget = min(bfqq->max_budget, bfqd->bfq_max_budget);\n\n\t/*\n\t * If there is still backlog, then assign a new budget, making\n\t * sure that it is large enough for the next request.  Since\n\t * the finish time of bfqq must be kept in sync with the\n\t * budget, be sure to call __bfq_bfqq_expire() *after* this\n\t * update.\n\t *\n\t * If there is no backlog, then no need to update the budget;\n\t * it will be updated on the arrival of a new request.\n\t */\n\tnext_rq = bfqq->next_rq;\n\tif (next_rq)\n\t\tbfqq->entity.budget = max_t(unsigned long, bfqq->max_budget,\n\t\t\t\t\t    bfq_serv_to_charge(next_rq, bfqq));\n\n\tbfq_log_bfqq(bfqd, bfqq, \"head sect: %u, new budget %d\",\n\t\t\tnext_rq ? blk_rq_sectors(next_rq) : 0,\n\t\t\tbfqq->entity.budget);\n}\n\n/*\n * Return true if the process associated with bfqq is \"slow\". The slow\n * flag is used, in addition to the budget timeout, to reduce the\n * amount of service provided to seeky processes, and thus reduce\n * their chances to lower the throughput. More details in the comments\n * on the function bfq_bfqq_expire().\n *\n * An important observation is in order: as discussed in the comments\n * on the function bfq_update_peak_rate(), with devices with internal\n * queues, it is hard if ever possible to know when and for how long\n * an I/O request is processed by the device (apart from the trivial\n * I/O pattern where a new request is dispatched only after the\n * previous one has been completed). This makes it hard to evaluate\n * the real rate at which the I/O requests of each bfq_queue are\n * served.  In fact, for an I/O scheduler like BFQ, serving a\n * bfq_queue means just dispatching its requests during its service\n * slot (i.e., until the budget of the queue is exhausted, or the\n * queue remains idle, or, finally, a timeout fires). But, during the\n * service slot of a bfq_queue, around 100 ms at most, the device may\n * be even still processing requests of bfq_queues served in previous\n * service slots. On the opposite end, the requests of the in-service\n * bfq_queue may be completed after the service slot of the queue\n * finishes.\n *\n * Anyway, unless more sophisticated solutions are used\n * (where possible), the sum of the sizes of the requests dispatched\n * during the service slot of a bfq_queue is probably the only\n * approximation available for the service received by the bfq_queue\n * during its service slot. And this sum is the quantity used in this\n * function to evaluate the I/O speed of a process.\n */\nstatic bool bfq_bfqq_is_slow(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t\t\t bool compensate, enum bfqq_expiration reason,\n\t\t\t\t unsigned long *delta_ms)\n{\n\tktime_t delta_ktime;\n\tu32 delta_usecs;\n\tbool slow = BFQQ_SEEKY(bfqq); /* if delta too short, use seekyness */\n\n\tif (!bfq_bfqq_sync(bfqq))\n\t\treturn false;\n\n\tif (compensate)\n\t\tdelta_ktime = bfqd->last_idling_start;\n\telse\n\t\tdelta_ktime = ktime_get();\n\tdelta_ktime = ktime_sub(delta_ktime, bfqd->last_budget_start);\n\tdelta_usecs = ktime_to_us(delta_ktime);\n\n\t/* don't use too short time intervals */\n\tif (delta_usecs < 1000) {\n\t\tif (blk_queue_nonrot(bfqd->queue))\n\t\t\t /*\n\t\t\t  * give same worst-case guarantees as idling\n\t\t\t  * for seeky\n\t\t\t  */\n\t\t\t*delta_ms = BFQ_MIN_TT / NSEC_PER_MSEC;\n\t\telse /* charge at least one seek */\n\t\t\t*delta_ms = bfq_slice_idle / NSEC_PER_MSEC;\n\n\t\treturn slow;\n\t}\n\n\t*delta_ms = delta_usecs / USEC_PER_MSEC;\n\n\t/*\n\t * Use only long (> 20ms) intervals to filter out excessive\n\t * spikes in service rate estimation.\n\t */\n\tif (delta_usecs > 20000) {\n\t\t/*\n\t\t * Caveat for rotational devices: processes doing I/O\n\t\t * in the slower disk zones tend to be slow(er) even\n\t\t * if not seeky. In this respect, the estimated peak\n\t\t * rate is likely to be an average over the disk\n\t\t * surface. Accordingly, to not be too harsh with\n\t\t * unlucky processes, a process is deemed slow only if\n\t\t * its rate has been lower than half of the estimated\n\t\t * peak rate.\n\t\t */\n\t\tslow = bfqq->entity.service < bfqd->bfq_max_budget / 2;\n\t}\n\n\tbfq_log_bfqq(bfqd, bfqq, \"bfq_bfqq_is_slow: slow %d\", slow);\n\n\treturn slow;\n}\n\n/*\n * To be deemed as soft real-time, an application must meet two\n * requirements. First, the application must not require an average\n * bandwidth higher than the approximate bandwidth required to playback or\n * record a compressed high-definition video.\n * The next function is invoked on the completion of the last request of a\n * batch, to compute the next-start time instant, soft_rt_next_start, such\n * that, if the next request of the application does not arrive before\n * soft_rt_next_start, then the above requirement on the bandwidth is met.\n *\n * The second requirement is that the request pattern of the application is\n * isochronous, i.e., that, after issuing a request or a batch of requests,\n * the application stops issuing new requests until all its pending requests\n * have been completed. After that, the application may issue a new batch,\n * and so on.\n * For this reason the next function is invoked to compute\n * soft_rt_next_start only for applications that meet this requirement,\n * whereas soft_rt_next_start is set to infinity for applications that do\n * not.\n *\n * Unfortunately, even a greedy (i.e., I/O-bound) application may\n * happen to meet, occasionally or systematically, both the above\n * bandwidth and isochrony requirements. This may happen at least in\n * the following circumstances. First, if the CPU load is high. The\n * application may stop issuing requests while the CPUs are busy\n * serving other processes, then restart, then stop again for a while,\n * and so on. The other circumstances are related to the storage\n * device: the storage device is highly loaded or reaches a low-enough\n * throughput with the I/O of the application (e.g., because the I/O\n * is random and/or the device is slow). In all these cases, the\n * I/O of the application may be simply slowed down enough to meet\n * the bandwidth and isochrony requirements. To reduce the probability\n * that greedy applications are deemed as soft real-time in these\n * corner cases, a further rule is used in the computation of\n * soft_rt_next_start: the return value of this function is forced to\n * be higher than the maximum between the following two quantities.\n *\n * (a) Current time plus: (1) the maximum time for which the arrival\n *     of a request is waited for when a sync queue becomes idle,\n *     namely bfqd->bfq_slice_idle, and (2) a few extra jiffies. We\n *     postpone for a moment the reason for adding a few extra\n *     jiffies; we get back to it after next item (b).  Lower-bounding\n *     the return value of this function with the current time plus\n *     bfqd->bfq_slice_idle tends to filter out greedy applications,\n *     because the latter issue their next request as soon as possible\n *     after the last one has been completed. In contrast, a soft\n *     real-time application spends some time processing data, after a\n *     batch of its requests has been completed.\n *\n * (b) Current value of bfqq->soft_rt_next_start. As pointed out\n *     above, greedy applications may happen to meet both the\n *     bandwidth and isochrony requirements under heavy CPU or\n *     storage-device load. In more detail, in these scenarios, these\n *     applications happen, only for limited time periods, to do I/O\n *     slowly enough to meet all the requirements described so far,\n *     including the filtering in above item (a). These slow-speed\n *     time intervals are usually interspersed between other time\n *     intervals during which these applications do I/O at a very high\n *     speed. Fortunately, exactly because of the high speed of the\n *     I/O in the high-speed intervals, the values returned by this\n *     function happen to be so high, near the end of any such\n *     high-speed interval, to be likely to fall *after* the end of\n *     the low-speed time interval that follows. These high values are\n *     stored in bfqq->soft_rt_next_start after each invocation of\n *     this function. As a consequence, if the last value of\n *     bfqq->soft_rt_next_start is constantly used to lower-bound the\n *     next value that this function may return, then, from the very\n *     beginning of a low-speed interval, bfqq->soft_rt_next_start is\n *     likely to be constantly kept so high that any I/O request\n *     issued during the low-speed interval is considered as arriving\n *     to soon for the application to be deemed as soft\n *     real-time. Then, in the high-speed interval that follows, the\n *     application will not be deemed as soft real-time, just because\n *     it will do I/O at a high speed. And so on.\n *\n * Getting back to the filtering in item (a), in the following two\n * cases this filtering might be easily passed by a greedy\n * application, if the reference quantity was just\n * bfqd->bfq_slice_idle:\n * 1) HZ is so low that the duration of a jiffy is comparable to or\n *    higher than bfqd->bfq_slice_idle. This happens, e.g., on slow\n *    devices with HZ=100. The time granularity may be so coarse\n *    that the approximation, in jiffies, of bfqd->bfq_slice_idle\n *    is rather lower than the exact value.\n * 2) jiffies, instead of increasing at a constant rate, may stop increasing\n *    for a while, then suddenly 'jump' by several units to recover the lost\n *    increments. This seems to happen, e.g., inside virtual machines.\n * To address this issue, in the filtering in (a) we do not use as a\n * reference time interval just bfqd->bfq_slice_idle, but\n * bfqd->bfq_slice_idle plus a few jiffies. In particular, we add the\n * minimum number of jiffies for which the filter seems to be quite\n * precise also in embedded systems and KVM/QEMU virtual machines.\n */\nstatic unsigned long bfq_bfqq_softrt_next_start(struct bfq_data *bfqd,\n\t\t\t\t\t\tstruct bfq_queue *bfqq)\n{\n\treturn max3(bfqq->soft_rt_next_start,\n\t\t    bfqq->last_idle_bklogged +\n\t\t    HZ * bfqq->service_from_backlogged /\n\t\t    bfqd->bfq_wr_max_softrt_rate,\n\t\t    jiffies + nsecs_to_jiffies(bfqq->bfqd->bfq_slice_idle) + 4);\n}\n\n/**\n * bfq_bfqq_expire - expire a queue.\n * @bfqd: device owning the queue.\n * @bfqq: the queue to expire.\n * @compensate: if true, compensate for the time spent idling.\n * @reason: the reason causing the expiration.\n *\n * If the process associated with bfqq does slow I/O (e.g., because it\n * issues random requests), we charge bfqq with the time it has been\n * in service instead of the service it has received (see\n * bfq_bfqq_charge_time for details on how this goal is achieved). As\n * a consequence, bfqq will typically get higher timestamps upon\n * reactivation, and hence it will be rescheduled as if it had\n * received more service than what it has actually received. In the\n * end, bfqq receives less service in proportion to how slowly its\n * associated process consumes its budgets (and hence how seriously it\n * tends to lower the throughput). In addition, this time-charging\n * strategy guarantees time fairness among slow processes. In\n * contrast, if the process associated with bfqq is not slow, we\n * charge bfqq exactly with the service it has received.\n *\n * Charging time to the first type of queues and the exact service to\n * the other has the effect of using the WF2Q+ policy to schedule the\n * former on a timeslice basis, without violating service domain\n * guarantees among the latter.\n */\nvoid bfq_bfqq_expire(struct bfq_data *bfqd,\n\t\t     struct bfq_queue *bfqq,\n\t\t     bool compensate,\n\t\t     enum bfqq_expiration reason)\n{\n\tbool slow;\n\tunsigned long delta = 0;\n\tstruct bfq_entity *entity = &bfqq->entity;\n\n\t/*\n\t * Check whether the process is slow (see bfq_bfqq_is_slow).\n\t */\n\tslow = bfq_bfqq_is_slow(bfqd, bfqq, compensate, reason, &delta);\n\n\t/*\n\t * As above explained, charge slow (typically seeky) and\n\t * timed-out queues with the time and not the service\n\t * received, to favor sequential workloads.\n\t *\n\t * Processes doing I/O in the slower disk zones will tend to\n\t * be slow(er) even if not seeky. Therefore, since the\n\t * estimated peak rate is actually an average over the disk\n\t * surface, these processes may timeout just for bad luck. To\n\t * avoid punishing them, do not charge time to processes that\n\t * succeeded in consuming at least 2/3 of their budget. This\n\t * allows BFQ to preserve enough elasticity to still perform\n\t * bandwidth, and not time, distribution with little unlucky\n\t * or quasi-sequential processes.\n\t */\n\tif (bfqq->wr_coeff == 1 &&\n\t    (slow ||\n\t     (reason == BFQQE_BUDGET_TIMEOUT &&\n\t      bfq_bfqq_budget_left(bfqq) >=  entity->budget / 3)))\n\t\tbfq_bfqq_charge_time(bfqd, bfqq, delta);\n\n\tif (reason == BFQQE_TOO_IDLE &&\n\t    entity->service <= 2 * entity->budget / 10)\n\t\tbfq_clear_bfqq_IO_bound(bfqq);\n\n\tif (bfqd->low_latency && bfqq->wr_coeff == 1)\n\t\tbfqq->last_wr_start_finish = jiffies;\n\n\tif (bfqd->low_latency && bfqd->bfq_wr_max_softrt_rate > 0 &&\n\t    RB_EMPTY_ROOT(&bfqq->sort_list)) {\n\t\t/*\n\t\t * If we get here, and there are no outstanding\n\t\t * requests, then the request pattern is isochronous\n\t\t * (see the comments on the function\n\t\t * bfq_bfqq_softrt_next_start()). Thus we can compute\n\t\t * soft_rt_next_start. And we do it, unless bfqq is in\n\t\t * interactive weight raising. We do not do it in the\n\t\t * latter subcase, for the following reason. bfqq may\n\t\t * be conveying the I/O needed to load a soft\n\t\t * real-time application. Such an application will\n\t\t * actually exhibit a soft real-time I/O pattern after\n\t\t * it finally starts doing its job. But, if\n\t\t * soft_rt_next_start is computed here for an\n\t\t * interactive bfqq, and bfqq had received a lot of\n\t\t * service before remaining with no outstanding\n\t\t * request (likely to happen on a fast device), then\n\t\t * soft_rt_next_start would be assigned such a high\n\t\t * value that, for a very long time, bfqq would be\n\t\t * prevented from being possibly considered as soft\n\t\t * real time.\n\t\t *\n\t\t * If, instead, the queue still has outstanding\n\t\t * requests, then we have to wait for the completion\n\t\t * of all the outstanding requests to discover whether\n\t\t * the request pattern is actually isochronous.\n\t\t */\n\t\tif (bfqq->dispatched == 0 &&\n\t\t    bfqq->wr_coeff != bfqd->bfq_wr_coeff)\n\t\t\tbfqq->soft_rt_next_start =\n\t\t\t\tbfq_bfqq_softrt_next_start(bfqd, bfqq);\n\t\telse if (bfqq->dispatched > 0) {\n\t\t\t/*\n\t\t\t * Schedule an update of soft_rt_next_start to when\n\t\t\t * the task may be discovered to be isochronous.\n\t\t\t */\n\t\t\tbfq_mark_bfqq_softrt_update(bfqq);\n\t\t}\n\t}\n\n\tbfq_log_bfqq(bfqd, bfqq,\n\t\t\"expire (%d, slow %d, num_disp %d, short_ttime %d)\", reason,\n\t\tslow, bfqq->dispatched, bfq_bfqq_has_short_ttime(bfqq));\n\n\t/*\n\t * bfqq expired, so no total service time needs to be computed\n\t * any longer: reset state machine for measuring total service\n\t * times.\n\t */\n\tbfqd->rqs_injected = bfqd->wait_dispatch = false;\n\tbfqd->waited_rq = NULL;\n\n\t/*\n\t * Increase, decrease or leave budget unchanged according to\n\t * reason.\n\t */\n\t__bfq_bfqq_recalc_budget(bfqd, bfqq, reason);\n\tif (__bfq_bfqq_expire(bfqd, bfqq, reason))\n\t\t/* bfqq is gone, no more actions on it */\n\t\treturn;\n\n\t/* mark bfqq as waiting a request only if a bic still points to it */\n\tif (!bfq_bfqq_busy(bfqq) &&\n\t    reason != BFQQE_BUDGET_TIMEOUT &&\n\t    reason != BFQQE_BUDGET_EXHAUSTED) {\n\t\tbfq_mark_bfqq_non_blocking_wait_rq(bfqq);\n\t\t/*\n\t\t * Not setting service to 0, because, if the next rq\n\t\t * arrives in time, the queue will go on receiving\n\t\t * service with this same budget (as if it never expired)\n\t\t */\n\t} else\n\t\tentity->service = 0;\n\n\t/*\n\t * Reset the received-service counter for every parent entity.\n\t * Differently from what happens with bfqq->entity.service,\n\t * the resetting of this counter never needs to be postponed\n\t * for parent entities. In fact, in case bfqq may have a\n\t * chance to go on being served using the last, partially\n\t * consumed budget, bfqq->entity.service needs to be kept,\n\t * because if bfqq then actually goes on being served using\n\t * the same budget, the last value of bfqq->entity.service is\n\t * needed to properly decrement bfqq->entity.budget by the\n\t * portion already consumed. In contrast, it is not necessary\n\t * to keep entity->service for parent entities too, because\n\t * the bubble up of the new value of bfqq->entity.budget will\n\t * make sure that the budgets of parent entities are correct,\n\t * even in case bfqq and thus parent entities go on receiving\n\t * service with the same budget.\n\t */\n\tentity = entity->parent;\n\tfor_each_entity(entity)\n\t\tentity->service = 0;\n}\n\n/*\n * Budget timeout is not implemented through a dedicated timer, but\n * just checked on request arrivals and completions, as well as on\n * idle timer expirations.\n */\nstatic bool bfq_bfqq_budget_timeout(struct bfq_queue *bfqq)\n{\n\treturn time_is_before_eq_jiffies(bfqq->budget_timeout);\n}\n\n/*\n * If we expire a queue that is actively waiting (i.e., with the\n * device idled) for the arrival of a new request, then we may incur\n * the timestamp misalignment problem described in the body of the\n * function __bfq_activate_entity. Hence we return true only if this\n * condition does not hold, or if the queue is slow enough to deserve\n * only to be kicked off for preserving a high throughput.\n */\nstatic bool bfq_may_expire_for_budg_timeout(struct bfq_queue *bfqq)\n{\n\tbfq_log_bfqq(bfqq->bfqd, bfqq,\n\t\t\"may_budget_timeout: wait_request %d left %d timeout %d\",\n\t\tbfq_bfqq_wait_request(bfqq),\n\t\t\tbfq_bfqq_budget_left(bfqq) >=  bfqq->entity.budget / 3,\n\t\tbfq_bfqq_budget_timeout(bfqq));\n\n\treturn (!bfq_bfqq_wait_request(bfqq) ||\n\t\tbfq_bfqq_budget_left(bfqq) >=  bfqq->entity.budget / 3)\n\t\t&&\n\t\tbfq_bfqq_budget_timeout(bfqq);\n}\n\nstatic bool idling_boosts_thr_without_issues(struct bfq_data *bfqd,\n\t\t\t\t\t     struct bfq_queue *bfqq)\n{\n\tbool rot_without_queueing =\n\t\t!blk_queue_nonrot(bfqd->queue) && !bfqd->hw_tag,\n\t\tbfqq_sequential_and_IO_bound,\n\t\tidling_boosts_thr;\n\n\t/* No point in idling for bfqq if it won't get requests any longer */\n\tif (unlikely(!bfqq_process_refs(bfqq)))\n\t\treturn false;\n\n\tbfqq_sequential_and_IO_bound = !BFQQ_SEEKY(bfqq) &&\n\t\tbfq_bfqq_IO_bound(bfqq) && bfq_bfqq_has_short_ttime(bfqq);\n\n\t/*\n\t * The next variable takes into account the cases where idling\n\t * boosts the throughput.\n\t *\n\t * The value of the variable is computed considering, first, that\n\t * idling is virtually always beneficial for the throughput if:\n\t * (a) the device is not NCQ-capable and rotational, or\n\t * (b) regardless of the presence of NCQ, the device is rotational and\n\t *     the request pattern for bfqq is I/O-bound and sequential, or\n\t * (c) regardless of whether it is rotational, the device is\n\t *     not NCQ-capable and the request pattern for bfqq is\n\t *     I/O-bound and sequential.\n\t *\n\t * Secondly, and in contrast to the above item (b), idling an\n\t * NCQ-capable flash-based device would not boost the\n\t * throughput even with sequential I/O; rather it would lower\n\t * the throughput in proportion to how fast the device\n\t * is. Accordingly, the next variable is true if any of the\n\t * above conditions (a), (b) or (c) is true, and, in\n\t * particular, happens to be false if bfqd is an NCQ-capable\n\t * flash-based device.\n\t */\n\tidling_boosts_thr = rot_without_queueing ||\n\t\t((!blk_queue_nonrot(bfqd->queue) || !bfqd->hw_tag) &&\n\t\t bfqq_sequential_and_IO_bound);\n\n\t/*\n\t * The return value of this function is equal to that of\n\t * idling_boosts_thr, unless a special case holds. In this\n\t * special case, described below, idling may cause problems to\n\t * weight-raised queues.\n\t *\n\t * When the request pool is saturated (e.g., in the presence\n\t * of write hogs), if the processes associated with\n\t * non-weight-raised queues ask for requests at a lower rate,\n\t * then processes associated with weight-raised queues have a\n\t * higher probability to get a request from the pool\n\t * immediately (or at least soon) when they need one. Thus\n\t * they have a higher probability to actually get a fraction\n\t * of the device throughput proportional to their high\n\t * weight. This is especially true with NCQ-capable drives,\n\t * which enqueue several requests in advance, and further\n\t * reorder internally-queued requests.\n\t *\n\t * For this reason, we force to false the return value if\n\t * there are weight-raised busy queues. In this case, and if\n\t * bfqq is not weight-raised, this guarantees that the device\n\t * is not idled for bfqq (if, instead, bfqq is weight-raised,\n\t * then idling will be guaranteed by another variable, see\n\t * below). Combined with the timestamping rules of BFQ (see\n\t * [1] for details), this behavior causes bfqq, and hence any\n\t * sync non-weight-raised queue, to get a lower number of\n\t * requests served, and thus to ask for a lower number of\n\t * requests from the request pool, before the busy\n\t * weight-raised queues get served again. This often mitigates\n\t * starvation problems in the presence of heavy write\n\t * workloads and NCQ, thereby guaranteeing a higher\n\t * application and system responsiveness in these hostile\n\t * scenarios.\n\t */\n\treturn idling_boosts_thr &&\n\t\tbfqd->wr_busy_queues == 0;\n}\n\n/*\n * For a queue that becomes empty, device idling is allowed only if\n * this function returns true for that queue. As a consequence, since\n * device idling plays a critical role for both throughput boosting\n * and service guarantees, the return value of this function plays a\n * critical role as well.\n *\n * In a nutshell, this function returns true only if idling is\n * beneficial for throughput or, even if detrimental for throughput,\n * idling is however necessary to preserve service guarantees (low\n * latency, desired throughput distribution, ...). In particular, on\n * NCQ-capable devices, this function tries to return false, so as to\n * help keep the drives' internal queues full, whenever this helps the\n * device boost the throughput without causing any service-guarantee\n * issue.\n *\n * Most of the issues taken into account to get the return value of\n * this function are not trivial. We discuss these issues in the two\n * functions providing the main pieces of information needed by this\n * function.\n */\nstatic bool bfq_better_to_idle(struct bfq_queue *bfqq)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tbool idling_boosts_thr_with_no_issue, idling_needed_for_service_guar;\n\n\t/* No point in idling for bfqq if it won't get requests any longer */\n\tif (unlikely(!bfqq_process_refs(bfqq)))\n\t\treturn false;\n\n\tif (unlikely(bfqd->strict_guarantees))\n\t\treturn true;\n\n\t/*\n\t * Idling is performed only if slice_idle > 0. In addition, we\n\t * do not idle if\n\t * (a) bfqq is async\n\t * (b) bfqq is in the idle io prio class: in this case we do\n\t * not idle because we want to minimize the bandwidth that\n\t * queues in this class can steal to higher-priority queues\n\t */\n\tif (bfqd->bfq_slice_idle == 0 || !bfq_bfqq_sync(bfqq) ||\n\t   bfq_class_idle(bfqq))\n\t\treturn false;\n\n\tidling_boosts_thr_with_no_issue =\n\t\tidling_boosts_thr_without_issues(bfqd, bfqq);\n\n\tidling_needed_for_service_guar =\n\t\tidling_needed_for_service_guarantees(bfqd, bfqq);\n\n\t/*\n\t * We have now the two components we need to compute the\n\t * return value of the function, which is true only if idling\n\t * either boosts the throughput (without issues), or is\n\t * necessary to preserve service guarantees.\n\t */\n\treturn idling_boosts_thr_with_no_issue ||\n\t\tidling_needed_for_service_guar;\n}\n\n/*\n * If the in-service queue is empty but the function bfq_better_to_idle\n * returns true, then:\n * 1) the queue must remain in service and cannot be expired, and\n * 2) the device must be idled to wait for the possible arrival of a new\n *    request for the queue.\n * See the comments on the function bfq_better_to_idle for the reasons\n * why performing device idling is the best choice to boost the throughput\n * and preserve service guarantees when bfq_better_to_idle itself\n * returns true.\n */\nstatic bool bfq_bfqq_must_idle(struct bfq_queue *bfqq)\n{\n\treturn RB_EMPTY_ROOT(&bfqq->sort_list) && bfq_better_to_idle(bfqq);\n}\n\n/*\n * This function chooses the queue from which to pick the next extra\n * I/O request to inject, if it finds a compatible queue. See the\n * comments on bfq_update_inject_limit() for details on the injection\n * mechanism, and for the definitions of the quantities mentioned\n * below.\n */\nstatic struct bfq_queue *\nbfq_choose_bfqq_for_injection(struct bfq_data *bfqd)\n{\n\tstruct bfq_queue *bfqq, *in_serv_bfqq = bfqd->in_service_queue;\n\tunsigned int limit = in_serv_bfqq->inject_limit;\n\t/*\n\t * If\n\t * - bfqq is not weight-raised and therefore does not carry\n\t *   time-critical I/O,\n\t * or\n\t * - regardless of whether bfqq is weight-raised, bfqq has\n\t *   however a long think time, during which it can absorb the\n\t *   effect of an appropriate number of extra I/O requests\n\t *   from other queues (see bfq_update_inject_limit for\n\t *   details on the computation of this number);\n\t * then injection can be performed without restrictions.\n\t */\n\tbool in_serv_always_inject = in_serv_bfqq->wr_coeff == 1 ||\n\t\t!bfq_bfqq_has_short_ttime(in_serv_bfqq);\n\n\t/*\n\t * If\n\t * - the baseline total service time could not be sampled yet,\n\t *   so the inject limit happens to be still 0, and\n\t * - a lot of time has elapsed since the plugging of I/O\n\t *   dispatching started, so drive speed is being wasted\n\t *   significantly;\n\t * then temporarily raise inject limit to one request.\n\t */\n\tif (limit == 0 && in_serv_bfqq->last_serv_time_ns == 0 &&\n\t    bfq_bfqq_wait_request(in_serv_bfqq) &&\n\t    time_is_before_eq_jiffies(bfqd->last_idling_start_jiffies +\n\t\t\t\t      bfqd->bfq_slice_idle)\n\t\t)\n\t\tlimit = 1;\n\n\tif (bfqd->rq_in_driver >= limit)\n\t\treturn NULL;\n\n\t/*\n\t * Linear search of the source queue for injection; but, with\n\t * a high probability, very few steps are needed to find a\n\t * candidate queue, i.e., a queue with enough budget left for\n\t * its next request. In fact:\n\t * - BFQ dynamically updates the budget of every queue so as\n\t *   to accommodate the expected backlog of the queue;\n\t * - if a queue gets all its requests dispatched as injected\n\t *   service, then the queue is removed from the active list\n\t *   (and re-added only if it gets new requests, but then it\n\t *   is assigned again enough budget for its new backlog).\n\t */\n\tlist_for_each_entry(bfqq, &bfqd->active_list, bfqq_list)\n\t\tif (!RB_EMPTY_ROOT(&bfqq->sort_list) &&\n\t\t    (in_serv_always_inject || bfqq->wr_coeff > 1) &&\n\t\t    bfq_serv_to_charge(bfqq->next_rq, bfqq) <=\n\t\t    bfq_bfqq_budget_left(bfqq)) {\n\t\t\t/*\n\t\t\t * Allow for only one large in-flight request\n\t\t\t * on non-rotational devices, for the\n\t\t\t * following reason. On non-rotationl drives,\n\t\t\t * large requests take much longer than\n\t\t\t * smaller requests to be served. In addition,\n\t\t\t * the drive prefers to serve large requests\n\t\t\t * w.r.t. to small ones, if it can choose. So,\n\t\t\t * having more than one large requests queued\n\t\t\t * in the drive may easily make the next first\n\t\t\t * request of the in-service queue wait for so\n\t\t\t * long to break bfqq's service guarantees. On\n\t\t\t * the bright side, large requests let the\n\t\t\t * drive reach a very high throughput, even if\n\t\t\t * there is only one in-flight large request\n\t\t\t * at a time.\n\t\t\t */\n\t\t\tif (blk_queue_nonrot(bfqd->queue) &&\n\t\t\t    blk_rq_sectors(bfqq->next_rq) >=\n\t\t\t    BFQQ_SECT_THR_NONROT)\n\t\t\t\tlimit = min_t(unsigned int, 1, limit);\n\t\t\telse\n\t\t\t\tlimit = in_serv_bfqq->inject_limit;\n\n\t\t\tif (bfqd->rq_in_driver < limit) {\n\t\t\t\tbfqd->rqs_injected = true;\n\t\t\t\treturn bfqq;\n\t\t\t}\n\t\t}\n\n\treturn NULL;\n}\n\n/*\n * Select a queue for service.  If we have a current queue in service,\n * check whether to continue servicing it, or retrieve and set a new one.\n */\nstatic struct bfq_queue *bfq_select_queue(struct bfq_data *bfqd)\n{\n\tstruct bfq_queue *bfqq;\n\tstruct request *next_rq;\n\tenum bfqq_expiration reason = BFQQE_BUDGET_TIMEOUT;\n\n\tbfqq = bfqd->in_service_queue;\n\tif (!bfqq)\n\t\tgoto new_queue;\n\n\tbfq_log_bfqq(bfqd, bfqq, \"select_queue: already in-service queue\");\n\n\t/*\n\t * Do not expire bfqq for budget timeout if bfqq may be about\n\t * to enjoy device idling. The reason why, in this case, we\n\t * prevent bfqq from expiring is the same as in the comments\n\t * on the case where bfq_bfqq_must_idle() returns true, in\n\t * bfq_completed_request().\n\t */\n\tif (bfq_may_expire_for_budg_timeout(bfqq) &&\n\t    !bfq_bfqq_must_idle(bfqq))\n\t\tgoto expire;\n\ncheck_queue:\n\t/*\n\t * This loop is rarely executed more than once. Even when it\n\t * happens, it is much more convenient to re-execute this loop\n\t * than to return NULL and trigger a new dispatch to get a\n\t * request served.\n\t */\n\tnext_rq = bfqq->next_rq;\n\t/*\n\t * If bfqq has requests queued and it has enough budget left to\n\t * serve them, keep the queue, otherwise expire it.\n\t */\n\tif (next_rq) {\n\t\tif (bfq_serv_to_charge(next_rq, bfqq) >\n\t\t\tbfq_bfqq_budget_left(bfqq)) {\n\t\t\t/*\n\t\t\t * Expire the queue for budget exhaustion,\n\t\t\t * which makes sure that the next budget is\n\t\t\t * enough to serve the next request, even if\n\t\t\t * it comes from the fifo expired path.\n\t\t\t */\n\t\t\treason = BFQQE_BUDGET_EXHAUSTED;\n\t\t\tgoto expire;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The idle timer may be pending because we may\n\t\t\t * not disable disk idling even when a new request\n\t\t\t * arrives.\n\t\t\t */\n\t\t\tif (bfq_bfqq_wait_request(bfqq)) {\n\t\t\t\t/*\n\t\t\t\t * If we get here: 1) at least a new request\n\t\t\t\t * has arrived but we have not disabled the\n\t\t\t\t * timer because the request was too small,\n\t\t\t\t * 2) then the block layer has unplugged\n\t\t\t\t * the device, causing the dispatch to be\n\t\t\t\t * invoked.\n\t\t\t\t *\n\t\t\t\t * Since the device is unplugged, now the\n\t\t\t\t * requests are probably large enough to\n\t\t\t\t * provide a reasonable throughput.\n\t\t\t\t * So we disable idling.\n\t\t\t\t */\n\t\t\t\tbfq_clear_bfqq_wait_request(bfqq);\n\t\t\t\thrtimer_try_to_cancel(&bfqd->idle_slice_timer);\n\t\t\t}\n\t\t\tgoto keep_queue;\n\t\t}\n\t}\n\n\t/*\n\t * No requests pending. However, if the in-service queue is idling\n\t * for a new request, or has requests waiting for a completion and\n\t * may idle after their completion, then keep it anyway.\n\t *\n\t * Yet, inject service from other queues if it boosts\n\t * throughput and is possible.\n\t */\n\tif (bfq_bfqq_wait_request(bfqq) ||\n\t    (bfqq->dispatched != 0 && bfq_better_to_idle(bfqq))) {\n\t\tstruct bfq_queue *async_bfqq =\n\t\t\tbfqq->bic && bfqq->bic->bfqq[0] &&\n\t\t\tbfq_bfqq_busy(bfqq->bic->bfqq[0]) &&\n\t\t\tbfqq->bic->bfqq[0]->next_rq ?\n\t\t\tbfqq->bic->bfqq[0] : NULL;\n\n\t\t/*\n\t\t * The next three mutually-exclusive ifs decide\n\t\t * whether to try injection, and choose the queue to\n\t\t * pick an I/O request from.\n\t\t *\n\t\t * The first if checks whether the process associated\n\t\t * with bfqq has also async I/O pending. If so, it\n\t\t * injects such I/O unconditionally. Injecting async\n\t\t * I/O from the same process can cause no harm to the\n\t\t * process. On the contrary, it can only increase\n\t\t * bandwidth and reduce latency for the process.\n\t\t *\n\t\t * The second if checks whether there happens to be a\n\t\t * non-empty waker queue for bfqq, i.e., a queue whose\n\t\t * I/O needs to be completed for bfqq to receive new\n\t\t * I/O. This happens, e.g., if bfqq is associated with\n\t\t * a process that does some sync. A sync generates\n\t\t * extra blocking I/O, which must be completed before\n\t\t * the process associated with bfqq can go on with its\n\t\t * I/O. If the I/O of the waker queue is not served,\n\t\t * then bfqq remains empty, and no I/O is dispatched,\n\t\t * until the idle timeout fires for bfqq. This is\n\t\t * likely to result in lower bandwidth and higher\n\t\t * latencies for bfqq, and in a severe loss of total\n\t\t * throughput. The best action to take is therefore to\n\t\t * serve the waker queue as soon as possible. So do it\n\t\t * (without relying on the third alternative below for\n\t\t * eventually serving waker_bfqq's I/O; see the last\n\t\t * paragraph for further details). This systematic\n\t\t * injection of I/O from the waker queue does not\n\t\t * cause any delay to bfqq's I/O. On the contrary,\n\t\t * next bfqq's I/O is brought forward dramatically,\n\t\t * for it is not blocked for milliseconds.\n\t\t *\n\t\t * The third if checks whether bfqq is a queue for\n\t\t * which it is better to avoid injection. It is so if\n\t\t * bfqq delivers more throughput when served without\n\t\t * any further I/O from other queues in the middle, or\n\t\t * if the service times of bfqq's I/O requests both\n\t\t * count more than overall throughput, and may be\n\t\t * easily increased by injection (this happens if bfqq\n\t\t * has a short think time). If none of these\n\t\t * conditions holds, then a candidate queue for\n\t\t * injection is looked for through\n\t\t * bfq_choose_bfqq_for_injection(). Note that the\n\t\t * latter may return NULL (for example if the inject\n\t\t * limit for bfqq is currently 0).\n\t\t *\n\t\t * NOTE: motivation for the second alternative\n\t\t *\n\t\t * Thanks to the way the inject limit is updated in\n\t\t * bfq_update_has_short_ttime(), it is rather likely\n\t\t * that, if I/O is being plugged for bfqq and the\n\t\t * waker queue has pending I/O requests that are\n\t\t * blocking bfqq's I/O, then the third alternative\n\t\t * above lets the waker queue get served before the\n\t\t * I/O-plugging timeout fires. So one may deem the\n\t\t * second alternative superfluous. It is not, because\n\t\t * the third alternative may be way less effective in\n\t\t * case of a synchronization. For two main\n\t\t * reasons. First, throughput may be low because the\n\t\t * inject limit may be too low to guarantee the same\n\t\t * amount of injected I/O, from the waker queue or\n\t\t * other queues, that the second alternative\n\t\t * guarantees (the second alternative unconditionally\n\t\t * injects a pending I/O request of the waker queue\n\t\t * for each bfq_dispatch_request()). Second, with the\n\t\t * third alternative, the duration of the plugging,\n\t\t * i.e., the time before bfqq finally receives new I/O,\n\t\t * may not be minimized, because the waker queue may\n\t\t * happen to be served only after other queues.\n\t\t */\n\t\tif (async_bfqq &&\n\t\t    icq_to_bic(async_bfqq->next_rq->elv.icq) == bfqq->bic &&\n\t\t    bfq_serv_to_charge(async_bfqq->next_rq, async_bfqq) <=\n\t\t    bfq_bfqq_budget_left(async_bfqq))\n\t\t\tbfqq = bfqq->bic->bfqq[0];\n\t\telse if (bfq_bfqq_has_waker(bfqq) &&\n\t\t\t   bfq_bfqq_busy(bfqq->waker_bfqq) &&\n\t\t\t   bfqq->next_rq &&\n\t\t\t   bfq_serv_to_charge(bfqq->waker_bfqq->next_rq,\n\t\t\t\t\t      bfqq->waker_bfqq) <=\n\t\t\t   bfq_bfqq_budget_left(bfqq->waker_bfqq)\n\t\t\t)\n\t\t\tbfqq = bfqq->waker_bfqq;\n\t\telse if (!idling_boosts_thr_without_issues(bfqd, bfqq) &&\n\t\t\t (bfqq->wr_coeff == 1 || bfqd->wr_busy_queues > 1 ||\n\t\t\t  !bfq_bfqq_has_short_ttime(bfqq)))\n\t\t\tbfqq = bfq_choose_bfqq_for_injection(bfqd);\n\t\telse\n\t\t\tbfqq = NULL;\n\n\t\tgoto keep_queue;\n\t}\n\n\treason = BFQQE_NO_MORE_REQUESTS;\nexpire:\n\tbfq_bfqq_expire(bfqd, bfqq, false, reason);\nnew_queue:\n\tbfqq = bfq_set_in_service_queue(bfqd);\n\tif (bfqq) {\n\t\tbfq_log_bfqq(bfqd, bfqq, \"select_queue: checking new queue\");\n\t\tgoto check_queue;\n\t}\nkeep_queue:\n\tif (bfqq)\n\t\tbfq_log_bfqq(bfqd, bfqq, \"select_queue: returned this queue\");\n\telse\n\t\tbfq_log(bfqd, \"select_queue: no queue returned\");\n\n\treturn bfqq;\n}\n\nstatic void bfq_update_wr_data(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\n\tif (bfqq->wr_coeff > 1) { /* queue is being weight-raised */\n\t\tbfq_log_bfqq(bfqd, bfqq,\n\t\t\t\"raising period dur %u/%u msec, old coeff %u, w %d(%d)\",\n\t\t\tjiffies_to_msecs(jiffies - bfqq->last_wr_start_finish),\n\t\t\tjiffies_to_msecs(bfqq->wr_cur_max_time),\n\t\t\tbfqq->wr_coeff,\n\t\t\tbfqq->entity.weight, bfqq->entity.orig_weight);\n\n\t\tif (entity->prio_changed)\n\t\t\tbfq_log_bfqq(bfqd, bfqq, \"WARN: pending prio change\");\n\n\t\t/*\n\t\t * If the queue was activated in a burst, or too much\n\t\t * time has elapsed from the beginning of this\n\t\t * weight-raising period, then end weight raising.\n\t\t */\n\t\tif (bfq_bfqq_in_large_burst(bfqq))\n\t\t\tbfq_bfqq_end_wr(bfqq);\n\t\telse if (time_is_before_jiffies(bfqq->last_wr_start_finish +\n\t\t\t\t\t\tbfqq->wr_cur_max_time)) {\n\t\t\tif (bfqq->wr_cur_max_time != bfqd->bfq_wr_rt_max_time ||\n\t\t\ttime_is_before_jiffies(bfqq->wr_start_at_switch_to_srt +\n\t\t\t\t\t       bfq_wr_duration(bfqd)))\n\t\t\t\tbfq_bfqq_end_wr(bfqq);\n\t\t\telse {\n\t\t\t\tswitch_back_to_interactive_wr(bfqq, bfqd);\n\t\t\t\tbfqq->entity.prio_changed = 1;\n\t\t\t}\n\t\t}\n\t\tif (bfqq->wr_coeff > 1 &&\n\t\t    bfqq->wr_cur_max_time != bfqd->bfq_wr_rt_max_time &&\n\t\t    bfqq->service_from_wr > max_service_from_wr) {\n\t\t\t/* see comments on max_service_from_wr */\n\t\t\tbfq_bfqq_end_wr(bfqq);\n\t\t}\n\t}\n\t/*\n\t * To improve latency (for this or other queues), immediately\n\t * update weight both if it must be raised and if it must be\n\t * lowered. Since, entity may be on some active tree here, and\n\t * might have a pending change of its ioprio class, invoke\n\t * next function with the last parameter unset (see the\n\t * comments on the function).\n\t */\n\tif ((entity->weight > entity->orig_weight) != (bfqq->wr_coeff > 1))\n\t\t__bfq_entity_update_weight_prio(bfq_entity_service_tree(entity),\n\t\t\t\t\t\tentity, false);\n}\n\n/*\n * Dispatch next request from bfqq.\n */\nstatic struct request *bfq_dispatch_rq_from_bfqq(struct bfq_data *bfqd,\n\t\t\t\t\t\t struct bfq_queue *bfqq)\n{\n\tstruct request *rq = bfqq->next_rq;\n\tunsigned long service_to_charge;\n\n\tservice_to_charge = bfq_serv_to_charge(rq, bfqq);\n\n\tbfq_bfqq_served(bfqq, service_to_charge);\n\n\tif (bfqq == bfqd->in_service_queue && bfqd->wait_dispatch) {\n\t\tbfqd->wait_dispatch = false;\n\t\tbfqd->waited_rq = rq;\n\t}\n\n\tbfq_dispatch_remove(bfqd->queue, rq);\n\n\tif (bfqq != bfqd->in_service_queue)\n\t\tgoto return_rq;\n\n\t/*\n\t * If weight raising has to terminate for bfqq, then next\n\t * function causes an immediate update of bfqq's weight,\n\t * without waiting for next activation. As a consequence, on\n\t * expiration, bfqq will be timestamped as if has never been\n\t * weight-raised during this service slot, even if it has\n\t * received part or even most of the service as a\n\t * weight-raised queue. This inflates bfqq's timestamps, which\n\t * is beneficial, as bfqq is then more willing to leave the\n\t * device immediately to possible other weight-raised queues.\n\t */\n\tbfq_update_wr_data(bfqd, bfqq);\n\n\t/*\n\t * Expire bfqq, pretending that its budget expired, if bfqq\n\t * belongs to CLASS_IDLE and other queues are waiting for\n\t * service.\n\t */\n\tif (!(bfq_tot_busy_queues(bfqd) > 1 && bfq_class_idle(bfqq)))\n\t\tgoto return_rq;\n\n\tbfq_bfqq_expire(bfqd, bfqq, false, BFQQE_BUDGET_EXHAUSTED);\n\nreturn_rq:\n\treturn rq;\n}\n\nstatic bool bfq_has_work(struct blk_mq_hw_ctx *hctx)\n{\n\tstruct bfq_data *bfqd = hctx->queue->elevator->elevator_data;\n\n\tif (!atomic_read(&hctx->elevator_queued))\n\t\treturn false;\n\n\t/*\n\t * Avoiding lock: a race on bfqd->busy_queues should cause at\n\t * most a call to dispatch for nothing\n\t */\n\treturn !list_empty_careful(&bfqd->dispatch) ||\n\t\tbfq_tot_busy_queues(bfqd) > 0;\n}\n\nstatic struct request *__bfq_dispatch_request(struct blk_mq_hw_ctx *hctx)\n{\n\tstruct bfq_data *bfqd = hctx->queue->elevator->elevator_data;\n\tstruct request *rq = NULL;\n\tstruct bfq_queue *bfqq = NULL;\n\n\tif (!list_empty(&bfqd->dispatch)) {\n\t\trq = list_first_entry(&bfqd->dispatch, struct request,\n\t\t\t\t      queuelist);\n\t\tlist_del_init(&rq->queuelist);\n\n\t\tbfqq = RQ_BFQQ(rq);\n\n\t\tif (bfqq) {\n\t\t\t/*\n\t\t\t * Increment counters here, because this\n\t\t\t * dispatch does not follow the standard\n\t\t\t * dispatch flow (where counters are\n\t\t\t * incremented)\n\t\t\t */\n\t\t\tbfqq->dispatched++;\n\n\t\t\tgoto inc_in_driver_start_rq;\n\t\t}\n\n\t\t/*\n\t\t * We exploit the bfq_finish_requeue_request hook to\n\t\t * decrement rq_in_driver, but\n\t\t * bfq_finish_requeue_request will not be invoked on\n\t\t * this request. So, to avoid unbalance, just start\n\t\t * this request, without incrementing rq_in_driver. As\n\t\t * a negative consequence, rq_in_driver is deceptively\n\t\t * lower than it should be while this request is in\n\t\t * service. This may cause bfq_schedule_dispatch to be\n\t\t * invoked uselessly.\n\t\t *\n\t\t * As for implementing an exact solution, the\n\t\t * bfq_finish_requeue_request hook, if defined, is\n\t\t * probably invoked also on this request. So, by\n\t\t * exploiting this hook, we could 1) increment\n\t\t * rq_in_driver here, and 2) decrement it in\n\t\t * bfq_finish_requeue_request. Such a solution would\n\t\t * let the value of the counter be always accurate,\n\t\t * but it would entail using an extra interface\n\t\t * function. This cost seems higher than the benefit,\n\t\t * being the frequency of non-elevator-private\n\t\t * requests very low.\n\t\t */\n\t\tgoto start_rq;\n\t}\n\n\tbfq_log(bfqd, \"dispatch requests: %d busy queues\",\n\t\tbfq_tot_busy_queues(bfqd));\n\n\tif (bfq_tot_busy_queues(bfqd) == 0)\n\t\tgoto exit;\n\n\t/*\n\t * Force device to serve one request at a time if\n\t * strict_guarantees is true. Forcing this service scheme is\n\t * currently the ONLY way to guarantee that the request\n\t * service order enforced by the scheduler is respected by a\n\t * queueing device. Otherwise the device is free even to make\n\t * some unlucky request wait for as long as the device\n\t * wishes.\n\t *\n\t * Of course, serving one request at a time may cause loss of\n\t * throughput.\n\t */\n\tif (bfqd->strict_guarantees && bfqd->rq_in_driver > 0)\n\t\tgoto exit;\n\n\tbfqq = bfq_select_queue(bfqd);\n\tif (!bfqq)\n\t\tgoto exit;\n\n\trq = bfq_dispatch_rq_from_bfqq(bfqd, bfqq);\n\n\tif (rq) {\ninc_in_driver_start_rq:\n\t\tbfqd->rq_in_driver++;\nstart_rq:\n\t\trq->rq_flags |= RQF_STARTED;\n\t}\nexit:\n\treturn rq;\n}\n\n#ifdef CONFIG_BFQ_CGROUP_DEBUG\nstatic void bfq_update_dispatch_stats(struct request_queue *q,\n\t\t\t\t      struct request *rq,\n\t\t\t\t      struct bfq_queue *in_serv_queue,\n\t\t\t\t      bool idle_timer_disabled)\n{\n\tstruct bfq_queue *bfqq = rq ? RQ_BFQQ(rq) : NULL;\n\n\tif (!idle_timer_disabled && !bfqq)\n\t\treturn;\n\n\t/*\n\t * rq and bfqq are guaranteed to exist until this function\n\t * ends, for the following reasons. First, rq can be\n\t * dispatched to the device, and then can be completed and\n\t * freed, only after this function ends. Second, rq cannot be\n\t * merged (and thus freed because of a merge) any longer,\n\t * because it has already started. Thus rq cannot be freed\n\t * before this function ends, and, since rq has a reference to\n\t * bfqq, the same guarantee holds for bfqq too.\n\t *\n\t * In addition, the following queue lock guarantees that\n\t * bfqq_group(bfqq) exists as well.\n\t */\n\tspin_lock_irq(&q->queue_lock);\n\tif (idle_timer_disabled)\n\t\t/*\n\t\t * Since the idle timer has been disabled,\n\t\t * in_serv_queue contained some request when\n\t\t * __bfq_dispatch_request was invoked above, which\n\t\t * implies that rq was picked exactly from\n\t\t * in_serv_queue. Thus in_serv_queue == bfqq, and is\n\t\t * therefore guaranteed to exist because of the above\n\t\t * arguments.\n\t\t */\n\t\tbfqg_stats_update_idle_time(bfqq_group(in_serv_queue));\n\tif (bfqq) {\n\t\tstruct bfq_group *bfqg = bfqq_group(bfqq);\n\n\t\tbfqg_stats_update_avg_queue_size(bfqg);\n\t\tbfqg_stats_set_start_empty_time(bfqg);\n\t\tbfqg_stats_update_io_remove(bfqg, rq->cmd_flags);\n\t}\n\tspin_unlock_irq(&q->queue_lock);\n}\n#else\nstatic inline void bfq_update_dispatch_stats(struct request_queue *q,\n\t\t\t\t\t     struct request *rq,\n\t\t\t\t\t     struct bfq_queue *in_serv_queue,\n\t\t\t\t\t     bool idle_timer_disabled) {}\n#endif /* CONFIG_BFQ_CGROUP_DEBUG */\n\nstatic struct request *bfq_dispatch_request(struct blk_mq_hw_ctx *hctx)\n{\n\tstruct bfq_data *bfqd = hctx->queue->elevator->elevator_data;\n\tstruct request *rq;\n\tstruct bfq_queue *in_serv_queue;\n\tbool waiting_rq, idle_timer_disabled;\n\n\tspin_lock_irq(&bfqd->lock);\n\n\tin_serv_queue = bfqd->in_service_queue;\n\twaiting_rq = in_serv_queue && bfq_bfqq_wait_request(in_serv_queue);\n\n\trq = __bfq_dispatch_request(hctx);\n\n\tidle_timer_disabled =\n\t\twaiting_rq && !bfq_bfqq_wait_request(in_serv_queue);\n\n\tspin_unlock_irq(&bfqd->lock);\n\n\tbfq_update_dispatch_stats(hctx->queue, rq, in_serv_queue,\n\t\t\t\t  idle_timer_disabled);\n\n\treturn rq;\n}\n\n/*\n * Task holds one reference to the queue, dropped when task exits.  Each rq\n * in-flight on this queue also holds a reference, dropped when rq is freed.\n *\n * Scheduler lock must be held here. Recall not to use bfqq after calling\n * this function on it.\n */\nvoid bfq_put_queue(struct bfq_queue *bfqq)\n{\n\tstruct bfq_queue *item;\n\tstruct hlist_node *n;\n\tstruct bfq_group *bfqg = bfqq_group(bfqq);\n\n\tif (bfqq->bfqd)\n\t\tbfq_log_bfqq(bfqq->bfqd, bfqq, \"put_queue: %p %d\",\n\t\t\t     bfqq, bfqq->ref);\n\n\tbfqq->ref--;\n\tif (bfqq->ref)\n\t\treturn;\n\n\tif (!hlist_unhashed(&bfqq->burst_list_node)) {\n\t\thlist_del_init(&bfqq->burst_list_node);\n\t\t/*\n\t\t * Decrement also burst size after the removal, if the\n\t\t * process associated with bfqq is exiting, and thus\n\t\t * does not contribute to the burst any longer. This\n\t\t * decrement helps filter out false positives of large\n\t\t * bursts, when some short-lived process (often due to\n\t\t * the execution of commands by some service) happens\n\t\t * to start and exit while a complex application is\n\t\t * starting, and thus spawning several processes that\n\t\t * do I/O (and that *must not* be treated as a large\n\t\t * burst, see comments on bfq_handle_burst).\n\t\t *\n\t\t * In particular, the decrement is performed only if:\n\t\t * 1) bfqq is not a merged queue, because, if it is,\n\t\t * then this free of bfqq is not triggered by the exit\n\t\t * of the process bfqq is associated with, but exactly\n\t\t * by the fact that bfqq has just been merged.\n\t\t * 2) burst_size is greater than 0, to handle\n\t\t * unbalanced decrements. Unbalanced decrements may\n\t\t * happen in te following case: bfqq is inserted into\n\t\t * the current burst list--without incrementing\n\t\t * bust_size--because of a split, but the current\n\t\t * burst list is not the burst list bfqq belonged to\n\t\t * (see comments on the case of a split in\n\t\t * bfq_set_request).\n\t\t */\n\t\tif (bfqq->bic && bfqq->bfqd->burst_size > 0)\n\t\t\tbfqq->bfqd->burst_size--;\n\t}\n\n\t/*\n\t * bfqq does not exist any longer, so it cannot be woken by\n\t * any other queue, and cannot wake any other queue. Then bfqq\n\t * must be removed from the woken list of its possible waker\n\t * queue, and all queues in the woken list of bfqq must stop\n\t * having a waker queue. Strictly speaking, these updates\n\t * should be performed when bfqq remains with no I/O source\n\t * attached to it, which happens before bfqq gets freed. In\n\t * particular, this happens when the last process associated\n\t * with bfqq exits or gets associated with a different\n\t * queue. However, both events lead to bfqq being freed soon,\n\t * and dangling references would come out only after bfqq gets\n\t * freed. So these updates are done here, as a simple and safe\n\t * way to handle all cases.\n\t */\n\t/* remove bfqq from woken list */\n\tif (!hlist_unhashed(&bfqq->woken_list_node))\n\t\thlist_del_init(&bfqq->woken_list_node);\n\n\t/* reset waker for all queues in woken list */\n\thlist_for_each_entry_safe(item, n, &bfqq->woken_list,\n\t\t\t\t  woken_list_node) {\n\t\titem->waker_bfqq = NULL;\n\t\tbfq_clear_bfqq_has_waker(item);\n\t\thlist_del_init(&item->woken_list_node);\n\t}\n\n\tif (bfqq->bfqd && bfqq->bfqd->last_completed_rq_bfqq == bfqq)\n\t\tbfqq->bfqd->last_completed_rq_bfqq = NULL;\n\n\tkmem_cache_free(bfq_pool, bfqq);\n\tbfqg_and_blkg_put(bfqg);\n}\n\nstatic void bfq_put_cooperator(struct bfq_queue *bfqq)\n{\n\tstruct bfq_queue *__bfqq, *next;\n\n\t/*\n\t * If this queue was scheduled to merge with another queue, be\n\t * sure to drop the reference taken on that queue (and others in\n\t * the merge chain). See bfq_setup_merge and bfq_merge_bfqqs.\n\t */\n\t__bfqq = bfqq->new_bfqq;\n\twhile (__bfqq) {\n\t\tif (__bfqq == bfqq)\n\t\t\tbreak;\n\t\tnext = __bfqq->new_bfqq;\n\t\tbfq_put_queue(__bfqq);\n\t\t__bfqq = next;\n\t}\n}\n\nstatic void bfq_exit_bfqq(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\tif (bfqq == bfqd->in_service_queue) {\n\t\t__bfq_bfqq_expire(bfqd, bfqq, BFQQE_BUDGET_TIMEOUT);\n\t\tbfq_schedule_dispatch(bfqd);\n\t}\n\n\tbfq_log_bfqq(bfqd, bfqq, \"exit_bfqq: %p, %d\", bfqq, bfqq->ref);\n\n\tbfq_put_cooperator(bfqq);\n\n\tbfq_release_process_ref(bfqd, bfqq);\n}\n\nstatic void bfq_exit_icq_bfqq(struct bfq_io_cq *bic, bool is_sync)\n{\n\tstruct bfq_queue *bfqq = bic_to_bfqq(bic, is_sync);\n\tstruct bfq_data *bfqd;\n\n\tif (bfqq)\n\t\tbfqd = bfqq->bfqd; /* NULL if scheduler already exited */\n\n\tif (bfqq && bfqd) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&bfqd->lock, flags);\n\t\tbfqq->bic = NULL;\n\t\tbfq_exit_bfqq(bfqd, bfqq);\n\t\tbic_set_bfqq(bic, NULL, is_sync);\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t}\n}\n\nstatic void bfq_exit_icq(struct io_cq *icq)\n{\n\tstruct bfq_io_cq *bic = icq_to_bic(icq);\n\n\tbfq_exit_icq_bfqq(bic, true);\n\tbfq_exit_icq_bfqq(bic, false);\n}\n\n/*\n * Update the entity prio values; note that the new values will not\n * be used until the next (re)activation.\n */\nstatic void\nbfq_set_next_ioprio_data(struct bfq_queue *bfqq, struct bfq_io_cq *bic)\n{\n\tstruct task_struct *tsk = current;\n\tint ioprio_class;\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\n\tif (!bfqd)\n\t\treturn;\n\n\tioprio_class = IOPRIO_PRIO_CLASS(bic->ioprio);\n\tswitch (ioprio_class) {\n\tdefault:\n\t\tpr_err(\"bdi %s: bfq: bad prio class %d\\n\",\n\t\t\t\tbdi_dev_name(bfqq->bfqd->queue->backing_dev_info),\n\t\t\t\tioprio_class);\n\t\tfallthrough;\n\tcase IOPRIO_CLASS_NONE:\n\t\t/*\n\t\t * No prio set, inherit CPU scheduling settings.\n\t\t */\n\t\tbfqq->new_ioprio = task_nice_ioprio(tsk);\n\t\tbfqq->new_ioprio_class = task_nice_ioclass(tsk);\n\t\tbreak;\n\tcase IOPRIO_CLASS_RT:\n\t\tbfqq->new_ioprio = IOPRIO_PRIO_DATA(bic->ioprio);\n\t\tbfqq->new_ioprio_class = IOPRIO_CLASS_RT;\n\t\tbreak;\n\tcase IOPRIO_CLASS_BE:\n\t\tbfqq->new_ioprio = IOPRIO_PRIO_DATA(bic->ioprio);\n\t\tbfqq->new_ioprio_class = IOPRIO_CLASS_BE;\n\t\tbreak;\n\tcase IOPRIO_CLASS_IDLE:\n\t\tbfqq->new_ioprio_class = IOPRIO_CLASS_IDLE;\n\t\tbfqq->new_ioprio = 7;\n\t\tbreak;\n\t}\n\n\tif (bfqq->new_ioprio >= IOPRIO_BE_NR) {\n\t\tpr_crit(\"bfq_set_next_ioprio_data: new_ioprio %d\\n\",\n\t\t\tbfqq->new_ioprio);\n\t\tbfqq->new_ioprio = IOPRIO_BE_NR;\n\t}\n\n\tbfqq->entity.new_weight = bfq_ioprio_to_weight(bfqq->new_ioprio);\n\tbfqq->entity.prio_changed = 1;\n}\n\nstatic struct bfq_queue *bfq_get_queue(struct bfq_data *bfqd,\n\t\t\t\t       struct bio *bio, bool is_sync,\n\t\t\t\t       struct bfq_io_cq *bic);\n\nstatic void bfq_check_ioprio_change(struct bfq_io_cq *bic, struct bio *bio)\n{\n\tstruct bfq_data *bfqd = bic_to_bfqd(bic);\n\tstruct bfq_queue *bfqq;\n\tint ioprio = bic->icq.ioc->ioprio;\n\n\t/*\n\t * This condition may trigger on a newly created bic, be sure to\n\t * drop the lock before returning.\n\t */\n\tif (unlikely(!bfqd) || likely(bic->ioprio == ioprio))\n\t\treturn;\n\n\tbic->ioprio = ioprio;\n\n\tbfqq = bic_to_bfqq(bic, false);\n\tif (bfqq) {\n\t\tbfq_release_process_ref(bfqd, bfqq);\n\t\tbfqq = bfq_get_queue(bfqd, bio, BLK_RW_ASYNC, bic);\n\t\tbic_set_bfqq(bic, bfqq, false);\n\t}\n\n\tbfqq = bic_to_bfqq(bic, true);\n\tif (bfqq)\n\t\tbfq_set_next_ioprio_data(bfqq, bic);\n}\n\nstatic void bfq_init_bfqq(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t\t  struct bfq_io_cq *bic, pid_t pid, int is_sync)\n{\n\tRB_CLEAR_NODE(&bfqq->entity.rb_node);\n\tINIT_LIST_HEAD(&bfqq->fifo);\n\tINIT_HLIST_NODE(&bfqq->burst_list_node);\n\tINIT_HLIST_NODE(&bfqq->woken_list_node);\n\tINIT_HLIST_HEAD(&bfqq->woken_list);\n\n\tbfqq->ref = 0;\n\tbfqq->bfqd = bfqd;\n\n\tif (bic)\n\t\tbfq_set_next_ioprio_data(bfqq, bic);\n\n\tif (is_sync) {\n\t\t/*\n\t\t * No need to mark as has_short_ttime if in\n\t\t * idle_class, because no device idling is performed\n\t\t * for queues in idle class\n\t\t */\n\t\tif (!bfq_class_idle(bfqq))\n\t\t\t/* tentatively mark as has_short_ttime */\n\t\t\tbfq_mark_bfqq_has_short_ttime(bfqq);\n\t\tbfq_mark_bfqq_sync(bfqq);\n\t\tbfq_mark_bfqq_just_created(bfqq);\n\t} else\n\t\tbfq_clear_bfqq_sync(bfqq);\n\n\t/* set end request to minus infinity from now */\n\tbfqq->ttime.last_end_request = ktime_get_ns() + 1;\n\n\tbfq_mark_bfqq_IO_bound(bfqq);\n\n\tbfqq->pid = pid;\n\n\t/* Tentative initial value to trade off between thr and lat */\n\tbfqq->max_budget = (2 * bfq_max_budget(bfqd)) / 3;\n\tbfqq->budget_timeout = bfq_smallest_from_now();\n\n\tbfqq->wr_coeff = 1;\n\tbfqq->last_wr_start_finish = jiffies;\n\tbfqq->wr_start_at_switch_to_srt = bfq_smallest_from_now();\n\tbfqq->split_time = bfq_smallest_from_now();\n\n\t/*\n\t * To not forget the possibly high bandwidth consumed by a\n\t * process/queue in the recent past,\n\t * bfq_bfqq_softrt_next_start() returns a value at least equal\n\t * to the current value of bfqq->soft_rt_next_start (see\n\t * comments on bfq_bfqq_softrt_next_start).  Set\n\t * soft_rt_next_start to now, to mean that bfqq has consumed\n\t * no bandwidth so far.\n\t */\n\tbfqq->soft_rt_next_start = jiffies;\n\n\t/* first request is almost certainly seeky */\n\tbfqq->seek_history = 1;\n}\n\nstatic struct bfq_queue **bfq_async_queue_prio(struct bfq_data *bfqd,\n\t\t\t\t\t       struct bfq_group *bfqg,\n\t\t\t\t\t       int ioprio_class, int ioprio)\n{\n\tswitch (ioprio_class) {\n\tcase IOPRIO_CLASS_RT:\n\t\treturn &bfqg->async_bfqq[0][ioprio];\n\tcase IOPRIO_CLASS_NONE:\n\t\tioprio = IOPRIO_NORM;\n\t\tfallthrough;\n\tcase IOPRIO_CLASS_BE:\n\t\treturn &bfqg->async_bfqq[1][ioprio];\n\tcase IOPRIO_CLASS_IDLE:\n\t\treturn &bfqg->async_idle_bfqq;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic struct bfq_queue *bfq_get_queue(struct bfq_data *bfqd,\n\t\t\t\t       struct bio *bio, bool is_sync,\n\t\t\t\t       struct bfq_io_cq *bic)\n{\n\tconst int ioprio = IOPRIO_PRIO_DATA(bic->ioprio);\n\tconst int ioprio_class = IOPRIO_PRIO_CLASS(bic->ioprio);\n\tstruct bfq_queue **async_bfqq = NULL;\n\tstruct bfq_queue *bfqq;\n\tstruct bfq_group *bfqg;\n\n\trcu_read_lock();\n\n\tbfqg = bfq_find_set_group(bfqd, __bio_blkcg(bio));\n\tif (!bfqg) {\n\t\tbfqq = &bfqd->oom_bfqq;\n\t\tgoto out;\n\t}\n\n\tif (!is_sync) {\n\t\tasync_bfqq = bfq_async_queue_prio(bfqd, bfqg, ioprio_class,\n\t\t\t\t\t\t  ioprio);\n\t\tbfqq = *async_bfqq;\n\t\tif (bfqq)\n\t\t\tgoto out;\n\t}\n\n\tbfqq = kmem_cache_alloc_node(bfq_pool,\n\t\t\t\t     GFP_NOWAIT | __GFP_ZERO | __GFP_NOWARN,\n\t\t\t\t     bfqd->queue->node);\n\n\tif (bfqq) {\n\t\tbfq_init_bfqq(bfqd, bfqq, bic, current->pid,\n\t\t\t      is_sync);\n\t\tbfq_init_entity(&bfqq->entity, bfqg);\n\t\tbfq_log_bfqq(bfqd, bfqq, \"allocated\");\n\t} else {\n\t\tbfqq = &bfqd->oom_bfqq;\n\t\tbfq_log_bfqq(bfqd, bfqq, \"using oom bfqq\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Pin the queue now that it's allocated, scheduler exit will\n\t * prune it.\n\t */\n\tif (async_bfqq) {\n\t\tbfqq->ref++; /*\n\t\t\t      * Extra group reference, w.r.t. sync\n\t\t\t      * queue. This extra reference is removed\n\t\t\t      * only if bfqq->bfqg disappears, to\n\t\t\t      * guarantee that this queue is not freed\n\t\t\t      * until its group goes away.\n\t\t\t      */\n\t\tbfq_log_bfqq(bfqd, bfqq, \"get_queue, bfqq not in async: %p, %d\",\n\t\t\t     bfqq, bfqq->ref);\n\t\t*async_bfqq = bfqq;\n\t}\n\nout:\n\tbfqq->ref++; /* get a process reference to this queue */\n\tbfq_log_bfqq(bfqd, bfqq, \"get_queue, at end: %p, %d\", bfqq, bfqq->ref);\n\trcu_read_unlock();\n\treturn bfqq;\n}\n\nstatic void bfq_update_io_thinktime(struct bfq_data *bfqd,\n\t\t\t\t    struct bfq_queue *bfqq)\n{\n\tstruct bfq_ttime *ttime = &bfqq->ttime;\n\tu64 elapsed = ktime_get_ns() - bfqq->ttime.last_end_request;\n\n\telapsed = min_t(u64, elapsed, 2ULL * bfqd->bfq_slice_idle);\n\n\tttime->ttime_samples = (7*bfqq->ttime.ttime_samples + 256) / 8;\n\tttime->ttime_total = div_u64(7*ttime->ttime_total + 256*elapsed,  8);\n\tttime->ttime_mean = div64_ul(ttime->ttime_total + 128,\n\t\t\t\t     ttime->ttime_samples);\n}\n\nstatic void\nbfq_update_io_seektime(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t       struct request *rq)\n{\n\tbfqq->seek_history <<= 1;\n\tbfqq->seek_history |= BFQ_RQ_SEEKY(bfqd, bfqq->last_request_pos, rq);\n\n\tif (bfqq->wr_coeff > 1 &&\n\t    bfqq->wr_cur_max_time == bfqd->bfq_wr_rt_max_time &&\n\t    BFQQ_TOTALLY_SEEKY(bfqq))\n\t\tbfq_bfqq_end_wr(bfqq);\n}\n\nstatic void bfq_update_has_short_ttime(struct bfq_data *bfqd,\n\t\t\t\t       struct bfq_queue *bfqq,\n\t\t\t\t       struct bfq_io_cq *bic)\n{\n\tbool has_short_ttime = true, state_changed;\n\n\t/*\n\t * No need to update has_short_ttime if bfqq is async or in\n\t * idle io prio class, or if bfq_slice_idle is zero, because\n\t * no device idling is performed for bfqq in this case.\n\t */\n\tif (!bfq_bfqq_sync(bfqq) || bfq_class_idle(bfqq) ||\n\t    bfqd->bfq_slice_idle == 0)\n\t\treturn;\n\n\t/* Idle window just restored, statistics are meaningless. */\n\tif (time_is_after_eq_jiffies(bfqq->split_time +\n\t\t\t\t     bfqd->bfq_wr_min_idle_time))\n\t\treturn;\n\n\t/* Think time is infinite if no process is linked to\n\t * bfqq. Otherwise check average think time to\n\t * decide whether to mark as has_short_ttime\n\t */\n\tif (atomic_read(&bic->icq.ioc->active_ref) == 0 ||\n\t    (bfq_sample_valid(bfqq->ttime.ttime_samples) &&\n\t     bfqq->ttime.ttime_mean > bfqd->bfq_slice_idle))\n\t\thas_short_ttime = false;\n\n\tstate_changed = has_short_ttime != bfq_bfqq_has_short_ttime(bfqq);\n\n\tif (has_short_ttime)\n\t\tbfq_mark_bfqq_has_short_ttime(bfqq);\n\telse\n\t\tbfq_clear_bfqq_has_short_ttime(bfqq);\n\n\t/*\n\t * Until the base value for the total service time gets\n\t * finally computed for bfqq, the inject limit does depend on\n\t * the think-time state (short|long). In particular, the limit\n\t * is 0 or 1 if the think time is deemed, respectively, as\n\t * short or long (details in the comments in\n\t * bfq_update_inject_limit()). Accordingly, the next\n\t * instructions reset the inject limit if the think-time state\n\t * has changed and the above base value is still to be\n\t * computed.\n\t *\n\t * However, the reset is performed only if more than 100 ms\n\t * have elapsed since the last update of the inject limit, or\n\t * (inclusive) if the change is from short to long think\n\t * time. The reason for this waiting is as follows.\n\t *\n\t * bfqq may have a long think time because of a\n\t * synchronization with some other queue, i.e., because the\n\t * I/O of some other queue may need to be completed for bfqq\n\t * to receive new I/O. Details in the comments on the choice\n\t * of the queue for injection in bfq_select_queue().\n\t *\n\t * As stressed in those comments, if such a synchronization is\n\t * actually in place, then, without injection on bfqq, the\n\t * blocking I/O cannot happen to served while bfqq is in\n\t * service. As a consequence, if bfqq is granted\n\t * I/O-dispatch-plugging, then bfqq remains empty, and no I/O\n\t * is dispatched, until the idle timeout fires. This is likely\n\t * to result in lower bandwidth and higher latencies for bfqq,\n\t * and in a severe loss of total throughput.\n\t *\n\t * On the opposite end, a non-zero inject limit may allow the\n\t * I/O that blocks bfqq to be executed soon, and therefore\n\t * bfqq to receive new I/O soon.\n\t *\n\t * But, if the blocking gets actually eliminated, then the\n\t * next think-time sample for bfqq may be very low. This in\n\t * turn may cause bfqq's think time to be deemed\n\t * short. Without the 100 ms barrier, this new state change\n\t * would cause the body of the next if to be executed\n\t * immediately. But this would set to 0 the inject\n\t * limit. Without injection, the blocking I/O would cause the\n\t * think time of bfqq to become long again, and therefore the\n\t * inject limit to be raised again, and so on. The only effect\n\t * of such a steady oscillation between the two think-time\n\t * states would be to prevent effective injection on bfqq.\n\t *\n\t * In contrast, if the inject limit is not reset during such a\n\t * long time interval as 100 ms, then the number of short\n\t * think time samples can grow significantly before the reset\n\t * is performed. As a consequence, the think time state can\n\t * become stable before the reset. Therefore there will be no\n\t * state change when the 100 ms elapse, and no reset of the\n\t * inject limit. The inject limit remains steadily equal to 1\n\t * both during and after the 100 ms. So injection can be\n\t * performed at all times, and throughput gets boosted.\n\t *\n\t * An inject limit equal to 1 is however in conflict, in\n\t * general, with the fact that the think time of bfqq is\n\t * short, because injection may be likely to delay bfqq's I/O\n\t * (as explained in the comments in\n\t * bfq_update_inject_limit()). But this does not happen in\n\t * this special case, because bfqq's low think time is due to\n\t * an effective handling of a synchronization, through\n\t * injection. In this special case, bfqq's I/O does not get\n\t * delayed by injection; on the contrary, bfqq's I/O is\n\t * brought forward, because it is not blocked for\n\t * milliseconds.\n\t *\n\t * In addition, serving the blocking I/O much sooner, and much\n\t * more frequently than once per I/O-plugging timeout, makes\n\t * it much quicker to detect a waker queue (the concept of\n\t * waker queue is defined in the comments in\n\t * bfq_add_request()). This makes it possible to start sooner\n\t * to boost throughput more effectively, by injecting the I/O\n\t * of the waker queue unconditionally on every\n\t * bfq_dispatch_request().\n\t *\n\t * One last, important benefit of not resetting the inject\n\t * limit before 100 ms is that, during this time interval, the\n\t * base value for the total service time is likely to get\n\t * finally computed for bfqq, freeing the inject limit from\n\t * its relation with the think time.\n\t */\n\tif (state_changed && bfqq->last_serv_time_ns == 0 &&\n\t    (time_is_before_eq_jiffies(bfqq->decrease_time_jif +\n\t\t\t\t      msecs_to_jiffies(100)) ||\n\t     !has_short_ttime))\n\t\tbfq_reset_inject_limit(bfqd, bfqq);\n}\n\n/*\n * Called when a new fs request (rq) is added to bfqq.  Check if there's\n * something we should do about it.\n */\nstatic void bfq_rq_enqueued(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t\t    struct request *rq)\n{\n\tif (rq->cmd_flags & REQ_META)\n\t\tbfqq->meta_pending++;\n\n\tbfqq->last_request_pos = blk_rq_pos(rq) + blk_rq_sectors(rq);\n\n\tif (bfqq == bfqd->in_service_queue && bfq_bfqq_wait_request(bfqq)) {\n\t\tbool small_req = bfqq->queued[rq_is_sync(rq)] == 1 &&\n\t\t\t\t blk_rq_sectors(rq) < 32;\n\t\tbool budget_timeout = bfq_bfqq_budget_timeout(bfqq);\n\n\t\t/*\n\t\t * There is just this request queued: if\n\t\t * - the request is small, and\n\t\t * - we are idling to boost throughput, and\n\t\t * - the queue is not to be expired,\n\t\t * then just exit.\n\t\t *\n\t\t * In this way, if the device is being idled to wait\n\t\t * for a new request from the in-service queue, we\n\t\t * avoid unplugging the device and committing the\n\t\t * device to serve just a small request. In contrast\n\t\t * we wait for the block layer to decide when to\n\t\t * unplug the device: hopefully, new requests will be\n\t\t * merged to this one quickly, then the device will be\n\t\t * unplugged and larger requests will be dispatched.\n\t\t */\n\t\tif (small_req && idling_boosts_thr_without_issues(bfqd, bfqq) &&\n\t\t    !budget_timeout)\n\t\t\treturn;\n\n\t\t/*\n\t\t * A large enough request arrived, or idling is being\n\t\t * performed to preserve service guarantees, or\n\t\t * finally the queue is to be expired: in all these\n\t\t * cases disk idling is to be stopped, so clear\n\t\t * wait_request flag and reset timer.\n\t\t */\n\t\tbfq_clear_bfqq_wait_request(bfqq);\n\t\thrtimer_try_to_cancel(&bfqd->idle_slice_timer);\n\n\t\t/*\n\t\t * The queue is not empty, because a new request just\n\t\t * arrived. Hence we can safely expire the queue, in\n\t\t * case of budget timeout, without risking that the\n\t\t * timestamps of the queue are not updated correctly.\n\t\t * See [1] for more details.\n\t\t */\n\t\tif (budget_timeout)\n\t\t\tbfq_bfqq_expire(bfqd, bfqq, false,\n\t\t\t\t\tBFQQE_BUDGET_TIMEOUT);\n\t}\n}\n\n/* returns true if it causes the idle timer to be disabled */\nstatic bool __bfq_insert_request(struct bfq_data *bfqd, struct request *rq)\n{\n\tstruct bfq_queue *bfqq = RQ_BFQQ(rq),\n\t\t*new_bfqq = bfq_setup_cooperator(bfqd, bfqq, rq, true);\n\tbool waiting, idle_timer_disabled = false;\n\n\tif (new_bfqq) {\n\t\t/*\n\t\t * Release the request's reference to the old bfqq\n\t\t * and make sure one is taken to the shared queue.\n\t\t */\n\t\tnew_bfqq->allocated++;\n\t\tbfqq->allocated--;\n\t\tnew_bfqq->ref++;\n\t\t/*\n\t\t * If the bic associated with the process\n\t\t * issuing this request still points to bfqq\n\t\t * (and thus has not been already redirected\n\t\t * to new_bfqq or even some other bfq_queue),\n\t\t * then complete the merge and redirect it to\n\t\t * new_bfqq.\n\t\t */\n\t\tif (bic_to_bfqq(RQ_BIC(rq), 1) == bfqq)\n\t\t\tbfq_merge_bfqqs(bfqd, RQ_BIC(rq),\n\t\t\t\t\tbfqq, new_bfqq);\n\n\t\tbfq_clear_bfqq_just_created(bfqq);\n\t\t/*\n\t\t * rq is about to be enqueued into new_bfqq,\n\t\t * release rq reference on bfqq\n\t\t */\n\t\tbfq_put_queue(bfqq);\n\t\trq->elv.priv[1] = new_bfqq;\n\t\tbfqq = new_bfqq;\n\t}\n\n\tbfq_update_io_thinktime(bfqd, bfqq);\n\tbfq_update_has_short_ttime(bfqd, bfqq, RQ_BIC(rq));\n\tbfq_update_io_seektime(bfqd, bfqq, rq);\n\n\twaiting = bfqq && bfq_bfqq_wait_request(bfqq);\n\tbfq_add_request(rq);\n\tidle_timer_disabled = waiting && !bfq_bfqq_wait_request(bfqq);\n\n\trq->fifo_time = ktime_get_ns() + bfqd->bfq_fifo_expire[rq_is_sync(rq)];\n\tlist_add_tail(&rq->queuelist, &bfqq->fifo);\n\n\tbfq_rq_enqueued(bfqd, bfqq, rq);\n\n\treturn idle_timer_disabled;\n}\n\n#ifdef CONFIG_BFQ_CGROUP_DEBUG\nstatic void bfq_update_insert_stats(struct request_queue *q,\n\t\t\t\t    struct bfq_queue *bfqq,\n\t\t\t\t    bool idle_timer_disabled,\n\t\t\t\t    unsigned int cmd_flags)\n{\n\tif (!bfqq)\n\t\treturn;\n\n\t/*\n\t * bfqq still exists, because it can disappear only after\n\t * either it is merged with another queue, or the process it\n\t * is associated with exits. But both actions must be taken by\n\t * the same process currently executing this flow of\n\t * instructions.\n\t *\n\t * In addition, the following queue lock guarantees that\n\t * bfqq_group(bfqq) exists as well.\n\t */\n\tspin_lock_irq(&q->queue_lock);\n\tbfqg_stats_update_io_add(bfqq_group(bfqq), bfqq, cmd_flags);\n\tif (idle_timer_disabled)\n\t\tbfqg_stats_update_idle_time(bfqq_group(bfqq));\n\tspin_unlock_irq(&q->queue_lock);\n}\n#else\nstatic inline void bfq_update_insert_stats(struct request_queue *q,\n\t\t\t\t\t   struct bfq_queue *bfqq,\n\t\t\t\t\t   bool idle_timer_disabled,\n\t\t\t\t\t   unsigned int cmd_flags) {}\n#endif /* CONFIG_BFQ_CGROUP_DEBUG */\n\nstatic void bfq_insert_request(struct blk_mq_hw_ctx *hctx, struct request *rq,\n\t\t\t       bool at_head)\n{\n\tstruct request_queue *q = hctx->queue;\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\tstruct bfq_queue *bfqq;\n\tbool idle_timer_disabled = false;\n\tunsigned int cmd_flags;\n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\tif (!cgroup_subsys_on_dfl(io_cgrp_subsys) && rq->bio)\n\t\tbfqg_stats_update_legacy_io(q, rq);\n#endif\n\tspin_lock_irq(&bfqd->lock);\n\tif (blk_mq_sched_try_insert_merge(q, rq)) {\n\t\tspin_unlock_irq(&bfqd->lock);\n\t\treturn;\n\t}\n\n\tspin_unlock_irq(&bfqd->lock);\n\n\tblk_mq_sched_request_inserted(rq);\n\n\tspin_lock_irq(&bfqd->lock);\n\tbfqq = bfq_init_rq(rq);\n\tif (!bfqq || at_head || blk_rq_is_passthrough(rq)) {\n\t\tif (at_head)\n\t\t\tlist_add(&rq->queuelist, &bfqd->dispatch);\n\t\telse\n\t\t\tlist_add_tail(&rq->queuelist, &bfqd->dispatch);\n\t} else {\n\t\tidle_timer_disabled = __bfq_insert_request(bfqd, rq);\n\t\t/*\n\t\t * Update bfqq, because, if a queue merge has occurred\n\t\t * in __bfq_insert_request, then rq has been\n\t\t * redirected into a new queue.\n\t\t */\n\t\tbfqq = RQ_BFQQ(rq);\n\n\t\tif (rq_mergeable(rq)) {\n\t\t\telv_rqhash_add(q, rq);\n\t\t\tif (!q->last_merge)\n\t\t\t\tq->last_merge = rq;\n\t\t}\n\t}\n\n\t/*\n\t * Cache cmd_flags before releasing scheduler lock, because rq\n\t * may disappear afterwards (for example, because of a request\n\t * merge).\n\t */\n\tcmd_flags = rq->cmd_flags;\n\n\tspin_unlock_irq(&bfqd->lock);\n\n\tbfq_update_insert_stats(q, bfqq, idle_timer_disabled,\n\t\t\t\tcmd_flags);\n}\n\nstatic void bfq_insert_requests(struct blk_mq_hw_ctx *hctx,\n\t\t\t\tstruct list_head *list, bool at_head)\n{\n\twhile (!list_empty(list)) {\n\t\tstruct request *rq;\n\n\t\trq = list_first_entry(list, struct request, queuelist);\n\t\tlist_del_init(&rq->queuelist);\n\t\tbfq_insert_request(hctx, rq, at_head);\n\t\tatomic_inc(&hctx->elevator_queued);\n\t}\n}\n\nstatic void bfq_update_hw_tag(struct bfq_data *bfqd)\n{\n\tstruct bfq_queue *bfqq = bfqd->in_service_queue;\n\n\tbfqd->max_rq_in_driver = max_t(int, bfqd->max_rq_in_driver,\n\t\t\t\t       bfqd->rq_in_driver);\n\n\tif (bfqd->hw_tag == 1)\n\t\treturn;\n\n\t/*\n\t * This sample is valid if the number of outstanding requests\n\t * is large enough to allow a queueing behavior.  Note that the\n\t * sum is not exact, as it's not taking into account deactivated\n\t * requests.\n\t */\n\tif (bfqd->rq_in_driver + bfqd->queued <= BFQ_HW_QUEUE_THRESHOLD)\n\t\treturn;\n\n\t/*\n\t * If active queue hasn't enough requests and can idle, bfq might not\n\t * dispatch sufficient requests to hardware. Don't zero hw_tag in this\n\t * case\n\t */\n\tif (bfqq && bfq_bfqq_has_short_ttime(bfqq) &&\n\t    bfqq->dispatched + bfqq->queued[0] + bfqq->queued[1] <\n\t    BFQ_HW_QUEUE_THRESHOLD &&\n\t    bfqd->rq_in_driver < BFQ_HW_QUEUE_THRESHOLD)\n\t\treturn;\n\n\tif (bfqd->hw_tag_samples++ < BFQ_HW_QUEUE_SAMPLES)\n\t\treturn;\n\n\tbfqd->hw_tag = bfqd->max_rq_in_driver > BFQ_HW_QUEUE_THRESHOLD;\n\tbfqd->max_rq_in_driver = 0;\n\tbfqd->hw_tag_samples = 0;\n\n\tbfqd->nonrot_with_queueing =\n\t\tblk_queue_nonrot(bfqd->queue) && bfqd->hw_tag;\n}\n\nstatic void bfq_completed_request(struct bfq_queue *bfqq, struct bfq_data *bfqd)\n{\n\tu64 now_ns;\n\tu32 delta_us;\n\n\tbfq_update_hw_tag(bfqd);\n\n\tbfqd->rq_in_driver--;\n\tbfqq->dispatched--;\n\n\tif (!bfqq->dispatched && !bfq_bfqq_busy(bfqq)) {\n\t\t/*\n\t\t * Set budget_timeout (which we overload to store the\n\t\t * time at which the queue remains with no backlog and\n\t\t * no outstanding request; used by the weight-raising\n\t\t * mechanism).\n\t\t */\n\t\tbfqq->budget_timeout = jiffies;\n\n\t\tbfq_weights_tree_remove(bfqd, bfqq);\n\t}\n\n\tnow_ns = ktime_get_ns();\n\n\tbfqq->ttime.last_end_request = now_ns;\n\n\t/*\n\t * Using us instead of ns, to get a reasonable precision in\n\t * computing rate in next check.\n\t */\n\tdelta_us = div_u64(now_ns - bfqd->last_completion, NSEC_PER_USEC);\n\n\t/*\n\t * If the request took rather long to complete, and, according\n\t * to the maximum request size recorded, this completion latency\n\t * implies that the request was certainly served at a very low\n\t * rate (less than 1M sectors/sec), then the whole observation\n\t * interval that lasts up to this time instant cannot be a\n\t * valid time interval for computing a new peak rate.  Invoke\n\t * bfq_update_rate_reset to have the following three steps\n\t * taken:\n\t * - close the observation interval at the last (previous)\n\t *   request dispatch or completion\n\t * - compute rate, if possible, for that observation interval\n\t * - reset to zero samples, which will trigger a proper\n\t *   re-initialization of the observation interval on next\n\t *   dispatch\n\t */\n\tif (delta_us > BFQ_MIN_TT/NSEC_PER_USEC &&\n\t   (bfqd->last_rq_max_size<<BFQ_RATE_SHIFT)/delta_us <\n\t\t\t1UL<<(BFQ_RATE_SHIFT - 10))\n\t\tbfq_update_rate_reset(bfqd, NULL);\n\tbfqd->last_completion = now_ns;\n\tbfqd->last_completed_rq_bfqq = bfqq;\n\n\t/*\n\t * If we are waiting to discover whether the request pattern\n\t * of the task associated with the queue is actually\n\t * isochronous, and both requisites for this condition to hold\n\t * are now satisfied, then compute soft_rt_next_start (see the\n\t * comments on the function bfq_bfqq_softrt_next_start()). We\n\t * do not compute soft_rt_next_start if bfqq is in interactive\n\t * weight raising (see the comments in bfq_bfqq_expire() for\n\t * an explanation). We schedule this delayed update when bfqq\n\t * expires, if it still has in-flight requests.\n\t */\n\tif (bfq_bfqq_softrt_update(bfqq) && bfqq->dispatched == 0 &&\n\t    RB_EMPTY_ROOT(&bfqq->sort_list) &&\n\t    bfqq->wr_coeff != bfqd->bfq_wr_coeff)\n\t\tbfqq->soft_rt_next_start =\n\t\t\tbfq_bfqq_softrt_next_start(bfqd, bfqq);\n\n\t/*\n\t * If this is the in-service queue, check if it needs to be expired,\n\t * or if we want to idle in case it has no pending requests.\n\t */\n\tif (bfqd->in_service_queue == bfqq) {\n\t\tif (bfq_bfqq_must_idle(bfqq)) {\n\t\t\tif (bfqq->dispatched == 0)\n\t\t\t\tbfq_arm_slice_timer(bfqd);\n\t\t\t/*\n\t\t\t * If we get here, we do not expire bfqq, even\n\t\t\t * if bfqq was in budget timeout or had no\n\t\t\t * more requests (as controlled in the next\n\t\t\t * conditional instructions). The reason for\n\t\t\t * not expiring bfqq is as follows.\n\t\t\t *\n\t\t\t * Here bfqq->dispatched > 0 holds, but\n\t\t\t * bfq_bfqq_must_idle() returned true. This\n\t\t\t * implies that, even if no request arrives\n\t\t\t * for bfqq before bfqq->dispatched reaches 0,\n\t\t\t * bfqq will, however, not be expired on the\n\t\t\t * completion event that causes bfqq->dispatch\n\t\t\t * to reach zero. In contrast, on this event,\n\t\t\t * bfqq will start enjoying device idling\n\t\t\t * (I/O-dispatch plugging).\n\t\t\t *\n\t\t\t * But, if we expired bfqq here, bfqq would\n\t\t\t * not have the chance to enjoy device idling\n\t\t\t * when bfqq->dispatched finally reaches\n\t\t\t * zero. This would expose bfqq to violation\n\t\t\t * of its reserved service guarantees.\n\t\t\t */\n\t\t\treturn;\n\t\t} else if (bfq_may_expire_for_budg_timeout(bfqq))\n\t\t\tbfq_bfqq_expire(bfqd, bfqq, false,\n\t\t\t\t\tBFQQE_BUDGET_TIMEOUT);\n\t\telse if (RB_EMPTY_ROOT(&bfqq->sort_list) &&\n\t\t\t (bfqq->dispatched == 0 ||\n\t\t\t  !bfq_better_to_idle(bfqq)))\n\t\t\tbfq_bfqq_expire(bfqd, bfqq, false,\n\t\t\t\t\tBFQQE_NO_MORE_REQUESTS);\n\t}\n\n\tif (!bfqd->rq_in_driver)\n\t\tbfq_schedule_dispatch(bfqd);\n}\n\nstatic void bfq_finish_requeue_request_body(struct bfq_queue *bfqq)\n{\n\tbfqq->allocated--;\n\n\tbfq_put_queue(bfqq);\n}\n\n/*\n * The processes associated with bfqq may happen to generate their\n * cumulative I/O at a lower rate than the rate at which the device\n * could serve the same I/O. This is rather probable, e.g., if only\n * one process is associated with bfqq and the device is an SSD. It\n * results in bfqq becoming often empty while in service. In this\n * respect, if BFQ is allowed to switch to another queue when bfqq\n * remains empty, then the device goes on being fed with I/O requests,\n * and the throughput is not affected. In contrast, if BFQ is not\n * allowed to switch to another queue---because bfqq is sync and\n * I/O-dispatch needs to be plugged while bfqq is temporarily\n * empty---then, during the service of bfqq, there will be frequent\n * \"service holes\", i.e., time intervals during which bfqq gets empty\n * and the device can only consume the I/O already queued in its\n * hardware queues. During service holes, the device may even get to\n * remaining idle. In the end, during the service of bfqq, the device\n * is driven at a lower speed than the one it can reach with the kind\n * of I/O flowing through bfqq.\n *\n * To counter this loss of throughput, BFQ implements a \"request\n * injection mechanism\", which tries to fill the above service holes\n * with I/O requests taken from other queues. The hard part in this\n * mechanism is finding the right amount of I/O to inject, so as to\n * both boost throughput and not break bfqq's bandwidth and latency\n * guarantees. In this respect, the mechanism maintains a per-queue\n * inject limit, computed as below. While bfqq is empty, the injection\n * mechanism dispatches extra I/O requests only until the total number\n * of I/O requests in flight---i.e., already dispatched but not yet\n * completed---remains lower than this limit.\n *\n * A first definition comes in handy to introduce the algorithm by\n * which the inject limit is computed.  We define as first request for\n * bfqq, an I/O request for bfqq that arrives while bfqq is in\n * service, and causes bfqq to switch from empty to non-empty. The\n * algorithm updates the limit as a function of the effect of\n * injection on the service times of only the first requests of\n * bfqq. The reason for this restriction is that these are the\n * requests whose service time is affected most, because they are the\n * first to arrive after injection possibly occurred.\n *\n * To evaluate the effect of injection, the algorithm measures the\n * \"total service time\" of first requests. We define as total service\n * time of an I/O request, the time that elapses since when the\n * request is enqueued into bfqq, to when it is completed. This\n * quantity allows the whole effect of injection to be measured. It is\n * easy to see why. Suppose that some requests of other queues are\n * actually injected while bfqq is empty, and that a new request R\n * then arrives for bfqq. If the device does start to serve all or\n * part of the injected requests during the service hole, then,\n * because of this extra service, it may delay the next invocation of\n * the dispatch hook of BFQ. Then, even after R gets eventually\n * dispatched, the device may delay the actual service of R if it is\n * still busy serving the extra requests, or if it decides to serve,\n * before R, some extra request still present in its queues. As a\n * conclusion, the cumulative extra delay caused by injection can be\n * easily evaluated by just comparing the total service time of first\n * requests with and without injection.\n *\n * The limit-update algorithm works as follows. On the arrival of a\n * first request of bfqq, the algorithm measures the total time of the\n * request only if one of the three cases below holds, and, for each\n * case, it updates the limit as described below:\n *\n * (1) If there is no in-flight request. This gives a baseline for the\n *     total service time of the requests of bfqq. If the baseline has\n *     not been computed yet, then, after computing it, the limit is\n *     set to 1, to start boosting throughput, and to prepare the\n *     ground for the next case. If the baseline has already been\n *     computed, then it is updated, in case it results to be lower\n *     than the previous value.\n *\n * (2) If the limit is higher than 0 and there are in-flight\n *     requests. By comparing the total service time in this case with\n *     the above baseline, it is possible to know at which extent the\n *     current value of the limit is inflating the total service\n *     time. If the inflation is below a certain threshold, then bfqq\n *     is assumed to be suffering from no perceivable loss of its\n *     service guarantees, and the limit is even tentatively\n *     increased. If the inflation is above the threshold, then the\n *     limit is decreased. Due to the lack of any hysteresis, this\n *     logic makes the limit oscillate even in steady workload\n *     conditions. Yet we opted for it, because it is fast in reaching\n *     the best value for the limit, as a function of the current I/O\n *     workload. To reduce oscillations, this step is disabled for a\n *     short time interval after the limit happens to be decreased.\n *\n * (3) Periodically, after resetting the limit, to make sure that the\n *     limit eventually drops in case the workload changes. This is\n *     needed because, after the limit has gone safely up for a\n *     certain workload, it is impossible to guess whether the\n *     baseline total service time may have changed, without measuring\n *     it again without injection. A more effective version of this\n *     step might be to just sample the baseline, by interrupting\n *     injection only once, and then to reset/lower the limit only if\n *     the total service time with the current limit does happen to be\n *     too large.\n *\n * More details on each step are provided in the comments on the\n * pieces of code that implement these steps: the branch handling the\n * transition from empty to non empty in bfq_add_request(), the branch\n * handling injection in bfq_select_queue(), and the function\n * bfq_choose_bfqq_for_injection(). These comments also explain some\n * exceptions, made by the injection mechanism in some special cases.\n */\nstatic void bfq_update_inject_limit(struct bfq_data *bfqd,\n\t\t\t\t    struct bfq_queue *bfqq)\n{\n\tu64 tot_time_ns = ktime_get_ns() - bfqd->last_empty_occupied_ns;\n\tunsigned int old_limit = bfqq->inject_limit;\n\n\tif (bfqq->last_serv_time_ns > 0 && bfqd->rqs_injected) {\n\t\tu64 threshold = (bfqq->last_serv_time_ns * 3)>>1;\n\n\t\tif (tot_time_ns >= threshold && old_limit > 0) {\n\t\t\tbfqq->inject_limit--;\n\t\t\tbfqq->decrease_time_jif = jiffies;\n\t\t} else if (tot_time_ns < threshold &&\n\t\t\t   old_limit <= bfqd->max_rq_in_driver)\n\t\t\tbfqq->inject_limit++;\n\t}\n\n\t/*\n\t * Either we still have to compute the base value for the\n\t * total service time, and there seem to be the right\n\t * conditions to do it, or we can lower the last base value\n\t * computed.\n\t *\n\t * NOTE: (bfqd->rq_in_driver == 1) means that there is no I/O\n\t * request in flight, because this function is in the code\n\t * path that handles the completion of a request of bfqq, and,\n\t * in particular, this function is executed before\n\t * bfqd->rq_in_driver is decremented in such a code path.\n\t */\n\tif ((bfqq->last_serv_time_ns == 0 && bfqd->rq_in_driver == 1) ||\n\t    tot_time_ns < bfqq->last_serv_time_ns) {\n\t\tif (bfqq->last_serv_time_ns == 0) {\n\t\t\t/*\n\t\t\t * Now we certainly have a base value: make sure we\n\t\t\t * start trying injection.\n\t\t\t */\n\t\t\tbfqq->inject_limit = max_t(unsigned int, 1, old_limit);\n\t\t}\n\t\tbfqq->last_serv_time_ns = tot_time_ns;\n\t} else if (!bfqd->rqs_injected && bfqd->rq_in_driver == 1)\n\t\t/*\n\t\t * No I/O injected and no request still in service in\n\t\t * the drive: these are the exact conditions for\n\t\t * computing the base value of the total service time\n\t\t * for bfqq. So let's update this value, because it is\n\t\t * rather variable. For example, it varies if the size\n\t\t * or the spatial locality of the I/O requests in bfqq\n\t\t * change.\n\t\t */\n\t\tbfqq->last_serv_time_ns = tot_time_ns;\n\n\n\t/* update complete, not waiting for any request completion any longer */\n\tbfqd->waited_rq = NULL;\n\tbfqd->rqs_injected = false;\n}\n\n/*\n * Handle either a requeue or a finish for rq. The things to do are\n * the same in both cases: all references to rq are to be dropped. In\n * particular, rq is considered completed from the point of view of\n * the scheduler.\n */\nstatic void bfq_finish_requeue_request(struct request *rq)\n{\n\tstruct bfq_queue *bfqq = RQ_BFQQ(rq);\n\tstruct bfq_data *bfqd;\n\n\t/*\n\t * rq either is not associated with any icq, or is an already\n\t * requeued request that has not (yet) been re-inserted into\n\t * a bfq_queue.\n\t */\n\tif (!rq->elv.icq || !bfqq)\n\t\treturn;\n\n\tbfqd = bfqq->bfqd;\n\n\tif (rq->rq_flags & RQF_STARTED)\n\t\tbfqg_stats_update_completion(bfqq_group(bfqq),\n\t\t\t\t\t     rq->start_time_ns,\n\t\t\t\t\t     rq->io_start_time_ns,\n\t\t\t\t\t     rq->cmd_flags);\n\n\tif (likely(rq->rq_flags & RQF_STARTED)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&bfqd->lock, flags);\n\n\t\tif (rq == bfqd->waited_rq)\n\t\t\tbfq_update_inject_limit(bfqd, bfqq);\n\n\t\tbfq_completed_request(bfqq, bfqd);\n\t\tbfq_finish_requeue_request_body(bfqq);\n\t\tatomic_dec(&rq->mq_hctx->elevator_queued);\n\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t} else {\n\t\t/*\n\t\t * Request rq may be still/already in the scheduler,\n\t\t * in which case we need to remove it (this should\n\t\t * never happen in case of requeue). And we cannot\n\t\t * defer such a check and removal, to avoid\n\t\t * inconsistencies in the time interval from the end\n\t\t * of this function to the start of the deferred work.\n\t\t * This situation seems to occur only in process\n\t\t * context, as a consequence of a merge. In the\n\t\t * current version of the code, this implies that the\n\t\t * lock is held.\n\t\t */\n\n\t\tif (!RB_EMPTY_NODE(&rq->rb_node)) {\n\t\t\tbfq_remove_request(rq->q, rq);\n\t\t\tbfqg_stats_update_io_remove(bfqq_group(bfqq),\n\t\t\t\t\t\t    rq->cmd_flags);\n\t\t}\n\t\tbfq_finish_requeue_request_body(bfqq);\n\t}\n\n\t/*\n\t * Reset private fields. In case of a requeue, this allows\n\t * this function to correctly do nothing if it is spuriously\n\t * invoked again on this same request (see the check at the\n\t * beginning of the function). Probably, a better general\n\t * design would be to prevent blk-mq from invoking the requeue\n\t * or finish hooks of an elevator, for a request that is not\n\t * referred by that elevator.\n\t *\n\t * Resetting the following fields would break the\n\t * request-insertion logic if rq is re-inserted into a bfq\n\t * internal queue, without a re-preparation. Here we assume\n\t * that re-insertions of requeued requests, without\n\t * re-preparation, can happen only for pass_through or at_head\n\t * requests (which are not re-inserted into bfq internal\n\t * queues).\n\t */\n\trq->elv.priv[0] = NULL;\n\trq->elv.priv[1] = NULL;\n}\n\n/*\n * Removes the association between the current task and bfqq, assuming\n * that bic points to the bfq iocontext of the task.\n * Returns NULL if a new bfqq should be allocated, or the old bfqq if this\n * was the last process referring to that bfqq.\n */\nstatic struct bfq_queue *\nbfq_split_bfqq(struct bfq_io_cq *bic, struct bfq_queue *bfqq)\n{\n\tbfq_log_bfqq(bfqq->bfqd, bfqq, \"splitting queue\");\n\n\tif (bfqq_process_refs(bfqq) == 1) {\n\t\tbfqq->pid = current->pid;\n\t\tbfq_clear_bfqq_coop(bfqq);\n\t\tbfq_clear_bfqq_split_coop(bfqq);\n\t\treturn bfqq;\n\t}\n\n\tbic_set_bfqq(bic, NULL, 1);\n\n\tbfq_put_cooperator(bfqq);\n\n\tbfq_release_process_ref(bfqq->bfqd, bfqq);\n\treturn NULL;\n}\n\nstatic struct bfq_queue *bfq_get_bfqq_handle_split(struct bfq_data *bfqd,\n\t\t\t\t\t\t   struct bfq_io_cq *bic,\n\t\t\t\t\t\t   struct bio *bio,\n\t\t\t\t\t\t   bool split, bool is_sync,\n\t\t\t\t\t\t   bool *new_queue)\n{\n\tstruct bfq_queue *bfqq = bic_to_bfqq(bic, is_sync);\n\n\tif (likely(bfqq && bfqq != &bfqd->oom_bfqq))\n\t\treturn bfqq;\n\n\tif (new_queue)\n\t\t*new_queue = true;\n\n\tif (bfqq)\n\t\tbfq_put_queue(bfqq);\n\tbfqq = bfq_get_queue(bfqd, bio, is_sync, bic);\n\n\tbic_set_bfqq(bic, bfqq, is_sync);\n\tif (split && is_sync) {\n\t\tif ((bic->was_in_burst_list && bfqd->large_burst) ||\n\t\t    bic->saved_in_large_burst)\n\t\t\tbfq_mark_bfqq_in_large_burst(bfqq);\n\t\telse {\n\t\t\tbfq_clear_bfqq_in_large_burst(bfqq);\n\t\t\tif (bic->was_in_burst_list)\n\t\t\t\t/*\n\t\t\t\t * If bfqq was in the current\n\t\t\t\t * burst list before being\n\t\t\t\t * merged, then we have to add\n\t\t\t\t * it back. And we do not need\n\t\t\t\t * to increase burst_size, as\n\t\t\t\t * we did not decrement\n\t\t\t\t * burst_size when we removed\n\t\t\t\t * bfqq from the burst list as\n\t\t\t\t * a consequence of a merge\n\t\t\t\t * (see comments in\n\t\t\t\t * bfq_put_queue). In this\n\t\t\t\t * respect, it would be rather\n\t\t\t\t * costly to know whether the\n\t\t\t\t * current burst list is still\n\t\t\t\t * the same burst list from\n\t\t\t\t * which bfqq was removed on\n\t\t\t\t * the merge. To avoid this\n\t\t\t\t * cost, if bfqq was in a\n\t\t\t\t * burst list, then we add\n\t\t\t\t * bfqq to the current burst\n\t\t\t\t * list without any further\n\t\t\t\t * check. This can cause\n\t\t\t\t * inappropriate insertions,\n\t\t\t\t * but rarely enough to not\n\t\t\t\t * harm the detection of large\n\t\t\t\t * bursts significantly.\n\t\t\t\t */\n\t\t\t\thlist_add_head(&bfqq->burst_list_node,\n\t\t\t\t\t       &bfqd->burst_list);\n\t\t}\n\t\tbfqq->split_time = jiffies;\n\t}\n\n\treturn bfqq;\n}\n\n/*\n * Only reset private fields. The actual request preparation will be\n * performed by bfq_init_rq, when rq is either inserted or merged. See\n * comments on bfq_init_rq for the reason behind this delayed\n * preparation.\n */\nstatic void bfq_prepare_request(struct request *rq)\n{\n\t/*\n\t * Regardless of whether we have an icq attached, we have to\n\t * clear the scheduler pointers, as they might point to\n\t * previously allocated bic/bfqq structs.\n\t */\n\trq->elv.priv[0] = rq->elv.priv[1] = NULL;\n}\n\n/*\n * If needed, init rq, allocate bfq data structures associated with\n * rq, and increment reference counters in the destination bfq_queue\n * for rq. Return the destination bfq_queue for rq, or NULL is rq is\n * not associated with any bfq_queue.\n *\n * This function is invoked by the functions that perform rq insertion\n * or merging. One may have expected the above preparation operations\n * to be performed in bfq_prepare_request, and not delayed to when rq\n * is inserted or merged. The rationale behind this delayed\n * preparation is that, after the prepare_request hook is invoked for\n * rq, rq may still be transformed into a request with no icq, i.e., a\n * request not associated with any queue. No bfq hook is invoked to\n * signal this transformation. As a consequence, should these\n * preparation operations be performed when the prepare_request hook\n * is invoked, and should rq be transformed one moment later, bfq\n * would end up in an inconsistent state, because it would have\n * incremented some queue counters for an rq destined to\n * transformation, without any chance to correctly lower these\n * counters back. In contrast, no transformation can still happen for\n * rq after rq has been inserted or merged. So, it is safe to execute\n * these preparation operations when rq is finally inserted or merged.\n */\nstatic struct bfq_queue *bfq_init_rq(struct request *rq)\n{\n\tstruct request_queue *q = rq->q;\n\tstruct bio *bio = rq->bio;\n\tstruct bfq_data *bfqd = q->elevator->elevator_data;\n\tstruct bfq_io_cq *bic;\n\tconst int is_sync = rq_is_sync(rq);\n\tstruct bfq_queue *bfqq;\n\tbool new_queue = false;\n\tbool bfqq_already_existing = false, split = false;\n\n\tif (unlikely(!rq->elv.icq))\n\t\treturn NULL;\n\n\t/*\n\t * Assuming that elv.priv[1] is set only if everything is set\n\t * for this rq. This holds true, because this function is\n\t * invoked only for insertion or merging, and, after such\n\t * events, a request cannot be manipulated any longer before\n\t * being removed from bfq.\n\t */\n\tif (rq->elv.priv[1])\n\t\treturn rq->elv.priv[1];\n\n\tbic = icq_to_bic(rq->elv.icq);\n\n\tbfq_check_ioprio_change(bic, bio);\n\n\tbfq_bic_update_cgroup(bic, bio);\n\n\tbfqq = bfq_get_bfqq_handle_split(bfqd, bic, bio, false, is_sync,\n\t\t\t\t\t &new_queue);\n\n\tif (likely(!new_queue)) {\n\t\t/* If the queue was seeky for too long, break it apart. */\n\t\tif (bfq_bfqq_coop(bfqq) && bfq_bfqq_split_coop(bfqq)) {\n\t\t\tbfq_log_bfqq(bfqd, bfqq, \"breaking apart bfqq\");\n\n\t\t\t/* Update bic before losing reference to bfqq */\n\t\t\tif (bfq_bfqq_in_large_burst(bfqq))\n\t\t\t\tbic->saved_in_large_burst = true;\n\n\t\t\tbfqq = bfq_split_bfqq(bic, bfqq);\n\t\t\tsplit = true;\n\n\t\t\tif (!bfqq)\n\t\t\t\tbfqq = bfq_get_bfqq_handle_split(bfqd, bic, bio,\n\t\t\t\t\t\t\t\t true, is_sync,\n\t\t\t\t\t\t\t\t NULL);\n\t\t\telse\n\t\t\t\tbfqq_already_existing = true;\n\t\t}\n\t}\n\n\tbfqq->allocated++;\n\tbfqq->ref++;\n\tbfq_log_bfqq(bfqd, bfqq, \"get_request %p: bfqq %p, %d\",\n\t\t     rq, bfqq, bfqq->ref);\n\n\trq->elv.priv[0] = bic;\n\trq->elv.priv[1] = bfqq;\n\n\t/*\n\t * If a bfq_queue has only one process reference, it is owned\n\t * by only this bic: we can then set bfqq->bic = bic. in\n\t * addition, if the queue has also just been split, we have to\n\t * resume its state.\n\t */\n\tif (likely(bfqq != &bfqd->oom_bfqq) && bfqq_process_refs(bfqq) == 1) {\n\t\tbfqq->bic = bic;\n\t\tif (split) {\n\t\t\t/*\n\t\t\t * The queue has just been split from a shared\n\t\t\t * queue: restore the idle window and the\n\t\t\t * possible weight raising period.\n\t\t\t */\n\t\t\tbfq_bfqq_resume_state(bfqq, bfqd, bic,\n\t\t\t\t\t      bfqq_already_existing);\n\t\t}\n\t}\n\n\t/*\n\t * Consider bfqq as possibly belonging to a burst of newly\n\t * created queues only if:\n\t * 1) A burst is actually happening (bfqd->burst_size > 0)\n\t * or\n\t * 2) There is no other active queue. In fact, if, in\n\t *    contrast, there are active queues not belonging to the\n\t *    possible burst bfqq may belong to, then there is no gain\n\t *    in considering bfqq as belonging to a burst, and\n\t *    therefore in not weight-raising bfqq. See comments on\n\t *    bfq_handle_burst().\n\t *\n\t * This filtering also helps eliminating false positives,\n\t * occurring when bfqq does not belong to an actual large\n\t * burst, but some background task (e.g., a service) happens\n\t * to trigger the creation of new queues very close to when\n\t * bfqq and its possible companion queues are created. See\n\t * comments on bfq_handle_burst() for further details also on\n\t * this issue.\n\t */\n\tif (unlikely(bfq_bfqq_just_created(bfqq) &&\n\t\t     (bfqd->burst_size > 0 ||\n\t\t      bfq_tot_busy_queues(bfqd) == 0)))\n\t\tbfq_handle_burst(bfqd, bfqq);\n\n\treturn bfqq;\n}\n\nstatic void\nbfq_idle_slice_timer_body(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\n\t/*\n\t * Considering that bfqq may be in race, we should firstly check\n\t * whether bfqq is in service before doing something on it. If\n\t * the bfqq in race is not in service, it has already been expired\n\t * through __bfq_bfqq_expire func and its wait_request flags has\n\t * been cleared in __bfq_bfqd_reset_in_service func.\n\t */\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\n\tbfq_clear_bfqq_wait_request(bfqq);\n\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\t/*\n\t\t * Also here the queue can be safely expired\n\t\t * for budget timeout without wasting\n\t\t * guarantees\n\t\t */\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\t/*\n\t\t * The queue may not be empty upon timer expiration,\n\t\t * because we may not disable the timer when the\n\t\t * first request of the in-service queue arrives\n\t\t * during disk idling.\n\t\t */\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\n\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);\n}\n\n/*\n * Handler of the expiration of the timer running if the in-service queue\n * is idling inside its time slice.\n */\nstatic enum hrtimer_restart bfq_idle_slice_timer(struct hrtimer *timer)\n{\n\tstruct bfq_data *bfqd = container_of(timer, struct bfq_data,\n\t\t\t\t\t     idle_slice_timer);\n\tstruct bfq_queue *bfqq = bfqd->in_service_queue;\n\n\t/*\n\t * Theoretical race here: the in-service queue can be NULL or\n\t * different from the queue that was idling if a new request\n\t * arrives for the current queue and there is a full dispatch\n\t * cycle that changes the in-service queue.  This can hardly\n\t * happen, but in the worst case we just expire a queue too\n\t * early.\n\t */\n\tif (bfqq)\n\t\tbfq_idle_slice_timer_body(bfqd, bfqq);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic void __bfq_put_async_bfqq(struct bfq_data *bfqd,\n\t\t\t\t struct bfq_queue **bfqq_ptr)\n{\n\tstruct bfq_queue *bfqq = *bfqq_ptr;\n\n\tbfq_log(bfqd, \"put_async_bfqq: %p\", bfqq);\n\tif (bfqq) {\n\t\tbfq_bfqq_move(bfqd, bfqq, bfqd->root_group);\n\n\t\tbfq_log_bfqq(bfqd, bfqq, \"put_async_bfqq: putting %p, %d\",\n\t\t\t     bfqq, bfqq->ref);\n\t\tbfq_put_queue(bfqq);\n\t\t*bfqq_ptr = NULL;\n\t}\n}\n\n/*\n * Release all the bfqg references to its async queues.  If we are\n * deallocating the group these queues may still contain requests, so\n * we reparent them to the root cgroup (i.e., the only one that will\n * exist for sure until all the requests on a device are gone).\n */\nvoid bfq_put_async_queues(struct bfq_data *bfqd, struct bfq_group *bfqg)\n{\n\tint i, j;\n\n\tfor (i = 0; i < 2; i++)\n\t\tfor (j = 0; j < IOPRIO_BE_NR; j++)\n\t\t\t__bfq_put_async_bfqq(bfqd, &bfqg->async_bfqq[i][j]);\n\n\t__bfq_put_async_bfqq(bfqd, &bfqg->async_idle_bfqq);\n}\n\n/*\n * See the comments on bfq_limit_depth for the purpose of\n * the depths set in the function. Return minimum shallow depth we'll use.\n */\nstatic unsigned int bfq_update_depths(struct bfq_data *bfqd,\n\t\t\t\t      struct sbitmap_queue *bt)\n{\n\tunsigned int i, j, min_shallow = UINT_MAX;\n\n\t/*\n\t * In-word depths if no bfq_queue is being weight-raised:\n\t * leaving 25% of tags only for sync reads.\n\t *\n\t * In next formulas, right-shift the value\n\t * (1U<<bt->sb.shift), instead of computing directly\n\t * (1U<<(bt->sb.shift - something)), to be robust against\n\t * any possible value of bt->sb.shift, without having to\n\t * limit 'something'.\n\t */\n\t/* no more than 50% of tags for async I/O */\n\tbfqd->word_depths[0][0] = max((1U << bt->sb.shift) >> 1, 1U);\n\t/*\n\t * no more than 75% of tags for sync writes (25% extra tags\n\t * w.r.t. async I/O, to prevent async I/O from starving sync\n\t * writes)\n\t */\n\tbfqd->word_depths[0][1] = max(((1U << bt->sb.shift) * 3) >> 2, 1U);\n\n\t/*\n\t * In-word depths in case some bfq_queue is being weight-\n\t * raised: leaving ~63% of tags for sync reads. This is the\n\t * highest percentage for which, in our tests, application\n\t * start-up times didn't suffer from any regression due to tag\n\t * shortage.\n\t */\n\t/* no more than ~18% of tags for async I/O */\n\tbfqd->word_depths[1][0] = max(((1U << bt->sb.shift) * 3) >> 4, 1U);\n\t/* no more than ~37% of tags for sync writes (~20% extra tags) */\n\tbfqd->word_depths[1][1] = max(((1U << bt->sb.shift) * 6) >> 4, 1U);\n\n\tfor (i = 0; i < 2; i++)\n\t\tfor (j = 0; j < 2; j++)\n\t\t\tmin_shallow = min(min_shallow, bfqd->word_depths[i][j]);\n\n\treturn min_shallow;\n}\n\nstatic void bfq_depth_updated(struct blk_mq_hw_ctx *hctx)\n{\n\tstruct bfq_data *bfqd = hctx->queue->elevator->elevator_data;\n\tstruct blk_mq_tags *tags = hctx->sched_tags;\n\tunsigned int min_shallow;\n\n\tmin_shallow = bfq_update_depths(bfqd, tags->bitmap_tags);\n\tsbitmap_queue_min_shallow_depth(tags->bitmap_tags, min_shallow);\n}\n\nstatic int bfq_init_hctx(struct blk_mq_hw_ctx *hctx, unsigned int index)\n{\n\tbfq_depth_updated(hctx);\n\treturn 0;\n}\n\nstatic void bfq_exit_queue(struct elevator_queue *e)\n{\n\tstruct bfq_data *bfqd = e->elevator_data;\n\tstruct bfq_queue *bfqq, *n;\n\n\thrtimer_cancel(&bfqd->idle_slice_timer);\n\n\tspin_lock_irq(&bfqd->lock);\n\tlist_for_each_entry_safe(bfqq, n, &bfqd->idle_list, bfqq_list)\n\t\tbfq_deactivate_bfqq(bfqd, bfqq, false, false);\n\tspin_unlock_irq(&bfqd->lock);\n\n\thrtimer_cancel(&bfqd->idle_slice_timer);\n\n\t/* release oom-queue reference to root group */\n\tbfqg_and_blkg_put(bfqd->root_group);\n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\tblkcg_deactivate_policy(bfqd->queue, &blkcg_policy_bfq);\n#else\n\tspin_lock_irq(&bfqd->lock);\n\tbfq_put_async_queues(bfqd, bfqd->root_group);\n\tkfree(bfqd->root_group);\n\tspin_unlock_irq(&bfqd->lock);\n#endif\n\n\tkfree(bfqd);\n}\n\nstatic void bfq_init_root_group(struct bfq_group *root_group,\n\t\t\t\tstruct bfq_data *bfqd)\n{\n\tint i;\n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\troot_group->entity.parent = NULL;\n\troot_group->my_entity = NULL;\n\troot_group->bfqd = bfqd;\n#endif\n\troot_group->rq_pos_tree = RB_ROOT;\n\tfor (i = 0; i < BFQ_IOPRIO_CLASSES; i++)\n\t\troot_group->sched_data.service_tree[i] = BFQ_SERVICE_TREE_INIT;\n\troot_group->sched_data.bfq_class_idle_last_service = jiffies;\n}\n\nstatic int bfq_init_queue(struct request_queue *q, struct elevator_type *e)\n{\n\tstruct bfq_data *bfqd;\n\tstruct elevator_queue *eq;\n\n\teq = elevator_alloc(q, e);\n\tif (!eq)\n\t\treturn -ENOMEM;\n\n\tbfqd = kzalloc_node(sizeof(*bfqd), GFP_KERNEL, q->node);\n\tif (!bfqd) {\n\t\tkobject_put(&eq->kobj);\n\t\treturn -ENOMEM;\n\t}\n\teq->elevator_data = bfqd;\n\n\tspin_lock_irq(&q->queue_lock);\n\tq->elevator = eq;\n\tspin_unlock_irq(&q->queue_lock);\n\n\t/*\n\t * Our fallback bfqq if bfq_find_alloc_queue() runs into OOM issues.\n\t * Grab a permanent reference to it, so that the normal code flow\n\t * will not attempt to free it.\n\t */\n\tbfq_init_bfqq(bfqd, &bfqd->oom_bfqq, NULL, 1, 0);\n\tbfqd->oom_bfqq.ref++;\n\tbfqd->oom_bfqq.new_ioprio = BFQ_DEFAULT_QUEUE_IOPRIO;\n\tbfqd->oom_bfqq.new_ioprio_class = IOPRIO_CLASS_BE;\n\tbfqd->oom_bfqq.entity.new_weight =\n\t\tbfq_ioprio_to_weight(bfqd->oom_bfqq.new_ioprio);\n\n\t/* oom_bfqq does not participate to bursts */\n\tbfq_clear_bfqq_just_created(&bfqd->oom_bfqq);\n\n\t/*\n\t * Trigger weight initialization, according to ioprio, at the\n\t * oom_bfqq's first activation. The oom_bfqq's ioprio and ioprio\n\t * class won't be changed any more.\n\t */\n\tbfqd->oom_bfqq.entity.prio_changed = 1;\n\n\tbfqd->queue = q;\n\n\tINIT_LIST_HEAD(&bfqd->dispatch);\n\n\thrtimer_init(&bfqd->idle_slice_timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_REL);\n\tbfqd->idle_slice_timer.function = bfq_idle_slice_timer;\n\n\tbfqd->queue_weights_tree = RB_ROOT_CACHED;\n\tbfqd->num_groups_with_pending_reqs = 0;\n\n\tINIT_LIST_HEAD(&bfqd->active_list);\n\tINIT_LIST_HEAD(&bfqd->idle_list);\n\tINIT_HLIST_HEAD(&bfqd->burst_list);\n\n\tbfqd->hw_tag = -1;\n\tbfqd->nonrot_with_queueing = blk_queue_nonrot(bfqd->queue);\n\n\tbfqd->bfq_max_budget = bfq_default_max_budget;\n\n\tbfqd->bfq_fifo_expire[0] = bfq_fifo_expire[0];\n\tbfqd->bfq_fifo_expire[1] = bfq_fifo_expire[1];\n\tbfqd->bfq_back_max = bfq_back_max;\n\tbfqd->bfq_back_penalty = bfq_back_penalty;\n\tbfqd->bfq_slice_idle = bfq_slice_idle;\n\tbfqd->bfq_timeout = bfq_timeout;\n\n\tbfqd->bfq_requests_within_timer = 120;\n\n\tbfqd->bfq_large_burst_thresh = 8;\n\tbfqd->bfq_burst_interval = msecs_to_jiffies(180);\n\n\tbfqd->low_latency = true;\n\n\t/*\n\t * Trade-off between responsiveness and fairness.\n\t */\n\tbfqd->bfq_wr_coeff = 30;\n\tbfqd->bfq_wr_rt_max_time = msecs_to_jiffies(300);\n\tbfqd->bfq_wr_max_time = 0;\n\tbfqd->bfq_wr_min_idle_time = msecs_to_jiffies(2000);\n\tbfqd->bfq_wr_min_inter_arr_async = msecs_to_jiffies(500);\n\tbfqd->bfq_wr_max_softrt_rate = 7000; /*\n\t\t\t\t\t      * Approximate rate required\n\t\t\t\t\t      * to playback or record a\n\t\t\t\t\t      * high-definition compressed\n\t\t\t\t\t      * video.\n\t\t\t\t\t      */\n\tbfqd->wr_busy_queues = 0;\n\n\t/*\n\t * Begin by assuming, optimistically, that the device peak\n\t * rate is equal to 2/3 of the highest reference rate.\n\t */\n\tbfqd->rate_dur_prod = ref_rate[blk_queue_nonrot(bfqd->queue)] *\n\t\tref_wr_duration[blk_queue_nonrot(bfqd->queue)];\n\tbfqd->peak_rate = ref_rate[blk_queue_nonrot(bfqd->queue)] * 2 / 3;\n\n\tspin_lock_init(&bfqd->lock);\n\n\t/*\n\t * The invocation of the next bfq_create_group_hierarchy\n\t * function is the head of a chain of function calls\n\t * (bfq_create_group_hierarchy->blkcg_activate_policy->\n\t * blk_mq_freeze_queue) that may lead to the invocation of the\n\t * has_work hook function. For this reason,\n\t * bfq_create_group_hierarchy is invoked only after all\n\t * scheduler data has been initialized, apart from the fields\n\t * that can be initialized only after invoking\n\t * bfq_create_group_hierarchy. This, in particular, enables\n\t * has_work to correctly return false. Of course, to avoid\n\t * other inconsistencies, the blk-mq stack must then refrain\n\t * from invoking further scheduler hooks before this init\n\t * function is finished.\n\t */\n\tbfqd->root_group = bfq_create_group_hierarchy(bfqd, q->node);\n\tif (!bfqd->root_group)\n\t\tgoto out_free;\n\tbfq_init_root_group(bfqd->root_group, bfqd);\n\tbfq_init_entity(&bfqd->oom_bfqq.entity, bfqd->root_group);\n\n\twbt_disable_default(q);\n\treturn 0;\n\nout_free:\n\tkfree(bfqd);\n\tkobject_put(&eq->kobj);\n\treturn -ENOMEM;\n}\n\nstatic void bfq_slab_kill(void)\n{\n\tkmem_cache_destroy(bfq_pool);\n}\n\nstatic int __init bfq_slab_setup(void)\n{\n\tbfq_pool = KMEM_CACHE(bfq_queue, 0);\n\tif (!bfq_pool)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic ssize_t bfq_var_show(unsigned int var, char *page)\n{\n\treturn sprintf(page, \"%u\\n\", var);\n}\n\nstatic int bfq_var_store(unsigned long *var, const char *page)\n{\n\tunsigned long new_val;\n\tint ret = kstrtoul(page, 10, &new_val);\n\n\tif (ret)\n\t\treturn ret;\n\t*var = new_val;\n\treturn 0;\n}\n\n#define SHOW_FUNCTION(__FUNC, __VAR, __CONV)\t\t\t\t\\\nstatic ssize_t __FUNC(struct elevator_queue *e, char *page)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bfq_data *bfqd = e->elevator_data;\t\t\t\\\n\tu64 __data = __VAR;\t\t\t\t\t\t\\\n\tif (__CONV == 1)\t\t\t\t\t\t\\\n\t\t__data = jiffies_to_msecs(__data);\t\t\t\\\n\telse if (__CONV == 2)\t\t\t\t\t\t\\\n\t\t__data = div_u64(__data, NSEC_PER_MSEC);\t\t\\\n\treturn bfq_var_show(__data, (page));\t\t\t\t\\\n}\nSHOW_FUNCTION(bfq_fifo_expire_sync_show, bfqd->bfq_fifo_expire[1], 2);\nSHOW_FUNCTION(bfq_fifo_expire_async_show, bfqd->bfq_fifo_expire[0], 2);\nSHOW_FUNCTION(bfq_back_seek_max_show, bfqd->bfq_back_max, 0);\nSHOW_FUNCTION(bfq_back_seek_penalty_show, bfqd->bfq_back_penalty, 0);\nSHOW_FUNCTION(bfq_slice_idle_show, bfqd->bfq_slice_idle, 2);\nSHOW_FUNCTION(bfq_max_budget_show, bfqd->bfq_user_max_budget, 0);\nSHOW_FUNCTION(bfq_timeout_sync_show, bfqd->bfq_timeout, 1);\nSHOW_FUNCTION(bfq_strict_guarantees_show, bfqd->strict_guarantees, 0);\nSHOW_FUNCTION(bfq_low_latency_show, bfqd->low_latency, 0);\n#undef SHOW_FUNCTION\n\n#define USEC_SHOW_FUNCTION(__FUNC, __VAR)\t\t\t\t\\\nstatic ssize_t __FUNC(struct elevator_queue *e, char *page)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bfq_data *bfqd = e->elevator_data;\t\t\t\\\n\tu64 __data = __VAR;\t\t\t\t\t\t\\\n\t__data = div_u64(__data, NSEC_PER_USEC);\t\t\t\\\n\treturn bfq_var_show(__data, (page));\t\t\t\t\\\n}\nUSEC_SHOW_FUNCTION(bfq_slice_idle_us_show, bfqd->bfq_slice_idle);\n#undef USEC_SHOW_FUNCTION\n\n#define STORE_FUNCTION(__FUNC, __PTR, MIN, MAX, __CONV)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\n__FUNC(struct elevator_queue *e, const char *page, size_t count)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bfq_data *bfqd = e->elevator_data;\t\t\t\\\n\tunsigned long __data, __min = (MIN), __max = (MAX);\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = bfq_var_store(&__data, (page));\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\tif (__data < __min)\t\t\t\t\t\t\\\n\t\t__data = __min;\t\t\t\t\t\t\\\n\telse if (__data > __max)\t\t\t\t\t\\\n\t\t__data = __max;\t\t\t\t\t\t\\\n\tif (__CONV == 1)\t\t\t\t\t\t\\\n\t\t*(__PTR) = msecs_to_jiffies(__data);\t\t\t\\\n\telse if (__CONV == 2)\t\t\t\t\t\t\\\n\t\t*(__PTR) = (u64)__data * NSEC_PER_MSEC;\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t*(__PTR) = __data;\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\nSTORE_FUNCTION(bfq_fifo_expire_sync_store, &bfqd->bfq_fifo_expire[1], 1,\n\t\tINT_MAX, 2);\nSTORE_FUNCTION(bfq_fifo_expire_async_store, &bfqd->bfq_fifo_expire[0], 1,\n\t\tINT_MAX, 2);\nSTORE_FUNCTION(bfq_back_seek_max_store, &bfqd->bfq_back_max, 0, INT_MAX, 0);\nSTORE_FUNCTION(bfq_back_seek_penalty_store, &bfqd->bfq_back_penalty, 1,\n\t\tINT_MAX, 0);\nSTORE_FUNCTION(bfq_slice_idle_store, &bfqd->bfq_slice_idle, 0, INT_MAX, 2);\n#undef STORE_FUNCTION\n\n#define USEC_STORE_FUNCTION(__FUNC, __PTR, MIN, MAX)\t\t\t\\\nstatic ssize_t __FUNC(struct elevator_queue *e, const char *page, size_t count)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct bfq_data *bfqd = e->elevator_data;\t\t\t\\\n\tunsigned long __data, __min = (MIN), __max = (MAX);\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = bfq_var_store(&__data, (page));\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\tif (__data < __min)\t\t\t\t\t\t\\\n\t\t__data = __min;\t\t\t\t\t\t\\\n\telse if (__data > __max)\t\t\t\t\t\\\n\t\t__data = __max;\t\t\t\t\t\t\\\n\t*(__PTR) = (u64)__data * NSEC_PER_USEC;\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\nUSEC_STORE_FUNCTION(bfq_slice_idle_us_store, &bfqd->bfq_slice_idle, 0,\n\t\t    UINT_MAX);\n#undef USEC_STORE_FUNCTION\n\nstatic ssize_t bfq_max_budget_store(struct elevator_queue *e,\n\t\t\t\t    const char *page, size_t count)\n{\n\tstruct bfq_data *bfqd = e->elevator_data;\n\tunsigned long __data;\n\tint ret;\n\n\tret = bfq_var_store(&__data, (page));\n\tif (ret)\n\t\treturn ret;\n\n\tif (__data == 0)\n\t\tbfqd->bfq_max_budget = bfq_calc_max_budget(bfqd);\n\telse {\n\t\tif (__data > INT_MAX)\n\t\t\t__data = INT_MAX;\n\t\tbfqd->bfq_max_budget = __data;\n\t}\n\n\tbfqd->bfq_user_max_budget = __data;\n\n\treturn count;\n}\n\n/*\n * Leaving this name to preserve name compatibility with cfq\n * parameters, but this timeout is used for both sync and async.\n */\nstatic ssize_t bfq_timeout_sync_store(struct elevator_queue *e,\n\t\t\t\t      const char *page, size_t count)\n{\n\tstruct bfq_data *bfqd = e->elevator_data;\n\tunsigned long __data;\n\tint ret;\n\n\tret = bfq_var_store(&__data, (page));\n\tif (ret)\n\t\treturn ret;\n\n\tif (__data < 1)\n\t\t__data = 1;\n\telse if (__data > INT_MAX)\n\t\t__data = INT_MAX;\n\n\tbfqd->bfq_timeout = msecs_to_jiffies(__data);\n\tif (bfqd->bfq_user_max_budget == 0)\n\t\tbfqd->bfq_max_budget = bfq_calc_max_budget(bfqd);\n\n\treturn count;\n}\n\nstatic ssize_t bfq_strict_guarantees_store(struct elevator_queue *e,\n\t\t\t\t     const char *page, size_t count)\n{\n\tstruct bfq_data *bfqd = e->elevator_data;\n\tunsigned long __data;\n\tint ret;\n\n\tret = bfq_var_store(&__data, (page));\n\tif (ret)\n\t\treturn ret;\n\n\tif (__data > 1)\n\t\t__data = 1;\n\tif (!bfqd->strict_guarantees && __data == 1\n\t    && bfqd->bfq_slice_idle < 8 * NSEC_PER_MSEC)\n\t\tbfqd->bfq_slice_idle = 8 * NSEC_PER_MSEC;\n\n\tbfqd->strict_guarantees = __data;\n\n\treturn count;\n}\n\nstatic ssize_t bfq_low_latency_store(struct elevator_queue *e,\n\t\t\t\t     const char *page, size_t count)\n{\n\tstruct bfq_data *bfqd = e->elevator_data;\n\tunsigned long __data;\n\tint ret;\n\n\tret = bfq_var_store(&__data, (page));\n\tif (ret)\n\t\treturn ret;\n\n\tif (__data > 1)\n\t\t__data = 1;\n\tif (__data == 0 && bfqd->low_latency != 0)\n\t\tbfq_end_wr(bfqd);\n\tbfqd->low_latency = __data;\n\n\treturn count;\n}\n\n#define BFQ_ATTR(name) \\\n\t__ATTR(name, 0644, bfq_##name##_show, bfq_##name##_store)\n\nstatic struct elv_fs_entry bfq_attrs[] = {\n\tBFQ_ATTR(fifo_expire_sync),\n\tBFQ_ATTR(fifo_expire_async),\n\tBFQ_ATTR(back_seek_max),\n\tBFQ_ATTR(back_seek_penalty),\n\tBFQ_ATTR(slice_idle),\n\tBFQ_ATTR(slice_idle_us),\n\tBFQ_ATTR(max_budget),\n\tBFQ_ATTR(timeout_sync),\n\tBFQ_ATTR(strict_guarantees),\n\tBFQ_ATTR(low_latency),\n\t__ATTR_NULL\n};\n\nstatic struct elevator_type iosched_bfq_mq = {\n\t.ops = {\n\t\t.limit_depth\t\t= bfq_limit_depth,\n\t\t.prepare_request\t= bfq_prepare_request,\n\t\t.requeue_request        = bfq_finish_requeue_request,\n\t\t.finish_request\t\t= bfq_finish_requeue_request,\n\t\t.exit_icq\t\t= bfq_exit_icq,\n\t\t.insert_requests\t= bfq_insert_requests,\n\t\t.dispatch_request\t= bfq_dispatch_request,\n\t\t.next_request\t\t= elv_rb_latter_request,\n\t\t.former_request\t\t= elv_rb_former_request,\n\t\t.allow_merge\t\t= bfq_allow_bio_merge,\n\t\t.bio_merge\t\t= bfq_bio_merge,\n\t\t.request_merge\t\t= bfq_request_merge,\n\t\t.requests_merged\t= bfq_requests_merged,\n\t\t.request_merged\t\t= bfq_request_merged,\n\t\t.has_work\t\t= bfq_has_work,\n\t\t.depth_updated\t\t= bfq_depth_updated,\n\t\t.init_hctx\t\t= bfq_init_hctx,\n\t\t.init_sched\t\t= bfq_init_queue,\n\t\t.exit_sched\t\t= bfq_exit_queue,\n\t},\n\n\t.icq_size =\t\tsizeof(struct bfq_io_cq),\n\t.icq_align =\t\t__alignof__(struct bfq_io_cq),\n\t.elevator_attrs =\tbfq_attrs,\n\t.elevator_name =\t\"bfq\",\n\t.elevator_owner =\tTHIS_MODULE,\n};\nMODULE_ALIAS(\"bfq-iosched\");\n\nstatic int __init bfq_init(void)\n{\n\tint ret;\n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\tret = blkcg_policy_register(&blkcg_policy_bfq);\n\tif (ret)\n\t\treturn ret;\n#endif\n\n\tret = -ENOMEM;\n\tif (bfq_slab_setup())\n\t\tgoto err_pol_unreg;\n\n\t/*\n\t * Times to load large popular applications for the typical\n\t * systems installed on the reference devices (see the\n\t * comments before the definition of the next\n\t * array). Actually, we use slightly lower values, as the\n\t * estimated peak rate tends to be smaller than the actual\n\t * peak rate.  The reason for this last fact is that estimates\n\t * are computed over much shorter time intervals than the long\n\t * intervals typically used for benchmarking. Why? First, to\n\t * adapt more quickly to variations. Second, because an I/O\n\t * scheduler cannot rely on a peak-rate-evaluation workload to\n\t * be run for a long time.\n\t */\n\tref_wr_duration[0] = msecs_to_jiffies(7000); /* actually 8 sec */\n\tref_wr_duration[1] = msecs_to_jiffies(2500); /* actually 3 sec */\n\n\tret = elv_register(&iosched_bfq_mq);\n\tif (ret)\n\t\tgoto slab_kill;\n\n\treturn 0;\n\nslab_kill:\n\tbfq_slab_kill();\nerr_pol_unreg:\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\tblkcg_policy_unregister(&blkcg_policy_bfq);\n#endif\n\treturn ret;\n}\n\nstatic void __exit bfq_exit(void)\n{\n\telv_unregister(&iosched_bfq_mq);\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\tblkcg_policy_unregister(&blkcg_policy_bfq);\n#endif\n\tbfq_slab_kill();\n}\n\nmodule_init(bfq_init);\nmodule_exit(bfq_exit);\n\nMODULE_AUTHOR(\"Paolo Valente\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"MQ Budget Fair Queueing I/O Scheduler\");\n"}}, "reports": [{"events": [{"location": {"col": 20, "file": 0, "line": 6757}, "message": "WARNING: Comparison of 0/1 to bool variable"}], "macros": [], "notes": [], "path": "/src/block/bfq-iosched.c", "reportHash": "1dbba253710adb964bc17d30b52a279c", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
