<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/gpu/drm/i915/display/intel_display.c", "content": "/*\n * Copyright \u00a9 2006-2007 Intel Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Authors:\n *\tEric Anholt <eric@anholt.net>\n */\n\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/intel-iommu.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/dma-resv.h>\n#include <linux/slab.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_dp_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_plane_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_rect.h>\n\n#include \"display/intel_crt.h\"\n#include \"display/intel_ddi.h\"\n#include \"display/intel_dp.h\"\n#include \"display/intel_dp_mst.h\"\n#include \"display/intel_dpll_mgr.h\"\n#include \"display/intel_dsi.h\"\n#include \"display/intel_dvo.h\"\n#include \"display/intel_gmbus.h\"\n#include \"display/intel_hdmi.h\"\n#include \"display/intel_lvds.h\"\n#include \"display/intel_sdvo.h\"\n#include \"display/intel_tv.h\"\n#include \"display/intel_vdsc.h\"\n\n#include \"gt/intel_rps.h\"\n\n#include \"i915_drv.h\"\n#include \"i915_trace.h\"\n#include \"intel_acpi.h\"\n#include \"intel_atomic.h\"\n#include \"intel_atomic_plane.h\"\n#include \"intel_bw.h\"\n#include \"intel_cdclk.h\"\n#include \"intel_color.h\"\n#include \"intel_csr.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dp_link_training.h\"\n#include \"intel_fbc.h\"\n#include \"intel_fbdev.h\"\n#include \"intel_fifo_underrun.h\"\n#include \"intel_frontbuffer.h\"\n#include \"intel_hdcp.h\"\n#include \"intel_hotplug.h\"\n#include \"intel_overlay.h\"\n#include \"intel_pipe_crc.h\"\n#include \"intel_pm.h\"\n#include \"intel_psr.h\"\n#include \"intel_quirks.h\"\n#include \"intel_sideband.h\"\n#include \"intel_sprite.h\"\n#include \"intel_tc.h\"\n#include \"intel_vga.h\"\n\n/* Primary plane formats for gen <= 3 */\nstatic const u32 i8xx_primary_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n};\n\n/* Primary plane formats for ivb (no fp16 due to hw issue) */\nstatic const u32 ivb_primary_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_XRGB2101010,\n\tDRM_FORMAT_XBGR2101010,\n};\n\n/* Primary plane formats for gen >= 4, except ivb */\nstatic const u32 i965_primary_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_XRGB2101010,\n\tDRM_FORMAT_XBGR2101010,\n\tDRM_FORMAT_XBGR16161616F,\n};\n\n/* Primary plane formats for vlv/chv */\nstatic const u32 vlv_primary_formats[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XRGB2101010,\n\tDRM_FORMAT_XBGR2101010,\n\tDRM_FORMAT_ARGB2101010,\n\tDRM_FORMAT_ABGR2101010,\n\tDRM_FORMAT_XBGR16161616F,\n};\n\nstatic const u64 i9xx_format_modifiers[] = {\n\tI915_FORMAT_MOD_X_TILED,\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\n/* Cursor formats */\nstatic const u32 intel_cursor_formats[] = {\n\tDRM_FORMAT_ARGB8888,\n};\n\nstatic const u64 cursor_format_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nstatic void i9xx_crtc_clock_get(struct intel_crtc *crtc,\n\t\t\t\tstruct intel_crtc_state *pipe_config);\nstatic void ilk_pch_clock_get(struct intel_crtc *crtc,\n\t\t\t      struct intel_crtc_state *pipe_config);\n\nstatic int intel_framebuffer_init(struct intel_framebuffer *ifb,\n\t\t\t\t  struct drm_i915_gem_object *obj,\n\t\t\t\t  struct drm_mode_fb_cmd2 *mode_cmd);\nstatic void intel_set_pipe_timings(const struct intel_crtc_state *crtc_state);\nstatic void intel_set_pipe_src_size(const struct intel_crtc_state *crtc_state);\nstatic void intel_cpu_transcoder_set_m_n(const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t const struct intel_link_m_n *m_n,\n\t\t\t\t\t const struct intel_link_m_n *m2_n2);\nstatic void i9xx_set_pipeconf(const struct intel_crtc_state *crtc_state);\nstatic void ilk_set_pipeconf(const struct intel_crtc_state *crtc_state);\nstatic void hsw_set_pipeconf(const struct intel_crtc_state *crtc_state);\nstatic void bdw_set_pipemisc(const struct intel_crtc_state *crtc_state);\nstatic void vlv_prepare_pll(struct intel_crtc *crtc,\n\t\t\t    const struct intel_crtc_state *pipe_config);\nstatic void chv_prepare_pll(struct intel_crtc *crtc,\n\t\t\t    const struct intel_crtc_state *pipe_config);\nstatic void skl_pfit_enable(const struct intel_crtc_state *crtc_state);\nstatic void ilk_pfit_enable(const struct intel_crtc_state *crtc_state);\nstatic void intel_modeset_setup_hw_state(struct drm_device *dev,\n\t\t\t\t\t struct drm_modeset_acquire_ctx *ctx);\nstatic struct intel_crtc_state *intel_crtc_state_alloc(struct intel_crtc *crtc);\n\nstruct intel_limit {\n\tstruct {\n\t\tint min, max;\n\t} dot, vco, n, m, m1, m2, p, p1;\n\n\tstruct {\n\t\tint dot_limit;\n\t\tint p2_slow, p2_fast;\n\t} p2;\n};\n\n/* returns HPLL frequency in kHz */\nint vlv_get_hpll_vco(struct drm_i915_private *dev_priv)\n{\n\tint hpll_freq, vco_freq[] = { 800, 1600, 2000, 2400 };\n\n\t/* Obtain SKU information */\n\thpll_freq = vlv_cck_read(dev_priv, CCK_FUSE_REG) &\n\t\tCCK_FUSE_HPLL_FREQ_MASK;\n\n\treturn vco_freq[hpll_freq] * 1000;\n}\n\nint vlv_get_cck_clock(struct drm_i915_private *dev_priv,\n\t\t      const char *name, u32 reg, int ref_freq)\n{\n\tu32 val;\n\tint divider;\n\n\tval = vlv_cck_read(dev_priv, reg);\n\tdivider = val & CCK_FREQUENCY_VALUES;\n\n\tdrm_WARN(&dev_priv->drm, (val & CCK_FREQUENCY_STATUS) !=\n\t\t (divider << CCK_FREQUENCY_STATUS_SHIFT),\n\t\t \"%s change in progress\\n\", name);\n\n\treturn DIV_ROUND_CLOSEST(ref_freq << 1, divider + 1);\n}\n\nint vlv_get_cck_clock_hpll(struct drm_i915_private *dev_priv,\n\t\t\t   const char *name, u32 reg)\n{\n\tint hpll;\n\n\tvlv_cck_get(dev_priv);\n\n\tif (dev_priv->hpll_freq == 0)\n\t\tdev_priv->hpll_freq = vlv_get_hpll_vco(dev_priv);\n\n\thpll = vlv_get_cck_clock(dev_priv, name, reg, dev_priv->hpll_freq);\n\n\tvlv_cck_put(dev_priv);\n\n\treturn hpll;\n}\n\nstatic void intel_update_czclk(struct drm_i915_private *dev_priv)\n{\n\tif (!(IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)))\n\t\treturn;\n\n\tdev_priv->czclk_freq = vlv_get_cck_clock_hpll(dev_priv, \"czclk\",\n\t\t\t\t\t\t      CCK_CZ_CLOCK_CONTROL);\n\n\tdrm_dbg(&dev_priv->drm, \"CZ clock rate: %d kHz\\n\",\n\t\tdev_priv->czclk_freq);\n}\n\n/* units of 100MHz */\nstatic u32 intel_fdi_link_freq(struct drm_i915_private *dev_priv,\n\t\t\t       const struct intel_crtc_state *pipe_config)\n{\n\tif (HAS_DDI(dev_priv))\n\t\treturn pipe_config->port_clock; /* SPLL */\n\telse\n\t\treturn dev_priv->fdi_pll_freq;\n}\n\nstatic const struct intel_limit intel_limits_i8xx_dac = {\n\t.dot = { .min = 25000, .max = 350000 },\n\t.vco = { .min = 908000, .max = 1512000 },\n\t.n = { .min = 2, .max = 16 },\n\t.m = { .min = 96, .max = 140 },\n\t.m1 = { .min = 18, .max = 26 },\n\t.m2 = { .min = 6, .max = 16 },\n\t.p = { .min = 4, .max = 128 },\n\t.p1 = { .min = 2, .max = 33 },\n\t.p2 = { .dot_limit = 165000,\n\t\t.p2_slow = 4, .p2_fast = 2 },\n};\n\nstatic const struct intel_limit intel_limits_i8xx_dvo = {\n\t.dot = { .min = 25000, .max = 350000 },\n\t.vco = { .min = 908000, .max = 1512000 },\n\t.n = { .min = 2, .max = 16 },\n\t.m = { .min = 96, .max = 140 },\n\t.m1 = { .min = 18, .max = 26 },\n\t.m2 = { .min = 6, .max = 16 },\n\t.p = { .min = 4, .max = 128 },\n\t.p1 = { .min = 2, .max = 33 },\n\t.p2 = { .dot_limit = 165000,\n\t\t.p2_slow = 4, .p2_fast = 4 },\n};\n\nstatic const struct intel_limit intel_limits_i8xx_lvds = {\n\t.dot = { .min = 25000, .max = 350000 },\n\t.vco = { .min = 908000, .max = 1512000 },\n\t.n = { .min = 2, .max = 16 },\n\t.m = { .min = 96, .max = 140 },\n\t.m1 = { .min = 18, .max = 26 },\n\t.m2 = { .min = 6, .max = 16 },\n\t.p = { .min = 4, .max = 128 },\n\t.p1 = { .min = 1, .max = 6 },\n\t.p2 = { .dot_limit = 165000,\n\t\t.p2_slow = 14, .p2_fast = 7 },\n};\n\nstatic const struct intel_limit intel_limits_i9xx_sdvo = {\n\t.dot = { .min = 20000, .max = 400000 },\n\t.vco = { .min = 1400000, .max = 2800000 },\n\t.n = { .min = 1, .max = 6 },\n\t.m = { .min = 70, .max = 120 },\n\t.m1 = { .min = 8, .max = 18 },\n\t.m2 = { .min = 3, .max = 7 },\n\t.p = { .min = 5, .max = 80 },\n\t.p1 = { .min = 1, .max = 8 },\n\t.p2 = { .dot_limit = 200000,\n\t\t.p2_slow = 10, .p2_fast = 5 },\n};\n\nstatic const struct intel_limit intel_limits_i9xx_lvds = {\n\t.dot = { .min = 20000, .max = 400000 },\n\t.vco = { .min = 1400000, .max = 2800000 },\n\t.n = { .min = 1, .max = 6 },\n\t.m = { .min = 70, .max = 120 },\n\t.m1 = { .min = 8, .max = 18 },\n\t.m2 = { .min = 3, .max = 7 },\n\t.p = { .min = 7, .max = 98 },\n\t.p1 = { .min = 1, .max = 8 },\n\t.p2 = { .dot_limit = 112000,\n\t\t.p2_slow = 14, .p2_fast = 7 },\n};\n\n\nstatic const struct intel_limit intel_limits_g4x_sdvo = {\n\t.dot = { .min = 25000, .max = 270000 },\n\t.vco = { .min = 1750000, .max = 3500000},\n\t.n = { .min = 1, .max = 4 },\n\t.m = { .min = 104, .max = 138 },\n\t.m1 = { .min = 17, .max = 23 },\n\t.m2 = { .min = 5, .max = 11 },\n\t.p = { .min = 10, .max = 30 },\n\t.p1 = { .min = 1, .max = 3},\n\t.p2 = { .dot_limit = 270000,\n\t\t.p2_slow = 10,\n\t\t.p2_fast = 10\n\t},\n};\n\nstatic const struct intel_limit intel_limits_g4x_hdmi = {\n\t.dot = { .min = 22000, .max = 400000 },\n\t.vco = { .min = 1750000, .max = 3500000},\n\t.n = { .min = 1, .max = 4 },\n\t.m = { .min = 104, .max = 138 },\n\t.m1 = { .min = 16, .max = 23 },\n\t.m2 = { .min = 5, .max = 11 },\n\t.p = { .min = 5, .max = 80 },\n\t.p1 = { .min = 1, .max = 8},\n\t.p2 = { .dot_limit = 165000,\n\t\t.p2_slow = 10, .p2_fast = 5 },\n};\n\nstatic const struct intel_limit intel_limits_g4x_single_channel_lvds = {\n\t.dot = { .min = 20000, .max = 115000 },\n\t.vco = { .min = 1750000, .max = 3500000 },\n\t.n = { .min = 1, .max = 3 },\n\t.m = { .min = 104, .max = 138 },\n\t.m1 = { .min = 17, .max = 23 },\n\t.m2 = { .min = 5, .max = 11 },\n\t.p = { .min = 28, .max = 112 },\n\t.p1 = { .min = 2, .max = 8 },\n\t.p2 = { .dot_limit = 0,\n\t\t.p2_slow = 14, .p2_fast = 14\n\t},\n};\n\nstatic const struct intel_limit intel_limits_g4x_dual_channel_lvds = {\n\t.dot = { .min = 80000, .max = 224000 },\n\t.vco = { .min = 1750000, .max = 3500000 },\n\t.n = { .min = 1, .max = 3 },\n\t.m = { .min = 104, .max = 138 },\n\t.m1 = { .min = 17, .max = 23 },\n\t.m2 = { .min = 5, .max = 11 },\n\t.p = { .min = 14, .max = 42 },\n\t.p1 = { .min = 2, .max = 6 },\n\t.p2 = { .dot_limit = 0,\n\t\t.p2_slow = 7, .p2_fast = 7\n\t},\n};\n\nstatic const struct intel_limit pnv_limits_sdvo = {\n\t.dot = { .min = 20000, .max = 400000},\n\t.vco = { .min = 1700000, .max = 3500000 },\n\t/* Pineview's Ncounter is a ring counter */\n\t.n = { .min = 3, .max = 6 },\n\t.m = { .min = 2, .max = 256 },\n\t/* Pineview only has one combined m divider, which we treat as m2. */\n\t.m1 = { .min = 0, .max = 0 },\n\t.m2 = { .min = 0, .max = 254 },\n\t.p = { .min = 5, .max = 80 },\n\t.p1 = { .min = 1, .max = 8 },\n\t.p2 = { .dot_limit = 200000,\n\t\t.p2_slow = 10, .p2_fast = 5 },\n};\n\nstatic const struct intel_limit pnv_limits_lvds = {\n\t.dot = { .min = 20000, .max = 400000 },\n\t.vco = { .min = 1700000, .max = 3500000 },\n\t.n = { .min = 3, .max = 6 },\n\t.m = { .min = 2, .max = 256 },\n\t.m1 = { .min = 0, .max = 0 },\n\t.m2 = { .min = 0, .max = 254 },\n\t.p = { .min = 7, .max = 112 },\n\t.p1 = { .min = 1, .max = 8 },\n\t.p2 = { .dot_limit = 112000,\n\t\t.p2_slow = 14, .p2_fast = 14 },\n};\n\n/* Ironlake / Sandybridge\n *\n * We calculate clock using (register_value + 2) for N/M1/M2, so here\n * the range value for them is (actual_value - 2).\n */\nstatic const struct intel_limit ilk_limits_dac = {\n\t.dot = { .min = 25000, .max = 350000 },\n\t.vco = { .min = 1760000, .max = 3510000 },\n\t.n = { .min = 1, .max = 5 },\n\t.m = { .min = 79, .max = 127 },\n\t.m1 = { .min = 12, .max = 22 },\n\t.m2 = { .min = 5, .max = 9 },\n\t.p = { .min = 5, .max = 80 },\n\t.p1 = { .min = 1, .max = 8 },\n\t.p2 = { .dot_limit = 225000,\n\t\t.p2_slow = 10, .p2_fast = 5 },\n};\n\nstatic const struct intel_limit ilk_limits_single_lvds = {\n\t.dot = { .min = 25000, .max = 350000 },\n\t.vco = { .min = 1760000, .max = 3510000 },\n\t.n = { .min = 1, .max = 3 },\n\t.m = { .min = 79, .max = 118 },\n\t.m1 = { .min = 12, .max = 22 },\n\t.m2 = { .min = 5, .max = 9 },\n\t.p = { .min = 28, .max = 112 },\n\t.p1 = { .min = 2, .max = 8 },\n\t.p2 = { .dot_limit = 225000,\n\t\t.p2_slow = 14, .p2_fast = 14 },\n};\n\nstatic const struct intel_limit ilk_limits_dual_lvds = {\n\t.dot = { .min = 25000, .max = 350000 },\n\t.vco = { .min = 1760000, .max = 3510000 },\n\t.n = { .min = 1, .max = 3 },\n\t.m = { .min = 79, .max = 127 },\n\t.m1 = { .min = 12, .max = 22 },\n\t.m2 = { .min = 5, .max = 9 },\n\t.p = { .min = 14, .max = 56 },\n\t.p1 = { .min = 2, .max = 8 },\n\t.p2 = { .dot_limit = 225000,\n\t\t.p2_slow = 7, .p2_fast = 7 },\n};\n\n/* LVDS 100mhz refclk limits. */\nstatic const struct intel_limit ilk_limits_single_lvds_100m = {\n\t.dot = { .min = 25000, .max = 350000 },\n\t.vco = { .min = 1760000, .max = 3510000 },\n\t.n = { .min = 1, .max = 2 },\n\t.m = { .min = 79, .max = 126 },\n\t.m1 = { .min = 12, .max = 22 },\n\t.m2 = { .min = 5, .max = 9 },\n\t.p = { .min = 28, .max = 112 },\n\t.p1 = { .min = 2, .max = 8 },\n\t.p2 = { .dot_limit = 225000,\n\t\t.p2_slow = 14, .p2_fast = 14 },\n};\n\nstatic const struct intel_limit ilk_limits_dual_lvds_100m = {\n\t.dot = { .min = 25000, .max = 350000 },\n\t.vco = { .min = 1760000, .max = 3510000 },\n\t.n = { .min = 1, .max = 3 },\n\t.m = { .min = 79, .max = 126 },\n\t.m1 = { .min = 12, .max = 22 },\n\t.m2 = { .min = 5, .max = 9 },\n\t.p = { .min = 14, .max = 42 },\n\t.p1 = { .min = 2, .max = 6 },\n\t.p2 = { .dot_limit = 225000,\n\t\t.p2_slow = 7, .p2_fast = 7 },\n};\n\nstatic const struct intel_limit intel_limits_vlv = {\n\t /*\n\t  * These are the data rate limits (measured in fast clocks)\n\t  * since those are the strictest limits we have. The fast\n\t  * clock and actual rate limits are more relaxed, so checking\n\t  * them would make no difference.\n\t  */\n\t.dot = { .min = 25000 * 5, .max = 270000 * 5 },\n\t.vco = { .min = 4000000, .max = 6000000 },\n\t.n = { .min = 1, .max = 7 },\n\t.m1 = { .min = 2, .max = 3 },\n\t.m2 = { .min = 11, .max = 156 },\n\t.p1 = { .min = 2, .max = 3 },\n\t.p2 = { .p2_slow = 2, .p2_fast = 20 }, /* slow=min, fast=max */\n};\n\nstatic const struct intel_limit intel_limits_chv = {\n\t/*\n\t * These are the data rate limits (measured in fast clocks)\n\t * since those are the strictest limits we have.  The fast\n\t * clock and actual rate limits are more relaxed, so checking\n\t * them would make no difference.\n\t */\n\t.dot = { .min = 25000 * 5, .max = 540000 * 5},\n\t.vco = { .min = 4800000, .max = 6480000 },\n\t.n = { .min = 1, .max = 1 },\n\t.m1 = { .min = 2, .max = 2 },\n\t.m2 = { .min = 24 << 22, .max = 175 << 22 },\n\t.p1 = { .min = 2, .max = 4 },\n\t.p2 = {\t.p2_slow = 1, .p2_fast = 14 },\n};\n\nstatic const struct intel_limit intel_limits_bxt = {\n\t/* FIXME: find real dot limits */\n\t.dot = { .min = 0, .max = INT_MAX },\n\t.vco = { .min = 4800000, .max = 6700000 },\n\t.n = { .min = 1, .max = 1 },\n\t.m1 = { .min = 2, .max = 2 },\n\t/* FIXME: find real m2 limits */\n\t.m2 = { .min = 2 << 22, .max = 255 << 22 },\n\t.p1 = { .min = 2, .max = 4 },\n\t.p2 = { .p2_slow = 1, .p2_fast = 20 },\n};\n\n/* WA Display #0827: Gen9:all */\nstatic void\nskl_wa_827(struct drm_i915_private *dev_priv, enum pipe pipe, bool enable)\n{\n\tif (enable)\n\t\tintel_de_write(dev_priv, CLKGATE_DIS_PSL(pipe),\n\t\t               intel_de_read(dev_priv, CLKGATE_DIS_PSL(pipe)) | DUPS1_GATING_DIS | DUPS2_GATING_DIS);\n\telse\n\t\tintel_de_write(dev_priv, CLKGATE_DIS_PSL(pipe),\n\t\t               intel_de_read(dev_priv, CLKGATE_DIS_PSL(pipe)) & ~(DUPS1_GATING_DIS | DUPS2_GATING_DIS));\n}\n\n/* Wa_2006604312:icl,ehl */\nstatic void\nicl_wa_scalerclkgating(struct drm_i915_private *dev_priv, enum pipe pipe,\n\t\t       bool enable)\n{\n\tif (enable)\n\t\tintel_de_write(dev_priv, CLKGATE_DIS_PSL(pipe),\n\t\t               intel_de_read(dev_priv, CLKGATE_DIS_PSL(pipe)) | DPFR_GATING_DIS);\n\telse\n\t\tintel_de_write(dev_priv, CLKGATE_DIS_PSL(pipe),\n\t\t               intel_de_read(dev_priv, CLKGATE_DIS_PSL(pipe)) & ~DPFR_GATING_DIS);\n}\n\nstatic bool\nneeds_modeset(const struct intel_crtc_state *state)\n{\n\treturn drm_atomic_crtc_needs_modeset(&state->uapi);\n}\n\nstatic bool\nis_trans_port_sync_slave(const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->master_transcoder != INVALID_TRANSCODER;\n}\n\nstatic bool\nis_trans_port_sync_master(const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->sync_mode_slaves_mask != 0;\n}\n\nbool\nis_trans_port_sync_mode(const struct intel_crtc_state *crtc_state)\n{\n\treturn is_trans_port_sync_master(crtc_state) ||\n\t\tis_trans_port_sync_slave(crtc_state);\n}\n\n/*\n * Platform specific helpers to calculate the port PLL loopback- (clock.m),\n * and post-divider (clock.p) values, pre- (clock.vco) and post-divided fast\n * (clock.dot) clock rates. This fast dot clock is fed to the port's IO logic.\n * The helpers' return value is the rate of the clock that is fed to the\n * display engine's pipe which can be the above fast dot clock rate or a\n * divided-down version of it.\n */\n/* m1 is reserved as 0 in Pineview, n is a ring counter */\nstatic int pnv_calc_dpll_params(int refclk, struct dpll *clock)\n{\n\tclock->m = clock->m2 + 2;\n\tclock->p = clock->p1 * clock->p2;\n\tif (WARN_ON(clock->n == 0 || clock->p == 0))\n\t\treturn 0;\n\tclock->vco = DIV_ROUND_CLOSEST(refclk * clock->m, clock->n);\n\tclock->dot = DIV_ROUND_CLOSEST(clock->vco, clock->p);\n\n\treturn clock->dot;\n}\n\nstatic u32 i9xx_dpll_compute_m(struct dpll *dpll)\n{\n\treturn 5 * (dpll->m1 + 2) + (dpll->m2 + 2);\n}\n\nstatic int i9xx_calc_dpll_params(int refclk, struct dpll *clock)\n{\n\tclock->m = i9xx_dpll_compute_m(clock);\n\tclock->p = clock->p1 * clock->p2;\n\tif (WARN_ON(clock->n + 2 == 0 || clock->p == 0))\n\t\treturn 0;\n\tclock->vco = DIV_ROUND_CLOSEST(refclk * clock->m, clock->n + 2);\n\tclock->dot = DIV_ROUND_CLOSEST(clock->vco, clock->p);\n\n\treturn clock->dot;\n}\n\nstatic int vlv_calc_dpll_params(int refclk, struct dpll *clock)\n{\n\tclock->m = clock->m1 * clock->m2;\n\tclock->p = clock->p1 * clock->p2;\n\tif (WARN_ON(clock->n == 0 || clock->p == 0))\n\t\treturn 0;\n\tclock->vco = DIV_ROUND_CLOSEST(refclk * clock->m, clock->n);\n\tclock->dot = DIV_ROUND_CLOSEST(clock->vco, clock->p);\n\n\treturn clock->dot / 5;\n}\n\nint chv_calc_dpll_params(int refclk, struct dpll *clock)\n{\n\tclock->m = clock->m1 * clock->m2;\n\tclock->p = clock->p1 * clock->p2;\n\tif (WARN_ON(clock->n == 0 || clock->p == 0))\n\t\treturn 0;\n\tclock->vco = DIV_ROUND_CLOSEST_ULL(mul_u32_u32(refclk, clock->m),\n\t\t\t\t\t   clock->n << 22);\n\tclock->dot = DIV_ROUND_CLOSEST(clock->vco, clock->p);\n\n\treturn clock->dot / 5;\n}\n\n/*\n * Returns whether the given set of divisors are valid for a given refclk with\n * the given connectors.\n */\nstatic bool intel_pll_is_valid(struct drm_i915_private *dev_priv,\n\t\t\t       const struct intel_limit *limit,\n\t\t\t       const struct dpll *clock)\n{\n\tif (clock->n < limit->n.min || limit->n.max < clock->n)\n\t\treturn false;\n\tif (clock->p1 < limit->p1.min || limit->p1.max < clock->p1)\n\t\treturn false;\n\tif (clock->m2 < limit->m2.min || limit->m2.max < clock->m2)\n\t\treturn false;\n\tif (clock->m1 < limit->m1.min || limit->m1.max < clock->m1)\n\t\treturn false;\n\n\tif (!IS_PINEVIEW(dev_priv) && !IS_VALLEYVIEW(dev_priv) &&\n\t    !IS_CHERRYVIEW(dev_priv) && !IS_GEN9_LP(dev_priv))\n\t\tif (clock->m1 <= clock->m2)\n\t\t\treturn false;\n\n\tif (!IS_VALLEYVIEW(dev_priv) && !IS_CHERRYVIEW(dev_priv) &&\n\t    !IS_GEN9_LP(dev_priv)) {\n\t\tif (clock->p < limit->p.min || limit->p.max < clock->p)\n\t\t\treturn false;\n\t\tif (clock->m < limit->m.min || limit->m.max < clock->m)\n\t\t\treturn false;\n\t}\n\n\tif (clock->vco < limit->vco.min || limit->vco.max < clock->vco)\n\t\treturn false;\n\t/* XXX: We may need to be checking \"Dot clock\" depending on the multiplier,\n\t * connector, etc., rather than just a single range.\n\t */\n\tif (clock->dot < limit->dot.min || limit->dot.max < clock->dot)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int\ni9xx_select_p2_div(const struct intel_limit *limit,\n\t\t   const struct intel_crtc_state *crtc_state,\n\t\t   int target)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS)) {\n\t\t/*\n\t\t * For LVDS just rely on its current settings for dual-channel.\n\t\t * We haven't figured out how to reliably set up different\n\t\t * single/dual channel state, if we even can.\n\t\t */\n\t\tif (intel_is_dual_link_lvds(dev_priv))\n\t\t\treturn limit->p2.p2_fast;\n\t\telse\n\t\t\treturn limit->p2.p2_slow;\n\t} else {\n\t\tif (target < limit->p2.dot_limit)\n\t\t\treturn limit->p2.p2_slow;\n\t\telse\n\t\t\treturn limit->p2.p2_fast;\n\t}\n}\n\n/*\n * Returns a set of divisors for the desired target clock with the given\n * refclk, or FALSE.  The returned values represent the clock equation:\n * reflck * (5 * (m1 + 2) + (m2 + 2)) / (n + 2) / p1 / p2.\n *\n * Target and reference clocks are specified in kHz.\n *\n * If match_clock is provided, then best_clock P divider must match the P\n * divider from @match_clock used for LVDS downclocking.\n */\nstatic bool\ni9xx_find_best_dpll(const struct intel_limit *limit,\n\t\t    struct intel_crtc_state *crtc_state,\n\t\t    int target, int refclk, struct dpll *match_clock,\n\t\t    struct dpll *best_clock)\n{\n\tstruct drm_device *dev = crtc_state->uapi.crtc->dev;\n\tstruct dpll clock;\n\tint err = target;\n\n\tmemset(best_clock, 0, sizeof(*best_clock));\n\n\tclock.p2 = i9xx_select_p2_div(limit, crtc_state, target);\n\n\tfor (clock.m1 = limit->m1.min; clock.m1 <= limit->m1.max;\n\t     clock.m1++) {\n\t\tfor (clock.m2 = limit->m2.min;\n\t\t     clock.m2 <= limit->m2.max; clock.m2++) {\n\t\t\tif (clock.m2 >= clock.m1)\n\t\t\t\tbreak;\n\t\t\tfor (clock.n = limit->n.min;\n\t\t\t     clock.n <= limit->n.max; clock.n++) {\n\t\t\t\tfor (clock.p1 = limit->p1.min;\n\t\t\t\t\tclock.p1 <= limit->p1.max; clock.p1++) {\n\t\t\t\t\tint this_err;\n\n\t\t\t\t\ti9xx_calc_dpll_params(refclk, &clock);\n\t\t\t\t\tif (!intel_pll_is_valid(to_i915(dev),\n\t\t\t\t\t\t\t\tlimit,\n\t\t\t\t\t\t\t\t&clock))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (match_clock &&\n\t\t\t\t\t    clock.p != match_clock->p)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tthis_err = abs(clock.dot - target);\n\t\t\t\t\tif (this_err < err) {\n\t\t\t\t\t\t*best_clock = clock;\n\t\t\t\t\t\terr = this_err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (err != target);\n}\n\n/*\n * Returns a set of divisors for the desired target clock with the given\n * refclk, or FALSE.  The returned values represent the clock equation:\n * reflck * (5 * (m1 + 2) + (m2 + 2)) / (n + 2) / p1 / p2.\n *\n * Target and reference clocks are specified in kHz.\n *\n * If match_clock is provided, then best_clock P divider must match the P\n * divider from @match_clock used for LVDS downclocking.\n */\nstatic bool\npnv_find_best_dpll(const struct intel_limit *limit,\n\t\t   struct intel_crtc_state *crtc_state,\n\t\t   int target, int refclk, struct dpll *match_clock,\n\t\t   struct dpll *best_clock)\n{\n\tstruct drm_device *dev = crtc_state->uapi.crtc->dev;\n\tstruct dpll clock;\n\tint err = target;\n\n\tmemset(best_clock, 0, sizeof(*best_clock));\n\n\tclock.p2 = i9xx_select_p2_div(limit, crtc_state, target);\n\n\tfor (clock.m1 = limit->m1.min; clock.m1 <= limit->m1.max;\n\t     clock.m1++) {\n\t\tfor (clock.m2 = limit->m2.min;\n\t\t     clock.m2 <= limit->m2.max; clock.m2++) {\n\t\t\tfor (clock.n = limit->n.min;\n\t\t\t     clock.n <= limit->n.max; clock.n++) {\n\t\t\t\tfor (clock.p1 = limit->p1.min;\n\t\t\t\t\tclock.p1 <= limit->p1.max; clock.p1++) {\n\t\t\t\t\tint this_err;\n\n\t\t\t\t\tpnv_calc_dpll_params(refclk, &clock);\n\t\t\t\t\tif (!intel_pll_is_valid(to_i915(dev),\n\t\t\t\t\t\t\t\tlimit,\n\t\t\t\t\t\t\t\t&clock))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (match_clock &&\n\t\t\t\t\t    clock.p != match_clock->p)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tthis_err = abs(clock.dot - target);\n\t\t\t\t\tif (this_err < err) {\n\t\t\t\t\t\t*best_clock = clock;\n\t\t\t\t\t\terr = this_err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (err != target);\n}\n\n/*\n * Returns a set of divisors for the desired target clock with the given\n * refclk, or FALSE.  The returned values represent the clock equation:\n * reflck * (5 * (m1 + 2) + (m2 + 2)) / (n + 2) / p1 / p2.\n *\n * Target and reference clocks are specified in kHz.\n *\n * If match_clock is provided, then best_clock P divider must match the P\n * divider from @match_clock used for LVDS downclocking.\n */\nstatic bool\ng4x_find_best_dpll(const struct intel_limit *limit,\n\t\t   struct intel_crtc_state *crtc_state,\n\t\t   int target, int refclk, struct dpll *match_clock,\n\t\t   struct dpll *best_clock)\n{\n\tstruct drm_device *dev = crtc_state->uapi.crtc->dev;\n\tstruct dpll clock;\n\tint max_n;\n\tbool found = false;\n\t/* approximately equals target * 0.00585 */\n\tint err_most = (target >> 8) + (target >> 9);\n\n\tmemset(best_clock, 0, sizeof(*best_clock));\n\n\tclock.p2 = i9xx_select_p2_div(limit, crtc_state, target);\n\n\tmax_n = limit->n.max;\n\t/* based on hardware requirement, prefer smaller n to precision */\n\tfor (clock.n = limit->n.min; clock.n <= max_n; clock.n++) {\n\t\t/* based on hardware requirement, prefere larger m1,m2 */\n\t\tfor (clock.m1 = limit->m1.max;\n\t\t     clock.m1 >= limit->m1.min; clock.m1--) {\n\t\t\tfor (clock.m2 = limit->m2.max;\n\t\t\t     clock.m2 >= limit->m2.min; clock.m2--) {\n\t\t\t\tfor (clock.p1 = limit->p1.max;\n\t\t\t\t     clock.p1 >= limit->p1.min; clock.p1--) {\n\t\t\t\t\tint this_err;\n\n\t\t\t\t\ti9xx_calc_dpll_params(refclk, &clock);\n\t\t\t\t\tif (!intel_pll_is_valid(to_i915(dev),\n\t\t\t\t\t\t\t\tlimit,\n\t\t\t\t\t\t\t\t&clock))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tthis_err = abs(clock.dot - target);\n\t\t\t\t\tif (this_err < err_most) {\n\t\t\t\t\t\t*best_clock = clock;\n\t\t\t\t\t\terr_most = this_err;\n\t\t\t\t\t\tmax_n = clock.n;\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}\n\n/*\n * Check if the calculated PLL configuration is more optimal compared to the\n * best configuration and error found so far. Return the calculated error.\n */\nstatic bool vlv_PLL_is_optimal(struct drm_device *dev, int target_freq,\n\t\t\t       const struct dpll *calculated_clock,\n\t\t\t       const struct dpll *best_clock,\n\t\t\t       unsigned int best_error_ppm,\n\t\t\t       unsigned int *error_ppm)\n{\n\t/*\n\t * For CHV ignore the error and consider only the P value.\n\t * Prefer a bigger P value based on HW requirements.\n\t */\n\tif (IS_CHERRYVIEW(to_i915(dev))) {\n\t\t*error_ppm = 0;\n\n\t\treturn calculated_clock->p > best_clock->p;\n\t}\n\n\tif (drm_WARN_ON_ONCE(dev, !target_freq))\n\t\treturn false;\n\n\t*error_ppm = div_u64(1000000ULL *\n\t\t\t\tabs(target_freq - calculated_clock->dot),\n\t\t\t     target_freq);\n\t/*\n\t * Prefer a better P value over a better (smaller) error if the error\n\t * is small. Ensure this preference for future configurations too by\n\t * setting the error to 0.\n\t */\n\tif (*error_ppm < 100 && calculated_clock->p > best_clock->p) {\n\t\t*error_ppm = 0;\n\n\t\treturn true;\n\t}\n\n\treturn *error_ppm + 10 < best_error_ppm;\n}\n\n/*\n * Returns a set of divisors for the desired target clock with the given\n * refclk, or FALSE.  The returned values represent the clock equation:\n * reflck * (5 * (m1 + 2) + (m2 + 2)) / (n + 2) / p1 / p2.\n */\nstatic bool\nvlv_find_best_dpll(const struct intel_limit *limit,\n\t\t   struct intel_crtc_state *crtc_state,\n\t\t   int target, int refclk, struct dpll *match_clock,\n\t\t   struct dpll *best_clock)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct dpll clock;\n\tunsigned int bestppm = 1000000;\n\t/* min update 19.2 MHz */\n\tint max_n = min(limit->n.max, refclk / 19200);\n\tbool found = false;\n\n\ttarget *= 5; /* fast clock */\n\n\tmemset(best_clock, 0, sizeof(*best_clock));\n\n\t/* based on hardware requirement, prefer smaller n to precision */\n\tfor (clock.n = limit->n.min; clock.n <= max_n; clock.n++) {\n\t\tfor (clock.p1 = limit->p1.max; clock.p1 >= limit->p1.min; clock.p1--) {\n\t\t\tfor (clock.p2 = limit->p2.p2_fast; clock.p2 >= limit->p2.p2_slow;\n\t\t\t     clock.p2 -= clock.p2 > 10 ? 2 : 1) {\n\t\t\t\tclock.p = clock.p1 * clock.p2;\n\t\t\t\t/* based on hardware requirement, prefer bigger m1,m2 values */\n\t\t\t\tfor (clock.m1 = limit->m1.min; clock.m1 <= limit->m1.max; clock.m1++) {\n\t\t\t\t\tunsigned int ppm;\n\n\t\t\t\t\tclock.m2 = DIV_ROUND_CLOSEST(target * clock.p * clock.n,\n\t\t\t\t\t\t\t\t     refclk * clock.m1);\n\n\t\t\t\t\tvlv_calc_dpll_params(refclk, &clock);\n\n\t\t\t\t\tif (!intel_pll_is_valid(to_i915(dev),\n\t\t\t\t\t\t\t\tlimit,\n\t\t\t\t\t\t\t\t&clock))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (!vlv_PLL_is_optimal(dev, target,\n\t\t\t\t\t\t\t\t&clock,\n\t\t\t\t\t\t\t\tbest_clock,\n\t\t\t\t\t\t\t\tbestppm, &ppm))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t*best_clock = clock;\n\t\t\t\t\tbestppm = ppm;\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}\n\n/*\n * Returns a set of divisors for the desired target clock with the given\n * refclk, or FALSE.  The returned values represent the clock equation:\n * reflck * (5 * (m1 + 2) + (m2 + 2)) / (n + 2) / p1 / p2.\n */\nstatic bool\nchv_find_best_dpll(const struct intel_limit *limit,\n\t\t   struct intel_crtc_state *crtc_state,\n\t\t   int target, int refclk, struct dpll *match_clock,\n\t\t   struct dpll *best_clock)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_device *dev = crtc->base.dev;\n\tunsigned int best_error_ppm;\n\tstruct dpll clock;\n\tu64 m2;\n\tint found = false;\n\n\tmemset(best_clock, 0, sizeof(*best_clock));\n\tbest_error_ppm = 1000000;\n\n\t/*\n\t * Based on hardware doc, the n always set to 1, and m1 always\n\t * set to 2.  If requires to support 200Mhz refclk, we need to\n\t * revisit this because n may not 1 anymore.\n\t */\n\tclock.n = 1, clock.m1 = 2;\n\ttarget *= 5;\t/* fast clock */\n\n\tfor (clock.p1 = limit->p1.max; clock.p1 >= limit->p1.min; clock.p1--) {\n\t\tfor (clock.p2 = limit->p2.p2_fast;\n\t\t\t\tclock.p2 >= limit->p2.p2_slow;\n\t\t\t\tclock.p2 -= clock.p2 > 10 ? 2 : 1) {\n\t\t\tunsigned int error_ppm;\n\n\t\t\tclock.p = clock.p1 * clock.p2;\n\n\t\t\tm2 = DIV_ROUND_CLOSEST_ULL(mul_u32_u32(target, clock.p * clock.n) << 22,\n\t\t\t\t\t\t   refclk * clock.m1);\n\n\t\t\tif (m2 > INT_MAX/clock.m1)\n\t\t\t\tcontinue;\n\n\t\t\tclock.m2 = m2;\n\n\t\t\tchv_calc_dpll_params(refclk, &clock);\n\n\t\t\tif (!intel_pll_is_valid(to_i915(dev), limit, &clock))\n\t\t\t\tcontinue;\n\n\t\t\tif (!vlv_PLL_is_optimal(dev, target, &clock, best_clock,\n\t\t\t\t\t\tbest_error_ppm, &error_ppm))\n\t\t\t\tcontinue;\n\n\t\t\t*best_clock = clock;\n\t\t\tbest_error_ppm = error_ppm;\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\treturn found;\n}\n\nbool bxt_find_best_dpll(struct intel_crtc_state *crtc_state,\n\t\t\tstruct dpll *best_clock)\n{\n\tint refclk = 100000;\n\tconst struct intel_limit *limit = &intel_limits_bxt;\n\n\treturn chv_find_best_dpll(limit, crtc_state,\n\t\t\t\t  crtc_state->port_clock, refclk,\n\t\t\t\t  NULL, best_clock);\n}\n\nstatic bool pipe_scanline_is_moving(struct drm_i915_private *dev_priv,\n\t\t\t\t    enum pipe pipe)\n{\n\ti915_reg_t reg = PIPEDSL(pipe);\n\tu32 line1, line2;\n\tu32 line_mask;\n\n\tif (IS_GEN(dev_priv, 2))\n\t\tline_mask = DSL_LINEMASK_GEN2;\n\telse\n\t\tline_mask = DSL_LINEMASK_GEN3;\n\n\tline1 = intel_de_read(dev_priv, reg) & line_mask;\n\tmsleep(5);\n\tline2 = intel_de_read(dev_priv, reg) & line_mask;\n\n\treturn line1 != line2;\n}\n\nstatic void wait_for_pipe_scanline_moving(struct intel_crtc *crtc, bool state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\t/* Wait for the display line to settle/start moving */\n\tif (wait_for(pipe_scanline_is_moving(dev_priv, pipe) == state, 100))\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"pipe %c scanline %s wait timed out\\n\",\n\t\t\tpipe_name(pipe), onoff(state));\n}\n\nstatic void intel_wait_for_pipe_scanline_stopped(struct intel_crtc *crtc)\n{\n\twait_for_pipe_scanline_moving(crtc, false);\n}\n\nstatic void intel_wait_for_pipe_scanline_moving(struct intel_crtc *crtc)\n{\n\twait_for_pipe_scanline_moving(crtc, true);\n}\n\nstatic void\nintel_wait_for_pipe_off(const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tif (INTEL_GEN(dev_priv) >= 4) {\n\t\tenum transcoder cpu_transcoder = old_crtc_state->cpu_transcoder;\n\t\ti915_reg_t reg = PIPECONF(cpu_transcoder);\n\n\t\t/* Wait for the Pipe State to go off */\n\t\tif (intel_de_wait_for_clear(dev_priv, reg,\n\t\t\t\t\t    I965_PIPECONF_ACTIVE, 100))\n\t\t\tdrm_WARN(&dev_priv->drm, 1,\n\t\t\t\t \"pipe_off wait timed out\\n\");\n\t} else {\n\t\tintel_wait_for_pipe_scanline_stopped(crtc);\n\t}\n}\n\n/* Only for pre-ILK configs */\nvoid assert_pll(struct drm_i915_private *dev_priv,\n\t\tenum pipe pipe, bool state)\n{\n\tu32 val;\n\tbool cur_state;\n\n\tval = intel_de_read(dev_priv, DPLL(pipe));\n\tcur_state = !!(val & DPLL_VCO_ENABLE);\n\tI915_STATE_WARN(cur_state != state,\n\t     \"PLL state assertion failure (expected %s, current %s)\\n\",\n\t\t\tonoff(state), onoff(cur_state));\n}\n\n/* XXX: the dsi pll is shared between MIPI DSI ports */\nvoid assert_dsi_pll(struct drm_i915_private *dev_priv, bool state)\n{\n\tu32 val;\n\tbool cur_state;\n\n\tvlv_cck_get(dev_priv);\n\tval = vlv_cck_read(dev_priv, CCK_REG_DSI_PLL_CONTROL);\n\tvlv_cck_put(dev_priv);\n\n\tcur_state = val & DSI_PLL_VCO_EN;\n\tI915_STATE_WARN(cur_state != state,\n\t     \"DSI PLL state assertion failure (expected %s, current %s)\\n\",\n\t\t\tonoff(state), onoff(cur_state));\n}\n\nstatic void assert_fdi_tx(struct drm_i915_private *dev_priv,\n\t\t\t  enum pipe pipe, bool state)\n{\n\tbool cur_state;\n\n\tif (HAS_DDI(dev_priv)) {\n\t\t/*\n\t\t * DDI does not have a specific FDI_TX register.\n\t\t *\n\t\t * FDI is never fed from EDP transcoder\n\t\t * so pipe->transcoder cast is fine here.\n\t\t */\n\t\tenum transcoder cpu_transcoder = (enum transcoder)pipe;\n\t\tu32 val = intel_de_read(dev_priv,\n\t\t\t\t\tTRANS_DDI_FUNC_CTL(cpu_transcoder));\n\t\tcur_state = !!(val & TRANS_DDI_FUNC_ENABLE);\n\t} else {\n\t\tu32 val = intel_de_read(dev_priv, FDI_TX_CTL(pipe));\n\t\tcur_state = !!(val & FDI_TX_ENABLE);\n\t}\n\tI915_STATE_WARN(cur_state != state,\n\t     \"FDI TX state assertion failure (expected %s, current %s)\\n\",\n\t\t\tonoff(state), onoff(cur_state));\n}\n#define assert_fdi_tx_enabled(d, p) assert_fdi_tx(d, p, true)\n#define assert_fdi_tx_disabled(d, p) assert_fdi_tx(d, p, false)\n\nstatic void assert_fdi_rx(struct drm_i915_private *dev_priv,\n\t\t\t  enum pipe pipe, bool state)\n{\n\tu32 val;\n\tbool cur_state;\n\n\tval = intel_de_read(dev_priv, FDI_RX_CTL(pipe));\n\tcur_state = !!(val & FDI_RX_ENABLE);\n\tI915_STATE_WARN(cur_state != state,\n\t     \"FDI RX state assertion failure (expected %s, current %s)\\n\",\n\t\t\tonoff(state), onoff(cur_state));\n}\n#define assert_fdi_rx_enabled(d, p) assert_fdi_rx(d, p, true)\n#define assert_fdi_rx_disabled(d, p) assert_fdi_rx(d, p, false)\n\nstatic void assert_fdi_tx_pll_enabled(struct drm_i915_private *dev_priv,\n\t\t\t\t      enum pipe pipe)\n{\n\tu32 val;\n\n\t/* ILK FDI PLL is always enabled */\n\tif (IS_GEN(dev_priv, 5))\n\t\treturn;\n\n\t/* On Haswell, DDI ports are responsible for the FDI PLL setup */\n\tif (HAS_DDI(dev_priv))\n\t\treturn;\n\n\tval = intel_de_read(dev_priv, FDI_TX_CTL(pipe));\n\tI915_STATE_WARN(!(val & FDI_TX_PLL_ENABLE), \"FDI TX PLL assertion failure, should be active but is disabled\\n\");\n}\n\nvoid assert_fdi_rx_pll(struct drm_i915_private *dev_priv,\n\t\t       enum pipe pipe, bool state)\n{\n\tu32 val;\n\tbool cur_state;\n\n\tval = intel_de_read(dev_priv, FDI_RX_CTL(pipe));\n\tcur_state = !!(val & FDI_RX_PLL_ENABLE);\n\tI915_STATE_WARN(cur_state != state,\n\t     \"FDI RX PLL assertion failure (expected %s, current %s)\\n\",\n\t\t\tonoff(state), onoff(cur_state));\n}\n\nvoid assert_panel_unlocked(struct drm_i915_private *dev_priv, enum pipe pipe)\n{\n\ti915_reg_t pp_reg;\n\tu32 val;\n\tenum pipe panel_pipe = INVALID_PIPE;\n\tbool locked = true;\n\n\tif (drm_WARN_ON(&dev_priv->drm, HAS_DDI(dev_priv)))\n\t\treturn;\n\n\tif (HAS_PCH_SPLIT(dev_priv)) {\n\t\tu32 port_sel;\n\n\t\tpp_reg = PP_CONTROL(0);\n\t\tport_sel = intel_de_read(dev_priv, PP_ON_DELAYS(0)) & PANEL_PORT_SELECT_MASK;\n\n\t\tswitch (port_sel) {\n\t\tcase PANEL_PORT_SELECT_LVDS:\n\t\t\tintel_lvds_port_enabled(dev_priv, PCH_LVDS, &panel_pipe);\n\t\t\tbreak;\n\t\tcase PANEL_PORT_SELECT_DPA:\n\t\t\tintel_dp_port_enabled(dev_priv, DP_A, PORT_A, &panel_pipe);\n\t\t\tbreak;\n\t\tcase PANEL_PORT_SELECT_DPC:\n\t\t\tintel_dp_port_enabled(dev_priv, PCH_DP_C, PORT_C, &panel_pipe);\n\t\t\tbreak;\n\t\tcase PANEL_PORT_SELECT_DPD:\n\t\t\tintel_dp_port_enabled(dev_priv, PCH_DP_D, PORT_D, &panel_pipe);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tMISSING_CASE(port_sel);\n\t\t\tbreak;\n\t\t}\n\t} else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\t/* presumably write lock depends on pipe, not port select */\n\t\tpp_reg = PP_CONTROL(pipe);\n\t\tpanel_pipe = pipe;\n\t} else {\n\t\tu32 port_sel;\n\n\t\tpp_reg = PP_CONTROL(0);\n\t\tport_sel = intel_de_read(dev_priv, PP_ON_DELAYS(0)) & PANEL_PORT_SELECT_MASK;\n\n\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t    port_sel != PANEL_PORT_SELECT_LVDS);\n\t\tintel_lvds_port_enabled(dev_priv, LVDS, &panel_pipe);\n\t}\n\n\tval = intel_de_read(dev_priv, pp_reg);\n\tif (!(val & PANEL_POWER_ON) ||\n\t    ((val & PANEL_UNLOCK_MASK) == PANEL_UNLOCK_REGS))\n\t\tlocked = false;\n\n\tI915_STATE_WARN(panel_pipe == pipe && locked,\n\t     \"panel assertion failure, pipe %c regs locked\\n\",\n\t     pipe_name(pipe));\n}\n\nvoid assert_pipe(struct drm_i915_private *dev_priv,\n\t\t enum transcoder cpu_transcoder, bool state)\n{\n\tbool cur_state;\n\tenum intel_display_power_domain power_domain;\n\tintel_wakeref_t wakeref;\n\n\t/* we keep both pipes enabled on 830 */\n\tif (IS_I830(dev_priv))\n\t\tstate = true;\n\n\tpower_domain = POWER_DOMAIN_TRANSCODER(cpu_transcoder);\n\twakeref = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\tif (wakeref) {\n\t\tu32 val = intel_de_read(dev_priv, PIPECONF(cpu_transcoder));\n\t\tcur_state = !!(val & PIPECONF_ENABLE);\n\n\t\tintel_display_power_put(dev_priv, power_domain, wakeref);\n\t} else {\n\t\tcur_state = false;\n\t}\n\n\tI915_STATE_WARN(cur_state != state,\n\t\t\t\"transcoder %s assertion failure (expected %s, current %s)\\n\",\n\t\t\ttranscoder_name(cpu_transcoder),\n\t\t\tonoff(state), onoff(cur_state));\n}\n\nstatic void assert_plane(struct intel_plane *plane, bool state)\n{\n\tenum pipe pipe;\n\tbool cur_state;\n\n\tcur_state = plane->get_hw_state(plane, &pipe);\n\n\tI915_STATE_WARN(cur_state != state,\n\t\t\t\"%s assertion failure (expected %s, current %s)\\n\",\n\t\t\tplane->base.name, onoff(state), onoff(cur_state));\n}\n\n#define assert_plane_enabled(p) assert_plane(p, true)\n#define assert_plane_disabled(p) assert_plane(p, false)\n\nstatic void assert_planes_disabled(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_plane *plane;\n\n\tfor_each_intel_plane_on_crtc(&dev_priv->drm, crtc, plane)\n\t\tassert_plane_disabled(plane);\n}\n\nstatic void assert_vblank_disabled(struct drm_crtc *crtc)\n{\n\tif (I915_STATE_WARN_ON(drm_crtc_vblank_get(crtc) == 0))\n\t\tdrm_crtc_vblank_put(crtc);\n}\n\nvoid assert_pch_transcoder_disabled(struct drm_i915_private *dev_priv,\n\t\t\t\t    enum pipe pipe)\n{\n\tu32 val;\n\tbool enabled;\n\n\tval = intel_de_read(dev_priv, PCH_TRANSCONF(pipe));\n\tenabled = !!(val & TRANS_ENABLE);\n\tI915_STATE_WARN(enabled,\n\t     \"transcoder assertion failed, should be off on pipe %c but is still active\\n\",\n\t     pipe_name(pipe));\n}\n\nstatic void assert_pch_dp_disabled(struct drm_i915_private *dev_priv,\n\t\t\t\t   enum pipe pipe, enum port port,\n\t\t\t\t   i915_reg_t dp_reg)\n{\n\tenum pipe port_pipe;\n\tbool state;\n\n\tstate = intel_dp_port_enabled(dev_priv, dp_reg, port, &port_pipe);\n\n\tI915_STATE_WARN(state && port_pipe == pipe,\n\t\t\t\"PCH DP %c enabled on transcoder %c, should be disabled\\n\",\n\t\t\tport_name(port), pipe_name(pipe));\n\n\tI915_STATE_WARN(HAS_PCH_IBX(dev_priv) && !state && port_pipe == PIPE_B,\n\t\t\t\"IBX PCH DP %c still using transcoder B\\n\",\n\t\t\tport_name(port));\n}\n\nstatic void assert_pch_hdmi_disabled(struct drm_i915_private *dev_priv,\n\t\t\t\t     enum pipe pipe, enum port port,\n\t\t\t\t     i915_reg_t hdmi_reg)\n{\n\tenum pipe port_pipe;\n\tbool state;\n\n\tstate = intel_sdvo_port_enabled(dev_priv, hdmi_reg, &port_pipe);\n\n\tI915_STATE_WARN(state && port_pipe == pipe,\n\t\t\t\"PCH HDMI %c enabled on transcoder %c, should be disabled\\n\",\n\t\t\tport_name(port), pipe_name(pipe));\n\n\tI915_STATE_WARN(HAS_PCH_IBX(dev_priv) && !state && port_pipe == PIPE_B,\n\t\t\t\"IBX PCH HDMI %c still using transcoder B\\n\",\n\t\t\tport_name(port));\n}\n\nstatic void assert_pch_ports_disabled(struct drm_i915_private *dev_priv,\n\t\t\t\t      enum pipe pipe)\n{\n\tenum pipe port_pipe;\n\n\tassert_pch_dp_disabled(dev_priv, pipe, PORT_B, PCH_DP_B);\n\tassert_pch_dp_disabled(dev_priv, pipe, PORT_C, PCH_DP_C);\n\tassert_pch_dp_disabled(dev_priv, pipe, PORT_D, PCH_DP_D);\n\n\tI915_STATE_WARN(intel_crt_port_enabled(dev_priv, PCH_ADPA, &port_pipe) &&\n\t\t\tport_pipe == pipe,\n\t\t\t\"PCH VGA enabled on transcoder %c, should be disabled\\n\",\n\t\t\tpipe_name(pipe));\n\n\tI915_STATE_WARN(intel_lvds_port_enabled(dev_priv, PCH_LVDS, &port_pipe) &&\n\t\t\tport_pipe == pipe,\n\t\t\t\"PCH LVDS enabled on transcoder %c, should be disabled\\n\",\n\t\t\tpipe_name(pipe));\n\n\t/* PCH SDVOB multiplex with HDMIB */\n\tassert_pch_hdmi_disabled(dev_priv, pipe, PORT_B, PCH_HDMIB);\n\tassert_pch_hdmi_disabled(dev_priv, pipe, PORT_C, PCH_HDMIC);\n\tassert_pch_hdmi_disabled(dev_priv, pipe, PORT_D, PCH_HDMID);\n}\n\nstatic void _vlv_enable_pll(struct intel_crtc *crtc,\n\t\t\t    const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tintel_de_write(dev_priv, DPLL(pipe), pipe_config->dpll_hw_state.dpll);\n\tintel_de_posting_read(dev_priv, DPLL(pipe));\n\tudelay(150);\n\n\tif (intel_de_wait_for_set(dev_priv, DPLL(pipe), DPLL_LOCK_VLV, 1))\n\t\tdrm_err(&dev_priv->drm, \"DPLL %d failed to lock\\n\", pipe);\n}\n\nstatic void vlv_enable_pll(struct intel_crtc *crtc,\n\t\t\t   const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tassert_pipe_disabled(dev_priv, pipe_config->cpu_transcoder);\n\n\t/* PLL is protected by panel, make sure we can write it */\n\tassert_panel_unlocked(dev_priv, pipe);\n\n\tif (pipe_config->dpll_hw_state.dpll & DPLL_VCO_ENABLE)\n\t\t_vlv_enable_pll(crtc, pipe_config);\n\n\tintel_de_write(dev_priv, DPLL_MD(pipe),\n\t\t       pipe_config->dpll_hw_state.dpll_md);\n\tintel_de_posting_read(dev_priv, DPLL_MD(pipe));\n}\n\n\nstatic void _chv_enable_pll(struct intel_crtc *crtc,\n\t\t\t    const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tenum dpio_channel port = vlv_pipe_to_channel(pipe);\n\tu32 tmp;\n\n\tvlv_dpio_get(dev_priv);\n\n\t/* Enable back the 10bit clock to display controller */\n\ttmp = vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW14(port));\n\ttmp |= DPIO_DCLKP_EN;\n\tvlv_dpio_write(dev_priv, pipe, CHV_CMN_DW14(port), tmp);\n\n\tvlv_dpio_put(dev_priv);\n\n\t/*\n\t * Need to wait > 100ns between dclkp clock enable bit and PLL enable.\n\t */\n\tudelay(1);\n\n\t/* Enable PLL */\n\tintel_de_write(dev_priv, DPLL(pipe), pipe_config->dpll_hw_state.dpll);\n\n\t/* Check PLL is locked */\n\tif (intel_de_wait_for_set(dev_priv, DPLL(pipe), DPLL_LOCK_VLV, 1))\n\t\tdrm_err(&dev_priv->drm, \"PLL %d failed to lock\\n\", pipe);\n}\n\nstatic void chv_enable_pll(struct intel_crtc *crtc,\n\t\t\t   const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tassert_pipe_disabled(dev_priv, pipe_config->cpu_transcoder);\n\n\t/* PLL is protected by panel, make sure we can write it */\n\tassert_panel_unlocked(dev_priv, pipe);\n\n\tif (pipe_config->dpll_hw_state.dpll & DPLL_VCO_ENABLE)\n\t\t_chv_enable_pll(crtc, pipe_config);\n\n\tif (pipe != PIPE_A) {\n\t\t/*\n\t\t * WaPixelRepeatModeFixForC0:chv\n\t\t *\n\t\t * DPLLCMD is AWOL. Use chicken bits to propagate\n\t\t * the value from DPLLBMD to either pipe B or C.\n\t\t */\n\t\tintel_de_write(dev_priv, CBR4_VLV, CBR_DPLLBMD_PIPE(pipe));\n\t\tintel_de_write(dev_priv, DPLL_MD(PIPE_B),\n\t\t\t       pipe_config->dpll_hw_state.dpll_md);\n\t\tintel_de_write(dev_priv, CBR4_VLV, 0);\n\t\tdev_priv->chv_dpll_md[pipe] = pipe_config->dpll_hw_state.dpll_md;\n\n\t\t/*\n\t\t * DPLLB VGA mode also seems to cause problems.\n\t\t * We should always have it disabled.\n\t\t */\n\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t    (intel_de_read(dev_priv, DPLL(PIPE_B)) &\n\t\t\t     DPLL_VGA_MODE_DIS) == 0);\n\t} else {\n\t\tintel_de_write(dev_priv, DPLL_MD(pipe),\n\t\t\t       pipe_config->dpll_hw_state.dpll_md);\n\t\tintel_de_posting_read(dev_priv, DPLL_MD(pipe));\n\t}\n}\n\nstatic bool i9xx_has_pps(struct drm_i915_private *dev_priv)\n{\n\tif (IS_I830(dev_priv))\n\t\treturn false;\n\n\treturn IS_PINEVIEW(dev_priv) || IS_MOBILE(dev_priv);\n}\n\nstatic void i9xx_enable_pll(struct intel_crtc *crtc,\n\t\t\t    const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\ti915_reg_t reg = DPLL(crtc->pipe);\n\tu32 dpll = crtc_state->dpll_hw_state.dpll;\n\tint i;\n\n\tassert_pipe_disabled(dev_priv, crtc_state->cpu_transcoder);\n\n\t/* PLL is protected by panel, make sure we can write it */\n\tif (i9xx_has_pps(dev_priv))\n\t\tassert_panel_unlocked(dev_priv, crtc->pipe);\n\n\t/*\n\t * Apparently we need to have VGA mode enabled prior to changing\n\t * the P1/P2 dividers. Otherwise the DPLL will keep using the old\n\t * dividers, even though the register value does change.\n\t */\n\tintel_de_write(dev_priv, reg, dpll & ~DPLL_VGA_MODE_DIS);\n\tintel_de_write(dev_priv, reg, dpll);\n\n\t/* Wait for the clocks to stabilize. */\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(150);\n\n\tif (INTEL_GEN(dev_priv) >= 4) {\n\t\tintel_de_write(dev_priv, DPLL_MD(crtc->pipe),\n\t\t\t       crtc_state->dpll_hw_state.dpll_md);\n\t} else {\n\t\t/* The pixel multiplier can only be updated once the\n\t\t * DPLL is enabled and the clocks are stable.\n\t\t *\n\t\t * So write it again.\n\t\t */\n\t\tintel_de_write(dev_priv, reg, dpll);\n\t}\n\n\t/* We do this three times for luck */\n\tfor (i = 0; i < 3; i++) {\n\t\tintel_de_write(dev_priv, reg, dpll);\n\t\tintel_de_posting_read(dev_priv, reg);\n\t\tudelay(150); /* wait for warmup */\n\t}\n}\n\nstatic void i9xx_disable_pll(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\t/* Don't disable pipe or pipe PLLs if needed */\n\tif (IS_I830(dev_priv))\n\t\treturn;\n\n\t/* Make sure the pipe isn't still relying on us */\n\tassert_pipe_disabled(dev_priv, crtc_state->cpu_transcoder);\n\n\tintel_de_write(dev_priv, DPLL(pipe), DPLL_VGA_MODE_DIS);\n\tintel_de_posting_read(dev_priv, DPLL(pipe));\n}\n\nstatic void vlv_disable_pll(struct drm_i915_private *dev_priv, enum pipe pipe)\n{\n\tu32 val;\n\n\t/* Make sure the pipe isn't still relying on us */\n\tassert_pipe_disabled(dev_priv, (enum transcoder)pipe);\n\n\tval = DPLL_INTEGRATED_REF_CLK_VLV |\n\t\tDPLL_REF_CLK_ENABLE_VLV | DPLL_VGA_MODE_DIS;\n\tif (pipe != PIPE_A)\n\t\tval |= DPLL_INTEGRATED_CRI_CLK_VLV;\n\n\tintel_de_write(dev_priv, DPLL(pipe), val);\n\tintel_de_posting_read(dev_priv, DPLL(pipe));\n}\n\nstatic void chv_disable_pll(struct drm_i915_private *dev_priv, enum pipe pipe)\n{\n\tenum dpio_channel port = vlv_pipe_to_channel(pipe);\n\tu32 val;\n\n\t/* Make sure the pipe isn't still relying on us */\n\tassert_pipe_disabled(dev_priv, (enum transcoder)pipe);\n\n\tval = DPLL_SSC_REF_CLK_CHV |\n\t\tDPLL_REF_CLK_ENABLE_VLV | DPLL_VGA_MODE_DIS;\n\tif (pipe != PIPE_A)\n\t\tval |= DPLL_INTEGRATED_CRI_CLK_VLV;\n\n\tintel_de_write(dev_priv, DPLL(pipe), val);\n\tintel_de_posting_read(dev_priv, DPLL(pipe));\n\n\tvlv_dpio_get(dev_priv);\n\n\t/* Disable 10bit clock to display controller */\n\tval = vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW14(port));\n\tval &= ~DPIO_DCLKP_EN;\n\tvlv_dpio_write(dev_priv, pipe, CHV_CMN_DW14(port), val);\n\n\tvlv_dpio_put(dev_priv);\n}\n\nvoid vlv_wait_port_ready(struct drm_i915_private *dev_priv,\n\t\t\t struct intel_digital_port *dig_port,\n\t\t\t unsigned int expected_mask)\n{\n\tu32 port_mask;\n\ti915_reg_t dpll_reg;\n\n\tswitch (dig_port->base.port) {\n\tcase PORT_B:\n\t\tport_mask = DPLL_PORTB_READY_MASK;\n\t\tdpll_reg = DPLL(0);\n\t\tbreak;\n\tcase PORT_C:\n\t\tport_mask = DPLL_PORTC_READY_MASK;\n\t\tdpll_reg = DPLL(0);\n\t\texpected_mask <<= 4;\n\t\tbreak;\n\tcase PORT_D:\n\t\tport_mask = DPLL_PORTD_READY_MASK;\n\t\tdpll_reg = DPIO_PHY_STATUS;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (intel_de_wait_for_register(dev_priv, dpll_reg,\n\t\t\t\t       port_mask, expected_mask, 1000))\n\t\tdrm_WARN(&dev_priv->drm, 1,\n\t\t\t \"timed out waiting for [ENCODER:%d:%s] port ready: got 0x%x, expected 0x%x\\n\",\n\t\t\t dig_port->base.base.base.id, dig_port->base.base.name,\n\t\t\t intel_de_read(dev_priv, dpll_reg) & port_mask,\n\t\t\t expected_mask);\n}\n\nstatic void ilk_enable_pch_transcoder(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\ti915_reg_t reg;\n\tu32 val, pipeconf_val;\n\n\t/* Make sure PCH DPLL is enabled */\n\tassert_shared_dpll_enabled(dev_priv, crtc_state->shared_dpll);\n\n\t/* FDI must be feeding us bits for PCH ports */\n\tassert_fdi_tx_enabled(dev_priv, pipe);\n\tassert_fdi_rx_enabled(dev_priv, pipe);\n\n\tif (HAS_PCH_CPT(dev_priv)) {\n\t\treg = TRANS_CHICKEN2(pipe);\n\t\tval = intel_de_read(dev_priv, reg);\n\t\t/*\n\t\t * Workaround: Set the timing override bit\n\t\t * before enabling the pch transcoder.\n\t\t */\n\t\tval |= TRANS_CHICKEN2_TIMING_OVERRIDE;\n\t\t/* Configure frame start delay to match the CPU */\n\t\tval &= ~TRANS_CHICKEN2_FRAME_START_DELAY_MASK;\n\t\tval |= TRANS_CHICKEN2_FRAME_START_DELAY(0);\n\t\tintel_de_write(dev_priv, reg, val);\n\t}\n\n\treg = PCH_TRANSCONF(pipe);\n\tval = intel_de_read(dev_priv, reg);\n\tpipeconf_val = intel_de_read(dev_priv, PIPECONF(pipe));\n\n\tif (HAS_PCH_IBX(dev_priv)) {\n\t\t/* Configure frame start delay to match the CPU */\n\t\tval &= ~TRANS_FRAME_START_DELAY_MASK;\n\t\tval |= TRANS_FRAME_START_DELAY(0);\n\n\t\t/*\n\t\t * Make the BPC in transcoder be consistent with\n\t\t * that in pipeconf reg. For HDMI we must use 8bpc\n\t\t * here for both 8bpc and 12bpc.\n\t\t */\n\t\tval &= ~PIPECONF_BPC_MASK;\n\t\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))\n\t\t\tval |= PIPECONF_8BPC;\n\t\telse\n\t\t\tval |= pipeconf_val & PIPECONF_BPC_MASK;\n\t}\n\n\tval &= ~TRANS_INTERLACE_MASK;\n\tif ((pipeconf_val & PIPECONF_INTERLACE_MASK) == PIPECONF_INTERLACED_ILK) {\n\t\tif (HAS_PCH_IBX(dev_priv) &&\n\t\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_SDVO))\n\t\t\tval |= TRANS_LEGACY_INTERLACED_ILK;\n\t\telse\n\t\t\tval |= TRANS_INTERLACED;\n\t} else {\n\t\tval |= TRANS_PROGRESSIVE;\n\t}\n\n\tintel_de_write(dev_priv, reg, val | TRANS_ENABLE);\n\tif (intel_de_wait_for_set(dev_priv, reg, TRANS_STATE_ENABLE, 100))\n\t\tdrm_err(&dev_priv->drm, \"failed to enable transcoder %c\\n\",\n\t\t\tpipe_name(pipe));\n}\n\nstatic void lpt_enable_pch_transcoder(struct drm_i915_private *dev_priv,\n\t\t\t\t      enum transcoder cpu_transcoder)\n{\n\tu32 val, pipeconf_val;\n\n\t/* FDI must be feeding us bits for PCH ports */\n\tassert_fdi_tx_enabled(dev_priv, (enum pipe) cpu_transcoder);\n\tassert_fdi_rx_enabled(dev_priv, PIPE_A);\n\n\tval = intel_de_read(dev_priv, TRANS_CHICKEN2(PIPE_A));\n\t/* Workaround: set timing override bit. */\n\tval |= TRANS_CHICKEN2_TIMING_OVERRIDE;\n\t/* Configure frame start delay to match the CPU */\n\tval &= ~TRANS_CHICKEN2_FRAME_START_DELAY_MASK;\n\tval |= TRANS_CHICKEN2_FRAME_START_DELAY(0);\n\tintel_de_write(dev_priv, TRANS_CHICKEN2(PIPE_A), val);\n\n\tval = TRANS_ENABLE;\n\tpipeconf_val = intel_de_read(dev_priv, PIPECONF(cpu_transcoder));\n\n\tif ((pipeconf_val & PIPECONF_INTERLACE_MASK_HSW) ==\n\t    PIPECONF_INTERLACED_ILK)\n\t\tval |= TRANS_INTERLACED;\n\telse\n\t\tval |= TRANS_PROGRESSIVE;\n\n\tintel_de_write(dev_priv, LPT_TRANSCONF, val);\n\tif (intel_de_wait_for_set(dev_priv, LPT_TRANSCONF,\n\t\t\t\t  TRANS_STATE_ENABLE, 100))\n\t\tdrm_err(&dev_priv->drm, \"Failed to enable PCH transcoder\\n\");\n}\n\nstatic void ilk_disable_pch_transcoder(struct drm_i915_private *dev_priv,\n\t\t\t\t       enum pipe pipe)\n{\n\ti915_reg_t reg;\n\tu32 val;\n\n\t/* FDI relies on the transcoder */\n\tassert_fdi_tx_disabled(dev_priv, pipe);\n\tassert_fdi_rx_disabled(dev_priv, pipe);\n\n\t/* Ports must be off as well */\n\tassert_pch_ports_disabled(dev_priv, pipe);\n\n\treg = PCH_TRANSCONF(pipe);\n\tval = intel_de_read(dev_priv, reg);\n\tval &= ~TRANS_ENABLE;\n\tintel_de_write(dev_priv, reg, val);\n\t/* wait for PCH transcoder off, transcoder state */\n\tif (intel_de_wait_for_clear(dev_priv, reg, TRANS_STATE_ENABLE, 50))\n\t\tdrm_err(&dev_priv->drm, \"failed to disable transcoder %c\\n\",\n\t\t\tpipe_name(pipe));\n\n\tif (HAS_PCH_CPT(dev_priv)) {\n\t\t/* Workaround: Clear the timing override chicken bit again. */\n\t\treg = TRANS_CHICKEN2(pipe);\n\t\tval = intel_de_read(dev_priv, reg);\n\t\tval &= ~TRANS_CHICKEN2_TIMING_OVERRIDE;\n\t\tintel_de_write(dev_priv, reg, val);\n\t}\n}\n\nvoid lpt_disable_pch_transcoder(struct drm_i915_private *dev_priv)\n{\n\tu32 val;\n\n\tval = intel_de_read(dev_priv, LPT_TRANSCONF);\n\tval &= ~TRANS_ENABLE;\n\tintel_de_write(dev_priv, LPT_TRANSCONF, val);\n\t/* wait for PCH transcoder off, transcoder state */\n\tif (intel_de_wait_for_clear(dev_priv, LPT_TRANSCONF,\n\t\t\t\t    TRANS_STATE_ENABLE, 50))\n\t\tdrm_err(&dev_priv->drm, \"Failed to disable PCH transcoder\\n\");\n\n\t/* Workaround: clear timing override bit. */\n\tval = intel_de_read(dev_priv, TRANS_CHICKEN2(PIPE_A));\n\tval &= ~TRANS_CHICKEN2_TIMING_OVERRIDE;\n\tintel_de_write(dev_priv, TRANS_CHICKEN2(PIPE_A), val);\n}\n\nenum pipe intel_crtc_pch_transcoder(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tif (HAS_PCH_LPT(dev_priv))\n\t\treturn PIPE_A;\n\telse\n\t\treturn crtc->pipe;\n}\n\nstatic u32 intel_crtc_max_vblank_count(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\n\t/*\n\t * On i965gm the hardware frame counter reads\n\t * zero when the TV encoder is enabled :(\n\t */\n\tif (IS_I965GM(dev_priv) &&\n\t    (crtc_state->output_types & BIT(INTEL_OUTPUT_TVOUT)))\n\t\treturn 0;\n\n\tif (INTEL_GEN(dev_priv) >= 5 || IS_G4X(dev_priv))\n\t\treturn 0xffffffff; /* full 32 bit counter */\n\telse if (INTEL_GEN(dev_priv) >= 3)\n\t\treturn 0xffffff; /* only 24 bits of frame count */\n\telse\n\t\treturn 0; /* Gen2 doesn't have a hardware frame counter */\n}\n\nvoid intel_crtc_vblank_on(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tassert_vblank_disabled(&crtc->base);\n\tdrm_crtc_set_max_vblank_count(&crtc->base,\n\t\t\t\t      intel_crtc_max_vblank_count(crtc_state));\n\tdrm_crtc_vblank_on(&crtc->base);\n}\n\nvoid intel_crtc_vblank_off(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tdrm_crtc_vblank_off(&crtc->base);\n\tassert_vblank_disabled(&crtc->base);\n}\n\nvoid intel_enable_pipe(const struct intel_crtc_state *new_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(new_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = new_crtc_state->cpu_transcoder;\n\tenum pipe pipe = crtc->pipe;\n\ti915_reg_t reg;\n\tu32 val;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"enabling pipe %c\\n\", pipe_name(pipe));\n\n\tassert_planes_disabled(crtc);\n\n\t/*\n\t * A pipe without a PLL won't actually be able to drive bits from\n\t * a plane.  On ILK+ the pipe PLLs are integrated, so we don't\n\t * need the check.\n\t */\n\tif (HAS_GMCH(dev_priv)) {\n\t\tif (intel_crtc_has_type(new_crtc_state, INTEL_OUTPUT_DSI))\n\t\t\tassert_dsi_pll_enabled(dev_priv);\n\t\telse\n\t\t\tassert_pll_enabled(dev_priv, pipe);\n\t} else {\n\t\tif (new_crtc_state->has_pch_encoder) {\n\t\t\t/* if driving the PCH, we need FDI enabled */\n\t\t\tassert_fdi_rx_pll_enabled(dev_priv,\n\t\t\t\t\t\t  intel_crtc_pch_transcoder(crtc));\n\t\t\tassert_fdi_tx_pll_enabled(dev_priv,\n\t\t\t\t\t\t  (enum pipe) cpu_transcoder);\n\t\t}\n\t\t/* FIXME: assert CPU port conditions for SNB+ */\n\t}\n\n\ttrace_intel_pipe_enable(crtc);\n\n\treg = PIPECONF(cpu_transcoder);\n\tval = intel_de_read(dev_priv, reg);\n\tif (val & PIPECONF_ENABLE) {\n\t\t/* we keep both pipes enabled on 830 */\n\t\tdrm_WARN_ON(&dev_priv->drm, !IS_I830(dev_priv));\n\t\treturn;\n\t}\n\n\tintel_de_write(dev_priv, reg, val | PIPECONF_ENABLE);\n\tintel_de_posting_read(dev_priv, reg);\n\n\t/*\n\t * Until the pipe starts PIPEDSL reads will return a stale value,\n\t * which causes an apparent vblank timestamp jump when PIPEDSL\n\t * resets to its proper value. That also messes up the frame count\n\t * when it's derived from the timestamps. So let's wait for the\n\t * pipe to start properly before we call drm_crtc_vblank_on()\n\t */\n\tif (intel_crtc_max_vblank_count(new_crtc_state) == 0)\n\t\tintel_wait_for_pipe_scanline_moving(crtc);\n}\n\nvoid intel_disable_pipe(const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = old_crtc_state->cpu_transcoder;\n\tenum pipe pipe = crtc->pipe;\n\ti915_reg_t reg;\n\tu32 val;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"disabling pipe %c\\n\", pipe_name(pipe));\n\n\t/*\n\t * Make sure planes won't keep trying to pump pixels to us,\n\t * or we might hang the display.\n\t */\n\tassert_planes_disabled(crtc);\n\n\ttrace_intel_pipe_disable(crtc);\n\n\treg = PIPECONF(cpu_transcoder);\n\tval = intel_de_read(dev_priv, reg);\n\tif ((val & PIPECONF_ENABLE) == 0)\n\t\treturn;\n\n\t/*\n\t * Double wide has implications for planes\n\t * so best keep it disabled when not needed.\n\t */\n\tif (old_crtc_state->double_wide)\n\t\tval &= ~PIPECONF_DOUBLE_WIDE;\n\n\t/* Don't disable pipe or pipe PLLs if needed */\n\tif (!IS_I830(dev_priv))\n\t\tval &= ~PIPECONF_ENABLE;\n\n\tintel_de_write(dev_priv, reg, val);\n\tif ((val & PIPECONF_ENABLE) == 0)\n\t\tintel_wait_for_pipe_off(old_crtc_state);\n}\n\nstatic unsigned int intel_tile_size(const struct drm_i915_private *dev_priv)\n{\n\treturn IS_GEN(dev_priv, 2) ? 2048 : 4096;\n}\n\nstatic bool is_ccs_plane(const struct drm_framebuffer *fb, int plane)\n{\n\tif (!is_ccs_modifier(fb->modifier))\n\t\treturn false;\n\n\treturn plane >= fb->format->num_planes / 2;\n}\n\nstatic bool is_gen12_ccs_modifier(u64 modifier)\n{\n\treturn modifier == I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS ||\n\t       modifier == I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS;\n\n}\n\nstatic bool is_gen12_ccs_plane(const struct drm_framebuffer *fb, int plane)\n{\n\treturn is_gen12_ccs_modifier(fb->modifier) && is_ccs_plane(fb, plane);\n}\n\nstatic bool is_aux_plane(const struct drm_framebuffer *fb, int plane)\n{\n\tif (is_ccs_modifier(fb->modifier))\n\t\treturn is_ccs_plane(fb, plane);\n\n\treturn plane == 1;\n}\n\nstatic int main_to_ccs_plane(const struct drm_framebuffer *fb, int main_plane)\n{\n\tdrm_WARN_ON(fb->dev, !is_ccs_modifier(fb->modifier) ||\n\t\t    (main_plane && main_plane >= fb->format->num_planes / 2));\n\n\treturn fb->format->num_planes / 2 + main_plane;\n}\n\nstatic int ccs_to_main_plane(const struct drm_framebuffer *fb, int ccs_plane)\n{\n\tdrm_WARN_ON(fb->dev, !is_ccs_modifier(fb->modifier) ||\n\t\t    ccs_plane < fb->format->num_planes / 2);\n\n\treturn ccs_plane - fb->format->num_planes / 2;\n}\n\n/* Return either the main plane's CCS or - if not a CCS FB - UV plane */\nint intel_main_to_aux_plane(const struct drm_framebuffer *fb, int main_plane)\n{\n\tif (is_ccs_modifier(fb->modifier))\n\t\treturn main_to_ccs_plane(fb, main_plane);\n\n\treturn 1;\n}\n\nbool\nintel_format_info_is_yuv_semiplanar(const struct drm_format_info *info,\n\t\t\t\t    uint64_t modifier)\n{\n\treturn info->is_yuv &&\n\t       info->num_planes == (is_ccs_modifier(modifier) ? 4 : 2);\n}\n\nstatic bool is_semiplanar_uv_plane(const struct drm_framebuffer *fb,\n\t\t\t\t   int color_plane)\n{\n\treturn intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier) &&\n\t       color_plane == 1;\n}\n\nstatic unsigned int\nintel_tile_width_bytes(const struct drm_framebuffer *fb, int color_plane)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(fb->dev);\n\tunsigned int cpp = fb->format->cpp[color_plane];\n\n\tswitch (fb->modifier) {\n\tcase DRM_FORMAT_MOD_LINEAR:\n\t\treturn intel_tile_size(dev_priv);\n\tcase I915_FORMAT_MOD_X_TILED:\n\t\tif (IS_GEN(dev_priv, 2))\n\t\t\treturn 128;\n\t\telse\n\t\t\treturn 512;\n\tcase I915_FORMAT_MOD_Y_TILED_CCS:\n\t\tif (is_ccs_plane(fb, color_plane))\n\t\t\treturn 128;\n\t\tfallthrough;\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS:\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS:\n\t\tif (is_ccs_plane(fb, color_plane))\n\t\t\treturn 64;\n\t\tfallthrough;\n\tcase I915_FORMAT_MOD_Y_TILED:\n\t\tif (IS_GEN(dev_priv, 2) || HAS_128_BYTE_Y_TILING(dev_priv))\n\t\t\treturn 128;\n\t\telse\n\t\t\treturn 512;\n\tcase I915_FORMAT_MOD_Yf_TILED_CCS:\n\t\tif (is_ccs_plane(fb, color_plane))\n\t\t\treturn 128;\n\t\tfallthrough;\n\tcase I915_FORMAT_MOD_Yf_TILED:\n\t\tswitch (cpp) {\n\t\tcase 1:\n\t\t\treturn 64;\n\t\tcase 2:\n\t\tcase 4:\n\t\t\treturn 128;\n\t\tcase 8:\n\t\tcase 16:\n\t\t\treturn 256;\n\t\tdefault:\n\t\t\tMISSING_CASE(cpp);\n\t\t\treturn cpp;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(fb->modifier);\n\t\treturn cpp;\n\t}\n}\n\nstatic unsigned int\nintel_tile_height(const struct drm_framebuffer *fb, int color_plane)\n{\n\tif (is_gen12_ccs_plane(fb, color_plane))\n\t\treturn 1;\n\n\treturn intel_tile_size(to_i915(fb->dev)) /\n\t\tintel_tile_width_bytes(fb, color_plane);\n}\n\n/* Return the tile dimensions in pixel units */\nstatic void intel_tile_dims(const struct drm_framebuffer *fb, int color_plane,\n\t\t\t    unsigned int *tile_width,\n\t\t\t    unsigned int *tile_height)\n{\n\tunsigned int tile_width_bytes = intel_tile_width_bytes(fb, color_plane);\n\tunsigned int cpp = fb->format->cpp[color_plane];\n\n\t*tile_width = tile_width_bytes / cpp;\n\t*tile_height = intel_tile_height(fb, color_plane);\n}\n\nstatic unsigned int intel_tile_row_size(const struct drm_framebuffer *fb,\n\t\t\t\t\tint color_plane)\n{\n\tunsigned int tile_width, tile_height;\n\n\tintel_tile_dims(fb, color_plane, &tile_width, &tile_height);\n\n\treturn fb->pitches[color_plane] * tile_height;\n}\n\nunsigned int\nintel_fb_align_height(const struct drm_framebuffer *fb,\n\t\t      int color_plane, unsigned int height)\n{\n\tunsigned int tile_height = intel_tile_height(fb, color_plane);\n\n\treturn ALIGN(height, tile_height);\n}\n\nunsigned int intel_rotation_info_size(const struct intel_rotation_info *rot_info)\n{\n\tunsigned int size = 0;\n\tint i;\n\n\tfor (i = 0 ; i < ARRAY_SIZE(rot_info->plane); i++)\n\t\tsize += rot_info->plane[i].width * rot_info->plane[i].height;\n\n\treturn size;\n}\n\nunsigned int intel_remapped_info_size(const struct intel_remapped_info *rem_info)\n{\n\tunsigned int size = 0;\n\tint i;\n\n\tfor (i = 0 ; i < ARRAY_SIZE(rem_info->plane); i++)\n\t\tsize += rem_info->plane[i].width * rem_info->plane[i].height;\n\n\treturn size;\n}\n\nstatic void\nintel_fill_fb_ggtt_view(struct i915_ggtt_view *view,\n\t\t\tconst struct drm_framebuffer *fb,\n\t\t\tunsigned int rotation)\n{\n\tview->type = I915_GGTT_VIEW_NORMAL;\n\tif (drm_rotation_90_or_270(rotation)) {\n\t\tview->type = I915_GGTT_VIEW_ROTATED;\n\t\tview->rotated = to_intel_framebuffer(fb)->rot_info;\n\t}\n}\n\nstatic unsigned int intel_cursor_alignment(const struct drm_i915_private *dev_priv)\n{\n\tif (IS_I830(dev_priv))\n\t\treturn 16 * 1024;\n\telse if (IS_I85X(dev_priv))\n\t\treturn 256;\n\telse if (IS_I845G(dev_priv) || IS_I865G(dev_priv))\n\t\treturn 32;\n\telse\n\t\treturn 4 * 1024;\n}\n\nstatic unsigned int intel_linear_alignment(const struct drm_i915_private *dev_priv)\n{\n\tif (INTEL_GEN(dev_priv) >= 9)\n\t\treturn 256 * 1024;\n\telse if (IS_I965G(dev_priv) || IS_I965GM(dev_priv) ||\n\t\t IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\treturn 128 * 1024;\n\telse if (INTEL_GEN(dev_priv) >= 4)\n\t\treturn 4 * 1024;\n\telse\n\t\treturn 0;\n}\n\nstatic unsigned int intel_surf_alignment(const struct drm_framebuffer *fb,\n\t\t\t\t\t int color_plane)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(fb->dev);\n\n\t/* AUX_DIST needs only 4K alignment */\n\tif ((INTEL_GEN(dev_priv) < 12 && is_aux_plane(fb, color_plane)) ||\n\t    is_ccs_plane(fb, color_plane))\n\t\treturn 4096;\n\n\tswitch (fb->modifier) {\n\tcase DRM_FORMAT_MOD_LINEAR:\n\t\treturn intel_linear_alignment(dev_priv);\n\tcase I915_FORMAT_MOD_X_TILED:\n\t\tif (INTEL_GEN(dev_priv) >= 9)\n\t\t\treturn 256 * 1024;\n\t\treturn 0;\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS:\n\t\tif (is_semiplanar_uv_plane(fb, color_plane))\n\t\t\treturn intel_tile_row_size(fb, color_plane);\n\t\tfallthrough;\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS:\n\t\treturn 16 * 1024;\n\tcase I915_FORMAT_MOD_Y_TILED_CCS:\n\tcase I915_FORMAT_MOD_Yf_TILED_CCS:\n\tcase I915_FORMAT_MOD_Y_TILED:\n\t\tif (INTEL_GEN(dev_priv) >= 12 &&\n\t\t    is_semiplanar_uv_plane(fb, color_plane))\n\t\t\treturn intel_tile_row_size(fb, color_plane);\n\t\tfallthrough;\n\tcase I915_FORMAT_MOD_Yf_TILED:\n\t\treturn 1 * 1024 * 1024;\n\tdefault:\n\t\tMISSING_CASE(fb->modifier);\n\t\treturn 0;\n\t}\n}\n\nstatic bool intel_plane_uses_fence(const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\n\treturn INTEL_GEN(dev_priv) < 4 ||\n\t\t(plane->has_fbc &&\n\t\t plane_state->view.type == I915_GGTT_VIEW_NORMAL);\n}\n\nstruct i915_vma *\nintel_pin_and_fence_fb_obj(struct drm_framebuffer *fb,\n\t\t\t   const struct i915_ggtt_view *view,\n\t\t\t   bool uses_fence,\n\t\t\t   unsigned long *out_flags)\n{\n\tstruct drm_device *dev = fb->dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_i915_gem_object *obj = intel_fb_obj(fb);\n\tintel_wakeref_t wakeref;\n\tstruct i915_vma *vma;\n\tunsigned int pinctl;\n\tu32 alignment;\n\n\tif (drm_WARN_ON(dev, !i915_gem_object_is_framebuffer(obj)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\talignment = intel_surf_alignment(fb, 0);\n\tif (drm_WARN_ON(dev, alignment && !is_power_of_2(alignment)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Note that the w/a also requires 64 PTE of padding following the\n\t * bo. We currently fill all unused PTE with the shadow page and so\n\t * we should always have valid PTE following the scanout preventing\n\t * the VT-d warning.\n\t */\n\tif (intel_scanout_needs_vtd_wa(dev_priv) && alignment < 256 * 1024)\n\t\talignment = 256 * 1024;\n\n\t/*\n\t * Global gtt pte registers are special registers which actually forward\n\t * writes to a chunk of system memory. Which means that there is no risk\n\t * that the register values disappear as soon as we call\n\t * intel_runtime_pm_put(), so it is correct to wrap only the\n\t * pin/unpin/fence and not more.\n\t */\n\twakeref = intel_runtime_pm_get(&dev_priv->runtime_pm);\n\n\tatomic_inc(&dev_priv->gpu_error.pending_fb_pin);\n\n\t/*\n\t * Valleyview is definitely limited to scanning out the first\n\t * 512MiB. Lets presume this behaviour was inherited from the\n\t * g4x display engine and that all earlier gen are similarly\n\t * limited. Testing suggests that it is a little more\n\t * complicated than this. For example, Cherryview appears quite\n\t * happy to scanout from anywhere within its global aperture.\n\t */\n\tpinctl = 0;\n\tif (HAS_GMCH(dev_priv))\n\t\tpinctl |= PIN_MAPPABLE;\n\n\tvma = i915_gem_object_pin_to_display_plane(obj,\n\t\t\t\t\t\t   alignment, view, pinctl);\n\tif (IS_ERR(vma))\n\t\tgoto err;\n\n\tif (uses_fence && i915_vma_is_map_and_fenceable(vma)) {\n\t\tint ret;\n\n\t\t/*\n\t\t * Install a fence for tiled scan-out. Pre-i965 always needs a\n\t\t * fence, whereas 965+ only requires a fence if using\n\t\t * framebuffer compression.  For simplicity, we always, when\n\t\t * possible, install a fence as the cost is not that onerous.\n\t\t *\n\t\t * If we fail to fence the tiled scanout, then either the\n\t\t * modeset will reject the change (which is highly unlikely as\n\t\t * the affected systems, all but one, do not have unmappable\n\t\t * space) or we will not be able to enable full powersaving\n\t\t * techniques (also likely not to apply due to various limits\n\t\t * FBC and the like impose on the size of the buffer, which\n\t\t * presumably we violated anyway with this unmappable buffer).\n\t\t * Anyway, it is presumably better to stumble onwards with\n\t\t * something and try to run the system in a \"less than optimal\"\n\t\t * mode that matches the user configuration.\n\t\t */\n\t\tret = i915_vma_pin_fence(vma);\n\t\tif (ret != 0 && INTEL_GEN(dev_priv) < 4) {\n\t\t\ti915_gem_object_unpin_from_display_plane(vma);\n\t\t\tvma = ERR_PTR(ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (ret == 0 && vma->fence)\n\t\t\t*out_flags |= PLANE_HAS_FENCE;\n\t}\n\n\ti915_vma_get(vma);\nerr:\n\tatomic_dec(&dev_priv->gpu_error.pending_fb_pin);\n\tintel_runtime_pm_put(&dev_priv->runtime_pm, wakeref);\n\treturn vma;\n}\n\nvoid intel_unpin_fb_vma(struct i915_vma *vma, unsigned long flags)\n{\n\ti915_gem_object_lock(vma->obj, NULL);\n\tif (flags & PLANE_HAS_FENCE)\n\t\ti915_vma_unpin_fence(vma);\n\ti915_gem_object_unpin_from_display_plane(vma);\n\ti915_gem_object_unlock(vma->obj);\n\n\ti915_vma_put(vma);\n}\n\nstatic int intel_fb_pitch(const struct drm_framebuffer *fb, int color_plane,\n\t\t\t  unsigned int rotation)\n{\n\tif (drm_rotation_90_or_270(rotation))\n\t\treturn to_intel_framebuffer(fb)->rotated[color_plane].pitch;\n\telse\n\t\treturn fb->pitches[color_plane];\n}\n\n/*\n * Convert the x/y offsets into a linear offset.\n * Only valid with 0/180 degree rotation, which is fine since linear\n * offset is only used with linear buffers on pre-hsw and tiled buffers\n * with gen2/3, and 90/270 degree rotations isn't supported on any of them.\n */\nu32 intel_fb_xy_to_linear(int x, int y,\n\t\t\t  const struct intel_plane_state *state,\n\t\t\t  int color_plane)\n{\n\tconst struct drm_framebuffer *fb = state->hw.fb;\n\tunsigned int cpp = fb->format->cpp[color_plane];\n\tunsigned int pitch = state->color_plane[color_plane].stride;\n\n\treturn y * pitch + x * cpp;\n}\n\n/*\n * Add the x/y offsets derived from fb->offsets[] to the user\n * specified plane src x/y offsets. The resulting x/y offsets\n * specify the start of scanout from the beginning of the gtt mapping.\n */\nvoid intel_add_fb_offsets(int *x, int *y,\n\t\t\t  const struct intel_plane_state *state,\n\t\t\t  int color_plane)\n\n{\n\t*x += state->color_plane[color_plane].x;\n\t*y += state->color_plane[color_plane].y;\n}\n\nstatic u32 intel_adjust_tile_offset(int *x, int *y,\n\t\t\t\t    unsigned int tile_width,\n\t\t\t\t    unsigned int tile_height,\n\t\t\t\t    unsigned int tile_size,\n\t\t\t\t    unsigned int pitch_tiles,\n\t\t\t\t    u32 old_offset,\n\t\t\t\t    u32 new_offset)\n{\n\tunsigned int pitch_pixels = pitch_tiles * tile_width;\n\tunsigned int tiles;\n\n\tWARN_ON(old_offset & (tile_size - 1));\n\tWARN_ON(new_offset & (tile_size - 1));\n\tWARN_ON(new_offset > old_offset);\n\n\ttiles = (old_offset - new_offset) / tile_size;\n\n\t*y += tiles / pitch_tiles * tile_height;\n\t*x += tiles % pitch_tiles * tile_width;\n\n\t/* minimize x in case it got needlessly big */\n\t*y += *x / pitch_pixels * tile_height;\n\t*x %= pitch_pixels;\n\n\treturn new_offset;\n}\n\nstatic bool is_surface_linear(const struct drm_framebuffer *fb, int color_plane)\n{\n\treturn fb->modifier == DRM_FORMAT_MOD_LINEAR ||\n\t       is_gen12_ccs_plane(fb, color_plane);\n}\n\nstatic u32 intel_adjust_aligned_offset(int *x, int *y,\n\t\t\t\t       const struct drm_framebuffer *fb,\n\t\t\t\t       int color_plane,\n\t\t\t\t       unsigned int rotation,\n\t\t\t\t       unsigned int pitch,\n\t\t\t\t       u32 old_offset, u32 new_offset)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(fb->dev);\n\tunsigned int cpp = fb->format->cpp[color_plane];\n\n\tdrm_WARN_ON(&dev_priv->drm, new_offset > old_offset);\n\n\tif (!is_surface_linear(fb, color_plane)) {\n\t\tunsigned int tile_size, tile_width, tile_height;\n\t\tunsigned int pitch_tiles;\n\n\t\ttile_size = intel_tile_size(dev_priv);\n\t\tintel_tile_dims(fb, color_plane, &tile_width, &tile_height);\n\n\t\tif (drm_rotation_90_or_270(rotation)) {\n\t\t\tpitch_tiles = pitch / tile_height;\n\t\t\tswap(tile_width, tile_height);\n\t\t} else {\n\t\t\tpitch_tiles = pitch / (tile_width * cpp);\n\t\t}\n\n\t\tintel_adjust_tile_offset(x, y, tile_width, tile_height,\n\t\t\t\t\t tile_size, pitch_tiles,\n\t\t\t\t\t old_offset, new_offset);\n\t} else {\n\t\told_offset += *y * pitch + *x * cpp;\n\n\t\t*y = (old_offset - new_offset) / pitch;\n\t\t*x = ((old_offset - new_offset) - *y * pitch) / cpp;\n\t}\n\n\treturn new_offset;\n}\n\n/*\n * Adjust the tile offset by moving the difference into\n * the x/y offsets.\n */\nstatic u32 intel_plane_adjust_aligned_offset(int *x, int *y,\n\t\t\t\t\t     const struct intel_plane_state *state,\n\t\t\t\t\t     int color_plane,\n\t\t\t\t\t     u32 old_offset, u32 new_offset)\n{\n\treturn intel_adjust_aligned_offset(x, y, state->hw.fb, color_plane,\n\t\t\t\t\t   state->hw.rotation,\n\t\t\t\t\t   state->color_plane[color_plane].stride,\n\t\t\t\t\t   old_offset, new_offset);\n}\n\n/*\n * Computes the aligned offset to the base tile and adjusts\n * x, y. bytes per pixel is assumed to be a power-of-two.\n *\n * In the 90/270 rotated case, x and y are assumed\n * to be already rotated to match the rotated GTT view, and\n * pitch is the tile_height aligned framebuffer height.\n *\n * This function is used when computing the derived information\n * under intel_framebuffer, so using any of that information\n * here is not allowed. Anything under drm_framebuffer can be\n * used. This is why the user has to pass in the pitch since it\n * is specified in the rotated orientation.\n */\nstatic u32 intel_compute_aligned_offset(struct drm_i915_private *dev_priv,\n\t\t\t\t\tint *x, int *y,\n\t\t\t\t\tconst struct drm_framebuffer *fb,\n\t\t\t\t\tint color_plane,\n\t\t\t\t\tunsigned int pitch,\n\t\t\t\t\tunsigned int rotation,\n\t\t\t\t\tu32 alignment)\n{\n\tunsigned int cpp = fb->format->cpp[color_plane];\n\tu32 offset, offset_aligned;\n\n\tif (!is_surface_linear(fb, color_plane)) {\n\t\tunsigned int tile_size, tile_width, tile_height;\n\t\tunsigned int tile_rows, tiles, pitch_tiles;\n\n\t\ttile_size = intel_tile_size(dev_priv);\n\t\tintel_tile_dims(fb, color_plane, &tile_width, &tile_height);\n\n\t\tif (drm_rotation_90_or_270(rotation)) {\n\t\t\tpitch_tiles = pitch / tile_height;\n\t\t\tswap(tile_width, tile_height);\n\t\t} else {\n\t\t\tpitch_tiles = pitch / (tile_width * cpp);\n\t\t}\n\n\t\ttile_rows = *y / tile_height;\n\t\t*y %= tile_height;\n\n\t\ttiles = *x / tile_width;\n\t\t*x %= tile_width;\n\n\t\toffset = (tile_rows * pitch_tiles + tiles) * tile_size;\n\n\t\toffset_aligned = offset;\n\t\tif (alignment)\n\t\t\toffset_aligned = rounddown(offset_aligned, alignment);\n\n\t\tintel_adjust_tile_offset(x, y, tile_width, tile_height,\n\t\t\t\t\t tile_size, pitch_tiles,\n\t\t\t\t\t offset, offset_aligned);\n\t} else {\n\t\toffset = *y * pitch + *x * cpp;\n\t\toffset_aligned = offset;\n\t\tif (alignment) {\n\t\t\toffset_aligned = rounddown(offset_aligned, alignment);\n\t\t\t*y = (offset % alignment) / pitch;\n\t\t\t*x = ((offset % alignment) - *y * pitch) / cpp;\n\t\t} else {\n\t\t\t*y = *x = 0;\n\t\t}\n\t}\n\n\treturn offset_aligned;\n}\n\nstatic u32 intel_plane_compute_aligned_offset(int *x, int *y,\n\t\t\t\t\t      const struct intel_plane_state *state,\n\t\t\t\t\t      int color_plane)\n{\n\tstruct intel_plane *intel_plane = to_intel_plane(state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(intel_plane->base.dev);\n\tconst struct drm_framebuffer *fb = state->hw.fb;\n\tunsigned int rotation = state->hw.rotation;\n\tint pitch = state->color_plane[color_plane].stride;\n\tu32 alignment;\n\n\tif (intel_plane->id == PLANE_CURSOR)\n\t\talignment = intel_cursor_alignment(dev_priv);\n\telse\n\t\talignment = intel_surf_alignment(fb, color_plane);\n\n\treturn intel_compute_aligned_offset(dev_priv, x, y, fb, color_plane,\n\t\t\t\t\t    pitch, rotation, alignment);\n}\n\n/* Convert the fb->offset[] into x/y offsets */\nstatic int intel_fb_offset_to_xy(int *x, int *y,\n\t\t\t\t const struct drm_framebuffer *fb,\n\t\t\t\t int color_plane)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(fb->dev);\n\tunsigned int height;\n\tu32 alignment;\n\n\tif (INTEL_GEN(dev_priv) >= 12 &&\n\t    is_semiplanar_uv_plane(fb, color_plane))\n\t\talignment = intel_tile_row_size(fb, color_plane);\n\telse if (fb->modifier != DRM_FORMAT_MOD_LINEAR)\n\t\talignment = intel_tile_size(dev_priv);\n\telse\n\t\talignment = 0;\n\n\tif (alignment != 0 && fb->offsets[color_plane] % alignment) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Misaligned offset 0x%08x for color plane %d\\n\",\n\t\t\t    fb->offsets[color_plane], color_plane);\n\t\treturn -EINVAL;\n\t}\n\n\theight = drm_framebuffer_plane_height(fb->height, fb, color_plane);\n\theight = ALIGN(height, intel_tile_height(fb, color_plane));\n\n\t/* Catch potential overflows early */\n\tif (add_overflows_t(u32, mul_u32_u32(height, fb->pitches[color_plane]),\n\t\t\t    fb->offsets[color_plane])) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Bad offset 0x%08x or pitch %d for color plane %d\\n\",\n\t\t\t    fb->offsets[color_plane], fb->pitches[color_plane],\n\t\t\t    color_plane);\n\t\treturn -ERANGE;\n\t}\n\n\t*x = 0;\n\t*y = 0;\n\n\tintel_adjust_aligned_offset(x, y,\n\t\t\t\t    fb, color_plane, DRM_MODE_ROTATE_0,\n\t\t\t\t    fb->pitches[color_plane],\n\t\t\t\t    fb->offsets[color_plane], 0);\n\n\treturn 0;\n}\n\nstatic unsigned int intel_fb_modifier_to_tiling(u64 fb_modifier)\n{\n\tswitch (fb_modifier) {\n\tcase I915_FORMAT_MOD_X_TILED:\n\t\treturn I915_TILING_X;\n\tcase I915_FORMAT_MOD_Y_TILED:\n\tcase I915_FORMAT_MOD_Y_TILED_CCS:\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS:\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS:\n\t\treturn I915_TILING_Y;\n\tdefault:\n\t\treturn I915_TILING_NONE;\n\t}\n}\n\n/*\n * From the Sky Lake PRM:\n * \"The Color Control Surface (CCS) contains the compression status of\n *  the cache-line pairs. The compression state of the cache-line pair\n *  is specified by 2 bits in the CCS. Each CCS cache-line represents\n *  an area on the main surface of 16 x16 sets of 128 byte Y-tiled\n *  cache-line-pairs. CCS is always Y tiled.\"\n *\n * Since cache line pairs refers to horizontally adjacent cache lines,\n * each cache line in the CCS corresponds to an area of 32x16 cache\n * lines on the main surface. Since each pixel is 4 bytes, this gives\n * us a ratio of one byte in the CCS for each 8x16 pixels in the\n * main surface.\n */\nstatic const struct drm_format_info skl_ccs_formats[] = {\n\t{ .format = DRM_FORMAT_XRGB8888, .depth = 24, .num_planes = 2,\n\t  .cpp = { 4, 1, }, .hsub = 8, .vsub = 16, },\n\t{ .format = DRM_FORMAT_XBGR8888, .depth = 24, .num_planes = 2,\n\t  .cpp = { 4, 1, }, .hsub = 8, .vsub = 16, },\n\t{ .format = DRM_FORMAT_ARGB8888, .depth = 32, .num_planes = 2,\n\t  .cpp = { 4, 1, }, .hsub = 8, .vsub = 16, .has_alpha = true, },\n\t{ .format = DRM_FORMAT_ABGR8888, .depth = 32, .num_planes = 2,\n\t  .cpp = { 4, 1, }, .hsub = 8, .vsub = 16, .has_alpha = true, },\n};\n\n/*\n * Gen-12 compression uses 4 bits of CCS data for each cache line pair in the\n * main surface. And each 64B CCS cache line represents an area of 4x1 Y-tiles\n * in the main surface. With 4 byte pixels and each Y-tile having dimensions of\n * 32x32 pixels, the ratio turns out to 1B in the CCS for every 2x32 pixels in\n * the main surface.\n */\nstatic const struct drm_format_info gen12_ccs_formats[] = {\n\t{ .format = DRM_FORMAT_XRGB8888, .depth = 24, .num_planes = 2,\n\t  .char_per_block = { 4, 1 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 1, .vsub = 1, },\n\t{ .format = DRM_FORMAT_XBGR8888, .depth = 24, .num_planes = 2,\n\t  .char_per_block = { 4, 1 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 1, .vsub = 1, },\n\t{ .format = DRM_FORMAT_ARGB8888, .depth = 32, .num_planes = 2,\n\t  .char_per_block = { 4, 1 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 1, .vsub = 1, .has_alpha = true },\n\t{ .format = DRM_FORMAT_ABGR8888, .depth = 32, .num_planes = 2,\n\t  .char_per_block = { 4, 1 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 1, .vsub = 1, .has_alpha = true },\n\t{ .format = DRM_FORMAT_YUYV, .num_planes = 2,\n\t  .char_per_block = { 2, 1 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 2, .vsub = 1, .is_yuv = true },\n\t{ .format = DRM_FORMAT_YVYU, .num_planes = 2,\n\t  .char_per_block = { 2, 1 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 2, .vsub = 1, .is_yuv = true },\n\t{ .format = DRM_FORMAT_UYVY, .num_planes = 2,\n\t  .char_per_block = { 2, 1 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 2, .vsub = 1, .is_yuv = true },\n\t{ .format = DRM_FORMAT_VYUY, .num_planes = 2,\n\t  .char_per_block = { 2, 1 }, .block_w = { 1, 2 }, .block_h = { 1, 1 },\n\t  .hsub = 2, .vsub = 1, .is_yuv = true },\n\t{ .format = DRM_FORMAT_NV12, .num_planes = 4,\n\t  .char_per_block = { 1, 2, 1, 1 }, .block_w = { 1, 1, 4, 4 }, .block_h = { 1, 1, 1, 1 },\n\t  .hsub = 2, .vsub = 2, .is_yuv = true },\n\t{ .format = DRM_FORMAT_P010, .num_planes = 4,\n\t  .char_per_block = { 2, 4, 1, 1 }, .block_w = { 1, 1, 2, 2 }, .block_h = { 1, 1, 1, 1 },\n\t  .hsub = 2, .vsub = 2, .is_yuv = true },\n\t{ .format = DRM_FORMAT_P012, .num_planes = 4,\n\t  .char_per_block = { 2, 4, 1, 1 }, .block_w = { 1, 1, 2, 2 }, .block_h = { 1, 1, 1, 1 },\n\t  .hsub = 2, .vsub = 2, .is_yuv = true },\n\t{ .format = DRM_FORMAT_P016, .num_planes = 4,\n\t  .char_per_block = { 2, 4, 1, 1 }, .block_w = { 1, 1, 2, 2 }, .block_h = { 1, 1, 1, 1 },\n\t  .hsub = 2, .vsub = 2, .is_yuv = true },\n};\n\nstatic const struct drm_format_info *\nlookup_format_info(const struct drm_format_info formats[],\n\t\t   int num_formats, u32 format)\n{\n\tint i;\n\n\tfor (i = 0; i < num_formats; i++) {\n\t\tif (formats[i].format == format)\n\t\t\treturn &formats[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct drm_format_info *\nintel_get_format_info(const struct drm_mode_fb_cmd2 *cmd)\n{\n\tswitch (cmd->modifier[0]) {\n\tcase I915_FORMAT_MOD_Y_TILED_CCS:\n\tcase I915_FORMAT_MOD_Yf_TILED_CCS:\n\t\treturn lookup_format_info(skl_ccs_formats,\n\t\t\t\t\t  ARRAY_SIZE(skl_ccs_formats),\n\t\t\t\t\t  cmd->pixel_format);\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS:\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS:\n\t\treturn lookup_format_info(gen12_ccs_formats,\n\t\t\t\t\t  ARRAY_SIZE(gen12_ccs_formats),\n\t\t\t\t\t  cmd->pixel_format);\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nbool is_ccs_modifier(u64 modifier)\n{\n\treturn modifier == I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS ||\n\t       modifier == I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS ||\n\t       modifier == I915_FORMAT_MOD_Y_TILED_CCS ||\n\t       modifier == I915_FORMAT_MOD_Yf_TILED_CCS;\n}\n\nstatic int gen12_ccs_aux_stride(struct drm_framebuffer *fb, int ccs_plane)\n{\n\treturn DIV_ROUND_UP(fb->pitches[ccs_to_main_plane(fb, ccs_plane)],\n\t\t\t    512) * 64;\n}\n\nu32 intel_plane_fb_max_stride(struct drm_i915_private *dev_priv,\n\t\t\t      u32 pixel_format, u64 modifier)\n{\n\tstruct intel_crtc *crtc;\n\tstruct intel_plane *plane;\n\n\t/*\n\t * We assume the primary plane for pipe A has\n\t * the highest stride limits of them all,\n\t * if in case pipe A is disabled, use the first pipe from pipe_mask.\n\t */\n\tcrtc = intel_get_first_crtc(dev_priv);\n\tif (!crtc)\n\t\treturn 0;\n\n\tplane = to_intel_plane(crtc->base.primary);\n\n\treturn plane->max_stride(plane, pixel_format, modifier,\n\t\t\t\t DRM_MODE_ROTATE_0);\n}\n\nstatic\nu32 intel_fb_max_stride(struct drm_i915_private *dev_priv,\n\t\t\tu32 pixel_format, u64 modifier)\n{\n\t/*\n\t * Arbitrary limit for gen4+ chosen to match the\n\t * render engine max stride.\n\t *\n\t * The new CCS hash mode makes remapping impossible\n\t */\n\tif (!is_ccs_modifier(modifier)) {\n\t\tif (INTEL_GEN(dev_priv) >= 7)\n\t\t\treturn 256*1024;\n\t\telse if (INTEL_GEN(dev_priv) >= 4)\n\t\t\treturn 128*1024;\n\t}\n\n\treturn intel_plane_fb_max_stride(dev_priv, pixel_format, modifier);\n}\n\nstatic u32\nintel_fb_stride_alignment(const struct drm_framebuffer *fb, int color_plane)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(fb->dev);\n\tu32 tile_width;\n\n\tif (is_surface_linear(fb, color_plane)) {\n\t\tu32 max_stride = intel_plane_fb_max_stride(dev_priv,\n\t\t\t\t\t\t\t   fb->format->format,\n\t\t\t\t\t\t\t   fb->modifier);\n\n\t\t/*\n\t\t * To make remapping with linear generally feasible\n\t\t * we need the stride to be page aligned.\n\t\t */\n\t\tif (fb->pitches[color_plane] > max_stride &&\n\t\t    !is_ccs_modifier(fb->modifier))\n\t\t\treturn intel_tile_size(dev_priv);\n\t\telse\n\t\t\treturn 64;\n\t}\n\n\ttile_width = intel_tile_width_bytes(fb, color_plane);\n\tif (is_ccs_modifier(fb->modifier)) {\n\t\t/*\n\t\t * Display WA #0531: skl,bxt,kbl,glk\n\t\t *\n\t\t * Render decompression and plane width > 3840\n\t\t * combined with horizontal panning requires the\n\t\t * plane stride to be a multiple of 4. We'll just\n\t\t * require the entire fb to accommodate that to avoid\n\t\t * potential runtime errors at plane configuration time.\n\t\t */\n\t\tif (IS_GEN(dev_priv, 9) && color_plane == 0 && fb->width > 3840)\n\t\t\ttile_width *= 4;\n\t\t/*\n\t\t * The main surface pitch must be padded to a multiple of four\n\t\t * tile widths.\n\t\t */\n\t\telse if (INTEL_GEN(dev_priv) >= 12)\n\t\t\ttile_width *= 4;\n\t}\n\treturn tile_width;\n}\n\nbool intel_plane_can_remap(const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tint i;\n\n\t/* We don't want to deal with remapping with cursors */\n\tif (plane->id == PLANE_CURSOR)\n\t\treturn false;\n\n\t/*\n\t * The display engine limits already match/exceed the\n\t * render engine limits, so not much point in remapping.\n\t * Would also need to deal with the fence POT alignment\n\t * and gen2 2KiB GTT tile size.\n\t */\n\tif (INTEL_GEN(dev_priv) < 4)\n\t\treturn false;\n\n\t/*\n\t * The new CCS hash mode isn't compatible with remapping as\n\t * the virtual address of the pages affects the compressed data.\n\t */\n\tif (is_ccs_modifier(fb->modifier))\n\t\treturn false;\n\n\t/* Linear needs a page aligned stride for remapping */\n\tif (fb->modifier == DRM_FORMAT_MOD_LINEAR) {\n\t\tunsigned int alignment = intel_tile_size(dev_priv) - 1;\n\n\t\tfor (i = 0; i < fb->format->num_planes; i++) {\n\t\t\tif (fb->pitches[i] & alignment)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool intel_plane_needs_remap(const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int rotation = plane_state->hw.rotation;\n\tu32 stride, max_stride;\n\n\t/*\n\t * No remapping for invisible planes since we don't have\n\t * an actual source viewport to remap.\n\t */\n\tif (!plane_state->uapi.visible)\n\t\treturn false;\n\n\tif (!intel_plane_can_remap(plane_state))\n\t\treturn false;\n\n\t/*\n\t * FIXME: aux plane limits on gen9+ are\n\t * unclear in Bspec, for now no checking.\n\t */\n\tstride = intel_fb_pitch(fb, 0, rotation);\n\tmax_stride = plane->max_stride(plane, fb->format->format,\n\t\t\t\t       fb->modifier, rotation);\n\n\treturn stride > max_stride;\n}\n\nstatic void\nintel_fb_plane_get_subsampling(int *hsub, int *vsub,\n\t\t\t       const struct drm_framebuffer *fb,\n\t\t\t       int color_plane)\n{\n\tint main_plane;\n\n\tif (color_plane == 0) {\n\t\t*hsub = 1;\n\t\t*vsub = 1;\n\n\t\treturn;\n\t}\n\n\t/*\n\t * TODO: Deduct the subsampling from the char block for all CCS\n\t * formats and planes.\n\t */\n\tif (!is_gen12_ccs_plane(fb, color_plane)) {\n\t\t*hsub = fb->format->hsub;\n\t\t*vsub = fb->format->vsub;\n\n\t\treturn;\n\t}\n\n\tmain_plane = ccs_to_main_plane(fb, color_plane);\n\t*hsub = drm_format_info_block_width(fb->format, color_plane) /\n\t\tdrm_format_info_block_width(fb->format, main_plane);\n\n\t/*\n\t * The min stride check in the core framebuffer_check() function\n\t * assumes that format->hsub applies to every plane except for the\n\t * first plane. That's incorrect for the CCS AUX plane of the first\n\t * plane, but for the above check to pass we must define the block\n\t * width with that subsampling applied to it. Adjust the width here\n\t * accordingly, so we can calculate the actual subsampling factor.\n\t */\n\tif (main_plane == 0)\n\t\t*hsub *= fb->format->hsub;\n\n\t*vsub = 32;\n}\nstatic int\nintel_fb_check_ccs_xy(struct drm_framebuffer *fb, int ccs_plane, int x, int y)\n{\n\tstruct drm_i915_private *i915 = to_i915(fb->dev);\n\tstruct intel_framebuffer *intel_fb = to_intel_framebuffer(fb);\n\tint main_plane;\n\tint hsub, vsub;\n\tint tile_width, tile_height;\n\tint ccs_x, ccs_y;\n\tint main_x, main_y;\n\n\tif (!is_ccs_plane(fb, ccs_plane))\n\t\treturn 0;\n\n\tintel_tile_dims(fb, ccs_plane, &tile_width, &tile_height);\n\tintel_fb_plane_get_subsampling(&hsub, &vsub, fb, ccs_plane);\n\n\ttile_width *= hsub;\n\ttile_height *= vsub;\n\n\tccs_x = (x * hsub) % tile_width;\n\tccs_y = (y * vsub) % tile_height;\n\n\tmain_plane = ccs_to_main_plane(fb, ccs_plane);\n\tmain_x = intel_fb->normal[main_plane].x % tile_width;\n\tmain_y = intel_fb->normal[main_plane].y % tile_height;\n\n\t/*\n\t * CCS doesn't have its own x/y offset register, so the intra CCS tile\n\t * x/y offsets must match between CCS and the main surface.\n\t */\n\tif (main_x != ccs_x || main_y != ccs_y) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t      \"Bad CCS x/y (main %d,%d ccs %d,%d) full (main %d,%d ccs %d,%d)\\n\",\n\t\t\t      main_x, main_y,\n\t\t\t      ccs_x, ccs_y,\n\t\t\t      intel_fb->normal[main_plane].x,\n\t\t\t      intel_fb->normal[main_plane].y,\n\t\t\t      x, y);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nintel_fb_plane_dims(int *w, int *h, struct drm_framebuffer *fb, int color_plane)\n{\n\tint main_plane = is_ccs_plane(fb, color_plane) ?\n\t\t\t ccs_to_main_plane(fb, color_plane) : 0;\n\tint main_hsub, main_vsub;\n\tint hsub, vsub;\n\n\tintel_fb_plane_get_subsampling(&main_hsub, &main_vsub, fb, main_plane);\n\tintel_fb_plane_get_subsampling(&hsub, &vsub, fb, color_plane);\n\t*w = fb->width / main_hsub / hsub;\n\t*h = fb->height / main_vsub / vsub;\n}\n\n/*\n * Setup the rotated view for an FB plane and return the size the GTT mapping\n * requires for this view.\n */\nstatic u32\nsetup_fb_rotation(int plane, const struct intel_remapped_plane_info *plane_info,\n\t\t  u32 gtt_offset_rotated, int x, int y,\n\t\t  unsigned int width, unsigned int height,\n\t\t  unsigned int tile_size,\n\t\t  unsigned int tile_width, unsigned int tile_height,\n\t\t  struct drm_framebuffer *fb)\n{\n\tstruct intel_framebuffer *intel_fb = to_intel_framebuffer(fb);\n\tstruct intel_rotation_info *rot_info = &intel_fb->rot_info;\n\tunsigned int pitch_tiles;\n\tstruct drm_rect r;\n\n\t/* Y or Yf modifiers required for 90/270 rotation */\n\tif (fb->modifier != I915_FORMAT_MOD_Y_TILED &&\n\t    fb->modifier != I915_FORMAT_MOD_Yf_TILED)\n\t\treturn 0;\n\n\tif (drm_WARN_ON(fb->dev, plane >= ARRAY_SIZE(rot_info->plane)))\n\t\treturn 0;\n\n\trot_info->plane[plane] = *plane_info;\n\n\tintel_fb->rotated[plane].pitch = plane_info->height * tile_height;\n\n\t/* rotate the x/y offsets to match the GTT view */\n\tdrm_rect_init(&r, x, y, width, height);\n\tdrm_rect_rotate(&r,\n\t\t\tplane_info->width * tile_width,\n\t\t\tplane_info->height * tile_height,\n\t\t\tDRM_MODE_ROTATE_270);\n\tx = r.x1;\n\ty = r.y1;\n\n\t/* rotate the tile dimensions to match the GTT view */\n\tpitch_tiles = intel_fb->rotated[plane].pitch / tile_height;\n\tswap(tile_width, tile_height);\n\n\t/*\n\t * We only keep the x/y offsets, so push all of the\n\t * gtt offset into the x/y offsets.\n\t */\n\tintel_adjust_tile_offset(&x, &y,\n\t\t\t\t tile_width, tile_height,\n\t\t\t\t tile_size, pitch_tiles,\n\t\t\t\t gtt_offset_rotated * tile_size, 0);\n\n\t/*\n\t * First pixel of the framebuffer from\n\t * the start of the rotated gtt mapping.\n\t */\n\tintel_fb->rotated[plane].x = x;\n\tintel_fb->rotated[plane].y = y;\n\n\treturn plane_info->width * plane_info->height;\n}\n\nstatic int\nintel_fill_fb_info(struct drm_i915_private *dev_priv,\n\t\t   struct drm_framebuffer *fb)\n{\n\tstruct intel_framebuffer *intel_fb = to_intel_framebuffer(fb);\n\tstruct drm_i915_gem_object *obj = intel_fb_obj(fb);\n\tu32 gtt_offset_rotated = 0;\n\tunsigned int max_size = 0;\n\tint i, num_planes = fb->format->num_planes;\n\tunsigned int tile_size = intel_tile_size(dev_priv);\n\n\tfor (i = 0; i < num_planes; i++) {\n\t\tunsigned int width, height;\n\t\tunsigned int cpp, size;\n\t\tu32 offset;\n\t\tint x, y;\n\t\tint ret;\n\n\t\tcpp = fb->format->cpp[i];\n\t\tintel_fb_plane_dims(&width, &height, fb, i);\n\n\t\tret = intel_fb_offset_to_xy(&x, &y, fb, i);\n\t\tif (ret) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"bad fb plane %d offset: 0x%x\\n\",\n\t\t\t\t    i, fb->offsets[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = intel_fb_check_ccs_xy(fb, i, x, y);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * The fence (if used) is aligned to the start of the object\n\t\t * so having the framebuffer wrap around across the edge of the\n\t\t * fenced region doesn't really work. We have no API to configure\n\t\t * the fence start offset within the object (nor could we probably\n\t\t * on gen2/3). So it's just easier if we just require that the\n\t\t * fb layout agrees with the fence layout. We already check that the\n\t\t * fb stride matches the fence stride elsewhere.\n\t\t */\n\t\tif (i == 0 && i915_gem_object_is_tiled(obj) &&\n\t\t    (x + width) * cpp > fb->pitches[i]) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"bad fb plane %d offset: 0x%x\\n\",\n\t\t\t\t     i, fb->offsets[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/*\n\t\t * First pixel of the framebuffer from\n\t\t * the start of the normal gtt mapping.\n\t\t */\n\t\tintel_fb->normal[i].x = x;\n\t\tintel_fb->normal[i].y = y;\n\n\t\toffset = intel_compute_aligned_offset(dev_priv, &x, &y, fb, i,\n\t\t\t\t\t\t      fb->pitches[i],\n\t\t\t\t\t\t      DRM_MODE_ROTATE_0,\n\t\t\t\t\t\t      tile_size);\n\t\toffset /= tile_size;\n\n\t\tif (!is_surface_linear(fb, i)) {\n\t\t\tstruct intel_remapped_plane_info plane_info;\n\t\t\tunsigned int tile_width, tile_height;\n\n\t\t\tintel_tile_dims(fb, i, &tile_width, &tile_height);\n\n\t\t\tplane_info.offset = offset;\n\t\t\tplane_info.stride = DIV_ROUND_UP(fb->pitches[i],\n\t\t\t\t\t\t\t tile_width * cpp);\n\t\t\tplane_info.width = DIV_ROUND_UP(x + width, tile_width);\n\t\t\tplane_info.height = DIV_ROUND_UP(y + height,\n\t\t\t\t\t\t\t tile_height);\n\n\t\t\t/* how many tiles does this plane need */\n\t\t\tsize = plane_info.stride * plane_info.height;\n\t\t\t/*\n\t\t\t * If the plane isn't horizontally tile aligned,\n\t\t\t * we need one more tile.\n\t\t\t */\n\t\t\tif (x != 0)\n\t\t\t\tsize++;\n\n\t\t\tgtt_offset_rotated +=\n\t\t\t\tsetup_fb_rotation(i, &plane_info,\n\t\t\t\t\t\t  gtt_offset_rotated,\n\t\t\t\t\t\t  x, y, width, height,\n\t\t\t\t\t\t  tile_size,\n\t\t\t\t\t\t  tile_width, tile_height,\n\t\t\t\t\t\t  fb);\n\t\t} else {\n\t\t\tsize = DIV_ROUND_UP((y + height) * fb->pitches[i] +\n\t\t\t\t\t    x * cpp, tile_size);\n\t\t}\n\n\t\t/* how many tiles in total needed in the bo */\n\t\tmax_size = max(max_size, offset + size);\n\t}\n\n\tif (mul_u32_u32(max_size, tile_size) > obj->base.size) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"fb too big for bo (need %llu bytes, have %zu bytes)\\n\",\n\t\t\t    mul_u32_u32(max_size, tile_size), obj->base.size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nintel_plane_remap_gtt(struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tstruct drm_framebuffer *fb = plane_state->hw.fb;\n\tstruct intel_framebuffer *intel_fb = to_intel_framebuffer(fb);\n\tstruct intel_rotation_info *info = &plane_state->view.rotated;\n\tunsigned int rotation = plane_state->hw.rotation;\n\tint i, num_planes = fb->format->num_planes;\n\tunsigned int tile_size = intel_tile_size(dev_priv);\n\tunsigned int src_x, src_y;\n\tunsigned int src_w, src_h;\n\tu32 gtt_offset = 0;\n\n\tmemset(&plane_state->view, 0, sizeof(plane_state->view));\n\tplane_state->view.type = drm_rotation_90_or_270(rotation) ?\n\t\tI915_GGTT_VIEW_ROTATED : I915_GGTT_VIEW_REMAPPED;\n\n\tsrc_x = plane_state->uapi.src.x1 >> 16;\n\tsrc_y = plane_state->uapi.src.y1 >> 16;\n\tsrc_w = drm_rect_width(&plane_state->uapi.src) >> 16;\n\tsrc_h = drm_rect_height(&plane_state->uapi.src) >> 16;\n\n\tdrm_WARN_ON(&dev_priv->drm, is_ccs_modifier(fb->modifier));\n\n\t/* Make src coordinates relative to the viewport */\n\tdrm_rect_translate(&plane_state->uapi.src,\n\t\t\t   -(src_x << 16), -(src_y << 16));\n\n\t/* Rotate src coordinates to match rotated GTT view */\n\tif (drm_rotation_90_or_270(rotation))\n\t\tdrm_rect_rotate(&plane_state->uapi.src,\n\t\t\t\tsrc_w << 16, src_h << 16,\n\t\t\t\tDRM_MODE_ROTATE_270);\n\n\tfor (i = 0; i < num_planes; i++) {\n\t\tunsigned int hsub = i ? fb->format->hsub : 1;\n\t\tunsigned int vsub = i ? fb->format->vsub : 1;\n\t\tunsigned int cpp = fb->format->cpp[i];\n\t\tunsigned int tile_width, tile_height;\n\t\tunsigned int width, height;\n\t\tunsigned int pitch_tiles;\n\t\tunsigned int x, y;\n\t\tu32 offset;\n\n\t\tintel_tile_dims(fb, i, &tile_width, &tile_height);\n\n\t\tx = src_x / hsub;\n\t\ty = src_y / vsub;\n\t\twidth = src_w / hsub;\n\t\theight = src_h / vsub;\n\n\t\t/*\n\t\t * First pixel of the src viewport from the\n\t\t * start of the normal gtt mapping.\n\t\t */\n\t\tx += intel_fb->normal[i].x;\n\t\ty += intel_fb->normal[i].y;\n\n\t\toffset = intel_compute_aligned_offset(dev_priv, &x, &y,\n\t\t\t\t\t\t      fb, i, fb->pitches[i],\n\t\t\t\t\t\t      DRM_MODE_ROTATE_0, tile_size);\n\t\toffset /= tile_size;\n\n\t\tdrm_WARN_ON(&dev_priv->drm, i >= ARRAY_SIZE(info->plane));\n\t\tinfo->plane[i].offset = offset;\n\t\tinfo->plane[i].stride = DIV_ROUND_UP(fb->pitches[i],\n\t\t\t\t\t\t     tile_width * cpp);\n\t\tinfo->plane[i].width = DIV_ROUND_UP(x + width, tile_width);\n\t\tinfo->plane[i].height = DIV_ROUND_UP(y + height, tile_height);\n\n\t\tif (drm_rotation_90_or_270(rotation)) {\n\t\t\tstruct drm_rect r;\n\n\t\t\t/* rotate the x/y offsets to match the GTT view */\n\t\t\tdrm_rect_init(&r, x, y, width, height);\n\t\t\tdrm_rect_rotate(&r,\n\t\t\t\t\tinfo->plane[i].width * tile_width,\n\t\t\t\t\tinfo->plane[i].height * tile_height,\n\t\t\t\t\tDRM_MODE_ROTATE_270);\n\t\t\tx = r.x1;\n\t\t\ty = r.y1;\n\n\t\t\tpitch_tiles = info->plane[i].height;\n\t\t\tplane_state->color_plane[i].stride = pitch_tiles * tile_height;\n\n\t\t\t/* rotate the tile dimensions to match the GTT view */\n\t\t\tswap(tile_width, tile_height);\n\t\t} else {\n\t\t\tpitch_tiles = info->plane[i].width;\n\t\t\tplane_state->color_plane[i].stride = pitch_tiles * tile_width * cpp;\n\t\t}\n\n\t\t/*\n\t\t * We only keep the x/y offsets, so push all of the\n\t\t * gtt offset into the x/y offsets.\n\t\t */\n\t\tintel_adjust_tile_offset(&x, &y,\n\t\t\t\t\t tile_width, tile_height,\n\t\t\t\t\t tile_size, pitch_tiles,\n\t\t\t\t\t gtt_offset * tile_size, 0);\n\n\t\tgtt_offset += info->plane[i].width * info->plane[i].height;\n\n\t\tplane_state->color_plane[i].offset = 0;\n\t\tplane_state->color_plane[i].x = x;\n\t\tplane_state->color_plane[i].y = y;\n\t}\n}\n\nstatic int\nintel_plane_compute_gtt(struct intel_plane_state *plane_state)\n{\n\tconst struct intel_framebuffer *fb =\n\t\tto_intel_framebuffer(plane_state->hw.fb);\n\tunsigned int rotation = plane_state->hw.rotation;\n\tint i, num_planes;\n\n\tif (!fb)\n\t\treturn 0;\n\n\tnum_planes = fb->base.format->num_planes;\n\n\tif (intel_plane_needs_remap(plane_state)) {\n\t\tintel_plane_remap_gtt(plane_state);\n\n\t\t/*\n\t\t * Sometimes even remapping can't overcome\n\t\t * the stride limitations :( Can happen with\n\t\t * big plane sizes and suitably misaligned\n\t\t * offsets.\n\t\t */\n\t\treturn intel_plane_check_stride(plane_state);\n\t}\n\n\tintel_fill_fb_ggtt_view(&plane_state->view, &fb->base, rotation);\n\n\tfor (i = 0; i < num_planes; i++) {\n\t\tplane_state->color_plane[i].stride = intel_fb_pitch(&fb->base, i, rotation);\n\t\tplane_state->color_plane[i].offset = 0;\n\n\t\tif (drm_rotation_90_or_270(rotation)) {\n\t\t\tplane_state->color_plane[i].x = fb->rotated[i].x;\n\t\t\tplane_state->color_plane[i].y = fb->rotated[i].y;\n\t\t} else {\n\t\t\tplane_state->color_plane[i].x = fb->normal[i].x;\n\t\t\tplane_state->color_plane[i].y = fb->normal[i].y;\n\t\t}\n\t}\n\n\t/* Rotate src coordinates to match rotated GTT view */\n\tif (drm_rotation_90_or_270(rotation))\n\t\tdrm_rect_rotate(&plane_state->uapi.src,\n\t\t\t\tfb->base.width << 16, fb->base.height << 16,\n\t\t\t\tDRM_MODE_ROTATE_270);\n\n\treturn intel_plane_check_stride(plane_state);\n}\n\nstatic int i9xx_format_to_fourcc(int format)\n{\n\tswitch (format) {\n\tcase DISPPLANE_8BPP:\n\t\treturn DRM_FORMAT_C8;\n\tcase DISPPLANE_BGRA555:\n\t\treturn DRM_FORMAT_ARGB1555;\n\tcase DISPPLANE_BGRX555:\n\t\treturn DRM_FORMAT_XRGB1555;\n\tcase DISPPLANE_BGRX565:\n\t\treturn DRM_FORMAT_RGB565;\n\tdefault:\n\tcase DISPPLANE_BGRX888:\n\t\treturn DRM_FORMAT_XRGB8888;\n\tcase DISPPLANE_RGBX888:\n\t\treturn DRM_FORMAT_XBGR8888;\n\tcase DISPPLANE_BGRA888:\n\t\treturn DRM_FORMAT_ARGB8888;\n\tcase DISPPLANE_RGBA888:\n\t\treturn DRM_FORMAT_ABGR8888;\n\tcase DISPPLANE_BGRX101010:\n\t\treturn DRM_FORMAT_XRGB2101010;\n\tcase DISPPLANE_RGBX101010:\n\t\treturn DRM_FORMAT_XBGR2101010;\n\tcase DISPPLANE_BGRA101010:\n\t\treturn DRM_FORMAT_ARGB2101010;\n\tcase DISPPLANE_RGBA101010:\n\t\treturn DRM_FORMAT_ABGR2101010;\n\tcase DISPPLANE_RGBX161616:\n\t\treturn DRM_FORMAT_XBGR16161616F;\n\t}\n}\n\nint skl_format_to_fourcc(int format, bool rgb_order, bool alpha)\n{\n\tswitch (format) {\n\tcase PLANE_CTL_FORMAT_RGB_565:\n\t\treturn DRM_FORMAT_RGB565;\n\tcase PLANE_CTL_FORMAT_NV12:\n\t\treturn DRM_FORMAT_NV12;\n\tcase PLANE_CTL_FORMAT_XYUV:\n\t\treturn DRM_FORMAT_XYUV8888;\n\tcase PLANE_CTL_FORMAT_P010:\n\t\treturn DRM_FORMAT_P010;\n\tcase PLANE_CTL_FORMAT_P012:\n\t\treturn DRM_FORMAT_P012;\n\tcase PLANE_CTL_FORMAT_P016:\n\t\treturn DRM_FORMAT_P016;\n\tcase PLANE_CTL_FORMAT_Y210:\n\t\treturn DRM_FORMAT_Y210;\n\tcase PLANE_CTL_FORMAT_Y212:\n\t\treturn DRM_FORMAT_Y212;\n\tcase PLANE_CTL_FORMAT_Y216:\n\t\treturn DRM_FORMAT_Y216;\n\tcase PLANE_CTL_FORMAT_Y410:\n\t\treturn DRM_FORMAT_XVYU2101010;\n\tcase PLANE_CTL_FORMAT_Y412:\n\t\treturn DRM_FORMAT_XVYU12_16161616;\n\tcase PLANE_CTL_FORMAT_Y416:\n\t\treturn DRM_FORMAT_XVYU16161616;\n\tdefault:\n\tcase PLANE_CTL_FORMAT_XRGB_8888:\n\t\tif (rgb_order) {\n\t\t\tif (alpha)\n\t\t\t\treturn DRM_FORMAT_ABGR8888;\n\t\t\telse\n\t\t\t\treturn DRM_FORMAT_XBGR8888;\n\t\t} else {\n\t\t\tif (alpha)\n\t\t\t\treturn DRM_FORMAT_ARGB8888;\n\t\t\telse\n\t\t\t\treturn DRM_FORMAT_XRGB8888;\n\t\t}\n\tcase PLANE_CTL_FORMAT_XRGB_2101010:\n\t\tif (rgb_order) {\n\t\t\tif (alpha)\n\t\t\t\treturn DRM_FORMAT_ABGR2101010;\n\t\t\telse\n\t\t\t\treturn DRM_FORMAT_XBGR2101010;\n\t\t} else {\n\t\t\tif (alpha)\n\t\t\t\treturn DRM_FORMAT_ARGB2101010;\n\t\t\telse\n\t\t\t\treturn DRM_FORMAT_XRGB2101010;\n\t\t}\n\tcase PLANE_CTL_FORMAT_XRGB_16161616F:\n\t\tif (rgb_order) {\n\t\t\tif (alpha)\n\t\t\t\treturn DRM_FORMAT_ABGR16161616F;\n\t\t\telse\n\t\t\t\treturn DRM_FORMAT_XBGR16161616F;\n\t\t} else {\n\t\t\tif (alpha)\n\t\t\t\treturn DRM_FORMAT_ARGB16161616F;\n\t\t\telse\n\t\t\t\treturn DRM_FORMAT_XRGB16161616F;\n\t\t}\n\t}\n}\n\nstatic struct i915_vma *\ninitial_plane_vma(struct drm_i915_private *i915,\n\t\t  struct intel_initial_plane_config *plane_config)\n{\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_vma *vma;\n\tu32 base, size;\n\n\tif (plane_config->size == 0)\n\t\treturn NULL;\n\n\tbase = round_down(plane_config->base,\n\t\t\t  I915_GTT_MIN_ALIGNMENT);\n\tsize = round_up(plane_config->base + plane_config->size,\n\t\t\tI915_GTT_MIN_ALIGNMENT);\n\tsize -= base;\n\n\t/*\n\t * If the FB is too big, just don't use it since fbdev is not very\n\t * important and we should probably use that space with FBC or other\n\t * features.\n\t */\n\tif (size * 2 > i915->stolen_usable_size)\n\t\treturn NULL;\n\n\tobj = i915_gem_object_create_stolen_for_preallocated(i915, base, size);\n\tif (IS_ERR(obj))\n\t\treturn NULL;\n\n\t/*\n\t * Mark it WT ahead of time to avoid changing the\n\t * cache_level during fbdev initialization. The\n\t * unbind there would get stuck waiting for rcu.\n\t */\n\ti915_gem_object_set_cache_coherency(obj, HAS_WT(i915) ?\n\t\t\t\t\t    I915_CACHE_WT : I915_CACHE_NONE);\n\n\tswitch (plane_config->tiling) {\n\tcase I915_TILING_NONE:\n\t\tbreak;\n\tcase I915_TILING_X:\n\tcase I915_TILING_Y:\n\t\tobj->tiling_and_stride =\n\t\t\tplane_config->fb->base.pitches[0] |\n\t\t\tplane_config->tiling;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(plane_config->tiling);\n\t\tgoto err_obj;\n\t}\n\n\tvma = i915_vma_instance(obj, &i915->ggtt.vm, NULL);\n\tif (IS_ERR(vma))\n\t\tgoto err_obj;\n\n\tif (i915_ggtt_pin(vma, NULL, 0, PIN_MAPPABLE | PIN_OFFSET_FIXED | base))\n\t\tgoto err_obj;\n\n\tif (i915_gem_object_is_tiled(obj) &&\n\t    !i915_vma_is_map_and_fenceable(vma))\n\t\tgoto err_obj;\n\n\treturn vma;\n\nerr_obj:\n\ti915_gem_object_put(obj);\n\treturn NULL;\n}\n\nstatic bool\nintel_alloc_initial_plane_obj(struct intel_crtc *crtc,\n\t\t\t      struct intel_initial_plane_config *plane_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_mode_fb_cmd2 mode_cmd = { 0 };\n\tstruct drm_framebuffer *fb = &plane_config->fb->base;\n\tstruct i915_vma *vma;\n\n\tswitch (fb->modifier) {\n\tcase DRM_FORMAT_MOD_LINEAR:\n\tcase I915_FORMAT_MOD_X_TILED:\n\tcase I915_FORMAT_MOD_Y_TILED:\n\t\tbreak;\n\tdefault:\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"Unsupported modifier for initial FB: 0x%llx\\n\",\n\t\t\tfb->modifier);\n\t\treturn false;\n\t}\n\n\tvma = initial_plane_vma(dev_priv, plane_config);\n\tif (!vma)\n\t\treturn false;\n\n\tmode_cmd.pixel_format = fb->format->format;\n\tmode_cmd.width = fb->width;\n\tmode_cmd.height = fb->height;\n\tmode_cmd.pitches[0] = fb->pitches[0];\n\tmode_cmd.modifier[0] = fb->modifier;\n\tmode_cmd.flags = DRM_MODE_FB_MODIFIERS;\n\n\tif (intel_framebuffer_init(to_intel_framebuffer(fb),\n\t\t\t\t   vma->obj, &mode_cmd)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"intel fb init failed\\n\");\n\t\tgoto err_vma;\n\t}\n\n\tplane_config->vma = vma;\n\treturn true;\n\nerr_vma:\n\ti915_vma_put(vma);\n\treturn false;\n}\n\nstatic void\nintel_set_plane_visible(struct intel_crtc_state *crtc_state,\n\t\t\tstruct intel_plane_state *plane_state,\n\t\t\tbool visible)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\n\tplane_state->uapi.visible = visible;\n\n\tif (visible)\n\t\tcrtc_state->uapi.plane_mask |= drm_plane_mask(&plane->base);\n\telse\n\t\tcrtc_state->uapi.plane_mask &= ~drm_plane_mask(&plane->base);\n}\n\nstatic void fixup_active_planes(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tstruct drm_plane *plane;\n\n\t/*\n\t * Active_planes aliases if multiple \"primary\" or cursor planes\n\t * have been used on the same (or wrong) pipe. plane_mask uses\n\t * unique ids, hence we can use that to reconstruct active_planes.\n\t */\n\tcrtc_state->active_planes = 0;\n\n\tdrm_for_each_plane_mask(plane, &dev_priv->drm,\n\t\t\t\tcrtc_state->uapi.plane_mask)\n\t\tcrtc_state->active_planes |= BIT(to_intel_plane(plane)->id);\n}\n\nstatic void intel_plane_disable_noatomic(struct intel_crtc *crtc,\n\t\t\t\t\t struct intel_plane *plane)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tto_intel_crtc_state(crtc->base.state);\n\tstruct intel_plane_state *plane_state =\n\t\tto_intel_plane_state(plane->base.state);\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Disabling [PLANE:%d:%s] on [CRTC:%d:%s]\\n\",\n\t\t    plane->base.base.id, plane->base.name,\n\t\t    crtc->base.base.id, crtc->base.name);\n\n\tintel_set_plane_visible(crtc_state, plane_state, false);\n\tfixup_active_planes(crtc_state);\n\tcrtc_state->data_rate[plane->id] = 0;\n\tcrtc_state->min_cdclk[plane->id] = 0;\n\n\tif (plane->id == PLANE_PRIMARY)\n\t\thsw_disable_ips(crtc_state);\n\n\t/*\n\t * Vblank time updates from the shadow to live plane control register\n\t * are blocked if the memory self-refresh mode is active at that\n\t * moment. So to make sure the plane gets truly disabled, disable\n\t * first the self-refresh mode. The self-refresh enable bit in turn\n\t * will be checked/applied by the HW only at the next frame start\n\t * event which is after the vblank start event, so we need to have a\n\t * wait-for-vblank between disabling the plane and the pipe.\n\t */\n\tif (HAS_GMCH(dev_priv) &&\n\t    intel_set_memory_cxsr(dev_priv, false))\n\t\tintel_wait_for_vblank(dev_priv, crtc->pipe);\n\n\t/*\n\t * Gen2 reports pipe underruns whenever all planes are disabled.\n\t * So disable underrun reporting before all the planes get disabled.\n\t */\n\tif (IS_GEN(dev_priv, 2) && !crtc_state->active_planes)\n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, crtc->pipe, false);\n\n\tintel_disable_plane(plane, crtc_state);\n}\n\nstatic struct intel_frontbuffer *\nto_intel_frontbuffer(struct drm_framebuffer *fb)\n{\n\treturn fb ? to_intel_framebuffer(fb)->frontbuffer : NULL;\n}\n\nstatic void\nintel_find_initial_plane_obj(struct intel_crtc *intel_crtc,\n\t\t\t     struct intel_initial_plane_config *plane_config)\n{\n\tstruct drm_device *dev = intel_crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_crtc *c;\n\tstruct drm_plane *primary = intel_crtc->base.primary;\n\tstruct drm_plane_state *plane_state = primary->state;\n\tstruct intel_plane *intel_plane = to_intel_plane(primary);\n\tstruct intel_plane_state *intel_state =\n\t\tto_intel_plane_state(plane_state);\n\tstruct drm_framebuffer *fb;\n\tstruct i915_vma *vma;\n\n\tif (!plane_config->fb)\n\t\treturn;\n\n\tif (intel_alloc_initial_plane_obj(intel_crtc, plane_config)) {\n\t\tfb = &plane_config->fb->base;\n\t\tvma = plane_config->vma;\n\t\tgoto valid_fb;\n\t}\n\n\t/*\n\t * Failed to alloc the obj, check to see if we should share\n\t * an fb with another CRTC instead\n\t */\n\tfor_each_crtc(dev, c) {\n\t\tstruct intel_plane_state *state;\n\n\t\tif (c == &intel_crtc->base)\n\t\t\tcontinue;\n\n\t\tif (!to_intel_crtc(c)->active)\n\t\t\tcontinue;\n\n\t\tstate = to_intel_plane_state(c->primary->state);\n\t\tif (!state->vma)\n\t\t\tcontinue;\n\n\t\tif (intel_plane_ggtt_offset(state) == plane_config->base) {\n\t\t\tfb = state->hw.fb;\n\t\t\tvma = state->vma;\n\t\t\tgoto valid_fb;\n\t\t}\n\t}\n\n\t/*\n\t * We've failed to reconstruct the BIOS FB.  Current display state\n\t * indicates that the primary plane is visible, but has a NULL FB,\n\t * which will lead to problems later if we don't fix it up.  The\n\t * simplest solution is to just disable the primary plane now and\n\t * pretend the BIOS never had it enabled.\n\t */\n\tintel_plane_disable_noatomic(intel_crtc, intel_plane);\n\n\treturn;\n\nvalid_fb:\n\tintel_state->hw.rotation = plane_config->rotation;\n\tintel_fill_fb_ggtt_view(&intel_state->view, fb,\n\t\t\t\tintel_state->hw.rotation);\n\tintel_state->color_plane[0].stride =\n\t\tintel_fb_pitch(fb, 0, intel_state->hw.rotation);\n\n\t__i915_vma_pin(vma);\n\tintel_state->vma = i915_vma_get(vma);\n\tif (intel_plane_uses_fence(intel_state) && i915_vma_pin_fence(vma) == 0)\n\t\tif (vma->fence)\n\t\t\tintel_state->flags |= PLANE_HAS_FENCE;\n\n\tplane_state->src_x = 0;\n\tplane_state->src_y = 0;\n\tplane_state->src_w = fb->width << 16;\n\tplane_state->src_h = fb->height << 16;\n\n\tplane_state->crtc_x = 0;\n\tplane_state->crtc_y = 0;\n\tplane_state->crtc_w = fb->width;\n\tplane_state->crtc_h = fb->height;\n\n\tintel_state->uapi.src = drm_plane_state_src(plane_state);\n\tintel_state->uapi.dst = drm_plane_state_dest(plane_state);\n\n\tif (plane_config->tiling)\n\t\tdev_priv->preserve_bios_swizzle = true;\n\n\tplane_state->fb = fb;\n\tdrm_framebuffer_get(fb);\n\n\tplane_state->crtc = &intel_crtc->base;\n\tintel_plane_copy_uapi_to_hw_state(intel_state, intel_state);\n\n\tintel_frontbuffer_flush(to_intel_frontbuffer(fb), ORIGIN_DIRTYFB);\n\n\tatomic_or(to_intel_plane(primary)->frontbuffer_bit,\n\t\t  &to_intel_frontbuffer(fb)->bits);\n}\n\nstatic int skl_max_plane_width(const struct drm_framebuffer *fb,\n\t\t\t       int color_plane,\n\t\t\t       unsigned int rotation)\n{\n\tint cpp = fb->format->cpp[color_plane];\n\n\tswitch (fb->modifier) {\n\tcase DRM_FORMAT_MOD_LINEAR:\n\tcase I915_FORMAT_MOD_X_TILED:\n\t\t/*\n\t\t * Validated limit is 4k, but has 5k should\n\t\t * work apart from the following features:\n\t\t * - Ytile (already limited to 4k)\n\t\t * - FP16 (already limited to 4k)\n\t\t * - render compression (already limited to 4k)\n\t\t * - KVMR sprite and cursor (don't care)\n\t\t * - horizontal panning (TODO verify this)\n\t\t * - pipe and plane scaling (TODO verify this)\n\t\t */\n\t\tif (cpp == 8)\n\t\t\treturn 4096;\n\t\telse\n\t\t\treturn 5120;\n\tcase I915_FORMAT_MOD_Y_TILED_CCS:\n\tcase I915_FORMAT_MOD_Yf_TILED_CCS:\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS:\n\t\t/* FIXME AUX plane? */\n\tcase I915_FORMAT_MOD_Y_TILED:\n\tcase I915_FORMAT_MOD_Yf_TILED:\n\t\tif (cpp == 8)\n\t\t\treturn 2048;\n\t\telse\n\t\t\treturn 4096;\n\tdefault:\n\t\tMISSING_CASE(fb->modifier);\n\t\treturn 2048;\n\t}\n}\n\nstatic int glk_max_plane_width(const struct drm_framebuffer *fb,\n\t\t\t       int color_plane,\n\t\t\t       unsigned int rotation)\n{\n\tint cpp = fb->format->cpp[color_plane];\n\n\tswitch (fb->modifier) {\n\tcase DRM_FORMAT_MOD_LINEAR:\n\tcase I915_FORMAT_MOD_X_TILED:\n\t\tif (cpp == 8)\n\t\t\treturn 4096;\n\t\telse\n\t\t\treturn 5120;\n\tcase I915_FORMAT_MOD_Y_TILED_CCS:\n\tcase I915_FORMAT_MOD_Yf_TILED_CCS:\n\t\t/* FIXME AUX plane? */\n\tcase I915_FORMAT_MOD_Y_TILED:\n\tcase I915_FORMAT_MOD_Yf_TILED:\n\t\tif (cpp == 8)\n\t\t\treturn 2048;\n\t\telse\n\t\t\treturn 5120;\n\tdefault:\n\t\tMISSING_CASE(fb->modifier);\n\t\treturn 2048;\n\t}\n}\n\nstatic int icl_min_plane_width(const struct drm_framebuffer *fb)\n{\n\t/* Wa_14011264657, Wa_14011050563: gen11+ */\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_C8:\n\t\treturn 18;\n\tcase DRM_FORMAT_RGB565:\n\t\treturn 10;\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_XRGB2101010:\n\tcase DRM_FORMAT_XBGR2101010:\n\tcase DRM_FORMAT_ARGB2101010:\n\tcase DRM_FORMAT_ABGR2101010:\n\tcase DRM_FORMAT_XVYU2101010:\n\tcase DRM_FORMAT_Y212:\n\tcase DRM_FORMAT_Y216:\n\t\treturn 6;\n\tcase DRM_FORMAT_NV12:\n\t\treturn 20;\n\tcase DRM_FORMAT_P010:\n\tcase DRM_FORMAT_P012:\n\tcase DRM_FORMAT_P016:\n\t\treturn 12;\n\tcase DRM_FORMAT_XRGB16161616F:\n\tcase DRM_FORMAT_XBGR16161616F:\n\tcase DRM_FORMAT_ARGB16161616F:\n\tcase DRM_FORMAT_ABGR16161616F:\n\tcase DRM_FORMAT_XVYU12_16161616:\n\tcase DRM_FORMAT_XVYU16161616:\n\t\treturn 4;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic int icl_max_plane_width(const struct drm_framebuffer *fb,\n\t\t\t       int color_plane,\n\t\t\t       unsigned int rotation)\n{\n\treturn 5120;\n}\n\nstatic int skl_max_plane_height(void)\n{\n\treturn 4096;\n}\n\nstatic int icl_max_plane_height(void)\n{\n\treturn 4320;\n}\n\nstatic bool\nskl_check_main_ccs_coordinates(struct intel_plane_state *plane_state,\n\t\t\t       int main_x, int main_y, u32 main_offset,\n\t\t\t       int ccs_plane)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tint aux_x = plane_state->color_plane[ccs_plane].x;\n\tint aux_y = plane_state->color_plane[ccs_plane].y;\n\tu32 aux_offset = plane_state->color_plane[ccs_plane].offset;\n\tu32 alignment = intel_surf_alignment(fb, ccs_plane);\n\tint hsub;\n\tint vsub;\n\n\tintel_fb_plane_get_subsampling(&hsub, &vsub, fb, ccs_plane);\n\twhile (aux_offset >= main_offset && aux_y <= main_y) {\n\t\tint x, y;\n\n\t\tif (aux_x == main_x && aux_y == main_y)\n\t\t\tbreak;\n\n\t\tif (aux_offset == 0)\n\t\t\tbreak;\n\n\t\tx = aux_x / hsub;\n\t\ty = aux_y / vsub;\n\t\taux_offset = intel_plane_adjust_aligned_offset(&x, &y,\n\t\t\t\t\t\t\t       plane_state,\n\t\t\t\t\t\t\t       ccs_plane,\n\t\t\t\t\t\t\t       aux_offset,\n\t\t\t\t\t\t\t       aux_offset -\n\t\t\t\t\t\t\t\talignment);\n\t\taux_x = x * hsub + aux_x % hsub;\n\t\taux_y = y * vsub + aux_y % vsub;\n\t}\n\n\tif (aux_x != main_x || aux_y != main_y)\n\t\treturn false;\n\n\tplane_state->color_plane[ccs_plane].offset = aux_offset;\n\tplane_state->color_plane[ccs_plane].x = aux_x;\n\tplane_state->color_plane[ccs_plane].y = aux_y;\n\n\treturn true;\n}\n\nunsigned int\nintel_plane_fence_y_offset(const struct intel_plane_state *plane_state)\n{\n\tint x = 0, y = 0;\n\n\tintel_plane_adjust_aligned_offset(&x, &y, plane_state, 0,\n\t\t\t\t\t  plane_state->color_plane[0].offset, 0);\n\n\treturn y;\n}\n\nstatic int skl_check_main_surface(struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int rotation = plane_state->hw.rotation;\n\tint x = plane_state->uapi.src.x1 >> 16;\n\tint y = plane_state->uapi.src.y1 >> 16;\n\tint w = drm_rect_width(&plane_state->uapi.src) >> 16;\n\tint h = drm_rect_height(&plane_state->uapi.src) >> 16;\n\tint max_width, min_width, max_height;\n\tu32 alignment, offset;\n\tint aux_plane = intel_main_to_aux_plane(fb, 0);\n\tu32 aux_offset = plane_state->color_plane[aux_plane].offset;\n\n\tif (INTEL_GEN(dev_priv) >= 11) {\n\t\tmax_width = icl_max_plane_width(fb, 0, rotation);\n\t\tmin_width = icl_min_plane_width(fb);\n\t} else if (INTEL_GEN(dev_priv) >= 10 || IS_GEMINILAKE(dev_priv)) {\n\t\tmax_width = glk_max_plane_width(fb, 0, rotation);\n\t\tmin_width = 1;\n\t} else {\n\t\tmax_width = skl_max_plane_width(fb, 0, rotation);\n\t\tmin_width = 1;\n\t}\n\n\tif (INTEL_GEN(dev_priv) >= 11)\n\t\tmax_height = icl_max_plane_height();\n\telse\n\t\tmax_height = skl_max_plane_height();\n\n\tif (w > max_width || w < min_width || h > max_height) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"requested Y/RGB source size %dx%d outside limits (min: %dx1 max: %dx%d)\\n\",\n\t\t\t    w, h, min_width, max_width, max_height);\n\t\treturn -EINVAL;\n\t}\n\n\tintel_add_fb_offsets(&x, &y, plane_state, 0);\n\toffset = intel_plane_compute_aligned_offset(&x, &y, plane_state, 0);\n\talignment = intel_surf_alignment(fb, 0);\n\tif (drm_WARN_ON(&dev_priv->drm, alignment && !is_power_of_2(alignment)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * AUX surface offset is specified as the distance from the\n\t * main surface offset, and it must be non-negative. Make\n\t * sure that is what we will get.\n\t */\n\tif (offset > aux_offset)\n\t\toffset = intel_plane_adjust_aligned_offset(&x, &y, plane_state, 0,\n\t\t\t\t\t\t\t   offset, aux_offset & ~(alignment - 1));\n\n\t/*\n\t * When using an X-tiled surface, the plane blows up\n\t * if the x offset + width exceed the stride.\n\t *\n\t * TODO: linear and Y-tiled seem fine, Yf untested,\n\t */\n\tif (fb->modifier == I915_FORMAT_MOD_X_TILED) {\n\t\tint cpp = fb->format->cpp[0];\n\n\t\twhile ((x + w) * cpp > plane_state->color_plane[0].stride) {\n\t\t\tif (offset == 0) {\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"Unable to find suitable display surface offset due to X-tiling\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\toffset = intel_plane_adjust_aligned_offset(&x, &y, plane_state, 0,\n\t\t\t\t\t\t\t\t   offset, offset - alignment);\n\t\t}\n\t}\n\n\t/*\n\t * CCS AUX surface doesn't have its own x/y offsets, we must make sure\n\t * they match with the main surface x/y offsets.\n\t */\n\tif (is_ccs_modifier(fb->modifier)) {\n\t\twhile (!skl_check_main_ccs_coordinates(plane_state, x, y,\n\t\t\t\t\t\t       offset, aux_plane)) {\n\t\t\tif (offset == 0)\n\t\t\t\tbreak;\n\n\t\t\toffset = intel_plane_adjust_aligned_offset(&x, &y, plane_state, 0,\n\t\t\t\t\t\t\t\t   offset, offset - alignment);\n\t\t}\n\n\t\tif (x != plane_state->color_plane[aux_plane].x ||\n\t\t    y != plane_state->color_plane[aux_plane].y) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Unable to find suitable display surface offset due to CCS\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tplane_state->color_plane[0].offset = offset;\n\tplane_state->color_plane[0].x = x;\n\tplane_state->color_plane[0].y = y;\n\n\t/*\n\t * Put the final coordinates back so that the src\n\t * coordinate checks will see the right values.\n\t */\n\tdrm_rect_translate_to(&plane_state->uapi.src,\n\t\t\t      x << 16, y << 16);\n\n\treturn 0;\n}\n\nstatic int skl_check_nv12_aux_surface(struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int rotation = plane_state->hw.rotation;\n\tint uv_plane = 1;\n\tint max_width = skl_max_plane_width(fb, uv_plane, rotation);\n\tint max_height = 4096;\n\tint x = plane_state->uapi.src.x1 >> 17;\n\tint y = plane_state->uapi.src.y1 >> 17;\n\tint w = drm_rect_width(&plane_state->uapi.src) >> 17;\n\tint h = drm_rect_height(&plane_state->uapi.src) >> 17;\n\tu32 offset;\n\n\tintel_add_fb_offsets(&x, &y, plane_state, uv_plane);\n\toffset = intel_plane_compute_aligned_offset(&x, &y,\n\t\t\t\t\t\t    plane_state, uv_plane);\n\n\t/* FIXME not quite sure how/if these apply to the chroma plane */\n\tif (w > max_width || h > max_height) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"CbCr source size %dx%d too big (limit %dx%d)\\n\",\n\t\t\t    w, h, max_width, max_height);\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_ccs_modifier(fb->modifier)) {\n\t\tint ccs_plane = main_to_ccs_plane(fb, uv_plane);\n\t\tint aux_offset = plane_state->color_plane[ccs_plane].offset;\n\t\tint alignment = intel_surf_alignment(fb, uv_plane);\n\n\t\tif (offset > aux_offset)\n\t\t\toffset = intel_plane_adjust_aligned_offset(&x, &y,\n\t\t\t\t\t\t\t\t   plane_state,\n\t\t\t\t\t\t\t\t   uv_plane,\n\t\t\t\t\t\t\t\t   offset,\n\t\t\t\t\t\t\t\t   aux_offset & ~(alignment - 1));\n\n\t\twhile (!skl_check_main_ccs_coordinates(plane_state, x, y,\n\t\t\t\t\t\t       offset, ccs_plane)) {\n\t\t\tif (offset == 0)\n\t\t\t\tbreak;\n\n\t\t\toffset = intel_plane_adjust_aligned_offset(&x, &y,\n\t\t\t\t\t\t\t\t   plane_state,\n\t\t\t\t\t\t\t\t   uv_plane,\n\t\t\t\t\t\t\t\t   offset, offset - alignment);\n\t\t}\n\n\t\tif (x != plane_state->color_plane[ccs_plane].x ||\n\t\t    y != plane_state->color_plane[ccs_plane].y) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"Unable to find suitable display surface offset due to CCS\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tplane_state->color_plane[uv_plane].offset = offset;\n\tplane_state->color_plane[uv_plane].x = x;\n\tplane_state->color_plane[uv_plane].y = y;\n\n\treturn 0;\n}\n\nstatic int skl_check_ccs_aux_surface(struct intel_plane_state *plane_state)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tint src_x = plane_state->uapi.src.x1 >> 16;\n\tint src_y = plane_state->uapi.src.y1 >> 16;\n\tu32 offset;\n\tint ccs_plane;\n\n\tfor (ccs_plane = 0; ccs_plane < fb->format->num_planes; ccs_plane++) {\n\t\tint main_hsub, main_vsub;\n\t\tint hsub, vsub;\n\t\tint x, y;\n\n\t\tif (!is_ccs_plane(fb, ccs_plane))\n\t\t\tcontinue;\n\n\t\tintel_fb_plane_get_subsampling(&main_hsub, &main_vsub, fb,\n\t\t\t\t\t       ccs_to_main_plane(fb, ccs_plane));\n\t\tintel_fb_plane_get_subsampling(&hsub, &vsub, fb, ccs_plane);\n\n\t\thsub *= main_hsub;\n\t\tvsub *= main_vsub;\n\t\tx = src_x / hsub;\n\t\ty = src_y / vsub;\n\n\t\tintel_add_fb_offsets(&x, &y, plane_state, ccs_plane);\n\n\t\toffset = intel_plane_compute_aligned_offset(&x, &y,\n\t\t\t\t\t\t\t    plane_state,\n\t\t\t\t\t\t\t    ccs_plane);\n\n\t\tplane_state->color_plane[ccs_plane].offset = offset;\n\t\tplane_state->color_plane[ccs_plane].x = (x * hsub +\n\t\t\t\t\t\t\t src_x % hsub) /\n\t\t\t\t\t\t\tmain_hsub;\n\t\tplane_state->color_plane[ccs_plane].y = (y * vsub +\n\t\t\t\t\t\t\t src_y % vsub) /\n\t\t\t\t\t\t\tmain_vsub;\n\t}\n\n\treturn 0;\n}\n\nint skl_check_plane_surface(struct intel_plane_state *plane_state)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tint ret, i;\n\n\tret = intel_plane_compute_gtt(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!plane_state->uapi.visible)\n\t\treturn 0;\n\n\t/*\n\t * Handle the AUX surface first since the main surface setup depends on\n\t * it.\n\t */\n\tif (is_ccs_modifier(fb->modifier)) {\n\t\tret = skl_check_ccs_aux_surface(plane_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (intel_format_info_is_yuv_semiplanar(fb->format,\n\t\t\t\t\t\tfb->modifier)) {\n\t\tret = skl_check_nv12_aux_surface(plane_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = fb->format->num_planes; i < ARRAY_SIZE(plane_state->color_plane); i++) {\n\t\tplane_state->color_plane[i].offset = ~0xfff;\n\t\tplane_state->color_plane[i].x = 0;\n\t\tplane_state->color_plane[i].y = 0;\n\t}\n\n\tret = skl_check_main_surface(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void i9xx_plane_ratio(const struct intel_crtc_state *crtc_state,\n\t\t\t     const struct intel_plane_state *plane_state,\n\t\t\t     unsigned int *num, unsigned int *den)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int cpp = fb->format->cpp[0];\n\n\t/*\n\t * g4x bspec says 64bpp pixel rate can't exceed 80%\n\t * of cdclk when the sprite plane is enabled on the\n\t * same pipe. ilk/snb bspec says 64bpp pixel rate is\n\t * never allowed to exceed 80% of cdclk. Let's just go\n\t * with the ilk/snb limit always.\n\t */\n\tif (cpp == 8) {\n\t\t*num = 10;\n\t\t*den = 8;\n\t} else {\n\t\t*num = 1;\n\t\t*den = 1;\n\t}\n}\n\nstatic int i9xx_plane_min_cdclk(const struct intel_crtc_state *crtc_state,\n\t\t\t\tconst struct intel_plane_state *plane_state)\n{\n\tunsigned int pixel_rate;\n\tunsigned int num, den;\n\n\t/*\n\t * Note that crtc_state->pixel_rate accounts for both\n\t * horizontal and vertical panel fitter downscaling factors.\n\t * Pre-HSW bspec tells us to only consider the horizontal\n\t * downscaling factor here. We ignore that and just consider\n\t * both for simplicity.\n\t */\n\tpixel_rate = crtc_state->pixel_rate;\n\n\ti9xx_plane_ratio(crtc_state, plane_state, &num, &den);\n\n\t/* two pixels per clock with double wide pipe */\n\tif (crtc_state->double_wide)\n\t\tden *= 2;\n\n\treturn DIV_ROUND_UP(pixel_rate * num, den);\n}\n\nunsigned int\ni9xx_plane_max_stride(struct intel_plane *plane,\n\t\t      u32 pixel_format, u64 modifier,\n\t\t      unsigned int rotation)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\n\tif (!HAS_GMCH(dev_priv)) {\n\t\treturn 32*1024;\n\t} else if (INTEL_GEN(dev_priv) >= 4) {\n\t\tif (modifier == I915_FORMAT_MOD_X_TILED)\n\t\t\treturn 16*1024;\n\t\telse\n\t\t\treturn 32*1024;\n\t} else if (INTEL_GEN(dev_priv) >= 3) {\n\t\tif (modifier == I915_FORMAT_MOD_X_TILED)\n\t\t\treturn 8*1024;\n\t\telse\n\t\t\treturn 16*1024;\n\t} else {\n\t\tif (plane->i9xx_plane == PLANE_C)\n\t\t\treturn 4*1024;\n\t\telse\n\t\t\treturn 8*1024;\n\t}\n}\n\nstatic u32 i9xx_plane_ctl_crtc(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 dspcntr = 0;\n\n\tif (crtc_state->gamma_enable)\n\t\tdspcntr |= DISPPLANE_GAMMA_ENABLE;\n\n\tif (crtc_state->csc_enable)\n\t\tdspcntr |= DISPPLANE_PIPE_CSC_ENABLE;\n\n\tif (INTEL_GEN(dev_priv) < 5)\n\t\tdspcntr |= DISPPLANE_SEL_PIPE(crtc->pipe);\n\n\treturn dspcntr;\n}\n\nstatic u32 i9xx_plane_ctl(const struct intel_crtc_state *crtc_state,\n\t\t\t  const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int rotation = plane_state->hw.rotation;\n\tu32 dspcntr;\n\n\tdspcntr = DISPLAY_PLANE_ENABLE;\n\n\tif (IS_G4X(dev_priv) || IS_GEN(dev_priv, 5) ||\n\t    IS_GEN(dev_priv, 6) || IS_IVYBRIDGE(dev_priv))\n\t\tdspcntr |= DISPPLANE_TRICKLE_FEED_DISABLE;\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_C8:\n\t\tdspcntr |= DISPPLANE_8BPP;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB1555:\n\t\tdspcntr |= DISPPLANE_BGRX555;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB1555:\n\t\tdspcntr |= DISPPLANE_BGRA555;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\t\tdspcntr |= DISPPLANE_BGRX565;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\t\tdspcntr |= DISPPLANE_BGRX888;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR8888:\n\t\tdspcntr |= DISPPLANE_RGBX888;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB8888:\n\t\tdspcntr |= DISPPLANE_BGRA888;\n\t\tbreak;\n\tcase DRM_FORMAT_ABGR8888:\n\t\tdspcntr |= DISPPLANE_RGBA888;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB2101010:\n\t\tdspcntr |= DISPPLANE_BGRX101010;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR2101010:\n\t\tdspcntr |= DISPPLANE_RGBX101010;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB2101010:\n\t\tdspcntr |= DISPPLANE_BGRA101010;\n\t\tbreak;\n\tcase DRM_FORMAT_ABGR2101010:\n\t\tdspcntr |= DISPPLANE_RGBA101010;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR16161616F:\n\t\tdspcntr |= DISPPLANE_RGBX161616;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(fb->format->format);\n\t\treturn 0;\n\t}\n\n\tif (INTEL_GEN(dev_priv) >= 4 &&\n\t    fb->modifier == I915_FORMAT_MOD_X_TILED)\n\t\tdspcntr |= DISPPLANE_TILED;\n\n\tif (rotation & DRM_MODE_ROTATE_180)\n\t\tdspcntr |= DISPPLANE_ROTATE_180;\n\n\tif (rotation & DRM_MODE_REFLECT_X)\n\t\tdspcntr |= DISPPLANE_MIRROR;\n\n\treturn dspcntr;\n}\n\nint i9xx_check_plane_surface(struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tint src_x, src_y, src_w;\n\tu32 offset;\n\tint ret;\n\n\tret = intel_plane_compute_gtt(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!plane_state->uapi.visible)\n\t\treturn 0;\n\n\tsrc_w = drm_rect_width(&plane_state->uapi.src) >> 16;\n\tsrc_x = plane_state->uapi.src.x1 >> 16;\n\tsrc_y = plane_state->uapi.src.y1 >> 16;\n\n\t/* Undocumented hardware limit on i965/g4x/vlv/chv */\n\tif (HAS_GMCH(dev_priv) && fb->format->cpp[0] == 8 && src_w > 2048)\n\t\treturn -EINVAL;\n\n\tintel_add_fb_offsets(&src_x, &src_y, plane_state, 0);\n\n\tif (INTEL_GEN(dev_priv) >= 4)\n\t\toffset = intel_plane_compute_aligned_offset(&src_x, &src_y,\n\t\t\t\t\t\t\t    plane_state, 0);\n\telse\n\t\toffset = 0;\n\n\t/*\n\t * Put the final coordinates back so that the src\n\t * coordinate checks will see the right values.\n\t */\n\tdrm_rect_translate_to(&plane_state->uapi.src,\n\t\t\t      src_x << 16, src_y << 16);\n\n\t/* HSW/BDW do this automagically in hardware */\n\tif (!IS_HASWELL(dev_priv) && !IS_BROADWELL(dev_priv)) {\n\t\tunsigned int rotation = plane_state->hw.rotation;\n\t\tint src_w = drm_rect_width(&plane_state->uapi.src) >> 16;\n\t\tint src_h = drm_rect_height(&plane_state->uapi.src) >> 16;\n\n\t\tif (rotation & DRM_MODE_ROTATE_180) {\n\t\t\tsrc_x += src_w - 1;\n\t\t\tsrc_y += src_h - 1;\n\t\t} else if (rotation & DRM_MODE_REFLECT_X) {\n\t\t\tsrc_x += src_w - 1;\n\t\t}\n\t}\n\n\tplane_state->color_plane[0].offset = offset;\n\tplane_state->color_plane[0].x = src_x;\n\tplane_state->color_plane[0].y = src_y;\n\n\treturn 0;\n}\n\nstatic bool i9xx_plane_has_windowing(struct intel_plane *plane)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum i9xx_plane_id i9xx_plane = plane->i9xx_plane;\n\n\tif (IS_CHERRYVIEW(dev_priv))\n\t\treturn i9xx_plane == PLANE_B;\n\telse if (INTEL_GEN(dev_priv) >= 5 || IS_G4X(dev_priv))\n\t\treturn false;\n\telse if (IS_GEN(dev_priv, 4))\n\t\treturn i9xx_plane == PLANE_C;\n\telse\n\t\treturn i9xx_plane == PLANE_B ||\n\t\t\ti9xx_plane == PLANE_C;\n}\n\nstatic int\ni9xx_plane_check(struct intel_crtc_state *crtc_state,\n\t\t struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tint ret;\n\n\tret = chv_plane_check_rotation(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_atomic_helper_check_plane_state(&plane_state->uapi,\n\t\t\t\t\t\t  &crtc_state->uapi,\n\t\t\t\t\t\t  DRM_PLANE_HELPER_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_HELPER_NO_SCALING,\n\t\t\t\t\t\t  i9xx_plane_has_windowing(plane),\n\t\t\t\t\t\t  true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i9xx_check_plane_surface(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!plane_state->uapi.visible)\n\t\treturn 0;\n\n\tret = intel_plane_check_src_coordinates(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tplane_state->ctl = i9xx_plane_ctl(crtc_state, plane_state);\n\n\treturn 0;\n}\n\nstatic void i9xx_update_plane(struct intel_plane *plane,\n\t\t\t      const struct intel_crtc_state *crtc_state,\n\t\t\t      const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum i9xx_plane_id i9xx_plane = plane->i9xx_plane;\n\tu32 linear_offset;\n\tint x = plane_state->color_plane[0].x;\n\tint y = plane_state->color_plane[0].y;\n\tint crtc_x = plane_state->uapi.dst.x1;\n\tint crtc_y = plane_state->uapi.dst.y1;\n\tint crtc_w = drm_rect_width(&plane_state->uapi.dst);\n\tint crtc_h = drm_rect_height(&plane_state->uapi.dst);\n\tunsigned long irqflags;\n\tu32 dspaddr_offset;\n\tu32 dspcntr;\n\n\tdspcntr = plane_state->ctl | i9xx_plane_ctl_crtc(crtc_state);\n\n\tlinear_offset = intel_fb_xy_to_linear(x, y, plane_state, 0);\n\n\tif (INTEL_GEN(dev_priv) >= 4)\n\t\tdspaddr_offset = plane_state->color_plane[0].offset;\n\telse\n\t\tdspaddr_offset = linear_offset;\n\n\tspin_lock_irqsave(&dev_priv->uncore.lock, irqflags);\n\n\tintel_de_write_fw(dev_priv, DSPSTRIDE(i9xx_plane),\n\t\t\t  plane_state->color_plane[0].stride);\n\n\tif (INTEL_GEN(dev_priv) < 4) {\n\t\t/*\n\t\t * PLANE_A doesn't actually have a full window\n\t\t * generator but let's assume we still need to\n\t\t * program whatever is there.\n\t\t */\n\t\tintel_de_write_fw(dev_priv, DSPPOS(i9xx_plane),\n\t\t\t\t  (crtc_y << 16) | crtc_x);\n\t\tintel_de_write_fw(dev_priv, DSPSIZE(i9xx_plane),\n\t\t\t\t  ((crtc_h - 1) << 16) | (crtc_w - 1));\n\t} else if (IS_CHERRYVIEW(dev_priv) && i9xx_plane == PLANE_B) {\n\t\tintel_de_write_fw(dev_priv, PRIMPOS(i9xx_plane),\n\t\t\t\t  (crtc_y << 16) | crtc_x);\n\t\tintel_de_write_fw(dev_priv, PRIMSIZE(i9xx_plane),\n\t\t\t\t  ((crtc_h - 1) << 16) | (crtc_w - 1));\n\t\tintel_de_write_fw(dev_priv, PRIMCNSTALPHA(i9xx_plane), 0);\n\t}\n\n\tif (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {\n\t\tintel_de_write_fw(dev_priv, DSPOFFSET(i9xx_plane),\n\t\t\t\t  (y << 16) | x);\n\t} else if (INTEL_GEN(dev_priv) >= 4) {\n\t\tintel_de_write_fw(dev_priv, DSPLINOFF(i9xx_plane),\n\t\t\t\t  linear_offset);\n\t\tintel_de_write_fw(dev_priv, DSPTILEOFF(i9xx_plane),\n\t\t\t\t  (y << 16) | x);\n\t}\n\n\t/*\n\t * The control register self-arms if the plane was previously\n\t * disabled. Try to make the plane enable atomic by writing\n\t * the control register just before the surface register.\n\t */\n\tintel_de_write_fw(dev_priv, DSPCNTR(i9xx_plane), dspcntr);\n\tif (INTEL_GEN(dev_priv) >= 4)\n\t\tintel_de_write_fw(dev_priv, DSPSURF(i9xx_plane),\n\t\t\t\t  intel_plane_ggtt_offset(plane_state) + dspaddr_offset);\n\telse\n\t\tintel_de_write_fw(dev_priv, DSPADDR(i9xx_plane),\n\t\t\t\t  intel_plane_ggtt_offset(plane_state) + dspaddr_offset);\n\n\tspin_unlock_irqrestore(&dev_priv->uncore.lock, irqflags);\n}\n\nstatic void i9xx_disable_plane(struct intel_plane *plane,\n\t\t\t       const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum i9xx_plane_id i9xx_plane = plane->i9xx_plane;\n\tunsigned long irqflags;\n\tu32 dspcntr;\n\n\t/*\n\t * DSPCNTR pipe gamma enable on g4x+ and pipe csc\n\t * enable on ilk+ affect the pipe bottom color as\n\t * well, so we must configure them even if the plane\n\t * is disabled.\n\t *\n\t * On pre-g4x there is no way to gamma correct the\n\t * pipe bottom color but we'll keep on doing this\n\t * anyway so that the crtc state readout works correctly.\n\t */\n\tdspcntr = i9xx_plane_ctl_crtc(crtc_state);\n\n\tspin_lock_irqsave(&dev_priv->uncore.lock, irqflags);\n\n\tintel_de_write_fw(dev_priv, DSPCNTR(i9xx_plane), dspcntr);\n\tif (INTEL_GEN(dev_priv) >= 4)\n\t\tintel_de_write_fw(dev_priv, DSPSURF(i9xx_plane), 0);\n\telse\n\t\tintel_de_write_fw(dev_priv, DSPADDR(i9xx_plane), 0);\n\n\tspin_unlock_irqrestore(&dev_priv->uncore.lock, irqflags);\n}\n\nstatic bool i9xx_plane_get_hw_state(struct intel_plane *plane,\n\t\t\t\t    enum pipe *pipe)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum intel_display_power_domain power_domain;\n\tenum i9xx_plane_id i9xx_plane = plane->i9xx_plane;\n\tintel_wakeref_t wakeref;\n\tbool ret;\n\tu32 val;\n\n\t/*\n\t * Not 100% correct for planes that can move between pipes,\n\t * but that's only the case for gen2-4 which don't have any\n\t * display power wells.\n\t */\n\tpower_domain = POWER_DOMAIN_PIPE(plane->pipe);\n\twakeref = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tval = intel_de_read(dev_priv, DSPCNTR(i9xx_plane));\n\n\tret = val & DISPLAY_PLANE_ENABLE;\n\n\tif (INTEL_GEN(dev_priv) >= 5)\n\t\t*pipe = plane->pipe;\n\telse\n\t\t*pipe = (val & DISPPLANE_SEL_PIPE_MASK) >>\n\t\t\tDISPPLANE_SEL_PIPE_SHIFT;\n\n\tintel_display_power_put(dev_priv, power_domain, wakeref);\n\n\treturn ret;\n}\n\nstatic void skl_detach_scaler(struct intel_crtc *intel_crtc, int id)\n{\n\tstruct drm_device *dev = intel_crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&dev_priv->uncore.lock, irqflags);\n\n\tintel_de_write_fw(dev_priv, SKL_PS_CTRL(intel_crtc->pipe, id), 0);\n\tintel_de_write_fw(dev_priv, SKL_PS_WIN_POS(intel_crtc->pipe, id), 0);\n\tintel_de_write_fw(dev_priv, SKL_PS_WIN_SZ(intel_crtc->pipe, id), 0);\n\n\tspin_unlock_irqrestore(&dev_priv->uncore.lock, irqflags);\n}\n\n/*\n * This function detaches (aka. unbinds) unused scalers in hardware\n */\nstatic void skl_detach_scalers(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *intel_crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tconst struct intel_crtc_scaler_state *scaler_state =\n\t\t&crtc_state->scaler_state;\n\tint i;\n\n\t/* loop through and disable scalers that aren't in use */\n\tfor (i = 0; i < intel_crtc->num_scalers; i++) {\n\t\tif (!scaler_state->scalers[i].in_use)\n\t\t\tskl_detach_scaler(intel_crtc, i);\n\t}\n}\n\nstatic unsigned int skl_plane_stride_mult(const struct drm_framebuffer *fb,\n\t\t\t\t\t  int color_plane, unsigned int rotation)\n{\n\t/*\n\t * The stride is either expressed as a multiple of 64 bytes chunks for\n\t * linear buffers or in number of tiles for tiled buffers.\n\t */\n\tif (is_surface_linear(fb, color_plane))\n\t\treturn 64;\n\telse if (drm_rotation_90_or_270(rotation))\n\t\treturn intel_tile_height(fb, color_plane);\n\telse\n\t\treturn intel_tile_width_bytes(fb, color_plane);\n}\n\nu32 skl_plane_stride(const struct intel_plane_state *plane_state,\n\t\t     int color_plane)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int rotation = plane_state->hw.rotation;\n\tu32 stride = plane_state->color_plane[color_plane].stride;\n\n\tif (color_plane >= fb->format->num_planes)\n\t\treturn 0;\n\n\treturn stride / skl_plane_stride_mult(fb, color_plane, rotation);\n}\n\nstatic u32 skl_plane_ctl_format(u32 pixel_format)\n{\n\tswitch (pixel_format) {\n\tcase DRM_FORMAT_C8:\n\t\treturn PLANE_CTL_FORMAT_INDEXED;\n\tcase DRM_FORMAT_RGB565:\n\t\treturn PLANE_CTL_FORMAT_RGB_565;\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ABGR8888:\n\t\treturn PLANE_CTL_FORMAT_XRGB_8888 | PLANE_CTL_ORDER_RGBX;\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\t\treturn PLANE_CTL_FORMAT_XRGB_8888;\n\tcase DRM_FORMAT_XBGR2101010:\n\tcase DRM_FORMAT_ABGR2101010:\n\t\treturn PLANE_CTL_FORMAT_XRGB_2101010 | PLANE_CTL_ORDER_RGBX;\n\tcase DRM_FORMAT_XRGB2101010:\n\tcase DRM_FORMAT_ARGB2101010:\n\t\treturn PLANE_CTL_FORMAT_XRGB_2101010;\n\tcase DRM_FORMAT_XBGR16161616F:\n\tcase DRM_FORMAT_ABGR16161616F:\n\t\treturn PLANE_CTL_FORMAT_XRGB_16161616F | PLANE_CTL_ORDER_RGBX;\n\tcase DRM_FORMAT_XRGB16161616F:\n\tcase DRM_FORMAT_ARGB16161616F:\n\t\treturn PLANE_CTL_FORMAT_XRGB_16161616F;\n\tcase DRM_FORMAT_XYUV8888:\n\t\treturn PLANE_CTL_FORMAT_XYUV;\n\tcase DRM_FORMAT_YUYV:\n\t\treturn PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_YUYV;\n\tcase DRM_FORMAT_YVYU:\n\t\treturn PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_YVYU;\n\tcase DRM_FORMAT_UYVY:\n\t\treturn PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_UYVY;\n\tcase DRM_FORMAT_VYUY:\n\t\treturn PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_VYUY;\n\tcase DRM_FORMAT_NV12:\n\t\treturn PLANE_CTL_FORMAT_NV12;\n\tcase DRM_FORMAT_P010:\n\t\treturn PLANE_CTL_FORMAT_P010;\n\tcase DRM_FORMAT_P012:\n\t\treturn PLANE_CTL_FORMAT_P012;\n\tcase DRM_FORMAT_P016:\n\t\treturn PLANE_CTL_FORMAT_P016;\n\tcase DRM_FORMAT_Y210:\n\t\treturn PLANE_CTL_FORMAT_Y210;\n\tcase DRM_FORMAT_Y212:\n\t\treturn PLANE_CTL_FORMAT_Y212;\n\tcase DRM_FORMAT_Y216:\n\t\treturn PLANE_CTL_FORMAT_Y216;\n\tcase DRM_FORMAT_XVYU2101010:\n\t\treturn PLANE_CTL_FORMAT_Y410;\n\tcase DRM_FORMAT_XVYU12_16161616:\n\t\treturn PLANE_CTL_FORMAT_Y412;\n\tcase DRM_FORMAT_XVYU16161616:\n\t\treturn PLANE_CTL_FORMAT_Y416;\n\tdefault:\n\t\tMISSING_CASE(pixel_format);\n\t}\n\n\treturn 0;\n}\n\nstatic u32 skl_plane_ctl_alpha(const struct intel_plane_state *plane_state)\n{\n\tif (!plane_state->hw.fb->format->has_alpha)\n\t\treturn PLANE_CTL_ALPHA_DISABLE;\n\n\tswitch (plane_state->hw.pixel_blend_mode) {\n\tcase DRM_MODE_BLEND_PIXEL_NONE:\n\t\treturn PLANE_CTL_ALPHA_DISABLE;\n\tcase DRM_MODE_BLEND_PREMULTI:\n\t\treturn PLANE_CTL_ALPHA_SW_PREMULTIPLY;\n\tcase DRM_MODE_BLEND_COVERAGE:\n\t\treturn PLANE_CTL_ALPHA_HW_PREMULTIPLY;\n\tdefault:\n\t\tMISSING_CASE(plane_state->hw.pixel_blend_mode);\n\t\treturn PLANE_CTL_ALPHA_DISABLE;\n\t}\n}\n\nstatic u32 glk_plane_color_ctl_alpha(const struct intel_plane_state *plane_state)\n{\n\tif (!plane_state->hw.fb->format->has_alpha)\n\t\treturn PLANE_COLOR_ALPHA_DISABLE;\n\n\tswitch (plane_state->hw.pixel_blend_mode) {\n\tcase DRM_MODE_BLEND_PIXEL_NONE:\n\t\treturn PLANE_COLOR_ALPHA_DISABLE;\n\tcase DRM_MODE_BLEND_PREMULTI:\n\t\treturn PLANE_COLOR_ALPHA_SW_PREMULTIPLY;\n\tcase DRM_MODE_BLEND_COVERAGE:\n\t\treturn PLANE_COLOR_ALPHA_HW_PREMULTIPLY;\n\tdefault:\n\t\tMISSING_CASE(plane_state->hw.pixel_blend_mode);\n\t\treturn PLANE_COLOR_ALPHA_DISABLE;\n\t}\n}\n\nstatic u32 skl_plane_ctl_tiling(u64 fb_modifier)\n{\n\tswitch (fb_modifier) {\n\tcase DRM_FORMAT_MOD_LINEAR:\n\t\tbreak;\n\tcase I915_FORMAT_MOD_X_TILED:\n\t\treturn PLANE_CTL_TILED_X;\n\tcase I915_FORMAT_MOD_Y_TILED:\n\t\treturn PLANE_CTL_TILED_Y;\n\tcase I915_FORMAT_MOD_Y_TILED_CCS:\n\t\treturn PLANE_CTL_TILED_Y | PLANE_CTL_RENDER_DECOMPRESSION_ENABLE;\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS:\n\t\treturn PLANE_CTL_TILED_Y |\n\t\t       PLANE_CTL_RENDER_DECOMPRESSION_ENABLE |\n\t\t       PLANE_CTL_CLEAR_COLOR_DISABLE;\n\tcase I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS:\n\t\treturn PLANE_CTL_TILED_Y | PLANE_CTL_MEDIA_DECOMPRESSION_ENABLE;\n\tcase I915_FORMAT_MOD_Yf_TILED:\n\t\treturn PLANE_CTL_TILED_YF;\n\tcase I915_FORMAT_MOD_Yf_TILED_CCS:\n\t\treturn PLANE_CTL_TILED_YF | PLANE_CTL_RENDER_DECOMPRESSION_ENABLE;\n\tdefault:\n\t\tMISSING_CASE(fb_modifier);\n\t}\n\n\treturn 0;\n}\n\nstatic u32 skl_plane_ctl_rotate(unsigned int rotate)\n{\n\tswitch (rotate) {\n\tcase DRM_MODE_ROTATE_0:\n\t\tbreak;\n\t/*\n\t * DRM_MODE_ROTATE_ is counter clockwise to stay compatible with Xrandr\n\t * while i915 HW rotation is clockwise, thats why this swapping.\n\t */\n\tcase DRM_MODE_ROTATE_90:\n\t\treturn PLANE_CTL_ROTATE_270;\n\tcase DRM_MODE_ROTATE_180:\n\t\treturn PLANE_CTL_ROTATE_180;\n\tcase DRM_MODE_ROTATE_270:\n\t\treturn PLANE_CTL_ROTATE_90;\n\tdefault:\n\t\tMISSING_CASE(rotate);\n\t}\n\n\treturn 0;\n}\n\nstatic u32 cnl_plane_ctl_flip(unsigned int reflect)\n{\n\tswitch (reflect) {\n\tcase 0:\n\t\tbreak;\n\tcase DRM_MODE_REFLECT_X:\n\t\treturn PLANE_CTL_FLIP_HORIZONTAL;\n\tcase DRM_MODE_REFLECT_Y:\n\tdefault:\n\t\tMISSING_CASE(reflect);\n\t}\n\n\treturn 0;\n}\n\nu32 skl_plane_ctl_crtc(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tu32 plane_ctl = 0;\n\n\tif (INTEL_GEN(dev_priv) >= 10 || IS_GEMINILAKE(dev_priv))\n\t\treturn plane_ctl;\n\n\tif (crtc_state->gamma_enable)\n\t\tplane_ctl |= PLANE_CTL_PIPE_GAMMA_ENABLE;\n\n\tif (crtc_state->csc_enable)\n\t\tplane_ctl |= PLANE_CTL_PIPE_CSC_ENABLE;\n\n\treturn plane_ctl;\n}\n\nu32 skl_plane_ctl(const struct intel_crtc_state *crtc_state,\n\t\t  const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tunsigned int rotation = plane_state->hw.rotation;\n\tconst struct drm_intel_sprite_colorkey *key = &plane_state->ckey;\n\tu32 plane_ctl;\n\n\tplane_ctl = PLANE_CTL_ENABLE;\n\n\tif (INTEL_GEN(dev_priv) < 10 && !IS_GEMINILAKE(dev_priv)) {\n\t\tplane_ctl |= skl_plane_ctl_alpha(plane_state);\n\t\tplane_ctl |= PLANE_CTL_PLANE_GAMMA_DISABLE;\n\n\t\tif (plane_state->hw.color_encoding == DRM_COLOR_YCBCR_BT709)\n\t\t\tplane_ctl |= PLANE_CTL_YUV_TO_RGB_CSC_FORMAT_BT709;\n\n\t\tif (plane_state->hw.color_range == DRM_COLOR_YCBCR_FULL_RANGE)\n\t\t\tplane_ctl |= PLANE_CTL_YUV_RANGE_CORRECTION_DISABLE;\n\t}\n\n\tplane_ctl |= skl_plane_ctl_format(fb->format->format);\n\tplane_ctl |= skl_plane_ctl_tiling(fb->modifier);\n\tplane_ctl |= skl_plane_ctl_rotate(rotation & DRM_MODE_ROTATE_MASK);\n\n\tif (INTEL_GEN(dev_priv) >= 10)\n\t\tplane_ctl |= cnl_plane_ctl_flip(rotation &\n\t\t\t\t\t\tDRM_MODE_REFLECT_MASK);\n\n\tif (key->flags & I915_SET_COLORKEY_DESTINATION)\n\t\tplane_ctl |= PLANE_CTL_KEY_ENABLE_DESTINATION;\n\telse if (key->flags & I915_SET_COLORKEY_SOURCE)\n\t\tplane_ctl |= PLANE_CTL_KEY_ENABLE_SOURCE;\n\n\treturn plane_ctl;\n}\n\nu32 glk_plane_color_ctl_crtc(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tu32 plane_color_ctl = 0;\n\n\tif (INTEL_GEN(dev_priv) >= 11)\n\t\treturn plane_color_ctl;\n\n\tif (crtc_state->gamma_enable)\n\t\tplane_color_ctl |= PLANE_COLOR_PIPE_GAMMA_ENABLE;\n\n\tif (crtc_state->csc_enable)\n\t\tplane_color_ctl |= PLANE_COLOR_PIPE_CSC_ENABLE;\n\n\treturn plane_color_ctl;\n}\n\nu32 glk_plane_color_ctl(const struct intel_crtc_state *crtc_state,\n\t\t\tconst struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tu32 plane_color_ctl = 0;\n\n\tplane_color_ctl |= PLANE_COLOR_PLANE_GAMMA_DISABLE;\n\tplane_color_ctl |= glk_plane_color_ctl_alpha(plane_state);\n\n\tif (fb->format->is_yuv && !icl_is_hdr_plane(dev_priv, plane->id)) {\n\t\tswitch (plane_state->hw.color_encoding) {\n\t\tcase DRM_COLOR_YCBCR_BT709:\n\t\t\tplane_color_ctl |= PLANE_COLOR_CSC_MODE_YUV709_TO_RGB709;\n\t\t\tbreak;\n\t\tcase DRM_COLOR_YCBCR_BT2020:\n\t\t\tplane_color_ctl |=\n\t\t\t\tPLANE_COLOR_CSC_MODE_YUV2020_TO_RGB2020;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tplane_color_ctl |=\n\t\t\t\tPLANE_COLOR_CSC_MODE_YUV601_TO_RGB601;\n\t\t}\n\t\tif (plane_state->hw.color_range == DRM_COLOR_YCBCR_FULL_RANGE)\n\t\t\tplane_color_ctl |= PLANE_COLOR_YUV_RANGE_CORRECTION_DISABLE;\n\t} else if (fb->format->is_yuv) {\n\t\tplane_color_ctl |= PLANE_COLOR_INPUT_CSC_ENABLE;\n\t}\n\n\treturn plane_color_ctl;\n}\n\nstatic int\n__intel_display_resume(struct drm_device *dev,\n\t\t       struct drm_atomic_state *state,\n\t\t       struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_crtc *crtc;\n\tint i, ret;\n\n\tintel_modeset_setup_hw_state(dev, ctx);\n\tintel_vga_redisable(to_i915(dev));\n\n\tif (!state)\n\t\treturn 0;\n\n\t/*\n\t * We've duplicated the state, pointers to the old state are invalid.\n\t *\n\t * Don't attempt to use the old state until we commit the duplicated state.\n\t */\n\tfor_each_new_crtc_in_state(state, crtc, crtc_state, i) {\n\t\t/*\n\t\t * Force recalculation even if we restore\n\t\t * current state. With fast modeset this may not result\n\t\t * in a modeset when the state is compatible.\n\t\t */\n\t\tcrtc_state->mode_changed = true;\n\t}\n\n\t/* ignore any reset values/BIOS leftovers in the WM registers */\n\tif (!HAS_GMCH(to_i915(dev)))\n\t\tto_intel_atomic_state(state)->skip_intermediate_wm = true;\n\n\tret = drm_atomic_helper_commit_duplicated_state(state, ctx);\n\n\tdrm_WARN_ON(dev, ret == -EDEADLK);\n\treturn ret;\n}\n\nstatic bool gpu_reset_clobbers_display(struct drm_i915_private *dev_priv)\n{\n\treturn (INTEL_INFO(dev_priv)->gpu_reset_clobbers_display &&\n\t\tintel_has_gpu_reset(&dev_priv->gt));\n}\n\nvoid intel_prepare_reset(struct drm_i915_private *dev_priv)\n{\n\tstruct drm_device *dev = &dev_priv->drm;\n\tstruct drm_modeset_acquire_ctx *ctx = &dev_priv->reset_ctx;\n\tstruct drm_atomic_state *state;\n\tint ret;\n\n\t/* reset doesn't touch the display */\n\tif (!dev_priv->params.force_reset_modeset_test &&\n\t    !gpu_reset_clobbers_display(dev_priv))\n\t\treturn;\n\n\t/* We have a modeset vs reset deadlock, defensively unbreak it. */\n\tset_bit(I915_RESET_MODESET, &dev_priv->gt.reset.flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&dev_priv->gt.reset.flags, I915_RESET_MODESET);\n\n\tif (atomic_read(&dev_priv->gpu_error.pending_fb_pin)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Modeset potentially stuck, unbreaking through wedging\\n\");\n\t\tintel_gt_set_wedged(&dev_priv->gt);\n\t}\n\n\t/*\n\t * Need mode_config.mutex so that we don't\n\t * trample ongoing ->detect() and whatnot.\n\t */\n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_modeset_acquire_init(ctx, 0);\n\twhile (1) {\n\t\tret = drm_modeset_lock_all_ctx(dev, ctx);\n\t\tif (ret != -EDEADLK)\n\t\t\tbreak;\n\n\t\tdrm_modeset_backoff(ctx);\n\t}\n\t/*\n\t * Disabling the crtcs gracefully seems nicer. Also the\n\t * g33 docs say we should at least disable all the planes.\n\t */\n\tstate = drm_atomic_helper_duplicate_state(dev, ctx);\n\tif (IS_ERR(state)) {\n\t\tret = PTR_ERR(state);\n\t\tdrm_err(&dev_priv->drm, \"Duplicating state failed with %i\\n\",\n\t\t\tret);\n\t\treturn;\n\t}\n\n\tret = drm_atomic_helper_disable_all(dev, ctx);\n\tif (ret) {\n\t\tdrm_err(&dev_priv->drm, \"Suspending crtc's failed with %i\\n\",\n\t\t\tret);\n\t\tdrm_atomic_state_put(state);\n\t\treturn;\n\t}\n\n\tdev_priv->modeset_restore_state = state;\n\tstate->acquire_ctx = ctx;\n}\n\nvoid intel_finish_reset(struct drm_i915_private *dev_priv)\n{\n\tstruct drm_device *dev = &dev_priv->drm;\n\tstruct drm_modeset_acquire_ctx *ctx = &dev_priv->reset_ctx;\n\tstruct drm_atomic_state *state;\n\tint ret;\n\n\t/* reset doesn't touch the display */\n\tif (!test_bit(I915_RESET_MODESET, &dev_priv->gt.reset.flags))\n\t\treturn;\n\n\tstate = fetch_and_zero(&dev_priv->modeset_restore_state);\n\tif (!state)\n\t\tgoto unlock;\n\n\t/* reset doesn't touch the display */\n\tif (!gpu_reset_clobbers_display(dev_priv)) {\n\t\t/* for testing only restore the display */\n\t\tret = __intel_display_resume(dev, state, ctx);\n\t\tif (ret)\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Restoring old state failed with %i\\n\", ret);\n\t} else {\n\t\t/*\n\t\t * The display has been reset as well,\n\t\t * so need a full re-initialization.\n\t\t */\n\t\tintel_pps_unlock_regs_wa(dev_priv);\n\t\tintel_modeset_init_hw(dev_priv);\n\t\tintel_init_clock_gating(dev_priv);\n\n\t\tspin_lock_irq(&dev_priv->irq_lock);\n\t\tif (dev_priv->display.hpd_irq_setup)\n\t\t\tdev_priv->display.hpd_irq_setup(dev_priv);\n\t\tspin_unlock_irq(&dev_priv->irq_lock);\n\n\t\tret = __intel_display_resume(dev, state, ctx);\n\t\tif (ret)\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Restoring old state failed with %i\\n\", ret);\n\n\t\tintel_hpd_init(dev_priv);\n\t}\n\n\tdrm_atomic_state_put(state);\nunlock:\n\tdrm_modeset_drop_locks(ctx);\n\tdrm_modeset_acquire_fini(ctx);\n\tmutex_unlock(&dev->mode_config.mutex);\n\n\tclear_bit_unlock(I915_RESET_MODESET, &dev_priv->gt.reset.flags);\n}\n\nstatic void icl_set_pipe_chicken(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tu32 tmp;\n\n\ttmp = intel_de_read(dev_priv, PIPE_CHICKEN(pipe));\n\n\t/*\n\t * Display WA #1153: icl\n\t * enable hardware to bypass the alpha math\n\t * and rounding for per-pixel values 00 and 0xff\n\t */\n\ttmp |= PER_PIXEL_ALPHA_BYPASS_EN;\n\t/*\n\t * Display WA # 1605353570: icl\n\t * Set the pixel rounding bit to 1 for allowing\n\t * passthrough of Frame buffer pixels unmodified\n\t * across pipe\n\t */\n\ttmp |= PIXEL_ROUNDING_TRUNC_FB_PASSTHRU;\n\tintel_de_write(dev_priv, PIPE_CHICKEN(pipe), tmp);\n}\n\nstatic void intel_fdi_normal_train(struct intel_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum pipe pipe = crtc->pipe;\n\ti915_reg_t reg;\n\tu32 temp;\n\n\t/* enable normal train */\n\treg = FDI_TX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\tif (IS_IVYBRIDGE(dev_priv)) {\n\t\ttemp &= ~FDI_LINK_TRAIN_NONE_IVB;\n\t\ttemp |= FDI_LINK_TRAIN_NONE_IVB | FDI_TX_ENHANCE_FRAME_ENABLE;\n\t} else {\n\t\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\t\ttemp |= FDI_LINK_TRAIN_NONE | FDI_TX_ENHANCE_FRAME_ENABLE;\n\t}\n\tintel_de_write(dev_priv, reg, temp);\n\n\treg = FDI_RX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\tif (HAS_PCH_CPT(dev_priv)) {\n\t\ttemp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;\n\t\ttemp |= FDI_LINK_TRAIN_NORMAL_CPT;\n\t} else {\n\t\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\t\ttemp |= FDI_LINK_TRAIN_NONE;\n\t}\n\tintel_de_write(dev_priv, reg, temp | FDI_RX_ENHANCE_FRAME_ENABLE);\n\n\t/* wait one idle pattern time */\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(1000);\n\n\t/* IVB wants error correction enabled */\n\tif (IS_IVYBRIDGE(dev_priv))\n\t\tintel_de_write(dev_priv, reg,\n\t\t               intel_de_read(dev_priv, reg) | FDI_FS_ERRC_ENABLE | FDI_FE_ERRC_ENABLE);\n}\n\n/* The FDI link training functions for ILK/Ibexpeak. */\nstatic void ilk_fdi_link_train(struct intel_crtc *crtc,\n\t\t\t       const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum pipe pipe = crtc->pipe;\n\ti915_reg_t reg;\n\tu32 temp, tries;\n\n\t/* FDI needs bits from pipe first */\n\tassert_pipe_enabled(dev_priv, crtc_state->cpu_transcoder);\n\n\t/* Train 1: umask FDI RX Interrupt symbol_lock and bit_lock bit\n\t   for train result */\n\treg = FDI_RX_IMR(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~FDI_RX_SYMBOL_LOCK;\n\ttemp &= ~FDI_RX_BIT_LOCK;\n\tintel_de_write(dev_priv, reg, temp);\n\tintel_de_read(dev_priv, reg);\n\tudelay(150);\n\n\t/* enable CPU FDI TX and PCH FDI RX */\n\treg = FDI_TX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~FDI_DP_PORT_WIDTH_MASK;\n\ttemp |= FDI_DP_PORT_WIDTH(crtc_state->fdi_lanes);\n\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\ttemp |= FDI_LINK_TRAIN_PATTERN_1;\n\tintel_de_write(dev_priv, reg, temp | FDI_TX_ENABLE);\n\n\treg = FDI_RX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\ttemp |= FDI_LINK_TRAIN_PATTERN_1;\n\tintel_de_write(dev_priv, reg, temp | FDI_RX_ENABLE);\n\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(150);\n\n\t/* Ironlake workaround, enable clock pointer after FDI enable*/\n\tintel_de_write(dev_priv, FDI_RX_CHICKEN(pipe),\n\t\t       FDI_RX_PHASE_SYNC_POINTER_OVR);\n\tintel_de_write(dev_priv, FDI_RX_CHICKEN(pipe),\n\t\t       FDI_RX_PHASE_SYNC_POINTER_OVR | FDI_RX_PHASE_SYNC_POINTER_EN);\n\n\treg = FDI_RX_IIR(pipe);\n\tfor (tries = 0; tries < 5; tries++) {\n\t\ttemp = intel_de_read(dev_priv, reg);\n\t\tdrm_dbg_kms(&dev_priv->drm, \"FDI_RX_IIR 0x%x\\n\", temp);\n\n\t\tif ((temp & FDI_RX_BIT_LOCK)) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"FDI train 1 done.\\n\");\n\t\t\tintel_de_write(dev_priv, reg, temp | FDI_RX_BIT_LOCK);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (tries == 5)\n\t\tdrm_err(&dev_priv->drm, \"FDI train 1 fail!\\n\");\n\n\t/* Train 2 */\n\treg = FDI_TX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\ttemp |= FDI_LINK_TRAIN_PATTERN_2;\n\tintel_de_write(dev_priv, reg, temp);\n\n\treg = FDI_RX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\ttemp |= FDI_LINK_TRAIN_PATTERN_2;\n\tintel_de_write(dev_priv, reg, temp);\n\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(150);\n\n\treg = FDI_RX_IIR(pipe);\n\tfor (tries = 0; tries < 5; tries++) {\n\t\ttemp = intel_de_read(dev_priv, reg);\n\t\tdrm_dbg_kms(&dev_priv->drm, \"FDI_RX_IIR 0x%x\\n\", temp);\n\n\t\tif (temp & FDI_RX_SYMBOL_LOCK) {\n\t\t\tintel_de_write(dev_priv, reg,\n\t\t\t\t       temp | FDI_RX_SYMBOL_LOCK);\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"FDI train 2 done.\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (tries == 5)\n\t\tdrm_err(&dev_priv->drm, \"FDI train 2 fail!\\n\");\n\n\tdrm_dbg_kms(&dev_priv->drm, \"FDI train done\\n\");\n\n}\n\nstatic const int snb_b_fdi_train_param[] = {\n\tFDI_LINK_TRAIN_400MV_0DB_SNB_B,\n\tFDI_LINK_TRAIN_400MV_6DB_SNB_B,\n\tFDI_LINK_TRAIN_600MV_3_5DB_SNB_B,\n\tFDI_LINK_TRAIN_800MV_0DB_SNB_B,\n};\n\n/* The FDI link training functions for SNB/Cougarpoint. */\nstatic void gen6_fdi_link_train(struct intel_crtc *crtc,\n\t\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum pipe pipe = crtc->pipe;\n\ti915_reg_t reg;\n\tu32 temp, i, retry;\n\n\t/* Train 1: umask FDI RX Interrupt symbol_lock and bit_lock bit\n\t   for train result */\n\treg = FDI_RX_IMR(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~FDI_RX_SYMBOL_LOCK;\n\ttemp &= ~FDI_RX_BIT_LOCK;\n\tintel_de_write(dev_priv, reg, temp);\n\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(150);\n\n\t/* enable CPU FDI TX and PCH FDI RX */\n\treg = FDI_TX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~FDI_DP_PORT_WIDTH_MASK;\n\ttemp |= FDI_DP_PORT_WIDTH(crtc_state->fdi_lanes);\n\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\ttemp |= FDI_LINK_TRAIN_PATTERN_1;\n\ttemp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;\n\t/* SNB-B */\n\ttemp |= FDI_LINK_TRAIN_400MV_0DB_SNB_B;\n\tintel_de_write(dev_priv, reg, temp | FDI_TX_ENABLE);\n\n\tintel_de_write(dev_priv, FDI_RX_MISC(pipe),\n\t\t       FDI_RX_TP1_TO_TP2_48 | FDI_RX_FDI_DELAY_90);\n\n\treg = FDI_RX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\tif (HAS_PCH_CPT(dev_priv)) {\n\t\ttemp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;\n\t\ttemp |= FDI_LINK_TRAIN_PATTERN_1_CPT;\n\t} else {\n\t\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\t\ttemp |= FDI_LINK_TRAIN_PATTERN_1;\n\t}\n\tintel_de_write(dev_priv, reg, temp | FDI_RX_ENABLE);\n\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(150);\n\n\tfor (i = 0; i < 4; i++) {\n\t\treg = FDI_TX_CTL(pipe);\n\t\ttemp = intel_de_read(dev_priv, reg);\n\t\ttemp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;\n\t\ttemp |= snb_b_fdi_train_param[i];\n\t\tintel_de_write(dev_priv, reg, temp);\n\n\t\tintel_de_posting_read(dev_priv, reg);\n\t\tudelay(500);\n\n\t\tfor (retry = 0; retry < 5; retry++) {\n\t\t\treg = FDI_RX_IIR(pipe);\n\t\t\ttemp = intel_de_read(dev_priv, reg);\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"FDI_RX_IIR 0x%x\\n\", temp);\n\t\t\tif (temp & FDI_RX_BIT_LOCK) {\n\t\t\t\tintel_de_write(dev_priv, reg,\n\t\t\t\t\t       temp | FDI_RX_BIT_LOCK);\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"FDI train 1 done.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(50);\n\t\t}\n\t\tif (retry < 5)\n\t\t\tbreak;\n\t}\n\tif (i == 4)\n\t\tdrm_err(&dev_priv->drm, \"FDI train 1 fail!\\n\");\n\n\t/* Train 2 */\n\treg = FDI_TX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\ttemp |= FDI_LINK_TRAIN_PATTERN_2;\n\tif (IS_GEN(dev_priv, 6)) {\n\t\ttemp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;\n\t\t/* SNB-B */\n\t\ttemp |= FDI_LINK_TRAIN_400MV_0DB_SNB_B;\n\t}\n\tintel_de_write(dev_priv, reg, temp);\n\n\treg = FDI_RX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\tif (HAS_PCH_CPT(dev_priv)) {\n\t\ttemp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;\n\t\ttemp |= FDI_LINK_TRAIN_PATTERN_2_CPT;\n\t} else {\n\t\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\t\ttemp |= FDI_LINK_TRAIN_PATTERN_2;\n\t}\n\tintel_de_write(dev_priv, reg, temp);\n\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(150);\n\n\tfor (i = 0; i < 4; i++) {\n\t\treg = FDI_TX_CTL(pipe);\n\t\ttemp = intel_de_read(dev_priv, reg);\n\t\ttemp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;\n\t\ttemp |= snb_b_fdi_train_param[i];\n\t\tintel_de_write(dev_priv, reg, temp);\n\n\t\tintel_de_posting_read(dev_priv, reg);\n\t\tudelay(500);\n\n\t\tfor (retry = 0; retry < 5; retry++) {\n\t\t\treg = FDI_RX_IIR(pipe);\n\t\t\ttemp = intel_de_read(dev_priv, reg);\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"FDI_RX_IIR 0x%x\\n\", temp);\n\t\t\tif (temp & FDI_RX_SYMBOL_LOCK) {\n\t\t\t\tintel_de_write(dev_priv, reg,\n\t\t\t\t\t       temp | FDI_RX_SYMBOL_LOCK);\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"FDI train 2 done.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(50);\n\t\t}\n\t\tif (retry < 5)\n\t\t\tbreak;\n\t}\n\tif (i == 4)\n\t\tdrm_err(&dev_priv->drm, \"FDI train 2 fail!\\n\");\n\n\tdrm_dbg_kms(&dev_priv->drm, \"FDI train done.\\n\");\n}\n\n/* Manual link training for Ivy Bridge A0 parts */\nstatic void ivb_manual_fdi_link_train(struct intel_crtc *crtc,\n\t\t\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum pipe pipe = crtc->pipe;\n\ti915_reg_t reg;\n\tu32 temp, i, j;\n\n\t/* Train 1: umask FDI RX Interrupt symbol_lock and bit_lock bit\n\t   for train result */\n\treg = FDI_RX_IMR(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~FDI_RX_SYMBOL_LOCK;\n\ttemp &= ~FDI_RX_BIT_LOCK;\n\tintel_de_write(dev_priv, reg, temp);\n\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(150);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"FDI_RX_IIR before link train 0x%x\\n\",\n\t\t    intel_de_read(dev_priv, FDI_RX_IIR(pipe)));\n\n\t/* Try each vswing and preemphasis setting twice before moving on */\n\tfor (j = 0; j < ARRAY_SIZE(snb_b_fdi_train_param) * 2; j++) {\n\t\t/* disable first in case we need to retry */\n\t\treg = FDI_TX_CTL(pipe);\n\t\ttemp = intel_de_read(dev_priv, reg);\n\t\ttemp &= ~(FDI_LINK_TRAIN_AUTO | FDI_LINK_TRAIN_NONE_IVB);\n\t\ttemp &= ~FDI_TX_ENABLE;\n\t\tintel_de_write(dev_priv, reg, temp);\n\n\t\treg = FDI_RX_CTL(pipe);\n\t\ttemp = intel_de_read(dev_priv, reg);\n\t\ttemp &= ~FDI_LINK_TRAIN_AUTO;\n\t\ttemp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;\n\t\ttemp &= ~FDI_RX_ENABLE;\n\t\tintel_de_write(dev_priv, reg, temp);\n\n\t\t/* enable CPU FDI TX and PCH FDI RX */\n\t\treg = FDI_TX_CTL(pipe);\n\t\ttemp = intel_de_read(dev_priv, reg);\n\t\ttemp &= ~FDI_DP_PORT_WIDTH_MASK;\n\t\ttemp |= FDI_DP_PORT_WIDTH(crtc_state->fdi_lanes);\n\t\ttemp |= FDI_LINK_TRAIN_PATTERN_1_IVB;\n\t\ttemp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;\n\t\ttemp |= snb_b_fdi_train_param[j/2];\n\t\ttemp |= FDI_COMPOSITE_SYNC;\n\t\tintel_de_write(dev_priv, reg, temp | FDI_TX_ENABLE);\n\n\t\tintel_de_write(dev_priv, FDI_RX_MISC(pipe),\n\t\t\t       FDI_RX_TP1_TO_TP2_48 | FDI_RX_FDI_DELAY_90);\n\n\t\treg = FDI_RX_CTL(pipe);\n\t\ttemp = intel_de_read(dev_priv, reg);\n\t\ttemp |= FDI_LINK_TRAIN_PATTERN_1_CPT;\n\t\ttemp |= FDI_COMPOSITE_SYNC;\n\t\tintel_de_write(dev_priv, reg, temp | FDI_RX_ENABLE);\n\n\t\tintel_de_posting_read(dev_priv, reg);\n\t\tudelay(1); /* should be 0.5us */\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\treg = FDI_RX_IIR(pipe);\n\t\t\ttemp = intel_de_read(dev_priv, reg);\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"FDI_RX_IIR 0x%x\\n\", temp);\n\n\t\t\tif (temp & FDI_RX_BIT_LOCK ||\n\t\t\t    (intel_de_read(dev_priv, reg) & FDI_RX_BIT_LOCK)) {\n\t\t\t\tintel_de_write(dev_priv, reg,\n\t\t\t\t\t       temp | FDI_RX_BIT_LOCK);\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"FDI train 1 done, level %i.\\n\",\n\t\t\t\t\t    i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(1); /* should be 0.5us */\n\t\t}\n\t\tif (i == 4) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"FDI train 1 fail on vswing %d\\n\", j / 2);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Train 2 */\n\t\treg = FDI_TX_CTL(pipe);\n\t\ttemp = intel_de_read(dev_priv, reg);\n\t\ttemp &= ~FDI_LINK_TRAIN_NONE_IVB;\n\t\ttemp |= FDI_LINK_TRAIN_PATTERN_2_IVB;\n\t\tintel_de_write(dev_priv, reg, temp);\n\n\t\treg = FDI_RX_CTL(pipe);\n\t\ttemp = intel_de_read(dev_priv, reg);\n\t\ttemp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;\n\t\ttemp |= FDI_LINK_TRAIN_PATTERN_2_CPT;\n\t\tintel_de_write(dev_priv, reg, temp);\n\n\t\tintel_de_posting_read(dev_priv, reg);\n\t\tudelay(2); /* should be 1.5us */\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\treg = FDI_RX_IIR(pipe);\n\t\t\ttemp = intel_de_read(dev_priv, reg);\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"FDI_RX_IIR 0x%x\\n\", temp);\n\n\t\t\tif (temp & FDI_RX_SYMBOL_LOCK ||\n\t\t\t    (intel_de_read(dev_priv, reg) & FDI_RX_SYMBOL_LOCK)) {\n\t\t\t\tintel_de_write(dev_priv, reg,\n\t\t\t\t\t       temp | FDI_RX_SYMBOL_LOCK);\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"FDI train 2 done, level %i.\\n\",\n\t\t\t\t\t    i);\n\t\t\t\tgoto train_done;\n\t\t\t}\n\t\t\tudelay(2); /* should be 1.5us */\n\t\t}\n\t\tif (i == 4)\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"FDI train 2 fail on vswing %d\\n\", j / 2);\n\t}\n\ntrain_done:\n\tdrm_dbg_kms(&dev_priv->drm, \"FDI train done.\\n\");\n}\n\nstatic void ilk_fdi_pll_enable(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *intel_crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(intel_crtc->base.dev);\n\tenum pipe pipe = intel_crtc->pipe;\n\ti915_reg_t reg;\n\tu32 temp;\n\n\t/* enable PCH FDI RX PLL, wait warmup plus DMI latency */\n\treg = FDI_RX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~(FDI_DP_PORT_WIDTH_MASK | (0x7 << 16));\n\ttemp |= FDI_DP_PORT_WIDTH(crtc_state->fdi_lanes);\n\ttemp |= (intel_de_read(dev_priv, PIPECONF(pipe)) & PIPECONF_BPC_MASK) << 11;\n\tintel_de_write(dev_priv, reg, temp | FDI_RX_PLL_ENABLE);\n\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(200);\n\n\t/* Switch from Rawclk to PCDclk */\n\ttemp = intel_de_read(dev_priv, reg);\n\tintel_de_write(dev_priv, reg, temp | FDI_PCDCLK);\n\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(200);\n\n\t/* Enable CPU FDI TX PLL, always on for Ironlake */\n\treg = FDI_TX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\tif ((temp & FDI_TX_PLL_ENABLE) == 0) {\n\t\tintel_de_write(dev_priv, reg, temp | FDI_TX_PLL_ENABLE);\n\n\t\tintel_de_posting_read(dev_priv, reg);\n\t\tudelay(100);\n\t}\n}\n\nstatic void ilk_fdi_pll_disable(struct intel_crtc *intel_crtc)\n{\n\tstruct drm_device *dev = intel_crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum pipe pipe = intel_crtc->pipe;\n\ti915_reg_t reg;\n\tu32 temp;\n\n\t/* Switch from PCDclk to Rawclk */\n\treg = FDI_RX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\tintel_de_write(dev_priv, reg, temp & ~FDI_PCDCLK);\n\n\t/* Disable CPU FDI TX PLL */\n\treg = FDI_TX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\tintel_de_write(dev_priv, reg, temp & ~FDI_TX_PLL_ENABLE);\n\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(100);\n\n\treg = FDI_RX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\tintel_de_write(dev_priv, reg, temp & ~FDI_RX_PLL_ENABLE);\n\n\t/* Wait for the clocks to turn off. */\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(100);\n}\n\nstatic void ilk_fdi_disable(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\ti915_reg_t reg;\n\tu32 temp;\n\n\t/* disable CPU FDI tx and PCH FDI rx */\n\treg = FDI_TX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\tintel_de_write(dev_priv, reg, temp & ~FDI_TX_ENABLE);\n\tintel_de_posting_read(dev_priv, reg);\n\n\treg = FDI_RX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~(0x7 << 16);\n\ttemp |= (intel_de_read(dev_priv, PIPECONF(pipe)) & PIPECONF_BPC_MASK) << 11;\n\tintel_de_write(dev_priv, reg, temp & ~FDI_RX_ENABLE);\n\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(100);\n\n\t/* Ironlake workaround, disable clock pointer after downing FDI */\n\tif (HAS_PCH_IBX(dev_priv))\n\t\tintel_de_write(dev_priv, FDI_RX_CHICKEN(pipe),\n\t\t\t       FDI_RX_PHASE_SYNC_POINTER_OVR);\n\n\t/* still set train pattern 1 */\n\treg = FDI_TX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\ttemp |= FDI_LINK_TRAIN_PATTERN_1;\n\tintel_de_write(dev_priv, reg, temp);\n\n\treg = FDI_RX_CTL(pipe);\n\ttemp = intel_de_read(dev_priv, reg);\n\tif (HAS_PCH_CPT(dev_priv)) {\n\t\ttemp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;\n\t\ttemp |= FDI_LINK_TRAIN_PATTERN_1_CPT;\n\t} else {\n\t\ttemp &= ~FDI_LINK_TRAIN_NONE;\n\t\ttemp |= FDI_LINK_TRAIN_PATTERN_1;\n\t}\n\t/* BPC in FDI rx is consistent with that in PIPECONF */\n\ttemp &= ~(0x07 << 16);\n\ttemp |= (intel_de_read(dev_priv, PIPECONF(pipe)) & PIPECONF_BPC_MASK) << 11;\n\tintel_de_write(dev_priv, reg, temp);\n\n\tintel_de_posting_read(dev_priv, reg);\n\tudelay(100);\n}\n\nbool intel_has_pending_fb_unpin(struct drm_i915_private *dev_priv)\n{\n\tstruct drm_crtc *crtc;\n\tbool cleanup_done;\n\n\tdrm_for_each_crtc(crtc, &dev_priv->drm) {\n\t\tstruct drm_crtc_commit *commit;\n\t\tspin_lock(&crtc->commit_lock);\n\t\tcommit = list_first_entry_or_null(&crtc->commit_list,\n\t\t\t\t\t\t  struct drm_crtc_commit, commit_entry);\n\t\tcleanup_done = commit ?\n\t\t\ttry_wait_for_completion(&commit->cleanup_done) : true;\n\t\tspin_unlock(&crtc->commit_lock);\n\n\t\tif (cleanup_done)\n\t\t\tcontinue;\n\n\t\tdrm_crtc_wait_one_vblank(crtc);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid lpt_disable_iclkip(struct drm_i915_private *dev_priv)\n{\n\tu32 temp;\n\n\tintel_de_write(dev_priv, PIXCLK_GATE, PIXCLK_GATE_GATE);\n\n\tmutex_lock(&dev_priv->sb_lock);\n\n\ttemp = intel_sbi_read(dev_priv, SBI_SSCCTL6, SBI_ICLK);\n\ttemp |= SBI_SSCCTL_DISABLE;\n\tintel_sbi_write(dev_priv, SBI_SSCCTL6, temp, SBI_ICLK);\n\n\tmutex_unlock(&dev_priv->sb_lock);\n}\n\n/* Program iCLKIP clock to the desired frequency */\nstatic void lpt_program_iclkip(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tint clock = crtc_state->hw.adjusted_mode.crtc_clock;\n\tu32 divsel, phaseinc, auxdiv, phasedir = 0;\n\tu32 temp;\n\n\tlpt_disable_iclkip(dev_priv);\n\n\t/* The iCLK virtual clock root frequency is in MHz,\n\t * but the adjusted_mode->crtc_clock in in KHz. To get the\n\t * divisors, it is necessary to divide one by another, so we\n\t * convert the virtual clock precision to KHz here for higher\n\t * precision.\n\t */\n\tfor (auxdiv = 0; auxdiv < 2; auxdiv++) {\n\t\tu32 iclk_virtual_root_freq = 172800 * 1000;\n\t\tu32 iclk_pi_range = 64;\n\t\tu32 desired_divisor;\n\n\t\tdesired_divisor = DIV_ROUND_CLOSEST(iclk_virtual_root_freq,\n\t\t\t\t\t\t    clock << auxdiv);\n\t\tdivsel = (desired_divisor / iclk_pi_range) - 2;\n\t\tphaseinc = desired_divisor % iclk_pi_range;\n\n\t\t/*\n\t\t * Near 20MHz is a corner case which is\n\t\t * out of range for the 7-bit divisor\n\t\t */\n\t\tif (divsel <= 0x7f)\n\t\t\tbreak;\n\t}\n\n\t/* This should not happen with any sane values */\n\tdrm_WARN_ON(&dev_priv->drm, SBI_SSCDIVINTPHASE_DIVSEL(divsel) &\n\t\t    ~SBI_SSCDIVINTPHASE_DIVSEL_MASK);\n\tdrm_WARN_ON(&dev_priv->drm, SBI_SSCDIVINTPHASE_DIR(phasedir) &\n\t\t    ~SBI_SSCDIVINTPHASE_INCVAL_MASK);\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"iCLKIP clock: found settings for %dKHz refresh rate: auxdiv=%x, divsel=%x, phasedir=%x, phaseinc=%x\\n\",\n\t\t    clock, auxdiv, divsel, phasedir, phaseinc);\n\n\tmutex_lock(&dev_priv->sb_lock);\n\n\t/* Program SSCDIVINTPHASE6 */\n\ttemp = intel_sbi_read(dev_priv, SBI_SSCDIVINTPHASE6, SBI_ICLK);\n\ttemp &= ~SBI_SSCDIVINTPHASE_DIVSEL_MASK;\n\ttemp |= SBI_SSCDIVINTPHASE_DIVSEL(divsel);\n\ttemp &= ~SBI_SSCDIVINTPHASE_INCVAL_MASK;\n\ttemp |= SBI_SSCDIVINTPHASE_INCVAL(phaseinc);\n\ttemp |= SBI_SSCDIVINTPHASE_DIR(phasedir);\n\ttemp |= SBI_SSCDIVINTPHASE_PROPAGATE;\n\tintel_sbi_write(dev_priv, SBI_SSCDIVINTPHASE6, temp, SBI_ICLK);\n\n\t/* Program SSCAUXDIV */\n\ttemp = intel_sbi_read(dev_priv, SBI_SSCAUXDIV6, SBI_ICLK);\n\ttemp &= ~SBI_SSCAUXDIV_FINALDIV2SEL(1);\n\ttemp |= SBI_SSCAUXDIV_FINALDIV2SEL(auxdiv);\n\tintel_sbi_write(dev_priv, SBI_SSCAUXDIV6, temp, SBI_ICLK);\n\n\t/* Enable modulator and associated divider */\n\ttemp = intel_sbi_read(dev_priv, SBI_SSCCTL6, SBI_ICLK);\n\ttemp &= ~SBI_SSCCTL_DISABLE;\n\tintel_sbi_write(dev_priv, SBI_SSCCTL6, temp, SBI_ICLK);\n\n\tmutex_unlock(&dev_priv->sb_lock);\n\n\t/* Wait for initialization time */\n\tudelay(24);\n\n\tintel_de_write(dev_priv, PIXCLK_GATE, PIXCLK_GATE_UNGATE);\n}\n\nint lpt_get_iclkip(struct drm_i915_private *dev_priv)\n{\n\tu32 divsel, phaseinc, auxdiv;\n\tu32 iclk_virtual_root_freq = 172800 * 1000;\n\tu32 iclk_pi_range = 64;\n\tu32 desired_divisor;\n\tu32 temp;\n\n\tif ((intel_de_read(dev_priv, PIXCLK_GATE) & PIXCLK_GATE_UNGATE) == 0)\n\t\treturn 0;\n\n\tmutex_lock(&dev_priv->sb_lock);\n\n\ttemp = intel_sbi_read(dev_priv, SBI_SSCCTL6, SBI_ICLK);\n\tif (temp & SBI_SSCCTL_DISABLE) {\n\t\tmutex_unlock(&dev_priv->sb_lock);\n\t\treturn 0;\n\t}\n\n\ttemp = intel_sbi_read(dev_priv, SBI_SSCDIVINTPHASE6, SBI_ICLK);\n\tdivsel = (temp & SBI_SSCDIVINTPHASE_DIVSEL_MASK) >>\n\t\tSBI_SSCDIVINTPHASE_DIVSEL_SHIFT;\n\tphaseinc = (temp & SBI_SSCDIVINTPHASE_INCVAL_MASK) >>\n\t\tSBI_SSCDIVINTPHASE_INCVAL_SHIFT;\n\n\ttemp = intel_sbi_read(dev_priv, SBI_SSCAUXDIV6, SBI_ICLK);\n\tauxdiv = (temp & SBI_SSCAUXDIV_FINALDIV2SEL_MASK) >>\n\t\tSBI_SSCAUXDIV_FINALDIV2SEL_SHIFT;\n\n\tmutex_unlock(&dev_priv->sb_lock);\n\n\tdesired_divisor = (divsel + 2) * iclk_pi_range + phaseinc;\n\n\treturn DIV_ROUND_CLOSEST(iclk_virtual_root_freq,\n\t\t\t\t desired_divisor << auxdiv);\n}\n\nstatic void ilk_pch_transcoder_set_timings(const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t   enum pipe pch_transcoder)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\n\tintel_de_write(dev_priv, PCH_TRANS_HTOTAL(pch_transcoder),\n\t\t       intel_de_read(dev_priv, HTOTAL(cpu_transcoder)));\n\tintel_de_write(dev_priv, PCH_TRANS_HBLANK(pch_transcoder),\n\t\t       intel_de_read(dev_priv, HBLANK(cpu_transcoder)));\n\tintel_de_write(dev_priv, PCH_TRANS_HSYNC(pch_transcoder),\n\t\t       intel_de_read(dev_priv, HSYNC(cpu_transcoder)));\n\n\tintel_de_write(dev_priv, PCH_TRANS_VTOTAL(pch_transcoder),\n\t\t       intel_de_read(dev_priv, VTOTAL(cpu_transcoder)));\n\tintel_de_write(dev_priv, PCH_TRANS_VBLANK(pch_transcoder),\n\t\t       intel_de_read(dev_priv, VBLANK(cpu_transcoder)));\n\tintel_de_write(dev_priv, PCH_TRANS_VSYNC(pch_transcoder),\n\t\t       intel_de_read(dev_priv, VSYNC(cpu_transcoder)));\n\tintel_de_write(dev_priv, PCH_TRANS_VSYNCSHIFT(pch_transcoder),\n\t\t       intel_de_read(dev_priv, VSYNCSHIFT(cpu_transcoder)));\n}\n\nstatic void cpt_set_fdi_bc_bifurcation(struct drm_i915_private *dev_priv, bool enable)\n{\n\tu32 temp;\n\n\ttemp = intel_de_read(dev_priv, SOUTH_CHICKEN1);\n\tif (!!(temp & FDI_BC_BIFURCATION_SELECT) == enable)\n\t\treturn;\n\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_de_read(dev_priv, FDI_RX_CTL(PIPE_B)) &\n\t\t    FDI_RX_ENABLE);\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_de_read(dev_priv, FDI_RX_CTL(PIPE_C)) &\n\t\t    FDI_RX_ENABLE);\n\n\ttemp &= ~FDI_BC_BIFURCATION_SELECT;\n\tif (enable)\n\t\ttemp |= FDI_BC_BIFURCATION_SELECT;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"%sabling fdi C rx\\n\",\n\t\t    enable ? \"en\" : \"dis\");\n\tintel_de_write(dev_priv, SOUTH_CHICKEN1, temp);\n\tintel_de_posting_read(dev_priv, SOUTH_CHICKEN1);\n}\n\nstatic void ivb_update_fdi_bc_bifurcation(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tswitch (crtc->pipe) {\n\tcase PIPE_A:\n\t\tbreak;\n\tcase PIPE_B:\n\t\tif (crtc_state->fdi_lanes > 2)\n\t\t\tcpt_set_fdi_bc_bifurcation(dev_priv, false);\n\t\telse\n\t\t\tcpt_set_fdi_bc_bifurcation(dev_priv, true);\n\n\t\tbreak;\n\tcase PIPE_C:\n\t\tcpt_set_fdi_bc_bifurcation(dev_priv, true);\n\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n/*\n * Finds the encoder associated with the given CRTC. This can only be\n * used when we know that the CRTC isn't feeding multiple encoders!\n */\nstatic struct intel_encoder *\nintel_get_crtc_new_encoder(const struct intel_atomic_state *state,\n\t\t\t   const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tconst struct drm_connector_state *connector_state;\n\tconst struct drm_connector *connector;\n\tstruct intel_encoder *encoder = NULL;\n\tint num_encoders = 0;\n\tint i;\n\n\tfor_each_new_connector_in_state(&state->base, connector, connector_state, i) {\n\t\tif (connector_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tencoder = to_intel_encoder(connector_state->best_encoder);\n\t\tnum_encoders++;\n\t}\n\n\tdrm_WARN(encoder->base.dev, num_encoders != 1,\n\t\t \"%d encoders for pipe %c\\n\",\n\t\t num_encoders, pipe_name(crtc->pipe));\n\n\treturn encoder;\n}\n\n/*\n * Enable PCH resources required for PCH ports:\n *   - PCH PLLs\n *   - FDI training & RX/TX\n *   - update transcoder timings\n *   - DP transcoding bits\n *   - transcoder\n */\nstatic void ilk_pch_enable(const struct intel_atomic_state *state,\n\t\t\t   const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum pipe pipe = crtc->pipe;\n\tu32 temp;\n\n\tassert_pch_transcoder_disabled(dev_priv, pipe);\n\n\tif (IS_IVYBRIDGE(dev_priv))\n\t\tivb_update_fdi_bc_bifurcation(crtc_state);\n\n\t/* Write the TU size bits before fdi link training, so that error\n\t * detection works. */\n\tintel_de_write(dev_priv, FDI_RX_TUSIZE1(pipe),\n\t\t       intel_de_read(dev_priv, PIPE_DATA_M1(pipe)) & TU_SIZE_MASK);\n\n\t/* For PCH output, training FDI link */\n\tdev_priv->display.fdi_link_train(crtc, crtc_state);\n\n\t/* We need to program the right clock selection before writing the pixel\n\t * mutliplier into the DPLL. */\n\tif (HAS_PCH_CPT(dev_priv)) {\n\t\tu32 sel;\n\n\t\ttemp = intel_de_read(dev_priv, PCH_DPLL_SEL);\n\t\ttemp |= TRANS_DPLL_ENABLE(pipe);\n\t\tsel = TRANS_DPLLB_SEL(pipe);\n\t\tif (crtc_state->shared_dpll ==\n\t\t    intel_get_shared_dpll_by_id(dev_priv, DPLL_ID_PCH_PLL_B))\n\t\t\ttemp |= sel;\n\t\telse\n\t\t\ttemp &= ~sel;\n\t\tintel_de_write(dev_priv, PCH_DPLL_SEL, temp);\n\t}\n\n\t/* XXX: pch pll's can be enabled any time before we enable the PCH\n\t * transcoder, and we actually should do this to not upset any PCH\n\t * transcoder that already use the clock when we share it.\n\t *\n\t * Note that enable_shared_dpll tries to do the right thing, but\n\t * get_shared_dpll unconditionally resets the pll - we need that to have\n\t * the right LVDS enable sequence. */\n\tintel_enable_shared_dpll(crtc_state);\n\n\t/* set transcoder timing, panel must allow it */\n\tassert_panel_unlocked(dev_priv, pipe);\n\tilk_pch_transcoder_set_timings(crtc_state, pipe);\n\n\tintel_fdi_normal_train(crtc);\n\n\t/* For PCH DP, enable TRANS_DP_CTL */\n\tif (HAS_PCH_CPT(dev_priv) &&\n\t    intel_crtc_has_dp_encoder(crtc_state)) {\n\t\tconst struct drm_display_mode *adjusted_mode =\n\t\t\t&crtc_state->hw.adjusted_mode;\n\t\tu32 bpc = (intel_de_read(dev_priv, PIPECONF(pipe)) & PIPECONF_BPC_MASK) >> 5;\n\t\ti915_reg_t reg = TRANS_DP_CTL(pipe);\n\t\tenum port port;\n\n\t\ttemp = intel_de_read(dev_priv, reg);\n\t\ttemp &= ~(TRANS_DP_PORT_SEL_MASK |\n\t\t\t  TRANS_DP_SYNC_MASK |\n\t\t\t  TRANS_DP_BPC_MASK);\n\t\ttemp |= TRANS_DP_OUTPUT_ENABLE;\n\t\ttemp |= bpc << 9; /* same format but at 11:9 */\n\n\t\tif (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\t\ttemp |= TRANS_DP_HSYNC_ACTIVE_HIGH;\n\t\tif (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\t\ttemp |= TRANS_DP_VSYNC_ACTIVE_HIGH;\n\n\t\tport = intel_get_crtc_new_encoder(state, crtc_state)->port;\n\t\tdrm_WARN_ON(dev, port < PORT_B || port > PORT_D);\n\t\ttemp |= TRANS_DP_PORT_SEL(port);\n\n\t\tintel_de_write(dev_priv, reg, temp);\n\t}\n\n\tilk_enable_pch_transcoder(crtc_state);\n}\n\nvoid lpt_pch_enable(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\n\tassert_pch_transcoder_disabled(dev_priv, PIPE_A);\n\n\tlpt_program_iclkip(crtc_state);\n\n\t/* Set transcoder timing. */\n\tilk_pch_transcoder_set_timings(crtc_state, PIPE_A);\n\n\tlpt_enable_pch_transcoder(dev_priv, cpu_transcoder);\n}\n\nstatic void cpt_verify_modeset(struct drm_i915_private *dev_priv,\n\t\t\t       enum pipe pipe)\n{\n\ti915_reg_t dslreg = PIPEDSL(pipe);\n\tu32 temp;\n\n\ttemp = intel_de_read(dev_priv, dslreg);\n\tudelay(500);\n\tif (wait_for(intel_de_read(dev_priv, dslreg) != temp, 5)) {\n\t\tif (wait_for(intel_de_read(dev_priv, dslreg) != temp, 5))\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"mode set failed: pipe %c stuck\\n\",\n\t\t\t\tpipe_name(pipe));\n\t}\n}\n\n/*\n * The hardware phase 0.0 refers to the center of the pixel.\n * We want to start from the top/left edge which is phase\n * -0.5. That matches how the hardware calculates the scaling\n * factors (from top-left of the first pixel to bottom-right\n * of the last pixel, as opposed to the pixel centers).\n *\n * For 4:2:0 subsampled chroma planes we obviously have to\n * adjust that so that the chroma sample position lands in\n * the right spot.\n *\n * Note that for packed YCbCr 4:2:2 formats there is no way to\n * control chroma siting. The hardware simply replicates the\n * chroma samples for both of the luma samples, and thus we don't\n * actually get the expected MPEG2 chroma siting convention :(\n * The same behaviour is observed on pre-SKL platforms as well.\n *\n * Theory behind the formula (note that we ignore sub-pixel\n * source coordinates):\n * s = source sample position\n * d = destination sample position\n *\n * Downscaling 4:1:\n * -0.5\n * | 0.0\n * | |     1.5 (initial phase)\n * | |     |\n * v v     v\n * | s | s | s | s |\n * |       d       |\n *\n * Upscaling 1:4:\n * -0.5\n * | -0.375 (initial phase)\n * | |     0.0\n * | |     |\n * v v     v\n * |       s       |\n * | d | d | d | d |\n */\nu16 skl_scaler_calc_phase(int sub, int scale, bool chroma_cosited)\n{\n\tint phase = -0x8000;\n\tu16 trip = 0;\n\n\tif (chroma_cosited)\n\t\tphase += (sub - 1) * 0x8000 / sub;\n\n\tphase += scale / (2 * sub);\n\n\t/*\n\t * Hardware initial phase limited to [-0.5:1.5].\n\t * Since the max hardware scale factor is 3.0, we\n\t * should never actually excdeed 1.0 here.\n\t */\n\tWARN_ON(phase < -0x8000 || phase > 0x18000);\n\n\tif (phase < 0)\n\t\tphase = 0x10000 + phase;\n\telse\n\t\ttrip = PS_PHASE_TRIP;\n\n\treturn ((phase >> 2) & PS_PHASE_MASK) | trip;\n}\n\n#define SKL_MIN_SRC_W 8\n#define SKL_MAX_SRC_W 4096\n#define SKL_MIN_SRC_H 8\n#define SKL_MAX_SRC_H 4096\n#define SKL_MIN_DST_W 8\n#define SKL_MAX_DST_W 4096\n#define SKL_MIN_DST_H 8\n#define SKL_MAX_DST_H 4096\n#define ICL_MAX_SRC_W 5120\n#define ICL_MAX_SRC_H 4096\n#define ICL_MAX_DST_W 5120\n#define ICL_MAX_DST_H 4096\n#define SKL_MIN_YUV_420_SRC_W 16\n#define SKL_MIN_YUV_420_SRC_H 16\n\nstatic int\nskl_update_scaler(struct intel_crtc_state *crtc_state, bool force_detach,\n\t\t  unsigned int scaler_user, int *scaler_id,\n\t\t  int src_w, int src_h, int dst_w, int dst_h,\n\t\t  const struct drm_format_info *format,\n\t\t  u64 modifier, bool need_scaler)\n{\n\tstruct intel_crtc_scaler_state *scaler_state =\n\t\t&crtc_state->scaler_state;\n\tstruct intel_crtc *intel_crtc =\n\t\tto_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(intel_crtc->base.dev);\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\n\t/*\n\t * Src coordinates are already rotated by 270 degrees for\n\t * the 90/270 degree plane rotation cases (to match the\n\t * GTT mapping), hence no need to account for rotation here.\n\t */\n\tif (src_w != dst_w || src_h != dst_h)\n\t\tneed_scaler = true;\n\n\t/*\n\t * Scaling/fitting not supported in IF-ID mode in GEN9+\n\t * TODO: Interlace fetch mode doesn't support YUV420 planar formats.\n\t * Once NV12 is enabled, handle it here while allocating scaler\n\t * for NV12.\n\t */\n\tif (INTEL_GEN(dev_priv) >= 9 && crtc_state->hw.enable &&\n\t    need_scaler && adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Pipe/Plane scaling not supported with IF-ID mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * if plane is being disabled or scaler is no more required or force detach\n\t *  - free scaler binded to this plane/crtc\n\t *  - in order to do this, update crtc->scaler_usage\n\t *\n\t * Here scaler state in crtc_state is set free so that\n\t * scaler can be assigned to other user. Actual register\n\t * update to free the scaler is done in plane/panel-fit programming.\n\t * For this purpose crtc/plane_state->scaler_id isn't reset here.\n\t */\n\tif (force_detach || !need_scaler) {\n\t\tif (*scaler_id >= 0) {\n\t\t\tscaler_state->scaler_users &= ~(1 << scaler_user);\n\t\t\tscaler_state->scalers[*scaler_id].in_use = 0;\n\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"scaler_user index %u.%u: \"\n\t\t\t\t    \"Staged freeing scaler id %d scaler_users = 0x%x\\n\",\n\t\t\t\t    intel_crtc->pipe, scaler_user, *scaler_id,\n\t\t\t\t    scaler_state->scaler_users);\n\t\t\t*scaler_id = -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (format && intel_format_info_is_yuv_semiplanar(format, modifier) &&\n\t    (src_h < SKL_MIN_YUV_420_SRC_H || src_w < SKL_MIN_YUV_420_SRC_W)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Planar YUV: src dimensions not met\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* range checks */\n\tif (src_w < SKL_MIN_SRC_W || src_h < SKL_MIN_SRC_H ||\n\t    dst_w < SKL_MIN_DST_W || dst_h < SKL_MIN_DST_H ||\n\t    (INTEL_GEN(dev_priv) >= 11 &&\n\t     (src_w > ICL_MAX_SRC_W || src_h > ICL_MAX_SRC_H ||\n\t      dst_w > ICL_MAX_DST_W || dst_h > ICL_MAX_DST_H)) ||\n\t    (INTEL_GEN(dev_priv) < 11 &&\n\t     (src_w > SKL_MAX_SRC_W || src_h > SKL_MAX_SRC_H ||\n\t      dst_w > SKL_MAX_DST_W || dst_h > SKL_MAX_DST_H)))\t{\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"scaler_user index %u.%u: src %ux%u dst %ux%u \"\n\t\t\t    \"size is out of scaler range\\n\",\n\t\t\t    intel_crtc->pipe, scaler_user, src_w, src_h,\n\t\t\t    dst_w, dst_h);\n\t\treturn -EINVAL;\n\t}\n\n\t/* mark this plane as a scaler user in crtc_state */\n\tscaler_state->scaler_users |= (1 << scaler_user);\n\tdrm_dbg_kms(&dev_priv->drm, \"scaler_user index %u.%u: \"\n\t\t    \"staged scaling request for %ux%u->%ux%u scaler_users = 0x%x\\n\",\n\t\t    intel_crtc->pipe, scaler_user, src_w, src_h, dst_w, dst_h,\n\t\t    scaler_state->scaler_users);\n\n\treturn 0;\n}\n\nstatic int skl_update_scaler_crtc(struct intel_crtc_state *crtc_state)\n{\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\tint width, height;\n\n\tif (crtc_state->pch_pfit.enabled) {\n\t\twidth = drm_rect_width(&crtc_state->pch_pfit.dst);\n\t\theight = drm_rect_height(&crtc_state->pch_pfit.dst);\n\t} else {\n\t\twidth = adjusted_mode->crtc_hdisplay;\n\t\theight = adjusted_mode->crtc_vdisplay;\n\t}\n\n\treturn skl_update_scaler(crtc_state, !crtc_state->hw.active,\n\t\t\t\t SKL_CRTC_INDEX,\n\t\t\t\t &crtc_state->scaler_state.scaler_id,\n\t\t\t\t crtc_state->pipe_src_w, crtc_state->pipe_src_h,\n\t\t\t\t width, height, NULL, 0,\n\t\t\t\t crtc_state->pch_pfit.enabled);\n}\n\n/**\n * skl_update_scaler_plane - Stages update to scaler state for a given plane.\n * @crtc_state: crtc's scaler state\n * @plane_state: atomic plane state to update\n *\n * Return\n *     0 - scaler_usage updated successfully\n *    error - requested scaling cannot be supported or other error condition\n */\nstatic int skl_update_scaler_plane(struct intel_crtc_state *crtc_state,\n\t\t\t\t   struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *intel_plane =\n\t\tto_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(intel_plane->base.dev);\n\tstruct drm_framebuffer *fb = plane_state->hw.fb;\n\tint ret;\n\tbool force_detach = !fb || !plane_state->uapi.visible;\n\tbool need_scaler = false;\n\n\t/* Pre-gen11 and SDR planes always need a scaler for planar formats. */\n\tif (!icl_is_hdr_plane(dev_priv, intel_plane->id) &&\n\t    fb && intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier))\n\t\tneed_scaler = true;\n\n\tret = skl_update_scaler(crtc_state, force_detach,\n\t\t\t\tdrm_plane_index(&intel_plane->base),\n\t\t\t\t&plane_state->scaler_id,\n\t\t\t\tdrm_rect_width(&plane_state->uapi.src) >> 16,\n\t\t\t\tdrm_rect_height(&plane_state->uapi.src) >> 16,\n\t\t\t\tdrm_rect_width(&plane_state->uapi.dst),\n\t\t\t\tdrm_rect_height(&plane_state->uapi.dst),\n\t\t\t\tfb ? fb->format : NULL,\n\t\t\t\tfb ? fb->modifier : 0,\n\t\t\t\tneed_scaler);\n\n\tif (ret || plane_state->scaler_id < 0)\n\t\treturn ret;\n\n\t/* check colorkey */\n\tif (plane_state->ckey.flags) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[PLANE:%d:%s] scaling with color key not allowed\",\n\t\t\t    intel_plane->base.base.id,\n\t\t\t    intel_plane->base.name);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check src format */\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_XRGB2101010:\n\tcase DRM_FORMAT_XBGR2101010:\n\tcase DRM_FORMAT_ARGB2101010:\n\tcase DRM_FORMAT_ABGR2101010:\n\tcase DRM_FORMAT_YUYV:\n\tcase DRM_FORMAT_YVYU:\n\tcase DRM_FORMAT_UYVY:\n\tcase DRM_FORMAT_VYUY:\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_XYUV8888:\n\tcase DRM_FORMAT_P010:\n\tcase DRM_FORMAT_P012:\n\tcase DRM_FORMAT_P016:\n\tcase DRM_FORMAT_Y210:\n\tcase DRM_FORMAT_Y212:\n\tcase DRM_FORMAT_Y216:\n\tcase DRM_FORMAT_XVYU2101010:\n\tcase DRM_FORMAT_XVYU12_16161616:\n\tcase DRM_FORMAT_XVYU16161616:\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR16161616F:\n\tcase DRM_FORMAT_ABGR16161616F:\n\tcase DRM_FORMAT_XRGB16161616F:\n\tcase DRM_FORMAT_ARGB16161616F:\n\t\tif (INTEL_GEN(dev_priv) >= 11)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[PLANE:%d:%s] FB:%d unsupported scaling format 0x%x\\n\",\n\t\t\t    intel_plane->base.base.id, intel_plane->base.name,\n\t\t\t    fb->base.id, fb->format->format);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid skl_scaler_disable(const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tint i;\n\n\tfor (i = 0; i < crtc->num_scalers; i++)\n\t\tskl_detach_scaler(crtc, i);\n}\n\nstatic void skl_pfit_enable(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct intel_crtc_scaler_state *scaler_state =\n\t\t&crtc_state->scaler_state;\n\tstruct drm_rect src = {\n\t\t.x2 = crtc_state->pipe_src_w << 16,\n\t\t.y2 = crtc_state->pipe_src_h << 16,\n\t};\n\tconst struct drm_rect *dst = &crtc_state->pch_pfit.dst;\n\tu16 uv_rgb_hphase, uv_rgb_vphase;\n\tenum pipe pipe = crtc->pipe;\n\tint width = drm_rect_width(dst);\n\tint height = drm_rect_height(dst);\n\tint x = dst->x1;\n\tint y = dst->y1;\n\tint hscale, vscale;\n\tunsigned long irqflags;\n\tint id;\n\n\tif (!crtc_state->pch_pfit.enabled)\n\t\treturn;\n\n\tif (drm_WARN_ON(&dev_priv->drm,\n\t\t\tcrtc_state->scaler_state.scaler_id < 0))\n\t\treturn;\n\n\thscale = drm_rect_calc_hscale(&src, dst, 0, INT_MAX);\n\tvscale = drm_rect_calc_vscale(&src, dst, 0, INT_MAX);\n\n\tuv_rgb_hphase = skl_scaler_calc_phase(1, hscale, false);\n\tuv_rgb_vphase = skl_scaler_calc_phase(1, vscale, false);\n\n\tid = scaler_state->scaler_id;\n\n\tspin_lock_irqsave(&dev_priv->uncore.lock, irqflags);\n\n\tintel_de_write_fw(dev_priv, SKL_PS_CTRL(pipe, id), PS_SCALER_EN |\n\t\t\t  PS_FILTER_MEDIUM | scaler_state->scalers[id].mode);\n\tintel_de_write_fw(dev_priv, SKL_PS_VPHASE(pipe, id),\n\t\t\t  PS_Y_PHASE(0) | PS_UV_RGB_PHASE(uv_rgb_vphase));\n\tintel_de_write_fw(dev_priv, SKL_PS_HPHASE(pipe, id),\n\t\t\t  PS_Y_PHASE(0) | PS_UV_RGB_PHASE(uv_rgb_hphase));\n\tintel_de_write_fw(dev_priv, SKL_PS_WIN_POS(pipe, id),\n\t\t\t  x << 16 | y);\n\tintel_de_write_fw(dev_priv, SKL_PS_WIN_SZ(pipe, id),\n\t\t\t  width << 16 | height);\n\n\tspin_unlock_irqrestore(&dev_priv->uncore.lock, irqflags);\n}\n\nstatic void ilk_pfit_enable(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct drm_rect *dst = &crtc_state->pch_pfit.dst;\n\tenum pipe pipe = crtc->pipe;\n\tint width = drm_rect_width(dst);\n\tint height = drm_rect_height(dst);\n\tint x = dst->x1;\n\tint y = dst->y1;\n\n\tif (!crtc_state->pch_pfit.enabled)\n\t\treturn;\n\n\t/* Force use of hard-coded filter coefficients\n\t * as some pre-programmed values are broken,\n\t * e.g. x201.\n\t */\n\tif (IS_IVYBRIDGE(dev_priv) || IS_HASWELL(dev_priv))\n\t\tintel_de_write(dev_priv, PF_CTL(pipe), PF_ENABLE |\n\t\t\t       PF_FILTER_MED_3x3 | PF_PIPE_SEL_IVB(pipe));\n\telse\n\t\tintel_de_write(dev_priv, PF_CTL(pipe), PF_ENABLE |\n\t\t\t       PF_FILTER_MED_3x3);\n\tintel_de_write(dev_priv, PF_WIN_POS(pipe), x << 16 | y);\n\tintel_de_write(dev_priv, PF_WIN_SZ(pipe), width << 16 | height);\n}\n\nvoid hsw_enable_ips(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\n\tif (!crtc_state->ips_enabled)\n\t\treturn;\n\n\t/*\n\t * We can only enable IPS after we enable a plane and wait for a vblank\n\t * This function is called from post_plane_update, which is run after\n\t * a vblank wait.\n\t */\n\tdrm_WARN_ON(dev, !(crtc_state->active_planes & ~BIT(PLANE_CURSOR)));\n\n\tif (IS_BROADWELL(dev_priv)) {\n\t\tdrm_WARN_ON(dev, sandybridge_pcode_write(dev_priv, DISPLAY_IPS_CONTROL,\n\t\t\t\t\t\t\t IPS_ENABLE | IPS_PCODE_CONTROL));\n\t\t/* Quoting Art Runyan: \"its not safe to expect any particular\n\t\t * value in IPS_CTL bit 31 after enabling IPS through the\n\t\t * mailbox.\" Moreover, the mailbox may return a bogus state,\n\t\t * so we need to just enable it and continue on.\n\t\t */\n\t} else {\n\t\tintel_de_write(dev_priv, IPS_CTL, IPS_ENABLE);\n\t\t/* The bit only becomes 1 in the next vblank, so this wait here\n\t\t * is essentially intel_wait_for_vblank. If we don't have this\n\t\t * and don't wait for vblanks until the end of crtc_enable, then\n\t\t * the HW state readout code will complain that the expected\n\t\t * IPS_CTL value is not the one we read. */\n\t\tif (intel_de_wait_for_set(dev_priv, IPS_CTL, IPS_ENABLE, 50))\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Timed out waiting for IPS enable\\n\");\n\t}\n}\n\nvoid hsw_disable_ips(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\n\tif (!crtc_state->ips_enabled)\n\t\treturn;\n\n\tif (IS_BROADWELL(dev_priv)) {\n\t\tdrm_WARN_ON(dev,\n\t\t\t    sandybridge_pcode_write(dev_priv, DISPLAY_IPS_CONTROL, 0));\n\t\t/*\n\t\t * Wait for PCODE to finish disabling IPS. The BSpec specified\n\t\t * 42ms timeout value leads to occasional timeouts so use 100ms\n\t\t * instead.\n\t\t */\n\t\tif (intel_de_wait_for_clear(dev_priv, IPS_CTL, IPS_ENABLE, 100))\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Timed out waiting for IPS disable\\n\");\n\t} else {\n\t\tintel_de_write(dev_priv, IPS_CTL, 0);\n\t\tintel_de_posting_read(dev_priv, IPS_CTL);\n\t}\n\n\t/* We need to wait for a vblank before we can disable the plane. */\n\tintel_wait_for_vblank(dev_priv, crtc->pipe);\n}\n\nstatic void intel_crtc_dpms_overlay_disable(struct intel_crtc *intel_crtc)\n{\n\tif (intel_crtc->overlay)\n\t\t(void) intel_overlay_switch_off(intel_crtc->overlay);\n\n\t/* Let userspace switch the overlay on again. In most cases userspace\n\t * has to recompute where to put it anyway.\n\t */\n}\n\nstatic bool hsw_pre_update_disable_ips(const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t       const struct intel_crtc_state *new_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(new_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tif (!old_crtc_state->ips_enabled)\n\t\treturn false;\n\n\tif (needs_modeset(new_crtc_state))\n\t\treturn true;\n\n\t/*\n\t * Workaround : Do not read or write the pipe palette/gamma data while\n\t * GAMMA_MODE is configured for split gamma and IPS_CTL has IPS enabled.\n\t *\n\t * Disable IPS before we program the LUT.\n\t */\n\tif (IS_HASWELL(dev_priv) &&\n\t    (new_crtc_state->uapi.color_mgmt_changed ||\n\t     new_crtc_state->update_pipe) &&\n\t    new_crtc_state->gamma_mode == GAMMA_MODE_MODE_SPLIT)\n\t\treturn true;\n\n\treturn !new_crtc_state->ips_enabled;\n}\n\nstatic bool hsw_post_update_enable_ips(const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t       const struct intel_crtc_state *new_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(new_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tif (!new_crtc_state->ips_enabled)\n\t\treturn false;\n\n\tif (needs_modeset(new_crtc_state))\n\t\treturn true;\n\n\t/*\n\t * Workaround : Do not read or write the pipe palette/gamma data while\n\t * GAMMA_MODE is configured for split gamma and IPS_CTL has IPS enabled.\n\t *\n\t * Re-enable IPS after the LUT has been programmed.\n\t */\n\tif (IS_HASWELL(dev_priv) &&\n\t    (new_crtc_state->uapi.color_mgmt_changed ||\n\t     new_crtc_state->update_pipe) &&\n\t    new_crtc_state->gamma_mode == GAMMA_MODE_MODE_SPLIT)\n\t\treturn true;\n\n\t/*\n\t * We can't read out IPS on broadwell, assume the worst and\n\t * forcibly enable IPS on the first fastset.\n\t */\n\tif (new_crtc_state->update_pipe && old_crtc_state->inherited)\n\t\treturn true;\n\n\treturn !old_crtc_state->ips_enabled;\n}\n\nstatic bool needs_nv12_wa(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\n\tif (!crtc_state->nv12_planes)\n\t\treturn false;\n\n\t/* WA Display #0827: Gen9:all */\n\tif (IS_GEN(dev_priv, 9) && !IS_GEMINILAKE(dev_priv))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool needs_scalerclk_wa(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\n\t/* Wa_2006604312:icl,ehl */\n\tif (crtc_state->scaler_state.scaler_users > 0 && IS_GEN(dev_priv, 11))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool planes_enabling(const struct intel_crtc_state *old_crtc_state,\n\t\t\t    const struct intel_crtc_state *new_crtc_state)\n{\n\treturn (!old_crtc_state->active_planes || needs_modeset(new_crtc_state)) &&\n\t\tnew_crtc_state->active_planes;\n}\n\nstatic bool planes_disabling(const struct intel_crtc_state *old_crtc_state,\n\t\t\t     const struct intel_crtc_state *new_crtc_state)\n{\n\treturn old_crtc_state->active_planes &&\n\t\t(!new_crtc_state->active_planes || needs_modeset(new_crtc_state));\n}\n\nstatic void intel_post_plane_update(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tenum pipe pipe = crtc->pipe;\n\n\tintel_frontbuffer_flip(dev_priv, new_crtc_state->fb_bits);\n\n\tif (new_crtc_state->update_wm_post && new_crtc_state->hw.active)\n\t\tintel_update_watermarks(crtc);\n\n\tif (hsw_post_update_enable_ips(old_crtc_state, new_crtc_state))\n\t\thsw_enable_ips(new_crtc_state);\n\n\tintel_fbc_post_update(state, crtc);\n\n\tif (needs_nv12_wa(old_crtc_state) &&\n\t    !needs_nv12_wa(new_crtc_state))\n\t\tskl_wa_827(dev_priv, pipe, false);\n\n\tif (needs_scalerclk_wa(old_crtc_state) &&\n\t    !needs_scalerclk_wa(new_crtc_state))\n\t\ticl_wa_scalerclkgating(dev_priv, pipe, false);\n}\n\nstatic void intel_pre_plane_update(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tenum pipe pipe = crtc->pipe;\n\n\tif (hsw_pre_update_disable_ips(old_crtc_state, new_crtc_state))\n\t\thsw_disable_ips(old_crtc_state);\n\n\tif (intel_fbc_pre_update(state, crtc))\n\t\tintel_wait_for_vblank(dev_priv, pipe);\n\n\t/* Display WA 827 */\n\tif (!needs_nv12_wa(old_crtc_state) &&\n\t    needs_nv12_wa(new_crtc_state))\n\t\tskl_wa_827(dev_priv, pipe, true);\n\n\t/* Wa_2006604312:icl,ehl */\n\tif (!needs_scalerclk_wa(old_crtc_state) &&\n\t    needs_scalerclk_wa(new_crtc_state))\n\t\ticl_wa_scalerclkgating(dev_priv, pipe, true);\n\n\t/*\n\t * Vblank time updates from the shadow to live plane control register\n\t * are blocked if the memory self-refresh mode is active at that\n\t * moment. So to make sure the plane gets truly disabled, disable\n\t * first the self-refresh mode. The self-refresh enable bit in turn\n\t * will be checked/applied by the HW only at the next frame start\n\t * event which is after the vblank start event, so we need to have a\n\t * wait-for-vblank between disabling the plane and the pipe.\n\t */\n\tif (HAS_GMCH(dev_priv) && old_crtc_state->hw.active &&\n\t    new_crtc_state->disable_cxsr && intel_set_memory_cxsr(dev_priv, false))\n\t\tintel_wait_for_vblank(dev_priv, pipe);\n\n\t/*\n\t * IVB workaround: must disable low power watermarks for at least\n\t * one frame before enabling scaling.  LP watermarks can be re-enabled\n\t * when scaling is disabled.\n\t *\n\t * WaCxSRDisabledForSpriteScaling:ivb\n\t */\n\tif (old_crtc_state->hw.active &&\n\t    new_crtc_state->disable_lp_wm && ilk_disable_lp_wm(dev_priv))\n\t\tintel_wait_for_vblank(dev_priv, pipe);\n\n\t/*\n\t * If we're doing a modeset we don't need to do any\n\t * pre-vblank watermark programming here.\n\t */\n\tif (!needs_modeset(new_crtc_state)) {\n\t\t/*\n\t\t * For platforms that support atomic watermarks, program the\n\t\t * 'intermediate' watermarks immediately.  On pre-gen9 platforms, these\n\t\t * will be the intermediate values that are safe for both pre- and\n\t\t * post- vblank; when vblank happens, the 'active' values will be set\n\t\t * to the final 'target' values and we'll do this again to get the\n\t\t * optimal watermarks.  For gen9+ platforms, the values we program here\n\t\t * will be the final target values which will get automatically latched\n\t\t * at vblank time; no further programming will be necessary.\n\t\t *\n\t\t * If a platform hasn't been transitioned to atomic watermarks yet,\n\t\t * we'll continue to update watermarks the old way, if flags tell\n\t\t * us to.\n\t\t */\n\t\tif (dev_priv->display.initial_watermarks)\n\t\t\tdev_priv->display.initial_watermarks(state, crtc);\n\t\telse if (new_crtc_state->update_wm_pre)\n\t\t\tintel_update_watermarks(crtc);\n\t}\n\n\t/*\n\t * Gen2 reports pipe underruns whenever all planes are disabled.\n\t * So disable underrun reporting before all the planes get disabled.\n\t *\n\t * We do this after .initial_watermarks() so that we have a\n\t * chance of catching underruns with the intermediate watermarks\n\t * vs. the old plane configuration.\n\t */\n\tif (IS_GEN(dev_priv, 2) && planes_disabling(old_crtc_state, new_crtc_state))\n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, false);\n}\n\nstatic void intel_crtc_disable_planes(struct intel_atomic_state *state,\n\t\t\t\t      struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tunsigned int update_mask = new_crtc_state->update_planes;\n\tconst struct intel_plane_state *old_plane_state;\n\tstruct intel_plane *plane;\n\tunsigned fb_bits = 0;\n\tint i;\n\n\tintel_crtc_dpms_overlay_disable(crtc);\n\n\tfor_each_old_intel_plane_in_state(state, plane, old_plane_state, i) {\n\t\tif (crtc->pipe != plane->pipe ||\n\t\t    !(update_mask & BIT(plane->id)))\n\t\t\tcontinue;\n\n\t\tintel_disable_plane(plane, new_crtc_state);\n\n\t\tif (old_plane_state->uapi.visible)\n\t\t\tfb_bits |= plane->frontbuffer_bit;\n\t}\n\n\tintel_frontbuffer_flip(dev_priv, fb_bits);\n}\n\n/*\n * intel_connector_primary_encoder - get the primary encoder for a connector\n * @connector: connector for which to return the encoder\n *\n * Returns the primary encoder for a connector. There is a 1:1 mapping from\n * all connectors to their encoder, except for DP-MST connectors which have\n * both a virtual and a primary encoder. These DP-MST primary encoders can be\n * pointed to by as many DP-MST connectors as there are pipes.\n */\nstatic struct intel_encoder *\nintel_connector_primary_encoder(struct intel_connector *connector)\n{\n\tstruct intel_encoder *encoder;\n\n\tif (connector->mst_port)\n\t\treturn &dp_to_dig_port(connector->mst_port)->base;\n\n\tencoder = intel_attached_encoder(connector);\n\tdrm_WARN_ON(connector->base.dev, !encoder);\n\n\treturn encoder;\n}\n\nstatic void intel_encoders_update_prepare(struct intel_atomic_state *state)\n{\n\tstruct drm_connector_state *new_conn_state;\n\tstruct drm_connector *connector;\n\tint i;\n\n\tfor_each_new_connector_in_state(&state->base, connector, new_conn_state,\n\t\t\t\t\ti) {\n\t\tstruct intel_connector *intel_connector;\n\t\tstruct intel_encoder *encoder;\n\t\tstruct intel_crtc *crtc;\n\n\t\tif (!intel_connector_needs_modeset(state, connector))\n\t\t\tcontinue;\n\n\t\tintel_connector = to_intel_connector(connector);\n\t\tencoder = intel_connector_primary_encoder(intel_connector);\n\t\tif (!encoder->update_prepare)\n\t\t\tcontinue;\n\n\t\tcrtc = new_conn_state->crtc ?\n\t\t\tto_intel_crtc(new_conn_state->crtc) : NULL;\n\t\tencoder->update_prepare(state, encoder, crtc);\n\t}\n}\n\nstatic void intel_encoders_update_complete(struct intel_atomic_state *state)\n{\n\tstruct drm_connector_state *new_conn_state;\n\tstruct drm_connector *connector;\n\tint i;\n\n\tfor_each_new_connector_in_state(&state->base, connector, new_conn_state,\n\t\t\t\t\ti) {\n\t\tstruct intel_connector *intel_connector;\n\t\tstruct intel_encoder *encoder;\n\t\tstruct intel_crtc *crtc;\n\n\t\tif (!intel_connector_needs_modeset(state, connector))\n\t\t\tcontinue;\n\n\t\tintel_connector = to_intel_connector(connector);\n\t\tencoder = intel_connector_primary_encoder(intel_connector);\n\t\tif (!encoder->update_complete)\n\t\t\tcontinue;\n\n\t\tcrtc = new_conn_state->crtc ?\n\t\t\tto_intel_crtc(new_conn_state->crtc) : NULL;\n\t\tencoder->update_complete(state, encoder, crtc);\n\t}\n}\n\nstatic void intel_encoders_pre_pll_enable(struct intel_atomic_state *state,\n\t\t\t\t\t  struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct drm_connector_state *conn_state;\n\tstruct drm_connector *conn;\n\tint i;\n\n\tfor_each_new_connector_in_state(&state->base, conn, conn_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(conn_state->best_encoder);\n\n\t\tif (conn_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tif (encoder->pre_pll_enable)\n\t\t\tencoder->pre_pll_enable(state, encoder,\n\t\t\t\t\t\tcrtc_state, conn_state);\n\t}\n}\n\nstatic void intel_encoders_pre_enable(struct intel_atomic_state *state,\n\t\t\t\t      struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct drm_connector_state *conn_state;\n\tstruct drm_connector *conn;\n\tint i;\n\n\tfor_each_new_connector_in_state(&state->base, conn, conn_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(conn_state->best_encoder);\n\n\t\tif (conn_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tif (encoder->pre_enable)\n\t\t\tencoder->pre_enable(state, encoder,\n\t\t\t\t\t    crtc_state, conn_state);\n\t}\n}\n\nstatic void intel_encoders_enable(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct drm_connector_state *conn_state;\n\tstruct drm_connector *conn;\n\tint i;\n\n\tfor_each_new_connector_in_state(&state->base, conn, conn_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(conn_state->best_encoder);\n\n\t\tif (conn_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tif (encoder->enable)\n\t\t\tencoder->enable(state, encoder,\n\t\t\t\t\tcrtc_state, conn_state);\n\t\tintel_opregion_notify_encoder(encoder, true);\n\t}\n}\n\nstatic void intel_encoders_disable(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tconst struct drm_connector_state *old_conn_state;\n\tstruct drm_connector *conn;\n\tint i;\n\n\tfor_each_old_connector_in_state(&state->base, conn, old_conn_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(old_conn_state->best_encoder);\n\n\t\tif (old_conn_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tintel_opregion_notify_encoder(encoder, false);\n\t\tif (encoder->disable)\n\t\t\tencoder->disable(state, encoder,\n\t\t\t\t\t old_crtc_state, old_conn_state);\n\t}\n}\n\nstatic void intel_encoders_post_disable(struct intel_atomic_state *state,\n\t\t\t\t\tstruct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tconst struct drm_connector_state *old_conn_state;\n\tstruct drm_connector *conn;\n\tint i;\n\n\tfor_each_old_connector_in_state(&state->base, conn, old_conn_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(old_conn_state->best_encoder);\n\n\t\tif (old_conn_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tif (encoder->post_disable)\n\t\t\tencoder->post_disable(state, encoder,\n\t\t\t\t\t      old_crtc_state, old_conn_state);\n\t}\n}\n\nstatic void intel_encoders_post_pll_disable(struct intel_atomic_state *state,\n\t\t\t\t\t    struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tconst struct drm_connector_state *old_conn_state;\n\tstruct drm_connector *conn;\n\tint i;\n\n\tfor_each_old_connector_in_state(&state->base, conn, old_conn_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(old_conn_state->best_encoder);\n\n\t\tif (old_conn_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tif (encoder->post_pll_disable)\n\t\t\tencoder->post_pll_disable(state, encoder,\n\t\t\t\t\t\t  old_crtc_state, old_conn_state);\n\t}\n}\n\nstatic void intel_encoders_update_pipe(struct intel_atomic_state *state,\n\t\t\t\t       struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct drm_connector_state *conn_state;\n\tstruct drm_connector *conn;\n\tint i;\n\n\tfor_each_new_connector_in_state(&state->base, conn, conn_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(conn_state->best_encoder);\n\n\t\tif (conn_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tif (encoder->update_pipe)\n\t\t\tencoder->update_pipe(state, encoder,\n\t\t\t\t\t     crtc_state, conn_state);\n\t}\n}\n\nstatic void intel_disable_primary_plane(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct intel_plane *plane = to_intel_plane(crtc->base.primary);\n\n\tplane->disable_plane(plane, crtc_state);\n}\n\nstatic void ilk_crtc_enable(struct intel_atomic_state *state,\n\t\t\t    struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tif (drm_WARN_ON(&dev_priv->drm, crtc->active))\n\t\treturn;\n\n\t/*\n\t * Sometimes spurious CPU pipe underruns happen during FDI\n\t * training, at least with VGA+HDMI cloning. Suppress them.\n\t *\n\t * On ILK we get an occasional spurious CPU pipe underruns\n\t * between eDP port A enable and vdd enable. Also PCH port\n\t * enable seems to result in the occasional CPU pipe underrun.\n\t *\n\t * Spurious PCH underruns also occur during PCH enabling.\n\t */\n\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, false);\n\tintel_set_pch_fifo_underrun_reporting(dev_priv, pipe, false);\n\n\tif (new_crtc_state->has_pch_encoder)\n\t\tintel_prepare_shared_dpll(new_crtc_state);\n\n\tif (intel_crtc_has_dp_encoder(new_crtc_state))\n\t\tintel_dp_set_m_n(new_crtc_state, M1_N1);\n\n\tintel_set_pipe_timings(new_crtc_state);\n\tintel_set_pipe_src_size(new_crtc_state);\n\n\tif (new_crtc_state->has_pch_encoder)\n\t\tintel_cpu_transcoder_set_m_n(new_crtc_state,\n\t\t\t\t\t     &new_crtc_state->fdi_m_n, NULL);\n\n\tilk_set_pipeconf(new_crtc_state);\n\n\tcrtc->active = true;\n\n\tintel_encoders_pre_enable(state, crtc);\n\n\tif (new_crtc_state->has_pch_encoder) {\n\t\t/* Note: FDI PLL enabling _must_ be done before we enable the\n\t\t * cpu pipes, hence this is separate from all the other fdi/pch\n\t\t * enabling. */\n\t\tilk_fdi_pll_enable(new_crtc_state);\n\t} else {\n\t\tassert_fdi_tx_disabled(dev_priv, pipe);\n\t\tassert_fdi_rx_disabled(dev_priv, pipe);\n\t}\n\n\tilk_pfit_enable(new_crtc_state);\n\n\t/*\n\t * On ILK+ LUT must be loaded before the pipe is running but with\n\t * clocks enabled\n\t */\n\tintel_color_load_luts(new_crtc_state);\n\tintel_color_commit(new_crtc_state);\n\t/* update DSPCNTR to configure gamma for pipe bottom color */\n\tintel_disable_primary_plane(new_crtc_state);\n\n\tif (dev_priv->display.initial_watermarks)\n\t\tdev_priv->display.initial_watermarks(state, crtc);\n\tintel_enable_pipe(new_crtc_state);\n\n\tif (new_crtc_state->has_pch_encoder)\n\t\tilk_pch_enable(state, new_crtc_state);\n\n\tintel_crtc_vblank_on(new_crtc_state);\n\n\tintel_encoders_enable(state, crtc);\n\n\tif (HAS_PCH_CPT(dev_priv))\n\t\tcpt_verify_modeset(dev_priv, pipe);\n\n\t/*\n\t * Must wait for vblank to avoid spurious PCH FIFO underruns.\n\t * And a second vblank wait is needed at least on ILK with\n\t * some interlaced HDMI modes. Let's do the double wait always\n\t * in case there are more corner cases we don't know about.\n\t */\n\tif (new_crtc_state->has_pch_encoder) {\n\t\tintel_wait_for_vblank(dev_priv, pipe);\n\t\tintel_wait_for_vblank(dev_priv, pipe);\n\t}\n\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);\n\tintel_set_pch_fifo_underrun_reporting(dev_priv, pipe, true);\n}\n\n/* IPS only exists on ULT machines and is tied to pipe A. */\nstatic bool hsw_crtc_supports_ips(struct intel_crtc *crtc)\n{\n\treturn HAS_IPS(to_i915(crtc->base.dev)) && crtc->pipe == PIPE_A;\n}\n\nstatic void glk_pipe_scaler_clock_gating_wa(struct drm_i915_private *dev_priv,\n\t\t\t\t\t    enum pipe pipe, bool apply)\n{\n\tu32 val = intel_de_read(dev_priv, CLKGATE_DIS_PSL(pipe));\n\tu32 mask = DPF_GATING_DIS | DPF_RAM_GATING_DIS | DPFR_GATING_DIS;\n\n\tif (apply)\n\t\tval |= mask;\n\telse\n\t\tval &= ~mask;\n\n\tintel_de_write(dev_priv, CLKGATE_DIS_PSL(pipe), val);\n}\n\nstatic void icl_pipe_mbus_enable(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tu32 val;\n\n\tval = MBUS_DBOX_A_CREDIT(2);\n\n\tif (INTEL_GEN(dev_priv) >= 12) {\n\t\tval |= MBUS_DBOX_BW_CREDIT(2);\n\t\tval |= MBUS_DBOX_B_CREDIT(12);\n\t} else {\n\t\tval |= MBUS_DBOX_BW_CREDIT(1);\n\t\tval |= MBUS_DBOX_B_CREDIT(8);\n\t}\n\n\tintel_de_write(dev_priv, PIPE_MBUS_DBOX_CTL(pipe), val);\n}\n\nstatic void hsw_set_linetime_wm(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tintel_de_write(dev_priv, WM_LINETIME(crtc->pipe),\n\t\t       HSW_LINETIME(crtc_state->linetime) |\n\t\t       HSW_IPS_LINETIME(crtc_state->ips_linetime));\n}\n\nstatic void hsw_set_frame_start_delay(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\ti915_reg_t reg = CHICKEN_TRANS(crtc_state->cpu_transcoder);\n\tu32 val;\n\n\tval = intel_de_read(dev_priv, reg);\n\tval &= ~HSW_FRAME_START_DELAY_MASK;\n\tval |= HSW_FRAME_START_DELAY(0);\n\tintel_de_write(dev_priv, reg, val);\n}\n\nstatic void hsw_crtc_enable(struct intel_atomic_state *state,\n\t\t\t    struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe, hsw_workaround_pipe;\n\tenum transcoder cpu_transcoder = new_crtc_state->cpu_transcoder;\n\tbool psl_clkgate_wa;\n\n\tif (drm_WARN_ON(&dev_priv->drm, crtc->active))\n\t\treturn;\n\n\tintel_encoders_pre_pll_enable(state, crtc);\n\n\tif (new_crtc_state->shared_dpll)\n\t\tintel_enable_shared_dpll(new_crtc_state);\n\n\tintel_encoders_pre_enable(state, crtc);\n\n\tif (!transcoder_is_dsi(cpu_transcoder))\n\t\tintel_set_pipe_timings(new_crtc_state);\n\n\tintel_set_pipe_src_size(new_crtc_state);\n\n\tif (cpu_transcoder != TRANSCODER_EDP &&\n\t    !transcoder_is_dsi(cpu_transcoder))\n\t\tintel_de_write(dev_priv, PIPE_MULT(cpu_transcoder),\n\t\t\t       new_crtc_state->pixel_multiplier - 1);\n\n\tif (new_crtc_state->has_pch_encoder)\n\t\tintel_cpu_transcoder_set_m_n(new_crtc_state,\n\t\t\t\t\t     &new_crtc_state->fdi_m_n, NULL);\n\n\tif (!transcoder_is_dsi(cpu_transcoder)) {\n\t\thsw_set_frame_start_delay(new_crtc_state);\n\t\thsw_set_pipeconf(new_crtc_state);\n\t}\n\n\tif (INTEL_GEN(dev_priv) >= 9 || IS_BROADWELL(dev_priv))\n\t\tbdw_set_pipemisc(new_crtc_state);\n\n\tcrtc->active = true;\n\n\t/* Display WA #1180: WaDisableScalarClockGating: glk, cnl */\n\tpsl_clkgate_wa = (IS_GEMINILAKE(dev_priv) || IS_CANNONLAKE(dev_priv)) &&\n\t\tnew_crtc_state->pch_pfit.enabled;\n\tif (psl_clkgate_wa)\n\t\tglk_pipe_scaler_clock_gating_wa(dev_priv, pipe, true);\n\n\tif (INTEL_GEN(dev_priv) >= 9)\n\t\tskl_pfit_enable(new_crtc_state);\n\telse\n\t\tilk_pfit_enable(new_crtc_state);\n\n\t/*\n\t * On ILK+ LUT must be loaded before the pipe is running but with\n\t * clocks enabled\n\t */\n\tintel_color_load_luts(new_crtc_state);\n\tintel_color_commit(new_crtc_state);\n\t/* update DSPCNTR to configure gamma/csc for pipe bottom color */\n\tif (INTEL_GEN(dev_priv) < 9)\n\t\tintel_disable_primary_plane(new_crtc_state);\n\n\thsw_set_linetime_wm(new_crtc_state);\n\n\tif (INTEL_GEN(dev_priv) >= 11)\n\t\ticl_set_pipe_chicken(crtc);\n\n\tif (dev_priv->display.initial_watermarks)\n\t\tdev_priv->display.initial_watermarks(state, crtc);\n\n\tif (INTEL_GEN(dev_priv) >= 11)\n\t\ticl_pipe_mbus_enable(crtc);\n\n\tintel_encoders_enable(state, crtc);\n\n\tif (psl_clkgate_wa) {\n\t\tintel_wait_for_vblank(dev_priv, pipe);\n\t\tglk_pipe_scaler_clock_gating_wa(dev_priv, pipe, false);\n\t}\n\n\t/* If we change the relative order between pipe/planes enabling, we need\n\t * to change the workaround. */\n\thsw_workaround_pipe = new_crtc_state->hsw_workaround_pipe;\n\tif (IS_HASWELL(dev_priv) && hsw_workaround_pipe != INVALID_PIPE) {\n\t\tintel_wait_for_vblank(dev_priv, hsw_workaround_pipe);\n\t\tintel_wait_for_vblank(dev_priv, hsw_workaround_pipe);\n\t}\n}\n\nvoid ilk_pfit_disable(const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\t/* To avoid upsetting the power well on haswell only disable the pfit if\n\t * it's in use. The hw state code will make sure we get this right. */\n\tif (!old_crtc_state->pch_pfit.enabled)\n\t\treturn;\n\n\tintel_de_write(dev_priv, PF_CTL(pipe), 0);\n\tintel_de_write(dev_priv, PF_WIN_POS(pipe), 0);\n\tintel_de_write(dev_priv, PF_WIN_SZ(pipe), 0);\n}\n\nstatic void ilk_crtc_disable(struct intel_atomic_state *state,\n\t\t\t     struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\t/*\n\t * Sometimes spurious CPU pipe underruns happen when the\n\t * pipe is already disabled, but FDI RX/TX is still enabled.\n\t * Happens at least with VGA+HDMI cloning. Suppress them.\n\t */\n\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, false);\n\tintel_set_pch_fifo_underrun_reporting(dev_priv, pipe, false);\n\n\tintel_encoders_disable(state, crtc);\n\n\tintel_crtc_vblank_off(old_crtc_state);\n\n\tintel_disable_pipe(old_crtc_state);\n\n\tilk_pfit_disable(old_crtc_state);\n\n\tif (old_crtc_state->has_pch_encoder)\n\t\tilk_fdi_disable(crtc);\n\n\tintel_encoders_post_disable(state, crtc);\n\n\tif (old_crtc_state->has_pch_encoder) {\n\t\tilk_disable_pch_transcoder(dev_priv, pipe);\n\n\t\tif (HAS_PCH_CPT(dev_priv)) {\n\t\t\ti915_reg_t reg;\n\t\t\tu32 temp;\n\n\t\t\t/* disable TRANS_DP_CTL */\n\t\t\treg = TRANS_DP_CTL(pipe);\n\t\t\ttemp = intel_de_read(dev_priv, reg);\n\t\t\ttemp &= ~(TRANS_DP_OUTPUT_ENABLE |\n\t\t\t\t  TRANS_DP_PORT_SEL_MASK);\n\t\t\ttemp |= TRANS_DP_PORT_SEL_NONE;\n\t\t\tintel_de_write(dev_priv, reg, temp);\n\n\t\t\t/* disable DPLL_SEL */\n\t\t\ttemp = intel_de_read(dev_priv, PCH_DPLL_SEL);\n\t\t\ttemp &= ~(TRANS_DPLL_ENABLE(pipe) | TRANS_DPLLB_SEL(pipe));\n\t\t\tintel_de_write(dev_priv, PCH_DPLL_SEL, temp);\n\t\t}\n\n\t\tilk_fdi_pll_disable(crtc);\n\t}\n\n\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);\n\tintel_set_pch_fifo_underrun_reporting(dev_priv, pipe, true);\n}\n\nstatic void hsw_crtc_disable(struct intel_atomic_state *state,\n\t\t\t     struct intel_crtc *crtc)\n{\n\t/*\n\t * FIXME collapse everything to one hook.\n\t * Need care with mst->ddi interactions.\n\t */\n\tintel_encoders_disable(state, crtc);\n\tintel_encoders_post_disable(state, crtc);\n}\n\nstatic void i9xx_pfit_enable(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tif (!crtc_state->gmch_pfit.control)\n\t\treturn;\n\n\t/*\n\t * The panel fitter should only be adjusted whilst the pipe is disabled,\n\t * according to register description and PRM.\n\t */\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_de_read(dev_priv, PFIT_CONTROL) & PFIT_ENABLE);\n\tassert_pipe_disabled(dev_priv, crtc_state->cpu_transcoder);\n\n\tintel_de_write(dev_priv, PFIT_PGM_RATIOS,\n\t\t       crtc_state->gmch_pfit.pgm_ratios);\n\tintel_de_write(dev_priv, PFIT_CONTROL, crtc_state->gmch_pfit.control);\n\n\t/* Border color in case we don't scale up to the full screen. Black by\n\t * default, change to something else for debugging. */\n\tintel_de_write(dev_priv, BCLRPAT(crtc->pipe), 0);\n}\n\nbool intel_phy_is_combo(struct drm_i915_private *dev_priv, enum phy phy)\n{\n\tif (phy == PHY_NONE)\n\t\treturn false;\n\telse if (IS_ROCKETLAKE(dev_priv))\n\t\treturn phy <= PHY_D;\n\telse if (IS_ELKHARTLAKE(dev_priv))\n\t\treturn phy <= PHY_C;\n\telse if (INTEL_GEN(dev_priv) >= 11)\n\t\treturn phy <= PHY_B;\n\telse\n\t\treturn false;\n}\n\nbool intel_phy_is_tc(struct drm_i915_private *dev_priv, enum phy phy)\n{\n\tif (IS_ROCKETLAKE(dev_priv))\n\t\treturn false;\n\telse if (INTEL_GEN(dev_priv) >= 12)\n\t\treturn phy >= PHY_D && phy <= PHY_I;\n\telse if (INTEL_GEN(dev_priv) >= 11 && !IS_ELKHARTLAKE(dev_priv))\n\t\treturn phy >= PHY_C && phy <= PHY_F;\n\telse\n\t\treturn false;\n}\n\nenum phy intel_port_to_phy(struct drm_i915_private *i915, enum port port)\n{\n\tif (IS_ROCKETLAKE(i915) && port >= PORT_D)\n\t\treturn (enum phy)port - 1;\n\telse if (IS_ELKHARTLAKE(i915) && port == PORT_D)\n\t\treturn PHY_A;\n\n\treturn (enum phy)port;\n}\n\nenum tc_port intel_port_to_tc(struct drm_i915_private *dev_priv, enum port port)\n{\n\tif (!intel_phy_is_tc(dev_priv, intel_port_to_phy(dev_priv, port)))\n\t\treturn PORT_TC_NONE;\n\n\tif (INTEL_GEN(dev_priv) >= 12)\n\t\treturn port - PORT_D;\n\n\treturn port - PORT_C;\n}\n\nenum intel_display_power_domain intel_port_to_power_domain(enum port port)\n{\n\tswitch (port) {\n\tcase PORT_A:\n\t\treturn POWER_DOMAIN_PORT_DDI_A_LANES;\n\tcase PORT_B:\n\t\treturn POWER_DOMAIN_PORT_DDI_B_LANES;\n\tcase PORT_C:\n\t\treturn POWER_DOMAIN_PORT_DDI_C_LANES;\n\tcase PORT_D:\n\t\treturn POWER_DOMAIN_PORT_DDI_D_LANES;\n\tcase PORT_E:\n\t\treturn POWER_DOMAIN_PORT_DDI_E_LANES;\n\tcase PORT_F:\n\t\treturn POWER_DOMAIN_PORT_DDI_F_LANES;\n\tcase PORT_G:\n\t\treturn POWER_DOMAIN_PORT_DDI_G_LANES;\n\tcase PORT_H:\n\t\treturn POWER_DOMAIN_PORT_DDI_H_LANES;\n\tcase PORT_I:\n\t\treturn POWER_DOMAIN_PORT_DDI_I_LANES;\n\tdefault:\n\t\tMISSING_CASE(port);\n\t\treturn POWER_DOMAIN_PORT_OTHER;\n\t}\n}\n\nenum intel_display_power_domain\nintel_aux_power_domain(struct intel_digital_port *dig_port)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);\n\tenum phy phy = intel_port_to_phy(dev_priv, dig_port->base.port);\n\n\tif (intel_phy_is_tc(dev_priv, phy) &&\n\t    dig_port->tc_mode == TC_PORT_TBT_ALT) {\n\t\tswitch (dig_port->aux_ch) {\n\t\tcase AUX_CH_C:\n\t\t\treturn POWER_DOMAIN_AUX_C_TBT;\n\t\tcase AUX_CH_D:\n\t\t\treturn POWER_DOMAIN_AUX_D_TBT;\n\t\tcase AUX_CH_E:\n\t\t\treturn POWER_DOMAIN_AUX_E_TBT;\n\t\tcase AUX_CH_F:\n\t\t\treturn POWER_DOMAIN_AUX_F_TBT;\n\t\tcase AUX_CH_G:\n\t\t\treturn POWER_DOMAIN_AUX_G_TBT;\n\t\tcase AUX_CH_H:\n\t\t\treturn POWER_DOMAIN_AUX_H_TBT;\n\t\tcase AUX_CH_I:\n\t\t\treturn POWER_DOMAIN_AUX_I_TBT;\n\t\tdefault:\n\t\t\tMISSING_CASE(dig_port->aux_ch);\n\t\t\treturn POWER_DOMAIN_AUX_C_TBT;\n\t\t}\n\t}\n\n\treturn intel_legacy_aux_to_power_domain(dig_port->aux_ch);\n}\n\n/*\n * Converts aux_ch to power_domain without caring about TBT ports for that use\n * intel_aux_power_domain()\n */\nenum intel_display_power_domain\nintel_legacy_aux_to_power_domain(enum aux_ch aux_ch)\n{\n\tswitch (aux_ch) {\n\tcase AUX_CH_A:\n\t\treturn POWER_DOMAIN_AUX_A;\n\tcase AUX_CH_B:\n\t\treturn POWER_DOMAIN_AUX_B;\n\tcase AUX_CH_C:\n\t\treturn POWER_DOMAIN_AUX_C;\n\tcase AUX_CH_D:\n\t\treturn POWER_DOMAIN_AUX_D;\n\tcase AUX_CH_E:\n\t\treturn POWER_DOMAIN_AUX_E;\n\tcase AUX_CH_F:\n\t\treturn POWER_DOMAIN_AUX_F;\n\tcase AUX_CH_G:\n\t\treturn POWER_DOMAIN_AUX_G;\n\tcase AUX_CH_H:\n\t\treturn POWER_DOMAIN_AUX_H;\n\tcase AUX_CH_I:\n\t\treturn POWER_DOMAIN_AUX_I;\n\tdefault:\n\t\tMISSING_CASE(aux_ch);\n\t\treturn POWER_DOMAIN_AUX_A;\n\t}\n}\n\nstatic u64 get_crtc_power_domains(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct drm_encoder *encoder;\n\tenum pipe pipe = crtc->pipe;\n\tu64 mask;\n\tenum transcoder transcoder = crtc_state->cpu_transcoder;\n\n\tif (!crtc_state->hw.active)\n\t\treturn 0;\n\n\tmask = BIT_ULL(POWER_DOMAIN_PIPE(pipe));\n\tmask |= BIT_ULL(POWER_DOMAIN_TRANSCODER(transcoder));\n\tif (crtc_state->pch_pfit.enabled ||\n\t    crtc_state->pch_pfit.force_thru)\n\t\tmask |= BIT_ULL(POWER_DOMAIN_PIPE_PANEL_FITTER(pipe));\n\n\tdrm_for_each_encoder_mask(encoder, &dev_priv->drm,\n\t\t\t\t  crtc_state->uapi.encoder_mask) {\n\t\tstruct intel_encoder *intel_encoder = to_intel_encoder(encoder);\n\n\t\tmask |= BIT_ULL(intel_encoder->power_domain);\n\t}\n\n\tif (HAS_DDI(dev_priv) && crtc_state->has_audio)\n\t\tmask |= BIT_ULL(POWER_DOMAIN_AUDIO);\n\n\tif (crtc_state->shared_dpll)\n\t\tmask |= BIT_ULL(POWER_DOMAIN_DISPLAY_CORE);\n\n\treturn mask;\n}\n\nstatic u64\nmodeset_get_crtc_power_domains(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum intel_display_power_domain domain;\n\tu64 domains, new_domains, old_domains;\n\n\told_domains = crtc->enabled_power_domains;\n\tcrtc->enabled_power_domains = new_domains =\n\t\tget_crtc_power_domains(crtc_state);\n\n\tdomains = new_domains & ~old_domains;\n\n\tfor_each_power_domain(domain, domains)\n\t\tintel_display_power_get(dev_priv, domain);\n\n\treturn old_domains & ~new_domains;\n}\n\nstatic void modeset_put_power_domains(struct drm_i915_private *dev_priv,\n\t\t\t\t      u64 domains)\n{\n\tenum intel_display_power_domain domain;\n\n\tfor_each_power_domain(domain, domains)\n\t\tintel_display_power_put_unchecked(dev_priv, domain);\n}\n\nstatic void valleyview_crtc_enable(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tif (drm_WARN_ON(&dev_priv->drm, crtc->active))\n\t\treturn;\n\n\tif (intel_crtc_has_dp_encoder(new_crtc_state))\n\t\tintel_dp_set_m_n(new_crtc_state, M1_N1);\n\n\tintel_set_pipe_timings(new_crtc_state);\n\tintel_set_pipe_src_size(new_crtc_state);\n\n\tif (IS_CHERRYVIEW(dev_priv) && pipe == PIPE_B) {\n\t\tintel_de_write(dev_priv, CHV_BLEND(pipe), CHV_BLEND_LEGACY);\n\t\tintel_de_write(dev_priv, CHV_CANVAS(pipe), 0);\n\t}\n\n\ti9xx_set_pipeconf(new_crtc_state);\n\n\tcrtc->active = true;\n\n\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);\n\n\tintel_encoders_pre_pll_enable(state, crtc);\n\n\tif (IS_CHERRYVIEW(dev_priv)) {\n\t\tchv_prepare_pll(crtc, new_crtc_state);\n\t\tchv_enable_pll(crtc, new_crtc_state);\n\t} else {\n\t\tvlv_prepare_pll(crtc, new_crtc_state);\n\t\tvlv_enable_pll(crtc, new_crtc_state);\n\t}\n\n\tintel_encoders_pre_enable(state, crtc);\n\n\ti9xx_pfit_enable(new_crtc_state);\n\n\tintel_color_load_luts(new_crtc_state);\n\tintel_color_commit(new_crtc_state);\n\t/* update DSPCNTR to configure gamma for pipe bottom color */\n\tintel_disable_primary_plane(new_crtc_state);\n\n\tdev_priv->display.initial_watermarks(state, crtc);\n\tintel_enable_pipe(new_crtc_state);\n\n\tintel_crtc_vblank_on(new_crtc_state);\n\n\tintel_encoders_enable(state, crtc);\n}\n\nstatic void i9xx_set_pll_dividers(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tintel_de_write(dev_priv, FP0(crtc->pipe),\n\t\t       crtc_state->dpll_hw_state.fp0);\n\tintel_de_write(dev_priv, FP1(crtc->pipe),\n\t\t       crtc_state->dpll_hw_state.fp1);\n}\n\nstatic void i9xx_crtc_enable(struct intel_atomic_state *state,\n\t\t\t     struct intel_crtc *crtc)\n{\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tif (drm_WARN_ON(&dev_priv->drm, crtc->active))\n\t\treturn;\n\n\ti9xx_set_pll_dividers(new_crtc_state);\n\n\tif (intel_crtc_has_dp_encoder(new_crtc_state))\n\t\tintel_dp_set_m_n(new_crtc_state, M1_N1);\n\n\tintel_set_pipe_timings(new_crtc_state);\n\tintel_set_pipe_src_size(new_crtc_state);\n\n\ti9xx_set_pipeconf(new_crtc_state);\n\n\tcrtc->active = true;\n\n\tif (!IS_GEN(dev_priv, 2))\n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);\n\n\tintel_encoders_pre_enable(state, crtc);\n\n\ti9xx_enable_pll(crtc, new_crtc_state);\n\n\ti9xx_pfit_enable(new_crtc_state);\n\n\tintel_color_load_luts(new_crtc_state);\n\tintel_color_commit(new_crtc_state);\n\t/* update DSPCNTR to configure gamma for pipe bottom color */\n\tintel_disable_primary_plane(new_crtc_state);\n\n\tif (dev_priv->display.initial_watermarks)\n\t\tdev_priv->display.initial_watermarks(state, crtc);\n\telse\n\t\tintel_update_watermarks(crtc);\n\tintel_enable_pipe(new_crtc_state);\n\n\tintel_crtc_vblank_on(new_crtc_state);\n\n\tintel_encoders_enable(state, crtc);\n\n\t/* prevents spurious underruns */\n\tif (IS_GEN(dev_priv, 2))\n\t\tintel_wait_for_vblank(dev_priv, pipe);\n}\n\nstatic void i9xx_pfit_disable(const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tif (!old_crtc_state->gmch_pfit.control)\n\t\treturn;\n\n\tassert_pipe_disabled(dev_priv, old_crtc_state->cpu_transcoder);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"disabling pfit, current: 0x%08x\\n\",\n\t\t    intel_de_read(dev_priv, PFIT_CONTROL));\n\tintel_de_write(dev_priv, PFIT_CONTROL, 0);\n}\n\nstatic void i9xx_crtc_disable(struct intel_atomic_state *state,\n\t\t\t      struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\t/*\n\t * On gen2 planes are double buffered but the pipe isn't, so we must\n\t * wait for planes to fully turn off before disabling the pipe.\n\t */\n\tif (IS_GEN(dev_priv, 2))\n\t\tintel_wait_for_vblank(dev_priv, pipe);\n\n\tintel_encoders_disable(state, crtc);\n\n\tintel_crtc_vblank_off(old_crtc_state);\n\n\tintel_disable_pipe(old_crtc_state);\n\n\ti9xx_pfit_disable(old_crtc_state);\n\n\tintel_encoders_post_disable(state, crtc);\n\n\tif (!intel_crtc_has_type(old_crtc_state, INTEL_OUTPUT_DSI)) {\n\t\tif (IS_CHERRYVIEW(dev_priv))\n\t\t\tchv_disable_pll(dev_priv, pipe);\n\t\telse if (IS_VALLEYVIEW(dev_priv))\n\t\t\tvlv_disable_pll(dev_priv, pipe);\n\t\telse\n\t\t\ti9xx_disable_pll(old_crtc_state);\n\t}\n\n\tintel_encoders_post_pll_disable(state, crtc);\n\n\tif (!IS_GEN(dev_priv, 2))\n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, false);\n\n\tif (!dev_priv->display.initial_watermarks)\n\t\tintel_update_watermarks(crtc);\n\n\t/* clock the pipe down to 640x480@60 to potentially save power */\n\tif (IS_I830(dev_priv))\n\t\ti830_enable_pipe(dev_priv, pipe);\n}\n\nstatic void intel_crtc_disable_noatomic(struct intel_crtc *crtc,\n\t\t\t\t\tstruct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct intel_encoder *encoder;\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_bw_state *bw_state =\n\t\tto_intel_bw_state(dev_priv->bw_obj.state);\n\tstruct intel_cdclk_state *cdclk_state =\n\t\tto_intel_cdclk_state(dev_priv->cdclk.obj.state);\n\tstruct intel_dbuf_state *dbuf_state =\n\t\tto_intel_dbuf_state(dev_priv->dbuf.obj.state);\n\tstruct intel_crtc_state *crtc_state =\n\t\tto_intel_crtc_state(crtc->base.state);\n\tenum intel_display_power_domain domain;\n\tstruct intel_plane *plane;\n\tstruct drm_atomic_state *state;\n\tstruct intel_crtc_state *temp_crtc_state;\n\tenum pipe pipe = crtc->pipe;\n\tu64 domains;\n\tint ret;\n\n\tif (!crtc_state->hw.active)\n\t\treturn;\n\n\tfor_each_intel_plane_on_crtc(&dev_priv->drm, crtc, plane) {\n\t\tconst struct intel_plane_state *plane_state =\n\t\t\tto_intel_plane_state(plane->base.state);\n\n\t\tif (plane_state->uapi.visible)\n\t\t\tintel_plane_disable_noatomic(crtc, plane);\n\t}\n\n\tstate = drm_atomic_state_alloc(&dev_priv->drm);\n\tif (!state) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"failed to disable [CRTC:%d:%s], out of memory\",\n\t\t\t    crtc->base.base.id, crtc->base.name);\n\t\treturn;\n\t}\n\n\tstate->acquire_ctx = ctx;\n\n\t/* Everything's already locked, -EDEADLK can't happen. */\n\ttemp_crtc_state = intel_atomic_get_crtc_state(state, crtc);\n\tret = drm_atomic_add_affected_connectors(state, &crtc->base);\n\n\tdrm_WARN_ON(&dev_priv->drm, IS_ERR(temp_crtc_state) || ret);\n\n\tdev_priv->display.crtc_disable(to_intel_atomic_state(state), crtc);\n\n\tdrm_atomic_state_put(state);\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"[CRTC:%d:%s] hw state adjusted, was enabled, now disabled\\n\",\n\t\t    crtc->base.base.id, crtc->base.name);\n\n\tcrtc->active = false;\n\tcrtc->base.enabled = false;\n\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    drm_atomic_set_mode_for_crtc(&crtc_state->uapi, NULL) < 0);\n\tcrtc_state->uapi.active = false;\n\tcrtc_state->uapi.connector_mask = 0;\n\tcrtc_state->uapi.encoder_mask = 0;\n\tintel_crtc_free_hw_state(crtc_state);\n\tmemset(&crtc_state->hw, 0, sizeof(crtc_state->hw));\n\n\tfor_each_encoder_on_crtc(&dev_priv->drm, &crtc->base, encoder)\n\t\tencoder->base.crtc = NULL;\n\n\tintel_fbc_disable(crtc);\n\tintel_update_watermarks(crtc);\n\tintel_disable_shared_dpll(crtc_state);\n\n\tdomains = crtc->enabled_power_domains;\n\tfor_each_power_domain(domain, domains)\n\t\tintel_display_power_put_unchecked(dev_priv, domain);\n\tcrtc->enabled_power_domains = 0;\n\n\tdev_priv->active_pipes &= ~BIT(pipe);\n\tcdclk_state->min_cdclk[pipe] = 0;\n\tcdclk_state->min_voltage_level[pipe] = 0;\n\tcdclk_state->active_pipes &= ~BIT(pipe);\n\n\tdbuf_state->active_pipes &= ~BIT(pipe);\n\n\tbw_state->data_rate[pipe] = 0;\n\tbw_state->num_active_planes[pipe] = 0;\n}\n\n/*\n * turn all crtc's off, but do not adjust state\n * This has to be paired with a call to intel_modeset_setup_hw_state.\n */\nint intel_display_suspend(struct drm_device *dev)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_atomic_state *state;\n\tint ret;\n\n\tstate = drm_atomic_helper_suspend(dev);\n\tret = PTR_ERR_OR_ZERO(state);\n\tif (ret)\n\t\tdrm_err(&dev_priv->drm, \"Suspending crtc's failed with %i\\n\",\n\t\t\tret);\n\telse\n\t\tdev_priv->modeset_restore_state = state;\n\treturn ret;\n}\n\nvoid intel_encoder_destroy(struct drm_encoder *encoder)\n{\n\tstruct intel_encoder *intel_encoder = to_intel_encoder(encoder);\n\n\tdrm_encoder_cleanup(encoder);\n\tkfree(intel_encoder);\n}\n\n/* Cross check the actual hw state with our own modeset state tracking (and it's\n * internal consistency). */\nstatic void intel_connector_verify_state(struct intel_crtc_state *crtc_state,\n\t\t\t\t\t struct drm_connector_state *conn_state)\n{\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s]\\n\",\n\t\t    connector->base.base.id, connector->base.name);\n\n\tif (connector->get_hw_state(connector)) {\n\t\tstruct intel_encoder *encoder = intel_attached_encoder(connector);\n\n\t\tI915_STATE_WARN(!crtc_state,\n\t\t\t \"connector enabled without attached crtc\\n\");\n\n\t\tif (!crtc_state)\n\t\t\treturn;\n\n\t\tI915_STATE_WARN(!crtc_state->hw.active,\n\t\t\t\t\"connector is active, but attached crtc isn't\\n\");\n\n\t\tif (!encoder || encoder->type == INTEL_OUTPUT_DP_MST)\n\t\t\treturn;\n\n\t\tI915_STATE_WARN(conn_state->best_encoder != &encoder->base,\n\t\t\t\"atomic encoder doesn't match attached encoder\\n\");\n\n\t\tI915_STATE_WARN(conn_state->crtc != encoder->base.crtc,\n\t\t\t\"attached encoder crtc differs from connector crtc\\n\");\n\t} else {\n\t\tI915_STATE_WARN(crtc_state && crtc_state->hw.active,\n\t\t\t\t\"attached crtc is active, but connector isn't\\n\");\n\t\tI915_STATE_WARN(!crtc_state && conn_state->best_encoder,\n\t\t\t\"best encoder set without crtc!\\n\");\n\t}\n}\n\nstatic int pipe_required_fdi_lanes(struct intel_crtc_state *crtc_state)\n{\n\tif (crtc_state->hw.enable && crtc_state->has_pch_encoder)\n\t\treturn crtc_state->fdi_lanes;\n\n\treturn 0;\n}\n\nstatic int ilk_check_fdi_lanes(struct drm_device *dev, enum pipe pipe,\n\t\t\t       struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_atomic_state *state = pipe_config->uapi.state;\n\tstruct intel_crtc *other_crtc;\n\tstruct intel_crtc_state *other_crtc_state;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"checking fdi config on pipe %c, lanes %i\\n\",\n\t\t    pipe_name(pipe), pipe_config->fdi_lanes);\n\tif (pipe_config->fdi_lanes > 4) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"invalid fdi lane config on pipe %c: %i lanes\\n\",\n\t\t\t    pipe_name(pipe), pipe_config->fdi_lanes);\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {\n\t\tif (pipe_config->fdi_lanes > 2) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"only 2 lanes on haswell, required: %i lanes\\n\",\n\t\t\t\t    pipe_config->fdi_lanes);\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (INTEL_NUM_PIPES(dev_priv) == 2)\n\t\treturn 0;\n\n\t/* Ivybridge 3 pipe is really complicated */\n\tswitch (pipe) {\n\tcase PIPE_A:\n\t\treturn 0;\n\tcase PIPE_B:\n\t\tif (pipe_config->fdi_lanes <= 2)\n\t\t\treturn 0;\n\n\t\tother_crtc = intel_get_crtc_for_pipe(dev_priv, PIPE_C);\n\t\tother_crtc_state =\n\t\t\tintel_atomic_get_crtc_state(state, other_crtc);\n\t\tif (IS_ERR(other_crtc_state))\n\t\t\treturn PTR_ERR(other_crtc_state);\n\n\t\tif (pipe_required_fdi_lanes(other_crtc_state) > 0) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"invalid shared fdi lane config on pipe %c: %i lanes\\n\",\n\t\t\t\t    pipe_name(pipe), pipe_config->fdi_lanes);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\tcase PIPE_C:\n\t\tif (pipe_config->fdi_lanes > 2) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"only 2 lanes on pipe %c: required %i lanes\\n\",\n\t\t\t\t    pipe_name(pipe), pipe_config->fdi_lanes);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tother_crtc = intel_get_crtc_for_pipe(dev_priv, PIPE_B);\n\t\tother_crtc_state =\n\t\t\tintel_atomic_get_crtc_state(state, other_crtc);\n\t\tif (IS_ERR(other_crtc_state))\n\t\t\treturn PTR_ERR(other_crtc_state);\n\n\t\tif (pipe_required_fdi_lanes(other_crtc_state) > 2) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"fdi link B uses too many lanes to enable link C\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n#define RETRY 1\nstatic int ilk_fdi_compute_config(struct intel_crtc *intel_crtc,\n\t\t\t\t  struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_device *dev = intel_crtc->base.dev;\n\tstruct drm_i915_private *i915 = to_i915(dev);\n\tconst struct drm_display_mode *adjusted_mode = &pipe_config->hw.adjusted_mode;\n\tint lane, link_bw, fdi_dotclock, ret;\n\tbool needs_recompute = false;\n\nretry:\n\t/* FDI is a binary signal running at ~2.7GHz, encoding\n\t * each output octet as 10 bits. The actual frequency\n\t * is stored as a divider into a 100MHz clock, and the\n\t * mode pixel clock is stored in units of 1KHz.\n\t * Hence the bw of each lane in terms of the mode signal\n\t * is:\n\t */\n\tlink_bw = intel_fdi_link_freq(i915, pipe_config);\n\n\tfdi_dotclock = adjusted_mode->crtc_clock;\n\n\tlane = ilk_get_lanes_required(fdi_dotclock, link_bw,\n\t\t\t\t      pipe_config->pipe_bpp);\n\n\tpipe_config->fdi_lanes = lane;\n\n\tintel_link_compute_m_n(pipe_config->pipe_bpp, lane, fdi_dotclock,\n\t\t\t       link_bw, &pipe_config->fdi_m_n, false, false);\n\n\tret = ilk_check_fdi_lanes(dev, intel_crtc->pipe, pipe_config);\n\tif (ret == -EDEADLK)\n\t\treturn ret;\n\n\tif (ret == -EINVAL && pipe_config->pipe_bpp > 6*3) {\n\t\tpipe_config->pipe_bpp -= 2*3;\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"fdi link bw constraint, reducing pipe bpp to %i\\n\",\n\t\t\t    pipe_config->pipe_bpp);\n\t\tneeds_recompute = true;\n\t\tpipe_config->bw_constrained = true;\n\n\t\tgoto retry;\n\t}\n\n\tif (needs_recompute)\n\t\treturn RETRY;\n\n\treturn ret;\n}\n\nbool hsw_crtc_state_ips_capable(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\t/* IPS only exists on ULT machines and is tied to pipe A. */\n\tif (!hsw_crtc_supports_ips(crtc))\n\t\treturn false;\n\n\tif (!dev_priv->params.enable_ips)\n\t\treturn false;\n\n\tif (crtc_state->pipe_bpp > 24)\n\t\treturn false;\n\n\t/*\n\t * We compare against max which means we must take\n\t * the increased cdclk requirement into account when\n\t * calculating the new cdclk.\n\t *\n\t * Should measure whether using a lower cdclk w/o IPS\n\t */\n\tif (IS_BROADWELL(dev_priv) &&\n\t    crtc_state->pixel_rate > dev_priv->max_cdclk_freq * 95 / 100)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int hsw_compute_ips_config(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(crtc_state->uapi.crtc->dev);\n\tstruct intel_atomic_state *state =\n\t\tto_intel_atomic_state(crtc_state->uapi.state);\n\n\tcrtc_state->ips_enabled = false;\n\n\tif (!hsw_crtc_state_ips_capable(crtc_state))\n\t\treturn 0;\n\n\t/*\n\t * When IPS gets enabled, the pipe CRC changes. Since IPS gets\n\t * enabled and disabled dynamically based on package C states,\n\t * user space can't make reliable use of the CRCs, so let's just\n\t * completely disable it.\n\t */\n\tif (crtc_state->crc_enabled)\n\t\treturn 0;\n\n\t/* IPS should be fine as long as at least one plane is enabled. */\n\tif (!(crtc_state->active_planes & ~BIT(PLANE_CURSOR)))\n\t\treturn 0;\n\n\tif (IS_BROADWELL(dev_priv)) {\n\t\tconst struct intel_cdclk_state *cdclk_state;\n\n\t\tcdclk_state = intel_atomic_get_cdclk_state(state);\n\t\tif (IS_ERR(cdclk_state))\n\t\t\treturn PTR_ERR(cdclk_state);\n\n\t\t/* pixel rate mustn't exceed 95% of cdclk with IPS on BDW */\n\t\tif (crtc_state->pixel_rate > cdclk_state->logical.cdclk * 95 / 100)\n\t\t\treturn 0;\n\t}\n\n\tcrtc_state->ips_enabled = true;\n\n\treturn 0;\n}\n\nstatic bool intel_crtc_supports_double_wide(const struct intel_crtc *crtc)\n{\n\tconst struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\t/* GDG double wide on either pipe, otherwise pipe A only */\n\treturn INTEL_GEN(dev_priv) < 4 &&\n\t\t(crtc->pipe == PIPE_A || IS_I915G(dev_priv));\n}\n\nstatic u32 ilk_pipe_pixel_rate(const struct intel_crtc_state *crtc_state)\n{\n\tu32 pixel_rate = crtc_state->hw.adjusted_mode.crtc_clock;\n\tunsigned int pipe_w, pipe_h, pfit_w, pfit_h;\n\n\t/*\n\t * We only use IF-ID interlacing. If we ever use\n\t * PF-ID we'll need to adjust the pixel_rate here.\n\t */\n\n\tif (!crtc_state->pch_pfit.enabled)\n\t\treturn pixel_rate;\n\n\tpipe_w = crtc_state->pipe_src_w;\n\tpipe_h = crtc_state->pipe_src_h;\n\n\tpfit_w = drm_rect_width(&crtc_state->pch_pfit.dst);\n\tpfit_h = drm_rect_height(&crtc_state->pch_pfit.dst);\n\n\tif (pipe_w < pfit_w)\n\t\tpipe_w = pfit_w;\n\tif (pipe_h < pfit_h)\n\t\tpipe_h = pfit_h;\n\n\tif (drm_WARN_ON(crtc_state->uapi.crtc->dev,\n\t\t\t!pfit_w || !pfit_h))\n\t\treturn pixel_rate;\n\n\treturn div_u64(mul_u32_u32(pixel_rate, pipe_w * pipe_h),\n\t\t       pfit_w * pfit_h);\n}\n\nstatic void intel_crtc_compute_pixel_rate(struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\n\tif (HAS_GMCH(dev_priv))\n\t\t/* FIXME calculate proper pipe pixel rate for GMCH pfit */\n\t\tcrtc_state->pixel_rate =\n\t\t\tcrtc_state->hw.adjusted_mode.crtc_clock;\n\telse\n\t\tcrtc_state->pixel_rate =\n\t\t\tilk_pipe_pixel_rate(crtc_state);\n}\n\nstatic int intel_crtc_compute_config(struct intel_crtc *crtc,\n\t\t\t\t     struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct drm_display_mode *adjusted_mode = &pipe_config->hw.adjusted_mode;\n\tint clock_limit = dev_priv->max_dotclk_freq;\n\n\tif (INTEL_GEN(dev_priv) < 4) {\n\t\tclock_limit = dev_priv->max_cdclk_freq * 9 / 10;\n\n\t\t/*\n\t\t * Enable double wide mode when the dot clock\n\t\t * is > 90% of the (display) core speed.\n\t\t */\n\t\tif (intel_crtc_supports_double_wide(crtc) &&\n\t\t    adjusted_mode->crtc_clock > clock_limit) {\n\t\t\tclock_limit = dev_priv->max_dotclk_freq;\n\t\t\tpipe_config->double_wide = true;\n\t\t}\n\t}\n\n\tif (adjusted_mode->crtc_clock > clock_limit) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"requested pixel clock (%d kHz) too high (max: %d kHz, double wide: %s)\\n\",\n\t\t\t    adjusted_mode->crtc_clock, clock_limit,\n\t\t\t    yesno(pipe_config->double_wide));\n\t\treturn -EINVAL;\n\t}\n\n\tif ((pipe_config->output_format == INTEL_OUTPUT_FORMAT_YCBCR420 ||\n\t     pipe_config->output_format == INTEL_OUTPUT_FORMAT_YCBCR444) &&\n\t     pipe_config->hw.ctm) {\n\t\t/*\n\t\t * There is only one pipe CSC unit per pipe, and we need that\n\t\t * for output conversion from RGB->YCBCR. So if CTM is already\n\t\t * applied we can't support YCBCR420 output.\n\t\t */\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"YCBCR420 and CTM together are not possible\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Pipe horizontal size must be even in:\n\t * - DVO ganged mode\n\t * - LVDS dual channel mode\n\t * - Double wide pipe\n\t */\n\tif (pipe_config->pipe_src_w & 1) {\n\t\tif (pipe_config->double_wide) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Odd pipe source width not supported with double wide pipe\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (intel_crtc_has_type(pipe_config, INTEL_OUTPUT_LVDS) &&\n\t\t    intel_is_dual_link_lvds(dev_priv)) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Odd pipe source width not supported with dual link LVDS\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Cantiga+ cannot handle modes with a hsync front porch of 0.\n\t * WaPruneModeWithIncorrectHsyncOffset:ctg,elk,ilk,snb,ivb,vlv,hsw.\n\t */\n\tif ((INTEL_GEN(dev_priv) > 4 || IS_G4X(dev_priv)) &&\n\t\tadjusted_mode->crtc_hsync_start == adjusted_mode->crtc_hdisplay)\n\t\treturn -EINVAL;\n\n\tintel_crtc_compute_pixel_rate(pipe_config);\n\n\tif (pipe_config->has_pch_encoder)\n\t\treturn ilk_fdi_compute_config(crtc, pipe_config);\n\n\treturn 0;\n}\n\nstatic void\nintel_reduce_m_n_ratio(u32 *num, u32 *den)\n{\n\twhile (*num > DATA_LINK_M_N_MASK ||\n\t       *den > DATA_LINK_M_N_MASK) {\n\t\t*num >>= 1;\n\t\t*den >>= 1;\n\t}\n}\n\nstatic void compute_m_n(unsigned int m, unsigned int n,\n\t\t\tu32 *ret_m, u32 *ret_n,\n\t\t\tbool constant_n)\n{\n\t/*\n\t * Several DP dongles in particular seem to be fussy about\n\t * too large link M/N values. Give N value as 0x8000 that\n\t * should be acceptable by specific devices. 0x8000 is the\n\t * specified fixed N value for asynchronous clock mode,\n\t * which the devices expect also in synchronous clock mode.\n\t */\n\tif (constant_n)\n\t\t*ret_n = DP_LINK_CONSTANT_N_VALUE;\n\telse\n\t\t*ret_n = min_t(unsigned int, roundup_pow_of_two(n), DATA_LINK_N_MAX);\n\n\t*ret_m = div_u64(mul_u32_u32(m, *ret_n), n);\n\tintel_reduce_m_n_ratio(ret_m, ret_n);\n}\n\nvoid\nintel_link_compute_m_n(u16 bits_per_pixel, int nlanes,\n\t\t       int pixel_clock, int link_clock,\n\t\t       struct intel_link_m_n *m_n,\n\t\t       bool constant_n, bool fec_enable)\n{\n\tu32 data_clock = bits_per_pixel * pixel_clock;\n\n\tif (fec_enable)\n\t\tdata_clock = intel_dp_mode_to_fec_clock(data_clock);\n\n\tm_n->tu = 64;\n\tcompute_m_n(data_clock,\n\t\t    link_clock * nlanes * 8,\n\t\t    &m_n->gmch_m, &m_n->gmch_n,\n\t\t    constant_n);\n\n\tcompute_m_n(pixel_clock, link_clock,\n\t\t    &m_n->link_m, &m_n->link_n,\n\t\t    constant_n);\n}\n\nstatic void intel_panel_sanitize_ssc(struct drm_i915_private *dev_priv)\n{\n\t/*\n\t * There may be no VBT; and if the BIOS enabled SSC we can\n\t * just keep using it to avoid unnecessary flicker.  Whereas if the\n\t * BIOS isn't using it, don't assume it will work even if the VBT\n\t * indicates as much.\n\t */\n\tif (HAS_PCH_IBX(dev_priv) || HAS_PCH_CPT(dev_priv)) {\n\t\tbool bios_lvds_use_ssc = intel_de_read(dev_priv,\n\t\t\t\t\t\t       PCH_DREF_CONTROL) &\n\t\t\tDREF_SSC1_ENABLE;\n\n\t\tif (dev_priv->vbt.lvds_use_ssc != bios_lvds_use_ssc) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"SSC %s by BIOS, overriding VBT which says %s\\n\",\n\t\t\t\t    enableddisabled(bios_lvds_use_ssc),\n\t\t\t\t    enableddisabled(dev_priv->vbt.lvds_use_ssc));\n\t\t\tdev_priv->vbt.lvds_use_ssc = bios_lvds_use_ssc;\n\t\t}\n\t}\n}\n\nstatic bool intel_panel_use_ssc(struct drm_i915_private *dev_priv)\n{\n\tif (dev_priv->params.panel_use_ssc >= 0)\n\t\treturn dev_priv->params.panel_use_ssc != 0;\n\treturn dev_priv->vbt.lvds_use_ssc\n\t\t&& !(dev_priv->quirks & QUIRK_LVDS_SSC_DISABLE);\n}\n\nstatic u32 pnv_dpll_compute_fp(struct dpll *dpll)\n{\n\treturn (1 << dpll->n) << 16 | dpll->m2;\n}\n\nstatic u32 i9xx_dpll_compute_fp(struct dpll *dpll)\n{\n\treturn dpll->n << 16 | dpll->m1 << 8 | dpll->m2;\n}\n\nstatic void i9xx_update_pll_dividers(struct intel_crtc *crtc,\n\t\t\t\t     struct intel_crtc_state *crtc_state,\n\t\t\t\t     struct dpll *reduced_clock)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 fp, fp2 = 0;\n\n\tif (IS_PINEVIEW(dev_priv)) {\n\t\tfp = pnv_dpll_compute_fp(&crtc_state->dpll);\n\t\tif (reduced_clock)\n\t\t\tfp2 = pnv_dpll_compute_fp(reduced_clock);\n\t} else {\n\t\tfp = i9xx_dpll_compute_fp(&crtc_state->dpll);\n\t\tif (reduced_clock)\n\t\t\tfp2 = i9xx_dpll_compute_fp(reduced_clock);\n\t}\n\n\tcrtc_state->dpll_hw_state.fp0 = fp;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS) &&\n\t    reduced_clock) {\n\t\tcrtc_state->dpll_hw_state.fp1 = fp2;\n\t} else {\n\t\tcrtc_state->dpll_hw_state.fp1 = fp;\n\t}\n}\n\nstatic void vlv_pllb_recal_opamp(struct drm_i915_private *dev_priv, enum pipe\n\t\tpipe)\n{\n\tu32 reg_val;\n\n\t/*\n\t * PLLB opamp always calibrates to max value of 0x3f, force enable it\n\t * and set it to a reasonable value instead.\n\t */\n\treg_val = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW9(1));\n\treg_val &= 0xffffff00;\n\treg_val |= 0x00000030;\n\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW9(1), reg_val);\n\n\treg_val = vlv_dpio_read(dev_priv, pipe, VLV_REF_DW13);\n\treg_val &= 0x00ffffff;\n\treg_val |= 0x8c000000;\n\tvlv_dpio_write(dev_priv, pipe, VLV_REF_DW13, reg_val);\n\n\treg_val = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW9(1));\n\treg_val &= 0xffffff00;\n\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW9(1), reg_val);\n\n\treg_val = vlv_dpio_read(dev_priv, pipe, VLV_REF_DW13);\n\treg_val &= 0x00ffffff;\n\treg_val |= 0xb0000000;\n\tvlv_dpio_write(dev_priv, pipe, VLV_REF_DW13, reg_val);\n}\n\nstatic void intel_pch_transcoder_set_m_n(const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t const struct intel_link_m_n *m_n)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tintel_de_write(dev_priv, PCH_TRANS_DATA_M1(pipe),\n\t\t       TU_SIZE(m_n->tu) | m_n->gmch_m);\n\tintel_de_write(dev_priv, PCH_TRANS_DATA_N1(pipe), m_n->gmch_n);\n\tintel_de_write(dev_priv, PCH_TRANS_LINK_M1(pipe), m_n->link_m);\n\tintel_de_write(dev_priv, PCH_TRANS_LINK_N1(pipe), m_n->link_n);\n}\n\nstatic bool transcoder_has_m2_n2(struct drm_i915_private *dev_priv,\n\t\t\t\t enum transcoder transcoder)\n{\n\tif (IS_HASWELL(dev_priv))\n\t\treturn transcoder == TRANSCODER_EDP;\n\n\t/*\n\t * Strictly speaking some registers are available before\n\t * gen7, but we only support DRRS on gen7+\n\t */\n\treturn IS_GEN(dev_priv, 7) || IS_CHERRYVIEW(dev_priv);\n}\n\nstatic void intel_cpu_transcoder_set_m_n(const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t const struct intel_link_m_n *m_n,\n\t\t\t\t\t const struct intel_link_m_n *m2_n2)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tenum transcoder transcoder = crtc_state->cpu_transcoder;\n\n\tif (INTEL_GEN(dev_priv) >= 5) {\n\t\tintel_de_write(dev_priv, PIPE_DATA_M1(transcoder),\n\t\t\t       TU_SIZE(m_n->tu) | m_n->gmch_m);\n\t\tintel_de_write(dev_priv, PIPE_DATA_N1(transcoder),\n\t\t\t       m_n->gmch_n);\n\t\tintel_de_write(dev_priv, PIPE_LINK_M1(transcoder),\n\t\t\t       m_n->link_m);\n\t\tintel_de_write(dev_priv, PIPE_LINK_N1(transcoder),\n\t\t\t       m_n->link_n);\n\t\t/*\n\t\t *  M2_N2 registers are set only if DRRS is supported\n\t\t * (to make sure the registers are not unnecessarily accessed).\n\t\t */\n\t\tif (m2_n2 && crtc_state->has_drrs &&\n\t\t    transcoder_has_m2_n2(dev_priv, transcoder)) {\n\t\t\tintel_de_write(dev_priv, PIPE_DATA_M2(transcoder),\n\t\t\t\t       TU_SIZE(m2_n2->tu) | m2_n2->gmch_m);\n\t\t\tintel_de_write(dev_priv, PIPE_DATA_N2(transcoder),\n\t\t\t\t       m2_n2->gmch_n);\n\t\t\tintel_de_write(dev_priv, PIPE_LINK_M2(transcoder),\n\t\t\t\t       m2_n2->link_m);\n\t\t\tintel_de_write(dev_priv, PIPE_LINK_N2(transcoder),\n\t\t\t\t       m2_n2->link_n);\n\t\t}\n\t} else {\n\t\tintel_de_write(dev_priv, PIPE_DATA_M_G4X(pipe),\n\t\t\t       TU_SIZE(m_n->tu) | m_n->gmch_m);\n\t\tintel_de_write(dev_priv, PIPE_DATA_N_G4X(pipe), m_n->gmch_n);\n\t\tintel_de_write(dev_priv, PIPE_LINK_M_G4X(pipe), m_n->link_m);\n\t\tintel_de_write(dev_priv, PIPE_LINK_N_G4X(pipe), m_n->link_n);\n\t}\n}\n\nvoid intel_dp_set_m_n(const struct intel_crtc_state *crtc_state, enum link_m_n_set m_n)\n{\n\tconst struct intel_link_m_n *dp_m_n, *dp_m2_n2 = NULL;\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\tif (m_n == M1_N1) {\n\t\tdp_m_n = &crtc_state->dp_m_n;\n\t\tdp_m2_n2 = &crtc_state->dp_m2_n2;\n\t} else if (m_n == M2_N2) {\n\n\t\t/*\n\t\t * M2_N2 registers are not supported. Hence m2_n2 divider value\n\t\t * needs to be programmed into M1_N1.\n\t\t */\n\t\tdp_m_n = &crtc_state->dp_m2_n2;\n\t} else {\n\t\tdrm_err(&i915->drm, \"Unsupported divider value\\n\");\n\t\treturn;\n\t}\n\n\tif (crtc_state->has_pch_encoder)\n\t\tintel_pch_transcoder_set_m_n(crtc_state, &crtc_state->dp_m_n);\n\telse\n\t\tintel_cpu_transcoder_set_m_n(crtc_state, dp_m_n, dp_m2_n2);\n}\n\nstatic void vlv_compute_dpll(struct intel_crtc *crtc,\n\t\t\t     struct intel_crtc_state *pipe_config)\n{\n\tpipe_config->dpll_hw_state.dpll = DPLL_INTEGRATED_REF_CLK_VLV |\n\t\tDPLL_REF_CLK_ENABLE_VLV | DPLL_VGA_MODE_DIS;\n\tif (crtc->pipe != PIPE_A)\n\t\tpipe_config->dpll_hw_state.dpll |= DPLL_INTEGRATED_CRI_CLK_VLV;\n\n\t/* DPLL not used with DSI, but still need the rest set up */\n\tif (!intel_crtc_has_type(pipe_config, INTEL_OUTPUT_DSI))\n\t\tpipe_config->dpll_hw_state.dpll |= DPLL_VCO_ENABLE |\n\t\t\tDPLL_EXT_BUFFER_ENABLE_VLV;\n\n\tpipe_config->dpll_hw_state.dpll_md =\n\t\t(pipe_config->pixel_multiplier - 1) << DPLL_MD_UDI_MULTIPLIER_SHIFT;\n}\n\nstatic void chv_compute_dpll(struct intel_crtc *crtc,\n\t\t\t     struct intel_crtc_state *pipe_config)\n{\n\tpipe_config->dpll_hw_state.dpll = DPLL_SSC_REF_CLK_CHV |\n\t\tDPLL_REF_CLK_ENABLE_VLV | DPLL_VGA_MODE_DIS;\n\tif (crtc->pipe != PIPE_A)\n\t\tpipe_config->dpll_hw_state.dpll |= DPLL_INTEGRATED_CRI_CLK_VLV;\n\n\t/* DPLL not used with DSI, but still need the rest set up */\n\tif (!intel_crtc_has_type(pipe_config, INTEL_OUTPUT_DSI))\n\t\tpipe_config->dpll_hw_state.dpll |= DPLL_VCO_ENABLE;\n\n\tpipe_config->dpll_hw_state.dpll_md =\n\t\t(pipe_config->pixel_multiplier - 1) << DPLL_MD_UDI_MULTIPLIER_SHIFT;\n}\n\nstatic void vlv_prepare_pll(struct intel_crtc *crtc,\n\t\t\t    const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum pipe pipe = crtc->pipe;\n\tu32 mdiv;\n\tu32 bestn, bestm1, bestm2, bestp1, bestp2;\n\tu32 coreclk, reg_val;\n\n\t/* Enable Refclk */\n\tintel_de_write(dev_priv, DPLL(pipe),\n\t\t       pipe_config->dpll_hw_state.dpll & ~(DPLL_VCO_ENABLE | DPLL_EXT_BUFFER_ENABLE_VLV));\n\n\t/* No need to actually set up the DPLL with DSI */\n\tif ((pipe_config->dpll_hw_state.dpll & DPLL_VCO_ENABLE) == 0)\n\t\treturn;\n\n\tvlv_dpio_get(dev_priv);\n\n\tbestn = pipe_config->dpll.n;\n\tbestm1 = pipe_config->dpll.m1;\n\tbestm2 = pipe_config->dpll.m2;\n\tbestp1 = pipe_config->dpll.p1;\n\tbestp2 = pipe_config->dpll.p2;\n\n\t/* See eDP HDMI DPIO driver vbios notes doc */\n\n\t/* PLL B needs special handling */\n\tif (pipe == PIPE_B)\n\t\tvlv_pllb_recal_opamp(dev_priv, pipe);\n\n\t/* Set up Tx target for periodic Rcomp update */\n\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW9_BCAST, 0x0100000f);\n\n\t/* Disable target IRef on PLL */\n\treg_val = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW8(pipe));\n\treg_val &= 0x00ffffff;\n\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW8(pipe), reg_val);\n\n\t/* Disable fast lock */\n\tvlv_dpio_write(dev_priv, pipe, VLV_CMN_DW0, 0x610);\n\n\t/* Set idtafcrecal before PLL is enabled */\n\tmdiv = ((bestm1 << DPIO_M1DIV_SHIFT) | (bestm2 & DPIO_M2DIV_MASK));\n\tmdiv |= ((bestp1 << DPIO_P1_SHIFT) | (bestp2 << DPIO_P2_SHIFT));\n\tmdiv |= ((bestn << DPIO_N_SHIFT));\n\tmdiv |= (1 << DPIO_K_SHIFT);\n\n\t/*\n\t * Post divider depends on pixel clock rate, DAC vs digital (and LVDS,\n\t * but we don't support that).\n\t * Note: don't use the DAC post divider as it seems unstable.\n\t */\n\tmdiv |= (DPIO_POST_DIV_HDMIDP << DPIO_POST_DIV_SHIFT);\n\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW3(pipe), mdiv);\n\n\tmdiv |= DPIO_ENABLE_CALIBRATION;\n\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW3(pipe), mdiv);\n\n\t/* Set HBR and RBR LPF coefficients */\n\tif (pipe_config->port_clock == 162000 ||\n\t    intel_crtc_has_type(pipe_config, INTEL_OUTPUT_ANALOG) ||\n\t    intel_crtc_has_type(pipe_config, INTEL_OUTPUT_HDMI))\n\t\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW10(pipe),\n\t\t\t\t 0x009f0003);\n\telse\n\t\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW10(pipe),\n\t\t\t\t 0x00d0000f);\n\n\tif (intel_crtc_has_dp_encoder(pipe_config)) {\n\t\t/* Use SSC source */\n\t\tif (pipe == PIPE_A)\n\t\t\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),\n\t\t\t\t\t 0x0df40000);\n\t\telse\n\t\t\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),\n\t\t\t\t\t 0x0df70000);\n\t} else { /* HDMI or VGA */\n\t\t/* Use bend source */\n\t\tif (pipe == PIPE_A)\n\t\t\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),\n\t\t\t\t\t 0x0df70000);\n\t\telse\n\t\t\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),\n\t\t\t\t\t 0x0df40000);\n\t}\n\n\tcoreclk = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW7(pipe));\n\tcoreclk = (coreclk & 0x0000ff00) | 0x01c00000;\n\tif (intel_crtc_has_dp_encoder(pipe_config))\n\t\tcoreclk |= 0x01000000;\n\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW7(pipe), coreclk);\n\n\tvlv_dpio_write(dev_priv, pipe, VLV_PLL_DW11(pipe), 0x87871000);\n\n\tvlv_dpio_put(dev_priv);\n}\n\nstatic void chv_prepare_pll(struct intel_crtc *crtc,\n\t\t\t    const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum pipe pipe = crtc->pipe;\n\tenum dpio_channel port = vlv_pipe_to_channel(pipe);\n\tu32 loopfilter, tribuf_calcntr;\n\tu32 bestn, bestm1, bestm2, bestp1, bestp2, bestm2_frac;\n\tu32 dpio_val;\n\tint vco;\n\n\t/* Enable Refclk and SSC */\n\tintel_de_write(dev_priv, DPLL(pipe),\n\t\t       pipe_config->dpll_hw_state.dpll & ~DPLL_VCO_ENABLE);\n\n\t/* No need to actually set up the DPLL with DSI */\n\tif ((pipe_config->dpll_hw_state.dpll & DPLL_VCO_ENABLE) == 0)\n\t\treturn;\n\n\tbestn = pipe_config->dpll.n;\n\tbestm2_frac = pipe_config->dpll.m2 & 0x3fffff;\n\tbestm1 = pipe_config->dpll.m1;\n\tbestm2 = pipe_config->dpll.m2 >> 22;\n\tbestp1 = pipe_config->dpll.p1;\n\tbestp2 = pipe_config->dpll.p2;\n\tvco = pipe_config->dpll.vco;\n\tdpio_val = 0;\n\tloopfilter = 0;\n\n\tvlv_dpio_get(dev_priv);\n\n\t/* p1 and p2 divider */\n\tvlv_dpio_write(dev_priv, pipe, CHV_CMN_DW13(port),\n\t\t\t5 << DPIO_CHV_S1_DIV_SHIFT |\n\t\t\tbestp1 << DPIO_CHV_P1_DIV_SHIFT |\n\t\t\tbestp2 << DPIO_CHV_P2_DIV_SHIFT |\n\t\t\t1 << DPIO_CHV_K_DIV_SHIFT);\n\n\t/* Feedback post-divider - m2 */\n\tvlv_dpio_write(dev_priv, pipe, CHV_PLL_DW0(port), bestm2);\n\n\t/* Feedback refclk divider - n and m1 */\n\tvlv_dpio_write(dev_priv, pipe, CHV_PLL_DW1(port),\n\t\t\tDPIO_CHV_M1_DIV_BY_2 |\n\t\t\t1 << DPIO_CHV_N_DIV_SHIFT);\n\n\t/* M2 fraction division */\n\tvlv_dpio_write(dev_priv, pipe, CHV_PLL_DW2(port), bestm2_frac);\n\n\t/* M2 fraction division enable */\n\tdpio_val = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW3(port));\n\tdpio_val &= ~(DPIO_CHV_FEEDFWD_GAIN_MASK | DPIO_CHV_FRAC_DIV_EN);\n\tdpio_val |= (2 << DPIO_CHV_FEEDFWD_GAIN_SHIFT);\n\tif (bestm2_frac)\n\t\tdpio_val |= DPIO_CHV_FRAC_DIV_EN;\n\tvlv_dpio_write(dev_priv, pipe, CHV_PLL_DW3(port), dpio_val);\n\n\t/* Program digital lock detect threshold */\n\tdpio_val = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW9(port));\n\tdpio_val &= ~(DPIO_CHV_INT_LOCK_THRESHOLD_MASK |\n\t\t\t\t\tDPIO_CHV_INT_LOCK_THRESHOLD_SEL_COARSE);\n\tdpio_val |= (0x5 << DPIO_CHV_INT_LOCK_THRESHOLD_SHIFT);\n\tif (!bestm2_frac)\n\t\tdpio_val |= DPIO_CHV_INT_LOCK_THRESHOLD_SEL_COARSE;\n\tvlv_dpio_write(dev_priv, pipe, CHV_PLL_DW9(port), dpio_val);\n\n\t/* Loop filter */\n\tif (vco == 5400000) {\n\t\tloopfilter |= (0x3 << DPIO_CHV_PROP_COEFF_SHIFT);\n\t\tloopfilter |= (0x8 << DPIO_CHV_INT_COEFF_SHIFT);\n\t\tloopfilter |= (0x1 << DPIO_CHV_GAIN_CTRL_SHIFT);\n\t\ttribuf_calcntr = 0x9;\n\t} else if (vco <= 6200000) {\n\t\tloopfilter |= (0x5 << DPIO_CHV_PROP_COEFF_SHIFT);\n\t\tloopfilter |= (0xB << DPIO_CHV_INT_COEFF_SHIFT);\n\t\tloopfilter |= (0x3 << DPIO_CHV_GAIN_CTRL_SHIFT);\n\t\ttribuf_calcntr = 0x9;\n\t} else if (vco <= 6480000) {\n\t\tloopfilter |= (0x4 << DPIO_CHV_PROP_COEFF_SHIFT);\n\t\tloopfilter |= (0x9 << DPIO_CHV_INT_COEFF_SHIFT);\n\t\tloopfilter |= (0x3 << DPIO_CHV_GAIN_CTRL_SHIFT);\n\t\ttribuf_calcntr = 0x8;\n\t} else {\n\t\t/* Not supported. Apply the same limits as in the max case */\n\t\tloopfilter |= (0x4 << DPIO_CHV_PROP_COEFF_SHIFT);\n\t\tloopfilter |= (0x9 << DPIO_CHV_INT_COEFF_SHIFT);\n\t\tloopfilter |= (0x3 << DPIO_CHV_GAIN_CTRL_SHIFT);\n\t\ttribuf_calcntr = 0;\n\t}\n\tvlv_dpio_write(dev_priv, pipe, CHV_PLL_DW6(port), loopfilter);\n\n\tdpio_val = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW8(port));\n\tdpio_val &= ~DPIO_CHV_TDC_TARGET_CNT_MASK;\n\tdpio_val |= (tribuf_calcntr << DPIO_CHV_TDC_TARGET_CNT_SHIFT);\n\tvlv_dpio_write(dev_priv, pipe, CHV_PLL_DW8(port), dpio_val);\n\n\t/* AFC Recal */\n\tvlv_dpio_write(dev_priv, pipe, CHV_CMN_DW14(port),\n\t\t\tvlv_dpio_read(dev_priv, pipe, CHV_CMN_DW14(port)) |\n\t\t\tDPIO_AFC_RECAL);\n\n\tvlv_dpio_put(dev_priv);\n}\n\n/**\n * vlv_force_pll_on - forcibly enable just the PLL\n * @dev_priv: i915 private structure\n * @pipe: pipe PLL to enable\n * @dpll: PLL configuration\n *\n * Enable the PLL for @pipe using the supplied @dpll config. To be used\n * in cases where we need the PLL enabled even when @pipe is not going to\n * be enabled.\n */\nint vlv_force_pll_on(struct drm_i915_private *dev_priv, enum pipe pipe,\n\t\t     const struct dpll *dpll)\n{\n\tstruct intel_crtc *crtc = intel_get_crtc_for_pipe(dev_priv, pipe);\n\tstruct intel_crtc_state *pipe_config;\n\n\tpipe_config = intel_crtc_state_alloc(crtc);\n\tif (!pipe_config)\n\t\treturn -ENOMEM;\n\n\tpipe_config->cpu_transcoder = (enum transcoder)pipe;\n\tpipe_config->pixel_multiplier = 1;\n\tpipe_config->dpll = *dpll;\n\n\tif (IS_CHERRYVIEW(dev_priv)) {\n\t\tchv_compute_dpll(crtc, pipe_config);\n\t\tchv_prepare_pll(crtc, pipe_config);\n\t\tchv_enable_pll(crtc, pipe_config);\n\t} else {\n\t\tvlv_compute_dpll(crtc, pipe_config);\n\t\tvlv_prepare_pll(crtc, pipe_config);\n\t\tvlv_enable_pll(crtc, pipe_config);\n\t}\n\n\tkfree(pipe_config);\n\n\treturn 0;\n}\n\n/**\n * vlv_force_pll_off - forcibly disable just the PLL\n * @dev_priv: i915 private structure\n * @pipe: pipe PLL to disable\n *\n * Disable the PLL for @pipe. To be used in cases where we need\n * the PLL enabled even when @pipe is not going to be enabled.\n */\nvoid vlv_force_pll_off(struct drm_i915_private *dev_priv, enum pipe pipe)\n{\n\tif (IS_CHERRYVIEW(dev_priv))\n\t\tchv_disable_pll(dev_priv, pipe);\n\telse\n\t\tvlv_disable_pll(dev_priv, pipe);\n}\n\nstatic void i9xx_compute_dpll(struct intel_crtc *crtc,\n\t\t\t      struct intel_crtc_state *crtc_state,\n\t\t\t      struct dpll *reduced_clock)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 dpll;\n\tstruct dpll *clock = &crtc_state->dpll;\n\n\ti9xx_update_pll_dividers(crtc, crtc_state, reduced_clock);\n\n\tdpll = DPLL_VGA_MODE_DIS;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS))\n\t\tdpll |= DPLLB_MODE_LVDS;\n\telse\n\t\tdpll |= DPLLB_MODE_DAC_SERIAL;\n\n\tif (IS_I945G(dev_priv) || IS_I945GM(dev_priv) ||\n\t    IS_G33(dev_priv) || IS_PINEVIEW(dev_priv)) {\n\t\tdpll |= (crtc_state->pixel_multiplier - 1)\n\t\t\t<< SDVO_MULTIPLIER_SHIFT_HIRES;\n\t}\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_SDVO) ||\n\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))\n\t\tdpll |= DPLL_SDVO_HIGH_SPEED;\n\n\tif (intel_crtc_has_dp_encoder(crtc_state))\n\t\tdpll |= DPLL_SDVO_HIGH_SPEED;\n\n\t/* compute bitmask from p1 value */\n\tif (IS_PINEVIEW(dev_priv))\n\t\tdpll |= (1 << (clock->p1 - 1)) << DPLL_FPA01_P1_POST_DIV_SHIFT_PINEVIEW;\n\telse {\n\t\tdpll |= (1 << (clock->p1 - 1)) << DPLL_FPA01_P1_POST_DIV_SHIFT;\n\t\tif (IS_G4X(dev_priv) && reduced_clock)\n\t\t\tdpll |= (1 << (reduced_clock->p1 - 1)) << DPLL_FPA1_P1_POST_DIV_SHIFT;\n\t}\n\tswitch (clock->p2) {\n\tcase 5:\n\t\tdpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_5;\n\t\tbreak;\n\tcase 7:\n\t\tdpll |= DPLLB_LVDS_P2_CLOCK_DIV_7;\n\t\tbreak;\n\tcase 10:\n\t\tdpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_10;\n\t\tbreak;\n\tcase 14:\n\t\tdpll |= DPLLB_LVDS_P2_CLOCK_DIV_14;\n\t\tbreak;\n\t}\n\tif (INTEL_GEN(dev_priv) >= 4)\n\t\tdpll |= (6 << PLL_LOAD_PULSE_PHASE_SHIFT);\n\n\tif (crtc_state->sdvo_tv_clock)\n\t\tdpll |= PLL_REF_INPUT_TVCLKINBC;\n\telse if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS) &&\n\t\t intel_panel_use_ssc(dev_priv))\n\t\tdpll |= PLLB_REF_INPUT_SPREADSPECTRUMIN;\n\telse\n\t\tdpll |= PLL_REF_INPUT_DREFCLK;\n\n\tdpll |= DPLL_VCO_ENABLE;\n\tcrtc_state->dpll_hw_state.dpll = dpll;\n\n\tif (INTEL_GEN(dev_priv) >= 4) {\n\t\tu32 dpll_md = (crtc_state->pixel_multiplier - 1)\n\t\t\t<< DPLL_MD_UDI_MULTIPLIER_SHIFT;\n\t\tcrtc_state->dpll_hw_state.dpll_md = dpll_md;\n\t}\n}\n\nstatic void i8xx_compute_dpll(struct intel_crtc *crtc,\n\t\t\t      struct intel_crtc_state *crtc_state,\n\t\t\t      struct dpll *reduced_clock)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tu32 dpll;\n\tstruct dpll *clock = &crtc_state->dpll;\n\n\ti9xx_update_pll_dividers(crtc, crtc_state, reduced_clock);\n\n\tdpll = DPLL_VGA_MODE_DIS;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS)) {\n\t\tdpll |= (1 << (clock->p1 - 1)) << DPLL_FPA01_P1_POST_DIV_SHIFT;\n\t} else {\n\t\tif (clock->p1 == 2)\n\t\t\tdpll |= PLL_P1_DIVIDE_BY_TWO;\n\t\telse\n\t\t\tdpll |= (clock->p1 - 2) << DPLL_FPA01_P1_POST_DIV_SHIFT;\n\t\tif (clock->p2 == 4)\n\t\t\tdpll |= PLL_P2_DIVIDE_BY_4;\n\t}\n\n\t/*\n\t * Bspec:\n\t * \"[Almador Errata}: For the correct operation of the muxed DVO pins\n\t *  (GDEVSELB/I2Cdata, GIRDBY/I2CClk) and (GFRAMEB/DVI_Data,\n\t *  GTRDYB/DVI_Clk): Bit 31 (DPLL VCO Enable) and Bit 30 (2X Clock\n\t *  Enable) must be set to \u201c1\u201d in both the DPLL A Control Register\n\t *  (06014h-06017h) and DPLL B Control Register (06018h-0601Bh).\"\n\t *\n\t * For simplicity We simply keep both bits always enabled in\n\t * both DPLLS. The spec says we should disable the DVO 2X clock\n\t * when not needed, but this seems to work fine in practice.\n\t */\n\tif (IS_I830(dev_priv) ||\n\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DVO))\n\t\tdpll |= DPLL_DVO_2X_MODE;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS) &&\n\t    intel_panel_use_ssc(dev_priv))\n\t\tdpll |= PLLB_REF_INPUT_SPREADSPECTRUMIN;\n\telse\n\t\tdpll |= PLL_REF_INPUT_DREFCLK;\n\n\tdpll |= DPLL_VCO_ENABLE;\n\tcrtc_state->dpll_hw_state.dpll = dpll;\n}\n\nstatic void intel_set_pipe_timings(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tconst struct drm_display_mode *adjusted_mode = &crtc_state->hw.adjusted_mode;\n\tu32 crtc_vtotal, crtc_vblank_end;\n\tint vsyncshift = 0;\n\n\t/* We need to be careful not to changed the adjusted mode, for otherwise\n\t * the hw state checker will get angry at the mismatch. */\n\tcrtc_vtotal = adjusted_mode->crtc_vtotal;\n\tcrtc_vblank_end = adjusted_mode->crtc_vblank_end;\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\t/* the chip adds 2 halflines automatically */\n\t\tcrtc_vtotal -= 1;\n\t\tcrtc_vblank_end -= 1;\n\n\t\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_SDVO))\n\t\t\tvsyncshift = (adjusted_mode->crtc_htotal - 1) / 2;\n\t\telse\n\t\t\tvsyncshift = adjusted_mode->crtc_hsync_start -\n\t\t\t\tadjusted_mode->crtc_htotal / 2;\n\t\tif (vsyncshift < 0)\n\t\t\tvsyncshift += adjusted_mode->crtc_htotal;\n\t}\n\n\tif (INTEL_GEN(dev_priv) > 3)\n\t\tintel_de_write(dev_priv, VSYNCSHIFT(cpu_transcoder),\n\t\t               vsyncshift);\n\n\tintel_de_write(dev_priv, HTOTAL(cpu_transcoder),\n\t\t       (adjusted_mode->crtc_hdisplay - 1) | ((adjusted_mode->crtc_htotal - 1) << 16));\n\tintel_de_write(dev_priv, HBLANK(cpu_transcoder),\n\t\t       (adjusted_mode->crtc_hblank_start - 1) | ((adjusted_mode->crtc_hblank_end - 1) << 16));\n\tintel_de_write(dev_priv, HSYNC(cpu_transcoder),\n\t\t       (adjusted_mode->crtc_hsync_start - 1) | ((adjusted_mode->crtc_hsync_end - 1) << 16));\n\n\tintel_de_write(dev_priv, VTOTAL(cpu_transcoder),\n\t\t       (adjusted_mode->crtc_vdisplay - 1) | ((crtc_vtotal - 1) << 16));\n\tintel_de_write(dev_priv, VBLANK(cpu_transcoder),\n\t\t       (adjusted_mode->crtc_vblank_start - 1) | ((crtc_vblank_end - 1) << 16));\n\tintel_de_write(dev_priv, VSYNC(cpu_transcoder),\n\t\t       (adjusted_mode->crtc_vsync_start - 1) | ((adjusted_mode->crtc_vsync_end - 1) << 16));\n\n\t/* Workaround: when the EDP input selection is B, the VTOTAL_B must be\n\t * programmed with the VTOTAL_EDP value. Same for VTOTAL_C. This is\n\t * documented on the DDI_FUNC_CTL register description, EDP Input Select\n\t * bits. */\n\tif (IS_HASWELL(dev_priv) && cpu_transcoder == TRANSCODER_EDP &&\n\t    (pipe == PIPE_B || pipe == PIPE_C))\n\t\tintel_de_write(dev_priv, VTOTAL(pipe),\n\t\t               intel_de_read(dev_priv, VTOTAL(cpu_transcoder)));\n\n}\n\nstatic void intel_set_pipe_src_size(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\t/* pipesrc controls the size that is scaled from, which should\n\t * always be the user's requested size.\n\t */\n\tintel_de_write(dev_priv, PIPESRC(pipe),\n\t\t       ((crtc_state->pipe_src_w - 1) << 16) | (crtc_state->pipe_src_h - 1));\n}\n\nstatic bool intel_pipe_is_interlaced(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\n\tif (IS_GEN(dev_priv, 2))\n\t\treturn false;\n\n\tif (INTEL_GEN(dev_priv) >= 9 ||\n\t    IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))\n\t\treturn intel_de_read(dev_priv, PIPECONF(cpu_transcoder)) & PIPECONF_INTERLACE_MASK_HSW;\n\telse\n\t\treturn intel_de_read(dev_priv, PIPECONF(cpu_transcoder)) & PIPECONF_INTERLACE_MASK;\n}\n\nstatic void intel_get_pipe_timings(struct intel_crtc *crtc,\n\t\t\t\t   struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum transcoder cpu_transcoder = pipe_config->cpu_transcoder;\n\tu32 tmp;\n\n\ttmp = intel_de_read(dev_priv, HTOTAL(cpu_transcoder));\n\tpipe_config->hw.adjusted_mode.crtc_hdisplay = (tmp & 0xffff) + 1;\n\tpipe_config->hw.adjusted_mode.crtc_htotal = ((tmp >> 16) & 0xffff) + 1;\n\n\tif (!transcoder_is_dsi(cpu_transcoder)) {\n\t\ttmp = intel_de_read(dev_priv, HBLANK(cpu_transcoder));\n\t\tpipe_config->hw.adjusted_mode.crtc_hblank_start =\n\t\t\t\t\t\t\t(tmp & 0xffff) + 1;\n\t\tpipe_config->hw.adjusted_mode.crtc_hblank_end =\n\t\t\t\t\t\t((tmp >> 16) & 0xffff) + 1;\n\t}\n\ttmp = intel_de_read(dev_priv, HSYNC(cpu_transcoder));\n\tpipe_config->hw.adjusted_mode.crtc_hsync_start = (tmp & 0xffff) + 1;\n\tpipe_config->hw.adjusted_mode.crtc_hsync_end = ((tmp >> 16) & 0xffff) + 1;\n\n\ttmp = intel_de_read(dev_priv, VTOTAL(cpu_transcoder));\n\tpipe_config->hw.adjusted_mode.crtc_vdisplay = (tmp & 0xffff) + 1;\n\tpipe_config->hw.adjusted_mode.crtc_vtotal = ((tmp >> 16) & 0xffff) + 1;\n\n\tif (!transcoder_is_dsi(cpu_transcoder)) {\n\t\ttmp = intel_de_read(dev_priv, VBLANK(cpu_transcoder));\n\t\tpipe_config->hw.adjusted_mode.crtc_vblank_start =\n\t\t\t\t\t\t\t(tmp & 0xffff) + 1;\n\t\tpipe_config->hw.adjusted_mode.crtc_vblank_end =\n\t\t\t\t\t\t((tmp >> 16) & 0xffff) + 1;\n\t}\n\ttmp = intel_de_read(dev_priv, VSYNC(cpu_transcoder));\n\tpipe_config->hw.adjusted_mode.crtc_vsync_start = (tmp & 0xffff) + 1;\n\tpipe_config->hw.adjusted_mode.crtc_vsync_end = ((tmp >> 16) & 0xffff) + 1;\n\n\tif (intel_pipe_is_interlaced(pipe_config)) {\n\t\tpipe_config->hw.adjusted_mode.flags |= DRM_MODE_FLAG_INTERLACE;\n\t\tpipe_config->hw.adjusted_mode.crtc_vtotal += 1;\n\t\tpipe_config->hw.adjusted_mode.crtc_vblank_end += 1;\n\t}\n}\n\nstatic void intel_get_pipe_src_size(struct intel_crtc *crtc,\n\t\t\t\t    struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tu32 tmp;\n\n\ttmp = intel_de_read(dev_priv, PIPESRC(crtc->pipe));\n\tpipe_config->pipe_src_h = (tmp & 0xffff) + 1;\n\tpipe_config->pipe_src_w = ((tmp >> 16) & 0xffff) + 1;\n\n\tpipe_config->hw.mode.vdisplay = pipe_config->pipe_src_h;\n\tpipe_config->hw.mode.hdisplay = pipe_config->pipe_src_w;\n}\n\nvoid intel_mode_from_pipe_config(struct drm_display_mode *mode,\n\t\t\t\t struct intel_crtc_state *pipe_config)\n{\n\tmode->hdisplay = pipe_config->hw.adjusted_mode.crtc_hdisplay;\n\tmode->htotal = pipe_config->hw.adjusted_mode.crtc_htotal;\n\tmode->hsync_start = pipe_config->hw.adjusted_mode.crtc_hsync_start;\n\tmode->hsync_end = pipe_config->hw.adjusted_mode.crtc_hsync_end;\n\n\tmode->vdisplay = pipe_config->hw.adjusted_mode.crtc_vdisplay;\n\tmode->vtotal = pipe_config->hw.adjusted_mode.crtc_vtotal;\n\tmode->vsync_start = pipe_config->hw.adjusted_mode.crtc_vsync_start;\n\tmode->vsync_end = pipe_config->hw.adjusted_mode.crtc_vsync_end;\n\n\tmode->flags = pipe_config->hw.adjusted_mode.flags;\n\tmode->type = DRM_MODE_TYPE_DRIVER;\n\n\tmode->clock = pipe_config->hw.adjusted_mode.crtc_clock;\n\n\tdrm_mode_set_name(mode);\n}\n\nstatic void i9xx_set_pipeconf(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 pipeconf;\n\n\tpipeconf = 0;\n\n\t/* we keep both pipes enabled on 830 */\n\tif (IS_I830(dev_priv))\n\t\tpipeconf |= intel_de_read(dev_priv, PIPECONF(crtc->pipe)) & PIPECONF_ENABLE;\n\n\tif (crtc_state->double_wide)\n\t\tpipeconf |= PIPECONF_DOUBLE_WIDE;\n\n\t/* only g4x and later have fancy bpc/dither controls */\n\tif (IS_G4X(dev_priv) || IS_VALLEYVIEW(dev_priv) ||\n\t    IS_CHERRYVIEW(dev_priv)) {\n\t\t/* Bspec claims that we can't use dithering for 30bpp pipes. */\n\t\tif (crtc_state->dither && crtc_state->pipe_bpp != 30)\n\t\t\tpipeconf |= PIPECONF_DITHER_EN |\n\t\t\t\t    PIPECONF_DITHER_TYPE_SP;\n\n\t\tswitch (crtc_state->pipe_bpp) {\n\t\tcase 18:\n\t\t\tpipeconf |= PIPECONF_6BPC;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tpipeconf |= PIPECONF_8BPC;\n\t\t\tbreak;\n\t\tcase 30:\n\t\t\tpipeconf |= PIPECONF_10BPC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Case prevented by intel_choose_pipe_bpp_dither. */\n\t\t\tBUG();\n\t\t}\n\t}\n\n\tif (crtc_state->hw.adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tif (INTEL_GEN(dev_priv) < 4 ||\n\t\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_SDVO))\n\t\t\tpipeconf |= PIPECONF_INTERLACE_W_FIELD_INDICATION;\n\t\telse\n\t\t\tpipeconf |= PIPECONF_INTERLACE_W_SYNC_SHIFT;\n\t} else {\n\t\tpipeconf |= PIPECONF_PROGRESSIVE;\n\t}\n\n\tif ((IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) &&\n\t     crtc_state->limited_color_range)\n\t\tpipeconf |= PIPECONF_COLOR_RANGE_SELECT;\n\n\tpipeconf |= PIPECONF_GAMMA_MODE(crtc_state->gamma_mode);\n\n\tpipeconf |= PIPECONF_FRAME_START_DELAY(0);\n\n\tintel_de_write(dev_priv, PIPECONF(crtc->pipe), pipeconf);\n\tintel_de_posting_read(dev_priv, PIPECONF(crtc->pipe));\n}\n\nstatic int i8xx_crtc_compute_clock(struct intel_crtc *crtc,\n\t\t\t\t   struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tconst struct intel_limit *limit;\n\tint refclk = 48000;\n\n\tmemset(&crtc_state->dpll_hw_state, 0,\n\t       sizeof(crtc_state->dpll_hw_state));\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS)) {\n\t\tif (intel_panel_use_ssc(dev_priv)) {\n\t\t\trefclk = dev_priv->vbt.lvds_ssc_freq;\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"using SSC reference clock of %d kHz\\n\",\n\t\t\t\t    refclk);\n\t\t}\n\n\t\tlimit = &intel_limits_i8xx_lvds;\n\t} else if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DVO)) {\n\t\tlimit = &intel_limits_i8xx_dvo;\n\t} else {\n\t\tlimit = &intel_limits_i8xx_dac;\n\t}\n\n\tif (!crtc_state->clock_set &&\n\t    !i9xx_find_best_dpll(limit, crtc_state, crtc_state->port_clock,\n\t\t\t\t refclk, NULL, &crtc_state->dpll)) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Couldn't find PLL settings for mode!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ti8xx_compute_dpll(crtc, crtc_state, NULL);\n\n\treturn 0;\n}\n\nstatic int g4x_crtc_compute_clock(struct intel_crtc *crtc,\n\t\t\t\t  struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct intel_limit *limit;\n\tint refclk = 96000;\n\n\tmemset(&crtc_state->dpll_hw_state, 0,\n\t       sizeof(crtc_state->dpll_hw_state));\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS)) {\n\t\tif (intel_panel_use_ssc(dev_priv)) {\n\t\t\trefclk = dev_priv->vbt.lvds_ssc_freq;\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"using SSC reference clock of %d kHz\\n\",\n\t\t\t\t    refclk);\n\t\t}\n\n\t\tif (intel_is_dual_link_lvds(dev_priv))\n\t\t\tlimit = &intel_limits_g4x_dual_channel_lvds;\n\t\telse\n\t\t\tlimit = &intel_limits_g4x_single_channel_lvds;\n\t} else if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI) ||\n\t\t   intel_crtc_has_type(crtc_state, INTEL_OUTPUT_ANALOG)) {\n\t\tlimit = &intel_limits_g4x_hdmi;\n\t} else if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_SDVO)) {\n\t\tlimit = &intel_limits_g4x_sdvo;\n\t} else {\n\t\t/* The option is for other outputs */\n\t\tlimit = &intel_limits_i9xx_sdvo;\n\t}\n\n\tif (!crtc_state->clock_set &&\n\t    !g4x_find_best_dpll(limit, crtc_state, crtc_state->port_clock,\n\t\t\t\trefclk, NULL, &crtc_state->dpll)) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Couldn't find PLL settings for mode!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ti9xx_compute_dpll(crtc, crtc_state, NULL);\n\n\treturn 0;\n}\n\nstatic int pnv_crtc_compute_clock(struct intel_crtc *crtc,\n\t\t\t\t  struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tconst struct intel_limit *limit;\n\tint refclk = 96000;\n\n\tmemset(&crtc_state->dpll_hw_state, 0,\n\t       sizeof(crtc_state->dpll_hw_state));\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS)) {\n\t\tif (intel_panel_use_ssc(dev_priv)) {\n\t\t\trefclk = dev_priv->vbt.lvds_ssc_freq;\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"using SSC reference clock of %d kHz\\n\",\n\t\t\t\t    refclk);\n\t\t}\n\n\t\tlimit = &pnv_limits_lvds;\n\t} else {\n\t\tlimit = &pnv_limits_sdvo;\n\t}\n\n\tif (!crtc_state->clock_set &&\n\t    !pnv_find_best_dpll(limit, crtc_state, crtc_state->port_clock,\n\t\t\t\trefclk, NULL, &crtc_state->dpll)) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Couldn't find PLL settings for mode!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ti9xx_compute_dpll(crtc, crtc_state, NULL);\n\n\treturn 0;\n}\n\nstatic int i9xx_crtc_compute_clock(struct intel_crtc *crtc,\n\t\t\t\t   struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tconst struct intel_limit *limit;\n\tint refclk = 96000;\n\n\tmemset(&crtc_state->dpll_hw_state, 0,\n\t       sizeof(crtc_state->dpll_hw_state));\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS)) {\n\t\tif (intel_panel_use_ssc(dev_priv)) {\n\t\t\trefclk = dev_priv->vbt.lvds_ssc_freq;\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"using SSC reference clock of %d kHz\\n\",\n\t\t\t\t    refclk);\n\t\t}\n\n\t\tlimit = &intel_limits_i9xx_lvds;\n\t} else {\n\t\tlimit = &intel_limits_i9xx_sdvo;\n\t}\n\n\tif (!crtc_state->clock_set &&\n\t    !i9xx_find_best_dpll(limit, crtc_state, crtc_state->port_clock,\n\t\t\t\t refclk, NULL, &crtc_state->dpll)) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Couldn't find PLL settings for mode!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ti9xx_compute_dpll(crtc, crtc_state, NULL);\n\n\treturn 0;\n}\n\nstatic int chv_crtc_compute_clock(struct intel_crtc *crtc,\n\t\t\t\t  struct intel_crtc_state *crtc_state)\n{\n\tint refclk = 100000;\n\tconst struct intel_limit *limit = &intel_limits_chv;\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\tmemset(&crtc_state->dpll_hw_state, 0,\n\t       sizeof(crtc_state->dpll_hw_state));\n\n\tif (!crtc_state->clock_set &&\n\t    !chv_find_best_dpll(limit, crtc_state, crtc_state->port_clock,\n\t\t\t\trefclk, NULL, &crtc_state->dpll)) {\n\t\tdrm_err(&i915->drm, \"Couldn't find PLL settings for mode!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchv_compute_dpll(crtc, crtc_state);\n\n\treturn 0;\n}\n\nstatic int vlv_crtc_compute_clock(struct intel_crtc *crtc,\n\t\t\t\t  struct intel_crtc_state *crtc_state)\n{\n\tint refclk = 100000;\n\tconst struct intel_limit *limit = &intel_limits_vlv;\n\tstruct drm_i915_private *i915 = to_i915(crtc_state->uapi.crtc->dev);\n\n\tmemset(&crtc_state->dpll_hw_state, 0,\n\t       sizeof(crtc_state->dpll_hw_state));\n\n\tif (!crtc_state->clock_set &&\n\t    !vlv_find_best_dpll(limit, crtc_state, crtc_state->port_clock,\n\t\t\t\trefclk, NULL, &crtc_state->dpll)) {\n\t\tdrm_err(&i915->drm,  \"Couldn't find PLL settings for mode!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvlv_compute_dpll(crtc, crtc_state);\n\n\treturn 0;\n}\n\nstatic bool i9xx_has_pfit(struct drm_i915_private *dev_priv)\n{\n\tif (IS_I830(dev_priv))\n\t\treturn false;\n\n\treturn INTEL_GEN(dev_priv) >= 4 ||\n\t\tIS_PINEVIEW(dev_priv) || IS_MOBILE(dev_priv);\n}\n\nstatic void i9xx_get_pfit_config(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 tmp;\n\n\tif (!i9xx_has_pfit(dev_priv))\n\t\treturn;\n\n\ttmp = intel_de_read(dev_priv, PFIT_CONTROL);\n\tif (!(tmp & PFIT_ENABLE))\n\t\treturn;\n\n\t/* Check whether the pfit is attached to our pipe. */\n\tif (INTEL_GEN(dev_priv) < 4) {\n\t\tif (crtc->pipe != PIPE_B)\n\t\t\treturn;\n\t} else {\n\t\tif ((tmp & PFIT_PIPE_MASK) != (crtc->pipe << PFIT_PIPE_SHIFT))\n\t\t\treturn;\n\t}\n\n\tcrtc_state->gmch_pfit.control = tmp;\n\tcrtc_state->gmch_pfit.pgm_ratios =\n\t\tintel_de_read(dev_priv, PFIT_PGM_RATIOS);\n}\n\nstatic void vlv_crtc_clock_get(struct intel_crtc *crtc,\n\t\t\t       struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum pipe pipe = crtc->pipe;\n\tstruct dpll clock;\n\tu32 mdiv;\n\tint refclk = 100000;\n\n\t/* In case of DSI, DPLL will not be used */\n\tif ((pipe_config->dpll_hw_state.dpll & DPLL_VCO_ENABLE) == 0)\n\t\treturn;\n\n\tvlv_dpio_get(dev_priv);\n\tmdiv = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW3(pipe));\n\tvlv_dpio_put(dev_priv);\n\n\tclock.m1 = (mdiv >> DPIO_M1DIV_SHIFT) & 7;\n\tclock.m2 = mdiv & DPIO_M2DIV_MASK;\n\tclock.n = (mdiv >> DPIO_N_SHIFT) & 0xf;\n\tclock.p1 = (mdiv >> DPIO_P1_SHIFT) & 7;\n\tclock.p2 = (mdiv >> DPIO_P2_SHIFT) & 0x1f;\n\n\tpipe_config->port_clock = vlv_calc_dpll_params(refclk, &clock);\n}\n\nstatic void\ni9xx_get_initial_plane_config(struct intel_crtc *crtc,\n\t\t\t      struct intel_initial_plane_config *plane_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_plane *plane = to_intel_plane(crtc->base.primary);\n\tenum i9xx_plane_id i9xx_plane = plane->i9xx_plane;\n\tenum pipe pipe;\n\tu32 val, base, offset;\n\tint fourcc, pixel_format;\n\tunsigned int aligned_height;\n\tstruct drm_framebuffer *fb;\n\tstruct intel_framebuffer *intel_fb;\n\n\tif (!plane->get_hw_state(plane, &pipe))\n\t\treturn;\n\n\tdrm_WARN_ON(dev, pipe != crtc->pipe);\n\n\tintel_fb = kzalloc(sizeof(*intel_fb), GFP_KERNEL);\n\tif (!intel_fb) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"failed to alloc fb\\n\");\n\t\treturn;\n\t}\n\n\tfb = &intel_fb->base;\n\n\tfb->dev = dev;\n\n\tval = intel_de_read(dev_priv, DSPCNTR(i9xx_plane));\n\n\tif (INTEL_GEN(dev_priv) >= 4) {\n\t\tif (val & DISPPLANE_TILED) {\n\t\t\tplane_config->tiling = I915_TILING_X;\n\t\t\tfb->modifier = I915_FORMAT_MOD_X_TILED;\n\t\t}\n\n\t\tif (val & DISPPLANE_ROTATE_180)\n\t\t\tplane_config->rotation = DRM_MODE_ROTATE_180;\n\t}\n\n\tif (IS_CHERRYVIEW(dev_priv) && pipe == PIPE_B &&\n\t    val & DISPPLANE_MIRROR)\n\t\tplane_config->rotation |= DRM_MODE_REFLECT_X;\n\n\tpixel_format = val & DISPPLANE_PIXFORMAT_MASK;\n\tfourcc = i9xx_format_to_fourcc(pixel_format);\n\tfb->format = drm_format_info(fourcc);\n\n\tif (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv)) {\n\t\toffset = intel_de_read(dev_priv, DSPOFFSET(i9xx_plane));\n\t\tbase = intel_de_read(dev_priv, DSPSURF(i9xx_plane)) & 0xfffff000;\n\t} else if (INTEL_GEN(dev_priv) >= 4) {\n\t\tif (plane_config->tiling)\n\t\t\toffset = intel_de_read(dev_priv,\n\t\t\t\t\t       DSPTILEOFF(i9xx_plane));\n\t\telse\n\t\t\toffset = intel_de_read(dev_priv,\n\t\t\t\t\t       DSPLINOFF(i9xx_plane));\n\t\tbase = intel_de_read(dev_priv, DSPSURF(i9xx_plane)) & 0xfffff000;\n\t} else {\n\t\tbase = intel_de_read(dev_priv, DSPADDR(i9xx_plane));\n\t}\n\tplane_config->base = base;\n\n\tval = intel_de_read(dev_priv, PIPESRC(pipe));\n\tfb->width = ((val >> 16) & 0xfff) + 1;\n\tfb->height = ((val >> 0) & 0xfff) + 1;\n\n\tval = intel_de_read(dev_priv, DSPSTRIDE(i9xx_plane));\n\tfb->pitches[0] = val & 0xffffffc0;\n\n\taligned_height = intel_fb_align_height(fb, 0, fb->height);\n\n\tplane_config->size = fb->pitches[0] * aligned_height;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"%s/%s with fb: size=%dx%d@%d, offset=%x, pitch %d, size 0x%x\\n\",\n\t\t    crtc->base.name, plane->base.name, fb->width, fb->height,\n\t\t    fb->format->cpp[0] * 8, base, fb->pitches[0],\n\t\t    plane_config->size);\n\n\tplane_config->fb = intel_fb;\n}\n\nstatic void chv_crtc_clock_get(struct intel_crtc *crtc,\n\t\t\t       struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum pipe pipe = crtc->pipe;\n\tenum dpio_channel port = vlv_pipe_to_channel(pipe);\n\tstruct dpll clock;\n\tu32 cmn_dw13, pll_dw0, pll_dw1, pll_dw2, pll_dw3;\n\tint refclk = 100000;\n\n\t/* In case of DSI, DPLL will not be used */\n\tif ((pipe_config->dpll_hw_state.dpll & DPLL_VCO_ENABLE) == 0)\n\t\treturn;\n\n\tvlv_dpio_get(dev_priv);\n\tcmn_dw13 = vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW13(port));\n\tpll_dw0 = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW0(port));\n\tpll_dw1 = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW1(port));\n\tpll_dw2 = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW2(port));\n\tpll_dw3 = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW3(port));\n\tvlv_dpio_put(dev_priv);\n\n\tclock.m1 = (pll_dw1 & 0x7) == DPIO_CHV_M1_DIV_BY_2 ? 2 : 0;\n\tclock.m2 = (pll_dw0 & 0xff) << 22;\n\tif (pll_dw3 & DPIO_CHV_FRAC_DIV_EN)\n\t\tclock.m2 |= pll_dw2 & 0x3fffff;\n\tclock.n = (pll_dw1 >> DPIO_CHV_N_DIV_SHIFT) & 0xf;\n\tclock.p1 = (cmn_dw13 >> DPIO_CHV_P1_DIV_SHIFT) & 0x7;\n\tclock.p2 = (cmn_dw13 >> DPIO_CHV_P2_DIV_SHIFT) & 0x1f;\n\n\tpipe_config->port_clock = chv_calc_dpll_params(refclk, &clock);\n}\n\nstatic enum intel_output_format\nbdw_get_pipemisc_output_format(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 tmp;\n\n\ttmp = intel_de_read(dev_priv, PIPEMISC(crtc->pipe));\n\n\tif (tmp & PIPEMISC_YUV420_ENABLE) {\n\t\t/* We support 4:2:0 in full blend mode only */\n\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t    (tmp & PIPEMISC_YUV420_MODE_FULL_BLEND) == 0);\n\n\t\treturn INTEL_OUTPUT_FORMAT_YCBCR420;\n\t} else if (tmp & PIPEMISC_OUTPUT_COLORSPACE_YUV) {\n\t\treturn INTEL_OUTPUT_FORMAT_YCBCR444;\n\t} else {\n\t\treturn INTEL_OUTPUT_FORMAT_RGB;\n\t}\n}\n\nstatic void i9xx_get_pipe_color_config(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct intel_plane *plane = to_intel_plane(crtc->base.primary);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum i9xx_plane_id i9xx_plane = plane->i9xx_plane;\n\tu32 tmp;\n\n\ttmp = intel_de_read(dev_priv, DSPCNTR(i9xx_plane));\n\n\tif (tmp & DISPPLANE_GAMMA_ENABLE)\n\t\tcrtc_state->gamma_enable = true;\n\n\tif (!HAS_GMCH(dev_priv) &&\n\t    tmp & DISPPLANE_PIPE_CSC_ENABLE)\n\t\tcrtc_state->csc_enable = true;\n}\n\nstatic bool i9xx_get_pipe_config(struct intel_crtc *crtc,\n\t\t\t\t struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum intel_display_power_domain power_domain;\n\tintel_wakeref_t wakeref;\n\tu32 tmp;\n\tbool ret;\n\n\tpower_domain = POWER_DOMAIN_PIPE(crtc->pipe);\n\twakeref = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_RGB;\n\tpipe_config->cpu_transcoder = (enum transcoder) crtc->pipe;\n\tpipe_config->shared_dpll = NULL;\n\n\tret = false;\n\n\ttmp = intel_de_read(dev_priv, PIPECONF(crtc->pipe));\n\tif (!(tmp & PIPECONF_ENABLE))\n\t\tgoto out;\n\n\tif (IS_G4X(dev_priv) || IS_VALLEYVIEW(dev_priv) ||\n\t    IS_CHERRYVIEW(dev_priv)) {\n\t\tswitch (tmp & PIPECONF_BPC_MASK) {\n\t\tcase PIPECONF_6BPC:\n\t\t\tpipe_config->pipe_bpp = 18;\n\t\t\tbreak;\n\t\tcase PIPECONF_8BPC:\n\t\t\tpipe_config->pipe_bpp = 24;\n\t\t\tbreak;\n\t\tcase PIPECONF_10BPC:\n\t\t\tpipe_config->pipe_bpp = 30;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) &&\n\t    (tmp & PIPECONF_COLOR_RANGE_SELECT))\n\t\tpipe_config->limited_color_range = true;\n\n\tpipe_config->gamma_mode = (tmp & PIPECONF_GAMMA_MODE_MASK_I9XX) >>\n\t\tPIPECONF_GAMMA_MODE_SHIFT;\n\n\tif (IS_CHERRYVIEW(dev_priv))\n\t\tpipe_config->cgm_mode = intel_de_read(dev_priv,\n\t\t\t\t\t\t      CGM_PIPE_MODE(crtc->pipe));\n\n\ti9xx_get_pipe_color_config(pipe_config);\n\tintel_color_get_config(pipe_config);\n\n\tif (INTEL_GEN(dev_priv) < 4)\n\t\tpipe_config->double_wide = tmp & PIPECONF_DOUBLE_WIDE;\n\n\tintel_get_pipe_timings(crtc, pipe_config);\n\tintel_get_pipe_src_size(crtc, pipe_config);\n\n\ti9xx_get_pfit_config(pipe_config);\n\n\tif (INTEL_GEN(dev_priv) >= 4) {\n\t\t/* No way to read it out on pipes B and C */\n\t\tif (IS_CHERRYVIEW(dev_priv) && crtc->pipe != PIPE_A)\n\t\t\ttmp = dev_priv->chv_dpll_md[crtc->pipe];\n\t\telse\n\t\t\ttmp = intel_de_read(dev_priv, DPLL_MD(crtc->pipe));\n\t\tpipe_config->pixel_multiplier =\n\t\t\t((tmp & DPLL_MD_UDI_MULTIPLIER_MASK)\n\t\t\t >> DPLL_MD_UDI_MULTIPLIER_SHIFT) + 1;\n\t\tpipe_config->dpll_hw_state.dpll_md = tmp;\n\t} else if (IS_I945G(dev_priv) || IS_I945GM(dev_priv) ||\n\t\t   IS_G33(dev_priv) || IS_PINEVIEW(dev_priv)) {\n\t\ttmp = intel_de_read(dev_priv, DPLL(crtc->pipe));\n\t\tpipe_config->pixel_multiplier =\n\t\t\t((tmp & SDVO_MULTIPLIER_MASK)\n\t\t\t >> SDVO_MULTIPLIER_SHIFT_HIRES) + 1;\n\t} else {\n\t\t/* Note that on i915G/GM the pixel multiplier is in the sdvo\n\t\t * port and will be fixed up in the encoder->get_config\n\t\t * function. */\n\t\tpipe_config->pixel_multiplier = 1;\n\t}\n\tpipe_config->dpll_hw_state.dpll = intel_de_read(dev_priv,\n\t\t\t\t\t\t\tDPLL(crtc->pipe));\n\tif (!IS_VALLEYVIEW(dev_priv) && !IS_CHERRYVIEW(dev_priv)) {\n\t\tpipe_config->dpll_hw_state.fp0 = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t       FP0(crtc->pipe));\n\t\tpipe_config->dpll_hw_state.fp1 = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t       FP1(crtc->pipe));\n\t} else {\n\t\t/* Mask out read-only status bits. */\n\t\tpipe_config->dpll_hw_state.dpll &= ~(DPLL_LOCK_VLV |\n\t\t\t\t\t\t     DPLL_PORTC_READY_MASK |\n\t\t\t\t\t\t     DPLL_PORTB_READY_MASK);\n\t}\n\n\tif (IS_CHERRYVIEW(dev_priv))\n\t\tchv_crtc_clock_get(crtc, pipe_config);\n\telse if (IS_VALLEYVIEW(dev_priv))\n\t\tvlv_crtc_clock_get(crtc, pipe_config);\n\telse\n\t\ti9xx_crtc_clock_get(crtc, pipe_config);\n\n\t/*\n\t * Normally the dotclock is filled in by the encoder .get_config()\n\t * but in case the pipe is enabled w/o any ports we need a sane\n\t * default.\n\t */\n\tpipe_config->hw.adjusted_mode.crtc_clock =\n\t\tpipe_config->port_clock / pipe_config->pixel_multiplier;\n\n\tret = true;\n\nout:\n\tintel_display_power_put(dev_priv, power_domain, wakeref);\n\n\treturn ret;\n}\n\nstatic void ilk_init_pch_refclk(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_encoder *encoder;\n\tint i;\n\tu32 val, final;\n\tbool has_lvds = false;\n\tbool has_cpu_edp = false;\n\tbool has_panel = false;\n\tbool has_ck505 = false;\n\tbool can_ssc = false;\n\tbool using_ssc_source = false;\n\n\t/* We need to take the global config into account */\n\tfor_each_intel_encoder(&dev_priv->drm, encoder) {\n\t\tswitch (encoder->type) {\n\t\tcase INTEL_OUTPUT_LVDS:\n\t\t\thas_panel = true;\n\t\t\thas_lvds = true;\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_EDP:\n\t\t\thas_panel = true;\n\t\t\tif (encoder->port == PORT_A)\n\t\t\t\thas_cpu_edp = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (HAS_PCH_IBX(dev_priv)) {\n\t\thas_ck505 = dev_priv->vbt.display_clock_mode;\n\t\tcan_ssc = has_ck505;\n\t} else {\n\t\thas_ck505 = false;\n\t\tcan_ssc = true;\n\t}\n\n\t/* Check if any DPLLs are using the SSC source */\n\tfor (i = 0; i < dev_priv->dpll.num_shared_dpll; i++) {\n\t\tu32 temp = intel_de_read(dev_priv, PCH_DPLL(i));\n\n\t\tif (!(temp & DPLL_VCO_ENABLE))\n\t\t\tcontinue;\n\n\t\tif ((temp & PLL_REF_INPUT_MASK) ==\n\t\t    PLLB_REF_INPUT_SPREADSPECTRUMIN) {\n\t\t\tusing_ssc_source = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"has_panel %d has_lvds %d has_ck505 %d using_ssc_source %d\\n\",\n\t\t    has_panel, has_lvds, has_ck505, using_ssc_source);\n\n\t/* Ironlake: try to setup display ref clock before DPLL\n\t * enabling. This is only under driver's control after\n\t * PCH B stepping, previous chipset stepping should be\n\t * ignoring this setting.\n\t */\n\tval = intel_de_read(dev_priv, PCH_DREF_CONTROL);\n\n\t/* As we must carefully and slowly disable/enable each source in turn,\n\t * compute the final state we want first and check if we need to\n\t * make any changes at all.\n\t */\n\tfinal = val;\n\tfinal &= ~DREF_NONSPREAD_SOURCE_MASK;\n\tif (has_ck505)\n\t\tfinal |= DREF_NONSPREAD_CK505_ENABLE;\n\telse\n\t\tfinal |= DREF_NONSPREAD_SOURCE_ENABLE;\n\n\tfinal &= ~DREF_SSC_SOURCE_MASK;\n\tfinal &= ~DREF_CPU_SOURCE_OUTPUT_MASK;\n\tfinal &= ~DREF_SSC1_ENABLE;\n\n\tif (has_panel) {\n\t\tfinal |= DREF_SSC_SOURCE_ENABLE;\n\n\t\tif (intel_panel_use_ssc(dev_priv) && can_ssc)\n\t\t\tfinal |= DREF_SSC1_ENABLE;\n\n\t\tif (has_cpu_edp) {\n\t\t\tif (intel_panel_use_ssc(dev_priv) && can_ssc)\n\t\t\t\tfinal |= DREF_CPU_SOURCE_OUTPUT_DOWNSPREAD;\n\t\t\telse\n\t\t\t\tfinal |= DREF_CPU_SOURCE_OUTPUT_NONSPREAD;\n\t\t} else\n\t\t\tfinal |= DREF_CPU_SOURCE_OUTPUT_DISABLE;\n\t} else if (using_ssc_source) {\n\t\tfinal |= DREF_SSC_SOURCE_ENABLE;\n\t\tfinal |= DREF_SSC1_ENABLE;\n\t}\n\n\tif (final == val)\n\t\treturn;\n\n\t/* Always enable nonspread source */\n\tval &= ~DREF_NONSPREAD_SOURCE_MASK;\n\n\tif (has_ck505)\n\t\tval |= DREF_NONSPREAD_CK505_ENABLE;\n\telse\n\t\tval |= DREF_NONSPREAD_SOURCE_ENABLE;\n\n\tif (has_panel) {\n\t\tval &= ~DREF_SSC_SOURCE_MASK;\n\t\tval |= DREF_SSC_SOURCE_ENABLE;\n\n\t\t/* SSC must be turned on before enabling the CPU output  */\n\t\tif (intel_panel_use_ssc(dev_priv) && can_ssc) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"Using SSC on panel\\n\");\n\t\t\tval |= DREF_SSC1_ENABLE;\n\t\t} else\n\t\t\tval &= ~DREF_SSC1_ENABLE;\n\n\t\t/* Get SSC going before enabling the outputs */\n\t\tintel_de_write(dev_priv, PCH_DREF_CONTROL, val);\n\t\tintel_de_posting_read(dev_priv, PCH_DREF_CONTROL);\n\t\tudelay(200);\n\n\t\tval &= ~DREF_CPU_SOURCE_OUTPUT_MASK;\n\n\t\t/* Enable CPU source on CPU attached eDP */\n\t\tif (has_cpu_edp) {\n\t\t\tif (intel_panel_use_ssc(dev_priv) && can_ssc) {\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"Using SSC on eDP\\n\");\n\t\t\t\tval |= DREF_CPU_SOURCE_OUTPUT_DOWNSPREAD;\n\t\t\t} else\n\t\t\t\tval |= DREF_CPU_SOURCE_OUTPUT_NONSPREAD;\n\t\t} else\n\t\t\tval |= DREF_CPU_SOURCE_OUTPUT_DISABLE;\n\n\t\tintel_de_write(dev_priv, PCH_DREF_CONTROL, val);\n\t\tintel_de_posting_read(dev_priv, PCH_DREF_CONTROL);\n\t\tudelay(200);\n\t} else {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Disabling CPU source output\\n\");\n\n\t\tval &= ~DREF_CPU_SOURCE_OUTPUT_MASK;\n\n\t\t/* Turn off CPU output */\n\t\tval |= DREF_CPU_SOURCE_OUTPUT_DISABLE;\n\n\t\tintel_de_write(dev_priv, PCH_DREF_CONTROL, val);\n\t\tintel_de_posting_read(dev_priv, PCH_DREF_CONTROL);\n\t\tudelay(200);\n\n\t\tif (!using_ssc_source) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"Disabling SSC source\\n\");\n\n\t\t\t/* Turn off the SSC source */\n\t\t\tval &= ~DREF_SSC_SOURCE_MASK;\n\t\t\tval |= DREF_SSC_SOURCE_DISABLE;\n\n\t\t\t/* Turn off SSC1 */\n\t\t\tval &= ~DREF_SSC1_ENABLE;\n\n\t\t\tintel_de_write(dev_priv, PCH_DREF_CONTROL, val);\n\t\t\tintel_de_posting_read(dev_priv, PCH_DREF_CONTROL);\n\t\t\tudelay(200);\n\t\t}\n\t}\n\n\tBUG_ON(val != final);\n}\n\nstatic void lpt_reset_fdi_mphy(struct drm_i915_private *dev_priv)\n{\n\tu32 tmp;\n\n\ttmp = intel_de_read(dev_priv, SOUTH_CHICKEN2);\n\ttmp |= FDI_MPHY_IOSFSB_RESET_CTL;\n\tintel_de_write(dev_priv, SOUTH_CHICKEN2, tmp);\n\n\tif (wait_for_us(intel_de_read(dev_priv, SOUTH_CHICKEN2) &\n\t\t\tFDI_MPHY_IOSFSB_RESET_STATUS, 100))\n\t\tdrm_err(&dev_priv->drm, \"FDI mPHY reset assert timeout\\n\");\n\n\ttmp = intel_de_read(dev_priv, SOUTH_CHICKEN2);\n\ttmp &= ~FDI_MPHY_IOSFSB_RESET_CTL;\n\tintel_de_write(dev_priv, SOUTH_CHICKEN2, tmp);\n\n\tif (wait_for_us((intel_de_read(dev_priv, SOUTH_CHICKEN2) &\n\t\t\t FDI_MPHY_IOSFSB_RESET_STATUS) == 0, 100))\n\t\tdrm_err(&dev_priv->drm, \"FDI mPHY reset de-assert timeout\\n\");\n}\n\n/* WaMPhyProgramming:hsw */\nstatic void lpt_program_fdi_mphy(struct drm_i915_private *dev_priv)\n{\n\tu32 tmp;\n\n\ttmp = intel_sbi_read(dev_priv, 0x8008, SBI_MPHY);\n\ttmp &= ~(0xFF << 24);\n\ttmp |= (0x12 << 24);\n\tintel_sbi_write(dev_priv, 0x8008, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x2008, SBI_MPHY);\n\ttmp |= (1 << 11);\n\tintel_sbi_write(dev_priv, 0x2008, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x2108, SBI_MPHY);\n\ttmp |= (1 << 11);\n\tintel_sbi_write(dev_priv, 0x2108, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x206C, SBI_MPHY);\n\ttmp |= (1 << 24) | (1 << 21) | (1 << 18);\n\tintel_sbi_write(dev_priv, 0x206C, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x216C, SBI_MPHY);\n\ttmp |= (1 << 24) | (1 << 21) | (1 << 18);\n\tintel_sbi_write(dev_priv, 0x216C, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x2080, SBI_MPHY);\n\ttmp &= ~(7 << 13);\n\ttmp |= (5 << 13);\n\tintel_sbi_write(dev_priv, 0x2080, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x2180, SBI_MPHY);\n\ttmp &= ~(7 << 13);\n\ttmp |= (5 << 13);\n\tintel_sbi_write(dev_priv, 0x2180, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x208C, SBI_MPHY);\n\ttmp &= ~0xFF;\n\ttmp |= 0x1C;\n\tintel_sbi_write(dev_priv, 0x208C, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x218C, SBI_MPHY);\n\ttmp &= ~0xFF;\n\ttmp |= 0x1C;\n\tintel_sbi_write(dev_priv, 0x218C, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x2098, SBI_MPHY);\n\ttmp &= ~(0xFF << 16);\n\ttmp |= (0x1C << 16);\n\tintel_sbi_write(dev_priv, 0x2098, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x2198, SBI_MPHY);\n\ttmp &= ~(0xFF << 16);\n\ttmp |= (0x1C << 16);\n\tintel_sbi_write(dev_priv, 0x2198, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x20C4, SBI_MPHY);\n\ttmp |= (1 << 27);\n\tintel_sbi_write(dev_priv, 0x20C4, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x21C4, SBI_MPHY);\n\ttmp |= (1 << 27);\n\tintel_sbi_write(dev_priv, 0x21C4, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x20EC, SBI_MPHY);\n\ttmp &= ~(0xF << 28);\n\ttmp |= (4 << 28);\n\tintel_sbi_write(dev_priv, 0x20EC, tmp, SBI_MPHY);\n\n\ttmp = intel_sbi_read(dev_priv, 0x21EC, SBI_MPHY);\n\ttmp &= ~(0xF << 28);\n\ttmp |= (4 << 28);\n\tintel_sbi_write(dev_priv, 0x21EC, tmp, SBI_MPHY);\n}\n\n/* Implements 3 different sequences from BSpec chapter \"Display iCLK\n * Programming\" based on the parameters passed:\n * - Sequence to enable CLKOUT_DP\n * - Sequence to enable CLKOUT_DP without spread\n * - Sequence to enable CLKOUT_DP for FDI usage and configure PCH FDI I/O\n */\nstatic void lpt_enable_clkout_dp(struct drm_i915_private *dev_priv,\n\t\t\t\t bool with_spread, bool with_fdi)\n{\n\tu32 reg, tmp;\n\n\tif (drm_WARN(&dev_priv->drm, with_fdi && !with_spread,\n\t\t     \"FDI requires downspread\\n\"))\n\t\twith_spread = true;\n\tif (drm_WARN(&dev_priv->drm, HAS_PCH_LPT_LP(dev_priv) &&\n\t\t     with_fdi, \"LP PCH doesn't have FDI\\n\"))\n\t\twith_fdi = false;\n\n\tmutex_lock(&dev_priv->sb_lock);\n\n\ttmp = intel_sbi_read(dev_priv, SBI_SSCCTL, SBI_ICLK);\n\ttmp &= ~SBI_SSCCTL_DISABLE;\n\ttmp |= SBI_SSCCTL_PATHALT;\n\tintel_sbi_write(dev_priv, SBI_SSCCTL, tmp, SBI_ICLK);\n\n\tudelay(24);\n\n\tif (with_spread) {\n\t\ttmp = intel_sbi_read(dev_priv, SBI_SSCCTL, SBI_ICLK);\n\t\ttmp &= ~SBI_SSCCTL_PATHALT;\n\t\tintel_sbi_write(dev_priv, SBI_SSCCTL, tmp, SBI_ICLK);\n\n\t\tif (with_fdi) {\n\t\t\tlpt_reset_fdi_mphy(dev_priv);\n\t\t\tlpt_program_fdi_mphy(dev_priv);\n\t\t}\n\t}\n\n\treg = HAS_PCH_LPT_LP(dev_priv) ? SBI_GEN0 : SBI_DBUFF0;\n\ttmp = intel_sbi_read(dev_priv, reg, SBI_ICLK);\n\ttmp |= SBI_GEN0_CFG_BUFFENABLE_DISABLE;\n\tintel_sbi_write(dev_priv, reg, tmp, SBI_ICLK);\n\n\tmutex_unlock(&dev_priv->sb_lock);\n}\n\n/* Sequence to disable CLKOUT_DP */\nvoid lpt_disable_clkout_dp(struct drm_i915_private *dev_priv)\n{\n\tu32 reg, tmp;\n\n\tmutex_lock(&dev_priv->sb_lock);\n\n\treg = HAS_PCH_LPT_LP(dev_priv) ? SBI_GEN0 : SBI_DBUFF0;\n\ttmp = intel_sbi_read(dev_priv, reg, SBI_ICLK);\n\ttmp &= ~SBI_GEN0_CFG_BUFFENABLE_DISABLE;\n\tintel_sbi_write(dev_priv, reg, tmp, SBI_ICLK);\n\n\ttmp = intel_sbi_read(dev_priv, SBI_SSCCTL, SBI_ICLK);\n\tif (!(tmp & SBI_SSCCTL_DISABLE)) {\n\t\tif (!(tmp & SBI_SSCCTL_PATHALT)) {\n\t\t\ttmp |= SBI_SSCCTL_PATHALT;\n\t\t\tintel_sbi_write(dev_priv, SBI_SSCCTL, tmp, SBI_ICLK);\n\t\t\tudelay(32);\n\t\t}\n\t\ttmp |= SBI_SSCCTL_DISABLE;\n\t\tintel_sbi_write(dev_priv, SBI_SSCCTL, tmp, SBI_ICLK);\n\t}\n\n\tmutex_unlock(&dev_priv->sb_lock);\n}\n\n#define BEND_IDX(steps) ((50 + (steps)) / 5)\n\nstatic const u16 sscdivintphase[] = {\n\t[BEND_IDX( 50)] = 0x3B23,\n\t[BEND_IDX( 45)] = 0x3B23,\n\t[BEND_IDX( 40)] = 0x3C23,\n\t[BEND_IDX( 35)] = 0x3C23,\n\t[BEND_IDX( 30)] = 0x3D23,\n\t[BEND_IDX( 25)] = 0x3D23,\n\t[BEND_IDX( 20)] = 0x3E23,\n\t[BEND_IDX( 15)] = 0x3E23,\n\t[BEND_IDX( 10)] = 0x3F23,\n\t[BEND_IDX(  5)] = 0x3F23,\n\t[BEND_IDX(  0)] = 0x0025,\n\t[BEND_IDX( -5)] = 0x0025,\n\t[BEND_IDX(-10)] = 0x0125,\n\t[BEND_IDX(-15)] = 0x0125,\n\t[BEND_IDX(-20)] = 0x0225,\n\t[BEND_IDX(-25)] = 0x0225,\n\t[BEND_IDX(-30)] = 0x0325,\n\t[BEND_IDX(-35)] = 0x0325,\n\t[BEND_IDX(-40)] = 0x0425,\n\t[BEND_IDX(-45)] = 0x0425,\n\t[BEND_IDX(-50)] = 0x0525,\n};\n\n/*\n * Bend CLKOUT_DP\n * steps -50 to 50 inclusive, in steps of 5\n * < 0 slow down the clock, > 0 speed up the clock, 0 == no bend (135MHz)\n * change in clock period = -(steps / 10) * 5.787 ps\n */\nstatic void lpt_bend_clkout_dp(struct drm_i915_private *dev_priv, int steps)\n{\n\tu32 tmp;\n\tint idx = BEND_IDX(steps);\n\n\tif (drm_WARN_ON(&dev_priv->drm, steps % 5 != 0))\n\t\treturn;\n\n\tif (drm_WARN_ON(&dev_priv->drm, idx >= ARRAY_SIZE(sscdivintphase)))\n\t\treturn;\n\n\tmutex_lock(&dev_priv->sb_lock);\n\n\tif (steps % 10 != 0)\n\t\ttmp = 0xAAAAAAAB;\n\telse\n\t\ttmp = 0x00000000;\n\tintel_sbi_write(dev_priv, SBI_SSCDITHPHASE, tmp, SBI_ICLK);\n\n\ttmp = intel_sbi_read(dev_priv, SBI_SSCDIVINTPHASE, SBI_ICLK);\n\ttmp &= 0xffff0000;\n\ttmp |= sscdivintphase[idx];\n\tintel_sbi_write(dev_priv, SBI_SSCDIVINTPHASE, tmp, SBI_ICLK);\n\n\tmutex_unlock(&dev_priv->sb_lock);\n}\n\n#undef BEND_IDX\n\nstatic bool spll_uses_pch_ssc(struct drm_i915_private *dev_priv)\n{\n\tu32 fuse_strap = intel_de_read(dev_priv, FUSE_STRAP);\n\tu32 ctl = intel_de_read(dev_priv, SPLL_CTL);\n\n\tif ((ctl & SPLL_PLL_ENABLE) == 0)\n\t\treturn false;\n\n\tif ((ctl & SPLL_REF_MASK) == SPLL_REF_MUXED_SSC &&\n\t    (fuse_strap & HSW_CPU_SSC_ENABLE) == 0)\n\t\treturn true;\n\n\tif (IS_BROADWELL(dev_priv) &&\n\t    (ctl & SPLL_REF_MASK) == SPLL_REF_PCH_SSC_BDW)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool wrpll_uses_pch_ssc(struct drm_i915_private *dev_priv,\n\t\t\t       enum intel_dpll_id id)\n{\n\tu32 fuse_strap = intel_de_read(dev_priv, FUSE_STRAP);\n\tu32 ctl = intel_de_read(dev_priv, WRPLL_CTL(id));\n\n\tif ((ctl & WRPLL_PLL_ENABLE) == 0)\n\t\treturn false;\n\n\tif ((ctl & WRPLL_REF_MASK) == WRPLL_REF_PCH_SSC)\n\t\treturn true;\n\n\tif ((IS_BROADWELL(dev_priv) || IS_HSW_ULT(dev_priv)) &&\n\t    (ctl & WRPLL_REF_MASK) == WRPLL_REF_MUXED_SSC_BDW &&\n\t    (fuse_strap & HSW_CPU_SSC_ENABLE) == 0)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void lpt_init_pch_refclk(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_encoder *encoder;\n\tbool has_fdi = false;\n\n\tfor_each_intel_encoder(&dev_priv->drm, encoder) {\n\t\tswitch (encoder->type) {\n\t\tcase INTEL_OUTPUT_ANALOG:\n\t\t\thas_fdi = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * The BIOS may have decided to use the PCH SSC\n\t * reference so we must not disable it until the\n\t * relevant PLLs have stopped relying on it. We'll\n\t * just leave the PCH SSC reference enabled in case\n\t * any active PLL is using it. It will get disabled\n\t * after runtime suspend if we don't have FDI.\n\t *\n\t * TODO: Move the whole reference clock handling\n\t * to the modeset sequence proper so that we can\n\t * actually enable/disable/reconfigure these things\n\t * safely. To do that we need to introduce a real\n\t * clock hierarchy. That would also allow us to do\n\t * clock bending finally.\n\t */\n\tdev_priv->pch_ssc_use = 0;\n\n\tif (spll_uses_pch_ssc(dev_priv)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"SPLL using PCH SSC\\n\");\n\t\tdev_priv->pch_ssc_use |= BIT(DPLL_ID_SPLL);\n\t}\n\n\tif (wrpll_uses_pch_ssc(dev_priv, DPLL_ID_WRPLL1)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"WRPLL1 using PCH SSC\\n\");\n\t\tdev_priv->pch_ssc_use |= BIT(DPLL_ID_WRPLL1);\n\t}\n\n\tif (wrpll_uses_pch_ssc(dev_priv, DPLL_ID_WRPLL2)) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"WRPLL2 using PCH SSC\\n\");\n\t\tdev_priv->pch_ssc_use |= BIT(DPLL_ID_WRPLL2);\n\t}\n\n\tif (dev_priv->pch_ssc_use)\n\t\treturn;\n\n\tif (has_fdi) {\n\t\tlpt_bend_clkout_dp(dev_priv, 0);\n\t\tlpt_enable_clkout_dp(dev_priv, true, true);\n\t} else {\n\t\tlpt_disable_clkout_dp(dev_priv);\n\t}\n}\n\n/*\n * Initialize reference clocks when the driver loads\n */\nvoid intel_init_pch_refclk(struct drm_i915_private *dev_priv)\n{\n\tif (HAS_PCH_IBX(dev_priv) || HAS_PCH_CPT(dev_priv))\n\t\tilk_init_pch_refclk(dev_priv);\n\telse if (HAS_PCH_LPT(dev_priv))\n\t\tlpt_init_pch_refclk(dev_priv);\n}\n\nstatic void ilk_set_pipeconf(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\tu32 val;\n\n\tval = 0;\n\n\tswitch (crtc_state->pipe_bpp) {\n\tcase 18:\n\t\tval |= PIPECONF_6BPC;\n\t\tbreak;\n\tcase 24:\n\t\tval |= PIPECONF_8BPC;\n\t\tbreak;\n\tcase 30:\n\t\tval |= PIPECONF_10BPC;\n\t\tbreak;\n\tcase 36:\n\t\tval |= PIPECONF_12BPC;\n\t\tbreak;\n\tdefault:\n\t\t/* Case prevented by intel_choose_pipe_bpp_dither. */\n\t\tBUG();\n\t}\n\n\tif (crtc_state->dither)\n\t\tval |= (PIPECONF_DITHER_EN | PIPECONF_DITHER_TYPE_SP);\n\n\tif (crtc_state->hw.adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE)\n\t\tval |= PIPECONF_INTERLACED_ILK;\n\telse\n\t\tval |= PIPECONF_PROGRESSIVE;\n\n\t/*\n\t * This would end up with an odd purple hue over\n\t * the entire display. Make sure we don't do it.\n\t */\n\tdrm_WARN_ON(&dev_priv->drm, crtc_state->limited_color_range &&\n\t\t    crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB);\n\n\tif (crtc_state->limited_color_range &&\n\t    !intel_crtc_has_type(crtc_state, INTEL_OUTPUT_SDVO))\n\t\tval |= PIPECONF_COLOR_RANGE_SELECT;\n\n\tif (crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB)\n\t\tval |= PIPECONF_OUTPUT_COLORSPACE_YUV709;\n\n\tval |= PIPECONF_GAMMA_MODE(crtc_state->gamma_mode);\n\n\tval |= PIPECONF_FRAME_START_DELAY(0);\n\n\tintel_de_write(dev_priv, PIPECONF(pipe), val);\n\tintel_de_posting_read(dev_priv, PIPECONF(pipe));\n}\n\nstatic void hsw_set_pipeconf(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\tu32 val = 0;\n\n\tif (IS_HASWELL(dev_priv) && crtc_state->dither)\n\t\tval |= (PIPECONF_DITHER_EN | PIPECONF_DITHER_TYPE_SP);\n\n\tif (crtc_state->hw.adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE)\n\t\tval |= PIPECONF_INTERLACED_ILK;\n\telse\n\t\tval |= PIPECONF_PROGRESSIVE;\n\n\tif (IS_HASWELL(dev_priv) &&\n\t    crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB)\n\t\tval |= PIPECONF_OUTPUT_COLORSPACE_YUV_HSW;\n\n\tintel_de_write(dev_priv, PIPECONF(cpu_transcoder), val);\n\tintel_de_posting_read(dev_priv, PIPECONF(cpu_transcoder));\n}\n\nstatic void bdw_set_pipemisc(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 val = 0;\n\n\tswitch (crtc_state->pipe_bpp) {\n\tcase 18:\n\t\tval |= PIPEMISC_DITHER_6_BPC;\n\t\tbreak;\n\tcase 24:\n\t\tval |= PIPEMISC_DITHER_8_BPC;\n\t\tbreak;\n\tcase 30:\n\t\tval |= PIPEMISC_DITHER_10_BPC;\n\t\tbreak;\n\tcase 36:\n\t\tval |= PIPEMISC_DITHER_12_BPC;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(crtc_state->pipe_bpp);\n\t\tbreak;\n\t}\n\n\tif (crtc_state->dither)\n\t\tval |= PIPEMISC_DITHER_ENABLE | PIPEMISC_DITHER_TYPE_SP;\n\n\tif (crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR420 ||\n\t    crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR444)\n\t\tval |= PIPEMISC_OUTPUT_COLORSPACE_YUV;\n\n\tif (crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR420)\n\t\tval |= PIPEMISC_YUV420_ENABLE |\n\t\t\tPIPEMISC_YUV420_MODE_FULL_BLEND;\n\n\tif (INTEL_GEN(dev_priv) >= 11 &&\n\t    (crtc_state->active_planes & ~(icl_hdr_plane_mask() |\n\t\t\t\t\t   BIT(PLANE_CURSOR))) == 0)\n\t\tval |= PIPEMISC_HDR_MODE_PRECISION;\n\n\tif (INTEL_GEN(dev_priv) >= 12)\n\t\tval |= PIPEMISC_PIXEL_ROUNDING_TRUNC;\n\n\tintel_de_write(dev_priv, PIPEMISC(crtc->pipe), val);\n}\n\nint bdw_get_pipemisc_bpp(struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 tmp;\n\n\ttmp = intel_de_read(dev_priv, PIPEMISC(crtc->pipe));\n\n\tswitch (tmp & PIPEMISC_DITHER_BPC_MASK) {\n\tcase PIPEMISC_DITHER_6_BPC:\n\t\treturn 18;\n\tcase PIPEMISC_DITHER_8_BPC:\n\t\treturn 24;\n\tcase PIPEMISC_DITHER_10_BPC:\n\t\treturn 30;\n\tcase PIPEMISC_DITHER_12_BPC:\n\t\treturn 36;\n\tdefault:\n\t\tMISSING_CASE(tmp);\n\t\treturn 0;\n\t}\n}\n\nint ilk_get_lanes_required(int target_clock, int link_bw, int bpp)\n{\n\t/*\n\t * Account for spread spectrum to avoid\n\t * oversubscribing the link. Max center spread\n\t * is 2.5%; use 5% for safety's sake.\n\t */\n\tu32 bps = target_clock * bpp * 21 / 20;\n\treturn DIV_ROUND_UP(bps, link_bw * 8);\n}\n\nstatic bool ilk_needs_fb_cb_tune(struct dpll *dpll, int factor)\n{\n\treturn i9xx_dpll_compute_m(dpll) < factor * dpll->n;\n}\n\nstatic void ilk_compute_dpll(struct intel_crtc *crtc,\n\t\t\t     struct intel_crtc_state *crtc_state,\n\t\t\t     struct dpll *reduced_clock)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 dpll, fp, fp2;\n\tint factor;\n\n\t/* Enable autotuning of the PLL clock (if permissible) */\n\tfactor = 21;\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS)) {\n\t\tif ((intel_panel_use_ssc(dev_priv) &&\n\t\t     dev_priv->vbt.lvds_ssc_freq == 100000) ||\n\t\t    (HAS_PCH_IBX(dev_priv) &&\n\t\t     intel_is_dual_link_lvds(dev_priv)))\n\t\t\tfactor = 25;\n\t} else if (crtc_state->sdvo_tv_clock) {\n\t\tfactor = 20;\n\t}\n\n\tfp = i9xx_dpll_compute_fp(&crtc_state->dpll);\n\n\tif (ilk_needs_fb_cb_tune(&crtc_state->dpll, factor))\n\t\tfp |= FP_CB_TUNE;\n\n\tif (reduced_clock) {\n\t\tfp2 = i9xx_dpll_compute_fp(reduced_clock);\n\n\t\tif (reduced_clock->m < factor * reduced_clock->n)\n\t\t\tfp2 |= FP_CB_TUNE;\n\t} else {\n\t\tfp2 = fp;\n\t}\n\n\tdpll = 0;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS))\n\t\tdpll |= DPLLB_MODE_LVDS;\n\telse\n\t\tdpll |= DPLLB_MODE_DAC_SERIAL;\n\n\tdpll |= (crtc_state->pixel_multiplier - 1)\n\t\t<< PLL_REF_SDVO_HDMI_MULTIPLIER_SHIFT;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_SDVO) ||\n\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))\n\t\tdpll |= DPLL_SDVO_HIGH_SPEED;\n\n\tif (intel_crtc_has_dp_encoder(crtc_state))\n\t\tdpll |= DPLL_SDVO_HIGH_SPEED;\n\n\t/*\n\t * The high speed IO clock is only really required for\n\t * SDVO/HDMI/DP, but we also enable it for CRT to make it\n\t * possible to share the DPLL between CRT and HDMI. Enabling\n\t * the clock needlessly does no real harm, except use up a\n\t * bit of power potentially.\n\t *\n\t * We'll limit this to IVB with 3 pipes, since it has only two\n\t * DPLLs and so DPLL sharing is the only way to get three pipes\n\t * driving PCH ports at the same time. On SNB we could do this,\n\t * and potentially avoid enabling the second DPLL, but it's not\n\t * clear if it''s a win or loss power wise. No point in doing\n\t * this on ILK at all since it has a fixed DPLL<->pipe mapping.\n\t */\n\tif (INTEL_NUM_PIPES(dev_priv) == 3 &&\n\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_ANALOG))\n\t\tdpll |= DPLL_SDVO_HIGH_SPEED;\n\n\t/* compute bitmask from p1 value */\n\tdpll |= (1 << (crtc_state->dpll.p1 - 1)) << DPLL_FPA01_P1_POST_DIV_SHIFT;\n\t/* also FPA1 */\n\tdpll |= (1 << (crtc_state->dpll.p1 - 1)) << DPLL_FPA1_P1_POST_DIV_SHIFT;\n\n\tswitch (crtc_state->dpll.p2) {\n\tcase 5:\n\t\tdpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_5;\n\t\tbreak;\n\tcase 7:\n\t\tdpll |= DPLLB_LVDS_P2_CLOCK_DIV_7;\n\t\tbreak;\n\tcase 10:\n\t\tdpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_10;\n\t\tbreak;\n\tcase 14:\n\t\tdpll |= DPLLB_LVDS_P2_CLOCK_DIV_14;\n\t\tbreak;\n\t}\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS) &&\n\t    intel_panel_use_ssc(dev_priv))\n\t\tdpll |= PLLB_REF_INPUT_SPREADSPECTRUMIN;\n\telse\n\t\tdpll |= PLL_REF_INPUT_DREFCLK;\n\n\tdpll |= DPLL_VCO_ENABLE;\n\n\tcrtc_state->dpll_hw_state.dpll = dpll;\n\tcrtc_state->dpll_hw_state.fp0 = fp;\n\tcrtc_state->dpll_hw_state.fp1 = fp2;\n}\n\nstatic int ilk_crtc_compute_clock(struct intel_crtc *crtc,\n\t\t\t\t  struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_atomic_state *state =\n\t\tto_intel_atomic_state(crtc_state->uapi.state);\n\tconst struct intel_limit *limit;\n\tint refclk = 120000;\n\n\tmemset(&crtc_state->dpll_hw_state, 0,\n\t       sizeof(crtc_state->dpll_hw_state));\n\n\t/* CPU eDP is the only output that doesn't need a PCH PLL of its own. */\n\tif (!crtc_state->has_pch_encoder)\n\t\treturn 0;\n\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS)) {\n\t\tif (intel_panel_use_ssc(dev_priv)) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"using SSC reference clock of %d kHz\\n\",\n\t\t\t\t    dev_priv->vbt.lvds_ssc_freq);\n\t\t\trefclk = dev_priv->vbt.lvds_ssc_freq;\n\t\t}\n\n\t\tif (intel_is_dual_link_lvds(dev_priv)) {\n\t\t\tif (refclk == 100000)\n\t\t\t\tlimit = &ilk_limits_dual_lvds_100m;\n\t\t\telse\n\t\t\t\tlimit = &ilk_limits_dual_lvds;\n\t\t} else {\n\t\t\tif (refclk == 100000)\n\t\t\t\tlimit = &ilk_limits_single_lvds_100m;\n\t\t\telse\n\t\t\t\tlimit = &ilk_limits_single_lvds;\n\t\t}\n\t} else {\n\t\tlimit = &ilk_limits_dac;\n\t}\n\n\tif (!crtc_state->clock_set &&\n\t    !g4x_find_best_dpll(limit, crtc_state, crtc_state->port_clock,\n\t\t\t\trefclk, NULL, &crtc_state->dpll)) {\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Couldn't find PLL settings for mode!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tilk_compute_dpll(crtc, crtc_state, NULL);\n\n\tif (!intel_reserve_shared_dplls(state, crtc, NULL)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"failed to find PLL for pipe %c\\n\",\n\t\t\t    pipe_name(crtc->pipe));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void intel_pch_transcoder_get_m_n(struct intel_crtc *crtc,\n\t\t\t\t\t struct intel_link_m_n *m_n)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tm_n->link_m = intel_de_read(dev_priv, PCH_TRANS_LINK_M1(pipe));\n\tm_n->link_n = intel_de_read(dev_priv, PCH_TRANS_LINK_N1(pipe));\n\tm_n->gmch_m = intel_de_read(dev_priv, PCH_TRANS_DATA_M1(pipe))\n\t\t& ~TU_SIZE_MASK;\n\tm_n->gmch_n = intel_de_read(dev_priv, PCH_TRANS_DATA_N1(pipe));\n\tm_n->tu = ((intel_de_read(dev_priv, PCH_TRANS_DATA_M1(pipe))\n\t\t    & TU_SIZE_MASK) >> TU_SIZE_SHIFT) + 1;\n}\n\nstatic void intel_cpu_transcoder_get_m_n(struct intel_crtc *crtc,\n\t\t\t\t\t enum transcoder transcoder,\n\t\t\t\t\t struct intel_link_m_n *m_n,\n\t\t\t\t\t struct intel_link_m_n *m2_n2)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum pipe pipe = crtc->pipe;\n\n\tif (INTEL_GEN(dev_priv) >= 5) {\n\t\tm_n->link_m = intel_de_read(dev_priv,\n\t\t\t\t\t    PIPE_LINK_M1(transcoder));\n\t\tm_n->link_n = intel_de_read(dev_priv,\n\t\t\t\t\t    PIPE_LINK_N1(transcoder));\n\t\tm_n->gmch_m = intel_de_read(dev_priv,\n\t\t\t\t\t    PIPE_DATA_M1(transcoder))\n\t\t\t& ~TU_SIZE_MASK;\n\t\tm_n->gmch_n = intel_de_read(dev_priv,\n\t\t\t\t\t    PIPE_DATA_N1(transcoder));\n\t\tm_n->tu = ((intel_de_read(dev_priv, PIPE_DATA_M1(transcoder))\n\t\t\t    & TU_SIZE_MASK) >> TU_SIZE_SHIFT) + 1;\n\n\t\tif (m2_n2 && transcoder_has_m2_n2(dev_priv, transcoder)) {\n\t\t\tm2_n2->link_m = intel_de_read(dev_priv,\n\t\t\t\t\t\t      PIPE_LINK_M2(transcoder));\n\t\t\tm2_n2->link_n =\tintel_de_read(dev_priv,\n\t\t\t\t\t\t\t     PIPE_LINK_N2(transcoder));\n\t\t\tm2_n2->gmch_m =\tintel_de_read(dev_priv,\n\t\t\t\t\t\t\t     PIPE_DATA_M2(transcoder))\n\t\t\t\t\t& ~TU_SIZE_MASK;\n\t\t\tm2_n2->gmch_n =\tintel_de_read(dev_priv,\n\t\t\t\t\t\t\t     PIPE_DATA_N2(transcoder));\n\t\t\tm2_n2->tu = ((intel_de_read(dev_priv, PIPE_DATA_M2(transcoder))\n\t\t\t\t\t& TU_SIZE_MASK) >> TU_SIZE_SHIFT) + 1;\n\t\t}\n\t} else {\n\t\tm_n->link_m = intel_de_read(dev_priv, PIPE_LINK_M_G4X(pipe));\n\t\tm_n->link_n = intel_de_read(dev_priv, PIPE_LINK_N_G4X(pipe));\n\t\tm_n->gmch_m = intel_de_read(dev_priv, PIPE_DATA_M_G4X(pipe))\n\t\t\t& ~TU_SIZE_MASK;\n\t\tm_n->gmch_n = intel_de_read(dev_priv, PIPE_DATA_N_G4X(pipe));\n\t\tm_n->tu = ((intel_de_read(dev_priv, PIPE_DATA_M_G4X(pipe))\n\t\t\t    & TU_SIZE_MASK) >> TU_SIZE_SHIFT) + 1;\n\t}\n}\n\nvoid intel_dp_get_m_n(struct intel_crtc *crtc,\n\t\t      struct intel_crtc_state *pipe_config)\n{\n\tif (pipe_config->has_pch_encoder)\n\t\tintel_pch_transcoder_get_m_n(crtc, &pipe_config->dp_m_n);\n\telse\n\t\tintel_cpu_transcoder_get_m_n(crtc, pipe_config->cpu_transcoder,\n\t\t\t\t\t     &pipe_config->dp_m_n,\n\t\t\t\t\t     &pipe_config->dp_m2_n2);\n}\n\nstatic void ilk_get_fdi_m_n_config(struct intel_crtc *crtc,\n\t\t\t\t   struct intel_crtc_state *pipe_config)\n{\n\tintel_cpu_transcoder_get_m_n(crtc, pipe_config->cpu_transcoder,\n\t\t\t\t     &pipe_config->fdi_m_n, NULL);\n}\n\nstatic void ilk_get_pfit_pos_size(struct intel_crtc_state *crtc_state,\n\t\t\t\t  u32 pos, u32 size)\n{\n\tdrm_rect_init(&crtc_state->pch_pfit.dst,\n\t\t      pos >> 16, pos & 0xffff,\n\t\t      size >> 16, size & 0xffff);\n}\n\nstatic void skl_get_pfit_config(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_crtc_scaler_state *scaler_state = &crtc_state->scaler_state;\n\tint id = -1;\n\tint i;\n\n\t/* find scaler attached to this pipe */\n\tfor (i = 0; i < crtc->num_scalers; i++) {\n\t\tu32 ctl, pos, size;\n\n\t\tctl = intel_de_read(dev_priv, SKL_PS_CTRL(crtc->pipe, i));\n\t\tif ((ctl & (PS_SCALER_EN | PS_PLANE_SEL_MASK)) != PS_SCALER_EN)\n\t\t\tcontinue;\n\n\t\tid = i;\n\t\tcrtc_state->pch_pfit.enabled = true;\n\n\t\tpos = intel_de_read(dev_priv, SKL_PS_WIN_POS(crtc->pipe, i));\n\t\tsize = intel_de_read(dev_priv, SKL_PS_WIN_SZ(crtc->pipe, i));\n\n\t\tilk_get_pfit_pos_size(crtc_state, pos, size);\n\n\t\tscaler_state->scalers[i].in_use = true;\n\t\tbreak;\n\t}\n\n\tscaler_state->scaler_id = id;\n\tif (id >= 0)\n\t\tscaler_state->scaler_users |= (1 << SKL_CRTC_INDEX);\n\telse\n\t\tscaler_state->scaler_users &= ~(1 << SKL_CRTC_INDEX);\n}\n\nstatic void\nskl_get_initial_plane_config(struct intel_crtc *crtc,\n\t\t\t     struct intel_initial_plane_config *plane_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_plane *plane = to_intel_plane(crtc->base.primary);\n\tenum plane_id plane_id = plane->id;\n\tenum pipe pipe;\n\tu32 val, base, offset, stride_mult, tiling, alpha;\n\tint fourcc, pixel_format;\n\tunsigned int aligned_height;\n\tstruct drm_framebuffer *fb;\n\tstruct intel_framebuffer *intel_fb;\n\n\tif (!plane->get_hw_state(plane, &pipe))\n\t\treturn;\n\n\tdrm_WARN_ON(dev, pipe != crtc->pipe);\n\n\tintel_fb = kzalloc(sizeof(*intel_fb), GFP_KERNEL);\n\tif (!intel_fb) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"failed to alloc fb\\n\");\n\t\treturn;\n\t}\n\n\tfb = &intel_fb->base;\n\n\tfb->dev = dev;\n\n\tval = intel_de_read(dev_priv, PLANE_CTL(pipe, plane_id));\n\n\tif (INTEL_GEN(dev_priv) >= 11)\n\t\tpixel_format = val & ICL_PLANE_CTL_FORMAT_MASK;\n\telse\n\t\tpixel_format = val & PLANE_CTL_FORMAT_MASK;\n\n\tif (INTEL_GEN(dev_priv) >= 10 || IS_GEMINILAKE(dev_priv)) {\n\t\talpha = intel_de_read(dev_priv,\n\t\t\t\t      PLANE_COLOR_CTL(pipe, plane_id));\n\t\talpha &= PLANE_COLOR_ALPHA_MASK;\n\t} else {\n\t\talpha = val & PLANE_CTL_ALPHA_MASK;\n\t}\n\n\tfourcc = skl_format_to_fourcc(pixel_format,\n\t\t\t\t      val & PLANE_CTL_ORDER_RGBX, alpha);\n\tfb->format = drm_format_info(fourcc);\n\n\ttiling = val & PLANE_CTL_TILED_MASK;\n\tswitch (tiling) {\n\tcase PLANE_CTL_TILED_LINEAR:\n\t\tfb->modifier = DRM_FORMAT_MOD_LINEAR;\n\t\tbreak;\n\tcase PLANE_CTL_TILED_X:\n\t\tplane_config->tiling = I915_TILING_X;\n\t\tfb->modifier = I915_FORMAT_MOD_X_TILED;\n\t\tbreak;\n\tcase PLANE_CTL_TILED_Y:\n\t\tplane_config->tiling = I915_TILING_Y;\n\t\tif (val & PLANE_CTL_RENDER_DECOMPRESSION_ENABLE)\n\t\t\tfb->modifier = INTEL_GEN(dev_priv) >= 12 ?\n\t\t\t\tI915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS :\n\t\t\t\tI915_FORMAT_MOD_Y_TILED_CCS;\n\t\telse if (val & PLANE_CTL_MEDIA_DECOMPRESSION_ENABLE)\n\t\t\tfb->modifier = I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS;\n\t\telse\n\t\t\tfb->modifier = I915_FORMAT_MOD_Y_TILED;\n\t\tbreak;\n\tcase PLANE_CTL_TILED_YF:\n\t\tif (val & PLANE_CTL_RENDER_DECOMPRESSION_ENABLE)\n\t\t\tfb->modifier = I915_FORMAT_MOD_Yf_TILED_CCS;\n\t\telse\n\t\t\tfb->modifier = I915_FORMAT_MOD_Yf_TILED;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(tiling);\n\t\tgoto error;\n\t}\n\n\t/*\n\t * DRM_MODE_ROTATE_ is counter clockwise to stay compatible with Xrandr\n\t * while i915 HW rotation is clockwise, thats why this swapping.\n\t */\n\tswitch (val & PLANE_CTL_ROTATE_MASK) {\n\tcase PLANE_CTL_ROTATE_0:\n\t\tplane_config->rotation = DRM_MODE_ROTATE_0;\n\t\tbreak;\n\tcase PLANE_CTL_ROTATE_90:\n\t\tplane_config->rotation = DRM_MODE_ROTATE_270;\n\t\tbreak;\n\tcase PLANE_CTL_ROTATE_180:\n\t\tplane_config->rotation = DRM_MODE_ROTATE_180;\n\t\tbreak;\n\tcase PLANE_CTL_ROTATE_270:\n\t\tplane_config->rotation = DRM_MODE_ROTATE_90;\n\t\tbreak;\n\t}\n\n\tif (INTEL_GEN(dev_priv) >= 10 &&\n\t    val & PLANE_CTL_FLIP_HORIZONTAL)\n\t\tplane_config->rotation |= DRM_MODE_REFLECT_X;\n\n\tbase = intel_de_read(dev_priv, PLANE_SURF(pipe, plane_id)) & 0xfffff000;\n\tplane_config->base = base;\n\n\toffset = intel_de_read(dev_priv, PLANE_OFFSET(pipe, plane_id));\n\n\tval = intel_de_read(dev_priv, PLANE_SIZE(pipe, plane_id));\n\tfb->height = ((val >> 16) & 0xffff) + 1;\n\tfb->width = ((val >> 0) & 0xffff) + 1;\n\n\tval = intel_de_read(dev_priv, PLANE_STRIDE(pipe, plane_id));\n\tstride_mult = skl_plane_stride_mult(fb, 0, DRM_MODE_ROTATE_0);\n\tfb->pitches[0] = (val & 0x3ff) * stride_mult;\n\n\taligned_height = intel_fb_align_height(fb, 0, fb->height);\n\n\tplane_config->size = fb->pitches[0] * aligned_height;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"%s/%s with fb: size=%dx%d@%d, offset=%x, pitch %d, size 0x%x\\n\",\n\t\t    crtc->base.name, plane->base.name, fb->width, fb->height,\n\t\t    fb->format->cpp[0] * 8, base, fb->pitches[0],\n\t\t    plane_config->size);\n\n\tplane_config->fb = intel_fb;\n\treturn;\n\nerror:\n\tkfree(intel_fb);\n}\n\nstatic void ilk_get_pfit_config(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 ctl, pos, size;\n\n\tctl = intel_de_read(dev_priv, PF_CTL(crtc->pipe));\n\tif ((ctl & PF_ENABLE) == 0)\n\t\treturn;\n\n\tcrtc_state->pch_pfit.enabled = true;\n\n\tpos = intel_de_read(dev_priv, PF_WIN_POS(crtc->pipe));\n\tsize = intel_de_read(dev_priv, PF_WIN_SZ(crtc->pipe));\n\n\tilk_get_pfit_pos_size(crtc_state, pos, size);\n\n\t/*\n\t * We currently do not free assignements of panel fitters on\n\t * ivb/hsw (since we don't use the higher upscaling modes which\n\t * differentiates them) so just WARN about this case for now.\n\t */\n\tdrm_WARN_ON(&dev_priv->drm, IS_GEN(dev_priv, 7) &&\n\t\t    (ctl & PF_PIPE_SEL_MASK_IVB) != PF_PIPE_SEL_IVB(crtc->pipe));\n}\n\nstatic bool ilk_get_pipe_config(struct intel_crtc *crtc,\n\t\t\t\tstruct intel_crtc_state *pipe_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum intel_display_power_domain power_domain;\n\tintel_wakeref_t wakeref;\n\tu32 tmp;\n\tbool ret;\n\n\tpower_domain = POWER_DOMAIN_PIPE(crtc->pipe);\n\twakeref = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tpipe_config->cpu_transcoder = (enum transcoder) crtc->pipe;\n\tpipe_config->shared_dpll = NULL;\n\n\tret = false;\n\ttmp = intel_de_read(dev_priv, PIPECONF(crtc->pipe));\n\tif (!(tmp & PIPECONF_ENABLE))\n\t\tgoto out;\n\n\tswitch (tmp & PIPECONF_BPC_MASK) {\n\tcase PIPECONF_6BPC:\n\t\tpipe_config->pipe_bpp = 18;\n\t\tbreak;\n\tcase PIPECONF_8BPC:\n\t\tpipe_config->pipe_bpp = 24;\n\t\tbreak;\n\tcase PIPECONF_10BPC:\n\t\tpipe_config->pipe_bpp = 30;\n\t\tbreak;\n\tcase PIPECONF_12BPC:\n\t\tpipe_config->pipe_bpp = 36;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (tmp & PIPECONF_COLOR_RANGE_SELECT)\n\t\tpipe_config->limited_color_range = true;\n\n\tswitch (tmp & PIPECONF_OUTPUT_COLORSPACE_MASK) {\n\tcase PIPECONF_OUTPUT_COLORSPACE_YUV601:\n\tcase PIPECONF_OUTPUT_COLORSPACE_YUV709:\n\t\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_YCBCR444;\n\t\tbreak;\n\tdefault:\n\t\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_RGB;\n\t\tbreak;\n\t}\n\n\tpipe_config->gamma_mode = (tmp & PIPECONF_GAMMA_MODE_MASK_ILK) >>\n\t\tPIPECONF_GAMMA_MODE_SHIFT;\n\n\tpipe_config->csc_mode = intel_de_read(dev_priv,\n\t\t\t\t\t      PIPE_CSC_MODE(crtc->pipe));\n\n\ti9xx_get_pipe_color_config(pipe_config);\n\tintel_color_get_config(pipe_config);\n\n\tif (intel_de_read(dev_priv, PCH_TRANSCONF(crtc->pipe)) & TRANS_ENABLE) {\n\t\tstruct intel_shared_dpll *pll;\n\t\tenum intel_dpll_id pll_id;\n\n\t\tpipe_config->has_pch_encoder = true;\n\n\t\ttmp = intel_de_read(dev_priv, FDI_RX_CTL(crtc->pipe));\n\t\tpipe_config->fdi_lanes = ((FDI_DP_PORT_WIDTH_MASK & tmp) >>\n\t\t\t\t\t  FDI_DP_PORT_WIDTH_SHIFT) + 1;\n\n\t\tilk_get_fdi_m_n_config(crtc, pipe_config);\n\n\t\tif (HAS_PCH_IBX(dev_priv)) {\n\t\t\t/*\n\t\t\t * The pipe->pch transcoder and pch transcoder->pll\n\t\t\t * mapping is fixed.\n\t\t\t */\n\t\t\tpll_id = (enum intel_dpll_id) crtc->pipe;\n\t\t} else {\n\t\t\ttmp = intel_de_read(dev_priv, PCH_DPLL_SEL);\n\t\t\tif (tmp & TRANS_DPLLB_SEL(crtc->pipe))\n\t\t\t\tpll_id = DPLL_ID_PCH_PLL_B;\n\t\t\telse\n\t\t\t\tpll_id= DPLL_ID_PCH_PLL_A;\n\t\t}\n\n\t\tpipe_config->shared_dpll =\n\t\t\tintel_get_shared_dpll_by_id(dev_priv, pll_id);\n\t\tpll = pipe_config->shared_dpll;\n\n\t\tdrm_WARN_ON(dev, !pll->info->funcs->get_hw_state(dev_priv, pll,\n\t\t\t\t\t\t &pipe_config->dpll_hw_state));\n\n\t\ttmp = pipe_config->dpll_hw_state.dpll;\n\t\tpipe_config->pixel_multiplier =\n\t\t\t((tmp & PLL_REF_SDVO_HDMI_MULTIPLIER_MASK)\n\t\t\t >> PLL_REF_SDVO_HDMI_MULTIPLIER_SHIFT) + 1;\n\n\t\tilk_pch_clock_get(crtc, pipe_config);\n\t} else {\n\t\tpipe_config->pixel_multiplier = 1;\n\t}\n\n\tintel_get_pipe_timings(crtc, pipe_config);\n\tintel_get_pipe_src_size(crtc, pipe_config);\n\n\tilk_get_pfit_config(pipe_config);\n\n\tret = true;\n\nout:\n\tintel_display_power_put(dev_priv, power_domain, wakeref);\n\n\treturn ret;\n}\n\nstatic int hsw_crtc_compute_clock(struct intel_crtc *crtc,\n\t\t\t\t  struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_atomic_state *state =\n\t\tto_intel_atomic_state(crtc_state->uapi.state);\n\n\tif (!intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DSI) ||\n\t    INTEL_GEN(dev_priv) >= 11) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tintel_get_crtc_new_encoder(state, crtc_state);\n\n\t\tif (!intel_reserve_shared_dplls(state, crtc, encoder)) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"failed to find PLL for pipe %c\\n\",\n\t\t\t\t    pipe_name(crtc->pipe));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void cnl_get_ddi_pll(struct drm_i915_private *dev_priv, enum port port,\n\t\t\t    struct intel_crtc_state *pipe_config)\n{\n\tenum intel_dpll_id id;\n\tu32 temp;\n\n\ttemp = intel_de_read(dev_priv, DPCLKA_CFGCR0) & DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(port);\n\tid = temp >> DPCLKA_CFGCR0_DDI_CLK_SEL_SHIFT(port);\n\n\tif (drm_WARN_ON(&dev_priv->drm, id < SKL_DPLL0 || id > SKL_DPLL2))\n\t\treturn;\n\n\tpipe_config->shared_dpll = intel_get_shared_dpll_by_id(dev_priv, id);\n}\n\nstatic void icl_get_ddi_pll(struct drm_i915_private *dev_priv, enum port port,\n\t\t\t    struct intel_crtc_state *pipe_config)\n{\n\tenum phy phy = intel_port_to_phy(dev_priv, port);\n\tenum icl_port_dpll_id port_dpll_id;\n\tenum intel_dpll_id id;\n\tu32 temp;\n\n\tif (intel_phy_is_combo(dev_priv, phy)) {\n\t\tu32 mask, shift;\n\n\t\tif (IS_ROCKETLAKE(dev_priv)) {\n\t\t\tmask = RKL_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy);\n\t\t\tshift = RKL_DPCLKA_CFGCR0_DDI_CLK_SEL_SHIFT(phy);\n\t\t} else {\n\t\t\tmask = ICL_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy);\n\t\t\tshift = ICL_DPCLKA_CFGCR0_DDI_CLK_SEL_SHIFT(phy);\n\t\t}\n\n\t\ttemp = intel_de_read(dev_priv, ICL_DPCLKA_CFGCR0) & mask;\n\t\tid = temp >> shift;\n\t\tport_dpll_id = ICL_PORT_DPLL_DEFAULT;\n\t} else if (intel_phy_is_tc(dev_priv, phy)) {\n\t\tu32 clk_sel = intel_de_read(dev_priv, DDI_CLK_SEL(port)) & DDI_CLK_SEL_MASK;\n\n\t\tif (clk_sel == DDI_CLK_SEL_MG) {\n\t\t\tid = icl_tc_port_to_pll_id(intel_port_to_tc(dev_priv,\n\t\t\t\t\t\t\t\t    port));\n\t\t\tport_dpll_id = ICL_PORT_DPLL_MG_PHY;\n\t\t} else {\n\t\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t\t    clk_sel < DDI_CLK_SEL_TBT_162);\n\t\t\tid = DPLL_ID_ICL_TBTPLL;\n\t\t\tport_dpll_id = ICL_PORT_DPLL_DEFAULT;\n\t\t}\n\t} else {\n\t\tdrm_WARN(&dev_priv->drm, 1, \"Invalid port %x\\n\", port);\n\t\treturn;\n\t}\n\n\tpipe_config->icl_port_dplls[port_dpll_id].pll =\n\t\tintel_get_shared_dpll_by_id(dev_priv, id);\n\n\ticl_set_active_port_dpll(pipe_config, port_dpll_id);\n}\n\nstatic void bxt_get_ddi_pll(struct drm_i915_private *dev_priv,\n\t\t\t\tenum port port,\n\t\t\t\tstruct intel_crtc_state *pipe_config)\n{\n\tenum intel_dpll_id id;\n\n\tswitch (port) {\n\tcase PORT_A:\n\t\tid = DPLL_ID_SKL_DPLL0;\n\t\tbreak;\n\tcase PORT_B:\n\t\tid = DPLL_ID_SKL_DPLL1;\n\t\tbreak;\n\tcase PORT_C:\n\t\tid = DPLL_ID_SKL_DPLL2;\n\t\tbreak;\n\tdefault:\n\t\tdrm_err(&dev_priv->drm, \"Incorrect port type\\n\");\n\t\treturn;\n\t}\n\n\tpipe_config->shared_dpll = intel_get_shared_dpll_by_id(dev_priv, id);\n}\n\nstatic void skl_get_ddi_pll(struct drm_i915_private *dev_priv, enum port port,\n\t\t\t    struct intel_crtc_state *pipe_config)\n{\n\tenum intel_dpll_id id;\n\tu32 temp;\n\n\ttemp = intel_de_read(dev_priv, DPLL_CTRL2) & DPLL_CTRL2_DDI_CLK_SEL_MASK(port);\n\tid = temp >> (port * 3 + 1);\n\n\tif (drm_WARN_ON(&dev_priv->drm, id < SKL_DPLL0 || id > SKL_DPLL3))\n\t\treturn;\n\n\tpipe_config->shared_dpll = intel_get_shared_dpll_by_id(dev_priv, id);\n}\n\nstatic void hsw_get_ddi_pll(struct drm_i915_private *dev_priv, enum port port,\n\t\t\t    struct intel_crtc_state *pipe_config)\n{\n\tenum intel_dpll_id id;\n\tu32 ddi_pll_sel = intel_de_read(dev_priv, PORT_CLK_SEL(port));\n\n\tswitch (ddi_pll_sel) {\n\tcase PORT_CLK_SEL_WRPLL1:\n\t\tid = DPLL_ID_WRPLL1;\n\t\tbreak;\n\tcase PORT_CLK_SEL_WRPLL2:\n\t\tid = DPLL_ID_WRPLL2;\n\t\tbreak;\n\tcase PORT_CLK_SEL_SPLL:\n\t\tid = DPLL_ID_SPLL;\n\t\tbreak;\n\tcase PORT_CLK_SEL_LCPLL_810:\n\t\tid = DPLL_ID_LCPLL_810;\n\t\tbreak;\n\tcase PORT_CLK_SEL_LCPLL_1350:\n\t\tid = DPLL_ID_LCPLL_1350;\n\t\tbreak;\n\tcase PORT_CLK_SEL_LCPLL_2700:\n\t\tid = DPLL_ID_LCPLL_2700;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(ddi_pll_sel);\n\t\tfallthrough;\n\tcase PORT_CLK_SEL_NONE:\n\t\treturn;\n\t}\n\n\tpipe_config->shared_dpll = intel_get_shared_dpll_by_id(dev_priv, id);\n}\n\nstatic bool hsw_get_transcoder_state(struct intel_crtc *crtc,\n\t\t\t\t     struct intel_crtc_state *pipe_config,\n\t\t\t\t     u64 *power_domain_mask,\n\t\t\t\t     intel_wakeref_t *wakerefs)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum intel_display_power_domain power_domain;\n\tunsigned long panel_transcoder_mask = BIT(TRANSCODER_EDP);\n\tunsigned long enabled_panel_transcoders = 0;\n\tenum transcoder panel_transcoder;\n\tintel_wakeref_t wf;\n\tu32 tmp;\n\n\tif (INTEL_GEN(dev_priv) >= 11)\n\t\tpanel_transcoder_mask |=\n\t\t\tBIT(TRANSCODER_DSI_0) | BIT(TRANSCODER_DSI_1);\n\n\t/*\n\t * The pipe->transcoder mapping is fixed with the exception of the eDP\n\t * and DSI transcoders handled below.\n\t */\n\tpipe_config->cpu_transcoder = (enum transcoder) crtc->pipe;\n\n\t/*\n\t * XXX: Do intel_display_power_get_if_enabled before reading this (for\n\t * consistency and less surprising code; it's in always on power).\n\t */\n\tfor_each_cpu_transcoder_masked(dev_priv, panel_transcoder,\n\t\t\t\t       panel_transcoder_mask) {\n\t\tbool force_thru = false;\n\t\tenum pipe trans_pipe;\n\n\t\ttmp = intel_de_read(dev_priv,\n\t\t\t\t    TRANS_DDI_FUNC_CTL(panel_transcoder));\n\t\tif (!(tmp & TRANS_DDI_FUNC_ENABLE))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Log all enabled ones, only use the first one.\n\t\t *\n\t\t * FIXME: This won't work for two separate DSI displays.\n\t\t */\n\t\tenabled_panel_transcoders |= BIT(panel_transcoder);\n\t\tif (enabled_panel_transcoders != BIT(panel_transcoder))\n\t\t\tcontinue;\n\n\t\tswitch (tmp & TRANS_DDI_EDP_INPUT_MASK) {\n\t\tdefault:\n\t\t\tdrm_WARN(dev, 1,\n\t\t\t\t \"unknown pipe linked to transcoder %s\\n\",\n\t\t\t\t transcoder_name(panel_transcoder));\n\t\t\tfallthrough;\n\t\tcase TRANS_DDI_EDP_INPUT_A_ONOFF:\n\t\t\tforce_thru = true;\n\t\t\tfallthrough;\n\t\tcase TRANS_DDI_EDP_INPUT_A_ON:\n\t\t\ttrans_pipe = PIPE_A;\n\t\t\tbreak;\n\t\tcase TRANS_DDI_EDP_INPUT_B_ONOFF:\n\t\t\ttrans_pipe = PIPE_B;\n\t\t\tbreak;\n\t\tcase TRANS_DDI_EDP_INPUT_C_ONOFF:\n\t\t\ttrans_pipe = PIPE_C;\n\t\t\tbreak;\n\t\tcase TRANS_DDI_EDP_INPUT_D_ONOFF:\n\t\t\ttrans_pipe = PIPE_D;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (trans_pipe == crtc->pipe) {\n\t\t\tpipe_config->cpu_transcoder = panel_transcoder;\n\t\t\tpipe_config->pch_pfit.force_thru = force_thru;\n\t\t}\n\t}\n\n\t/*\n\t * Valid combos: none, eDP, DSI0, DSI1, DSI0+DSI1\n\t */\n\tdrm_WARN_ON(dev, (enabled_panel_transcoders & BIT(TRANSCODER_EDP)) &&\n\t\t    enabled_panel_transcoders != BIT(TRANSCODER_EDP));\n\n\tpower_domain = POWER_DOMAIN_TRANSCODER(pipe_config->cpu_transcoder);\n\tdrm_WARN_ON(dev, *power_domain_mask & BIT_ULL(power_domain));\n\n\twf = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\tif (!wf)\n\t\treturn false;\n\n\twakerefs[power_domain] = wf;\n\t*power_domain_mask |= BIT_ULL(power_domain);\n\n\ttmp = intel_de_read(dev_priv, PIPECONF(pipe_config->cpu_transcoder));\n\n\treturn tmp & PIPECONF_ENABLE;\n}\n\nstatic bool bxt_get_dsi_transcoder_state(struct intel_crtc *crtc,\n\t\t\t\t\t struct intel_crtc_state *pipe_config,\n\t\t\t\t\t u64 *power_domain_mask,\n\t\t\t\t\t intel_wakeref_t *wakerefs)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum intel_display_power_domain power_domain;\n\tenum transcoder cpu_transcoder;\n\tintel_wakeref_t wf;\n\tenum port port;\n\tu32 tmp;\n\n\tfor_each_port_masked(port, BIT(PORT_A) | BIT(PORT_C)) {\n\t\tif (port == PORT_A)\n\t\t\tcpu_transcoder = TRANSCODER_DSI_A;\n\t\telse\n\t\t\tcpu_transcoder = TRANSCODER_DSI_C;\n\n\t\tpower_domain = POWER_DOMAIN_TRANSCODER(cpu_transcoder);\n\t\tdrm_WARN_ON(dev, *power_domain_mask & BIT_ULL(power_domain));\n\n\t\twf = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\t\tif (!wf)\n\t\t\tcontinue;\n\n\t\twakerefs[power_domain] = wf;\n\t\t*power_domain_mask |= BIT_ULL(power_domain);\n\n\t\t/*\n\t\t * The PLL needs to be enabled with a valid divider\n\t\t * configuration, otherwise accessing DSI registers will hang\n\t\t * the machine. See BSpec North Display Engine\n\t\t * registers/MIPI[BXT]. We can break out here early, since we\n\t\t * need the same DSI PLL to be enabled for both DSI ports.\n\t\t */\n\t\tif (!bxt_dsi_pll_is_enabled(dev_priv))\n\t\t\tbreak;\n\n\t\t/* XXX: this works for video mode only */\n\t\ttmp = intel_de_read(dev_priv, BXT_MIPI_PORT_CTRL(port));\n\t\tif (!(tmp & DPI_ENABLE))\n\t\t\tcontinue;\n\n\t\ttmp = intel_de_read(dev_priv, MIPI_CTRL(port));\n\t\tif ((tmp & BXT_PIPE_SELECT_MASK) != BXT_PIPE_SELECT(crtc->pipe))\n\t\t\tcontinue;\n\n\t\tpipe_config->cpu_transcoder = cpu_transcoder;\n\t\tbreak;\n\t}\n\n\treturn transcoder_is_dsi(pipe_config->cpu_transcoder);\n}\n\nstatic void hsw_get_ddi_port_state(struct intel_crtc *crtc,\n\t\t\t\t   struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = pipe_config->cpu_transcoder;\n\tstruct intel_shared_dpll *pll;\n\tenum port port;\n\tu32 tmp;\n\n\tif (transcoder_is_dsi(cpu_transcoder)) {\n\t\tport = (cpu_transcoder == TRANSCODER_DSI_A) ?\n\t\t\t\t\t\tPORT_A : PORT_B;\n\t} else {\n\t\ttmp = intel_de_read(dev_priv,\n\t\t\t\t    TRANS_DDI_FUNC_CTL(cpu_transcoder));\n\t\tif (INTEL_GEN(dev_priv) >= 12)\n\t\t\tport = TGL_TRANS_DDI_FUNC_CTL_VAL_TO_PORT(tmp);\n\t\telse\n\t\t\tport = TRANS_DDI_FUNC_CTL_VAL_TO_PORT(tmp);\n\t}\n\n\tif (INTEL_GEN(dev_priv) >= 11)\n\t\ticl_get_ddi_pll(dev_priv, port, pipe_config);\n\telse if (IS_CANNONLAKE(dev_priv))\n\t\tcnl_get_ddi_pll(dev_priv, port, pipe_config);\n\telse if (IS_GEN9_BC(dev_priv))\n\t\tskl_get_ddi_pll(dev_priv, port, pipe_config);\n\telse if (IS_GEN9_LP(dev_priv))\n\t\tbxt_get_ddi_pll(dev_priv, port, pipe_config);\n\telse\n\t\thsw_get_ddi_pll(dev_priv, port, pipe_config);\n\n\tpll = pipe_config->shared_dpll;\n\tif (pll) {\n\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t    !pll->info->funcs->get_hw_state(dev_priv, pll,\n\t\t\t\t\t\t&pipe_config->dpll_hw_state));\n\t}\n\n\t/*\n\t * Haswell has only FDI/PCH transcoder A. It is which is connected to\n\t * DDI E. So just check whether this pipe is wired to DDI E and whether\n\t * the PCH transcoder is on.\n\t */\n\tif (INTEL_GEN(dev_priv) < 9 &&\n\t    (port == PORT_E) && intel_de_read(dev_priv, LPT_TRANSCONF) & TRANS_ENABLE) {\n\t\tpipe_config->has_pch_encoder = true;\n\n\t\ttmp = intel_de_read(dev_priv, FDI_RX_CTL(PIPE_A));\n\t\tpipe_config->fdi_lanes = ((FDI_DP_PORT_WIDTH_MASK & tmp) >>\n\t\t\t\t\t  FDI_DP_PORT_WIDTH_SHIFT) + 1;\n\n\t\tilk_get_fdi_m_n_config(crtc, pipe_config);\n\t}\n}\n\nstatic bool hsw_get_pipe_config(struct intel_crtc *crtc,\n\t\t\t\tstruct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tintel_wakeref_t wakerefs[POWER_DOMAIN_NUM], wf;\n\tenum intel_display_power_domain power_domain;\n\tu64 power_domain_mask;\n\tbool active;\n\tu32 tmp;\n\n\tpipe_config->master_transcoder = INVALID_TRANSCODER;\n\n\tpower_domain = POWER_DOMAIN_PIPE(crtc->pipe);\n\twf = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\tif (!wf)\n\t\treturn false;\n\n\twakerefs[power_domain] = wf;\n\tpower_domain_mask = BIT_ULL(power_domain);\n\n\tpipe_config->shared_dpll = NULL;\n\n\tactive = hsw_get_transcoder_state(crtc, pipe_config,\n\t\t\t\t\t  &power_domain_mask, wakerefs);\n\n\tif (IS_GEN9_LP(dev_priv) &&\n\t    bxt_get_dsi_transcoder_state(crtc, pipe_config,\n\t\t\t\t\t &power_domain_mask, wakerefs)) {\n\t\tdrm_WARN_ON(&dev_priv->drm, active);\n\t\tactive = true;\n\t}\n\n\tif (!active)\n\t\tgoto out;\n\n\tif (!transcoder_is_dsi(pipe_config->cpu_transcoder) ||\n\t    INTEL_GEN(dev_priv) >= 11) {\n\t\thsw_get_ddi_port_state(crtc, pipe_config);\n\t\tintel_get_pipe_timings(crtc, pipe_config);\n\t}\n\n\tintel_get_pipe_src_size(crtc, pipe_config);\n\n\tif (IS_HASWELL(dev_priv)) {\n\t\tu32 tmp = intel_de_read(dev_priv,\n\t\t\t\t\tPIPECONF(pipe_config->cpu_transcoder));\n\n\t\tif (tmp & PIPECONF_OUTPUT_COLORSPACE_YUV_HSW)\n\t\t\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_YCBCR444;\n\t\telse\n\t\t\tpipe_config->output_format = INTEL_OUTPUT_FORMAT_RGB;\n\t} else {\n\t\tpipe_config->output_format =\n\t\t\tbdw_get_pipemisc_output_format(crtc);\n\n\t\t/*\n\t\t * Currently there is no interface defined to\n\t\t * check user preference between RGB/YCBCR444\n\t\t * or YCBCR420. So the only possible case for\n\t\t * YCBCR444 usage is driving YCBCR420 output\n\t\t * with LSPCON, when pipe is configured for\n\t\t * YCBCR444 output and LSPCON takes care of\n\t\t * downsampling it.\n\t\t */\n\t\tpipe_config->lspcon_downsampling =\n\t\t\tpipe_config->output_format == INTEL_OUTPUT_FORMAT_YCBCR444;\n\t}\n\n\tpipe_config->gamma_mode = intel_de_read(dev_priv,\n\t\t\t\t\t\tGAMMA_MODE(crtc->pipe));\n\n\tpipe_config->csc_mode = intel_de_read(dev_priv,\n\t\t\t\t\t      PIPE_CSC_MODE(crtc->pipe));\n\n\tif (INTEL_GEN(dev_priv) >= 9) {\n\t\ttmp = intel_de_read(dev_priv, SKL_BOTTOM_COLOR(crtc->pipe));\n\n\t\tif (tmp & SKL_BOTTOM_COLOR_GAMMA_ENABLE)\n\t\t\tpipe_config->gamma_enable = true;\n\n\t\tif (tmp & SKL_BOTTOM_COLOR_CSC_ENABLE)\n\t\t\tpipe_config->csc_enable = true;\n\t} else {\n\t\ti9xx_get_pipe_color_config(pipe_config);\n\t}\n\n\tintel_color_get_config(pipe_config);\n\n\ttmp = intel_de_read(dev_priv, WM_LINETIME(crtc->pipe));\n\tpipe_config->linetime = REG_FIELD_GET(HSW_LINETIME_MASK, tmp);\n\tif (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))\n\t\tpipe_config->ips_linetime =\n\t\t\tREG_FIELD_GET(HSW_IPS_LINETIME_MASK, tmp);\n\n\tpower_domain = POWER_DOMAIN_PIPE_PANEL_FITTER(crtc->pipe);\n\tdrm_WARN_ON(&dev_priv->drm, power_domain_mask & BIT_ULL(power_domain));\n\n\twf = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\tif (wf) {\n\t\twakerefs[power_domain] = wf;\n\t\tpower_domain_mask |= BIT_ULL(power_domain);\n\n\t\tif (INTEL_GEN(dev_priv) >= 9)\n\t\t\tskl_get_pfit_config(pipe_config);\n\t\telse\n\t\t\tilk_get_pfit_config(pipe_config);\n\t}\n\n\tif (hsw_crtc_supports_ips(crtc)) {\n\t\tif (IS_HASWELL(dev_priv))\n\t\t\tpipe_config->ips_enabled = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t\t IPS_CTL) & IPS_ENABLE;\n\t\telse {\n\t\t\t/*\n\t\t\t * We cannot readout IPS state on broadwell, set to\n\t\t\t * true so we can set it to a defined state on first\n\t\t\t * commit.\n\t\t\t */\n\t\t\tpipe_config->ips_enabled = true;\n\t\t}\n\t}\n\n\tif (pipe_config->cpu_transcoder != TRANSCODER_EDP &&\n\t    !transcoder_is_dsi(pipe_config->cpu_transcoder)) {\n\t\tpipe_config->pixel_multiplier =\n\t\t\tintel_de_read(dev_priv,\n\t\t\t\t      PIPE_MULT(pipe_config->cpu_transcoder)) + 1;\n\t} else {\n\t\tpipe_config->pixel_multiplier = 1;\n\t}\n\nout:\n\tfor_each_power_domain(power_domain, power_domain_mask)\n\t\tintel_display_power_put(dev_priv,\n\t\t\t\t\tpower_domain, wakerefs[power_domain]);\n\n\treturn active;\n}\n\nstatic u32 intel_cursor_base(const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tconst struct drm_i915_gem_object *obj = intel_fb_obj(fb);\n\tu32 base;\n\n\tif (INTEL_INFO(dev_priv)->display.cursor_needs_physical)\n\t\tbase = sg_dma_address(obj->mm.pages->sgl);\n\telse\n\t\tbase = intel_plane_ggtt_offset(plane_state);\n\n\treturn base + plane_state->color_plane[0].offset;\n}\n\nstatic u32 intel_cursor_position(const struct intel_plane_state *plane_state)\n{\n\tint x = plane_state->uapi.dst.x1;\n\tint y = plane_state->uapi.dst.y1;\n\tu32 pos = 0;\n\n\tif (x < 0) {\n\t\tpos |= CURSOR_POS_SIGN << CURSOR_X_SHIFT;\n\t\tx = -x;\n\t}\n\tpos |= x << CURSOR_X_SHIFT;\n\n\tif (y < 0) {\n\t\tpos |= CURSOR_POS_SIGN << CURSOR_Y_SHIFT;\n\t\ty = -y;\n\t}\n\tpos |= y << CURSOR_Y_SHIFT;\n\n\treturn pos;\n}\n\nstatic bool intel_cursor_size_ok(const struct intel_plane_state *plane_state)\n{\n\tconst struct drm_mode_config *config =\n\t\t&plane_state->uapi.plane->dev->mode_config;\n\tint width = drm_rect_width(&plane_state->uapi.dst);\n\tint height = drm_rect_height(&plane_state->uapi.dst);\n\n\treturn width > 0 && width <= config->cursor_width &&\n\t\theight > 0 && height <= config->cursor_height;\n}\n\nstatic int intel_cursor_check_surface(struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tunsigned int rotation = plane_state->hw.rotation;\n\tint src_x, src_y;\n\tu32 offset;\n\tint ret;\n\n\tret = intel_plane_compute_gtt(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!plane_state->uapi.visible)\n\t\treturn 0;\n\n\tsrc_x = plane_state->uapi.src.x1 >> 16;\n\tsrc_y = plane_state->uapi.src.y1 >> 16;\n\n\tintel_add_fb_offsets(&src_x, &src_y, plane_state, 0);\n\toffset = intel_plane_compute_aligned_offset(&src_x, &src_y,\n\t\t\t\t\t\t    plane_state, 0);\n\n\tif (src_x != 0 || src_y != 0) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Arbitrary cursor panning not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Put the final coordinates back so that the src\n\t * coordinate checks will see the right values.\n\t */\n\tdrm_rect_translate_to(&plane_state->uapi.src,\n\t\t\t      src_x << 16, src_y << 16);\n\n\t/* ILK+ do this automagically in hardware */\n\tif (HAS_GMCH(dev_priv) && rotation & DRM_MODE_ROTATE_180) {\n\t\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\t\tint src_w = drm_rect_width(&plane_state->uapi.src) >> 16;\n\t\tint src_h = drm_rect_height(&plane_state->uapi.src) >> 16;\n\n\t\toffset += (src_h * src_w - 1) * fb->format->cpp[0];\n\t}\n\n\tplane_state->color_plane[0].offset = offset;\n\tplane_state->color_plane[0].x = src_x;\n\tplane_state->color_plane[0].y = src_y;\n\n\treturn 0;\n}\n\nstatic int intel_check_cursor(struct intel_crtc_state *crtc_state,\n\t\t\t      struct intel_plane_state *plane_state)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tint ret;\n\n\tif (fb && fb->modifier != DRM_FORMAT_MOD_LINEAR) {\n\t\tdrm_dbg_kms(&i915->drm, \"cursor cannot be tiled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = drm_atomic_helper_check_plane_state(&plane_state->uapi,\n\t\t\t\t\t\t  &crtc_state->uapi,\n\t\t\t\t\t\t  DRM_PLANE_HELPER_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_HELPER_NO_SCALING,\n\t\t\t\t\t\t  true, true);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Use the unclipped src/dst rectangles, which we program to hw */\n\tplane_state->uapi.src = drm_plane_state_src(&plane_state->uapi);\n\tplane_state->uapi.dst = drm_plane_state_dest(&plane_state->uapi);\n\n\tret = intel_cursor_check_surface(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!plane_state->uapi.visible)\n\t\treturn 0;\n\n\tret = intel_plane_check_src_coordinates(plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic unsigned int\ni845_cursor_max_stride(struct intel_plane *plane,\n\t\t       u32 pixel_format, u64 modifier,\n\t\t       unsigned int rotation)\n{\n\treturn 2048;\n}\n\nstatic u32 i845_cursor_ctl_crtc(const struct intel_crtc_state *crtc_state)\n{\n\tu32 cntl = 0;\n\n\tif (crtc_state->gamma_enable)\n\t\tcntl |= CURSOR_GAMMA_ENABLE;\n\n\treturn cntl;\n}\n\nstatic u32 i845_cursor_ctl(const struct intel_crtc_state *crtc_state,\n\t\t\t   const struct intel_plane_state *plane_state)\n{\n\treturn CURSOR_ENABLE |\n\t\tCURSOR_FORMAT_ARGB |\n\t\tCURSOR_STRIDE(plane_state->color_plane[0].stride);\n}\n\nstatic bool i845_cursor_size_ok(const struct intel_plane_state *plane_state)\n{\n\tint width = drm_rect_width(&plane_state->uapi.dst);\n\n\t/*\n\t * 845g/865g are only limited by the width of their cursors,\n\t * the height is arbitrary up to the precision of the register.\n\t */\n\treturn intel_cursor_size_ok(plane_state) && IS_ALIGNED(width, 64);\n}\n\nstatic int i845_check_cursor(struct intel_crtc_state *crtc_state,\n\t\t\t     struct intel_plane_state *plane_state)\n{\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tstruct drm_i915_private *i915 = to_i915(plane_state->uapi.plane->dev);\n\tint ret;\n\n\tret = intel_check_cursor(crtc_state, plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\t/* if we want to turn off the cursor ignore width and height */\n\tif (!fb)\n\t\treturn 0;\n\n\t/* Check for which cursor types we support */\n\tif (!i845_cursor_size_ok(plane_state)) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Cursor dimension %dx%d not supported\\n\",\n\t\t\t    drm_rect_width(&plane_state->uapi.dst),\n\t\t\t    drm_rect_height(&plane_state->uapi.dst));\n\t\treturn -EINVAL;\n\t}\n\n\tdrm_WARN_ON(&i915->drm, plane_state->uapi.visible &&\n\t\t    plane_state->color_plane[0].stride != fb->pitches[0]);\n\n\tswitch (fb->pitches[0]) {\n\tcase 256:\n\tcase 512:\n\tcase 1024:\n\tcase 2048:\n\t\tbreak;\n\tdefault:\n\t\t drm_dbg_kms(&i915->drm, \"Invalid cursor stride (%u)\\n\",\n\t\t\t     fb->pitches[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tplane_state->ctl = i845_cursor_ctl(crtc_state, plane_state);\n\n\treturn 0;\n}\n\nstatic void i845_update_cursor(struct intel_plane *plane,\n\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t       const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tu32 cntl = 0, base = 0, pos = 0, size = 0;\n\tunsigned long irqflags;\n\n\tif (plane_state && plane_state->uapi.visible) {\n\t\tunsigned int width = drm_rect_width(&plane_state->uapi.dst);\n\t\tunsigned int height = drm_rect_height(&plane_state->uapi.dst);\n\n\t\tcntl = plane_state->ctl |\n\t\t\ti845_cursor_ctl_crtc(crtc_state);\n\n\t\tsize = (height << 12) | width;\n\n\t\tbase = intel_cursor_base(plane_state);\n\t\tpos = intel_cursor_position(plane_state);\n\t}\n\n\tspin_lock_irqsave(&dev_priv->uncore.lock, irqflags);\n\n\t/* On these chipsets we can only modify the base/size/stride\n\t * whilst the cursor is disabled.\n\t */\n\tif (plane->cursor.base != base ||\n\t    plane->cursor.size != size ||\n\t    plane->cursor.cntl != cntl) {\n\t\tintel_de_write_fw(dev_priv, CURCNTR(PIPE_A), 0);\n\t\tintel_de_write_fw(dev_priv, CURBASE(PIPE_A), base);\n\t\tintel_de_write_fw(dev_priv, CURSIZE, size);\n\t\tintel_de_write_fw(dev_priv, CURPOS(PIPE_A), pos);\n\t\tintel_de_write_fw(dev_priv, CURCNTR(PIPE_A), cntl);\n\n\t\tplane->cursor.base = base;\n\t\tplane->cursor.size = size;\n\t\tplane->cursor.cntl = cntl;\n\t} else {\n\t\tintel_de_write_fw(dev_priv, CURPOS(PIPE_A), pos);\n\t}\n\n\tspin_unlock_irqrestore(&dev_priv->uncore.lock, irqflags);\n}\n\nstatic void i845_disable_cursor(struct intel_plane *plane,\n\t\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\ti845_update_cursor(plane, crtc_state, NULL);\n}\n\nstatic bool i845_cursor_get_hw_state(struct intel_plane *plane,\n\t\t\t\t     enum pipe *pipe)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum intel_display_power_domain power_domain;\n\tintel_wakeref_t wakeref;\n\tbool ret;\n\n\tpower_domain = POWER_DOMAIN_PIPE(PIPE_A);\n\twakeref = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tret = intel_de_read(dev_priv, CURCNTR(PIPE_A)) & CURSOR_ENABLE;\n\n\t*pipe = PIPE_A;\n\n\tintel_display_power_put(dev_priv, power_domain, wakeref);\n\n\treturn ret;\n}\n\nstatic unsigned int\ni9xx_cursor_max_stride(struct intel_plane *plane,\n\t\t       u32 pixel_format, u64 modifier,\n\t\t       unsigned int rotation)\n{\n\treturn plane->base.dev->mode_config.cursor_width * 4;\n}\n\nstatic u32 i9xx_cursor_ctl_crtc(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tu32 cntl = 0;\n\n\tif (INTEL_GEN(dev_priv) >= 11)\n\t\treturn cntl;\n\n\tif (crtc_state->gamma_enable)\n\t\tcntl = MCURSOR_GAMMA_ENABLE;\n\n\tif (crtc_state->csc_enable)\n\t\tcntl |= MCURSOR_PIPE_CSC_ENABLE;\n\n\tif (INTEL_GEN(dev_priv) < 5 && !IS_G4X(dev_priv))\n\t\tcntl |= MCURSOR_PIPE_SELECT(crtc->pipe);\n\n\treturn cntl;\n}\n\nstatic u32 i9xx_cursor_ctl(const struct intel_crtc_state *crtc_state,\n\t\t\t   const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tu32 cntl = 0;\n\n\tif (IS_GEN(dev_priv, 6) || IS_IVYBRIDGE(dev_priv))\n\t\tcntl |= MCURSOR_TRICKLE_FEED_DISABLE;\n\n\tswitch (drm_rect_width(&plane_state->uapi.dst)) {\n\tcase 64:\n\t\tcntl |= MCURSOR_MODE_64_ARGB_AX;\n\t\tbreak;\n\tcase 128:\n\t\tcntl |= MCURSOR_MODE_128_ARGB_AX;\n\t\tbreak;\n\tcase 256:\n\t\tcntl |= MCURSOR_MODE_256_ARGB_AX;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(drm_rect_width(&plane_state->uapi.dst));\n\t\treturn 0;\n\t}\n\n\tif (plane_state->hw.rotation & DRM_MODE_ROTATE_180)\n\t\tcntl |= MCURSOR_ROTATE_180;\n\n\treturn cntl;\n}\n\nstatic bool i9xx_cursor_size_ok(const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(plane_state->uapi.plane->dev);\n\tint width = drm_rect_width(&plane_state->uapi.dst);\n\tint height = drm_rect_height(&plane_state->uapi.dst);\n\n\tif (!intel_cursor_size_ok(plane_state))\n\t\treturn false;\n\n\t/* Cursor width is limited to a few power-of-two sizes */\n\tswitch (width) {\n\tcase 256:\n\tcase 128:\n\tcase 64:\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t/*\n\t * IVB+ have CUR_FBC_CTL which allows an arbitrary cursor\n\t * height from 8 lines up to the cursor width, when the\n\t * cursor is not rotated. Everything else requires square\n\t * cursors.\n\t */\n\tif (HAS_CUR_FBC(dev_priv) &&\n\t    plane_state->hw.rotation & DRM_MODE_ROTATE_0) {\n\t\tif (height < 8 || height > width)\n\t\t\treturn false;\n\t} else {\n\t\tif (height != width)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int i9xx_check_cursor(struct intel_crtc_state *crtc_state,\n\t\t\t     struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tenum pipe pipe = plane->pipe;\n\tint ret;\n\n\tret = intel_check_cursor(crtc_state, plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\t/* if we want to turn off the cursor ignore width and height */\n\tif (!fb)\n\t\treturn 0;\n\n\t/* Check for which cursor types we support */\n\tif (!i9xx_cursor_size_ok(plane_state)) {\n\t\tdrm_dbg(&dev_priv->drm,\n\t\t\t\"Cursor dimension %dx%d not supported\\n\",\n\t\t\tdrm_rect_width(&plane_state->uapi.dst),\n\t\t\tdrm_rect_height(&plane_state->uapi.dst));\n\t\treturn -EINVAL;\n\t}\n\n\tdrm_WARN_ON(&dev_priv->drm, plane_state->uapi.visible &&\n\t\t    plane_state->color_plane[0].stride != fb->pitches[0]);\n\n\tif (fb->pitches[0] !=\n\t    drm_rect_width(&plane_state->uapi.dst) * fb->format->cpp[0]) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Invalid cursor stride (%u) (cursor width %d)\\n\",\n\t\t\t    fb->pitches[0],\n\t\t\t    drm_rect_width(&plane_state->uapi.dst));\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * There's something wrong with the cursor on CHV pipe C.\n\t * If it straddles the left edge of the screen then\n\t * moving it away from the edge or disabling it often\n\t * results in a pipe underrun, and often that can lead to\n\t * dead pipe (constant underrun reported, and it scans\n\t * out just a solid color). To recover from that, the\n\t * display power well must be turned off and on again.\n\t * Refuse the put the cursor into that compromised position.\n\t */\n\tif (IS_CHERRYVIEW(dev_priv) && pipe == PIPE_C &&\n\t    plane_state->uapi.visible && plane_state->uapi.dst.x1 < 0) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"CHV cursor C not allowed to straddle the left screen edge\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tplane_state->ctl = i9xx_cursor_ctl(crtc_state, plane_state);\n\n\treturn 0;\n}\n\nstatic void i9xx_update_cursor(struct intel_plane *plane,\n\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t       const struct intel_plane_state *plane_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum pipe pipe = plane->pipe;\n\tu32 cntl = 0, base = 0, pos = 0, fbc_ctl = 0;\n\tunsigned long irqflags;\n\n\tif (plane_state && plane_state->uapi.visible) {\n\t\tunsigned width = drm_rect_width(&plane_state->uapi.dst);\n\t\tunsigned height = drm_rect_height(&plane_state->uapi.dst);\n\n\t\tcntl = plane_state->ctl |\n\t\t\ti9xx_cursor_ctl_crtc(crtc_state);\n\n\t\tif (width != height)\n\t\t\tfbc_ctl = CUR_FBC_CTL_EN | (height - 1);\n\n\t\tbase = intel_cursor_base(plane_state);\n\t\tpos = intel_cursor_position(plane_state);\n\t}\n\n\tspin_lock_irqsave(&dev_priv->uncore.lock, irqflags);\n\n\t/*\n\t * On some platforms writing CURCNTR first will also\n\t * cause CURPOS to be armed by the CURBASE write.\n\t * Without the CURCNTR write the CURPOS write would\n\t * arm itself. Thus we always update CURCNTR before\n\t * CURPOS.\n\t *\n\t * On other platforms CURPOS always requires the\n\t * CURBASE write to arm the update. Additonally\n\t * a write to any of the cursor register will cancel\n\t * an already armed cursor update. Thus leaving out\n\t * the CURBASE write after CURPOS could lead to a\n\t * cursor that doesn't appear to move, or even change\n\t * shape. Thus we always write CURBASE.\n\t *\n\t * The other registers are armed by by the CURBASE write\n\t * except when the plane is getting enabled at which time\n\t * the CURCNTR write arms the update.\n\t */\n\n\tif (INTEL_GEN(dev_priv) >= 9)\n\t\tskl_write_cursor_wm(plane, crtc_state);\n\n\tif (plane->cursor.base != base ||\n\t    plane->cursor.size != fbc_ctl ||\n\t    plane->cursor.cntl != cntl) {\n\t\tif (HAS_CUR_FBC(dev_priv))\n\t\t\tintel_de_write_fw(dev_priv, CUR_FBC_CTL(pipe),\n\t\t\t\t\t  fbc_ctl);\n\t\tintel_de_write_fw(dev_priv, CURCNTR(pipe), cntl);\n\t\tintel_de_write_fw(dev_priv, CURPOS(pipe), pos);\n\t\tintel_de_write_fw(dev_priv, CURBASE(pipe), base);\n\n\t\tplane->cursor.base = base;\n\t\tplane->cursor.size = fbc_ctl;\n\t\tplane->cursor.cntl = cntl;\n\t} else {\n\t\tintel_de_write_fw(dev_priv, CURPOS(pipe), pos);\n\t\tintel_de_write_fw(dev_priv, CURBASE(pipe), base);\n\t}\n\n\tspin_unlock_irqrestore(&dev_priv->uncore.lock, irqflags);\n}\n\nstatic void i9xx_disable_cursor(struct intel_plane *plane,\n\t\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\ti9xx_update_cursor(plane, crtc_state, NULL);\n}\n\nstatic bool i9xx_cursor_get_hw_state(struct intel_plane *plane,\n\t\t\t\t     enum pipe *pipe)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tenum intel_display_power_domain power_domain;\n\tintel_wakeref_t wakeref;\n\tbool ret;\n\tu32 val;\n\n\t/*\n\t * Not 100% correct for planes that can move between pipes,\n\t * but that's only the case for gen2-3 which don't have any\n\t * display power wells.\n\t */\n\tpower_domain = POWER_DOMAIN_PIPE(plane->pipe);\n\twakeref = intel_display_power_get_if_enabled(dev_priv, power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tval = intel_de_read(dev_priv, CURCNTR(plane->pipe));\n\n\tret = val & MCURSOR_MODE;\n\n\tif (INTEL_GEN(dev_priv) >= 5 || IS_G4X(dev_priv))\n\t\t*pipe = plane->pipe;\n\telse\n\t\t*pipe = (val & MCURSOR_PIPE_SELECT_MASK) >>\n\t\t\tMCURSOR_PIPE_SELECT_SHIFT;\n\n\tintel_display_power_put(dev_priv, power_domain, wakeref);\n\n\treturn ret;\n}\n\n/* VESA 640x480x72Hz mode to set on the pipe */\nstatic const struct drm_display_mode load_detect_mode = {\n\tDRM_MODE(\"640x480\", DRM_MODE_TYPE_DEFAULT, 31500, 640, 664,\n\t\t 704, 832, 0, 480, 489, 491, 520, 0, DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n};\n\nstruct drm_framebuffer *\nintel_framebuffer_create(struct drm_i915_gem_object *obj,\n\t\t\t struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tstruct intel_framebuffer *intel_fb;\n\tint ret;\n\n\tintel_fb = kzalloc(sizeof(*intel_fb), GFP_KERNEL);\n\tif (!intel_fb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = intel_framebuffer_init(intel_fb, obj, mode_cmd);\n\tif (ret)\n\t\tgoto err;\n\n\treturn &intel_fb->base;\n\nerr:\n\tkfree(intel_fb);\n\treturn ERR_PTR(ret);\n}\n\nstatic int intel_modeset_disable_planes(struct drm_atomic_state *state,\n\t\t\t\t\tstruct drm_crtc *crtc)\n{\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *plane_state;\n\tint ret, i;\n\n\tret = drm_atomic_add_affected_planes(state, crtc);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_new_plane_in_state(state, plane, plane_state, i) {\n\t\tif (plane_state->crtc != crtc)\n\t\t\tcontinue;\n\n\t\tret = drm_atomic_set_crtc_for_plane(plane_state, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdrm_atomic_set_fb_for_plane(plane_state, NULL);\n\t}\n\n\treturn 0;\n}\n\nint intel_get_load_detect_pipe(struct drm_connector *connector,\n\t\t\t       struct intel_load_detect_pipe *old,\n\t\t\t       struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct intel_crtc *intel_crtc;\n\tstruct intel_encoder *intel_encoder =\n\t\tintel_attached_encoder(to_intel_connector(connector));\n\tstruct drm_crtc *possible_crtc;\n\tstruct drm_encoder *encoder = &intel_encoder->base;\n\tstruct drm_crtc *crtc = NULL;\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tstruct drm_atomic_state *state = NULL, *restore_state = NULL;\n\tstruct drm_connector_state *connector_state;\n\tstruct intel_crtc_state *crtc_state;\n\tint ret, i = -1;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[CONNECTOR:%d:%s], [ENCODER:%d:%s]\\n\",\n\t\t    connector->base.id, connector->name,\n\t\t    encoder->base.id, encoder->name);\n\n\told->restore_state = NULL;\n\n\tdrm_WARN_ON(dev, !drm_modeset_is_locked(&config->connection_mutex));\n\n\t/*\n\t * Algorithm gets a little messy:\n\t *\n\t *   - if the connector already has an assigned crtc, use it (but make\n\t *     sure it's on first)\n\t *\n\t *   - try to find the first unused crtc that can drive this connector,\n\t *     and use that if we find one\n\t */\n\n\t/* See if we already have a CRTC for this connector */\n\tif (connector->state->crtc) {\n\t\tcrtc = connector->state->crtc;\n\n\t\tret = drm_modeset_lock(&crtc->mutex, ctx);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\t/* Make sure the crtc and connector are running */\n\t\tgoto found;\n\t}\n\n\t/* Find an unused one (if possible) */\n\tfor_each_crtc(dev, possible_crtc) {\n\t\ti++;\n\t\tif (!(encoder->possible_crtcs & (1 << i)))\n\t\t\tcontinue;\n\n\t\tret = drm_modeset_lock(&possible_crtc->mutex, ctx);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tif (possible_crtc->state->enable) {\n\t\t\tdrm_modeset_unlock(&possible_crtc->mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcrtc = possible_crtc;\n\t\tbreak;\n\t}\n\n\t/*\n\t * If we didn't find an unused CRTC, don't use any.\n\t */\n\tif (!crtc) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"no pipe available for load-detect\\n\");\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\nfound:\n\tintel_crtc = to_intel_crtc(crtc);\n\n\tstate = drm_atomic_state_alloc(dev);\n\trestore_state = drm_atomic_state_alloc(dev);\n\tif (!state || !restore_state) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tstate->acquire_ctx = ctx;\n\trestore_state->acquire_ctx = ctx;\n\n\tconnector_state = drm_atomic_get_connector_state(state, connector);\n\tif (IS_ERR(connector_state)) {\n\t\tret = PTR_ERR(connector_state);\n\t\tgoto fail;\n\t}\n\n\tret = drm_atomic_set_crtc_for_connector(connector_state, crtc);\n\tif (ret)\n\t\tgoto fail;\n\n\tcrtc_state = intel_atomic_get_crtc_state(state, intel_crtc);\n\tif (IS_ERR(crtc_state)) {\n\t\tret = PTR_ERR(crtc_state);\n\t\tgoto fail;\n\t}\n\n\tcrtc_state->uapi.active = true;\n\n\tret = drm_atomic_set_mode_for_crtc(&crtc_state->uapi,\n\t\t\t\t\t   &load_detect_mode);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = intel_modeset_disable_planes(state, crtc);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = PTR_ERR_OR_ZERO(drm_atomic_get_connector_state(restore_state, connector));\n\tif (!ret)\n\t\tret = PTR_ERR_OR_ZERO(drm_atomic_get_crtc_state(restore_state, crtc));\n\tif (!ret)\n\t\tret = drm_atomic_add_affected_planes(restore_state, crtc);\n\tif (ret) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Failed to create a copy of old state to restore: %i\\n\",\n\t\t\t    ret);\n\t\tgoto fail;\n\t}\n\n\tret = drm_atomic_commit(state);\n\tif (ret) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"failed to set mode on load-detect pipe\\n\");\n\t\tgoto fail;\n\t}\n\n\told->restore_state = restore_state;\n\tdrm_atomic_state_put(state);\n\n\t/* let the connector get through one full cycle before testing */\n\tintel_wait_for_vblank(dev_priv, intel_crtc->pipe);\n\treturn true;\n\nfail:\n\tif (state) {\n\t\tdrm_atomic_state_put(state);\n\t\tstate = NULL;\n\t}\n\tif (restore_state) {\n\t\tdrm_atomic_state_put(restore_state);\n\t\trestore_state = NULL;\n\t}\n\n\tif (ret == -EDEADLK)\n\t\treturn ret;\n\n\treturn false;\n}\n\nvoid intel_release_load_detect_pipe(struct drm_connector *connector,\n\t\t\t\t    struct intel_load_detect_pipe *old,\n\t\t\t\t    struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct intel_encoder *intel_encoder =\n\t\tintel_attached_encoder(to_intel_connector(connector));\n\tstruct drm_i915_private *i915 = to_i915(intel_encoder->base.dev);\n\tstruct drm_encoder *encoder = &intel_encoder->base;\n\tstruct drm_atomic_state *state = old->restore_state;\n\tint ret;\n\n\tdrm_dbg_kms(&i915->drm, \"[CONNECTOR:%d:%s], [ENCODER:%d:%s]\\n\",\n\t\t    connector->base.id, connector->name,\n\t\t    encoder->base.id, encoder->name);\n\n\tif (!state)\n\t\treturn;\n\n\tret = drm_atomic_helper_commit_duplicated_state(state, ctx);\n\tif (ret)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Couldn't release load detect pipe: %i\\n\", ret);\n\tdrm_atomic_state_put(state);\n}\n\nstatic int i9xx_pll_refclk(struct drm_device *dev,\n\t\t\t   const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tu32 dpll = pipe_config->dpll_hw_state.dpll;\n\n\tif ((dpll & PLL_REF_INPUT_MASK) == PLLB_REF_INPUT_SPREADSPECTRUMIN)\n\t\treturn dev_priv->vbt.lvds_ssc_freq;\n\telse if (HAS_PCH_SPLIT(dev_priv))\n\t\treturn 120000;\n\telse if (!IS_GEN(dev_priv, 2))\n\t\treturn 96000;\n\telse\n\t\treturn 48000;\n}\n\n/* Returns the clock of the currently programmed mode of the given pipe. */\nstatic void i9xx_crtc_clock_get(struct intel_crtc *crtc,\n\t\t\t\tstruct intel_crtc_state *pipe_config)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum pipe pipe = crtc->pipe;\n\tu32 dpll = pipe_config->dpll_hw_state.dpll;\n\tu32 fp;\n\tstruct dpll clock;\n\tint port_clock;\n\tint refclk = i9xx_pll_refclk(dev, pipe_config);\n\n\tif ((dpll & DISPLAY_RATE_SELECT_FPA1) == 0)\n\t\tfp = pipe_config->dpll_hw_state.fp0;\n\telse\n\t\tfp = pipe_config->dpll_hw_state.fp1;\n\n\tclock.m1 = (fp & FP_M1_DIV_MASK) >> FP_M1_DIV_SHIFT;\n\tif (IS_PINEVIEW(dev_priv)) {\n\t\tclock.n = ffs((fp & FP_N_PINEVIEW_DIV_MASK) >> FP_N_DIV_SHIFT) - 1;\n\t\tclock.m2 = (fp & FP_M2_PINEVIEW_DIV_MASK) >> FP_M2_DIV_SHIFT;\n\t} else {\n\t\tclock.n = (fp & FP_N_DIV_MASK) >> FP_N_DIV_SHIFT;\n\t\tclock.m2 = (fp & FP_M2_DIV_MASK) >> FP_M2_DIV_SHIFT;\n\t}\n\n\tif (!IS_GEN(dev_priv, 2)) {\n\t\tif (IS_PINEVIEW(dev_priv))\n\t\t\tclock.p1 = ffs((dpll & DPLL_FPA01_P1_POST_DIV_MASK_PINEVIEW) >>\n\t\t\t\tDPLL_FPA01_P1_POST_DIV_SHIFT_PINEVIEW);\n\t\telse\n\t\t\tclock.p1 = ffs((dpll & DPLL_FPA01_P1_POST_DIV_MASK) >>\n\t\t\t       DPLL_FPA01_P1_POST_DIV_SHIFT);\n\n\t\tswitch (dpll & DPLL_MODE_MASK) {\n\t\tcase DPLLB_MODE_DAC_SERIAL:\n\t\t\tclock.p2 = dpll & DPLL_DAC_SERIAL_P2_CLOCK_DIV_5 ?\n\t\t\t\t5 : 10;\n\t\t\tbreak;\n\t\tcase DPLLB_MODE_LVDS:\n\t\t\tclock.p2 = dpll & DPLLB_LVDS_P2_CLOCK_DIV_7 ?\n\t\t\t\t7 : 14;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Unknown DPLL mode %08x in programmed \"\n\t\t\t\t    \"mode\\n\", (int)(dpll & DPLL_MODE_MASK));\n\t\t\treturn;\n\t\t}\n\n\t\tif (IS_PINEVIEW(dev_priv))\n\t\t\tport_clock = pnv_calc_dpll_params(refclk, &clock);\n\t\telse\n\t\t\tport_clock = i9xx_calc_dpll_params(refclk, &clock);\n\t} else {\n\t\tu32 lvds = IS_I830(dev_priv) ? 0 : intel_de_read(dev_priv,\n\t\t\t\t\t\t\t\t LVDS);\n\t\tbool is_lvds = (pipe == 1) && (lvds & LVDS_PORT_EN);\n\n\t\tif (is_lvds) {\n\t\t\tclock.p1 = ffs((dpll & DPLL_FPA01_P1_POST_DIV_MASK_I830_LVDS) >>\n\t\t\t\t       DPLL_FPA01_P1_POST_DIV_SHIFT);\n\n\t\t\tif (lvds & LVDS_CLKB_POWER_UP)\n\t\t\t\tclock.p2 = 7;\n\t\t\telse\n\t\t\t\tclock.p2 = 14;\n\t\t} else {\n\t\t\tif (dpll & PLL_P1_DIVIDE_BY_TWO)\n\t\t\t\tclock.p1 = 2;\n\t\t\telse {\n\t\t\t\tclock.p1 = ((dpll & DPLL_FPA01_P1_POST_DIV_MASK_I830) >>\n\t\t\t\t\t    DPLL_FPA01_P1_POST_DIV_SHIFT) + 2;\n\t\t\t}\n\t\t\tif (dpll & PLL_P2_DIVIDE_BY_4)\n\t\t\t\tclock.p2 = 4;\n\t\t\telse\n\t\t\t\tclock.p2 = 2;\n\t\t}\n\n\t\tport_clock = i9xx_calc_dpll_params(refclk, &clock);\n\t}\n\n\t/*\n\t * This value includes pixel_multiplier. We will use\n\t * port_clock to compute adjusted_mode.crtc_clock in the\n\t * encoder's get_config() function.\n\t */\n\tpipe_config->port_clock = port_clock;\n}\n\nint intel_dotclock_calculate(int link_freq,\n\t\t\t     const struct intel_link_m_n *m_n)\n{\n\t/*\n\t * The calculation for the data clock is:\n\t * pixel_clock = ((m/n)*(link_clock * nr_lanes))/bpp\n\t * But we want to avoid losing precison if possible, so:\n\t * pixel_clock = ((m * link_clock * nr_lanes)/(n*bpp))\n\t *\n\t * and the link clock is simpler:\n\t * link_clock = (m * link_clock) / n\n\t */\n\n\tif (!m_n->link_n)\n\t\treturn 0;\n\n\treturn div_u64(mul_u32_u32(m_n->link_m, link_freq), m_n->link_n);\n}\n\nstatic void ilk_pch_clock_get(struct intel_crtc *crtc,\n\t\t\t      struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\t/* read out port_clock from the DPLL */\n\ti9xx_crtc_clock_get(crtc, pipe_config);\n\n\t/*\n\t * In case there is an active pipe without active ports,\n\t * we may need some idea for the dotclock anyway.\n\t * Calculate one based on the FDI configuration.\n\t */\n\tpipe_config->hw.adjusted_mode.crtc_clock =\n\t\tintel_dotclock_calculate(intel_fdi_link_freq(dev_priv, pipe_config),\n\t\t\t\t\t &pipe_config->fdi_m_n);\n}\n\nstatic void intel_crtc_state_reset(struct intel_crtc_state *crtc_state,\n\t\t\t\t   struct intel_crtc *crtc)\n{\n\tmemset(crtc_state, 0, sizeof(*crtc_state));\n\n\t__drm_atomic_helper_crtc_state_reset(&crtc_state->uapi, &crtc->base);\n\n\tcrtc_state->cpu_transcoder = INVALID_TRANSCODER;\n\tcrtc_state->master_transcoder = INVALID_TRANSCODER;\n\tcrtc_state->hsw_workaround_pipe = INVALID_PIPE;\n\tcrtc_state->output_format = INTEL_OUTPUT_FORMAT_INVALID;\n\tcrtc_state->scaler_state.scaler_id = -1;\n\tcrtc_state->mst_master_transcoder = INVALID_TRANSCODER;\n}\n\nstatic struct intel_crtc_state *intel_crtc_state_alloc(struct intel_crtc *crtc)\n{\n\tstruct intel_crtc_state *crtc_state;\n\n\tcrtc_state = kmalloc(sizeof(*crtc_state), GFP_KERNEL);\n\n\tif (crtc_state)\n\t\tintel_crtc_state_reset(crtc_state, crtc);\n\n\treturn crtc_state;\n}\n\n/* Returns the currently programmed mode of the given encoder. */\nstruct drm_display_mode *\nintel_encoder_current_mode(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_crtc_state *crtc_state;\n\tstruct drm_display_mode *mode;\n\tstruct intel_crtc *crtc;\n\tenum pipe pipe;\n\n\tif (!encoder->get_hw_state(encoder, &pipe))\n\t\treturn NULL;\n\n\tcrtc = intel_get_crtc_for_pipe(dev_priv, pipe);\n\n\tmode = kzalloc(sizeof(*mode), GFP_KERNEL);\n\tif (!mode)\n\t\treturn NULL;\n\n\tcrtc_state = intel_crtc_state_alloc(crtc);\n\tif (!crtc_state) {\n\t\tkfree(mode);\n\t\treturn NULL;\n\t}\n\n\tif (!dev_priv->display.get_pipe_config(crtc, crtc_state)) {\n\t\tkfree(crtc_state);\n\t\tkfree(mode);\n\t\treturn NULL;\n\t}\n\n\tencoder->get_config(encoder, crtc_state);\n\n\tintel_mode_from_pipe_config(mode, crtc_state);\n\n\tkfree(crtc_state);\n\n\treturn mode;\n}\n\nstatic void intel_crtc_destroy(struct drm_crtc *crtc)\n{\n\tstruct intel_crtc *intel_crtc = to_intel_crtc(crtc);\n\n\tdrm_crtc_cleanup(crtc);\n\tkfree(intel_crtc);\n}\n\n/**\n * intel_wm_need_update - Check whether watermarks need updating\n * @cur: current plane state\n * @new: new plane state\n *\n * Check current plane state versus the new one to determine whether\n * watermarks need to be recalculated.\n *\n * Returns true or false.\n */\nstatic bool intel_wm_need_update(const struct intel_plane_state *cur,\n\t\t\t\t struct intel_plane_state *new)\n{\n\t/* Update watermarks on tiling or size changes. */\n\tif (new->uapi.visible != cur->uapi.visible)\n\t\treturn true;\n\n\tif (!cur->hw.fb || !new->hw.fb)\n\t\treturn false;\n\n\tif (cur->hw.fb->modifier != new->hw.fb->modifier ||\n\t    cur->hw.rotation != new->hw.rotation ||\n\t    drm_rect_width(&new->uapi.src) != drm_rect_width(&cur->uapi.src) ||\n\t    drm_rect_height(&new->uapi.src) != drm_rect_height(&cur->uapi.src) ||\n\t    drm_rect_width(&new->uapi.dst) != drm_rect_width(&cur->uapi.dst) ||\n\t    drm_rect_height(&new->uapi.dst) != drm_rect_height(&cur->uapi.dst))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool needs_scaling(const struct intel_plane_state *state)\n{\n\tint src_w = drm_rect_width(&state->uapi.src) >> 16;\n\tint src_h = drm_rect_height(&state->uapi.src) >> 16;\n\tint dst_w = drm_rect_width(&state->uapi.dst);\n\tint dst_h = drm_rect_height(&state->uapi.dst);\n\n\treturn (src_w != dst_w || src_h != dst_h);\n}\n\nint intel_plane_atomic_calc_changes(const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t    struct intel_crtc_state *crtc_state,\n\t\t\t\t    const struct intel_plane_state *old_plane_state,\n\t\t\t\t    struct intel_plane_state *plane_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tbool mode_changed = needs_modeset(crtc_state);\n\tbool was_crtc_enabled = old_crtc_state->hw.active;\n\tbool is_crtc_enabled = crtc_state->hw.active;\n\tbool turn_off, turn_on, visible, was_visible;\n\tint ret;\n\n\tif (INTEL_GEN(dev_priv) >= 9 && plane->id != PLANE_CURSOR) {\n\t\tret = skl_update_scaler_plane(crtc_state, plane_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\twas_visible = old_plane_state->uapi.visible;\n\tvisible = plane_state->uapi.visible;\n\n\tif (!was_crtc_enabled && drm_WARN_ON(&dev_priv->drm, was_visible))\n\t\twas_visible = false;\n\n\t/*\n\t * Visibility is calculated as if the crtc was on, but\n\t * after scaler setup everything depends on it being off\n\t * when the crtc isn't active.\n\t *\n\t * FIXME this is wrong for watermarks. Watermarks should also\n\t * be computed as if the pipe would be active. Perhaps move\n\t * per-plane wm computation to the .check_plane() hook, and\n\t * only combine the results from all planes in the current place?\n\t */\n\tif (!is_crtc_enabled) {\n\t\tintel_plane_set_invisible(crtc_state, plane_state);\n\t\tvisible = false;\n\t}\n\n\tif (!was_visible && !visible)\n\t\treturn 0;\n\n\tturn_off = was_visible && (!visible || mode_changed);\n\tturn_on = visible && (!was_visible || mode_changed);\n\n\tdrm_dbg_atomic(&dev_priv->drm,\n\t\t       \"[CRTC:%d:%s] with [PLANE:%d:%s] visible %i -> %i, off %i, on %i, ms %i\\n\",\n\t\t       crtc->base.base.id, crtc->base.name,\n\t\t       plane->base.base.id, plane->base.name,\n\t\t       was_visible, visible,\n\t\t       turn_off, turn_on, mode_changed);\n\n\tif (turn_on) {\n\t\tif (INTEL_GEN(dev_priv) < 5 && !IS_G4X(dev_priv))\n\t\t\tcrtc_state->update_wm_pre = true;\n\n\t\t/* must disable cxsr around plane enable/disable */\n\t\tif (plane->id != PLANE_CURSOR)\n\t\t\tcrtc_state->disable_cxsr = true;\n\t} else if (turn_off) {\n\t\tif (INTEL_GEN(dev_priv) < 5 && !IS_G4X(dev_priv))\n\t\t\tcrtc_state->update_wm_post = true;\n\n\t\t/* must disable cxsr around plane enable/disable */\n\t\tif (plane->id != PLANE_CURSOR)\n\t\t\tcrtc_state->disable_cxsr = true;\n\t} else if (intel_wm_need_update(old_plane_state, plane_state)) {\n\t\tif (INTEL_GEN(dev_priv) < 5 && !IS_G4X(dev_priv)) {\n\t\t\t/* FIXME bollocks */\n\t\t\tcrtc_state->update_wm_pre = true;\n\t\t\tcrtc_state->update_wm_post = true;\n\t\t}\n\t}\n\n\tif (visible || was_visible)\n\t\tcrtc_state->fb_bits |= plane->frontbuffer_bit;\n\n\t/*\n\t * ILK/SNB DVSACNTR/Sprite Enable\n\t * IVB SPR_CTL/Sprite Enable\n\t * \"When in Self Refresh Big FIFO mode, a write to enable the\n\t *  plane will be internally buffered and delayed while Big FIFO\n\t *  mode is exiting.\"\n\t *\n\t * Which means that enabling the sprite can take an extra frame\n\t * when we start in big FIFO mode (LP1+). Thus we need to drop\n\t * down to LP0 and wait for vblank in order to make sure the\n\t * sprite gets enabled on the next vblank after the register write.\n\t * Doing otherwise would risk enabling the sprite one frame after\n\t * we've already signalled flip completion. We can resume LP1+\n\t * once the sprite has been enabled.\n\t *\n\t *\n\t * WaCxSRDisabledForSpriteScaling:ivb\n\t * IVB SPR_SCALE/Scaling Enable\n\t * \"Low Power watermarks must be disabled for at least one\n\t *  frame before enabling sprite scaling, and kept disabled\n\t *  until sprite scaling is disabled.\"\n\t *\n\t * ILK/SNB DVSASCALE/Scaling Enable\n\t * \"When in Self Refresh Big FIFO mode, scaling enable will be\n\t *  masked off while Big FIFO mode is exiting.\"\n\t *\n\t * Despite the w/a only being listed for IVB we assume that\n\t * the ILK/SNB note has similar ramifications, hence we apply\n\t * the w/a on all three platforms.\n\t *\n\t * With experimental results seems this is needed also for primary\n\t * plane, not only sprite plane.\n\t */\n\tif (plane->id != PLANE_CURSOR &&\n\t    (IS_GEN_RANGE(dev_priv, 5, 6) ||\n\t     IS_IVYBRIDGE(dev_priv)) &&\n\t    (turn_on || (!needs_scaling(old_plane_state) &&\n\t\t\t needs_scaling(plane_state))))\n\t\tcrtc_state->disable_lp_wm = true;\n\n\treturn 0;\n}\n\nstatic bool encoders_cloneable(const struct intel_encoder *a,\n\t\t\t       const struct intel_encoder *b)\n{\n\t/* masks could be asymmetric, so check both ways */\n\treturn a == b || (a->cloneable & (1 << b->type) &&\n\t\t\t  b->cloneable & (1 << a->type));\n}\n\nstatic bool check_single_encoder_cloning(struct drm_atomic_state *state,\n\t\t\t\t\t struct intel_crtc *crtc,\n\t\t\t\t\t struct intel_encoder *encoder)\n{\n\tstruct intel_encoder *source_encoder;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *connector_state;\n\tint i;\n\n\tfor_each_new_connector_in_state(state, connector, connector_state, i) {\n\t\tif (connector_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tsource_encoder =\n\t\t\tto_intel_encoder(connector_state->best_encoder);\n\t\tif (!encoders_cloneable(encoder, source_encoder))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int icl_add_linked_planes(struct intel_atomic_state *state)\n{\n\tstruct intel_plane *plane, *linked;\n\tstruct intel_plane_state *plane_state, *linked_plane_state;\n\tint i;\n\n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tlinked = plane_state->planar_linked_plane;\n\n\t\tif (!linked)\n\t\t\tcontinue;\n\n\t\tlinked_plane_state = intel_atomic_get_plane_state(state, linked);\n\t\tif (IS_ERR(linked_plane_state))\n\t\t\treturn PTR_ERR(linked_plane_state);\n\n\t\tdrm_WARN_ON(state->base.dev,\n\t\t\t    linked_plane_state->planar_linked_plane != plane);\n\t\tdrm_WARN_ON(state->base.dev,\n\t\t\t    linked_plane_state->planar_slave == plane_state->planar_slave);\n\t}\n\n\treturn 0;\n}\n\nstatic int icl_check_nv12_planes(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_atomic_state *state = to_intel_atomic_state(crtc_state->uapi.state);\n\tstruct intel_plane *plane, *linked;\n\tstruct intel_plane_state *plane_state;\n\tint i;\n\n\tif (INTEL_GEN(dev_priv) < 11)\n\t\treturn 0;\n\n\t/*\n\t * Destroy all old plane links and make the slave plane invisible\n\t * in the crtc_state->active_planes mask.\n\t */\n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tif (plane->pipe != crtc->pipe || !plane_state->planar_linked_plane)\n\t\t\tcontinue;\n\n\t\tplane_state->planar_linked_plane = NULL;\n\t\tif (plane_state->planar_slave && !plane_state->uapi.visible) {\n\t\t\tcrtc_state->active_planes &= ~BIT(plane->id);\n\t\t\tcrtc_state->update_planes |= BIT(plane->id);\n\t\t}\n\n\t\tplane_state->planar_slave = false;\n\t}\n\n\tif (!crtc_state->nv12_planes)\n\t\treturn 0;\n\n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tstruct intel_plane_state *linked_state = NULL;\n\n\t\tif (plane->pipe != crtc->pipe ||\n\t\t    !(crtc_state->nv12_planes & BIT(plane->id)))\n\t\t\tcontinue;\n\n\t\tfor_each_intel_plane_on_crtc(&dev_priv->drm, crtc, linked) {\n\t\t\tif (!icl_is_nv12_y_plane(dev_priv, linked->id))\n\t\t\t\tcontinue;\n\n\t\t\tif (crtc_state->active_planes & BIT(linked->id))\n\t\t\t\tcontinue;\n\n\t\t\tlinked_state = intel_atomic_get_plane_state(state, linked);\n\t\t\tif (IS_ERR(linked_state))\n\t\t\t\treturn PTR_ERR(linked_state);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!linked_state) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Need %d free Y planes for planar YUV\\n\",\n\t\t\t\t    hweight8(crtc_state->nv12_planes));\n\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tplane_state->planar_linked_plane = linked;\n\n\t\tlinked_state->planar_slave = true;\n\t\tlinked_state->planar_linked_plane = plane;\n\t\tcrtc_state->active_planes |= BIT(linked->id);\n\t\tcrtc_state->update_planes |= BIT(linked->id);\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Using %s as Y plane for %s\\n\",\n\t\t\t    linked->base.name, plane->base.name);\n\n\t\t/* Copy parameters to slave plane */\n\t\tlinked_state->ctl = plane_state->ctl | PLANE_CTL_YUV420_Y_PLANE;\n\t\tlinked_state->color_ctl = plane_state->color_ctl;\n\t\tlinked_state->view = plane_state->view;\n\t\tmemcpy(linked_state->color_plane, plane_state->color_plane,\n\t\t       sizeof(linked_state->color_plane));\n\n\t\tintel_plane_copy_uapi_to_hw_state(linked_state, plane_state);\n\t\tlinked_state->uapi.src = plane_state->uapi.src;\n\t\tlinked_state->uapi.dst = plane_state->uapi.dst;\n\n\t\tif (icl_is_hdr_plane(dev_priv, plane->id)) {\n\t\t\tif (linked->id == PLANE_SPRITE5)\n\t\t\t\tplane_state->cus_ctl |= PLANE_CUS_PLANE_7;\n\t\t\telse if (linked->id == PLANE_SPRITE4)\n\t\t\t\tplane_state->cus_ctl |= PLANE_CUS_PLANE_6;\n\t\t\telse if (linked->id == PLANE_SPRITE3)\n\t\t\t\tplane_state->cus_ctl |= PLANE_CUS_PLANE_5_RKL;\n\t\t\telse if (linked->id == PLANE_SPRITE2)\n\t\t\t\tplane_state->cus_ctl |= PLANE_CUS_PLANE_4_RKL;\n\t\t\telse\n\t\t\t\tMISSING_CASE(linked->id);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool c8_planes_changed(const struct intel_crtc_state *new_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(new_crtc_state->uapi.crtc);\n\tstruct intel_atomic_state *state =\n\t\tto_intel_atomic_state(new_crtc_state->uapi.state);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\n\treturn !old_crtc_state->c8_planes != !new_crtc_state->c8_planes;\n}\n\nstatic u16 hsw_linetime_wm(const struct intel_crtc_state *crtc_state)\n{\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\tint linetime_wm;\n\n\tif (!crtc_state->hw.enable)\n\t\treturn 0;\n\n\tlinetime_wm = DIV_ROUND_CLOSEST(adjusted_mode->crtc_htotal * 1000 * 8,\n\t\t\t\t\tadjusted_mode->crtc_clock);\n\n\treturn min(linetime_wm, 0x1ff);\n}\n\nstatic u16 hsw_ips_linetime_wm(const struct intel_crtc_state *crtc_state,\n\t\t\t       const struct intel_cdclk_state *cdclk_state)\n{\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\tint linetime_wm;\n\n\tif (!crtc_state->hw.enable)\n\t\treturn 0;\n\n\tlinetime_wm = DIV_ROUND_CLOSEST(adjusted_mode->crtc_htotal * 1000 * 8,\n\t\t\t\t\tcdclk_state->logical.cdclk);\n\n\treturn min(linetime_wm, 0x1ff);\n}\n\nstatic u16 skl_linetime_wm(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\tint linetime_wm;\n\n\tif (!crtc_state->hw.enable)\n\t\treturn 0;\n\n\tlinetime_wm = DIV_ROUND_UP(adjusted_mode->crtc_htotal * 1000 * 8,\n\t\t\t\t   crtc_state->pixel_rate);\n\n\t/* Display WA #1135: BXT:ALL GLK:ALL */\n\tif (IS_GEN9_LP(dev_priv) && dev_priv->ipc_enabled)\n\t\tlinetime_wm /= 2;\n\n\treturn min(linetime_wm, 0x1ff);\n}\n\nstatic int hsw_compute_linetime_wm(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tconst struct intel_cdclk_state *cdclk_state;\n\n\tif (INTEL_GEN(dev_priv) >= 9)\n\t\tcrtc_state->linetime = skl_linetime_wm(crtc_state);\n\telse\n\t\tcrtc_state->linetime = hsw_linetime_wm(crtc_state);\n\n\tif (!hsw_crtc_supports_ips(crtc))\n\t\treturn 0;\n\n\tcdclk_state = intel_atomic_get_cdclk_state(state);\n\tif (IS_ERR(cdclk_state))\n\t\treturn PTR_ERR(cdclk_state);\n\n\tcrtc_state->ips_linetime = hsw_ips_linetime_wm(crtc_state,\n\t\t\t\t\t\t       cdclk_state);\n\n\treturn 0;\n}\n\nstatic int intel_crtc_atomic_check(struct intel_atomic_state *state,\n\t\t\t\t   struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_crtc_state *crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tbool mode_changed = needs_modeset(crtc_state);\n\tint ret;\n\n\tif (INTEL_GEN(dev_priv) < 5 && !IS_G4X(dev_priv) &&\n\t    mode_changed && !crtc_state->hw.active)\n\t\tcrtc_state->update_wm_post = true;\n\n\tif (mode_changed && crtc_state->hw.enable &&\n\t    dev_priv->display.crtc_compute_clock &&\n\t    !drm_WARN_ON(&dev_priv->drm, crtc_state->shared_dpll)) {\n\t\tret = dev_priv->display.crtc_compute_clock(crtc, crtc_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * May need to update pipe gamma enable bits\n\t * when C8 planes are getting enabled/disabled.\n\t */\n\tif (c8_planes_changed(crtc_state))\n\t\tcrtc_state->uapi.color_mgmt_changed = true;\n\n\tif (mode_changed || crtc_state->update_pipe ||\n\t    crtc_state->uapi.color_mgmt_changed) {\n\t\tret = intel_color_check(crtc_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (dev_priv->display.compute_pipe_wm) {\n\t\tret = dev_priv->display.compute_pipe_wm(crtc_state);\n\t\tif (ret) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Target pipe watermarks are invalid\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (dev_priv->display.compute_intermediate_wm) {\n\t\tif (drm_WARN_ON(&dev_priv->drm,\n\t\t\t\t!dev_priv->display.compute_pipe_wm))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Calculate 'intermediate' watermarks that satisfy both the\n\t\t * old state and the new state.  We can program these\n\t\t * immediately.\n\t\t */\n\t\tret = dev_priv->display.compute_intermediate_wm(crtc_state);\n\t\tif (ret) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"No valid intermediate pipe watermarks are possible\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (INTEL_GEN(dev_priv) >= 9) {\n\t\tif (mode_changed || crtc_state->update_pipe) {\n\t\t\tret = skl_update_scaler_crtc(crtc_state);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = intel_atomic_setup_scalers(dev_priv, crtc, crtc_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (HAS_IPS(dev_priv)) {\n\t\tret = hsw_compute_ips_config(crtc_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (INTEL_GEN(dev_priv) >= 9 ||\n\t    IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv)) {\n\t\tret = hsw_compute_linetime_wm(state, crtc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t}\n\n\tif (!mode_changed)\n\t\tintel_psr2_sel_fetch_update(state, crtc);\n\n\treturn 0;\n}\n\nstatic void intel_modeset_update_connector_atomic_state(struct drm_device *dev)\n{\n\tstruct intel_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tif (connector->base.state->crtc)\n\t\t\tdrm_connector_put(&connector->base);\n\n\t\tif (connector->base.encoder) {\n\t\t\tconnector->base.state->best_encoder =\n\t\t\t\tconnector->base.encoder;\n\t\t\tconnector->base.state->crtc =\n\t\t\t\tconnector->base.encoder->crtc;\n\n\t\t\tdrm_connector_get(&connector->base);\n\t\t} else {\n\t\t\tconnector->base.state->best_encoder = NULL;\n\t\t\tconnector->base.state->crtc = NULL;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n}\n\nstatic int\ncompute_sink_pipe_bpp(const struct drm_connector_state *conn_state,\n\t\t      struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_connector *connector = conn_state->connector;\n\tstruct drm_i915_private *i915 = to_i915(pipe_config->uapi.crtc->dev);\n\tconst struct drm_display_info *info = &connector->display_info;\n\tint bpp;\n\n\tswitch (conn_state->max_bpc) {\n\tcase 6 ... 7:\n\t\tbpp = 6 * 3;\n\t\tbreak;\n\tcase 8 ... 9:\n\t\tbpp = 8 * 3;\n\t\tbreak;\n\tcase 10 ... 11:\n\t\tbpp = 10 * 3;\n\t\tbreak;\n\tcase 12:\n\t\tbpp = 12 * 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (bpp < pipe_config->pipe_bpp) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CONNECTOR:%d:%s] Limiting display bpp to %d instead of \"\n\t\t\t    \"EDID bpp %d, requested bpp %d, max platform bpp %d\\n\",\n\t\t\t    connector->base.id, connector->name,\n\t\t\t    bpp, 3 * info->bpc,\n\t\t\t    3 * conn_state->max_requested_bpc,\n\t\t\t    pipe_config->pipe_bpp);\n\n\t\tpipe_config->pipe_bpp = bpp;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ncompute_baseline_pipe_bpp(struct intel_crtc *crtc,\n\t\t\t  struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct drm_atomic_state *state = pipe_config->uapi.state;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *connector_state;\n\tint bpp, i;\n\n\tif ((IS_G4X(dev_priv) || IS_VALLEYVIEW(dev_priv) ||\n\t    IS_CHERRYVIEW(dev_priv)))\n\t\tbpp = 10*3;\n\telse if (INTEL_GEN(dev_priv) >= 5)\n\t\tbpp = 12*3;\n\telse\n\t\tbpp = 8*3;\n\n\tpipe_config->pipe_bpp = bpp;\n\n\t/* Clamp display bpp to connector max bpp */\n\tfor_each_new_connector_in_state(state, connector, connector_state, i) {\n\t\tint ret;\n\n\t\tif (connector_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tret = compute_sink_pipe_bpp(connector_state, pipe_config);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void intel_dump_crtc_timings(struct drm_i915_private *i915,\n\t\t\t\t    const struct drm_display_mode *mode)\n{\n\tdrm_dbg_kms(&i915->drm, \"crtc timings: %d %d %d %d %d %d %d %d %d, \"\n\t\t    \"type: 0x%x flags: 0x%x\\n\",\n\t\t    mode->crtc_clock,\n\t\t    mode->crtc_hdisplay, mode->crtc_hsync_start,\n\t\t    mode->crtc_hsync_end, mode->crtc_htotal,\n\t\t    mode->crtc_vdisplay, mode->crtc_vsync_start,\n\t\t    mode->crtc_vsync_end, mode->crtc_vtotal,\n\t\t    mode->type, mode->flags);\n}\n\nstatic void\nintel_dump_m_n_config(const struct intel_crtc_state *pipe_config,\n\t\t      const char *id, unsigned int lane_count,\n\t\t      const struct intel_link_m_n *m_n)\n{\n\tstruct drm_i915_private *i915 = to_i915(pipe_config->uapi.crtc->dev);\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"%s: lanes: %i; gmch_m: %u, gmch_n: %u, link_m: %u, link_n: %u, tu: %u\\n\",\n\t\t    id, lane_count,\n\t\t    m_n->gmch_m, m_n->gmch_n,\n\t\t    m_n->link_m, m_n->link_n, m_n->tu);\n}\n\nstatic void\nintel_dump_infoframe(struct drm_i915_private *dev_priv,\n\t\t     const union hdmi_infoframe *frame)\n{\n\tif (!drm_debug_enabled(DRM_UT_KMS))\n\t\treturn;\n\n\thdmi_infoframe_log(KERN_DEBUG, dev_priv->drm.dev, frame);\n}\n\nstatic void\nintel_dump_dp_vsc_sdp(struct drm_i915_private *dev_priv,\n\t\t      const struct drm_dp_vsc_sdp *vsc)\n{\n\tif (!drm_debug_enabled(DRM_UT_KMS))\n\t\treturn;\n\n\tdrm_dp_vsc_sdp_log(KERN_DEBUG, dev_priv->drm.dev, vsc);\n}\n\n#define OUTPUT_TYPE(x) [INTEL_OUTPUT_ ## x] = #x\n\nstatic const char * const output_type_str[] = {\n\tOUTPUT_TYPE(UNUSED),\n\tOUTPUT_TYPE(ANALOG),\n\tOUTPUT_TYPE(DVO),\n\tOUTPUT_TYPE(SDVO),\n\tOUTPUT_TYPE(LVDS),\n\tOUTPUT_TYPE(TVOUT),\n\tOUTPUT_TYPE(HDMI),\n\tOUTPUT_TYPE(DP),\n\tOUTPUT_TYPE(EDP),\n\tOUTPUT_TYPE(DSI),\n\tOUTPUT_TYPE(DDI),\n\tOUTPUT_TYPE(DP_MST),\n};\n\n#undef OUTPUT_TYPE\n\nstatic void snprintf_output_types(char *buf, size_t len,\n\t\t\t\t  unsigned int output_types)\n{\n\tchar *str = buf;\n\tint i;\n\n\tstr[0] = '\\0';\n\n\tfor (i = 0; i < ARRAY_SIZE(output_type_str); i++) {\n\t\tint r;\n\n\t\tif ((output_types & BIT(i)) == 0)\n\t\t\tcontinue;\n\n\t\tr = snprintf(str, len, \"%s%s\",\n\t\t\t     str != buf ? \",\" : \"\", output_type_str[i]);\n\t\tif (r >= len)\n\t\t\tbreak;\n\t\tstr += r;\n\t\tlen -= r;\n\n\t\toutput_types &= ~BIT(i);\n\t}\n\n\tWARN_ON_ONCE(output_types != 0);\n}\n\nstatic const char * const output_format_str[] = {\n\t[INTEL_OUTPUT_FORMAT_INVALID] = \"Invalid\",\n\t[INTEL_OUTPUT_FORMAT_RGB] = \"RGB\",\n\t[INTEL_OUTPUT_FORMAT_YCBCR420] = \"YCBCR4:2:0\",\n\t[INTEL_OUTPUT_FORMAT_YCBCR444] = \"YCBCR4:4:4\",\n};\n\nstatic const char *output_formats(enum intel_output_format format)\n{\n\tif (format >= ARRAY_SIZE(output_format_str))\n\t\tformat = INTEL_OUTPUT_FORMAT_INVALID;\n\treturn output_format_str[format];\n}\n\nstatic void intel_dump_plane_state(const struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *i915 = to_i915(plane->base.dev);\n\tconst struct drm_framebuffer *fb = plane_state->hw.fb;\n\tstruct drm_format_name_buf format_name;\n\n\tif (!fb) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[PLANE:%d:%s] fb: [NOFB], visible: %s\\n\",\n\t\t\t    plane->base.base.id, plane->base.name,\n\t\t\t    yesno(plane_state->uapi.visible));\n\t\treturn;\n\t}\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[PLANE:%d:%s] fb: [FB:%d] %ux%u format = %s, visible: %s\\n\",\n\t\t    plane->base.base.id, plane->base.name,\n\t\t    fb->base.id, fb->width, fb->height,\n\t\t    drm_get_format_name(fb->format->format, &format_name),\n\t\t    yesno(plane_state->uapi.visible));\n\tdrm_dbg_kms(&i915->drm, \"\\trotation: 0x%x, scaler: %d\\n\",\n\t\t    plane_state->hw.rotation, plane_state->scaler_id);\n\tif (plane_state->uapi.visible)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"\\tsrc: \" DRM_RECT_FP_FMT \" dst: \" DRM_RECT_FMT \"\\n\",\n\t\t\t    DRM_RECT_FP_ARG(&plane_state->uapi.src),\n\t\t\t    DRM_RECT_ARG(&plane_state->uapi.dst));\n}\n\nstatic void intel_dump_pipe_config(const struct intel_crtc_state *pipe_config,\n\t\t\t\t   struct intel_atomic_state *state,\n\t\t\t\t   const char *context)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct intel_plane_state *plane_state;\n\tstruct intel_plane *plane;\n\tchar buf[64];\n\tint i;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[CRTC:%d:%s] enable: %s %s\\n\",\n\t\t    crtc->base.base.id, crtc->base.name,\n\t\t    yesno(pipe_config->hw.enable), context);\n\n\tif (!pipe_config->hw.enable)\n\t\tgoto dump_planes;\n\n\tsnprintf_output_types(buf, sizeof(buf), pipe_config->output_types);\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"active: %s, output_types: %s (0x%x), output format: %s\\n\",\n\t\t    yesno(pipe_config->hw.active),\n\t\t    buf, pipe_config->output_types,\n\t\t    output_formats(pipe_config->output_format));\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"cpu_transcoder: %s, pipe bpp: %i, dithering: %i\\n\",\n\t\t    transcoder_name(pipe_config->cpu_transcoder),\n\t\t    pipe_config->pipe_bpp, pipe_config->dither);\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"port sync: master transcoder: %s, slave transcoder bitmask = 0x%x\\n\",\n\t\t    transcoder_name(pipe_config->master_transcoder),\n\t\t    pipe_config->sync_mode_slaves_mask);\n\n\tif (pipe_config->has_pch_encoder)\n\t\tintel_dump_m_n_config(pipe_config, \"fdi\",\n\t\t\t\t      pipe_config->fdi_lanes,\n\t\t\t\t      &pipe_config->fdi_m_n);\n\n\tif (intel_crtc_has_dp_encoder(pipe_config)) {\n\t\tintel_dump_m_n_config(pipe_config, \"dp m_n\",\n\t\t\t\tpipe_config->lane_count, &pipe_config->dp_m_n);\n\t\tif (pipe_config->has_drrs)\n\t\t\tintel_dump_m_n_config(pipe_config, \"dp m2_n2\",\n\t\t\t\t\t      pipe_config->lane_count,\n\t\t\t\t\t      &pipe_config->dp_m2_n2);\n\t}\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"audio: %i, infoframes: %i, infoframes enabled: 0x%x\\n\",\n\t\t    pipe_config->has_audio, pipe_config->has_infoframe,\n\t\t    pipe_config->infoframes.enable);\n\n\tif (pipe_config->infoframes.enable &\n\t    intel_hdmi_infoframe_enable(HDMI_PACKET_TYPE_GENERAL_CONTROL))\n\t\tdrm_dbg_kms(&dev_priv->drm, \"GCP: 0x%x\\n\",\n\t\t\t    pipe_config->infoframes.gcp);\n\tif (pipe_config->infoframes.enable &\n\t    intel_hdmi_infoframe_enable(HDMI_INFOFRAME_TYPE_AVI))\n\t\tintel_dump_infoframe(dev_priv, &pipe_config->infoframes.avi);\n\tif (pipe_config->infoframes.enable &\n\t    intel_hdmi_infoframe_enable(HDMI_INFOFRAME_TYPE_SPD))\n\t\tintel_dump_infoframe(dev_priv, &pipe_config->infoframes.spd);\n\tif (pipe_config->infoframes.enable &\n\t    intel_hdmi_infoframe_enable(HDMI_INFOFRAME_TYPE_VENDOR))\n\t\tintel_dump_infoframe(dev_priv, &pipe_config->infoframes.hdmi);\n\tif (pipe_config->infoframes.enable &\n\t    intel_hdmi_infoframe_enable(HDMI_INFOFRAME_TYPE_DRM))\n\t\tintel_dump_infoframe(dev_priv, &pipe_config->infoframes.drm);\n\tif (pipe_config->infoframes.enable &\n\t    intel_hdmi_infoframe_enable(HDMI_PACKET_TYPE_GAMUT_METADATA))\n\t\tintel_dump_infoframe(dev_priv, &pipe_config->infoframes.drm);\n\tif (pipe_config->infoframes.enable &\n\t    intel_hdmi_infoframe_enable(DP_SDP_VSC))\n\t\tintel_dump_dp_vsc_sdp(dev_priv, &pipe_config->infoframes.vsc);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"requested mode:\\n\");\n\tdrm_mode_debug_printmodeline(&pipe_config->hw.mode);\n\tdrm_dbg_kms(&dev_priv->drm, \"adjusted mode:\\n\");\n\tdrm_mode_debug_printmodeline(&pipe_config->hw.adjusted_mode);\n\tintel_dump_crtc_timings(dev_priv, &pipe_config->hw.adjusted_mode);\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"port clock: %d, pipe src size: %dx%d, pixel rate %d\\n\",\n\t\t    pipe_config->port_clock,\n\t\t    pipe_config->pipe_src_w, pipe_config->pipe_src_h,\n\t\t    pipe_config->pixel_rate);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"linetime: %d, ips linetime: %d\\n\",\n\t\t    pipe_config->linetime, pipe_config->ips_linetime);\n\n\tif (INTEL_GEN(dev_priv) >= 9)\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"num_scalers: %d, scaler_users: 0x%x, scaler_id: %d\\n\",\n\t\t\t    crtc->num_scalers,\n\t\t\t    pipe_config->scaler_state.scaler_users,\n\t\t\t    pipe_config->scaler_state.scaler_id);\n\n\tif (HAS_GMCH(dev_priv))\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"gmch pfit: control: 0x%08x, ratios: 0x%08x, lvds border: 0x%08x\\n\",\n\t\t\t    pipe_config->gmch_pfit.control,\n\t\t\t    pipe_config->gmch_pfit.pgm_ratios,\n\t\t\t    pipe_config->gmch_pfit.lvds_border_bits);\n\telse\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"pch pfit: \" DRM_RECT_FMT \", %s, force thru: %s\\n\",\n\t\t\t    DRM_RECT_ARG(&pipe_config->pch_pfit.dst),\n\t\t\t    enableddisabled(pipe_config->pch_pfit.enabled),\n\t\t\t    yesno(pipe_config->pch_pfit.force_thru));\n\n\tdrm_dbg_kms(&dev_priv->drm, \"ips: %i, double wide: %i\\n\",\n\t\t    pipe_config->ips_enabled, pipe_config->double_wide);\n\n\tintel_dpll_dump_hw_state(dev_priv, &pipe_config->dpll_hw_state);\n\n\tif (IS_CHERRYVIEW(dev_priv))\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"cgm_mode: 0x%x gamma_mode: 0x%x gamma_enable: %d csc_enable: %d\\n\",\n\t\t\t    pipe_config->cgm_mode, pipe_config->gamma_mode,\n\t\t\t    pipe_config->gamma_enable, pipe_config->csc_enable);\n\telse\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"csc_mode: 0x%x gamma_mode: 0x%x gamma_enable: %d csc_enable: %d\\n\",\n\t\t\t    pipe_config->csc_mode, pipe_config->gamma_mode,\n\t\t\t    pipe_config->gamma_enable, pipe_config->csc_enable);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"MST master transcoder: %s\\n\",\n\t\t    transcoder_name(pipe_config->mst_master_transcoder));\n\ndump_planes:\n\tif (!state)\n\t\treturn;\n\n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tif (plane->pipe == crtc->pipe)\n\t\t\tintel_dump_plane_state(plane_state);\n\t}\n}\n\nstatic bool check_digital_port_conflicts(struct intel_atomic_state *state)\n{\n\tstruct drm_device *dev = state->base.dev;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tunsigned int used_ports = 0;\n\tunsigned int used_mst_ports = 0;\n\tbool ret = true;\n\n\t/*\n\t * We're going to peek into connector->state,\n\t * hence connection_mutex must be held.\n\t */\n\tdrm_modeset_lock_assert_held(&dev->mode_config.connection_mutex);\n\n\t/*\n\t * Walk the connector list instead of the encoder\n\t * list to detect the problem on ddi platforms\n\t * where there's just one encoder per digital port.\n\t */\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tstruct drm_connector_state *connector_state;\n\t\tstruct intel_encoder *encoder;\n\n\t\tconnector_state =\n\t\t\tdrm_atomic_get_new_connector_state(&state->base,\n\t\t\t\t\t\t\t   connector);\n\t\tif (!connector_state)\n\t\t\tconnector_state = connector->state;\n\n\t\tif (!connector_state->best_encoder)\n\t\t\tcontinue;\n\n\t\tencoder = to_intel_encoder(connector_state->best_encoder);\n\n\t\tdrm_WARN_ON(dev, !connector_state->crtc);\n\n\t\tswitch (encoder->type) {\n\t\tcase INTEL_OUTPUT_DDI:\n\t\t\tif (drm_WARN_ON(dev, !HAS_DDI(to_i915(dev))))\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase INTEL_OUTPUT_DP:\n\t\tcase INTEL_OUTPUT_HDMI:\n\t\tcase INTEL_OUTPUT_EDP:\n\t\t\t/* the same port mustn't appear more than once */\n\t\t\tif (used_ports & BIT(encoder->port))\n\t\t\t\tret = false;\n\n\t\t\tused_ports |= BIT(encoder->port);\n\t\t\tbreak;\n\t\tcase INTEL_OUTPUT_DP_MST:\n\t\t\tused_mst_ports |=\n\t\t\t\t1 << encoder->port;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\t/* can't mix MST and SST/HDMI on the same port */\n\tif (used_ports & used_mst_ports)\n\t\treturn false;\n\n\treturn ret;\n}\n\nstatic void\nintel_crtc_copy_uapi_to_hw_state_nomodeset(struct intel_crtc_state *crtc_state)\n{\n\tintel_crtc_copy_color_blobs(crtc_state);\n}\n\nstatic void\nintel_crtc_copy_uapi_to_hw_state(struct intel_crtc_state *crtc_state)\n{\n\tcrtc_state->hw.enable = crtc_state->uapi.enable;\n\tcrtc_state->hw.active = crtc_state->uapi.active;\n\tcrtc_state->hw.mode = crtc_state->uapi.mode;\n\tcrtc_state->hw.adjusted_mode = crtc_state->uapi.adjusted_mode;\n\tintel_crtc_copy_uapi_to_hw_state_nomodeset(crtc_state);\n}\n\nstatic void intel_crtc_copy_hw_to_uapi_state(struct intel_crtc_state *crtc_state)\n{\n\tcrtc_state->uapi.enable = crtc_state->hw.enable;\n\tcrtc_state->uapi.active = crtc_state->hw.active;\n\tdrm_WARN_ON(crtc_state->uapi.crtc->dev,\n\t\t    drm_atomic_set_mode_for_crtc(&crtc_state->uapi, &crtc_state->hw.mode) < 0);\n\n\tcrtc_state->uapi.adjusted_mode = crtc_state->hw.adjusted_mode;\n\n\t/* copy color blobs to uapi */\n\tdrm_property_replace_blob(&crtc_state->uapi.degamma_lut,\n\t\t\t\t  crtc_state->hw.degamma_lut);\n\tdrm_property_replace_blob(&crtc_state->uapi.gamma_lut,\n\t\t\t\t  crtc_state->hw.gamma_lut);\n\tdrm_property_replace_blob(&crtc_state->uapi.ctm,\n\t\t\t\t  crtc_state->hw.ctm);\n}\n\nstatic int\nintel_crtc_prepare_cleared_state(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct intel_crtc_state *saved_state;\n\n\tsaved_state = intel_crtc_state_alloc(crtc);\n\tif (!saved_state)\n\t\treturn -ENOMEM;\n\n\t/* free the old crtc_state->hw members */\n\tintel_crtc_free_hw_state(crtc_state);\n\n\t/* FIXME: before the switch to atomic started, a new pipe_config was\n\t * kzalloc'd. Code that depends on any field being zero should be\n\t * fixed, so that the crtc_state can be safely duplicated. For now,\n\t * only fields that are know to not cause problems are preserved. */\n\n\tsaved_state->uapi = crtc_state->uapi;\n\tsaved_state->scaler_state = crtc_state->scaler_state;\n\tsaved_state->shared_dpll = crtc_state->shared_dpll;\n\tsaved_state->dpll_hw_state = crtc_state->dpll_hw_state;\n\tmemcpy(saved_state->icl_port_dplls, crtc_state->icl_port_dplls,\n\t       sizeof(saved_state->icl_port_dplls));\n\tsaved_state->crc_enabled = crtc_state->crc_enabled;\n\tif (IS_G4X(dev_priv) ||\n\t    IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\tsaved_state->wm = crtc_state->wm;\n\n\tmemcpy(crtc_state, saved_state, sizeof(*crtc_state));\n\tkfree(saved_state);\n\n\tintel_crtc_copy_uapi_to_hw_state(crtc_state);\n\n\treturn 0;\n}\n\nstatic int\nintel_modeset_pipe_config(struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_crtc *crtc = pipe_config->uapi.crtc;\n\tstruct drm_atomic_state *state = pipe_config->uapi.state;\n\tstruct drm_i915_private *i915 = to_i915(pipe_config->uapi.crtc->dev);\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *connector_state;\n\tint base_bpp, ret, i;\n\tbool retry = true;\n\n\tpipe_config->cpu_transcoder =\n\t\t(enum transcoder) to_intel_crtc(crtc)->pipe;\n\n\t/*\n\t * Sanitize sync polarity flags based on requested ones. If neither\n\t * positive or negative polarity is requested, treat this as meaning\n\t * negative polarity.\n\t */\n\tif (!(pipe_config->hw.adjusted_mode.flags &\n\t      (DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NHSYNC)))\n\t\tpipe_config->hw.adjusted_mode.flags |= DRM_MODE_FLAG_NHSYNC;\n\n\tif (!(pipe_config->hw.adjusted_mode.flags &\n\t      (DRM_MODE_FLAG_PVSYNC | DRM_MODE_FLAG_NVSYNC)))\n\t\tpipe_config->hw.adjusted_mode.flags |= DRM_MODE_FLAG_NVSYNC;\n\n\tret = compute_baseline_pipe_bpp(to_intel_crtc(crtc),\n\t\t\t\t\tpipe_config);\n\tif (ret)\n\t\treturn ret;\n\n\tbase_bpp = pipe_config->pipe_bpp;\n\n\t/*\n\t * Determine the real pipe dimensions. Note that stereo modes can\n\t * increase the actual pipe size due to the frame doubling and\n\t * insertion of additional space for blanks between the frame. This\n\t * is stored in the crtc timings. We use the requested mode to do this\n\t * computation to clearly distinguish it from the adjusted mode, which\n\t * can be changed by the connectors in the below retry loop.\n\t */\n\tdrm_mode_get_hv_timing(&pipe_config->hw.mode,\n\t\t\t       &pipe_config->pipe_src_w,\n\t\t\t       &pipe_config->pipe_src_h);\n\n\tfor_each_new_connector_in_state(state, connector, connector_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(connector_state->best_encoder);\n\n\t\tif (connector_state->crtc != crtc)\n\t\t\tcontinue;\n\n\t\tif (!check_single_encoder_cloning(state, to_intel_crtc(crtc), encoder)) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"rejecting invalid cloning configuration\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/*\n\t\t * Determine output_types before calling the .compute_config()\n\t\t * hooks so that the hooks can use this information safely.\n\t\t */\n\t\tif (encoder->compute_output_type)\n\t\t\tpipe_config->output_types |=\n\t\t\t\tBIT(encoder->compute_output_type(encoder, pipe_config,\n\t\t\t\t\t\t\t\t connector_state));\n\t\telse\n\t\t\tpipe_config->output_types |= BIT(encoder->type);\n\t}\n\nencoder_retry:\n\t/* Ensure the port clock defaults are reset when retrying. */\n\tpipe_config->port_clock = 0;\n\tpipe_config->pixel_multiplier = 1;\n\n\t/* Fill in default crtc timings, allow encoders to overwrite them. */\n\tdrm_mode_set_crtcinfo(&pipe_config->hw.adjusted_mode,\n\t\t\t      CRTC_STEREO_DOUBLE);\n\n\t/* Pass our mode to the connectors and the CRTC to give them a chance to\n\t * adjust it according to limitations or connector properties, and also\n\t * a chance to reject the mode entirely.\n\t */\n\tfor_each_new_connector_in_state(state, connector, connector_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(connector_state->best_encoder);\n\n\t\tif (connector_state->crtc != crtc)\n\t\t\tcontinue;\n\n\t\tret = encoder->compute_config(encoder, pipe_config,\n\t\t\t\t\t      connector_state);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -EDEADLK)\n\t\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t\t    \"Encoder config failure: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Set default port clock if not overwritten by the encoder. Needs to be\n\t * done afterwards in case the encoder adjusts the mode. */\n\tif (!pipe_config->port_clock)\n\t\tpipe_config->port_clock = pipe_config->hw.adjusted_mode.crtc_clock\n\t\t\t* pipe_config->pixel_multiplier;\n\n\tret = intel_crtc_compute_config(to_intel_crtc(crtc), pipe_config);\n\tif (ret == -EDEADLK)\n\t\treturn ret;\n\tif (ret < 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"CRTC fixup failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (ret == RETRY) {\n\t\tif (drm_WARN(&i915->drm, !retry,\n\t\t\t     \"loop in pipe configuration computation\\n\"))\n\t\t\treturn -EINVAL;\n\n\t\tdrm_dbg_kms(&i915->drm, \"CRTC bw constrained, retrying\\n\");\n\t\tretry = false;\n\t\tgoto encoder_retry;\n\t}\n\n\t/* Dithering seems to not pass-through bits correctly when it should, so\n\t * only enable it on 6bpc panels and when its not a compliance\n\t * test requesting 6bpc video pattern.\n\t */\n\tpipe_config->dither = (pipe_config->pipe_bpp == 6*3) &&\n\t\t!pipe_config->dither_force_disable;\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"hw max bpp: %i, pipe bpp: %i, dithering: %i\\n\",\n\t\t    base_bpp, pipe_config->pipe_bpp, pipe_config->dither);\n\n\treturn 0;\n}\n\nstatic int\nintel_modeset_pipe_config_late(struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_atomic_state *state =\n\t\tto_intel_atomic_state(crtc_state->uapi.state);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_connector *connector;\n\tint i;\n\n\tfor_each_new_connector_in_state(&state->base, connector,\n\t\t\t\t\tconn_state, i) {\n\t\tstruct intel_encoder *encoder =\n\t\t\tto_intel_encoder(conn_state->best_encoder);\n\t\tint ret;\n\n\t\tif (conn_state->crtc != &crtc->base ||\n\t\t    !encoder->compute_config_late)\n\t\t\tcontinue;\n\n\t\tret = encoder->compute_config_late(encoder, crtc_state,\n\t\t\t\t\t\t   conn_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nbool intel_fuzzy_clock_check(int clock1, int clock2)\n{\n\tint diff;\n\n\tif (clock1 == clock2)\n\t\treturn true;\n\n\tif (!clock1 || !clock2)\n\t\treturn false;\n\n\tdiff = abs(clock1 - clock2);\n\n\tif (((((diff + clock1 + clock2) * 100)) / (clock1 + clock2)) < 105)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool\nintel_compare_m_n(unsigned int m, unsigned int n,\n\t\t  unsigned int m2, unsigned int n2,\n\t\t  bool exact)\n{\n\tif (m == m2 && n == n2)\n\t\treturn true;\n\n\tif (exact || !m || !n || !m2 || !n2)\n\t\treturn false;\n\n\tBUILD_BUG_ON(DATA_LINK_M_N_MASK > INT_MAX);\n\n\tif (n > n2) {\n\t\twhile (n > n2) {\n\t\t\tm2 <<= 1;\n\t\t\tn2 <<= 1;\n\t\t}\n\t} else if (n < n2) {\n\t\twhile (n < n2) {\n\t\t\tm <<= 1;\n\t\t\tn <<= 1;\n\t\t}\n\t}\n\n\tif (n != n2)\n\t\treturn false;\n\n\treturn intel_fuzzy_clock_check(m, m2);\n}\n\nstatic bool\nintel_compare_link_m_n(const struct intel_link_m_n *m_n,\n\t\t       const struct intel_link_m_n *m2_n2,\n\t\t       bool exact)\n{\n\treturn m_n->tu == m2_n2->tu &&\n\t\tintel_compare_m_n(m_n->gmch_m, m_n->gmch_n,\n\t\t\t\t  m2_n2->gmch_m, m2_n2->gmch_n, exact) &&\n\t\tintel_compare_m_n(m_n->link_m, m_n->link_n,\n\t\t\t\t  m2_n2->link_m, m2_n2->link_n, exact);\n}\n\nstatic bool\nintel_compare_infoframe(const union hdmi_infoframe *a,\n\t\t\tconst union hdmi_infoframe *b)\n{\n\treturn memcmp(a, b, sizeof(*a)) == 0;\n}\n\nstatic bool\nintel_compare_dp_vsc_sdp(const struct drm_dp_vsc_sdp *a,\n\t\t\t const struct drm_dp_vsc_sdp *b)\n{\n\treturn memcmp(a, b, sizeof(*a)) == 0;\n}\n\nstatic void\npipe_config_infoframe_mismatch(struct drm_i915_private *dev_priv,\n\t\t\t       bool fastset, const char *name,\n\t\t\t       const union hdmi_infoframe *a,\n\t\t\t       const union hdmi_infoframe *b)\n{\n\tif (fastset) {\n\t\tif (!drm_debug_enabled(DRM_UT_KMS))\n\t\t\treturn;\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"fastset mismatch in %s infoframe\\n\", name);\n\t\tdrm_dbg_kms(&dev_priv->drm, \"expected:\\n\");\n\t\thdmi_infoframe_log(KERN_DEBUG, dev_priv->drm.dev, a);\n\t\tdrm_dbg_kms(&dev_priv->drm, \"found:\\n\");\n\t\thdmi_infoframe_log(KERN_DEBUG, dev_priv->drm.dev, b);\n\t} else {\n\t\tdrm_err(&dev_priv->drm, \"mismatch in %s infoframe\\n\", name);\n\t\tdrm_err(&dev_priv->drm, \"expected:\\n\");\n\t\thdmi_infoframe_log(KERN_ERR, dev_priv->drm.dev, a);\n\t\tdrm_err(&dev_priv->drm, \"found:\\n\");\n\t\thdmi_infoframe_log(KERN_ERR, dev_priv->drm.dev, b);\n\t}\n}\n\nstatic void\npipe_config_dp_vsc_sdp_mismatch(struct drm_i915_private *dev_priv,\n\t\t\t\tbool fastset, const char *name,\n\t\t\t\tconst struct drm_dp_vsc_sdp *a,\n\t\t\t\tconst struct drm_dp_vsc_sdp *b)\n{\n\tif (fastset) {\n\t\tif (!drm_debug_enabled(DRM_UT_KMS))\n\t\t\treturn;\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"fastset mismatch in %s dp sdp\\n\", name);\n\t\tdrm_dbg_kms(&dev_priv->drm, \"expected:\\n\");\n\t\tdrm_dp_vsc_sdp_log(KERN_DEBUG, dev_priv->drm.dev, a);\n\t\tdrm_dbg_kms(&dev_priv->drm, \"found:\\n\");\n\t\tdrm_dp_vsc_sdp_log(KERN_DEBUG, dev_priv->drm.dev, b);\n\t} else {\n\t\tdrm_err(&dev_priv->drm, \"mismatch in %s dp sdp\\n\", name);\n\t\tdrm_err(&dev_priv->drm, \"expected:\\n\");\n\t\tdrm_dp_vsc_sdp_log(KERN_ERR, dev_priv->drm.dev, a);\n\t\tdrm_err(&dev_priv->drm, \"found:\\n\");\n\t\tdrm_dp_vsc_sdp_log(KERN_ERR, dev_priv->drm.dev, b);\n\t}\n}\n\nstatic void __printf(4, 5)\npipe_config_mismatch(bool fastset, const struct intel_crtc *crtc,\n\t\t     const char *name, const char *format, ...)\n{\n\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, format);\n\tvaf.fmt = format;\n\tvaf.va = &args;\n\n\tif (fastset)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"[CRTC:%d:%s] fastset mismatch in %s %pV\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name, name, &vaf);\n\telse\n\t\tdrm_err(&i915->drm, \"[CRTC:%d:%s] mismatch in %s %pV\\n\",\n\t\t\tcrtc->base.base.id, crtc->base.name, name, &vaf);\n\n\tva_end(args);\n}\n\nstatic bool fastboot_enabled(struct drm_i915_private *dev_priv)\n{\n\tif (dev_priv->params.fastboot != -1)\n\t\treturn dev_priv->params.fastboot;\n\n\t/* Enable fastboot by default on Skylake and newer */\n\tif (INTEL_GEN(dev_priv) >= 9)\n\t\treturn true;\n\n\t/* Enable fastboot by default on VLV and CHV */\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\treturn true;\n\n\t/* Disabled by default on all others */\n\treturn false;\n}\n\nstatic bool\nintel_pipe_config_compare(const struct intel_crtc_state *current_config,\n\t\t\t  const struct intel_crtc_state *pipe_config,\n\t\t\t  bool fastset)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(current_config->uapi.crtc->dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tbool ret = true;\n\tu32 bp_gamma = 0;\n\tbool fixup_inherited = fastset &&\n\t\tcurrent_config->inherited && !pipe_config->inherited;\n\n\tif (fixup_inherited && !fastboot_enabled(dev_priv)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"initial modeset and fastboot not set\\n\");\n\t\tret = false;\n\t}\n\n#define PIPE_CONF_CHECK_X(name) do { \\\n\tif (current_config->name != pipe_config->name) { \\\n\t\tpipe_config_mismatch(fastset, crtc, __stringify(name), \\\n\t\t\t\t     \"(expected 0x%08x, found 0x%08x)\", \\\n\t\t\t\t     current_config->name, \\\n\t\t\t\t     pipe_config->name); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_I(name) do { \\\n\tif (current_config->name != pipe_config->name) { \\\n\t\tpipe_config_mismatch(fastset, crtc, __stringify(name), \\\n\t\t\t\t     \"(expected %i, found %i)\", \\\n\t\t\t\t     current_config->name, \\\n\t\t\t\t     pipe_config->name); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_BOOL(name) do { \\\n\tif (current_config->name != pipe_config->name) { \\\n\t\tpipe_config_mismatch(fastset, crtc,  __stringify(name), \\\n\t\t\t\t     \"(expected %s, found %s)\", \\\n\t\t\t\t     yesno(current_config->name), \\\n\t\t\t\t     yesno(pipe_config->name)); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n/*\n * Checks state where we only read out the enabling, but not the entire\n * state itself (like full infoframes or ELD for audio). These states\n * require a full modeset on bootup to fix up.\n */\n#define PIPE_CONF_CHECK_BOOL_INCOMPLETE(name) do { \\\n\tif (!fixup_inherited || (!current_config->name && !pipe_config->name)) { \\\n\t\tPIPE_CONF_CHECK_BOOL(name); \\\n\t} else { \\\n\t\tpipe_config_mismatch(fastset, crtc, __stringify(name), \\\n\t\t\t\t     \"unable to verify whether state matches exactly, forcing modeset (expected %s, found %s)\", \\\n\t\t\t\t     yesno(current_config->name), \\\n\t\t\t\t     yesno(pipe_config->name)); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_P(name) do { \\\n\tif (current_config->name != pipe_config->name) { \\\n\t\tpipe_config_mismatch(fastset, crtc, __stringify(name), \\\n\t\t\t\t     \"(expected %p, found %p)\", \\\n\t\t\t\t     current_config->name, \\\n\t\t\t\t     pipe_config->name); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_M_N(name) do { \\\n\tif (!intel_compare_link_m_n(&current_config->name, \\\n\t\t\t\t    &pipe_config->name,\\\n\t\t\t\t    !fastset)) { \\\n\t\tpipe_config_mismatch(fastset, crtc, __stringify(name), \\\n\t\t\t\t     \"(expected tu %i gmch %i/%i link %i/%i, \" \\\n\t\t\t\t     \"found tu %i, gmch %i/%i link %i/%i)\", \\\n\t\t\t\t     current_config->name.tu, \\\n\t\t\t\t     current_config->name.gmch_m, \\\n\t\t\t\t     current_config->name.gmch_n, \\\n\t\t\t\t     current_config->name.link_m, \\\n\t\t\t\t     current_config->name.link_n, \\\n\t\t\t\t     pipe_config->name.tu, \\\n\t\t\t\t     pipe_config->name.gmch_m, \\\n\t\t\t\t     pipe_config->name.gmch_n, \\\n\t\t\t\t     pipe_config->name.link_m, \\\n\t\t\t\t     pipe_config->name.link_n); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n/* This is required for BDW+ where there is only one set of registers for\n * switching between high and low RR.\n * This macro can be used whenever a comparison has to be made between one\n * hw state and multiple sw state variables.\n */\n#define PIPE_CONF_CHECK_M_N_ALT(name, alt_name) do { \\\n\tif (!intel_compare_link_m_n(&current_config->name, \\\n\t\t\t\t    &pipe_config->name, !fastset) && \\\n\t    !intel_compare_link_m_n(&current_config->alt_name, \\\n\t\t\t\t    &pipe_config->name, !fastset)) { \\\n\t\tpipe_config_mismatch(fastset, crtc, __stringify(name), \\\n\t\t\t\t     \"(expected tu %i gmch %i/%i link %i/%i, \" \\\n\t\t\t\t     \"or tu %i gmch %i/%i link %i/%i, \" \\\n\t\t\t\t     \"found tu %i, gmch %i/%i link %i/%i)\", \\\n\t\t\t\t     current_config->name.tu, \\\n\t\t\t\t     current_config->name.gmch_m, \\\n\t\t\t\t     current_config->name.gmch_n, \\\n\t\t\t\t     current_config->name.link_m, \\\n\t\t\t\t     current_config->name.link_n, \\\n\t\t\t\t     current_config->alt_name.tu, \\\n\t\t\t\t     current_config->alt_name.gmch_m, \\\n\t\t\t\t     current_config->alt_name.gmch_n, \\\n\t\t\t\t     current_config->alt_name.link_m, \\\n\t\t\t\t     current_config->alt_name.link_n, \\\n\t\t\t\t     pipe_config->name.tu, \\\n\t\t\t\t     pipe_config->name.gmch_m, \\\n\t\t\t\t     pipe_config->name.gmch_n, \\\n\t\t\t\t     pipe_config->name.link_m, \\\n\t\t\t\t     pipe_config->name.link_n); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_FLAGS(name, mask) do { \\\n\tif ((current_config->name ^ pipe_config->name) & (mask)) { \\\n\t\tpipe_config_mismatch(fastset, crtc, __stringify(name), \\\n\t\t\t\t     \"(%x) (expected %i, found %i)\", \\\n\t\t\t\t     (mask), \\\n\t\t\t\t     current_config->name & (mask), \\\n\t\t\t\t     pipe_config->name & (mask)); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_CLOCK_FUZZY(name) do { \\\n\tif (!intel_fuzzy_clock_check(current_config->name, pipe_config->name)) { \\\n\t\tpipe_config_mismatch(fastset, crtc, __stringify(name), \\\n\t\t\t\t     \"(expected %i, found %i)\", \\\n\t\t\t\t     current_config->name, \\\n\t\t\t\t     pipe_config->name); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_INFOFRAME(name) do { \\\n\tif (!intel_compare_infoframe(&current_config->infoframes.name, \\\n\t\t\t\t     &pipe_config->infoframes.name)) { \\\n\t\tpipe_config_infoframe_mismatch(dev_priv, fastset, __stringify(name), \\\n\t\t\t\t\t       &current_config->infoframes.name, \\\n\t\t\t\t\t       &pipe_config->infoframes.name); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_DP_VSC_SDP(name) do { \\\n\tif (!current_config->has_psr && !pipe_config->has_psr && \\\n\t    !intel_compare_dp_vsc_sdp(&current_config->infoframes.name, \\\n\t\t\t\t      &pipe_config->infoframes.name)) { \\\n\t\tpipe_config_dp_vsc_sdp_mismatch(dev_priv, fastset, __stringify(name), \\\n\t\t\t\t\t\t&current_config->infoframes.name, \\\n\t\t\t\t\t\t&pipe_config->infoframes.name); \\\n\t\tret = false; \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_CHECK_COLOR_LUT(name1, name2, bit_precision) do { \\\n\tif (current_config->name1 != pipe_config->name1) { \\\n\t\tpipe_config_mismatch(fastset, crtc, __stringify(name1), \\\n\t\t\t\t\"(expected %i, found %i, won't compare lut values)\", \\\n\t\t\t\tcurrent_config->name1, \\\n\t\t\t\tpipe_config->name1); \\\n\t\tret = false;\\\n\t} else { \\\n\t\tif (!intel_color_lut_equal(current_config->name2, \\\n\t\t\t\t\tpipe_config->name2, pipe_config->name1, \\\n\t\t\t\t\tbit_precision)) { \\\n\t\t\tpipe_config_mismatch(fastset, crtc, __stringify(name2), \\\n\t\t\t\t\t\"hw_state doesn't match sw_state\"); \\\n\t\t\tret = false; \\\n\t\t} \\\n\t} \\\n} while (0)\n\n#define PIPE_CONF_QUIRK(quirk) \\\n\t((current_config->quirks | pipe_config->quirks) & (quirk))\n\n\tPIPE_CONF_CHECK_I(cpu_transcoder);\n\n\tPIPE_CONF_CHECK_BOOL(has_pch_encoder);\n\tPIPE_CONF_CHECK_I(fdi_lanes);\n\tPIPE_CONF_CHECK_M_N(fdi_m_n);\n\n\tPIPE_CONF_CHECK_I(lane_count);\n\tPIPE_CONF_CHECK_X(lane_lat_optim_mask);\n\n\tif (INTEL_GEN(dev_priv) < 8) {\n\t\tPIPE_CONF_CHECK_M_N(dp_m_n);\n\n\t\tif (current_config->has_drrs)\n\t\t\tPIPE_CONF_CHECK_M_N(dp_m2_n2);\n\t} else\n\t\tPIPE_CONF_CHECK_M_N_ALT(dp_m_n, dp_m2_n2);\n\n\tPIPE_CONF_CHECK_X(output_types);\n\n\tPIPE_CONF_CHECK_I(hw.adjusted_mode.crtc_hdisplay);\n\tPIPE_CONF_CHECK_I(hw.adjusted_mode.crtc_htotal);\n\tPIPE_CONF_CHECK_I(hw.adjusted_mode.crtc_hblank_start);\n\tPIPE_CONF_CHECK_I(hw.adjusted_mode.crtc_hblank_end);\n\tPIPE_CONF_CHECK_I(hw.adjusted_mode.crtc_hsync_start);\n\tPIPE_CONF_CHECK_I(hw.adjusted_mode.crtc_hsync_end);\n\n\tPIPE_CONF_CHECK_I(hw.adjusted_mode.crtc_vdisplay);\n\tPIPE_CONF_CHECK_I(hw.adjusted_mode.crtc_vtotal);\n\tPIPE_CONF_CHECK_I(hw.adjusted_mode.crtc_vblank_start);\n\tPIPE_CONF_CHECK_I(hw.adjusted_mode.crtc_vblank_end);\n\tPIPE_CONF_CHECK_I(hw.adjusted_mode.crtc_vsync_start);\n\tPIPE_CONF_CHECK_I(hw.adjusted_mode.crtc_vsync_end);\n\n\tPIPE_CONF_CHECK_I(pixel_multiplier);\n\tPIPE_CONF_CHECK_I(output_format);\n\tPIPE_CONF_CHECK_BOOL(has_hdmi_sink);\n\tif ((INTEL_GEN(dev_priv) < 8 && !IS_HASWELL(dev_priv)) ||\n\t    IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\tPIPE_CONF_CHECK_BOOL(limited_color_range);\n\n\tPIPE_CONF_CHECK_BOOL(hdmi_scrambling);\n\tPIPE_CONF_CHECK_BOOL(hdmi_high_tmds_clock_ratio);\n\tPIPE_CONF_CHECK_BOOL(has_infoframe);\n\tPIPE_CONF_CHECK_BOOL(fec_enable);\n\n\tPIPE_CONF_CHECK_BOOL_INCOMPLETE(has_audio);\n\n\tPIPE_CONF_CHECK_FLAGS(hw.adjusted_mode.flags,\n\t\t\t      DRM_MODE_FLAG_INTERLACE);\n\n\tif (!PIPE_CONF_QUIRK(PIPE_CONFIG_QUIRK_MODE_SYNC_FLAGS)) {\n\t\tPIPE_CONF_CHECK_FLAGS(hw.adjusted_mode.flags,\n\t\t\t\t      DRM_MODE_FLAG_PHSYNC);\n\t\tPIPE_CONF_CHECK_FLAGS(hw.adjusted_mode.flags,\n\t\t\t\t      DRM_MODE_FLAG_NHSYNC);\n\t\tPIPE_CONF_CHECK_FLAGS(hw.adjusted_mode.flags,\n\t\t\t\t      DRM_MODE_FLAG_PVSYNC);\n\t\tPIPE_CONF_CHECK_FLAGS(hw.adjusted_mode.flags,\n\t\t\t\t      DRM_MODE_FLAG_NVSYNC);\n\t}\n\n\tPIPE_CONF_CHECK_X(gmch_pfit.control);\n\t/* pfit ratios are autocomputed by the hw on gen4+ */\n\tif (INTEL_GEN(dev_priv) < 4)\n\t\tPIPE_CONF_CHECK_X(gmch_pfit.pgm_ratios);\n\tPIPE_CONF_CHECK_X(gmch_pfit.lvds_border_bits);\n\n\t/*\n\t * Changing the EDP transcoder input mux\n\t * (A_ONOFF vs. A_ON) requires a full modeset.\n\t */\n\tPIPE_CONF_CHECK_BOOL(pch_pfit.force_thru);\n\n\tif (!fastset) {\n\t\tPIPE_CONF_CHECK_I(pipe_src_w);\n\t\tPIPE_CONF_CHECK_I(pipe_src_h);\n\n\t\tPIPE_CONF_CHECK_BOOL(pch_pfit.enabled);\n\t\tif (current_config->pch_pfit.enabled) {\n\t\t\tPIPE_CONF_CHECK_I(pch_pfit.dst.x1);\n\t\t\tPIPE_CONF_CHECK_I(pch_pfit.dst.y1);\n\t\t\tPIPE_CONF_CHECK_I(pch_pfit.dst.x2);\n\t\t\tPIPE_CONF_CHECK_I(pch_pfit.dst.y2);\n\t\t}\n\n\t\tPIPE_CONF_CHECK_I(scaler_state.scaler_id);\n\t\tPIPE_CONF_CHECK_CLOCK_FUZZY(pixel_rate);\n\n\t\tPIPE_CONF_CHECK_X(gamma_mode);\n\t\tif (IS_CHERRYVIEW(dev_priv))\n\t\t\tPIPE_CONF_CHECK_X(cgm_mode);\n\t\telse\n\t\t\tPIPE_CONF_CHECK_X(csc_mode);\n\t\tPIPE_CONF_CHECK_BOOL(gamma_enable);\n\t\tPIPE_CONF_CHECK_BOOL(csc_enable);\n\n\t\tPIPE_CONF_CHECK_I(linetime);\n\t\tPIPE_CONF_CHECK_I(ips_linetime);\n\n\t\tbp_gamma = intel_color_get_gamma_bit_precision(pipe_config);\n\t\tif (bp_gamma)\n\t\t\tPIPE_CONF_CHECK_COLOR_LUT(gamma_mode, hw.gamma_lut, bp_gamma);\n\t}\n\n\tPIPE_CONF_CHECK_BOOL(double_wide);\n\n\tPIPE_CONF_CHECK_P(shared_dpll);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.dpll);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.dpll_md);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.fp0);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.fp1);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.wrpll);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.spll);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.ctrl1);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.cfgcr1);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.cfgcr2);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.cfgcr0);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.ebb0);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.ebb4);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.pll0);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.pll1);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.pll2);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.pll3);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.pll6);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.pll8);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.pll9);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.pll10);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.pcsdw12);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_refclkin_ctl);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_clktop2_coreclkctl1);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_clktop2_hsclkctl);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_pll_div0);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_pll_div1);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_pll_lf);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_pll_frac_lock);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_pll_ssc);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_pll_bias);\n\tPIPE_CONF_CHECK_X(dpll_hw_state.mg_pll_tdc_coldst_bias);\n\n\tPIPE_CONF_CHECK_X(dsi_pll.ctrl);\n\tPIPE_CONF_CHECK_X(dsi_pll.div);\n\n\tif (IS_G4X(dev_priv) || INTEL_GEN(dev_priv) >= 5)\n\t\tPIPE_CONF_CHECK_I(pipe_bpp);\n\n\tPIPE_CONF_CHECK_CLOCK_FUZZY(hw.adjusted_mode.crtc_clock);\n\tPIPE_CONF_CHECK_CLOCK_FUZZY(port_clock);\n\n\tPIPE_CONF_CHECK_I(min_voltage_level);\n\n\tPIPE_CONF_CHECK_X(infoframes.enable);\n\tPIPE_CONF_CHECK_X(infoframes.gcp);\n\tPIPE_CONF_CHECK_INFOFRAME(avi);\n\tPIPE_CONF_CHECK_INFOFRAME(spd);\n\tPIPE_CONF_CHECK_INFOFRAME(hdmi);\n\tPIPE_CONF_CHECK_INFOFRAME(drm);\n\tPIPE_CONF_CHECK_DP_VSC_SDP(vsc);\n\n\tPIPE_CONF_CHECK_X(sync_mode_slaves_mask);\n\tPIPE_CONF_CHECK_I(master_transcoder);\n\n\tPIPE_CONF_CHECK_I(dsc.compression_enable);\n\tPIPE_CONF_CHECK_I(dsc.dsc_split);\n\tPIPE_CONF_CHECK_I(dsc.compressed_bpp);\n\n\tPIPE_CONF_CHECK_I(mst_master_transcoder);\n\n#undef PIPE_CONF_CHECK_X\n#undef PIPE_CONF_CHECK_I\n#undef PIPE_CONF_CHECK_BOOL\n#undef PIPE_CONF_CHECK_BOOL_INCOMPLETE\n#undef PIPE_CONF_CHECK_P\n#undef PIPE_CONF_CHECK_FLAGS\n#undef PIPE_CONF_CHECK_CLOCK_FUZZY\n#undef PIPE_CONF_CHECK_COLOR_LUT\n#undef PIPE_CONF_QUIRK\n\n\treturn ret;\n}\n\nstatic void intel_pipe_config_sanity_check(struct drm_i915_private *dev_priv,\n\t\t\t\t\t   const struct intel_crtc_state *pipe_config)\n{\n\tif (pipe_config->has_pch_encoder) {\n\t\tint fdi_dotclock = intel_dotclock_calculate(intel_fdi_link_freq(dev_priv, pipe_config),\n\t\t\t\t\t\t\t    &pipe_config->fdi_m_n);\n\t\tint dotclock = pipe_config->hw.adjusted_mode.crtc_clock;\n\n\t\t/*\n\t\t * FDI already provided one idea for the dotclock.\n\t\t * Yell if the encoder disagrees.\n\t\t */\n\t\tdrm_WARN(&dev_priv->drm,\n\t\t\t !intel_fuzzy_clock_check(fdi_dotclock, dotclock),\n\t\t\t \"FDI dotclock and encoder dotclock mismatch, fdi: %i, encoder: %i\\n\",\n\t\t\t fdi_dotclock, dotclock);\n\t}\n}\n\nstatic void verify_wm_state(struct intel_crtc *crtc,\n\t\t\t    struct intel_crtc_state *new_crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tstruct skl_hw_state {\n\t\tstruct skl_ddb_entry ddb_y[I915_MAX_PLANES];\n\t\tstruct skl_ddb_entry ddb_uv[I915_MAX_PLANES];\n\t\tstruct skl_pipe_wm wm;\n\t} *hw;\n\tstruct skl_pipe_wm *sw_wm;\n\tstruct skl_ddb_entry *hw_ddb_entry, *sw_ddb_entry;\n\tu8 hw_enabled_slices;\n\tconst enum pipe pipe = crtc->pipe;\n\tint plane, level, max_level = ilk_wm_max_level(dev_priv);\n\n\tif (INTEL_GEN(dev_priv) < 9 || !new_crtc_state->hw.active)\n\t\treturn;\n\n\thw = kzalloc(sizeof(*hw), GFP_KERNEL);\n\tif (!hw)\n\t\treturn;\n\n\tskl_pipe_wm_get_hw_state(crtc, &hw->wm);\n\tsw_wm = &new_crtc_state->wm.skl.optimal;\n\n\tskl_pipe_ddb_get_hw_state(crtc, hw->ddb_y, hw->ddb_uv);\n\n\thw_enabled_slices = intel_enabled_dbuf_slices_mask(dev_priv);\n\n\tif (INTEL_GEN(dev_priv) >= 11 &&\n\t    hw_enabled_slices != dev_priv->dbuf.enabled_slices)\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"mismatch in DBUF Slices (expected 0x%x, got 0x%x)\\n\",\n\t\t\tdev_priv->dbuf.enabled_slices,\n\t\t\thw_enabled_slices);\n\n\t/* planes */\n\tfor_each_universal_plane(dev_priv, pipe, plane) {\n\t\tstruct skl_plane_wm *hw_plane_wm, *sw_plane_wm;\n\n\t\thw_plane_wm = &hw->wm.planes[plane];\n\t\tsw_plane_wm = &sw_wm->planes[plane];\n\n\t\t/* Watermarks */\n\t\tfor (level = 0; level <= max_level; level++) {\n\t\t\tif (skl_wm_level_equals(&hw_plane_wm->wm[level],\n\t\t\t\t\t\t&sw_plane_wm->wm[level]) ||\n\t\t\t    (level == 0 && skl_wm_level_equals(&hw_plane_wm->wm[level],\n\t\t\t\t\t\t\t       &sw_plane_wm->sagv_wm0)))\n\t\t\t\tcontinue;\n\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"mismatch in WM pipe %c plane %d level %d (expected e=%d b=%u l=%u, got e=%d b=%u l=%u)\\n\",\n\t\t\t\tpipe_name(pipe), plane + 1, level,\n\t\t\t\tsw_plane_wm->wm[level].plane_en,\n\t\t\t\tsw_plane_wm->wm[level].plane_res_b,\n\t\t\t\tsw_plane_wm->wm[level].plane_res_l,\n\t\t\t\thw_plane_wm->wm[level].plane_en,\n\t\t\t\thw_plane_wm->wm[level].plane_res_b,\n\t\t\t\thw_plane_wm->wm[level].plane_res_l);\n\t\t}\n\n\t\tif (!skl_wm_level_equals(&hw_plane_wm->trans_wm,\n\t\t\t\t\t &sw_plane_wm->trans_wm)) {\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"mismatch in trans WM pipe %c plane %d (expected e=%d b=%u l=%u, got e=%d b=%u l=%u)\\n\",\n\t\t\t\tpipe_name(pipe), plane + 1,\n\t\t\t\tsw_plane_wm->trans_wm.plane_en,\n\t\t\t\tsw_plane_wm->trans_wm.plane_res_b,\n\t\t\t\tsw_plane_wm->trans_wm.plane_res_l,\n\t\t\t\thw_plane_wm->trans_wm.plane_en,\n\t\t\t\thw_plane_wm->trans_wm.plane_res_b,\n\t\t\t\thw_plane_wm->trans_wm.plane_res_l);\n\t\t}\n\n\t\t/* DDB */\n\t\thw_ddb_entry = &hw->ddb_y[plane];\n\t\tsw_ddb_entry = &new_crtc_state->wm.skl.plane_ddb_y[plane];\n\n\t\tif (!skl_ddb_entry_equal(hw_ddb_entry, sw_ddb_entry)) {\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"mismatch in DDB state pipe %c plane %d (expected (%u,%u), found (%u,%u))\\n\",\n\t\t\t\tpipe_name(pipe), plane + 1,\n\t\t\t\tsw_ddb_entry->start, sw_ddb_entry->end,\n\t\t\t\thw_ddb_entry->start, hw_ddb_entry->end);\n\t\t}\n\t}\n\n\t/*\n\t * cursor\n\t * If the cursor plane isn't active, we may not have updated it's ddb\n\t * allocation. In that case since the ddb allocation will be updated\n\t * once the plane becomes visible, we can skip this check\n\t */\n\tif (1) {\n\t\tstruct skl_plane_wm *hw_plane_wm, *sw_plane_wm;\n\n\t\thw_plane_wm = &hw->wm.planes[PLANE_CURSOR];\n\t\tsw_plane_wm = &sw_wm->planes[PLANE_CURSOR];\n\n\t\t/* Watermarks */\n\t\tfor (level = 0; level <= max_level; level++) {\n\t\t\tif (skl_wm_level_equals(&hw_plane_wm->wm[level],\n\t\t\t\t\t\t&sw_plane_wm->wm[level]) ||\n\t\t\t    (level == 0 && skl_wm_level_equals(&hw_plane_wm->wm[level],\n\t\t\t\t\t\t\t       &sw_plane_wm->sagv_wm0)))\n\t\t\t\tcontinue;\n\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"mismatch in WM pipe %c cursor level %d (expected e=%d b=%u l=%u, got e=%d b=%u l=%u)\\n\",\n\t\t\t\tpipe_name(pipe), level,\n\t\t\t\tsw_plane_wm->wm[level].plane_en,\n\t\t\t\tsw_plane_wm->wm[level].plane_res_b,\n\t\t\t\tsw_plane_wm->wm[level].plane_res_l,\n\t\t\t\thw_plane_wm->wm[level].plane_en,\n\t\t\t\thw_plane_wm->wm[level].plane_res_b,\n\t\t\t\thw_plane_wm->wm[level].plane_res_l);\n\t\t}\n\n\t\tif (!skl_wm_level_equals(&hw_plane_wm->trans_wm,\n\t\t\t\t\t &sw_plane_wm->trans_wm)) {\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"mismatch in trans WM pipe %c cursor (expected e=%d b=%u l=%u, got e=%d b=%u l=%u)\\n\",\n\t\t\t\tpipe_name(pipe),\n\t\t\t\tsw_plane_wm->trans_wm.plane_en,\n\t\t\t\tsw_plane_wm->trans_wm.plane_res_b,\n\t\t\t\tsw_plane_wm->trans_wm.plane_res_l,\n\t\t\t\thw_plane_wm->trans_wm.plane_en,\n\t\t\t\thw_plane_wm->trans_wm.plane_res_b,\n\t\t\t\thw_plane_wm->trans_wm.plane_res_l);\n\t\t}\n\n\t\t/* DDB */\n\t\thw_ddb_entry = &hw->ddb_y[PLANE_CURSOR];\n\t\tsw_ddb_entry = &new_crtc_state->wm.skl.plane_ddb_y[PLANE_CURSOR];\n\n\t\tif (!skl_ddb_entry_equal(hw_ddb_entry, sw_ddb_entry)) {\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"mismatch in DDB state pipe %c cursor (expected (%u,%u), found (%u,%u))\\n\",\n\t\t\t\tpipe_name(pipe),\n\t\t\t\tsw_ddb_entry->start, sw_ddb_entry->end,\n\t\t\t\thw_ddb_entry->start, hw_ddb_entry->end);\n\t\t}\n\t}\n\n\tkfree(hw);\n}\n\nstatic void\nverify_connector_state(struct intel_atomic_state *state,\n\t\t       struct intel_crtc *crtc)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *new_conn_state;\n\tint i;\n\n\tfor_each_new_connector_in_state(&state->base, connector, new_conn_state, i) {\n\t\tstruct drm_encoder *encoder = connector->encoder;\n\t\tstruct intel_crtc_state *crtc_state = NULL;\n\n\t\tif (new_conn_state->crtc != &crtc->base)\n\t\t\tcontinue;\n\n\t\tif (crtc)\n\t\t\tcrtc_state = intel_atomic_get_new_crtc_state(state, crtc);\n\n\t\tintel_connector_verify_state(crtc_state, new_conn_state);\n\n\t\tI915_STATE_WARN(new_conn_state->best_encoder != encoder,\n\t\t     \"connector's atomic encoder doesn't match legacy encoder\\n\");\n\t}\n}\n\nstatic void\nverify_encoder_state(struct drm_i915_private *dev_priv, struct intel_atomic_state *state)\n{\n\tstruct intel_encoder *encoder;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *old_conn_state, *new_conn_state;\n\tint i;\n\n\tfor_each_intel_encoder(&dev_priv->drm, encoder) {\n\t\tbool enabled = false, found = false;\n\t\tenum pipe pipe;\n\n\t\tdrm_dbg_kms(&dev_priv->drm, \"[ENCODER:%d:%s]\\n\",\n\t\t\t    encoder->base.base.id,\n\t\t\t    encoder->base.name);\n\n\t\tfor_each_oldnew_connector_in_state(&state->base, connector, old_conn_state,\n\t\t\t\t\t\t   new_conn_state, i) {\n\t\t\tif (old_conn_state->best_encoder == &encoder->base)\n\t\t\t\tfound = true;\n\n\t\t\tif (new_conn_state->best_encoder != &encoder->base)\n\t\t\t\tcontinue;\n\t\t\tfound = enabled = true;\n\n\t\t\tI915_STATE_WARN(new_conn_state->crtc !=\n\t\t\t\t\tencoder->base.crtc,\n\t\t\t     \"connector's crtc doesn't match encoder crtc\\n\");\n\t\t}\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tI915_STATE_WARN(!!encoder->base.crtc != enabled,\n\t\t     \"encoder's enabled state mismatch \"\n\t\t     \"(expected %i, found %i)\\n\",\n\t\t     !!encoder->base.crtc, enabled);\n\n\t\tif (!encoder->base.crtc) {\n\t\t\tbool active;\n\n\t\t\tactive = encoder->get_hw_state(encoder, &pipe);\n\t\t\tI915_STATE_WARN(active,\n\t\t\t     \"encoder detached but still enabled on pipe %c.\\n\",\n\t\t\t     pipe_name(pipe));\n\t\t}\n\t}\n}\n\nstatic void\nverify_crtc_state(struct intel_crtc *crtc,\n\t\t  struct intel_crtc_state *old_crtc_state,\n\t\t  struct intel_crtc_state *new_crtc_state)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_encoder *encoder;\n\tstruct intel_crtc_state *pipe_config = old_crtc_state;\n\tstruct drm_atomic_state *state = old_crtc_state->uapi.state;\n\n\t__drm_atomic_helper_crtc_destroy_state(&old_crtc_state->uapi);\n\tintel_crtc_free_hw_state(old_crtc_state);\n\tintel_crtc_state_reset(old_crtc_state, crtc);\n\told_crtc_state->uapi.state = state;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[CRTC:%d:%s]\\n\", crtc->base.base.id,\n\t\t    crtc->base.name);\n\n\tpipe_config->hw.enable = new_crtc_state->hw.enable;\n\n\tpipe_config->hw.active =\n\t\tdev_priv->display.get_pipe_config(crtc, pipe_config);\n\n\t/* we keep both pipes enabled on 830 */\n\tif (IS_I830(dev_priv) && pipe_config->hw.active)\n\t\tpipe_config->hw.active = new_crtc_state->hw.active;\n\n\tI915_STATE_WARN(new_crtc_state->hw.active != pipe_config->hw.active,\n\t\t\t\"crtc active state doesn't match with hw state \"\n\t\t\t\"(expected %i, found %i)\\n\",\n\t\t\tnew_crtc_state->hw.active, pipe_config->hw.active);\n\n\tI915_STATE_WARN(crtc->active != new_crtc_state->hw.active,\n\t\t\t\"transitional active state does not match atomic hw state \"\n\t\t\t\"(expected %i, found %i)\\n\",\n\t\t\tnew_crtc_state->hw.active, crtc->active);\n\n\tfor_each_encoder_on_crtc(dev, &crtc->base, encoder) {\n\t\tenum pipe pipe;\n\t\tbool active;\n\n\t\tactive = encoder->get_hw_state(encoder, &pipe);\n\t\tI915_STATE_WARN(active != new_crtc_state->hw.active,\n\t\t\t\t\"[ENCODER:%i] active %i with crtc active %i\\n\",\n\t\t\t\tencoder->base.base.id, active,\n\t\t\t\tnew_crtc_state->hw.active);\n\n\t\tI915_STATE_WARN(active && crtc->pipe != pipe,\n\t\t\t\t\"Encoder connected to wrong pipe %c\\n\",\n\t\t\t\tpipe_name(pipe));\n\n\t\tif (active)\n\t\t\tencoder->get_config(encoder, pipe_config);\n\t}\n\n\tintel_crtc_compute_pixel_rate(pipe_config);\n\n\tif (!new_crtc_state->hw.active)\n\t\treturn;\n\n\tintel_pipe_config_sanity_check(dev_priv, pipe_config);\n\n\tif (!intel_pipe_config_compare(new_crtc_state,\n\t\t\t\t       pipe_config, false)) {\n\t\tI915_STATE_WARN(1, \"pipe state doesn't match!\\n\");\n\t\tintel_dump_pipe_config(pipe_config, NULL, \"[hw state]\");\n\t\tintel_dump_pipe_config(new_crtc_state, NULL, \"[sw state]\");\n\t}\n}\n\nstatic void\nintel_verify_planes(struct intel_atomic_state *state)\n{\n\tstruct intel_plane *plane;\n\tconst struct intel_plane_state *plane_state;\n\tint i;\n\n\tfor_each_new_intel_plane_in_state(state, plane,\n\t\t\t\t\t  plane_state, i)\n\t\tassert_plane(plane, plane_state->planar_slave ||\n\t\t\t     plane_state->uapi.visible);\n}\n\nstatic void\nverify_single_dpll_state(struct drm_i915_private *dev_priv,\n\t\t\t struct intel_shared_dpll *pll,\n\t\t\t struct intel_crtc *crtc,\n\t\t\t struct intel_crtc_state *new_crtc_state)\n{\n\tstruct intel_dpll_hw_state dpll_hw_state;\n\tunsigned int crtc_mask;\n\tbool active;\n\n\tmemset(&dpll_hw_state, 0, sizeof(dpll_hw_state));\n\n\tdrm_dbg_kms(&dev_priv->drm, \"%s\\n\", pll->info->name);\n\n\tactive = pll->info->funcs->get_hw_state(dev_priv, pll, &dpll_hw_state);\n\n\tif (!(pll->info->flags & INTEL_DPLL_ALWAYS_ON)) {\n\t\tI915_STATE_WARN(!pll->on && pll->active_mask,\n\t\t     \"pll in active use but not on in sw tracking\\n\");\n\t\tI915_STATE_WARN(pll->on && !pll->active_mask,\n\t\t     \"pll is on but not used by any active crtc\\n\");\n\t\tI915_STATE_WARN(pll->on != active,\n\t\t     \"pll on state mismatch (expected %i, found %i)\\n\",\n\t\t     pll->on, active);\n\t}\n\n\tif (!crtc) {\n\t\tI915_STATE_WARN(pll->active_mask & ~pll->state.crtc_mask,\n\t\t\t\t\"more active pll users than references: %x vs %x\\n\",\n\t\t\t\tpll->active_mask, pll->state.crtc_mask);\n\n\t\treturn;\n\t}\n\n\tcrtc_mask = drm_crtc_mask(&crtc->base);\n\n\tif (new_crtc_state->hw.active)\n\t\tI915_STATE_WARN(!(pll->active_mask & crtc_mask),\n\t\t\t\t\"pll active mismatch (expected pipe %c in active mask 0x%02x)\\n\",\n\t\t\t\tpipe_name(crtc->pipe), pll->active_mask);\n\telse\n\t\tI915_STATE_WARN(pll->active_mask & crtc_mask,\n\t\t\t\t\"pll active mismatch (didn't expect pipe %c in active mask 0x%02x)\\n\",\n\t\t\t\tpipe_name(crtc->pipe), pll->active_mask);\n\n\tI915_STATE_WARN(!(pll->state.crtc_mask & crtc_mask),\n\t\t\t\"pll enabled crtcs mismatch (expected 0x%x in 0x%02x)\\n\",\n\t\t\tcrtc_mask, pll->state.crtc_mask);\n\n\tI915_STATE_WARN(pll->on && memcmp(&pll->state.hw_state,\n\t\t\t\t\t  &dpll_hw_state,\n\t\t\t\t\t  sizeof(dpll_hw_state)),\n\t\t\t\"pll hw state mismatch\\n\");\n}\n\nstatic void\nverify_shared_dpll_state(struct intel_crtc *crtc,\n\t\t\t struct intel_crtc_state *old_crtc_state,\n\t\t\t struct intel_crtc_state *new_crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tif (new_crtc_state->shared_dpll)\n\t\tverify_single_dpll_state(dev_priv, new_crtc_state->shared_dpll, crtc, new_crtc_state);\n\n\tif (old_crtc_state->shared_dpll &&\n\t    old_crtc_state->shared_dpll != new_crtc_state->shared_dpll) {\n\t\tunsigned int crtc_mask = drm_crtc_mask(&crtc->base);\n\t\tstruct intel_shared_dpll *pll = old_crtc_state->shared_dpll;\n\n\t\tI915_STATE_WARN(pll->active_mask & crtc_mask,\n\t\t\t\t\"pll active mismatch (didn't expect pipe %c in active mask)\\n\",\n\t\t\t\tpipe_name(crtc->pipe));\n\t\tI915_STATE_WARN(pll->state.crtc_mask & crtc_mask,\n\t\t\t\t\"pll enabled crtcs mismatch (found %x in enabled mask)\\n\",\n\t\t\t\tpipe_name(crtc->pipe));\n\t}\n}\n\nstatic void\nintel_modeset_verify_crtc(struct intel_crtc *crtc,\n\t\t\t  struct intel_atomic_state *state,\n\t\t\t  struct intel_crtc_state *old_crtc_state,\n\t\t\t  struct intel_crtc_state *new_crtc_state)\n{\n\tif (!needs_modeset(new_crtc_state) && !new_crtc_state->update_pipe)\n\t\treturn;\n\n\tverify_wm_state(crtc, new_crtc_state);\n\tverify_connector_state(state, crtc);\n\tverify_crtc_state(crtc, old_crtc_state, new_crtc_state);\n\tverify_shared_dpll_state(crtc, old_crtc_state, new_crtc_state);\n}\n\nstatic void\nverify_disabled_dpll_state(struct drm_i915_private *dev_priv)\n{\n\tint i;\n\n\tfor (i = 0; i < dev_priv->dpll.num_shared_dpll; i++)\n\t\tverify_single_dpll_state(dev_priv,\n\t\t\t\t\t &dev_priv->dpll.shared_dplls[i],\n\t\t\t\t\t NULL, NULL);\n}\n\nstatic void\nintel_modeset_verify_disabled(struct drm_i915_private *dev_priv,\n\t\t\t      struct intel_atomic_state *state)\n{\n\tverify_encoder_state(dev_priv, state);\n\tverify_connector_state(state, NULL);\n\tverify_disabled_dpll_state(dev_priv);\n}\n\nstatic void\nintel_crtc_update_active_timings(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\n\tdrm_calc_timestamping_constants(&crtc->base, adjusted_mode);\n\n\tcrtc->mode_flags = crtc_state->mode_flags;\n\n\t/*\n\t * The scanline counter increments at the leading edge of hsync.\n\t *\n\t * On most platforms it starts counting from vtotal-1 on the\n\t * first active line. That means the scanline counter value is\n\t * always one less than what we would expect. Ie. just after\n\t * start of vblank, which also occurs at start of hsync (on the\n\t * last active line), the scanline counter will read vblank_start-1.\n\t *\n\t * On gen2 the scanline counter starts counting from 1 instead\n\t * of vtotal-1, so we have to subtract one (or rather add vtotal-1\n\t * to keep the value positive), instead of adding one.\n\t *\n\t * On HSW+ the behaviour of the scanline counter depends on the output\n\t * type. For DP ports it behaves like most other platforms, but on HDMI\n\t * there's an extra 1 line difference. So we need to add two instead of\n\t * one to the value.\n\t *\n\t * On VLV/CHV DSI the scanline counter would appear to increment\n\t * approx. 1/3 of a scanline before start of vblank. Unfortunately\n\t * that means we can't tell whether we're in vblank or not while\n\t * we're on that particular line. We must still set scanline_offset\n\t * to 1 so that the vblank timestamps come out correct when we query\n\t * the scanline counter from within the vblank interrupt handler.\n\t * However if queried just before the start of vblank we'll get an\n\t * answer that's slightly in the future.\n\t */\n\tif (IS_GEN(dev_priv, 2)) {\n\t\tint vtotal;\n\n\t\tvtotal = adjusted_mode->crtc_vtotal;\n\t\tif (adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\t\tvtotal /= 2;\n\n\t\tcrtc->scanline_offset = vtotal - 1;\n\t} else if (HAS_DDI(dev_priv) &&\n\t\t   intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI)) {\n\t\tcrtc->scanline_offset = 2;\n\t} else {\n\t\tcrtc->scanline_offset = 1;\n\t}\n}\n\nstatic void intel_modeset_clear_plls(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc_state *new_crtc_state;\n\tstruct intel_crtc *crtc;\n\tint i;\n\n\tif (!dev_priv->display.crtc_compute_clock)\n\t\treturn;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (!needs_modeset(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tintel_release_shared_dplls(state, crtc);\n\t}\n}\n\n/*\n * This implements the workaround described in the \"notes\" section of the mode\n * set sequence documentation. When going from no pipes or single pipe to\n * multiple pipes, and planes are enabled after the pipe, we need to wait at\n * least 2 vblanks on the first pipe before enabling planes on the second pipe.\n */\nstatic int hsw_mode_set_planes_workaround(struct intel_atomic_state *state)\n{\n\tstruct intel_crtc_state *crtc_state;\n\tstruct intel_crtc *crtc;\n\tstruct intel_crtc_state *first_crtc_state = NULL;\n\tstruct intel_crtc_state *other_crtc_state = NULL;\n\tenum pipe first_pipe = INVALID_PIPE, enabled_pipe = INVALID_PIPE;\n\tint i;\n\n\t/* look at all crtc's that are going to be enabled in during modeset */\n\tfor_each_new_intel_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tif (!crtc_state->hw.active ||\n\t\t    !needs_modeset(crtc_state))\n\t\t\tcontinue;\n\n\t\tif (first_crtc_state) {\n\t\t\tother_crtc_state = crtc_state;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfirst_crtc_state = crtc_state;\n\t\t\tfirst_pipe = crtc->pipe;\n\t\t}\n\t}\n\n\t/* No workaround needed? */\n\tif (!first_crtc_state)\n\t\treturn 0;\n\n\t/* w/a possibly needed, check how many crtc's are already enabled. */\n\tfor_each_intel_crtc(state->base.dev, crtc) {\n\t\tcrtc_state = intel_atomic_get_crtc_state(&state->base, crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn PTR_ERR(crtc_state);\n\n\t\tcrtc_state->hsw_workaround_pipe = INVALID_PIPE;\n\n\t\tif (!crtc_state->hw.active ||\n\t\t    needs_modeset(crtc_state))\n\t\t\tcontinue;\n\n\t\t/* 2 or more enabled crtcs means no need for w/a */\n\t\tif (enabled_pipe != INVALID_PIPE)\n\t\t\treturn 0;\n\n\t\tenabled_pipe = crtc->pipe;\n\t}\n\n\tif (enabled_pipe != INVALID_PIPE)\n\t\tfirst_crtc_state->hsw_workaround_pipe = enabled_pipe;\n\telse if (other_crtc_state)\n\t\tother_crtc_state->hsw_workaround_pipe = first_pipe;\n\n\treturn 0;\n}\n\nu8 intel_calc_active_pipes(struct intel_atomic_state *state,\n\t\t\t   u8 active_pipes)\n{\n\tconst struct intel_crtc_state *crtc_state;\n\tstruct intel_crtc *crtc;\n\tint i;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tif (crtc_state->hw.active)\n\t\t\tactive_pipes |= BIT(crtc->pipe);\n\t\telse\n\t\t\tactive_pipes &= ~BIT(crtc->pipe);\n\t}\n\n\treturn active_pipes;\n}\n\nstatic int intel_modeset_checks(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\n\tstate->modeset = true;\n\n\tif (IS_HASWELL(dev_priv))\n\t\treturn hsw_mode_set_planes_workaround(state);\n\n\treturn 0;\n}\n\n/*\n * Handle calculation of various watermark data at the end of the atomic check\n * phase.  The code here should be run after the per-crtc and per-plane 'check'\n * handlers to ensure that all derived state has been updated.\n */\nstatic int calc_watermark_data(struct intel_atomic_state *state)\n{\n\tstruct drm_device *dev = state->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\n\t/* Is there platform-specific watermark information to calculate? */\n\tif (dev_priv->display.compute_global_watermarks)\n\t\treturn dev_priv->display.compute_global_watermarks(state);\n\n\treturn 0;\n}\n\nstatic void intel_crtc_check_fastset(const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t     struct intel_crtc_state *new_crtc_state)\n{\n\tif (!intel_pipe_config_compare(old_crtc_state, new_crtc_state, true))\n\t\treturn;\n\n\tnew_crtc_state->uapi.mode_changed = false;\n\tnew_crtc_state->update_pipe = true;\n}\n\nstatic void intel_crtc_copy_fastset(const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t    struct intel_crtc_state *new_crtc_state)\n{\n\t/*\n\t * If we're not doing the full modeset we want to\n\t * keep the current M/N values as they may be\n\t * sufficiently different to the computed values\n\t * to cause problems.\n\t *\n\t * FIXME: should really copy more fuzzy state here\n\t */\n\tnew_crtc_state->fdi_m_n = old_crtc_state->fdi_m_n;\n\tnew_crtc_state->dp_m_n = old_crtc_state->dp_m_n;\n\tnew_crtc_state->dp_m2_n2 = old_crtc_state->dp_m2_n2;\n\tnew_crtc_state->has_drrs = old_crtc_state->has_drrs;\n}\n\nstatic int intel_crtc_add_planes_to_state(struct intel_atomic_state *state,\n\t\t\t\t\t  struct intel_crtc *crtc,\n\t\t\t\t\t  u8 plane_ids_mask)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_plane *plane;\n\n\tfor_each_intel_plane_on_crtc(&dev_priv->drm, crtc, plane) {\n\t\tstruct intel_plane_state *plane_state;\n\n\t\tif ((plane_ids_mask & BIT(plane->id)) == 0)\n\t\t\tcontinue;\n\n\t\tplane_state = intel_atomic_get_plane_state(state, plane);\n\t\tif (IS_ERR(plane_state))\n\t\t\treturn PTR_ERR(plane_state);\n\t}\n\n\treturn 0;\n}\n\nstatic bool active_planes_affects_min_cdclk(struct drm_i915_private *dev_priv)\n{\n\t/* See {hsw,vlv,ivb}_plane_ratio() */\n\treturn IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv) ||\n\t\tIS_CHERRYVIEW(dev_priv) || IS_VALLEYVIEW(dev_priv) ||\n\t\tIS_IVYBRIDGE(dev_priv) || (INTEL_GEN(dev_priv) >= 11);\n}\n\nstatic int intel_atomic_check_planes(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct intel_plane_state *plane_state;\n\tstruct intel_plane *plane;\n\tstruct intel_crtc *crtc;\n\tint i, ret;\n\n\tret = icl_add_linked_planes(state);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tret = intel_plane_atomic_check(state, plane);\n\t\tif (ret) {\n\t\t\tdrm_dbg_atomic(&dev_priv->drm,\n\t\t\t\t       \"[PLANE:%d:%s] atomic driver check failed\\n\",\n\t\t\t\t       plane->base.base.id, plane->base.name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tu8 old_active_planes, new_active_planes;\n\n\t\tret = icl_check_nv12_planes(new_crtc_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * On some platforms the number of active planes affects\n\t\t * the planes' minimum cdclk calculation. Add such planes\n\t\t * to the state before we compute the minimum cdclk.\n\t\t */\n\t\tif (!active_planes_affects_min_cdclk(dev_priv))\n\t\t\tcontinue;\n\n\t\told_active_planes = old_crtc_state->active_planes & ~BIT(PLANE_CURSOR);\n\t\tnew_active_planes = new_crtc_state->active_planes & ~BIT(PLANE_CURSOR);\n\n\t\t/*\n\t\t * Not only the number of planes, but if the plane configuration had\n\t\t * changed might already mean we need to recompute min CDCLK,\n\t\t * because different planes might consume different amount of Dbuf bandwidth\n\t\t * according to formula: Bw per plane = Pixel rate * bpp * pipe/plane scale factor\n\t\t */\n\t\tif (old_active_planes == new_active_planes)\n\t\t\tcontinue;\n\n\t\tret = intel_crtc_add_planes_to_state(state, crtc, new_active_planes);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_atomic_check_cdclk(struct intel_atomic_state *state,\n\t\t\t\t    bool *need_cdclk_calc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tconst struct intel_cdclk_state *old_cdclk_state;\n\tconst struct intel_cdclk_state *new_cdclk_state;\n\tstruct intel_plane_state *plane_state;\n\tstruct intel_bw_state *new_bw_state;\n\tstruct intel_plane *plane;\n\tint min_cdclk = 0;\n\tenum pipe pipe;\n\tint ret;\n\tint i;\n\t/*\n\t * active_planes bitmask has been updated, and potentially\n\t * affected planes are part of the state. We can now\n\t * compute the minimum cdclk for each plane.\n\t */\n\tfor_each_new_intel_plane_in_state(state, plane, plane_state, i) {\n\t\tret = intel_plane_calc_min_cdclk(state, plane, need_cdclk_calc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\told_cdclk_state = intel_atomic_get_old_cdclk_state(state);\n\tnew_cdclk_state = intel_atomic_get_new_cdclk_state(state);\n\n\tif (new_cdclk_state &&\n\t    old_cdclk_state->force_min_cdclk != new_cdclk_state->force_min_cdclk)\n\t\t*need_cdclk_calc = true;\n\n\tret = dev_priv->display.bw_calc_min_cdclk(state);\n\tif (ret)\n\t\treturn ret;\n\n\tnew_bw_state = intel_atomic_get_new_bw_state(state);\n\n\tif (!new_cdclk_state || !new_bw_state)\n\t\treturn 0;\n\n\tfor_each_pipe(dev_priv, pipe) {\n\t\tmin_cdclk = max(new_cdclk_state->min_cdclk[pipe], min_cdclk);\n\n\t\t/*\n\t\t * Currently do this change only if we need to increase\n\t\t */\n\t\tif (new_bw_state->min_cdclk > min_cdclk)\n\t\t\t*need_cdclk_calc = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_atomic_check_crtcs(struct intel_atomic_state *state)\n{\n\tstruct intel_crtc_state *crtc_state;\n\tstruct intel_crtc *crtc;\n\tint i;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tint ret = intel_crtc_atomic_check(state, crtc);\n\t\tstruct drm_i915_private *i915 = to_i915(crtc->base.dev);\n\t\tif (ret) {\n\t\t\tdrm_dbg_atomic(&i915->drm,\n\t\t\t\t       \"[CRTC:%d:%s] atomic driver check failed\\n\",\n\t\t\t\t       crtc->base.base.id, crtc->base.name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool intel_cpu_transcoders_need_modeset(struct intel_atomic_state *state,\n\t\t\t\t\t       u8 transcoders)\n{\n\tconst struct intel_crtc_state *new_crtc_state;\n\tstruct intel_crtc *crtc;\n\tint i;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (new_crtc_state->hw.enable &&\n\t\t    transcoders & BIT(new_crtc_state->cpu_transcoder) &&\n\t\t    needs_modeset(new_crtc_state))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * intel_atomic_check - validate state object\n * @dev: drm device\n * @_state: state to validate\n */\nstatic int intel_atomic_check(struct drm_device *dev,\n\t\t\t      struct drm_atomic_state *_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_atomic_state *state = to_intel_atomic_state(_state);\n\tstruct intel_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct intel_crtc *crtc;\n\tint ret, i;\n\tbool any_ms = false;\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tif (new_crtc_state->inherited != old_crtc_state->inherited)\n\t\t\tnew_crtc_state->uapi.mode_changed = true;\n\t}\n\n\tret = drm_atomic_helper_check_modeset(dev, &state->base);\n\tif (ret)\n\t\tgoto fail;\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tif (!needs_modeset(new_crtc_state)) {\n\t\t\t/* Light copy */\n\t\t\tintel_crtc_copy_uapi_to_hw_state_nomodeset(new_crtc_state);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = intel_crtc_prepare_cleared_state(new_crtc_state);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tif (!new_crtc_state->hw.enable)\n\t\t\tcontinue;\n\n\t\tret = intel_modeset_pipe_config(new_crtc_state);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tif (!needs_modeset(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tret = intel_modeset_pipe_config_late(new_crtc_state);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tintel_crtc_check_fastset(old_crtc_state, new_crtc_state);\n\t}\n\n\t/**\n\t * Check if fastset is allowed by external dependencies like other\n\t * pipes and transcoders.\n\t *\n\t * Right now it only forces a fullmodeset when the MST master\n\t * transcoder did not changed but the pipe of the master transcoder\n\t * needs a fullmodeset so all slaves also needs to do a fullmodeset or\n\t * in case of port synced crtcs, if one of the synced crtcs\n\t * needs a full modeset, all other synced crtcs should be\n\t * forced a full modeset.\n\t */\n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (!new_crtc_state->hw.enable || needs_modeset(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tif (intel_dp_mst_is_slave_trans(new_crtc_state)) {\n\t\t\tenum transcoder master = new_crtc_state->mst_master_transcoder;\n\n\t\t\tif (intel_cpu_transcoders_need_modeset(state, BIT(master))) {\n\t\t\t\tnew_crtc_state->uapi.mode_changed = true;\n\t\t\t\tnew_crtc_state->update_pipe = false;\n\t\t\t}\n\t\t}\n\n\t\tif (is_trans_port_sync_mode(new_crtc_state)) {\n\t\t\tu8 trans = new_crtc_state->sync_mode_slaves_mask;\n\n\t\t\tif (new_crtc_state->master_transcoder != INVALID_TRANSCODER)\n\t\t\t\ttrans |= BIT(new_crtc_state->master_transcoder);\n\n\t\t\tif (intel_cpu_transcoders_need_modeset(state, trans)) {\n\t\t\t\tnew_crtc_state->uapi.mode_changed = true;\n\t\t\t\tnew_crtc_state->update_pipe = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tif (needs_modeset(new_crtc_state)) {\n\t\t\tany_ms = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!new_crtc_state->update_pipe)\n\t\t\tcontinue;\n\n\t\tintel_crtc_copy_fastset(old_crtc_state, new_crtc_state);\n\t}\n\n\tif (any_ms && !check_digital_port_conflicts(state)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"rejecting conflicting digital port configuration\\n\");\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tret = drm_dp_mst_atomic_check(&state->base);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = intel_atomic_check_planes(state);\n\tif (ret)\n\t\tgoto fail;\n\n\t/*\n\t * distrust_bios_wm will force a full dbuf recomputation\n\t * but the hardware state will only get updated accordingly\n\t * if state->modeset==true. Hence distrust_bios_wm==true &&\n\t * state->modeset==false is an invalid combination which\n\t * would cause the hardware and software dbuf state to get\n\t * out of sync. We must prevent that.\n\t *\n\t * FIXME clean up this mess and introduce better\n\t * state tracking for dbuf.\n\t */\n\tif (dev_priv->wm.distrust_bios_wm)\n\t\tany_ms = true;\n\n\tintel_fbc_choose_crtc(dev_priv, state);\n\tret = calc_watermark_data(state);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = intel_bw_atomic_check(state);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = intel_atomic_check_cdclk(state, &any_ms);\n\tif (ret)\n\t\tgoto fail;\n\n\tif (any_ms) {\n\t\tret = intel_modeset_checks(state);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tret = intel_modeset_calc_cdclk(state);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tintel_modeset_clear_plls(state);\n\t}\n\n\tret = intel_atomic_check_crtcs(state);\n\tif (ret)\n\t\tgoto fail;\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tif (!needs_modeset(new_crtc_state) &&\n\t\t    !new_crtc_state->update_pipe)\n\t\t\tcontinue;\n\n\t\tintel_dump_pipe_config(new_crtc_state, state,\n\t\t\t\t       needs_modeset(new_crtc_state) ?\n\t\t\t\t       \"[modeset]\" : \"[fastset]\");\n\t}\n\n\treturn 0;\n\n fail:\n\tif (ret == -EDEADLK)\n\t\treturn ret;\n\n\t/*\n\t * FIXME would probably be nice to know which crtc specifically\n\t * caused the failure, in cases where we can pinpoint it.\n\t */\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i)\n\t\tintel_dump_pipe_config(new_crtc_state, state, \"[failed]\");\n\n\treturn ret;\n}\n\nstatic int intel_atomic_prepare_commit(struct intel_atomic_state *state)\n{\n\tstruct intel_crtc_state *crtc_state;\n\tstruct intel_crtc *crtc;\n\tint i, ret;\n\n\tret = drm_atomic_helper_prepare_planes(state->base.dev, &state->base);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tbool mode_changed = needs_modeset(crtc_state);\n\n\t\tif (mode_changed || crtc_state->update_pipe ||\n\t\t    crtc_state->uapi.color_mgmt_changed) {\n\t\t\tintel_dsb_prepare(crtc_state);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nu32 intel_crtc_get_vblank_counter(struct intel_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[drm_crtc_index(&crtc->base)];\n\n\tif (!vblank->max_vblank_count)\n\t\treturn (u32)drm_crtc_accurate_vblank_count(&crtc->base);\n\n\treturn crtc->base.funcs->get_vblank_counter(&crtc->base);\n}\n\nvoid intel_crtc_arm_fifo_underrun(struct intel_crtc *crtc,\n\t\t\t\t  struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tif (!IS_GEN(dev_priv, 2) || crtc_state->active_planes)\n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, crtc->pipe, true);\n\n\tif (crtc_state->has_pch_encoder) {\n\t\tenum pipe pch_transcoder =\n\t\t\tintel_crtc_pch_transcoder(crtc);\n\n\t\tintel_set_pch_fifo_underrun_reporting(dev_priv, pch_transcoder, true);\n\t}\n}\n\nstatic void intel_pipe_fastset(const struct intel_crtc_state *old_crtc_state,\n\t\t\t       const struct intel_crtc_state *new_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(new_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\t/*\n\t * Update pipe size and adjust fitter if needed: the reason for this is\n\t * that in compute_mode_changes we check the native mode (not the pfit\n\t * mode) to see if we can flip rather than do a full mode set. In the\n\t * fastboot case, we'll flip, but if we don't update the pipesrc and\n\t * pfit state, we'll end up with a big fb scanned out into the wrong\n\t * sized surface.\n\t */\n\tintel_set_pipe_src_size(new_crtc_state);\n\n\t/* on skylake this is done by detaching scalers */\n\tif (INTEL_GEN(dev_priv) >= 9) {\n\t\tskl_detach_scalers(new_crtc_state);\n\n\t\tif (new_crtc_state->pch_pfit.enabled)\n\t\t\tskl_pfit_enable(new_crtc_state);\n\t} else if (HAS_PCH_SPLIT(dev_priv)) {\n\t\tif (new_crtc_state->pch_pfit.enabled)\n\t\t\tilk_pfit_enable(new_crtc_state);\n\t\telse if (old_crtc_state->pch_pfit.enabled)\n\t\t\tilk_pfit_disable(old_crtc_state);\n\t}\n\n\t/*\n\t * The register is supposedly single buffered so perhaps\n\t * not 100% correct to do this here. But SKL+ calculate\n\t * this based on the adjust pixel rate so pfit changes do\n\t * affect it and so it must be updated for fastsets.\n\t * HSW/BDW only really need this here for fastboot, after\n\t * that the value should not change without a full modeset.\n\t */\n\tif (INTEL_GEN(dev_priv) >= 9 ||\n\t    IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))\n\t\thsw_set_linetime_wm(new_crtc_state);\n\n\tif (INTEL_GEN(dev_priv) >= 11)\n\t\ticl_set_pipe_chicken(crtc);\n}\n\nstatic void commit_pipe_config(struct intel_atomic_state *state,\n\t\t\t       struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tbool modeset = needs_modeset(new_crtc_state);\n\n\t/*\n\t * During modesets pipe configuration was programmed as the\n\t * CRTC was enabled.\n\t */\n\tif (!modeset) {\n\t\tif (new_crtc_state->uapi.color_mgmt_changed ||\n\t\t    new_crtc_state->update_pipe)\n\t\t\tintel_color_commit(new_crtc_state);\n\n\t\tif (INTEL_GEN(dev_priv) >= 9)\n\t\t\tskl_detach_scalers(new_crtc_state);\n\n\t\tif (INTEL_GEN(dev_priv) >= 9 || IS_BROADWELL(dev_priv))\n\t\t\tbdw_set_pipemisc(new_crtc_state);\n\n\t\tif (new_crtc_state->update_pipe)\n\t\t\tintel_pipe_fastset(old_crtc_state, new_crtc_state);\n\n\t\tintel_psr2_program_trans_man_trk_ctl(new_crtc_state);\n\t}\n\n\tif (dev_priv->display.atomic_update_watermarks)\n\t\tdev_priv->display.atomic_update_watermarks(state, crtc);\n}\n\nstatic void intel_enable_crtc(struct intel_atomic_state *state,\n\t\t\t      struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tconst struct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\n\tif (!needs_modeset(new_crtc_state))\n\t\treturn;\n\n\tintel_crtc_update_active_timings(new_crtc_state);\n\n\tdev_priv->display.crtc_enable(state, crtc);\n\n\t/* vblanks work again, re-enable pipe CRC. */\n\tintel_crtc_enable_pipe_crc(crtc);\n}\n\nstatic void intel_update_crtc(struct intel_atomic_state *state,\n\t\t\t      struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tconst struct intel_crtc_state *old_crtc_state =\n\t\tintel_atomic_get_old_crtc_state(state, crtc);\n\tstruct intel_crtc_state *new_crtc_state =\n\t\tintel_atomic_get_new_crtc_state(state, crtc);\n\tbool modeset = needs_modeset(new_crtc_state);\n\n\tif (!modeset) {\n\t\tif (new_crtc_state->preload_luts &&\n\t\t    (new_crtc_state->uapi.color_mgmt_changed ||\n\t\t     new_crtc_state->update_pipe))\n\t\t\tintel_color_load_luts(new_crtc_state);\n\n\t\tintel_pre_plane_update(state, crtc);\n\n\t\tif (new_crtc_state->update_pipe)\n\t\t\tintel_encoders_update_pipe(state, crtc);\n\t}\n\n\tif (new_crtc_state->update_pipe && !new_crtc_state->enable_fbc)\n\t\tintel_fbc_disable(crtc);\n\telse\n\t\tintel_fbc_enable(state, crtc);\n\n\t/* Perform vblank evasion around commit operation */\n\tintel_pipe_update_start(new_crtc_state);\n\n\tcommit_pipe_config(state, crtc);\n\n\tif (INTEL_GEN(dev_priv) >= 9)\n\t\tskl_update_planes_on_crtc(state, crtc);\n\telse\n\t\ti9xx_update_planes_on_crtc(state, crtc);\n\n\tintel_pipe_update_end(new_crtc_state);\n\n\t/*\n\t * We usually enable FIFO underrun interrupts as part of the\n\t * CRTC enable sequence during modesets.  But when we inherit a\n\t * valid pipe configuration from the BIOS we need to take care\n\t * of enabling them on the CRTC's first fastset.\n\t */\n\tif (new_crtc_state->update_pipe && !modeset &&\n\t    old_crtc_state->inherited)\n\t\tintel_crtc_arm_fifo_underrun(crtc, new_crtc_state);\n}\n\n\nstatic void intel_old_crtc_state_disables(struct intel_atomic_state *state,\n\t\t\t\t\t  struct intel_crtc_state *old_crtc_state,\n\t\t\t\t\t  struct intel_crtc_state *new_crtc_state,\n\t\t\t\t\t  struct intel_crtc *crtc)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\n\tintel_crtc_disable_planes(state, crtc);\n\n\t/*\n\t * We need to disable pipe CRC before disabling the pipe,\n\t * or we race against vblank off.\n\t */\n\tintel_crtc_disable_pipe_crc(crtc);\n\n\tdev_priv->display.crtc_disable(state, crtc);\n\tcrtc->active = false;\n\tintel_fbc_disable(crtc);\n\tintel_disable_shared_dpll(old_crtc_state);\n\n\t/* FIXME unify this for all platforms */\n\tif (!new_crtc_state->hw.active &&\n\t    !HAS_GMCH(dev_priv) &&\n\t    dev_priv->display.initial_watermarks)\n\t\tdev_priv->display.initial_watermarks(state, crtc);\n}\n\nstatic void intel_commit_modeset_disables(struct intel_atomic_state *state)\n{\n\tstruct intel_crtc_state *new_crtc_state, *old_crtc_state;\n\tstruct intel_crtc *crtc;\n\tu32 handled = 0;\n\tint i;\n\n\t/* Only disable port sync and MST slaves */\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tif (!needs_modeset(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tif (!old_crtc_state->hw.active)\n\t\t\tcontinue;\n\n\t\t/* In case of Transcoder port Sync master slave CRTCs can be\n\t\t * assigned in any order and we need to make sure that\n\t\t * slave CRTCs are disabled first and then master CRTC since\n\t\t * Slave vblanks are masked till Master Vblanks.\n\t\t */\n\t\tif (!is_trans_port_sync_slave(old_crtc_state) &&\n\t\t    !intel_dp_mst_is_slave_trans(old_crtc_state))\n\t\t\tcontinue;\n\n\t\tintel_pre_plane_update(state, crtc);\n\t\tintel_old_crtc_state_disables(state, old_crtc_state,\n\t\t\t\t\t      new_crtc_state, crtc);\n\t\thandled |= BIT(crtc->pipe);\n\t}\n\n\t/* Disable everything else left on */\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tif (!needs_modeset(new_crtc_state) ||\n\t\t    (handled & BIT(crtc->pipe)))\n\t\t\tcontinue;\n\n\t\tintel_pre_plane_update(state, crtc);\n\t\tif (old_crtc_state->hw.active)\n\t\t\tintel_old_crtc_state_disables(state, old_crtc_state,\n\t\t\t\t\t\t      new_crtc_state, crtc);\n\t}\n}\n\nstatic void intel_commit_modeset_enables(struct intel_atomic_state *state)\n{\n\tstruct intel_crtc_state *new_crtc_state;\n\tstruct intel_crtc *crtc;\n\tint i;\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (!new_crtc_state->hw.active)\n\t\t\tcontinue;\n\n\t\tintel_enable_crtc(state, crtc);\n\t\tintel_update_crtc(state, crtc);\n\t}\n}\n\nstatic void skl_commit_modeset_enables(struct intel_atomic_state *state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc *crtc;\n\tstruct intel_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct skl_ddb_entry entries[I915_MAX_PIPES] = {};\n\tu8 update_pipes = 0, modeset_pipes = 0;\n\tint i;\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tenum pipe pipe = crtc->pipe;\n\n\t\tif (!new_crtc_state->hw.active)\n\t\t\tcontinue;\n\n\t\t/* ignore allocations for crtc's that have been turned off. */\n\t\tif (!needs_modeset(new_crtc_state)) {\n\t\t\tentries[pipe] = old_crtc_state->wm.skl.ddb;\n\t\t\tupdate_pipes |= BIT(pipe);\n\t\t} else {\n\t\t\tmodeset_pipes |= BIT(pipe);\n\t\t}\n\t}\n\n\t/*\n\t * Whenever the number of active pipes changes, we need to make sure we\n\t * update the pipes in the right order so that their ddb allocations\n\t * never overlap with each other between CRTC updates. Otherwise we'll\n\t * cause pipe underruns and other bad stuff.\n\t *\n\t * So first lets enable all pipes that do not need a fullmodeset as\n\t * those don't have any external dependency.\n\t */\n\twhile (update_pipes) {\n\t\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t\t    new_crtc_state, i) {\n\t\t\tenum pipe pipe = crtc->pipe;\n\n\t\t\tif ((update_pipes & BIT(pipe)) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (skl_ddb_allocation_overlaps(&new_crtc_state->wm.skl.ddb,\n\t\t\t\t\t\t\tentries, I915_MAX_PIPES, pipe))\n\t\t\t\tcontinue;\n\n\t\t\tentries[pipe] = new_crtc_state->wm.skl.ddb;\n\t\t\tupdate_pipes &= ~BIT(pipe);\n\n\t\t\tintel_update_crtc(state, crtc);\n\n\t\t\t/*\n\t\t\t * If this is an already active pipe, it's DDB changed,\n\t\t\t * and this isn't the last pipe that needs updating\n\t\t\t * then we need to wait for a vblank to pass for the\n\t\t\t * new ddb allocation to take effect.\n\t\t\t */\n\t\t\tif (!skl_ddb_entry_equal(&new_crtc_state->wm.skl.ddb,\n\t\t\t\t\t\t &old_crtc_state->wm.skl.ddb) &&\n\t\t\t    (update_pipes | modeset_pipes))\n\t\t\t\tintel_wait_for_vblank(dev_priv, pipe);\n\t\t}\n\t}\n\n\tupdate_pipes = modeset_pipes;\n\n\t/*\n\t * Enable all pipes that needs a modeset and do not depends on other\n\t * pipes\n\t */\n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tenum pipe pipe = crtc->pipe;\n\n\t\tif ((modeset_pipes & BIT(pipe)) == 0)\n\t\t\tcontinue;\n\n\t\tif (intel_dp_mst_is_slave_trans(new_crtc_state) ||\n\t\t    is_trans_port_sync_master(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tmodeset_pipes &= ~BIT(pipe);\n\n\t\tintel_enable_crtc(state, crtc);\n\t}\n\n\t/*\n\t * Then we enable all remaining pipes that depend on other\n\t * pipes: MST slaves and port sync masters.\n\t */\n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tenum pipe pipe = crtc->pipe;\n\n\t\tif ((modeset_pipes & BIT(pipe)) == 0)\n\t\t\tcontinue;\n\n\t\tmodeset_pipes &= ~BIT(pipe);\n\n\t\tintel_enable_crtc(state, crtc);\n\t}\n\n\t/*\n\t * Finally we do the plane updates/etc. for all pipes that got enabled.\n\t */\n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tenum pipe pipe = crtc->pipe;\n\n\t\tif ((update_pipes & BIT(pipe)) == 0)\n\t\t\tcontinue;\n\n\t\tdrm_WARN_ON(&dev_priv->drm, skl_ddb_allocation_overlaps(&new_crtc_state->wm.skl.ddb,\n\t\t\t\t\t\t\t\t\tentries, I915_MAX_PIPES, pipe));\n\n\t\tentries[pipe] = new_crtc_state->wm.skl.ddb;\n\t\tupdate_pipes &= ~BIT(pipe);\n\n\t\tintel_update_crtc(state, crtc);\n\t}\n\n\tdrm_WARN_ON(&dev_priv->drm, modeset_pipes);\n\tdrm_WARN_ON(&dev_priv->drm, update_pipes);\n}\n\nstatic void intel_atomic_helper_free_state(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_atomic_state *state, *next;\n\tstruct llist_node *freed;\n\n\tfreed = llist_del_all(&dev_priv->atomic_helper.free_list);\n\tllist_for_each_entry_safe(state, next, freed, freed)\n\t\tdrm_atomic_state_put(&state->base);\n}\n\nstatic void intel_atomic_helper_free_state_worker(struct work_struct *work)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tcontainer_of(work, typeof(*dev_priv), atomic_helper.free_work);\n\n\tintel_atomic_helper_free_state(dev_priv);\n}\n\nstatic void intel_atomic_commit_fence_wait(struct intel_atomic_state *intel_state)\n{\n\tstruct wait_queue_entry wait_fence, wait_reset;\n\tstruct drm_i915_private *dev_priv = to_i915(intel_state->base.dev);\n\n\tinit_wait_entry(&wait_fence, 0);\n\tinit_wait_entry(&wait_reset, 0);\n\tfor (;;) {\n\t\tprepare_to_wait(&intel_state->commit_ready.wait,\n\t\t\t\t&wait_fence, TASK_UNINTERRUPTIBLE);\n\t\tprepare_to_wait(bit_waitqueue(&dev_priv->gt.reset.flags,\n\t\t\t\t\t      I915_RESET_MODESET),\n\t\t\t\t&wait_reset, TASK_UNINTERRUPTIBLE);\n\n\n\t\tif (i915_sw_fence_done(&intel_state->commit_ready) ||\n\t\t    test_bit(I915_RESET_MODESET, &dev_priv->gt.reset.flags))\n\t\t\tbreak;\n\n\t\tschedule();\n\t}\n\tfinish_wait(&intel_state->commit_ready.wait, &wait_fence);\n\tfinish_wait(bit_waitqueue(&dev_priv->gt.reset.flags,\n\t\t\t\t  I915_RESET_MODESET),\n\t\t    &wait_reset);\n}\n\nstatic void intel_cleanup_dsbs(struct intel_atomic_state *state)\n{\n\tstruct intel_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct intel_crtc *crtc;\n\tint i;\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i)\n\t\tintel_dsb_cleanup(old_crtc_state);\n}\n\nstatic void intel_atomic_cleanup_work(struct work_struct *work)\n{\n\tstruct intel_atomic_state *state =\n\t\tcontainer_of(work, struct intel_atomic_state, base.commit_work);\n\tstruct drm_i915_private *i915 = to_i915(state->base.dev);\n\n\tintel_cleanup_dsbs(state);\n\tdrm_atomic_helper_cleanup_planes(&i915->drm, &state->base);\n\tdrm_atomic_helper_commit_cleanup_done(&state->base);\n\tdrm_atomic_state_put(&state->base);\n\n\tintel_atomic_helper_free_state(i915);\n}\n\nstatic void intel_atomic_commit_tail(struct intel_atomic_state *state)\n{\n\tstruct drm_device *dev = state->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_crtc_state *new_crtc_state, *old_crtc_state;\n\tstruct intel_crtc *crtc;\n\tu64 put_domains[I915_MAX_PIPES] = {};\n\tintel_wakeref_t wakeref = 0;\n\tint i;\n\n\tintel_atomic_commit_fence_wait(state);\n\n\tdrm_atomic_helper_wait_for_dependencies(&state->base);\n\n\tif (state->modeset)\n\t\twakeref = intel_display_power_get(dev_priv, POWER_DOMAIN_MODESET);\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\tif (needs_modeset(new_crtc_state) ||\n\t\t    new_crtc_state->update_pipe) {\n\n\t\t\tput_domains[crtc->pipe] =\n\t\t\t\tmodeset_get_crtc_power_domains(new_crtc_state);\n\t\t}\n\t}\n\n\tintel_commit_modeset_disables(state);\n\n\t/* FIXME: Eventually get rid of our crtc->config pointer */\n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i)\n\t\tcrtc->config = new_crtc_state;\n\n\tif (state->modeset) {\n\t\tdrm_atomic_helper_update_legacy_modeset_state(dev, &state->base);\n\n\t\tintel_set_cdclk_pre_plane_update(state);\n\n\t\tintel_modeset_verify_disabled(dev_priv, state);\n\t}\n\n\tintel_sagv_pre_plane_update(state);\n\n\t/* Complete the events for pipes that have now been disabled */\n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tbool modeset = needs_modeset(new_crtc_state);\n\n\t\t/* Complete events for now disable pipes here. */\n\t\tif (modeset && !new_crtc_state->hw.active && new_crtc_state->uapi.event) {\n\t\t\tspin_lock_irq(&dev->event_lock);\n\t\t\tdrm_crtc_send_vblank_event(&crtc->base,\n\t\t\t\t\t\t   new_crtc_state->uapi.event);\n\t\t\tspin_unlock_irq(&dev->event_lock);\n\n\t\t\tnew_crtc_state->uapi.event = NULL;\n\t\t}\n\t}\n\n\tif (state->modeset)\n\t\tintel_encoders_update_prepare(state);\n\n\tintel_dbuf_pre_plane_update(state);\n\n\t/* Now enable the clocks, plane, pipe, and connectors that we set up. */\n\tdev_priv->display.commit_modeset_enables(state);\n\n\tif (state->modeset) {\n\t\tintel_encoders_update_complete(state);\n\n\t\tintel_set_cdclk_post_plane_update(state);\n\t}\n\n\t/* FIXME: We should call drm_atomic_helper_commit_hw_done() here\n\t * already, but still need the state for the delayed optimization. To\n\t * fix this:\n\t * - wrap the optimization/post_plane_update stuff into a per-crtc work.\n\t * - schedule that vblank worker _before_ calling hw_done\n\t * - at the start of commit_tail, cancel it _synchrously\n\t * - switch over to the vblank wait helper in the core after that since\n\t *   we don't need out special handling any more.\n\t */\n\tdrm_atomic_helper_wait_for_flip_done(dev, &state->base);\n\n\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (new_crtc_state->hw.active &&\n\t\t    !needs_modeset(new_crtc_state) &&\n\t\t    !new_crtc_state->preload_luts &&\n\t\t    (new_crtc_state->uapi.color_mgmt_changed ||\n\t\t     new_crtc_state->update_pipe))\n\t\t\tintel_color_load_luts(new_crtc_state);\n\t}\n\n\t/*\n\t * Now that the vblank has passed, we can go ahead and program the\n\t * optimal watermarks on platforms that need two-step watermark\n\t * programming.\n\t *\n\t * TODO: Move this (and other cleanup) to an async worker eventually.\n\t */\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t\t    new_crtc_state, i) {\n\t\t/*\n\t\t * Gen2 reports pipe underruns whenever all planes are disabled.\n\t\t * So re-enable underrun reporting after some planes get enabled.\n\t\t *\n\t\t * We do this before .optimize_watermarks() so that we have a\n\t\t * chance of catching underruns with the intermediate watermarks\n\t\t * vs. the new plane configuration.\n\t\t */\n\t\tif (IS_GEN(dev_priv, 2) && planes_enabling(old_crtc_state, new_crtc_state))\n\t\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, crtc->pipe, true);\n\n\t\tif (dev_priv->display.optimize_watermarks)\n\t\t\tdev_priv->display.optimize_watermarks(state, crtc);\n\t}\n\n\tintel_dbuf_post_plane_update(state);\n\n\tfor_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tintel_post_plane_update(state, crtc);\n\n\t\tif (put_domains[i])\n\t\t\tmodeset_put_power_domains(dev_priv, put_domains[i]);\n\n\t\tintel_modeset_verify_crtc(crtc, state, old_crtc_state, new_crtc_state);\n\n\t\t/*\n\t\t * DSB cleanup is done in cleanup_work aligning with framebuffer\n\t\t * cleanup. So copy and reset the dsb structure to sync with\n\t\t * commit_done and later do dsb cleanup in cleanup_work.\n\t\t */\n\t\told_crtc_state->dsb = fetch_and_zero(&new_crtc_state->dsb);\n\t}\n\n\t/* Underruns don't always raise interrupts, so check manually */\n\tintel_check_cpu_fifo_underruns(dev_priv);\n\tintel_check_pch_fifo_underruns(dev_priv);\n\n\tif (state->modeset)\n\t\tintel_verify_planes(state);\n\n\tintel_sagv_post_plane_update(state);\n\n\tdrm_atomic_helper_commit_hw_done(&state->base);\n\n\tif (state->modeset) {\n\t\t/* As one of the primary mmio accessors, KMS has a high\n\t\t * likelihood of triggering bugs in unclaimed access. After we\n\t\t * finish modesetting, see if an error has been flagged, and if\n\t\t * so enable debugging for the next modeset - and hope we catch\n\t\t * the culprit.\n\t\t */\n\t\tintel_uncore_arm_unclaimed_mmio_detection(&dev_priv->uncore);\n\t\tintel_display_power_put(dev_priv, POWER_DOMAIN_MODESET, wakeref);\n\t}\n\tintel_runtime_pm_put(&dev_priv->runtime_pm, state->wakeref);\n\n\t/*\n\t * Defer the cleanup of the old state to a separate worker to not\n\t * impede the current task (userspace for blocking modesets) that\n\t * are executed inline. For out-of-line asynchronous modesets/flips,\n\t * deferring to a new worker seems overkill, but we would place a\n\t * schedule point (cond_resched()) here anyway to keep latencies\n\t * down.\n\t */\n\tINIT_WORK(&state->base.commit_work, intel_atomic_cleanup_work);\n\tqueue_work(system_highpri_wq, &state->base.commit_work);\n}\n\nstatic void intel_atomic_commit_work(struct work_struct *work)\n{\n\tstruct intel_atomic_state *state =\n\t\tcontainer_of(work, struct intel_atomic_state, base.commit_work);\n\n\tintel_atomic_commit_tail(state);\n}\n\nstatic int __i915_sw_fence_call\nintel_atomic_commit_ready(struct i915_sw_fence *fence,\n\t\t\t  enum i915_sw_fence_notify notify)\n{\n\tstruct intel_atomic_state *state =\n\t\tcontainer_of(fence, struct intel_atomic_state, commit_ready);\n\n\tswitch (notify) {\n\tcase FENCE_COMPLETE:\n\t\t/* we do blocking waits in the worker, nothing to do here */\n\t\tbreak;\n\tcase FENCE_FREE:\n\t\t{\n\t\t\tstruct intel_atomic_helper *helper =\n\t\t\t\t&to_i915(state->base.dev)->atomic_helper;\n\n\t\t\tif (llist_add(&state->freed, &helper->free_list))\n\t\t\t\tschedule_work(&helper->free_work);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic void intel_atomic_track_fbs(struct intel_atomic_state *state)\n{\n\tstruct intel_plane_state *old_plane_state, *new_plane_state;\n\tstruct intel_plane *plane;\n\tint i;\n\n\tfor_each_oldnew_intel_plane_in_state(state, plane, old_plane_state,\n\t\t\t\t\t     new_plane_state, i)\n\t\tintel_frontbuffer_track(to_intel_frontbuffer(old_plane_state->hw.fb),\n\t\t\t\t\tto_intel_frontbuffer(new_plane_state->hw.fb),\n\t\t\t\t\tplane->frontbuffer_bit);\n}\n\nstatic int intel_atomic_commit(struct drm_device *dev,\n\t\t\t       struct drm_atomic_state *_state,\n\t\t\t       bool nonblock)\n{\n\tstruct intel_atomic_state *state = to_intel_atomic_state(_state);\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tint ret = 0;\n\n\tstate->wakeref = intel_runtime_pm_get(&dev_priv->runtime_pm);\n\n\tdrm_atomic_state_get(&state->base);\n\ti915_sw_fence_init(&state->commit_ready,\n\t\t\t   intel_atomic_commit_ready);\n\n\t/*\n\t * The intel_legacy_cursor_update() fast path takes care\n\t * of avoiding the vblank waits for simple cursor\n\t * movement and flips. For cursor on/off and size changes,\n\t * we want to perform the vblank waits so that watermark\n\t * updates happen during the correct frames. Gen9+ have\n\t * double buffered watermarks and so shouldn't need this.\n\t *\n\t * Unset state->legacy_cursor_update before the call to\n\t * drm_atomic_helper_setup_commit() because otherwise\n\t * drm_atomic_helper_wait_for_flip_done() is a noop and\n\t * we get FIFO underruns because we didn't wait\n\t * for vblank.\n\t *\n\t * FIXME doing watermarks and fb cleanup from a vblank worker\n\t * (assuming we had any) would solve these problems.\n\t */\n\tif (INTEL_GEN(dev_priv) < 9 && state->base.legacy_cursor_update) {\n\t\tstruct intel_crtc_state *new_crtc_state;\n\t\tstruct intel_crtc *crtc;\n\t\tint i;\n\n\t\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i)\n\t\t\tif (new_crtc_state->wm.need_postvbl_update ||\n\t\t\t    new_crtc_state->update_wm_post)\n\t\t\t\tstate->base.legacy_cursor_update = false;\n\t}\n\n\tret = intel_atomic_prepare_commit(state);\n\tif (ret) {\n\t\tdrm_dbg_atomic(&dev_priv->drm,\n\t\t\t       \"Preparing state failed with %i\\n\", ret);\n\t\ti915_sw_fence_commit(&state->commit_ready);\n\t\tintel_runtime_pm_put(&dev_priv->runtime_pm, state->wakeref);\n\t\treturn ret;\n\t}\n\n\tret = drm_atomic_helper_setup_commit(&state->base, nonblock);\n\tif (!ret)\n\t\tret = drm_atomic_helper_swap_state(&state->base, true);\n\tif (!ret)\n\t\tintel_atomic_swap_global_state(state);\n\n\tif (ret) {\n\t\tstruct intel_crtc_state *new_crtc_state;\n\t\tstruct intel_crtc *crtc;\n\t\tint i;\n\n\t\ti915_sw_fence_commit(&state->commit_ready);\n\n\t\tfor_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i)\n\t\t\tintel_dsb_cleanup(new_crtc_state);\n\n\t\tdrm_atomic_helper_cleanup_planes(dev, &state->base);\n\t\tintel_runtime_pm_put(&dev_priv->runtime_pm, state->wakeref);\n\t\treturn ret;\n\t}\n\tdev_priv->wm.distrust_bios_wm = false;\n\tintel_shared_dpll_swap_state(state);\n\tintel_atomic_track_fbs(state);\n\n\tdrm_atomic_state_get(&state->base);\n\tINIT_WORK(&state->base.commit_work, intel_atomic_commit_work);\n\n\ti915_sw_fence_commit(&state->commit_ready);\n\tif (nonblock && state->modeset) {\n\t\tqueue_work(dev_priv->modeset_wq, &state->base.commit_work);\n\t} else if (nonblock) {\n\t\tqueue_work(dev_priv->flip_wq, &state->base.commit_work);\n\t} else {\n\t\tif (state->modeset)\n\t\t\tflush_workqueue(dev_priv->modeset_wq);\n\t\tintel_atomic_commit_tail(state);\n\t}\n\n\treturn 0;\n}\n\nstruct wait_rps_boost {\n\tstruct wait_queue_entry wait;\n\n\tstruct drm_crtc *crtc;\n\tstruct i915_request *request;\n};\n\nstatic int do_rps_boost(struct wait_queue_entry *_wait,\n\t\t\tunsigned mode, int sync, void *key)\n{\n\tstruct wait_rps_boost *wait = container_of(_wait, typeof(*wait), wait);\n\tstruct i915_request *rq = wait->request;\n\n\t/*\n\t * If we missed the vblank, but the request is already running it\n\t * is reasonable to assume that it will complete before the next\n\t * vblank without our intervention, so leave RPS alone.\n\t */\n\tif (!i915_request_started(rq))\n\t\tintel_rps_boost(rq);\n\ti915_request_put(rq);\n\n\tdrm_crtc_vblank_put(wait->crtc);\n\n\tlist_del(&wait->wait.entry);\n\tkfree(wait);\n\treturn 1;\n}\n\nstatic void add_rps_boost_after_vblank(struct drm_crtc *crtc,\n\t\t\t\t       struct dma_fence *fence)\n{\n\tstruct wait_rps_boost *wait;\n\n\tif (!dma_fence_is_i915(fence))\n\t\treturn;\n\n\tif (INTEL_GEN(to_i915(crtc->dev)) < 6)\n\t\treturn;\n\n\tif (drm_crtc_vblank_get(crtc))\n\t\treturn;\n\n\twait = kmalloc(sizeof(*wait), GFP_KERNEL);\n\tif (!wait) {\n\t\tdrm_crtc_vblank_put(crtc);\n\t\treturn;\n\t}\n\n\twait->request = to_request(dma_fence_get(fence));\n\twait->crtc = crtc;\n\n\twait->wait.func = do_rps_boost;\n\twait->wait.flags = 0;\n\n\tadd_wait_queue(drm_crtc_vblank_waitqueue(crtc), &wait->wait);\n}\n\nstatic int intel_plane_pin_fb(struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tstruct drm_framebuffer *fb = plane_state->hw.fb;\n\tstruct i915_vma *vma;\n\n\tif (plane->id == PLANE_CURSOR &&\n\t    INTEL_INFO(dev_priv)->display.cursor_needs_physical) {\n\t\tstruct drm_i915_gem_object *obj = intel_fb_obj(fb);\n\t\tconst int align = intel_cursor_alignment(dev_priv);\n\t\tint err;\n\n\t\terr = i915_gem_object_attach_phys(obj, align);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tvma = intel_pin_and_fence_fb_obj(fb,\n\t\t\t\t\t &plane_state->view,\n\t\t\t\t\t intel_plane_uses_fence(plane_state),\n\t\t\t\t\t &plane_state->flags);\n\tif (IS_ERR(vma))\n\t\treturn PTR_ERR(vma);\n\n\tplane_state->vma = vma;\n\n\treturn 0;\n}\n\nstatic void intel_plane_unpin_fb(struct intel_plane_state *old_plane_state)\n{\n\tstruct i915_vma *vma;\n\n\tvma = fetch_and_zero(&old_plane_state->vma);\n\tif (vma)\n\t\tintel_unpin_fb_vma(vma, old_plane_state->flags);\n}\n\nstatic void fb_obj_bump_render_priority(struct drm_i915_gem_object *obj)\n{\n\tstruct i915_sched_attr attr = {\n\t\t.priority = I915_USER_PRIORITY(I915_PRIORITY_DISPLAY),\n\t};\n\n\ti915_gem_object_wait_priority(obj, 0, &attr);\n}\n\n/**\n * intel_prepare_plane_fb - Prepare fb for usage on plane\n * @_plane: drm plane to prepare for\n * @_new_plane_state: the plane state being prepared\n *\n * Prepares a framebuffer for usage on a display plane.  Generally this\n * involves pinning the underlying object and updating the frontbuffer tracking\n * bits.  Some older platforms need special physical address handling for\n * cursor planes.\n *\n * Returns 0 on success, negative error code on failure.\n */\nint\nintel_prepare_plane_fb(struct drm_plane *_plane,\n\t\t       struct drm_plane_state *_new_plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(_plane);\n\tstruct intel_plane_state *new_plane_state =\n\t\tto_intel_plane_state(_new_plane_state);\n\tstruct intel_atomic_state *state =\n\t\tto_intel_atomic_state(new_plane_state->uapi.state);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->base.dev);\n\tconst struct intel_plane_state *old_plane_state =\n\t\tintel_atomic_get_old_plane_state(state, plane);\n\tstruct drm_i915_gem_object *obj = intel_fb_obj(new_plane_state->hw.fb);\n\tstruct drm_i915_gem_object *old_obj = intel_fb_obj(old_plane_state->hw.fb);\n\tint ret;\n\n\tif (old_obj) {\n\t\tconst struct intel_crtc_state *crtc_state =\n\t\t\tintel_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\tto_intel_crtc(old_plane_state->hw.crtc));\n\n\t\t/* Big Hammer, we also need to ensure that any pending\n\t\t * MI_WAIT_FOR_EVENT inside a user batch buffer on the\n\t\t * current scanout is retired before unpinning the old\n\t\t * framebuffer. Note that we rely on userspace rendering\n\t\t * into the buffer attached to the pipe they are waiting\n\t\t * on. If not, userspace generates a GPU hang with IPEHR\n\t\t * point to the MI_WAIT_FOR_EVENT.\n\t\t *\n\t\t * This should only fail upon a hung GPU, in which case we\n\t\t * can safely continue.\n\t\t */\n\t\tif (needs_modeset(crtc_state)) {\n\t\t\tret = i915_sw_fence_await_reservation(&state->commit_ready,\n\t\t\t\t\t\t\t      old_obj->base.resv, NULL,\n\t\t\t\t\t\t\t      false, 0,\n\t\t\t\t\t\t\t      GFP_KERNEL);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (new_plane_state->uapi.fence) { /* explicit fencing */\n\t\tret = i915_sw_fence_await_dma_fence(&state->commit_ready,\n\t\t\t\t\t\t    new_plane_state->uapi.fence,\n\t\t\t\t\t\t    i915_fence_timeout(dev_priv),\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (!obj)\n\t\treturn 0;\n\n\tret = i915_gem_object_pin_pages(obj);\n\tif (ret)\n\t\treturn ret;\n\n\tret = intel_plane_pin_fb(new_plane_state);\n\n\ti915_gem_object_unpin_pages(obj);\n\tif (ret)\n\t\treturn ret;\n\n\tfb_obj_bump_render_priority(obj);\n\ti915_gem_object_flush_frontbuffer(obj, ORIGIN_DIRTYFB);\n\n\tif (!new_plane_state->uapi.fence) { /* implicit fencing */\n\t\tstruct dma_fence *fence;\n\n\t\tret = i915_sw_fence_await_reservation(&state->commit_ready,\n\t\t\t\t\t\t      obj->base.resv, NULL,\n\t\t\t\t\t\t      false,\n\t\t\t\t\t\t      i915_fence_timeout(dev_priv),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tif (ret < 0)\n\t\t\tgoto unpin_fb;\n\n\t\tfence = dma_resv_get_excl_rcu(obj->base.resv);\n\t\tif (fence) {\n\t\t\tadd_rps_boost_after_vblank(new_plane_state->hw.crtc,\n\t\t\t\t\t\t   fence);\n\t\t\tdma_fence_put(fence);\n\t\t}\n\t} else {\n\t\tadd_rps_boost_after_vblank(new_plane_state->hw.crtc,\n\t\t\t\t\t   new_plane_state->uapi.fence);\n\t}\n\n\t/*\n\t * We declare pageflips to be interactive and so merit a small bias\n\t * towards upclocking to deliver the frame on time. By only changing\n\t * the RPS thresholds to sample more regularly and aim for higher\n\t * clocks we can hopefully deliver low power workloads (like kodi)\n\t * that are not quite steady state without resorting to forcing\n\t * maximum clocks following a vblank miss (see do_rps_boost()).\n\t */\n\tif (!state->rps_interactive) {\n\t\tintel_rps_mark_interactive(&dev_priv->gt.rps, true);\n\t\tstate->rps_interactive = true;\n\t}\n\n\treturn 0;\n\nunpin_fb:\n\tintel_plane_unpin_fb(new_plane_state);\n\n\treturn ret;\n}\n\n/**\n * intel_cleanup_plane_fb - Cleans up an fb after plane use\n * @plane: drm plane to clean up for\n * @_old_plane_state: the state from the previous modeset\n *\n * Cleans up a framebuffer that has just been removed from a plane.\n */\nvoid\nintel_cleanup_plane_fb(struct drm_plane *plane,\n\t\t       struct drm_plane_state *_old_plane_state)\n{\n\tstruct intel_plane_state *old_plane_state =\n\t\tto_intel_plane_state(_old_plane_state);\n\tstruct intel_atomic_state *state =\n\t\tto_intel_atomic_state(old_plane_state->uapi.state);\n\tstruct drm_i915_private *dev_priv = to_i915(plane->dev);\n\tstruct drm_i915_gem_object *obj = intel_fb_obj(old_plane_state->hw.fb);\n\n\tif (!obj)\n\t\treturn;\n\n\tif (state->rps_interactive) {\n\t\tintel_rps_mark_interactive(&dev_priv->gt.rps, false);\n\t\tstate->rps_interactive = false;\n\t}\n\n\t/* Should only be called after a successful intel_prepare_plane_fb()! */\n\tintel_plane_unpin_fb(old_plane_state);\n}\n\n/**\n * intel_plane_destroy - destroy a plane\n * @plane: plane to destroy\n *\n * Common destruction function for all types of planes (primary, cursor,\n * sprite).\n */\nvoid intel_plane_destroy(struct drm_plane *plane)\n{\n\tdrm_plane_cleanup(plane);\n\tkfree(to_intel_plane(plane));\n}\n\nstatic bool i8xx_plane_format_mod_supported(struct drm_plane *_plane,\n\t\t\t\t\t    u32 format, u64 modifier)\n{\n\tswitch (modifier) {\n\tcase DRM_FORMAT_MOD_LINEAR:\n\tcase I915_FORMAT_MOD_X_TILED:\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tswitch (format) {\n\tcase DRM_FORMAT_C8:\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_XRGB1555:\n\tcase DRM_FORMAT_XRGB8888:\n\t\treturn modifier == DRM_FORMAT_MOD_LINEAR ||\n\t\t\tmodifier == I915_FORMAT_MOD_X_TILED;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool i965_plane_format_mod_supported(struct drm_plane *_plane,\n\t\t\t\t\t    u32 format, u64 modifier)\n{\n\tswitch (modifier) {\n\tcase DRM_FORMAT_MOD_LINEAR:\n\tcase I915_FORMAT_MOD_X_TILED:\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tswitch (format) {\n\tcase DRM_FORMAT_C8:\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_XRGB2101010:\n\tcase DRM_FORMAT_XBGR2101010:\n\tcase DRM_FORMAT_ARGB2101010:\n\tcase DRM_FORMAT_ABGR2101010:\n\tcase DRM_FORMAT_XBGR16161616F:\n\t\treturn modifier == DRM_FORMAT_MOD_LINEAR ||\n\t\t\tmodifier == I915_FORMAT_MOD_X_TILED;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool intel_cursor_format_mod_supported(struct drm_plane *_plane,\n\t\t\t\t\t      u32 format, u64 modifier)\n{\n\treturn modifier == DRM_FORMAT_MOD_LINEAR &&\n\t\tformat == DRM_FORMAT_ARGB8888;\n}\n\nstatic const struct drm_plane_funcs i965_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = intel_plane_destroy,\n\t.atomic_duplicate_state = intel_plane_duplicate_state,\n\t.atomic_destroy_state = intel_plane_destroy_state,\n\t.format_mod_supported = i965_plane_format_mod_supported,\n};\n\nstatic const struct drm_plane_funcs i8xx_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = intel_plane_destroy,\n\t.atomic_duplicate_state = intel_plane_duplicate_state,\n\t.atomic_destroy_state = intel_plane_destroy_state,\n\t.format_mod_supported = i8xx_plane_format_mod_supported,\n};\n\nstatic int\nintel_legacy_cursor_update(struct drm_plane *_plane,\n\t\t\t   struct drm_crtc *_crtc,\n\t\t\t   struct drm_framebuffer *fb,\n\t\t\t   int crtc_x, int crtc_y,\n\t\t\t   unsigned int crtc_w, unsigned int crtc_h,\n\t\t\t   u32 src_x, u32 src_y,\n\t\t\t   u32 src_w, u32 src_h,\n\t\t\t   struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct intel_plane *plane = to_intel_plane(_plane);\n\tstruct intel_crtc *crtc = to_intel_crtc(_crtc);\n\tstruct intel_plane_state *old_plane_state =\n\t\tto_intel_plane_state(plane->base.state);\n\tstruct intel_plane_state *new_plane_state;\n\tstruct intel_crtc_state *crtc_state =\n\t\tto_intel_crtc_state(crtc->base.state);\n\tstruct intel_crtc_state *new_crtc_state;\n\tint ret;\n\n\t/*\n\t * When crtc is inactive or there is a modeset pending,\n\t * wait for it to complete in the slowpath\n\t */\n\tif (!crtc_state->hw.active || needs_modeset(crtc_state) ||\n\t    crtc_state->update_pipe)\n\t\tgoto slow;\n\n\t/*\n\t * Don't do an async update if there is an outstanding commit modifying\n\t * the plane.  This prevents our async update's changes from getting\n\t * overridden by a previous synchronous update's state.\n\t */\n\tif (old_plane_state->uapi.commit &&\n\t    !try_wait_for_completion(&old_plane_state->uapi.commit->hw_done))\n\t\tgoto slow;\n\n\t/*\n\t * If any parameters change that may affect watermarks,\n\t * take the slowpath. Only changing fb or position should be\n\t * in the fastpath.\n\t */\n\tif (old_plane_state->uapi.crtc != &crtc->base ||\n\t    old_plane_state->uapi.src_w != src_w ||\n\t    old_plane_state->uapi.src_h != src_h ||\n\t    old_plane_state->uapi.crtc_w != crtc_w ||\n\t    old_plane_state->uapi.crtc_h != crtc_h ||\n\t    !old_plane_state->uapi.fb != !fb)\n\t\tgoto slow;\n\n\tnew_plane_state = to_intel_plane_state(intel_plane_duplicate_state(&plane->base));\n\tif (!new_plane_state)\n\t\treturn -ENOMEM;\n\n\tnew_crtc_state = to_intel_crtc_state(intel_crtc_duplicate_state(&crtc->base));\n\tif (!new_crtc_state) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tdrm_atomic_set_fb_for_plane(&new_plane_state->uapi, fb);\n\n\tnew_plane_state->uapi.src_x = src_x;\n\tnew_plane_state->uapi.src_y = src_y;\n\tnew_plane_state->uapi.src_w = src_w;\n\tnew_plane_state->uapi.src_h = src_h;\n\tnew_plane_state->uapi.crtc_x = crtc_x;\n\tnew_plane_state->uapi.crtc_y = crtc_y;\n\tnew_plane_state->uapi.crtc_w = crtc_w;\n\tnew_plane_state->uapi.crtc_h = crtc_h;\n\n\tintel_plane_copy_uapi_to_hw_state(new_plane_state, new_plane_state);\n\n\tret = intel_plane_atomic_check_with_state(crtc_state, new_crtc_state,\n\t\t\t\t\t\t  old_plane_state, new_plane_state);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = intel_plane_pin_fb(new_plane_state);\n\tif (ret)\n\t\tgoto out_free;\n\n\tintel_frontbuffer_flush(to_intel_frontbuffer(new_plane_state->hw.fb),\n\t\t\t\tORIGIN_FLIP);\n\tintel_frontbuffer_track(to_intel_frontbuffer(old_plane_state->hw.fb),\n\t\t\t\tto_intel_frontbuffer(new_plane_state->hw.fb),\n\t\t\t\tplane->frontbuffer_bit);\n\n\t/* Swap plane state */\n\tplane->base.state = &new_plane_state->uapi;\n\n\t/*\n\t * We cannot swap crtc_state as it may be in use by an atomic commit or\n\t * page flip that's running simultaneously. If we swap crtc_state and\n\t * destroy the old state, we will cause a use-after-free there.\n\t *\n\t * Only update active_planes, which is needed for our internal\n\t * bookkeeping. Either value will do the right thing when updating\n\t * planes atomically. If the cursor was part of the atomic update then\n\t * we would have taken the slowpath.\n\t */\n\tcrtc_state->active_planes = new_crtc_state->active_planes;\n\n\tif (new_plane_state->uapi.visible)\n\t\tintel_update_plane(plane, crtc_state, new_plane_state);\n\telse\n\t\tintel_disable_plane(plane, crtc_state);\n\n\tintel_plane_unpin_fb(old_plane_state);\n\nout_free:\n\tif (new_crtc_state)\n\t\tintel_crtc_destroy_state(&crtc->base, &new_crtc_state->uapi);\n\tif (ret)\n\t\tintel_plane_destroy_state(&plane->base, &new_plane_state->uapi);\n\telse\n\t\tintel_plane_destroy_state(&plane->base, &old_plane_state->uapi);\n\treturn ret;\n\nslow:\n\treturn drm_atomic_helper_update_plane(&plane->base, &crtc->base, fb,\n\t\t\t\t\t      crtc_x, crtc_y, crtc_w, crtc_h,\n\t\t\t\t\t      src_x, src_y, src_w, src_h, ctx);\n}\n\nstatic const struct drm_plane_funcs intel_cursor_plane_funcs = {\n\t.update_plane = intel_legacy_cursor_update,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = intel_plane_destroy,\n\t.atomic_duplicate_state = intel_plane_duplicate_state,\n\t.atomic_destroy_state = intel_plane_destroy_state,\n\t.format_mod_supported = intel_cursor_format_mod_supported,\n};\n\nstatic bool i9xx_plane_has_fbc(struct drm_i915_private *dev_priv,\n\t\t\t       enum i9xx_plane_id i9xx_plane)\n{\n\tif (!HAS_FBC(dev_priv))\n\t\treturn false;\n\n\tif (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))\n\t\treturn i9xx_plane == PLANE_A; /* tied to pipe A */\n\telse if (IS_IVYBRIDGE(dev_priv))\n\t\treturn i9xx_plane == PLANE_A || i9xx_plane == PLANE_B ||\n\t\t\ti9xx_plane == PLANE_C;\n\telse if (INTEL_GEN(dev_priv) >= 4)\n\t\treturn i9xx_plane == PLANE_A || i9xx_plane == PLANE_B;\n\telse\n\t\treturn i9xx_plane == PLANE_A;\n}\n\nstatic struct intel_plane *\nintel_primary_plane_create(struct drm_i915_private *dev_priv, enum pipe pipe)\n{\n\tstruct intel_plane *plane;\n\tconst struct drm_plane_funcs *plane_funcs;\n\tunsigned int supported_rotations;\n\tconst u32 *formats;\n\tint num_formats;\n\tint ret, zpos;\n\n\tif (INTEL_GEN(dev_priv) >= 9)\n\t\treturn skl_universal_plane_create(dev_priv, pipe,\n\t\t\t\t\t\t  PLANE_PRIMARY);\n\n\tplane = intel_plane_alloc();\n\tif (IS_ERR(plane))\n\t\treturn plane;\n\n\tplane->pipe = pipe;\n\t/*\n\t * On gen2/3 only plane A can do FBC, but the panel fitter and LVDS\n\t * port is hooked to pipe B. Hence we want plane A feeding pipe B.\n\t */\n\tif (HAS_FBC(dev_priv) && INTEL_GEN(dev_priv) < 4 &&\n\t    INTEL_NUM_PIPES(dev_priv) == 2)\n\t\tplane->i9xx_plane = (enum i9xx_plane_id) !pipe;\n\telse\n\t\tplane->i9xx_plane = (enum i9xx_plane_id) pipe;\n\tplane->id = PLANE_PRIMARY;\n\tplane->frontbuffer_bit = INTEL_FRONTBUFFER(pipe, plane->id);\n\n\tplane->has_fbc = i9xx_plane_has_fbc(dev_priv, plane->i9xx_plane);\n\tif (plane->has_fbc) {\n\t\tstruct intel_fbc *fbc = &dev_priv->fbc;\n\n\t\tfbc->possible_framebuffer_bits |= plane->frontbuffer_bit;\n\t}\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\tformats = vlv_primary_formats;\n\t\tnum_formats = ARRAY_SIZE(vlv_primary_formats);\n\t} else if (INTEL_GEN(dev_priv) >= 4) {\n\t\t/*\n\t\t * WaFP16GammaEnabling:ivb\n\t\t * \"Workaround : When using the 64-bit format, the plane\n\t\t *  output on each color channel has one quarter amplitude.\n\t\t *  It can be brought up to full amplitude by using pipe\n\t\t *  gamma correction or pipe color space conversion to\n\t\t *  multiply the plane output by four.\"\n\t\t *\n\t\t * There is no dedicated plane gamma for the primary plane,\n\t\t * and using the pipe gamma/csc could conflict with other\n\t\t * planes, so we choose not to expose fp16 on IVB primary\n\t\t * planes. HSW primary planes no longer have this problem.\n\t\t */\n\t\tif (IS_IVYBRIDGE(dev_priv)) {\n\t\t\tformats = ivb_primary_formats;\n\t\t\tnum_formats = ARRAY_SIZE(ivb_primary_formats);\n\t\t} else {\n\t\t\tformats = i965_primary_formats;\n\t\t\tnum_formats = ARRAY_SIZE(i965_primary_formats);\n\t\t}\n\t} else {\n\t\tformats = i8xx_primary_formats;\n\t\tnum_formats = ARRAY_SIZE(i8xx_primary_formats);\n\t}\n\n\tif (INTEL_GEN(dev_priv) >= 4)\n\t\tplane_funcs = &i965_plane_funcs;\n\telse\n\t\tplane_funcs = &i8xx_plane_funcs;\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\tplane->min_cdclk = vlv_plane_min_cdclk;\n\telse if (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))\n\t\tplane->min_cdclk = hsw_plane_min_cdclk;\n\telse if (IS_IVYBRIDGE(dev_priv))\n\t\tplane->min_cdclk = ivb_plane_min_cdclk;\n\telse\n\t\tplane->min_cdclk = i9xx_plane_min_cdclk;\n\n\tplane->max_stride = i9xx_plane_max_stride;\n\tplane->update_plane = i9xx_update_plane;\n\tplane->disable_plane = i9xx_disable_plane;\n\tplane->get_hw_state = i9xx_plane_get_hw_state;\n\tplane->check_plane = i9xx_plane_check;\n\n\tif (INTEL_GEN(dev_priv) >= 5 || IS_G4X(dev_priv))\n\t\tret = drm_universal_plane_init(&dev_priv->drm, &plane->base,\n\t\t\t\t\t       0, plane_funcs,\n\t\t\t\t\t       formats, num_formats,\n\t\t\t\t\t       i9xx_format_modifiers,\n\t\t\t\t\t       DRM_PLANE_TYPE_PRIMARY,\n\t\t\t\t\t       \"primary %c\", pipe_name(pipe));\n\telse\n\t\tret = drm_universal_plane_init(&dev_priv->drm, &plane->base,\n\t\t\t\t\t       0, plane_funcs,\n\t\t\t\t\t       formats, num_formats,\n\t\t\t\t\t       i9xx_format_modifiers,\n\t\t\t\t\t       DRM_PLANE_TYPE_PRIMARY,\n\t\t\t\t\t       \"plane %c\",\n\t\t\t\t\t       plane_name(plane->i9xx_plane));\n\tif (ret)\n\t\tgoto fail;\n\n\tif (IS_CHERRYVIEW(dev_priv) && pipe == PIPE_B) {\n\t\tsupported_rotations =\n\t\t\tDRM_MODE_ROTATE_0 | DRM_MODE_ROTATE_180 |\n\t\t\tDRM_MODE_REFLECT_X;\n\t} else if (INTEL_GEN(dev_priv) >= 4) {\n\t\tsupported_rotations =\n\t\t\tDRM_MODE_ROTATE_0 | DRM_MODE_ROTATE_180;\n\t} else {\n\t\tsupported_rotations = DRM_MODE_ROTATE_0;\n\t}\n\n\tif (INTEL_GEN(dev_priv) >= 4)\n\t\tdrm_plane_create_rotation_property(&plane->base,\n\t\t\t\t\t\t   DRM_MODE_ROTATE_0,\n\t\t\t\t\t\t   supported_rotations);\n\n\tzpos = 0;\n\tdrm_plane_create_zpos_immutable_property(&plane->base, zpos);\n\n\tdrm_plane_helper_add(&plane->base, &intel_plane_helper_funcs);\n\n\treturn plane;\n\nfail:\n\tintel_plane_free(plane);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic struct intel_plane *\nintel_cursor_plane_create(struct drm_i915_private *dev_priv,\n\t\t\t  enum pipe pipe)\n{\n\tstruct intel_plane *cursor;\n\tint ret, zpos;\n\n\tcursor = intel_plane_alloc();\n\tif (IS_ERR(cursor))\n\t\treturn cursor;\n\n\tcursor->pipe = pipe;\n\tcursor->i9xx_plane = (enum i9xx_plane_id) pipe;\n\tcursor->id = PLANE_CURSOR;\n\tcursor->frontbuffer_bit = INTEL_FRONTBUFFER(pipe, cursor->id);\n\n\tif (IS_I845G(dev_priv) || IS_I865G(dev_priv)) {\n\t\tcursor->max_stride = i845_cursor_max_stride;\n\t\tcursor->update_plane = i845_update_cursor;\n\t\tcursor->disable_plane = i845_disable_cursor;\n\t\tcursor->get_hw_state = i845_cursor_get_hw_state;\n\t\tcursor->check_plane = i845_check_cursor;\n\t} else {\n\t\tcursor->max_stride = i9xx_cursor_max_stride;\n\t\tcursor->update_plane = i9xx_update_cursor;\n\t\tcursor->disable_plane = i9xx_disable_cursor;\n\t\tcursor->get_hw_state = i9xx_cursor_get_hw_state;\n\t\tcursor->check_plane = i9xx_check_cursor;\n\t}\n\n\tcursor->cursor.base = ~0;\n\tcursor->cursor.cntl = ~0;\n\n\tif (IS_I845G(dev_priv) || IS_I865G(dev_priv) || HAS_CUR_FBC(dev_priv))\n\t\tcursor->cursor.size = ~0;\n\n\tret = drm_universal_plane_init(&dev_priv->drm, &cursor->base,\n\t\t\t\t       0, &intel_cursor_plane_funcs,\n\t\t\t\t       intel_cursor_formats,\n\t\t\t\t       ARRAY_SIZE(intel_cursor_formats),\n\t\t\t\t       cursor_format_modifiers,\n\t\t\t\t       DRM_PLANE_TYPE_CURSOR,\n\t\t\t\t       \"cursor %c\", pipe_name(pipe));\n\tif (ret)\n\t\tgoto fail;\n\n\tif (INTEL_GEN(dev_priv) >= 4)\n\t\tdrm_plane_create_rotation_property(&cursor->base,\n\t\t\t\t\t\t   DRM_MODE_ROTATE_0,\n\t\t\t\t\t\t   DRM_MODE_ROTATE_0 |\n\t\t\t\t\t\t   DRM_MODE_ROTATE_180);\n\n\tzpos = RUNTIME_INFO(dev_priv)->num_sprites[pipe] + 1;\n\tdrm_plane_create_zpos_immutable_property(&cursor->base, zpos);\n\n\tif (INTEL_GEN(dev_priv) >= 12)\n\t\tdrm_plane_enable_fb_damage_clips(&cursor->base);\n\n\tdrm_plane_helper_add(&cursor->base, &intel_plane_helper_funcs);\n\n\treturn cursor;\n\nfail:\n\tintel_plane_free(cursor);\n\n\treturn ERR_PTR(ret);\n}\n\n#define INTEL_CRTC_FUNCS \\\n\t.gamma_set = drm_atomic_helper_legacy_gamma_set, \\\n\t.set_config = drm_atomic_helper_set_config, \\\n\t.destroy = intel_crtc_destroy, \\\n\t.page_flip = drm_atomic_helper_page_flip, \\\n\t.atomic_duplicate_state = intel_crtc_duplicate_state, \\\n\t.atomic_destroy_state = intel_crtc_destroy_state, \\\n\t.set_crc_source = intel_crtc_set_crc_source, \\\n\t.verify_crc_source = intel_crtc_verify_crc_source, \\\n\t.get_crc_sources = intel_crtc_get_crc_sources\n\nstatic const struct drm_crtc_funcs bdw_crtc_funcs = {\n\tINTEL_CRTC_FUNCS,\n\n\t.get_vblank_counter = g4x_get_vblank_counter,\n\t.enable_vblank = bdw_enable_vblank,\n\t.disable_vblank = bdw_disable_vblank,\n\t.get_vblank_timestamp = intel_crtc_get_vblank_timestamp,\n};\n\nstatic const struct drm_crtc_funcs ilk_crtc_funcs = {\n\tINTEL_CRTC_FUNCS,\n\n\t.get_vblank_counter = g4x_get_vblank_counter,\n\t.enable_vblank = ilk_enable_vblank,\n\t.disable_vblank = ilk_disable_vblank,\n\t.get_vblank_timestamp = intel_crtc_get_vblank_timestamp,\n};\n\nstatic const struct drm_crtc_funcs g4x_crtc_funcs = {\n\tINTEL_CRTC_FUNCS,\n\n\t.get_vblank_counter = g4x_get_vblank_counter,\n\t.enable_vblank = i965_enable_vblank,\n\t.disable_vblank = i965_disable_vblank,\n\t.get_vblank_timestamp = intel_crtc_get_vblank_timestamp,\n};\n\nstatic const struct drm_crtc_funcs i965_crtc_funcs = {\n\tINTEL_CRTC_FUNCS,\n\n\t.get_vblank_counter = i915_get_vblank_counter,\n\t.enable_vblank = i965_enable_vblank,\n\t.disable_vblank = i965_disable_vblank,\n\t.get_vblank_timestamp = intel_crtc_get_vblank_timestamp,\n};\n\nstatic const struct drm_crtc_funcs i915gm_crtc_funcs = {\n\tINTEL_CRTC_FUNCS,\n\n\t.get_vblank_counter = i915_get_vblank_counter,\n\t.enable_vblank = i915gm_enable_vblank,\n\t.disable_vblank = i915gm_disable_vblank,\n\t.get_vblank_timestamp = intel_crtc_get_vblank_timestamp,\n};\n\nstatic const struct drm_crtc_funcs i915_crtc_funcs = {\n\tINTEL_CRTC_FUNCS,\n\n\t.get_vblank_counter = i915_get_vblank_counter,\n\t.enable_vblank = i8xx_enable_vblank,\n\t.disable_vblank = i8xx_disable_vblank,\n\t.get_vblank_timestamp = intel_crtc_get_vblank_timestamp,\n};\n\nstatic const struct drm_crtc_funcs i8xx_crtc_funcs = {\n\tINTEL_CRTC_FUNCS,\n\n\t/* no hw vblank counter */\n\t.enable_vblank = i8xx_enable_vblank,\n\t.disable_vblank = i8xx_disable_vblank,\n\t.get_vblank_timestamp = intel_crtc_get_vblank_timestamp,\n};\n\nstatic struct intel_crtc *intel_crtc_alloc(void)\n{\n\tstruct intel_crtc_state *crtc_state;\n\tstruct intel_crtc *crtc;\n\n\tcrtc = kzalloc(sizeof(*crtc), GFP_KERNEL);\n\tif (!crtc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcrtc_state = intel_crtc_state_alloc(crtc);\n\tif (!crtc_state) {\n\t\tkfree(crtc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tcrtc->base.state = &crtc_state->uapi;\n\tcrtc->config = crtc_state;\n\n\treturn crtc;\n}\n\nstatic void intel_crtc_free(struct intel_crtc *crtc)\n{\n\tintel_crtc_destroy_state(&crtc->base, crtc->base.state);\n\tkfree(crtc);\n}\n\nstatic void intel_plane_possible_crtcs_init(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_plane *plane;\n\n\tfor_each_intel_plane(&dev_priv->drm, plane) {\n\t\tstruct intel_crtc *crtc = intel_get_crtc_for_pipe(dev_priv,\n\t\t\t\t\t\t\t\t  plane->pipe);\n\n\t\tplane->base.possible_crtcs = drm_crtc_mask(&crtc->base);\n\t}\n}\n\nstatic int intel_crtc_init(struct drm_i915_private *dev_priv, enum pipe pipe)\n{\n\tstruct intel_plane *primary, *cursor;\n\tconst struct drm_crtc_funcs *funcs;\n\tstruct intel_crtc *crtc;\n\tint sprite, ret;\n\n\tcrtc = intel_crtc_alloc();\n\tif (IS_ERR(crtc))\n\t\treturn PTR_ERR(crtc);\n\n\tcrtc->pipe = pipe;\n\tcrtc->num_scalers = RUNTIME_INFO(dev_priv)->num_scalers[pipe];\n\n\tprimary = intel_primary_plane_create(dev_priv, pipe);\n\tif (IS_ERR(primary)) {\n\t\tret = PTR_ERR(primary);\n\t\tgoto fail;\n\t}\n\tcrtc->plane_ids_mask |= BIT(primary->id);\n\n\tfor_each_sprite(dev_priv, pipe, sprite) {\n\t\tstruct intel_plane *plane;\n\n\t\tplane = intel_sprite_plane_create(dev_priv, pipe, sprite);\n\t\tif (IS_ERR(plane)) {\n\t\t\tret = PTR_ERR(plane);\n\t\t\tgoto fail;\n\t\t}\n\t\tcrtc->plane_ids_mask |= BIT(plane->id);\n\t}\n\n\tcursor = intel_cursor_plane_create(dev_priv, pipe);\n\tif (IS_ERR(cursor)) {\n\t\tret = PTR_ERR(cursor);\n\t\tgoto fail;\n\t}\n\tcrtc->plane_ids_mask |= BIT(cursor->id);\n\n\tif (HAS_GMCH(dev_priv)) {\n\t\tif (IS_CHERRYVIEW(dev_priv) ||\n\t\t    IS_VALLEYVIEW(dev_priv) || IS_G4X(dev_priv))\n\t\t\tfuncs = &g4x_crtc_funcs;\n\t\telse if (IS_GEN(dev_priv, 4))\n\t\t\tfuncs = &i965_crtc_funcs;\n\t\telse if (IS_I945GM(dev_priv) || IS_I915GM(dev_priv))\n\t\t\tfuncs = &i915gm_crtc_funcs;\n\t\telse if (IS_GEN(dev_priv, 3))\n\t\t\tfuncs = &i915_crtc_funcs;\n\t\telse\n\t\t\tfuncs = &i8xx_crtc_funcs;\n\t} else {\n\t\tif (INTEL_GEN(dev_priv) >= 8)\n\t\t\tfuncs = &bdw_crtc_funcs;\n\t\telse\n\t\t\tfuncs = &ilk_crtc_funcs;\n\t}\n\n\tret = drm_crtc_init_with_planes(&dev_priv->drm, &crtc->base,\n\t\t\t\t\t&primary->base, &cursor->base,\n\t\t\t\t\tfuncs, \"pipe %c\", pipe_name(pipe));\n\tif (ret)\n\t\tgoto fail;\n\n\tBUG_ON(pipe >= ARRAY_SIZE(dev_priv->pipe_to_crtc_mapping) ||\n\t       dev_priv->pipe_to_crtc_mapping[pipe] != NULL);\n\tdev_priv->pipe_to_crtc_mapping[pipe] = crtc;\n\n\tif (INTEL_GEN(dev_priv) < 9) {\n\t\tenum i9xx_plane_id i9xx_plane = primary->i9xx_plane;\n\n\t\tBUG_ON(i9xx_plane >= ARRAY_SIZE(dev_priv->plane_to_crtc_mapping) ||\n\t\t       dev_priv->plane_to_crtc_mapping[i9xx_plane] != NULL);\n\t\tdev_priv->plane_to_crtc_mapping[i9xx_plane] = crtc;\n\t}\n\n\tintel_color_init(crtc);\n\n\tintel_crtc_crc_init(crtc);\n\n\tdrm_WARN_ON(&dev_priv->drm, drm_crtc_index(&crtc->base) != crtc->pipe);\n\n\treturn 0;\n\nfail:\n\tintel_crtc_free(crtc);\n\n\treturn ret;\n}\n\nint intel_get_pipe_from_crtc_id_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t      struct drm_file *file)\n{\n\tstruct drm_i915_get_pipe_from_crtc_id *pipe_from_crtc_id = data;\n\tstruct drm_crtc *drmmode_crtc;\n\tstruct intel_crtc *crtc;\n\n\tdrmmode_crtc = drm_crtc_find(dev, file, pipe_from_crtc_id->crtc_id);\n\tif (!drmmode_crtc)\n\t\treturn -ENOENT;\n\n\tcrtc = to_intel_crtc(drmmode_crtc);\n\tpipe_from_crtc_id->pipe = crtc->pipe;\n\n\treturn 0;\n}\n\nstatic u32 intel_encoder_possible_clones(struct intel_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct intel_encoder *source_encoder;\n\tu32 possible_clones = 0;\n\n\tfor_each_intel_encoder(dev, source_encoder) {\n\t\tif (encoders_cloneable(encoder, source_encoder))\n\t\t\tpossible_clones |= drm_encoder_mask(&source_encoder->base);\n\t}\n\n\treturn possible_clones;\n}\n\nstatic u32 intel_encoder_possible_crtcs(struct intel_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct intel_crtc *crtc;\n\tu32 possible_crtcs = 0;\n\n\tfor_each_intel_crtc(dev, crtc) {\n\t\tif (encoder->pipe_mask & BIT(crtc->pipe))\n\t\t\tpossible_crtcs |= drm_crtc_mask(&crtc->base);\n\t}\n\n\treturn possible_crtcs;\n}\n\nstatic bool ilk_has_edp_a(struct drm_i915_private *dev_priv)\n{\n\tif (!IS_MOBILE(dev_priv))\n\t\treturn false;\n\n\tif ((intel_de_read(dev_priv, DP_A) & DP_DETECTED) == 0)\n\t\treturn false;\n\n\tif (IS_GEN(dev_priv, 5) && (intel_de_read(dev_priv, FUSE_STRAP) & ILK_eDP_A_DISABLE))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool intel_ddi_crt_present(struct drm_i915_private *dev_priv)\n{\n\tif (INTEL_GEN(dev_priv) >= 9)\n\t\treturn false;\n\n\tif (IS_HSW_ULT(dev_priv) || IS_BDW_ULT(dev_priv))\n\t\treturn false;\n\n\tif (HAS_PCH_LPT_H(dev_priv) &&\n\t    intel_de_read(dev_priv, SFUSE_STRAP) & SFUSE_STRAP_CRT_DISABLED)\n\t\treturn false;\n\n\t/* DDI E can't be used if DDI A requires 4 lanes */\n\tif (intel_de_read(dev_priv, DDI_BUF_CTL(PORT_A)) & DDI_A_4_LANES)\n\t\treturn false;\n\n\tif (!dev_priv->vbt.int_crt_support)\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid intel_pps_unlock_regs_wa(struct drm_i915_private *dev_priv)\n{\n\tint pps_num;\n\tint pps_idx;\n\n\tif (HAS_DDI(dev_priv))\n\t\treturn;\n\t/*\n\t * This w/a is needed at least on CPT/PPT, but to be sure apply it\n\t * everywhere where registers can be write protected.\n\t */\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\tpps_num = 2;\n\telse\n\t\tpps_num = 1;\n\n\tfor (pps_idx = 0; pps_idx < pps_num; pps_idx++) {\n\t\tu32 val = intel_de_read(dev_priv, PP_CONTROL(pps_idx));\n\n\t\tval = (val & ~PANEL_UNLOCK_MASK) | PANEL_UNLOCK_REGS;\n\t\tintel_de_write(dev_priv, PP_CONTROL(pps_idx), val);\n\t}\n}\n\nstatic void intel_pps_init(struct drm_i915_private *dev_priv)\n{\n\tif (HAS_PCH_SPLIT(dev_priv) || IS_GEN9_LP(dev_priv))\n\t\tdev_priv->pps_mmio_base = PCH_PPS_BASE;\n\telse if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\tdev_priv->pps_mmio_base = VLV_PPS_BASE;\n\telse\n\t\tdev_priv->pps_mmio_base = PPS_BASE;\n\n\tintel_pps_unlock_regs_wa(dev_priv);\n}\n\nstatic void intel_setup_outputs(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_encoder *encoder;\n\tbool dpd_is_edp = false;\n\n\tintel_pps_init(dev_priv);\n\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn;\n\n\tif (IS_ROCKETLAKE(dev_priv)) {\n\t\tintel_ddi_init(dev_priv, PORT_A);\n\t\tintel_ddi_init(dev_priv, PORT_B);\n\t\tintel_ddi_init(dev_priv, PORT_D);\t/* DDI TC1 */\n\t\tintel_ddi_init(dev_priv, PORT_E);\t/* DDI TC2 */\n\t} else if (INTEL_GEN(dev_priv) >= 12) {\n\t\tintel_ddi_init(dev_priv, PORT_A);\n\t\tintel_ddi_init(dev_priv, PORT_B);\n\t\tintel_ddi_init(dev_priv, PORT_D);\n\t\tintel_ddi_init(dev_priv, PORT_E);\n\t\tintel_ddi_init(dev_priv, PORT_F);\n\t\tintel_ddi_init(dev_priv, PORT_G);\n\t\tintel_ddi_init(dev_priv, PORT_H);\n\t\tintel_ddi_init(dev_priv, PORT_I);\n\t\ticl_dsi_init(dev_priv);\n\t} else if (IS_ELKHARTLAKE(dev_priv)) {\n\t\tintel_ddi_init(dev_priv, PORT_A);\n\t\tintel_ddi_init(dev_priv, PORT_B);\n\t\tintel_ddi_init(dev_priv, PORT_C);\n\t\tintel_ddi_init(dev_priv, PORT_D);\n\t\ticl_dsi_init(dev_priv);\n\t} else if (IS_GEN(dev_priv, 11)) {\n\t\tintel_ddi_init(dev_priv, PORT_A);\n\t\tintel_ddi_init(dev_priv, PORT_B);\n\t\tintel_ddi_init(dev_priv, PORT_C);\n\t\tintel_ddi_init(dev_priv, PORT_D);\n\t\tintel_ddi_init(dev_priv, PORT_E);\n\t\t/*\n\t\t * On some ICL SKUs port F is not present. No strap bits for\n\t\t * this, so rely on VBT.\n\t\t * Work around broken VBTs on SKUs known to have no port F.\n\t\t */\n\t\tif (IS_ICL_WITH_PORT_F(dev_priv) &&\n\t\t    intel_bios_is_port_present(dev_priv, PORT_F))\n\t\t\tintel_ddi_init(dev_priv, PORT_F);\n\n\t\ticl_dsi_init(dev_priv);\n\t} else if (IS_GEN9_LP(dev_priv)) {\n\t\t/*\n\t\t * FIXME: Broxton doesn't support port detection via the\n\t\t * DDI_BUF_CTL_A or SFUSE_STRAP registers, find another way to\n\t\t * detect the ports.\n\t\t */\n\t\tintel_ddi_init(dev_priv, PORT_A);\n\t\tintel_ddi_init(dev_priv, PORT_B);\n\t\tintel_ddi_init(dev_priv, PORT_C);\n\n\t\tvlv_dsi_init(dev_priv);\n\t} else if (HAS_DDI(dev_priv)) {\n\t\tint found;\n\n\t\tif (intel_ddi_crt_present(dev_priv))\n\t\t\tintel_crt_init(dev_priv);\n\n\t\t/*\n\t\t * Haswell uses DDI functions to detect digital outputs.\n\t\t * On SKL pre-D0 the strap isn't connected, so we assume\n\t\t * it's there.\n\t\t */\n\t\tfound = intel_de_read(dev_priv, DDI_BUF_CTL(PORT_A)) & DDI_INIT_DISPLAY_DETECTED;\n\t\t/* WaIgnoreDDIAStrap: skl */\n\t\tif (found || IS_GEN9_BC(dev_priv))\n\t\t\tintel_ddi_init(dev_priv, PORT_A);\n\n\t\t/* DDI B, C, D, and F detection is indicated by the SFUSE_STRAP\n\t\t * register */\n\t\tfound = intel_de_read(dev_priv, SFUSE_STRAP);\n\n\t\tif (found & SFUSE_STRAP_DDIB_DETECTED)\n\t\t\tintel_ddi_init(dev_priv, PORT_B);\n\t\tif (found & SFUSE_STRAP_DDIC_DETECTED)\n\t\t\tintel_ddi_init(dev_priv, PORT_C);\n\t\tif (found & SFUSE_STRAP_DDID_DETECTED)\n\t\t\tintel_ddi_init(dev_priv, PORT_D);\n\t\tif (found & SFUSE_STRAP_DDIF_DETECTED)\n\t\t\tintel_ddi_init(dev_priv, PORT_F);\n\t\t/*\n\t\t * On SKL we don't have a way to detect DDI-E so we rely on VBT.\n\t\t */\n\t\tif (IS_GEN9_BC(dev_priv) &&\n\t\t    intel_bios_is_port_present(dev_priv, PORT_E))\n\t\t\tintel_ddi_init(dev_priv, PORT_E);\n\n\t} else if (HAS_PCH_SPLIT(dev_priv)) {\n\t\tint found;\n\n\t\t/*\n\t\t * intel_edp_init_connector() depends on this completing first,\n\t\t * to prevent the registration of both eDP and LVDS and the\n\t\t * incorrect sharing of the PPS.\n\t\t */\n\t\tintel_lvds_init(dev_priv);\n\t\tintel_crt_init(dev_priv);\n\n\t\tdpd_is_edp = intel_dp_is_port_edp(dev_priv, PORT_D);\n\n\t\tif (ilk_has_edp_a(dev_priv))\n\t\t\tintel_dp_init(dev_priv, DP_A, PORT_A);\n\n\t\tif (intel_de_read(dev_priv, PCH_HDMIB) & SDVO_DETECTED) {\n\t\t\t/* PCH SDVOB multiplex with HDMIB */\n\t\t\tfound = intel_sdvo_init(dev_priv, PCH_SDVOB, PORT_B);\n\t\t\tif (!found)\n\t\t\t\tintel_hdmi_init(dev_priv, PCH_HDMIB, PORT_B);\n\t\t\tif (!found && (intel_de_read(dev_priv, PCH_DP_B) & DP_DETECTED))\n\t\t\t\tintel_dp_init(dev_priv, PCH_DP_B, PORT_B);\n\t\t}\n\n\t\tif (intel_de_read(dev_priv, PCH_HDMIC) & SDVO_DETECTED)\n\t\t\tintel_hdmi_init(dev_priv, PCH_HDMIC, PORT_C);\n\n\t\tif (!dpd_is_edp && intel_de_read(dev_priv, PCH_HDMID) & SDVO_DETECTED)\n\t\t\tintel_hdmi_init(dev_priv, PCH_HDMID, PORT_D);\n\n\t\tif (intel_de_read(dev_priv, PCH_DP_C) & DP_DETECTED)\n\t\t\tintel_dp_init(dev_priv, PCH_DP_C, PORT_C);\n\n\t\tif (intel_de_read(dev_priv, PCH_DP_D) & DP_DETECTED)\n\t\t\tintel_dp_init(dev_priv, PCH_DP_D, PORT_D);\n\t} else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\tbool has_edp, has_port;\n\n\t\tif (IS_VALLEYVIEW(dev_priv) && dev_priv->vbt.int_crt_support)\n\t\t\tintel_crt_init(dev_priv);\n\n\t\t/*\n\t\t * The DP_DETECTED bit is the latched state of the DDC\n\t\t * SDA pin at boot. However since eDP doesn't require DDC\n\t\t * (no way to plug in a DP->HDMI dongle) the DDC pins for\n\t\t * eDP ports may have been muxed to an alternate function.\n\t\t * Thus we can't rely on the DP_DETECTED bit alone to detect\n\t\t * eDP ports. Consult the VBT as well as DP_DETECTED to\n\t\t * detect eDP ports.\n\t\t *\n\t\t * Sadly the straps seem to be missing sometimes even for HDMI\n\t\t * ports (eg. on Voyo V3 - CHT x7-Z8700), so check both strap\n\t\t * and VBT for the presence of the port. Additionally we can't\n\t\t * trust the port type the VBT declares as we've seen at least\n\t\t * HDMI ports that the VBT claim are DP or eDP.\n\t\t */\n\t\thas_edp = intel_dp_is_port_edp(dev_priv, PORT_B);\n\t\thas_port = intel_bios_is_port_present(dev_priv, PORT_B);\n\t\tif (intel_de_read(dev_priv, VLV_DP_B) & DP_DETECTED || has_port)\n\t\t\thas_edp &= intel_dp_init(dev_priv, VLV_DP_B, PORT_B);\n\t\tif ((intel_de_read(dev_priv, VLV_HDMIB) & SDVO_DETECTED || has_port) && !has_edp)\n\t\t\tintel_hdmi_init(dev_priv, VLV_HDMIB, PORT_B);\n\n\t\thas_edp = intel_dp_is_port_edp(dev_priv, PORT_C);\n\t\thas_port = intel_bios_is_port_present(dev_priv, PORT_C);\n\t\tif (intel_de_read(dev_priv, VLV_DP_C) & DP_DETECTED || has_port)\n\t\t\thas_edp &= intel_dp_init(dev_priv, VLV_DP_C, PORT_C);\n\t\tif ((intel_de_read(dev_priv, VLV_HDMIC) & SDVO_DETECTED || has_port) && !has_edp)\n\t\t\tintel_hdmi_init(dev_priv, VLV_HDMIC, PORT_C);\n\n\t\tif (IS_CHERRYVIEW(dev_priv)) {\n\t\t\t/*\n\t\t\t * eDP not supported on port D,\n\t\t\t * so no need to worry about it\n\t\t\t */\n\t\t\thas_port = intel_bios_is_port_present(dev_priv, PORT_D);\n\t\t\tif (intel_de_read(dev_priv, CHV_DP_D) & DP_DETECTED || has_port)\n\t\t\t\tintel_dp_init(dev_priv, CHV_DP_D, PORT_D);\n\t\t\tif (intel_de_read(dev_priv, CHV_HDMID) & SDVO_DETECTED || has_port)\n\t\t\t\tintel_hdmi_init(dev_priv, CHV_HDMID, PORT_D);\n\t\t}\n\n\t\tvlv_dsi_init(dev_priv);\n\t} else if (IS_PINEVIEW(dev_priv)) {\n\t\tintel_lvds_init(dev_priv);\n\t\tintel_crt_init(dev_priv);\n\t} else if (IS_GEN_RANGE(dev_priv, 3, 4)) {\n\t\tbool found = false;\n\n\t\tif (IS_MOBILE(dev_priv))\n\t\t\tintel_lvds_init(dev_priv);\n\n\t\tintel_crt_init(dev_priv);\n\n\t\tif (intel_de_read(dev_priv, GEN3_SDVOB) & SDVO_DETECTED) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"probing SDVOB\\n\");\n\t\t\tfound = intel_sdvo_init(dev_priv, GEN3_SDVOB, PORT_B);\n\t\t\tif (!found && IS_G4X(dev_priv)) {\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"probing HDMI on SDVOB\\n\");\n\t\t\t\tintel_hdmi_init(dev_priv, GEN4_HDMIB, PORT_B);\n\t\t\t}\n\n\t\t\tif (!found && IS_G4X(dev_priv))\n\t\t\t\tintel_dp_init(dev_priv, DP_B, PORT_B);\n\t\t}\n\n\t\t/* Before G4X SDVOC doesn't have its own detect register */\n\n\t\tif (intel_de_read(dev_priv, GEN3_SDVOB) & SDVO_DETECTED) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"probing SDVOC\\n\");\n\t\t\tfound = intel_sdvo_init(dev_priv, GEN3_SDVOC, PORT_C);\n\t\t}\n\n\t\tif (!found && (intel_de_read(dev_priv, GEN3_SDVOC) & SDVO_DETECTED)) {\n\n\t\t\tif (IS_G4X(dev_priv)) {\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"probing HDMI on SDVOC\\n\");\n\t\t\t\tintel_hdmi_init(dev_priv, GEN4_HDMIC, PORT_C);\n\t\t\t}\n\t\t\tif (IS_G4X(dev_priv))\n\t\t\t\tintel_dp_init(dev_priv, DP_C, PORT_C);\n\t\t}\n\n\t\tif (IS_G4X(dev_priv) && (intel_de_read(dev_priv, DP_D) & DP_DETECTED))\n\t\t\tintel_dp_init(dev_priv, DP_D, PORT_D);\n\n\t\tif (SUPPORTS_TV(dev_priv))\n\t\t\tintel_tv_init(dev_priv);\n\t} else if (IS_GEN(dev_priv, 2)) {\n\t\tif (IS_I85X(dev_priv))\n\t\t\tintel_lvds_init(dev_priv);\n\n\t\tintel_crt_init(dev_priv);\n\t\tintel_dvo_init(dev_priv);\n\t}\n\n\tintel_psr_init(dev_priv);\n\n\tfor_each_intel_encoder(&dev_priv->drm, encoder) {\n\t\tencoder->base.possible_crtcs =\n\t\t\tintel_encoder_possible_crtcs(encoder);\n\t\tencoder->base.possible_clones =\n\t\t\tintel_encoder_possible_clones(encoder);\n\t}\n\n\tintel_init_pch_refclk(dev_priv);\n\n\tdrm_helper_move_panel_connectors_to_head(&dev_priv->drm);\n}\n\nstatic void intel_user_framebuffer_destroy(struct drm_framebuffer *fb)\n{\n\tstruct intel_framebuffer *intel_fb = to_intel_framebuffer(fb);\n\n\tdrm_framebuffer_cleanup(fb);\n\tintel_frontbuffer_put(intel_fb->frontbuffer);\n\n\tkfree(intel_fb);\n}\n\nstatic int intel_user_framebuffer_create_handle(struct drm_framebuffer *fb,\n\t\t\t\t\t\tstruct drm_file *file,\n\t\t\t\t\t\tunsigned int *handle)\n{\n\tstruct drm_i915_gem_object *obj = intel_fb_obj(fb);\n\tstruct drm_i915_private *i915 = to_i915(obj->base.dev);\n\n\tif (obj->userptr.mm) {\n\t\tdrm_dbg(&i915->drm,\n\t\t\t\"attempting to use a userptr for a framebuffer, denied\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn drm_gem_handle_create(file, &obj->base, handle);\n}\n\nstatic int intel_user_framebuffer_dirty(struct drm_framebuffer *fb,\n\t\t\t\t\tstruct drm_file *file,\n\t\t\t\t\tunsigned flags, unsigned color,\n\t\t\t\t\tstruct drm_clip_rect *clips,\n\t\t\t\t\tunsigned num_clips)\n{\n\tstruct drm_i915_gem_object *obj = intel_fb_obj(fb);\n\n\ti915_gem_object_flush_if_display(obj);\n\tintel_frontbuffer_flush(to_intel_frontbuffer(fb), ORIGIN_DIRTYFB);\n\n\treturn 0;\n}\n\nstatic const struct drm_framebuffer_funcs intel_fb_funcs = {\n\t.destroy = intel_user_framebuffer_destroy,\n\t.create_handle = intel_user_framebuffer_create_handle,\n\t.dirty = intel_user_framebuffer_dirty,\n};\n\nstatic int intel_framebuffer_init(struct intel_framebuffer *intel_fb,\n\t\t\t\t  struct drm_i915_gem_object *obj,\n\t\t\t\t  struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(obj->base.dev);\n\tstruct drm_framebuffer *fb = &intel_fb->base;\n\tu32 max_stride;\n\tunsigned int tiling, stride;\n\tint ret = -EINVAL;\n\tint i;\n\n\tintel_fb->frontbuffer = intel_frontbuffer_get(obj);\n\tif (!intel_fb->frontbuffer)\n\t\treturn -ENOMEM;\n\n\ti915_gem_object_lock(obj, NULL);\n\ttiling = i915_gem_object_get_tiling(obj);\n\tstride = i915_gem_object_get_stride(obj);\n\ti915_gem_object_unlock(obj);\n\n\tif (mode_cmd->flags & DRM_MODE_FB_MODIFIERS) {\n\t\t/*\n\t\t * If there's a fence, enforce that\n\t\t * the fb modifier and tiling mode match.\n\t\t */\n\t\tif (tiling != I915_TILING_NONE &&\n\t\t    tiling != intel_fb_modifier_to_tiling(mode_cmd->modifier[0])) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"tiling_mode doesn't match fb modifier\\n\");\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tif (tiling == I915_TILING_X) {\n\t\t\tmode_cmd->modifier[0] = I915_FORMAT_MOD_X_TILED;\n\t\t} else if (tiling == I915_TILING_Y) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"No Y tiling for legacy addfb\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (!drm_any_plane_has_format(&dev_priv->drm,\n\t\t\t\t      mode_cmd->pixel_format,\n\t\t\t\t      mode_cmd->modifier[0])) {\n\t\tstruct drm_format_name_buf format_name;\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"unsupported pixel format %s / modifier 0x%llx\\n\",\n\t\t\t    drm_get_format_name(mode_cmd->pixel_format,\n\t\t\t\t\t\t&format_name),\n\t\t\t    mode_cmd->modifier[0]);\n\t\tgoto err;\n\t}\n\n\t/*\n\t * gen2/3 display engine uses the fence if present,\n\t * so the tiling mode must match the fb modifier exactly.\n\t */\n\tif (INTEL_GEN(dev_priv) < 4 &&\n\t    tiling != intel_fb_modifier_to_tiling(mode_cmd->modifier[0])) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"tiling_mode must match fb modifier exactly on gen2/3\\n\");\n\t\tgoto err;\n\t}\n\n\tmax_stride = intel_fb_max_stride(dev_priv, mode_cmd->pixel_format,\n\t\t\t\t\t mode_cmd->modifier[0]);\n\tif (mode_cmd->pitches[0] > max_stride) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"%s pitch (%u) must be at most %d\\n\",\n\t\t\t    mode_cmd->modifier[0] != DRM_FORMAT_MOD_LINEAR ?\n\t\t\t    \"tiled\" : \"linear\",\n\t\t\t    mode_cmd->pitches[0], max_stride);\n\t\tgoto err;\n\t}\n\n\t/*\n\t * If there's a fence, enforce that\n\t * the fb pitch and fence stride match.\n\t */\n\tif (tiling != I915_TILING_NONE && mode_cmd->pitches[0] != stride) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"pitch (%d) must match tiling stride (%d)\\n\",\n\t\t\t    mode_cmd->pitches[0], stride);\n\t\tgoto err;\n\t}\n\n\t/* FIXME need to adjust LINOFF/TILEOFF accordingly. */\n\tif (mode_cmd->offsets[0] != 0) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"plane 0 offset (0x%08x) must be 0\\n\",\n\t\t\t    mode_cmd->offsets[0]);\n\t\tgoto err;\n\t}\n\n\tdrm_helper_mode_fill_fb_struct(&dev_priv->drm, fb, mode_cmd);\n\n\tfor (i = 0; i < fb->format->num_planes; i++) {\n\t\tu32 stride_alignment;\n\n\t\tif (mode_cmd->handles[i] != mode_cmd->handles[0]) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm, \"bad plane %d handle\\n\",\n\t\t\t\t    i);\n\t\t\tgoto err;\n\t\t}\n\n\t\tstride_alignment = intel_fb_stride_alignment(fb, i);\n\t\tif (fb->pitches[i] & (stride_alignment - 1)) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"plane %d pitch (%d) must be at least %u byte aligned\\n\",\n\t\t\t\t    i, fb->pitches[i], stride_alignment);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (is_gen12_ccs_plane(fb, i)) {\n\t\t\tint ccs_aux_stride = gen12_ccs_aux_stride(fb, i);\n\n\t\t\tif (fb->pitches[i] != ccs_aux_stride) {\n\t\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t\t    \"ccs aux plane %d pitch (%d) must be %d\\n\",\n\t\t\t\t\t    i,\n\t\t\t\t\t    fb->pitches[i], ccs_aux_stride);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tfb->obj[i] = &obj->base;\n\t}\n\n\tret = intel_fill_fb_info(dev_priv, fb);\n\tif (ret)\n\t\tgoto err;\n\n\tret = drm_framebuffer_init(&dev_priv->drm, fb, &intel_fb_funcs);\n\tif (ret) {\n\t\tdrm_err(&dev_priv->drm, \"framebuffer init failed %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tintel_frontbuffer_put(intel_fb->frontbuffer);\n\treturn ret;\n}\n\nstatic struct drm_framebuffer *\nintel_user_framebuffer_create(struct drm_device *dev,\n\t\t\t      struct drm_file *filp,\n\t\t\t      const struct drm_mode_fb_cmd2 *user_mode_cmd)\n{\n\tstruct drm_framebuffer *fb;\n\tstruct drm_i915_gem_object *obj;\n\tstruct drm_mode_fb_cmd2 mode_cmd = *user_mode_cmd;\n\n\tobj = i915_gem_object_lookup(filp, mode_cmd.handles[0]);\n\tif (!obj)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tfb = intel_framebuffer_create(obj, &mode_cmd);\n\ti915_gem_object_put(obj);\n\n\treturn fb;\n}\n\nstatic enum drm_mode_status\nintel_mode_valid(struct drm_device *dev,\n\t\t const struct drm_display_mode *mode)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tint hdisplay_max, htotal_max;\n\tint vdisplay_max, vtotal_max;\n\n\t/*\n\t * Can't reject DBLSCAN here because Xorg ddxen can add piles\n\t * of DBLSCAN modes to the output's mode list when they detect\n\t * the scaling mode property on the connector. And they don't\n\t * ask the kernel to validate those modes in any way until\n\t * modeset time at which point the client gets a protocol error.\n\t * So in order to not upset those clients we silently ignore the\n\t * DBLSCAN flag on such connectors. For other connectors we will\n\t * reject modes with the DBLSCAN flag in encoder->compute_config().\n\t * And we always reject DBLSCAN modes in connector->mode_valid()\n\t * as we never want such modes on the connector's mode list.\n\t */\n\n\tif (mode->vscan > 1)\n\t\treturn MODE_NO_VSCAN;\n\n\tif (mode->flags & DRM_MODE_FLAG_HSKEW)\n\t\treturn MODE_H_ILLEGAL;\n\n\tif (mode->flags & (DRM_MODE_FLAG_CSYNC |\n\t\t\t   DRM_MODE_FLAG_NCSYNC |\n\t\t\t   DRM_MODE_FLAG_PCSYNC))\n\t\treturn MODE_HSYNC;\n\n\tif (mode->flags & (DRM_MODE_FLAG_BCAST |\n\t\t\t   DRM_MODE_FLAG_PIXMUX |\n\t\t\t   DRM_MODE_FLAG_CLKDIV2))\n\t\treturn MODE_BAD;\n\n\t/* Transcoder timing limits */\n\tif (INTEL_GEN(dev_priv) >= 11) {\n\t\thdisplay_max = 16384;\n\t\tvdisplay_max = 8192;\n\t\thtotal_max = 16384;\n\t\tvtotal_max = 8192;\n\t} else if (INTEL_GEN(dev_priv) >= 9 ||\n\t\t   IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv)) {\n\t\thdisplay_max = 8192; /* FDI max 4096 handled elsewhere */\n\t\tvdisplay_max = 4096;\n\t\thtotal_max = 8192;\n\t\tvtotal_max = 8192;\n\t} else if (INTEL_GEN(dev_priv) >= 3) {\n\t\thdisplay_max = 4096;\n\t\tvdisplay_max = 4096;\n\t\thtotal_max = 8192;\n\t\tvtotal_max = 8192;\n\t} else {\n\t\thdisplay_max = 2048;\n\t\tvdisplay_max = 2048;\n\t\thtotal_max = 4096;\n\t\tvtotal_max = 4096;\n\t}\n\n\tif (mode->hdisplay > hdisplay_max ||\n\t    mode->hsync_start > htotal_max ||\n\t    mode->hsync_end > htotal_max ||\n\t    mode->htotal > htotal_max)\n\t\treturn MODE_H_ILLEGAL;\n\n\tif (mode->vdisplay > vdisplay_max ||\n\t    mode->vsync_start > vtotal_max ||\n\t    mode->vsync_end > vtotal_max ||\n\t    mode->vtotal > vtotal_max)\n\t\treturn MODE_V_ILLEGAL;\n\n\tif (INTEL_GEN(dev_priv) >= 5) {\n\t\tif (mode->hdisplay < 64 ||\n\t\t    mode->htotal - mode->hdisplay < 32)\n\t\t\treturn MODE_H_ILLEGAL;\n\n\t\tif (mode->vtotal - mode->vdisplay < 5)\n\t\t\treturn MODE_V_ILLEGAL;\n\t} else {\n\t\tif (mode->htotal - mode->hdisplay < 32)\n\t\t\treturn MODE_H_ILLEGAL;\n\n\t\tif (mode->vtotal - mode->vdisplay < 3)\n\t\t\treturn MODE_V_ILLEGAL;\n\t}\n\n\treturn MODE_OK;\n}\n\nenum drm_mode_status\nintel_mode_valid_max_plane_size(struct drm_i915_private *dev_priv,\n\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tint plane_width_max, plane_height_max;\n\n\t/*\n\t * intel_mode_valid() should be\n\t * sufficient on older platforms.\n\t */\n\tif (INTEL_GEN(dev_priv) < 9)\n\t\treturn MODE_OK;\n\n\t/*\n\t * Most people will probably want a fullscreen\n\t * plane so let's not advertize modes that are\n\t * too big for that.\n\t */\n\tif (INTEL_GEN(dev_priv) >= 11) {\n\t\tplane_width_max = 5120;\n\t\tplane_height_max = 4320;\n\t} else {\n\t\tplane_width_max = 5120;\n\t\tplane_height_max = 4096;\n\t}\n\n\tif (mode->hdisplay > plane_width_max)\n\t\treturn MODE_H_ILLEGAL;\n\n\tif (mode->vdisplay > plane_height_max)\n\t\treturn MODE_V_ILLEGAL;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_mode_config_funcs intel_mode_funcs = {\n\t.fb_create = intel_user_framebuffer_create,\n\t.get_format_info = intel_get_format_info,\n\t.output_poll_changed = intel_fbdev_output_poll_changed,\n\t.mode_valid = intel_mode_valid,\n\t.atomic_check = intel_atomic_check,\n\t.atomic_commit = intel_atomic_commit,\n\t.atomic_state_alloc = intel_atomic_state_alloc,\n\t.atomic_state_clear = intel_atomic_state_clear,\n\t.atomic_state_free = intel_atomic_state_free,\n};\n\n/**\n * intel_init_display_hooks - initialize the display modesetting hooks\n * @dev_priv: device private\n */\nvoid intel_init_display_hooks(struct drm_i915_private *dev_priv)\n{\n\tintel_init_cdclk_hooks(dev_priv);\n\n\tif (INTEL_GEN(dev_priv) >= 9) {\n\t\tdev_priv->display.get_pipe_config = hsw_get_pipe_config;\n\t\tdev_priv->display.get_initial_plane_config =\n\t\t\tskl_get_initial_plane_config;\n\t\tdev_priv->display.crtc_compute_clock = hsw_crtc_compute_clock;\n\t\tdev_priv->display.crtc_enable = hsw_crtc_enable;\n\t\tdev_priv->display.crtc_disable = hsw_crtc_disable;\n\t} else if (HAS_DDI(dev_priv)) {\n\t\tdev_priv->display.get_pipe_config = hsw_get_pipe_config;\n\t\tdev_priv->display.get_initial_plane_config =\n\t\t\ti9xx_get_initial_plane_config;\n\t\tdev_priv->display.crtc_compute_clock =\n\t\t\thsw_crtc_compute_clock;\n\t\tdev_priv->display.crtc_enable = hsw_crtc_enable;\n\t\tdev_priv->display.crtc_disable = hsw_crtc_disable;\n\t} else if (HAS_PCH_SPLIT(dev_priv)) {\n\t\tdev_priv->display.get_pipe_config = ilk_get_pipe_config;\n\t\tdev_priv->display.get_initial_plane_config =\n\t\t\ti9xx_get_initial_plane_config;\n\t\tdev_priv->display.crtc_compute_clock =\n\t\t\tilk_crtc_compute_clock;\n\t\tdev_priv->display.crtc_enable = ilk_crtc_enable;\n\t\tdev_priv->display.crtc_disable = ilk_crtc_disable;\n\t} else if (IS_CHERRYVIEW(dev_priv)) {\n\t\tdev_priv->display.get_pipe_config = i9xx_get_pipe_config;\n\t\tdev_priv->display.get_initial_plane_config =\n\t\t\ti9xx_get_initial_plane_config;\n\t\tdev_priv->display.crtc_compute_clock = chv_crtc_compute_clock;\n\t\tdev_priv->display.crtc_enable = valleyview_crtc_enable;\n\t\tdev_priv->display.crtc_disable = i9xx_crtc_disable;\n\t} else if (IS_VALLEYVIEW(dev_priv)) {\n\t\tdev_priv->display.get_pipe_config = i9xx_get_pipe_config;\n\t\tdev_priv->display.get_initial_plane_config =\n\t\t\ti9xx_get_initial_plane_config;\n\t\tdev_priv->display.crtc_compute_clock = vlv_crtc_compute_clock;\n\t\tdev_priv->display.crtc_enable = valleyview_crtc_enable;\n\t\tdev_priv->display.crtc_disable = i9xx_crtc_disable;\n\t} else if (IS_G4X(dev_priv)) {\n\t\tdev_priv->display.get_pipe_config = i9xx_get_pipe_config;\n\t\tdev_priv->display.get_initial_plane_config =\n\t\t\ti9xx_get_initial_plane_config;\n\t\tdev_priv->display.crtc_compute_clock = g4x_crtc_compute_clock;\n\t\tdev_priv->display.crtc_enable = i9xx_crtc_enable;\n\t\tdev_priv->display.crtc_disable = i9xx_crtc_disable;\n\t} else if (IS_PINEVIEW(dev_priv)) {\n\t\tdev_priv->display.get_pipe_config = i9xx_get_pipe_config;\n\t\tdev_priv->display.get_initial_plane_config =\n\t\t\ti9xx_get_initial_plane_config;\n\t\tdev_priv->display.crtc_compute_clock = pnv_crtc_compute_clock;\n\t\tdev_priv->display.crtc_enable = i9xx_crtc_enable;\n\t\tdev_priv->display.crtc_disable = i9xx_crtc_disable;\n\t} else if (!IS_GEN(dev_priv, 2)) {\n\t\tdev_priv->display.get_pipe_config = i9xx_get_pipe_config;\n\t\tdev_priv->display.get_initial_plane_config =\n\t\t\ti9xx_get_initial_plane_config;\n\t\tdev_priv->display.crtc_compute_clock = i9xx_crtc_compute_clock;\n\t\tdev_priv->display.crtc_enable = i9xx_crtc_enable;\n\t\tdev_priv->display.crtc_disable = i9xx_crtc_disable;\n\t} else {\n\t\tdev_priv->display.get_pipe_config = i9xx_get_pipe_config;\n\t\tdev_priv->display.get_initial_plane_config =\n\t\t\ti9xx_get_initial_plane_config;\n\t\tdev_priv->display.crtc_compute_clock = i8xx_crtc_compute_clock;\n\t\tdev_priv->display.crtc_enable = i9xx_crtc_enable;\n\t\tdev_priv->display.crtc_disable = i9xx_crtc_disable;\n\t}\n\n\tif (IS_GEN(dev_priv, 5)) {\n\t\tdev_priv->display.fdi_link_train = ilk_fdi_link_train;\n\t} else if (IS_GEN(dev_priv, 6)) {\n\t\tdev_priv->display.fdi_link_train = gen6_fdi_link_train;\n\t} else if (IS_IVYBRIDGE(dev_priv)) {\n\t\t/* FIXME: detect B0+ stepping and use auto training */\n\t\tdev_priv->display.fdi_link_train = ivb_manual_fdi_link_train;\n\t}\n\n\tif (INTEL_GEN(dev_priv) >= 9)\n\t\tdev_priv->display.commit_modeset_enables = skl_commit_modeset_enables;\n\telse\n\t\tdev_priv->display.commit_modeset_enables = intel_commit_modeset_enables;\n\n}\n\nvoid intel_modeset_init_hw(struct drm_i915_private *i915)\n{\n\tstruct intel_cdclk_state *cdclk_state =\n\t\tto_intel_cdclk_state(i915->cdclk.obj.state);\n\tstruct intel_dbuf_state *dbuf_state =\n\t\tto_intel_dbuf_state(i915->dbuf.obj.state);\n\n\tintel_update_cdclk(i915);\n\tintel_dump_cdclk_config(&i915->cdclk.hw, \"Current CDCLK\");\n\tcdclk_state->logical = cdclk_state->actual = i915->cdclk.hw;\n\n\tdbuf_state->enabled_slices = i915->dbuf.enabled_slices;\n}\n\nstatic int sanitize_watermarks_add_affected(struct drm_atomic_state *state)\n{\n\tstruct drm_plane *plane;\n\tstruct intel_crtc *crtc;\n\n\tfor_each_intel_crtc(state->dev, crtc) {\n\t\tstruct intel_crtc_state *crtc_state;\n\n\t\tcrtc_state = intel_atomic_get_crtc_state(state, crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn PTR_ERR(crtc_state);\n\n\t\tif (crtc_state->hw.active) {\n\t\t\t/*\n\t\t\t * Preserve the inherited flag to avoid\n\t\t\t * taking the full modeset path.\n\t\t\t */\n\t\t\tcrtc_state->inherited = true;\n\t\t}\n\t}\n\n\tdrm_for_each_plane(plane, state->dev) {\n\t\tstruct drm_plane_state *plane_state;\n\n\t\tplane_state = drm_atomic_get_plane_state(state, plane);\n\t\tif (IS_ERR(plane_state))\n\t\t\treturn PTR_ERR(plane_state);\n\t}\n\n\treturn 0;\n}\n\n/*\n * Calculate what we think the watermarks should be for the state we've read\n * out of the hardware and then immediately program those watermarks so that\n * we ensure the hardware settings match our internal state.\n *\n * We can calculate what we think WM's should be by creating a duplicate of the\n * current state (which was constructed during hardware readout) and running it\n * through the atomic check code to calculate new watermark values in the\n * state object.\n */\nstatic void sanitize_watermarks(struct drm_i915_private *dev_priv)\n{\n\tstruct drm_atomic_state *state;\n\tstruct intel_atomic_state *intel_state;\n\tstruct intel_crtc *crtc;\n\tstruct intel_crtc_state *crtc_state;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint ret;\n\tint i;\n\n\t/* Only supported on platforms that use atomic watermark design */\n\tif (!dev_priv->display.optimize_watermarks)\n\t\treturn;\n\n\tstate = drm_atomic_state_alloc(&dev_priv->drm);\n\tif (drm_WARN_ON(&dev_priv->drm, !state))\n\t\treturn;\n\n\tintel_state = to_intel_atomic_state(state);\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\nretry:\n\tstate->acquire_ctx = &ctx;\n\n\t/*\n\t * Hardware readout is the only time we don't want to calculate\n\t * intermediate watermarks (since we don't trust the current\n\t * watermarks).\n\t */\n\tif (!HAS_GMCH(dev_priv))\n\t\tintel_state->skip_intermediate_wm = true;\n\n\tret = sanitize_watermarks_add_affected(state);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = intel_atomic_check(&dev_priv->drm, state);\n\tif (ret)\n\t\tgoto fail;\n\n\t/* Write calculated watermark values back */\n\tfor_each_new_intel_crtc_in_state(intel_state, crtc, crtc_state, i) {\n\t\tcrtc_state->wm.need_postvbl_update = true;\n\t\tdev_priv->display.optimize_watermarks(intel_state, crtc);\n\n\t\tto_intel_crtc_state(crtc->base.state)->wm = crtc_state->wm;\n\t}\n\nfail:\n\tif (ret == -EDEADLK) {\n\t\tdrm_atomic_state_clear(state);\n\t\tdrm_modeset_backoff(&ctx);\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * If we fail here, it means that the hardware appears to be\n\t * programmed in a way that shouldn't be possible, given our\n\t * understanding of watermark requirements.  This might mean a\n\t * mistake in the hardware readout code or a mistake in the\n\t * watermark calculations for a given platform.  Raise a WARN\n\t * so that this is noticeable.\n\t *\n\t * If this actually happens, we'll have to just leave the\n\t * BIOS-programmed watermarks untouched and hope for the best.\n\t */\n\tdrm_WARN(&dev_priv->drm, ret,\n\t\t \"Could not determine valid watermarks for inherited state\\n\");\n\n\tdrm_atomic_state_put(state);\n\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n}\n\nstatic void intel_update_fdi_pll_freq(struct drm_i915_private *dev_priv)\n{\n\tif (IS_GEN(dev_priv, 5)) {\n\t\tu32 fdi_pll_clk =\n\t\t\tintel_de_read(dev_priv, FDI_PLL_BIOS_0) & FDI_PLL_FB_CLOCK_MASK;\n\n\t\tdev_priv->fdi_pll_freq = (fdi_pll_clk + 2) * 10000;\n\t} else if (IS_GEN(dev_priv, 6) || IS_IVYBRIDGE(dev_priv)) {\n\t\tdev_priv->fdi_pll_freq = 270000;\n\t} else {\n\t\treturn;\n\t}\n\n\tdrm_dbg(&dev_priv->drm, \"FDI PLL freq=%d\\n\", dev_priv->fdi_pll_freq);\n}\n\nstatic int intel_initial_commit(struct drm_device *dev)\n{\n\tstruct drm_atomic_state *state = NULL;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tstruct intel_crtc *crtc;\n\tint ret = 0;\n\n\tstate = drm_atomic_state_alloc(dev);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\nretry:\n\tstate->acquire_ctx = &ctx;\n\n\tfor_each_intel_crtc(dev, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tintel_atomic_get_crtc_state(state, crtc);\n\n\t\tif (IS_ERR(crtc_state)) {\n\t\t\tret = PTR_ERR(crtc_state);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (crtc_state->hw.active) {\n\t\t\t/*\n\t\t\t * We've not yet detected sink capabilities\n\t\t\t * (audio,infoframes,etc.) and thus we don't want to\n\t\t\t * force a full state recomputation yet. We want that to\n\t\t\t * happen only for the first real commit from userspace.\n\t\t\t * So preserve the inherited flag for the time being.\n\t\t\t */\n\t\t\tcrtc_state->inherited = true;\n\n\t\t\tret = drm_atomic_add_affected_planes(state, &crtc->base);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * FIXME hack to force a LUT update to avoid the\n\t\t\t * plane update forcing the pipe gamma on without\n\t\t\t * having a proper LUT loaded. Remove once we\n\t\t\t * have readout for pipe gamma enable.\n\t\t\t */\n\t\t\tcrtc_state->uapi.color_mgmt_changed = true;\n\n\t\t\t/*\n\t\t\t * FIXME hack to force full modeset when DSC is being\n\t\t\t * used.\n\t\t\t *\n\t\t\t * As long as we do not have full state readout and\n\t\t\t * config comparison of crtc_state->dsc, we have no way\n\t\t\t * to ensure reliable fastset. Remove once we have\n\t\t\t * readout for DSC.\n\t\t\t */\n\t\t\tif (crtc_state->dsc.compression_enable) {\n\t\t\t\tret = drm_atomic_add_affected_connectors(state,\n\t\t\t\t\t\t\t\t\t &crtc->base);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t\tcrtc_state->uapi.mode_changed = true;\n\t\t\t\tdrm_dbg_kms(dev, \"Force full modeset for DSC\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tret = drm_atomic_commit(state);\n\nout:\n\tif (ret == -EDEADLK) {\n\t\tdrm_atomic_state_clear(state);\n\t\tdrm_modeset_backoff(&ctx);\n\t\tgoto retry;\n\t}\n\n\tdrm_atomic_state_put(state);\n\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\n\treturn ret;\n}\n\nstatic void intel_mode_config_init(struct drm_i915_private *i915)\n{\n\tstruct drm_mode_config *mode_config = &i915->drm.mode_config;\n\n\tdrm_mode_config_init(&i915->drm);\n\tINIT_LIST_HEAD(&i915->global_obj_list);\n\n\tmode_config->min_width = 0;\n\tmode_config->min_height = 0;\n\n\tmode_config->preferred_depth = 24;\n\tmode_config->prefer_shadow = 1;\n\n\tmode_config->allow_fb_modifiers = true;\n\n\tmode_config->funcs = &intel_mode_funcs;\n\n\t/*\n\t * Maximum framebuffer dimensions, chosen to match\n\t * the maximum render engine surface size on gen4+.\n\t */\n\tif (INTEL_GEN(i915) >= 7) {\n\t\tmode_config->max_width = 16384;\n\t\tmode_config->max_height = 16384;\n\t} else if (INTEL_GEN(i915) >= 4) {\n\t\tmode_config->max_width = 8192;\n\t\tmode_config->max_height = 8192;\n\t} else if (IS_GEN(i915, 3)) {\n\t\tmode_config->max_width = 4096;\n\t\tmode_config->max_height = 4096;\n\t} else {\n\t\tmode_config->max_width = 2048;\n\t\tmode_config->max_height = 2048;\n\t}\n\n\tif (IS_I845G(i915) || IS_I865G(i915)) {\n\t\tmode_config->cursor_width = IS_I845G(i915) ? 64 : 512;\n\t\tmode_config->cursor_height = 1023;\n\t} else if (IS_I830(i915) || IS_I85X(i915) ||\n\t\t   IS_I915G(i915) || IS_I915GM(i915)) {\n\t\tmode_config->cursor_width = 64;\n\t\tmode_config->cursor_height = 64;\n\t} else {\n\t\tmode_config->cursor_width = 256;\n\t\tmode_config->cursor_height = 256;\n\t}\n}\n\nstatic void intel_mode_config_cleanup(struct drm_i915_private *i915)\n{\n\tintel_atomic_global_obj_cleanup(i915);\n\tdrm_mode_config_cleanup(&i915->drm);\n}\n\nstatic void plane_config_fini(struct intel_initial_plane_config *plane_config)\n{\n\tif (plane_config->fb) {\n\t\tstruct drm_framebuffer *fb = &plane_config->fb->base;\n\n\t\t/* We may only have the stub and not a full framebuffer */\n\t\tif (drm_framebuffer_read_refcount(fb))\n\t\t\tdrm_framebuffer_put(fb);\n\t\telse\n\t\t\tkfree(fb);\n\t}\n\n\tif (plane_config->vma)\n\t\ti915_vma_put(plane_config->vma);\n}\n\n/* part #1: call before irq install */\nint intel_modeset_init_noirq(struct drm_i915_private *i915)\n{\n\tint ret;\n\n\tif (i915_inject_probe_failure(i915))\n\t\treturn -ENODEV;\n\n\tif (HAS_DISPLAY(i915)) {\n\t\tret = drm_vblank_init(&i915->drm,\n\t\t\t\t      INTEL_NUM_PIPES(i915));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tintel_bios_init(i915);\n\n\tret = intel_vga_register(i915);\n\tif (ret)\n\t\tgoto cleanup_bios;\n\n\t/* FIXME: completely on the wrong abstraction layer */\n\tintel_power_domains_init_hw(i915, false);\n\n\tintel_csr_ucode_init(i915);\n\n\ti915->modeset_wq = alloc_ordered_workqueue(\"i915_modeset\", 0);\n\ti915->flip_wq = alloc_workqueue(\"i915_flip\", WQ_HIGHPRI |\n\t\t\t\t\tWQ_UNBOUND, WQ_UNBOUND_MAX_ACTIVE);\n\n\tintel_mode_config_init(i915);\n\n\tret = intel_cdclk_init(i915);\n\tif (ret)\n\t\tgoto cleanup_vga_client_pw_domain_csr;\n\n\tret = intel_dbuf_init(i915);\n\tif (ret)\n\t\tgoto cleanup_vga_client_pw_domain_csr;\n\n\tret = intel_bw_init(i915);\n\tif (ret)\n\t\tgoto cleanup_vga_client_pw_domain_csr;\n\n\tinit_llist_head(&i915->atomic_helper.free_list);\n\tINIT_WORK(&i915->atomic_helper.free_work,\n\t\t  intel_atomic_helper_free_state_worker);\n\n\tintel_init_quirks(i915);\n\n\tintel_fbc_init(i915);\n\n\treturn 0;\n\ncleanup_vga_client_pw_domain_csr:\n\tintel_csr_ucode_fini(i915);\n\tintel_power_domains_driver_remove(i915);\n\tintel_vga_unregister(i915);\ncleanup_bios:\n\tintel_bios_driver_remove(i915);\n\n\treturn ret;\n}\n\n/* part #2: call after irq install, but before gem init */\nint intel_modeset_init_nogem(struct drm_i915_private *i915)\n{\n\tstruct drm_device *dev = &i915->drm;\n\tenum pipe pipe;\n\tstruct intel_crtc *crtc;\n\tint ret;\n\n\tintel_init_pm(i915);\n\n\tintel_panel_sanitize_ssc(i915);\n\n\tintel_gmbus_setup(i915);\n\n\tdrm_dbg_kms(&i915->drm, \"%d display pipe%s available.\\n\",\n\t\t    INTEL_NUM_PIPES(i915),\n\t\t    INTEL_NUM_PIPES(i915) > 1 ? \"s\" : \"\");\n\n\tif (HAS_DISPLAY(i915)) {\n\t\tfor_each_pipe(i915, pipe) {\n\t\t\tret = intel_crtc_init(i915, pipe);\n\t\t\tif (ret) {\n\t\t\t\tintel_mode_config_cleanup(i915);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tintel_plane_possible_crtcs_init(i915);\n\tintel_shared_dpll_init(dev);\n\tintel_update_fdi_pll_freq(i915);\n\n\tintel_update_czclk(i915);\n\tintel_modeset_init_hw(i915);\n\n\tintel_hdcp_component_init(i915);\n\n\tif (i915->max_cdclk_freq == 0)\n\t\tintel_update_max_cdclk(i915);\n\n\t/*\n\t * If the platform has HTI, we need to find out whether it has reserved\n\t * any display resources before we create our display outputs.\n\t */\n\tif (INTEL_INFO(i915)->display.has_hti)\n\t\ti915->hti_state = intel_de_read(i915, HDPORT_STATE);\n\n\t/* Just disable it once at startup */\n\tintel_vga_disable(i915);\n\tintel_setup_outputs(i915);\n\n\tdrm_modeset_lock_all(dev);\n\tintel_modeset_setup_hw_state(dev, dev->mode_config.acquire_ctx);\n\tdrm_modeset_unlock_all(dev);\n\n\tfor_each_intel_crtc(dev, crtc) {\n\t\tstruct intel_initial_plane_config plane_config = {};\n\n\t\tif (!crtc->active)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Note that reserving the BIOS fb up front prevents us\n\t\t * from stuffing other stolen allocations like the ring\n\t\t * on top.  This prevents some ugliness at boot time, and\n\t\t * can even allow for smooth boot transitions if the BIOS\n\t\t * fb is large enough for the active pipe configuration.\n\t\t */\n\t\ti915->display.get_initial_plane_config(crtc, &plane_config);\n\n\t\t/*\n\t\t * If the fb is shared between multiple heads, we'll\n\t\t * just get the first one.\n\t\t */\n\t\tintel_find_initial_plane_obj(crtc, &plane_config);\n\n\t\tplane_config_fini(&plane_config);\n\t}\n\n\t/*\n\t * Make sure hardware watermarks really match the state we read out.\n\t * Note that we need to do this after reconstructing the BIOS fb's\n\t * since the watermark calculation done here will use pstate->fb.\n\t */\n\tif (!HAS_GMCH(i915))\n\t\tsanitize_watermarks(i915);\n\n\t/*\n\t * Force all active planes to recompute their states. So that on\n\t * mode_setcrtc after probe, all the intel_plane_state variables\n\t * are already calculated and there is no assert_plane warnings\n\t * during bootup.\n\t */\n\tret = intel_initial_commit(dev);\n\tif (ret)\n\t\tdrm_dbg_kms(&i915->drm, \"Initial commit in probe failed.\\n\");\n\n\treturn 0;\n}\n\n/* part #3: call after gem init */\nint intel_modeset_init(struct drm_i915_private *i915)\n{\n\tint ret;\n\n\tintel_overlay_setup(i915);\n\n\tif (!HAS_DISPLAY(i915))\n\t\treturn 0;\n\n\tret = intel_fbdev_init(&i915->drm);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Only enable hotplug handling once the fbdev is fully set up. */\n\tintel_hpd_init(i915);\n\n\tintel_init_ipc(i915);\n\n\tintel_psr_set_force_mode_changed(i915->psr.dp);\n\n\treturn 0;\n}\n\nvoid i830_enable_pipe(struct drm_i915_private *dev_priv, enum pipe pipe)\n{\n\tstruct intel_crtc *crtc = intel_get_crtc_for_pipe(dev_priv, pipe);\n\t/* 640x480@60Hz, ~25175 kHz */\n\tstruct dpll clock = {\n\t\t.m1 = 18,\n\t\t.m2 = 7,\n\t\t.p1 = 13,\n\t\t.p2 = 4,\n\t\t.n = 2,\n\t};\n\tu32 dpll, fp;\n\tint i;\n\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    i9xx_calc_dpll_params(48000, &clock) != 25154);\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"enabling pipe %c due to force quirk (vco=%d dot=%d)\\n\",\n\t\t    pipe_name(pipe), clock.vco, clock.dot);\n\n\tfp = i9xx_dpll_compute_fp(&clock);\n\tdpll = DPLL_DVO_2X_MODE |\n\t\tDPLL_VGA_MODE_DIS |\n\t\t((clock.p1 - 2) << DPLL_FPA01_P1_POST_DIV_SHIFT) |\n\t\tPLL_P2_DIVIDE_BY_4 |\n\t\tPLL_REF_INPUT_DREFCLK |\n\t\tDPLL_VCO_ENABLE;\n\n\tintel_de_write(dev_priv, FP0(pipe), fp);\n\tintel_de_write(dev_priv, FP1(pipe), fp);\n\n\tintel_de_write(dev_priv, HTOTAL(pipe), (640 - 1) | ((800 - 1) << 16));\n\tintel_de_write(dev_priv, HBLANK(pipe), (640 - 1) | ((800 - 1) << 16));\n\tintel_de_write(dev_priv, HSYNC(pipe), (656 - 1) | ((752 - 1) << 16));\n\tintel_de_write(dev_priv, VTOTAL(pipe), (480 - 1) | ((525 - 1) << 16));\n\tintel_de_write(dev_priv, VBLANK(pipe), (480 - 1) | ((525 - 1) << 16));\n\tintel_de_write(dev_priv, VSYNC(pipe), (490 - 1) | ((492 - 1) << 16));\n\tintel_de_write(dev_priv, PIPESRC(pipe), ((640 - 1) << 16) | (480 - 1));\n\n\t/*\n\t * Apparently we need to have VGA mode enabled prior to changing\n\t * the P1/P2 dividers. Otherwise the DPLL will keep using the old\n\t * dividers, even though the register value does change.\n\t */\n\tintel_de_write(dev_priv, DPLL(pipe), dpll & ~DPLL_VGA_MODE_DIS);\n\tintel_de_write(dev_priv, DPLL(pipe), dpll);\n\n\t/* Wait for the clocks to stabilize. */\n\tintel_de_posting_read(dev_priv, DPLL(pipe));\n\tudelay(150);\n\n\t/* The pixel multiplier can only be updated once the\n\t * DPLL is enabled and the clocks are stable.\n\t *\n\t * So write it again.\n\t */\n\tintel_de_write(dev_priv, DPLL(pipe), dpll);\n\n\t/* We do this three times for luck */\n\tfor (i = 0; i < 3 ; i++) {\n\t\tintel_de_write(dev_priv, DPLL(pipe), dpll);\n\t\tintel_de_posting_read(dev_priv, DPLL(pipe));\n\t\tudelay(150); /* wait for warmup */\n\t}\n\n\tintel_de_write(dev_priv, PIPECONF(pipe),\n\t\t       PIPECONF_ENABLE | PIPECONF_PROGRESSIVE);\n\tintel_de_posting_read(dev_priv, PIPECONF(pipe));\n\n\tintel_wait_for_pipe_scanline_moving(crtc);\n}\n\nvoid i830_disable_pipe(struct drm_i915_private *dev_priv, enum pipe pipe)\n{\n\tstruct intel_crtc *crtc = intel_get_crtc_for_pipe(dev_priv, pipe);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"disabling pipe %c due to force quirk\\n\",\n\t\t    pipe_name(pipe));\n\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_de_read(dev_priv, DSPCNTR(PLANE_A)) &\n\t\t    DISPLAY_PLANE_ENABLE);\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_de_read(dev_priv, DSPCNTR(PLANE_B)) &\n\t\t    DISPLAY_PLANE_ENABLE);\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_de_read(dev_priv, DSPCNTR(PLANE_C)) &\n\t\t    DISPLAY_PLANE_ENABLE);\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_de_read(dev_priv, CURCNTR(PIPE_A)) & MCURSOR_MODE);\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_de_read(dev_priv, CURCNTR(PIPE_B)) & MCURSOR_MODE);\n\n\tintel_de_write(dev_priv, PIPECONF(pipe), 0);\n\tintel_de_posting_read(dev_priv, PIPECONF(pipe));\n\n\tintel_wait_for_pipe_scanline_stopped(crtc);\n\n\tintel_de_write(dev_priv, DPLL(pipe), DPLL_VGA_MODE_DIS);\n\tintel_de_posting_read(dev_priv, DPLL(pipe));\n}\n\nstatic void\nintel_sanitize_plane_mapping(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_crtc *crtc;\n\n\tif (INTEL_GEN(dev_priv) >= 4)\n\t\treturn;\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tstruct intel_plane *plane =\n\t\t\tto_intel_plane(crtc->base.primary);\n\t\tstruct intel_crtc *plane_crtc;\n\t\tenum pipe pipe;\n\n\t\tif (!plane->get_hw_state(plane, &pipe))\n\t\t\tcontinue;\n\n\t\tif (pipe == crtc->pipe)\n\t\t\tcontinue;\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[PLANE:%d:%s] attached to the wrong pipe, disabling plane\\n\",\n\t\t\t    plane->base.base.id, plane->base.name);\n\n\t\tplane_crtc = intel_get_crtc_for_pipe(dev_priv, pipe);\n\t\tintel_plane_disable_noatomic(plane_crtc, plane);\n\t}\n}\n\nstatic bool intel_crtc_has_encoders(struct intel_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct intel_encoder *encoder;\n\n\tfor_each_encoder_on_crtc(dev, &crtc->base, encoder)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct intel_connector *intel_encoder_find_connector(struct intel_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct intel_connector *connector;\n\n\tfor_each_connector_on_encoder(dev, &encoder->base, connector)\n\t\treturn connector;\n\n\treturn NULL;\n}\n\nstatic bool has_pch_trancoder(struct drm_i915_private *dev_priv,\n\t\t\t      enum pipe pch_transcoder)\n{\n\treturn HAS_PCH_IBX(dev_priv) || HAS_PCH_CPT(dev_priv) ||\n\t\t(HAS_PCH_LPT_H(dev_priv) && pch_transcoder == PIPE_A);\n}\n\nstatic void intel_sanitize_frame_start_delay(const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\tenum transcoder cpu_transcoder = crtc_state->cpu_transcoder;\n\n\tif (INTEL_GEN(dev_priv) >= 9 ||\n\t    IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv)) {\n\t\ti915_reg_t reg = CHICKEN_TRANS(cpu_transcoder);\n\t\tu32 val;\n\n\t\tif (transcoder_is_dsi(cpu_transcoder))\n\t\t\treturn;\n\n\t\tval = intel_de_read(dev_priv, reg);\n\t\tval &= ~HSW_FRAME_START_DELAY_MASK;\n\t\tval |= HSW_FRAME_START_DELAY(0);\n\t\tintel_de_write(dev_priv, reg, val);\n\t} else {\n\t\ti915_reg_t reg = PIPECONF(cpu_transcoder);\n\t\tu32 val;\n\n\t\tval = intel_de_read(dev_priv, reg);\n\t\tval &= ~PIPECONF_FRAME_START_DELAY_MASK;\n\t\tval |= PIPECONF_FRAME_START_DELAY(0);\n\t\tintel_de_write(dev_priv, reg, val);\n\t}\n\n\tif (!crtc_state->has_pch_encoder)\n\t\treturn;\n\n\tif (HAS_PCH_IBX(dev_priv)) {\n\t\ti915_reg_t reg = PCH_TRANSCONF(crtc->pipe);\n\t\tu32 val;\n\n\t\tval = intel_de_read(dev_priv, reg);\n\t\tval &= ~TRANS_FRAME_START_DELAY_MASK;\n\t\tval |= TRANS_FRAME_START_DELAY(0);\n\t\tintel_de_write(dev_priv, reg, val);\n\t} else {\n\t\tenum pipe pch_transcoder = intel_crtc_pch_transcoder(crtc);\n\t\ti915_reg_t reg = TRANS_CHICKEN2(pch_transcoder);\n\t\tu32 val;\n\n\t\tval = intel_de_read(dev_priv, reg);\n\t\tval &= ~TRANS_CHICKEN2_FRAME_START_DELAY_MASK;\n\t\tval |= TRANS_CHICKEN2_FRAME_START_DELAY(0);\n\t\tintel_de_write(dev_priv, reg, val);\n\t}\n}\n\nstatic void intel_sanitize_crtc(struct intel_crtc *crtc,\n\t\t\t\tstruct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_device *dev = crtc->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_crtc_state *crtc_state = to_intel_crtc_state(crtc->base.state);\n\n\tif (crtc_state->hw.active) {\n\t\tstruct intel_plane *plane;\n\n\t\t/* Clear any frame start delays used for debugging left by the BIOS */\n\t\tintel_sanitize_frame_start_delay(crtc_state);\n\n\t\t/* Disable everything but the primary plane */\n\t\tfor_each_intel_plane_on_crtc(dev, crtc, plane) {\n\t\t\tconst struct intel_plane_state *plane_state =\n\t\t\t\tto_intel_plane_state(plane->base.state);\n\n\t\t\tif (plane_state->uapi.visible &&\n\t\t\t    plane->base.type != DRM_PLANE_TYPE_PRIMARY)\n\t\t\t\tintel_plane_disable_noatomic(crtc, plane);\n\t\t}\n\n\t\t/*\n\t\t * Disable any background color set by the BIOS, but enable the\n\t\t * gamma and CSC to match how we program our planes.\n\t\t */\n\t\tif (INTEL_GEN(dev_priv) >= 9)\n\t\t\tintel_de_write(dev_priv, SKL_BOTTOM_COLOR(crtc->pipe),\n\t\t\t\t       SKL_BOTTOM_COLOR_GAMMA_ENABLE | SKL_BOTTOM_COLOR_CSC_ENABLE);\n\t}\n\n\t/* Adjust the state of the output pipe according to whether we\n\t * have active connectors/encoders. */\n\tif (crtc_state->hw.active && !intel_crtc_has_encoders(crtc))\n\t\tintel_crtc_disable_noatomic(crtc, ctx);\n\n\tif (crtc_state->hw.active || HAS_GMCH(dev_priv)) {\n\t\t/*\n\t\t * We start out with underrun reporting disabled to avoid races.\n\t\t * For correct bookkeeping mark this on active crtcs.\n\t\t *\n\t\t * Also on gmch platforms we dont have any hardware bits to\n\t\t * disable the underrun reporting. Which means we need to start\n\t\t * out with underrun reporting disabled also on inactive pipes,\n\t\t * since otherwise we'll complain about the garbage we read when\n\t\t * e.g. coming up after runtime pm.\n\t\t *\n\t\t * No protection against concurrent access is required - at\n\t\t * worst a fifo underrun happens which also sets this to false.\n\t\t */\n\t\tcrtc->cpu_fifo_underrun_disabled = true;\n\t\t/*\n\t\t * We track the PCH trancoder underrun reporting state\n\t\t * within the crtc. With crtc for pipe A housing the underrun\n\t\t * reporting state for PCH transcoder A, crtc for pipe B housing\n\t\t * it for PCH transcoder B, etc. LPT-H has only PCH transcoder A,\n\t\t * and marking underrun reporting as disabled for the non-existing\n\t\t * PCH transcoders B and C would prevent enabling the south\n\t\t * error interrupt (see cpt_can_enable_serr_int()).\n\t\t */\n\t\tif (has_pch_trancoder(dev_priv, crtc->pipe))\n\t\t\tcrtc->pch_fifo_underrun_disabled = true;\n\t}\n}\n\nstatic bool has_bogus_dpll_config(const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);\n\n\t/*\n\t * Some SNB BIOSen (eg. ASUS K53SV) are known to misprogram\n\t * the hardware when a high res displays plugged in. DPLL P\n\t * divider is zero, and the pipe timings are bonkers. We'll\n\t * try to disable everything in that case.\n\t *\n\t * FIXME would be nice to be able to sanitize this state\n\t * without several WARNs, but for now let's take the easy\n\t * road.\n\t */\n\treturn IS_GEN(dev_priv, 6) &&\n\t\tcrtc_state->hw.active &&\n\t\tcrtc_state->shared_dpll &&\n\t\tcrtc_state->port_clock == 0;\n}\n\nstatic void intel_sanitize_encoder(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_connector *connector;\n\tstruct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);\n\tstruct intel_crtc_state *crtc_state = crtc ?\n\t\tto_intel_crtc_state(crtc->base.state) : NULL;\n\n\t/* We need to check both for a crtc link (meaning that the\n\t * encoder is active and trying to read from a pipe) and the\n\t * pipe itself being active. */\n\tbool has_active_crtc = crtc_state &&\n\t\tcrtc_state->hw.active;\n\n\tif (crtc_state && has_bogus_dpll_config(crtc_state)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"BIOS has misprogrammed the hardware. Disabling pipe %c\\n\",\n\t\t\t    pipe_name(crtc->pipe));\n\t\thas_active_crtc = false;\n\t}\n\n\tconnector = intel_encoder_find_connector(encoder);\n\tif (connector && !has_active_crtc) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[ENCODER:%d:%s] has active connectors but no active pipe!\\n\",\n\t\t\t    encoder->base.base.id,\n\t\t\t    encoder->base.name);\n\n\t\t/* Connector is active, but has no active pipe. This is\n\t\t * fallout from our resume register restoring. Disable\n\t\t * the encoder manually again. */\n\t\tif (crtc_state) {\n\t\t\tstruct drm_encoder *best_encoder;\n\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"[ENCODER:%d:%s] manually disabled\\n\",\n\t\t\t\t    encoder->base.base.id,\n\t\t\t\t    encoder->base.name);\n\n\t\t\t/* avoid oopsing in case the hooks consult best_encoder */\n\t\t\tbest_encoder = connector->base.state->best_encoder;\n\t\t\tconnector->base.state->best_encoder = &encoder->base;\n\n\t\t\t/* FIXME NULL atomic state passed! */\n\t\t\tif (encoder->disable)\n\t\t\t\tencoder->disable(NULL, encoder, crtc_state,\n\t\t\t\t\t\t connector->base.state);\n\t\t\tif (encoder->post_disable)\n\t\t\t\tencoder->post_disable(NULL, encoder, crtc_state,\n\t\t\t\t\t\t      connector->base.state);\n\n\t\t\tconnector->base.state->best_encoder = best_encoder;\n\t\t}\n\t\tencoder->base.crtc = NULL;\n\n\t\t/* Inconsistent output/port/pipe state happens presumably due to\n\t\t * a bug in one of the get_hw_state functions. Or someplace else\n\t\t * in our code, like the register restore mess on resume. Clamp\n\t\t * things to off as a safer default. */\n\n\t\tconnector->base.dpms = DRM_MODE_DPMS_OFF;\n\t\tconnector->base.encoder = NULL;\n\t}\n\n\t/* notify opregion of the sanitized encoder state */\n\tintel_opregion_notify_encoder(encoder, connector && has_active_crtc);\n\n\tif (INTEL_GEN(dev_priv) >= 11)\n\t\ticl_sanitize_encoder_pll_mapping(encoder);\n}\n\n/* FIXME read out full plane state for all planes */\nstatic void readout_plane_state(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_plane *plane;\n\tstruct intel_crtc *crtc;\n\n\tfor_each_intel_plane(&dev_priv->drm, plane) {\n\t\tstruct intel_plane_state *plane_state =\n\t\t\tto_intel_plane_state(plane->base.state);\n\t\tstruct intel_crtc_state *crtc_state;\n\t\tenum pipe pipe = PIPE_A;\n\t\tbool visible;\n\n\t\tvisible = plane->get_hw_state(plane, &pipe);\n\n\t\tcrtc = intel_get_crtc_for_pipe(dev_priv, pipe);\n\t\tcrtc_state = to_intel_crtc_state(crtc->base.state);\n\n\t\tintel_set_plane_visible(crtc_state, plane_state, visible);\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[PLANE:%d:%s] hw state readout: %s, pipe %c\\n\",\n\t\t\t    plane->base.base.id, plane->base.name,\n\t\t\t    enableddisabled(visible), pipe_name(pipe));\n\t}\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\n\t\tfixup_active_planes(crtc_state);\n\t}\n}\n\nstatic void intel_modeset_readout_hw_state(struct drm_device *dev)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_cdclk_state *cdclk_state =\n\t\tto_intel_cdclk_state(dev_priv->cdclk.obj.state);\n\tstruct intel_dbuf_state *dbuf_state =\n\t\tto_intel_dbuf_state(dev_priv->dbuf.obj.state);\n\tenum pipe pipe;\n\tstruct intel_crtc *crtc;\n\tstruct intel_encoder *encoder;\n\tstruct intel_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tu8 active_pipes = 0;\n\n\tfor_each_intel_crtc(dev, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\n\t\t__drm_atomic_helper_crtc_destroy_state(&crtc_state->uapi);\n\t\tintel_crtc_free_hw_state(crtc_state);\n\t\tintel_crtc_state_reset(crtc_state, crtc);\n\n\t\tcrtc_state->hw.active = crtc_state->hw.enable =\n\t\t\tdev_priv->display.get_pipe_config(crtc, crtc_state);\n\n\t\tcrtc->base.enabled = crtc_state->hw.enable;\n\t\tcrtc->active = crtc_state->hw.active;\n\n\t\tif (crtc_state->hw.active)\n\t\t\tactive_pipes |= BIT(crtc->pipe);\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[CRTC:%d:%s] hw state readout: %s\\n\",\n\t\t\t    crtc->base.base.id, crtc->base.name,\n\t\t\t    enableddisabled(crtc_state->hw.active));\n\t}\n\n\tdev_priv->active_pipes = cdclk_state->active_pipes =\n\t\tdbuf_state->active_pipes = active_pipes;\n\n\treadout_plane_state(dev_priv);\n\n\tintel_dpll_readout_hw_state(dev_priv);\n\n\tfor_each_intel_encoder(dev, encoder) {\n\t\tpipe = 0;\n\n\t\tif (encoder->get_hw_state(encoder, &pipe)) {\n\t\t\tstruct intel_crtc_state *crtc_state;\n\n\t\t\tcrtc = intel_get_crtc_for_pipe(dev_priv, pipe);\n\t\t\tcrtc_state = to_intel_crtc_state(crtc->base.state);\n\n\t\t\tencoder->base.crtc = &crtc->base;\n\t\t\tencoder->get_config(encoder, crtc_state);\n\t\t} else {\n\t\t\tencoder->base.crtc = NULL;\n\t\t}\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[ENCODER:%d:%s] hw state readout: %s, pipe %c\\n\",\n\t\t\t    encoder->base.base.id, encoder->base.name,\n\t\t\t    enableddisabled(encoder->base.crtc),\n\t\t\t    pipe_name(pipe));\n\t}\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tif (connector->get_hw_state(connector)) {\n\t\t\tstruct intel_crtc_state *crtc_state;\n\t\t\tstruct intel_crtc *crtc;\n\n\t\t\tconnector->base.dpms = DRM_MODE_DPMS_ON;\n\n\t\t\tencoder = intel_attached_encoder(connector);\n\t\t\tconnector->base.encoder = &encoder->base;\n\n\t\t\tcrtc = to_intel_crtc(encoder->base.crtc);\n\t\t\tcrtc_state = crtc ? to_intel_crtc_state(crtc->base.state) : NULL;\n\n\t\t\tif (crtc_state && crtc_state->hw.active) {\n\t\t\t\t/*\n\t\t\t\t * This has to be done during hardware readout\n\t\t\t\t * because anything calling .crtc_disable may\n\t\t\t\t * rely on the connector_mask being accurate.\n\t\t\t\t */\n\t\t\t\tcrtc_state->uapi.connector_mask |=\n\t\t\t\t\tdrm_connector_mask(&connector->base);\n\t\t\t\tcrtc_state->uapi.encoder_mask |=\n\t\t\t\t\tdrm_encoder_mask(&encoder->base);\n\t\t\t}\n\t\t} else {\n\t\t\tconnector->base.dpms = DRM_MODE_DPMS_OFF;\n\t\t\tconnector->base.encoder = NULL;\n\t\t}\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[CONNECTOR:%d:%s] hw state readout: %s\\n\",\n\t\t\t    connector->base.base.id, connector->base.name,\n\t\t\t    enableddisabled(connector->base.encoder));\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tfor_each_intel_crtc(dev, crtc) {\n\t\tstruct intel_bw_state *bw_state =\n\t\t\tto_intel_bw_state(dev_priv->bw_obj.state);\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\t\tstruct intel_plane *plane;\n\t\tint min_cdclk = 0;\n\n\t\tif (crtc_state->hw.active) {\n\t\t\tstruct drm_display_mode *mode = &crtc_state->hw.mode;\n\n\t\t\tintel_mode_from_pipe_config(&crtc_state->hw.adjusted_mode,\n\t\t\t\t\t\t    crtc_state);\n\n\t\t\t*mode = crtc_state->hw.adjusted_mode;\n\t\t\tmode->hdisplay = crtc_state->pipe_src_w;\n\t\t\tmode->vdisplay = crtc_state->pipe_src_h;\n\n\t\t\t/*\n\t\t\t * The initial mode needs to be set in order to keep\n\t\t\t * the atomic core happy. It wants a valid mode if the\n\t\t\t * crtc's enabled, so we do the above call.\n\t\t\t *\n\t\t\t * But we don't set all the derived state fully, hence\n\t\t\t * set a flag to indicate that a full recalculation is\n\t\t\t * needed on the next commit.\n\t\t\t */\n\t\t\tcrtc_state->inherited = true;\n\n\t\t\tintel_crtc_compute_pixel_rate(crtc_state);\n\n\t\t\tintel_crtc_update_active_timings(crtc_state);\n\n\t\t\tintel_crtc_copy_hw_to_uapi_state(crtc_state);\n\t\t}\n\n\t\tfor_each_intel_plane_on_crtc(&dev_priv->drm, crtc, plane) {\n\t\t\tconst struct intel_plane_state *plane_state =\n\t\t\t\tto_intel_plane_state(plane->base.state);\n\n\t\t\t/*\n\t\t\t * FIXME don't have the fb yet, so can't\n\t\t\t * use intel_plane_data_rate() :(\n\t\t\t */\n\t\t\tif (plane_state->uapi.visible)\n\t\t\t\tcrtc_state->data_rate[plane->id] =\n\t\t\t\t\t4 * crtc_state->pixel_rate;\n\t\t\t/*\n\t\t\t * FIXME don't have the fb yet, so can't\n\t\t\t * use plane->min_cdclk() :(\n\t\t\t */\n\t\t\tif (plane_state->uapi.visible && plane->min_cdclk) {\n\t\t\t\tif (crtc_state->double_wide ||\n\t\t\t\t    INTEL_GEN(dev_priv) >= 10 || IS_GEMINILAKE(dev_priv))\n\t\t\t\t\tcrtc_state->min_cdclk[plane->id] =\n\t\t\t\t\t\tDIV_ROUND_UP(crtc_state->pixel_rate, 2);\n\t\t\t\telse\n\t\t\t\t\tcrtc_state->min_cdclk[plane->id] =\n\t\t\t\t\t\tcrtc_state->pixel_rate;\n\t\t\t}\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"[PLANE:%d:%s] min_cdclk %d kHz\\n\",\n\t\t\t\t    plane->base.base.id, plane->base.name,\n\t\t\t\t    crtc_state->min_cdclk[plane->id]);\n\t\t}\n\n\t\tif (crtc_state->hw.active) {\n\t\t\tmin_cdclk = intel_crtc_compute_min_cdclk(crtc_state);\n\t\t\tif (drm_WARN_ON(dev, min_cdclk < 0))\n\t\t\t\tmin_cdclk = 0;\n\t\t}\n\n\t\tcdclk_state->min_cdclk[crtc->pipe] = min_cdclk;\n\t\tcdclk_state->min_voltage_level[crtc->pipe] =\n\t\t\tcrtc_state->min_voltage_level;\n\n\t\tintel_bw_crtc_update(bw_state, crtc_state);\n\n\t\tintel_pipe_config_sanity_check(dev_priv, crtc_state);\n\t}\n}\n\nstatic void\nget_encoder_power_domains(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_encoder *encoder;\n\n\tfor_each_intel_encoder(&dev_priv->drm, encoder) {\n\t\tstruct intel_crtc_state *crtc_state;\n\n\t\tif (!encoder->get_power_domains)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * MST-primary and inactive encoders don't have a crtc state\n\t\t * and neither of these require any power domain references.\n\t\t */\n\t\tif (!encoder->base.crtc)\n\t\t\tcontinue;\n\n\t\tcrtc_state = to_intel_crtc_state(encoder->base.crtc->state);\n\t\tencoder->get_power_domains(encoder, crtc_state);\n\t}\n}\n\nstatic void intel_early_display_was(struct drm_i915_private *dev_priv)\n{\n\t/*\n\t * Display WA #1185 WaDisableDARBFClkGating:cnl,glk,icl,ehl,tgl\n\t * Also known as Wa_14010480278.\n\t */\n\tif (IS_GEN_RANGE(dev_priv, 10, 12) || IS_GEMINILAKE(dev_priv))\n\t\tintel_de_write(dev_priv, GEN9_CLKGATE_DIS_0,\n\t\t\t       intel_de_read(dev_priv, GEN9_CLKGATE_DIS_0) | DARBF_GATING_DIS);\n\n\tif (IS_HASWELL(dev_priv)) {\n\t\t/*\n\t\t * WaRsPkgCStateDisplayPMReq:hsw\n\t\t * System hang if this isn't done before disabling all planes!\n\t\t */\n\t\tintel_de_write(dev_priv, CHICKEN_PAR1_1,\n\t\t\t       intel_de_read(dev_priv, CHICKEN_PAR1_1) | FORCE_ARB_IDLE_PLANES);\n\t}\n}\n\nstatic void ibx_sanitize_pch_hdmi_port(struct drm_i915_private *dev_priv,\n\t\t\t\t       enum port port, i915_reg_t hdmi_reg)\n{\n\tu32 val = intel_de_read(dev_priv, hdmi_reg);\n\n\tif (val & SDVO_ENABLE ||\n\t    (val & SDVO_PIPE_SEL_MASK) == SDVO_PIPE_SEL(PIPE_A))\n\t\treturn;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Sanitizing transcoder select for HDMI %c\\n\",\n\t\t    port_name(port));\n\n\tval &= ~SDVO_PIPE_SEL_MASK;\n\tval |= SDVO_PIPE_SEL(PIPE_A);\n\n\tintel_de_write(dev_priv, hdmi_reg, val);\n}\n\nstatic void ibx_sanitize_pch_dp_port(struct drm_i915_private *dev_priv,\n\t\t\t\t     enum port port, i915_reg_t dp_reg)\n{\n\tu32 val = intel_de_read(dev_priv, dp_reg);\n\n\tif (val & DP_PORT_EN ||\n\t    (val & DP_PIPE_SEL_MASK) == DP_PIPE_SEL(PIPE_A))\n\t\treturn;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Sanitizing transcoder select for DP %c\\n\",\n\t\t    port_name(port));\n\n\tval &= ~DP_PIPE_SEL_MASK;\n\tval |= DP_PIPE_SEL(PIPE_A);\n\n\tintel_de_write(dev_priv, dp_reg, val);\n}\n\nstatic void ibx_sanitize_pch_ports(struct drm_i915_private *dev_priv)\n{\n\t/*\n\t * The BIOS may select transcoder B on some of the PCH\n\t * ports even it doesn't enable the port. This would trip\n\t * assert_pch_dp_disabled() and assert_pch_hdmi_disabled().\n\t * Sanitize the transcoder select bits to prevent that. We\n\t * assume that the BIOS never actually enabled the port,\n\t * because if it did we'd actually have to toggle the port\n\t * on and back off to make the transcoder A select stick\n\t * (see. intel_dp_link_down(), intel_disable_hdmi(),\n\t * intel_disable_sdvo()).\n\t */\n\tibx_sanitize_pch_dp_port(dev_priv, PORT_B, PCH_DP_B);\n\tibx_sanitize_pch_dp_port(dev_priv, PORT_C, PCH_DP_C);\n\tibx_sanitize_pch_dp_port(dev_priv, PORT_D, PCH_DP_D);\n\n\t/* PCH SDVOB multiplex with HDMIB */\n\tibx_sanitize_pch_hdmi_port(dev_priv, PORT_B, PCH_HDMIB);\n\tibx_sanitize_pch_hdmi_port(dev_priv, PORT_C, PCH_HDMIC);\n\tibx_sanitize_pch_hdmi_port(dev_priv, PORT_D, PCH_HDMID);\n}\n\n/* Scan out the current hw modeset state,\n * and sanitizes it to the current state\n */\nstatic void\nintel_modeset_setup_hw_state(struct drm_device *dev,\n\t\t\t     struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_encoder *encoder;\n\tstruct intel_crtc *crtc;\n\tintel_wakeref_t wakeref;\n\n\twakeref = intel_display_power_get(dev_priv, POWER_DOMAIN_INIT);\n\n\tintel_early_display_was(dev_priv);\n\tintel_modeset_readout_hw_state(dev);\n\n\t/* HW state is read out, now we need to sanitize this mess. */\n\n\t/* Sanitize the TypeC port mode upfront, encoders depend on this */\n\tfor_each_intel_encoder(dev, encoder) {\n\t\tenum phy phy = intel_port_to_phy(dev_priv, encoder->port);\n\n\t\t/* We need to sanitize only the MST primary port. */\n\t\tif (encoder->type != INTEL_OUTPUT_DP_MST &&\n\t\t    intel_phy_is_tc(dev_priv, phy))\n\t\t\tintel_tc_port_sanitize(enc_to_dig_port(encoder));\n\t}\n\n\tget_encoder_power_domains(dev_priv);\n\n\tif (HAS_PCH_IBX(dev_priv))\n\t\tibx_sanitize_pch_ports(dev_priv);\n\n\t/*\n\t * intel_sanitize_plane_mapping() may need to do vblank\n\t * waits, so we need vblank interrupts restored beforehand.\n\t */\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\n\t\tdrm_crtc_vblank_reset(&crtc->base);\n\n\t\tif (crtc_state->hw.active)\n\t\t\tintel_crtc_vblank_on(crtc_state);\n\t}\n\n\tintel_sanitize_plane_mapping(dev_priv);\n\n\tfor_each_intel_encoder(dev, encoder)\n\t\tintel_sanitize_encoder(encoder);\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\n\t\tintel_sanitize_crtc(crtc, ctx);\n\t\tintel_dump_pipe_config(crtc_state, NULL, \"[setup_hw_state]\");\n\t}\n\n\tintel_modeset_update_connector_atomic_state(dev);\n\n\tintel_dpll_sanitize_state(dev_priv);\n\n\tif (IS_G4X(dev_priv)) {\n\t\tg4x_wm_get_hw_state(dev_priv);\n\t\tg4x_wm_sanitize(dev_priv);\n\t} else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\tvlv_wm_get_hw_state(dev_priv);\n\t\tvlv_wm_sanitize(dev_priv);\n\t} else if (INTEL_GEN(dev_priv) >= 9) {\n\t\tskl_wm_get_hw_state(dev_priv);\n\t} else if (HAS_PCH_SPLIT(dev_priv)) {\n\t\tilk_wm_get_hw_state(dev_priv);\n\t}\n\n\tfor_each_intel_crtc(dev, crtc) {\n\t\tstruct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\t\tu64 put_domains;\n\n\t\tput_domains = modeset_get_crtc_power_domains(crtc_state);\n\t\tif (drm_WARN_ON(dev, put_domains))\n\t\t\tmodeset_put_power_domains(dev_priv, put_domains);\n\t}\n\n\tintel_display_power_put(dev_priv, POWER_DOMAIN_INIT, wakeref);\n}\n\nvoid intel_display_resume(struct drm_device *dev)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct drm_atomic_state *state = dev_priv->modeset_restore_state;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint ret;\n\n\tdev_priv->modeset_restore_state = NULL;\n\tif (state)\n\t\tstate->acquire_ctx = &ctx;\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\n\twhile (1) {\n\t\tret = drm_modeset_lock_all_ctx(dev, &ctx);\n\t\tif (ret != -EDEADLK)\n\t\t\tbreak;\n\n\t\tdrm_modeset_backoff(&ctx);\n\t}\n\n\tif (!ret)\n\t\tret = __intel_display_resume(dev, state, &ctx);\n\n\tintel_enable_ipc(dev_priv);\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\n\tif (ret)\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Restoring old state failed with %i\\n\", ret);\n\tif (state)\n\t\tdrm_atomic_state_put(state);\n}\n\nstatic void intel_hpd_poll_fini(struct drm_i915_private *i915)\n{\n\tstruct intel_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\n\t/* Kill all the work that may have been queued by hpd. */\n\tdrm_connector_list_iter_begin(&i915->drm, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tif (connector->modeset_retry_work.func)\n\t\t\tcancel_work_sync(&connector->modeset_retry_work);\n\t\tif (connector->hdcp.shim) {\n\t\t\tcancel_delayed_work_sync(&connector->hdcp.check_work);\n\t\t\tcancel_work_sync(&connector->hdcp.prop_work);\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n}\n\n/* part #1: call before irq uninstall */\nvoid intel_modeset_driver_remove(struct drm_i915_private *i915)\n{\n\tflush_workqueue(i915->flip_wq);\n\tflush_workqueue(i915->modeset_wq);\n\n\tflush_work(&i915->atomic_helper.free_work);\n\tdrm_WARN_ON(&i915->drm, !llist_empty(&i915->atomic_helper.free_list));\n}\n\n/* part #2: call after irq uninstall */\nvoid intel_modeset_driver_remove_noirq(struct drm_i915_private *i915)\n{\n\t/*\n\t * Due to the hpd irq storm handling the hotplug work can re-arm the\n\t * poll handlers. Hence disable polling after hpd handling is shut down.\n\t */\n\tintel_hpd_poll_fini(i915);\n\n\t/*\n\t * MST topology needs to be suspended so we don't have any calls to\n\t * fbdev after it's finalized. MST will be destroyed later as part of\n\t * drm_mode_config_cleanup()\n\t */\n\tintel_dp_mst_suspend(i915);\n\n\t/* poll work can call into fbdev, hence clean that up afterwards */\n\tintel_fbdev_fini(i915);\n\n\tintel_unregister_dsm_handler();\n\n\tintel_fbc_global_disable(i915);\n\n\t/* flush any delayed tasks or pending work */\n\tflush_scheduled_work();\n\n\tintel_hdcp_component_fini(i915);\n\n\tintel_mode_config_cleanup(i915);\n\n\tintel_overlay_cleanup(i915);\n\n\tintel_gmbus_teardown(i915);\n\n\tdestroy_workqueue(i915->flip_wq);\n\tdestroy_workqueue(i915->modeset_wq);\n\n\tintel_fbc_cleanup_cfb(i915);\n}\n\n/* part #3: call after gem init */\nvoid intel_modeset_driver_remove_nogem(struct drm_i915_private *i915)\n{\n\tintel_csr_ucode_fini(i915);\n\n\tintel_power_domains_driver_remove(i915);\n\n\tintel_vga_unregister(i915);\n\n\tintel_bios_driver_remove(i915);\n}\n\n#if IS_ENABLED(CONFIG_DRM_I915_CAPTURE_ERROR)\n\nstruct intel_display_error_state {\n\n\tu32 power_well_driver;\n\n\tstruct intel_cursor_error_state {\n\t\tu32 control;\n\t\tu32 position;\n\t\tu32 base;\n\t\tu32 size;\n\t} cursor[I915_MAX_PIPES];\n\n\tstruct intel_pipe_error_state {\n\t\tbool power_domain_on;\n\t\tu32 source;\n\t\tu32 stat;\n\t} pipe[I915_MAX_PIPES];\n\n\tstruct intel_plane_error_state {\n\t\tu32 control;\n\t\tu32 stride;\n\t\tu32 size;\n\t\tu32 pos;\n\t\tu32 addr;\n\t\tu32 surface;\n\t\tu32 tile_offset;\n\t} plane[I915_MAX_PIPES];\n\n\tstruct intel_transcoder_error_state {\n\t\tbool available;\n\t\tbool power_domain_on;\n\t\tenum transcoder cpu_transcoder;\n\n\t\tu32 conf;\n\n\t\tu32 htotal;\n\t\tu32 hblank;\n\t\tu32 hsync;\n\t\tu32 vtotal;\n\t\tu32 vblank;\n\t\tu32 vsync;\n\t} transcoder[5];\n};\n\nstruct intel_display_error_state *\nintel_display_capture_error_state(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_display_error_state *error;\n\tint transcoders[] = {\n\t\tTRANSCODER_A,\n\t\tTRANSCODER_B,\n\t\tTRANSCODER_C,\n\t\tTRANSCODER_D,\n\t\tTRANSCODER_EDP,\n\t};\n\tint i;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(transcoders) != ARRAY_SIZE(error->transcoder));\n\n\tif (!HAS_DISPLAY(dev_priv))\n\t\treturn NULL;\n\n\terror = kzalloc(sizeof(*error), GFP_ATOMIC);\n\tif (error == NULL)\n\t\treturn NULL;\n\n\tif (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))\n\t\terror->power_well_driver = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t HSW_PWR_WELL_CTL2);\n\n\tfor_each_pipe(dev_priv, i) {\n\t\terror->pipe[i].power_domain_on =\n\t\t\t__intel_display_power_is_enabled(dev_priv,\n\t\t\t\t\t\t\t POWER_DOMAIN_PIPE(i));\n\t\tif (!error->pipe[i].power_domain_on)\n\t\t\tcontinue;\n\n\t\terror->cursor[i].control = intel_de_read(dev_priv, CURCNTR(i));\n\t\terror->cursor[i].position = intel_de_read(dev_priv, CURPOS(i));\n\t\terror->cursor[i].base = intel_de_read(dev_priv, CURBASE(i));\n\n\t\terror->plane[i].control = intel_de_read(dev_priv, DSPCNTR(i));\n\t\terror->plane[i].stride = intel_de_read(dev_priv, DSPSTRIDE(i));\n\t\tif (INTEL_GEN(dev_priv) <= 3) {\n\t\t\terror->plane[i].size = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t     DSPSIZE(i));\n\t\t\terror->plane[i].pos = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t    DSPPOS(i));\n\t\t}\n\t\tif (INTEL_GEN(dev_priv) <= 7 && !IS_HASWELL(dev_priv))\n\t\t\terror->plane[i].addr = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t     DSPADDR(i));\n\t\tif (INTEL_GEN(dev_priv) >= 4) {\n\t\t\terror->plane[i].surface = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t\tDSPSURF(i));\n\t\t\terror->plane[i].tile_offset = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t\t    DSPTILEOFF(i));\n\t\t}\n\n\t\terror->pipe[i].source = intel_de_read(dev_priv, PIPESRC(i));\n\n\t\tif (HAS_GMCH(dev_priv))\n\t\t\terror->pipe[i].stat = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t    PIPESTAT(i));\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(error->transcoder); i++) {\n\t\tenum transcoder cpu_transcoder = transcoders[i];\n\n\t\tif (!HAS_TRANSCODER(dev_priv, cpu_transcoder))\n\t\t\tcontinue;\n\n\t\terror->transcoder[i].available = true;\n\t\terror->transcoder[i].power_domain_on =\n\t\t\t__intel_display_power_is_enabled(dev_priv,\n\t\t\t\tPOWER_DOMAIN_TRANSCODER(cpu_transcoder));\n\t\tif (!error->transcoder[i].power_domain_on)\n\t\t\tcontinue;\n\n\t\terror->transcoder[i].cpu_transcoder = cpu_transcoder;\n\n\t\terror->transcoder[i].conf = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t  PIPECONF(cpu_transcoder));\n\t\terror->transcoder[i].htotal = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t    HTOTAL(cpu_transcoder));\n\t\terror->transcoder[i].hblank = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t    HBLANK(cpu_transcoder));\n\t\terror->transcoder[i].hsync = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t   HSYNC(cpu_transcoder));\n\t\terror->transcoder[i].vtotal = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t    VTOTAL(cpu_transcoder));\n\t\terror->transcoder[i].vblank = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t    VBLANK(cpu_transcoder));\n\t\terror->transcoder[i].vsync = intel_de_read(dev_priv,\n\t\t\t\t\t\t\t   VSYNC(cpu_transcoder));\n\t}\n\n\treturn error;\n}\n\n#define err_printf(e, ...) i915_error_printf(e, __VA_ARGS__)\n\nvoid\nintel_display_print_error_state(struct drm_i915_error_state_buf *m,\n\t\t\t\tstruct intel_display_error_state *error)\n{\n\tstruct drm_i915_private *dev_priv = m->i915;\n\tint i;\n\n\tif (!error)\n\t\treturn;\n\n\terr_printf(m, \"Num Pipes: %d\\n\", INTEL_NUM_PIPES(dev_priv));\n\tif (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))\n\t\terr_printf(m, \"PWR_WELL_CTL2: %08x\\n\",\n\t\t\t   error->power_well_driver);\n\tfor_each_pipe(dev_priv, i) {\n\t\terr_printf(m, \"Pipe [%d]:\\n\", i);\n\t\terr_printf(m, \"  Power: %s\\n\",\n\t\t\t   onoff(error->pipe[i].power_domain_on));\n\t\terr_printf(m, \"  SRC: %08x\\n\", error->pipe[i].source);\n\t\terr_printf(m, \"  STAT: %08x\\n\", error->pipe[i].stat);\n\n\t\terr_printf(m, \"Plane [%d]:\\n\", i);\n\t\terr_printf(m, \"  CNTR: %08x\\n\", error->plane[i].control);\n\t\terr_printf(m, \"  STRIDE: %08x\\n\", error->plane[i].stride);\n\t\tif (INTEL_GEN(dev_priv) <= 3) {\n\t\t\terr_printf(m, \"  SIZE: %08x\\n\", error->plane[i].size);\n\t\t\terr_printf(m, \"  POS: %08x\\n\", error->plane[i].pos);\n\t\t}\n\t\tif (INTEL_GEN(dev_priv) <= 7 && !IS_HASWELL(dev_priv))\n\t\t\terr_printf(m, \"  ADDR: %08x\\n\", error->plane[i].addr);\n\t\tif (INTEL_GEN(dev_priv) >= 4) {\n\t\t\terr_printf(m, \"  SURF: %08x\\n\", error->plane[i].surface);\n\t\t\terr_printf(m, \"  TILEOFF: %08x\\n\", error->plane[i].tile_offset);\n\t\t}\n\n\t\terr_printf(m, \"Cursor [%d]:\\n\", i);\n\t\terr_printf(m, \"  CNTR: %08x\\n\", error->cursor[i].control);\n\t\terr_printf(m, \"  POS: %08x\\n\", error->cursor[i].position);\n\t\terr_printf(m, \"  BASE: %08x\\n\", error->cursor[i].base);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(error->transcoder); i++) {\n\t\tif (!error->transcoder[i].available)\n\t\t\tcontinue;\n\n\t\terr_printf(m, \"CPU transcoder: %s\\n\",\n\t\t\t   transcoder_name(error->transcoder[i].cpu_transcoder));\n\t\terr_printf(m, \"  Power: %s\\n\",\n\t\t\t   onoff(error->transcoder[i].power_domain_on));\n\t\terr_printf(m, \"  CONF: %08x\\n\", error->transcoder[i].conf);\n\t\terr_printf(m, \"  HTOTAL: %08x\\n\", error->transcoder[i].htotal);\n\t\terr_printf(m, \"  HBLANK: %08x\\n\", error->transcoder[i].hblank);\n\t\terr_printf(m, \"  HSYNC: %08x\\n\", error->transcoder[i].hsync);\n\t\terr_printf(m, \"  VTOTAL: %08x\\n\", error->transcoder[i].vtotal);\n\t\terr_printf(m, \"  VBLANK: %08x\\n\", error->transcoder[i].vblank);\n\t\terr_printf(m, \"  VSYNC: %08x\\n\", error->transcoder[i].vsync);\n\t}\n}\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 6225}, "message": "error: we previously assumed 'fb' could be null (see line 6209)"}], "macros": [], "notes": [], "path": "/src/drivers/gpu/drm/i915/display/intel_display.c", "reportHash": "905a23aea048f27983440556e97f1dec", "checkerName": "check_check_deref", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
