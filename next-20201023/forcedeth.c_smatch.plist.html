<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/net/ethernet/nvidia/forcedeth.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * forcedeth: Ethernet driver for NVIDIA nForce media access controllers.\n *\n * Note: This driver is a cleanroom reimplementation based on reverse\n *      engineered documentation written by Carl-Daniel Hailfinger\n *      and Andrew de Quincey.\n *\n * NVIDIA, nForce and other NVIDIA marks are trademarks or registered\n * trademarks of NVIDIA Corporation in the United States and other\n * countries.\n *\n * Copyright (C) 2003,4,5 Manfred Spraul\n * Copyright (C) 2004 Andrew de Quincey (wol support)\n * Copyright (C) 2004 Carl-Daniel Hailfinger (invalid MAC handling, insane\n *\t\tIRQ rate fixes, bigendian fixes, cleanups, verification)\n * Copyright (c) 2004,2005,2006,2007,2008,2009 NVIDIA Corporation\n *\n * Known bugs:\n * We suspect that on some hardware no TX done interrupts are generated.\n * This means recovery from netif_stop_queue only happens if the hw timer\n * interrupt fires (100 times/second, configurable with NVREG_POLL_DEFAULT)\n * and the timer is active in the IRQMask, or if a rx packet arrives by chance.\n * If your hardware reliably generates tx done interrupts, then you can remove\n * DEV_NEED_TIMERIRQ from the driver_data flags.\n * DEV_NEED_TIMERIRQ will not harm you on sane hardware, only generating a few\n * superfluous timer interrupts from the nic.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define FORCEDETH_VERSION\t\t\"0.64\"\n#define DRV_NAME\t\t\t\"forcedeth\"\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/ethtool.h>\n#include <linux/timer.h>\n#include <linux/skbuff.h>\n#include <linux/mii.h>\n#include <linux/random.h>\n#include <linux/if_vlan.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/prefetch.h>\n#include <linux/u64_stats_sync.h>\n#include <linux/io.h>\n\n#include <asm/irq.h>\n\n#define TX_WORK_PER_LOOP  64\n#define RX_WORK_PER_LOOP  64\n\n/*\n * Hardware access:\n */\n\n#define DEV_NEED_TIMERIRQ          0x0000001  /* set the timer irq flag in the irq mask */\n#define DEV_NEED_LINKTIMER         0x0000002  /* poll link settings. Relies on the timer irq */\n#define DEV_HAS_LARGEDESC          0x0000004  /* device supports jumbo frames and needs packet format 2 */\n#define DEV_HAS_HIGH_DMA           0x0000008  /* device supports 64bit dma */\n#define DEV_HAS_CHECKSUM           0x0000010  /* device supports tx and rx checksum offloads */\n#define DEV_HAS_VLAN               0x0000020  /* device supports vlan tagging and striping */\n#define DEV_HAS_MSI                0x0000040  /* device supports MSI */\n#define DEV_HAS_MSI_X              0x0000080  /* device supports MSI-X */\n#define DEV_HAS_POWER_CNTRL        0x0000100  /* device supports power savings */\n#define DEV_HAS_STATISTICS_V1      0x0000200  /* device supports hw statistics version 1 */\n#define DEV_HAS_STATISTICS_V2      0x0000400  /* device supports hw statistics version 2 */\n#define DEV_HAS_STATISTICS_V3      0x0000800  /* device supports hw statistics version 3 */\n#define DEV_HAS_STATISTICS_V12     0x0000600  /* device supports hw statistics version 1 and 2 */\n#define DEV_HAS_STATISTICS_V123    0x0000e00  /* device supports hw statistics version 1, 2, and 3 */\n#define DEV_HAS_TEST_EXTENDED      0x0001000  /* device supports extended diagnostic test */\n#define DEV_HAS_MGMT_UNIT          0x0002000  /* device supports management unit */\n#define DEV_HAS_CORRECT_MACADDR    0x0004000  /* device supports correct mac address order */\n#define DEV_HAS_COLLISION_FIX      0x0008000  /* device supports tx collision fix */\n#define DEV_HAS_PAUSEFRAME_TX_V1   0x0010000  /* device supports tx pause frames version 1 */\n#define DEV_HAS_PAUSEFRAME_TX_V2   0x0020000  /* device supports tx pause frames version 2 */\n#define DEV_HAS_PAUSEFRAME_TX_V3   0x0040000  /* device supports tx pause frames version 3 */\n#define DEV_NEED_TX_LIMIT          0x0080000  /* device needs to limit tx */\n#define DEV_NEED_TX_LIMIT2         0x0180000  /* device needs to limit tx, expect for some revs */\n#define DEV_HAS_GEAR_MODE          0x0200000  /* device supports gear mode */\n#define DEV_NEED_PHY_INIT_FIX      0x0400000  /* device needs specific phy workaround */\n#define DEV_NEED_LOW_POWER_FIX     0x0800000  /* device needs special power up workaround */\n#define DEV_NEED_MSI_FIX           0x1000000  /* device needs msi workaround */\n\nenum {\n\tNvRegIrqStatus = 0x000,\n#define NVREG_IRQSTAT_MIIEVENT\t0x040\n#define NVREG_IRQSTAT_MASK\t\t0x83ff\n\tNvRegIrqMask = 0x004,\n#define NVREG_IRQ_RX_ERROR\t\t0x0001\n#define NVREG_IRQ_RX\t\t\t0x0002\n#define NVREG_IRQ_RX_NOBUF\t\t0x0004\n#define NVREG_IRQ_TX_ERR\t\t0x0008\n#define NVREG_IRQ_TX_OK\t\t\t0x0010\n#define NVREG_IRQ_TIMER\t\t\t0x0020\n#define NVREG_IRQ_LINK\t\t\t0x0040\n#define NVREG_IRQ_RX_FORCED\t\t0x0080\n#define NVREG_IRQ_TX_FORCED\t\t0x0100\n#define NVREG_IRQ_RECOVER_ERROR\t\t0x8200\n#define NVREG_IRQMASK_THROUGHPUT\t0x00df\n#define NVREG_IRQMASK_CPU\t\t0x0060\n#define NVREG_IRQ_TX_ALL\t\t(NVREG_IRQ_TX_ERR|NVREG_IRQ_TX_OK|NVREG_IRQ_TX_FORCED)\n#define NVREG_IRQ_RX_ALL\t\t(NVREG_IRQ_RX_ERROR|NVREG_IRQ_RX|NVREG_IRQ_RX_NOBUF|NVREG_IRQ_RX_FORCED)\n#define NVREG_IRQ_OTHER\t\t\t(NVREG_IRQ_TIMER|NVREG_IRQ_LINK|NVREG_IRQ_RECOVER_ERROR)\n\n\tNvRegUnknownSetupReg6 = 0x008,\n#define NVREG_UNKSETUP6_VAL\t\t3\n\n/*\n * NVREG_POLL_DEFAULT is the interval length of the timer source on the nic\n * NVREG_POLL_DEFAULT=97 would result in an interval length of 1 ms\n */\n\tNvRegPollingInterval = 0x00c,\n#define NVREG_POLL_DEFAULT_THROUGHPUT\t65535 /* backup tx cleanup if loop max reached */\n#define NVREG_POLL_DEFAULT_CPU\t13\n\tNvRegMSIMap0 = 0x020,\n\tNvRegMSIMap1 = 0x024,\n\tNvRegMSIIrqMask = 0x030,\n#define NVREG_MSI_VECTOR_0_ENABLED 0x01\n\tNvRegMisc1 = 0x080,\n#define NVREG_MISC1_PAUSE_TX\t0x01\n#define NVREG_MISC1_HD\t\t0x02\n#define NVREG_MISC1_FORCE\t0x3b0f3c\n\n\tNvRegMacReset = 0x34,\n#define NVREG_MAC_RESET_ASSERT\t0x0F3\n\tNvRegTransmitterControl = 0x084,\n#define NVREG_XMITCTL_START\t0x01\n#define NVREG_XMITCTL_MGMT_ST\t0x40000000\n#define NVREG_XMITCTL_SYNC_MASK\t\t0x000f0000\n#define NVREG_XMITCTL_SYNC_NOT_READY\t0x0\n#define NVREG_XMITCTL_SYNC_PHY_INIT\t0x00040000\n#define NVREG_XMITCTL_MGMT_SEMA_MASK\t0x00000f00\n#define NVREG_XMITCTL_MGMT_SEMA_FREE\t0x0\n#define NVREG_XMITCTL_HOST_SEMA_MASK\t0x0000f000\n#define NVREG_XMITCTL_HOST_SEMA_ACQ\t0x0000f000\n#define NVREG_XMITCTL_HOST_LOADED\t0x00004000\n#define NVREG_XMITCTL_TX_PATH_EN\t0x01000000\n#define NVREG_XMITCTL_DATA_START\t0x00100000\n#define NVREG_XMITCTL_DATA_READY\t0x00010000\n#define NVREG_XMITCTL_DATA_ERROR\t0x00020000\n\tNvRegTransmitterStatus = 0x088,\n#define NVREG_XMITSTAT_BUSY\t0x01\n\n\tNvRegPacketFilterFlags = 0x8c,\n#define NVREG_PFF_PAUSE_RX\t0x08\n#define NVREG_PFF_ALWAYS\t0x7F0000\n#define NVREG_PFF_PROMISC\t0x80\n#define NVREG_PFF_MYADDR\t0x20\n#define NVREG_PFF_LOOPBACK\t0x10\n\n\tNvRegOffloadConfig = 0x90,\n#define NVREG_OFFLOAD_HOMEPHY\t0x601\n#define NVREG_OFFLOAD_NORMAL\tRX_NIC_BUFSIZE\n\tNvRegReceiverControl = 0x094,\n#define NVREG_RCVCTL_START\t0x01\n#define NVREG_RCVCTL_RX_PATH_EN\t0x01000000\n\tNvRegReceiverStatus = 0x98,\n#define NVREG_RCVSTAT_BUSY\t0x01\n\n\tNvRegSlotTime = 0x9c,\n#define NVREG_SLOTTIME_LEGBF_ENABLED\t0x80000000\n#define NVREG_SLOTTIME_10_100_FULL\t0x00007f00\n#define NVREG_SLOTTIME_1000_FULL\t0x0003ff00\n#define NVREG_SLOTTIME_HALF\t\t0x0000ff00\n#define NVREG_SLOTTIME_DEFAULT\t\t0x00007f00\n#define NVREG_SLOTTIME_MASK\t\t0x000000ff\n\n\tNvRegTxDeferral = 0xA0,\n#define NVREG_TX_DEFERRAL_DEFAULT\t\t0x15050f\n#define NVREG_TX_DEFERRAL_RGMII_10_100\t\t0x16070f\n#define NVREG_TX_DEFERRAL_RGMII_1000\t\t0x14050f\n#define NVREG_TX_DEFERRAL_RGMII_STRETCH_10\t0x16190f\n#define NVREG_TX_DEFERRAL_RGMII_STRETCH_100\t0x16300f\n#define NVREG_TX_DEFERRAL_MII_STRETCH\t\t0x152000\n\tNvRegRxDeferral = 0xA4,\n#define NVREG_RX_DEFERRAL_DEFAULT\t0x16\n\tNvRegMacAddrA = 0xA8,\n\tNvRegMacAddrB = 0xAC,\n\tNvRegMulticastAddrA = 0xB0,\n#define NVREG_MCASTADDRA_FORCE\t0x01\n\tNvRegMulticastAddrB = 0xB4,\n\tNvRegMulticastMaskA = 0xB8,\n#define NVREG_MCASTMASKA_NONE\t\t0xffffffff\n\tNvRegMulticastMaskB = 0xBC,\n#define NVREG_MCASTMASKB_NONE\t\t0xffff\n\n\tNvRegPhyInterface = 0xC0,\n#define PHY_RGMII\t\t0x10000000\n\tNvRegBackOffControl = 0xC4,\n#define NVREG_BKOFFCTRL_DEFAULT\t\t\t0x70000000\n#define NVREG_BKOFFCTRL_SEED_MASK\t\t0x000003ff\n#define NVREG_BKOFFCTRL_SELECT\t\t\t24\n#define NVREG_BKOFFCTRL_GEAR\t\t\t12\n\n\tNvRegTxRingPhysAddr = 0x100,\n\tNvRegRxRingPhysAddr = 0x104,\n\tNvRegRingSizes = 0x108,\n#define NVREG_RINGSZ_TXSHIFT 0\n#define NVREG_RINGSZ_RXSHIFT 16\n\tNvRegTransmitPoll = 0x10c,\n#define NVREG_TRANSMITPOLL_MAC_ADDR_REV\t0x00008000\n\tNvRegLinkSpeed = 0x110,\n#define NVREG_LINKSPEED_FORCE 0x10000\n#define NVREG_LINKSPEED_10\t1000\n#define NVREG_LINKSPEED_100\t100\n#define NVREG_LINKSPEED_1000\t50\n#define NVREG_LINKSPEED_MASK\t(0xFFF)\n\tNvRegUnknownSetupReg5 = 0x130,\n#define NVREG_UNKSETUP5_BIT31\t(1<<31)\n\tNvRegTxWatermark = 0x13c,\n#define NVREG_TX_WM_DESC1_DEFAULT\t0x0200010\n#define NVREG_TX_WM_DESC2_3_DEFAULT\t0x1e08000\n#define NVREG_TX_WM_DESC2_3_1000\t0xfe08000\n\tNvRegTxRxControl = 0x144,\n#define NVREG_TXRXCTL_KICK\t0x0001\n#define NVREG_TXRXCTL_BIT1\t0x0002\n#define NVREG_TXRXCTL_BIT2\t0x0004\n#define NVREG_TXRXCTL_IDLE\t0x0008\n#define NVREG_TXRXCTL_RESET\t0x0010\n#define NVREG_TXRXCTL_RXCHECK\t0x0400\n#define NVREG_TXRXCTL_DESC_1\t0\n#define NVREG_TXRXCTL_DESC_2\t0x002100\n#define NVREG_TXRXCTL_DESC_3\t0xc02200\n#define NVREG_TXRXCTL_VLANSTRIP 0x00040\n#define NVREG_TXRXCTL_VLANINS\t0x00080\n\tNvRegTxRingPhysAddrHigh = 0x148,\n\tNvRegRxRingPhysAddrHigh = 0x14C,\n\tNvRegTxPauseFrame = 0x170,\n#define NVREG_TX_PAUSEFRAME_DISABLE\t0x0fff0080\n#define NVREG_TX_PAUSEFRAME_ENABLE_V1\t0x01800010\n#define NVREG_TX_PAUSEFRAME_ENABLE_V2\t0x056003f0\n#define NVREG_TX_PAUSEFRAME_ENABLE_V3\t0x09f00880\n\tNvRegTxPauseFrameLimit = 0x174,\n#define NVREG_TX_PAUSEFRAMELIMIT_ENABLE\t0x00010000\n\tNvRegMIIStatus = 0x180,\n#define NVREG_MIISTAT_ERROR\t\t0x0001\n#define NVREG_MIISTAT_LINKCHANGE\t0x0008\n#define NVREG_MIISTAT_MASK_RW\t\t0x0007\n#define NVREG_MIISTAT_MASK_ALL\t\t0x000f\n\tNvRegMIIMask = 0x184,\n#define NVREG_MII_LINKCHANGE\t\t0x0008\n\n\tNvRegAdapterControl = 0x188,\n#define NVREG_ADAPTCTL_START\t0x02\n#define NVREG_ADAPTCTL_LINKUP\t0x04\n#define NVREG_ADAPTCTL_PHYVALID\t0x40000\n#define NVREG_ADAPTCTL_RUNNING\t0x100000\n#define NVREG_ADAPTCTL_PHYSHIFT\t24\n\tNvRegMIISpeed = 0x18c,\n#define NVREG_MIISPEED_BIT8\t(1<<8)\n#define NVREG_MIIDELAY\t5\n\tNvRegMIIControl = 0x190,\n#define NVREG_MIICTL_INUSE\t0x08000\n#define NVREG_MIICTL_WRITE\t0x00400\n#define NVREG_MIICTL_ADDRSHIFT\t5\n\tNvRegMIIData = 0x194,\n\tNvRegTxUnicast = 0x1a0,\n\tNvRegTxMulticast = 0x1a4,\n\tNvRegTxBroadcast = 0x1a8,\n\tNvRegWakeUpFlags = 0x200,\n#define NVREG_WAKEUPFLAGS_VAL\t\t0x7770\n#define NVREG_WAKEUPFLAGS_BUSYSHIFT\t24\n#define NVREG_WAKEUPFLAGS_ENABLESHIFT\t16\n#define NVREG_WAKEUPFLAGS_D3SHIFT\t12\n#define NVREG_WAKEUPFLAGS_D2SHIFT\t8\n#define NVREG_WAKEUPFLAGS_D1SHIFT\t4\n#define NVREG_WAKEUPFLAGS_D0SHIFT\t0\n#define NVREG_WAKEUPFLAGS_ACCEPT_MAGPAT\t\t0x01\n#define NVREG_WAKEUPFLAGS_ACCEPT_WAKEUPPAT\t0x02\n#define NVREG_WAKEUPFLAGS_ACCEPT_LINKCHANGE\t0x04\n#define NVREG_WAKEUPFLAGS_ENABLE\t0x1111\n\n\tNvRegMgmtUnitGetVersion = 0x204,\n#define NVREG_MGMTUNITGETVERSION\t0x01\n\tNvRegMgmtUnitVersion = 0x208,\n#define NVREG_MGMTUNITVERSION\t\t0x08\n\tNvRegPowerCap = 0x268,\n#define NVREG_POWERCAP_D3SUPP\t(1<<30)\n#define NVREG_POWERCAP_D2SUPP\t(1<<26)\n#define NVREG_POWERCAP_D1SUPP\t(1<<25)\n\tNvRegPowerState = 0x26c,\n#define NVREG_POWERSTATE_POWEREDUP\t0x8000\n#define NVREG_POWERSTATE_VALID\t\t0x0100\n#define NVREG_POWERSTATE_MASK\t\t0x0003\n#define NVREG_POWERSTATE_D0\t\t0x0000\n#define NVREG_POWERSTATE_D1\t\t0x0001\n#define NVREG_POWERSTATE_D2\t\t0x0002\n#define NVREG_POWERSTATE_D3\t\t0x0003\n\tNvRegMgmtUnitControl = 0x278,\n#define NVREG_MGMTUNITCONTROL_INUSE\t0x20000\n\tNvRegTxCnt = 0x280,\n\tNvRegTxZeroReXmt = 0x284,\n\tNvRegTxOneReXmt = 0x288,\n\tNvRegTxManyReXmt = 0x28c,\n\tNvRegTxLateCol = 0x290,\n\tNvRegTxUnderflow = 0x294,\n\tNvRegTxLossCarrier = 0x298,\n\tNvRegTxExcessDef = 0x29c,\n\tNvRegTxRetryErr = 0x2a0,\n\tNvRegRxFrameErr = 0x2a4,\n\tNvRegRxExtraByte = 0x2a8,\n\tNvRegRxLateCol = 0x2ac,\n\tNvRegRxRunt = 0x2b0,\n\tNvRegRxFrameTooLong = 0x2b4,\n\tNvRegRxOverflow = 0x2b8,\n\tNvRegRxFCSErr = 0x2bc,\n\tNvRegRxFrameAlignErr = 0x2c0,\n\tNvRegRxLenErr = 0x2c4,\n\tNvRegRxUnicast = 0x2c8,\n\tNvRegRxMulticast = 0x2cc,\n\tNvRegRxBroadcast = 0x2d0,\n\tNvRegTxDef = 0x2d4,\n\tNvRegTxFrame = 0x2d8,\n\tNvRegRxCnt = 0x2dc,\n\tNvRegTxPause = 0x2e0,\n\tNvRegRxPause = 0x2e4,\n\tNvRegRxDropFrame = 0x2e8,\n\tNvRegVlanControl = 0x300,\n#define NVREG_VLANCONTROL_ENABLE\t0x2000\n\tNvRegMSIXMap0 = 0x3e0,\n\tNvRegMSIXMap1 = 0x3e4,\n\tNvRegMSIXIrqStatus = 0x3f0,\n\n\tNvRegPowerState2 = 0x600,\n#define NVREG_POWERSTATE2_POWERUP_MASK\t\t0x0F15\n#define NVREG_POWERSTATE2_POWERUP_REV_A3\t0x0001\n#define NVREG_POWERSTATE2_PHY_RESET\t\t0x0004\n#define NVREG_POWERSTATE2_GATE_CLOCKS\t\t0x0F00\n};\n\n/* Big endian: should work, but is untested */\nstruct ring_desc {\n\t__le32 buf;\n\t__le32 flaglen;\n};\n\nstruct ring_desc_ex {\n\t__le32 bufhigh;\n\t__le32 buflow;\n\t__le32 txvlan;\n\t__le32 flaglen;\n};\n\nunion ring_type {\n\tstruct ring_desc *orig;\n\tstruct ring_desc_ex *ex;\n};\n\n#define FLAG_MASK_V1 0xffff0000\n#define FLAG_MASK_V2 0xffffc000\n#define LEN_MASK_V1 (0xffffffff ^ FLAG_MASK_V1)\n#define LEN_MASK_V2 (0xffffffff ^ FLAG_MASK_V2)\n\n#define NV_TX_LASTPACKET\t(1<<16)\n#define NV_TX_RETRYERROR\t(1<<19)\n#define NV_TX_RETRYCOUNT_MASK\t(0xF<<20)\n#define NV_TX_FORCED_INTERRUPT\t(1<<24)\n#define NV_TX_DEFERRED\t\t(1<<26)\n#define NV_TX_CARRIERLOST\t(1<<27)\n#define NV_TX_LATECOLLISION\t(1<<28)\n#define NV_TX_UNDERFLOW\t\t(1<<29)\n#define NV_TX_ERROR\t\t(1<<30)\n#define NV_TX_VALID\t\t(1<<31)\n\n#define NV_TX2_LASTPACKET\t(1<<29)\n#define NV_TX2_RETRYERROR\t(1<<18)\n#define NV_TX2_RETRYCOUNT_MASK\t(0xF<<19)\n#define NV_TX2_FORCED_INTERRUPT\t(1<<30)\n#define NV_TX2_DEFERRED\t\t(1<<25)\n#define NV_TX2_CARRIERLOST\t(1<<26)\n#define NV_TX2_LATECOLLISION\t(1<<27)\n#define NV_TX2_UNDERFLOW\t(1<<28)\n/* error and valid are the same for both */\n#define NV_TX2_ERROR\t\t(1<<30)\n#define NV_TX2_VALID\t\t(1<<31)\n#define NV_TX2_TSO\t\t(1<<28)\n#define NV_TX2_TSO_SHIFT\t14\n#define NV_TX2_TSO_MAX_SHIFT\t14\n#define NV_TX2_TSO_MAX_SIZE\t(1<<NV_TX2_TSO_MAX_SHIFT)\n#define NV_TX2_CHECKSUM_L3\t(1<<27)\n#define NV_TX2_CHECKSUM_L4\t(1<<26)\n\n#define NV_TX3_VLAN_TAG_PRESENT (1<<18)\n\n#define NV_RX_DESCRIPTORVALID\t(1<<16)\n#define NV_RX_MISSEDFRAME\t(1<<17)\n#define NV_RX_SUBTRACT1\t\t(1<<18)\n#define NV_RX_ERROR1\t\t(1<<23)\n#define NV_RX_ERROR2\t\t(1<<24)\n#define NV_RX_ERROR3\t\t(1<<25)\n#define NV_RX_ERROR4\t\t(1<<26)\n#define NV_RX_CRCERR\t\t(1<<27)\n#define NV_RX_OVERFLOW\t\t(1<<28)\n#define NV_RX_FRAMINGERR\t(1<<29)\n#define NV_RX_ERROR\t\t(1<<30)\n#define NV_RX_AVAIL\t\t(1<<31)\n#define NV_RX_ERROR_MASK\t(NV_RX_ERROR1|NV_RX_ERROR2|NV_RX_ERROR3|NV_RX_ERROR4|NV_RX_CRCERR|NV_RX_OVERFLOW|NV_RX_FRAMINGERR)\n\n#define NV_RX2_CHECKSUMMASK\t(0x1C000000)\n#define NV_RX2_CHECKSUM_IP\t(0x10000000)\n#define NV_RX2_CHECKSUM_IP_TCP\t(0x14000000)\n#define NV_RX2_CHECKSUM_IP_UDP\t(0x18000000)\n#define NV_RX2_DESCRIPTORVALID\t(1<<29)\n#define NV_RX2_SUBTRACT1\t(1<<25)\n#define NV_RX2_ERROR1\t\t(1<<18)\n#define NV_RX2_ERROR2\t\t(1<<19)\n#define NV_RX2_ERROR3\t\t(1<<20)\n#define NV_RX2_ERROR4\t\t(1<<21)\n#define NV_RX2_CRCERR\t\t(1<<22)\n#define NV_RX2_OVERFLOW\t\t(1<<23)\n#define NV_RX2_FRAMINGERR\t(1<<24)\n/* error and avail are the same for both */\n#define NV_RX2_ERROR\t\t(1<<30)\n#define NV_RX2_AVAIL\t\t(1<<31)\n#define NV_RX2_ERROR_MASK\t(NV_RX2_ERROR1|NV_RX2_ERROR2|NV_RX2_ERROR3|NV_RX2_ERROR4|NV_RX2_CRCERR|NV_RX2_OVERFLOW|NV_RX2_FRAMINGERR)\n\n#define NV_RX3_VLAN_TAG_PRESENT (1<<16)\n#define NV_RX3_VLAN_TAG_MASK\t(0x0000FFFF)\n\n/* Miscellaneous hardware related defines: */\n#define NV_PCI_REGSZ_VER1\t0x270\n#define NV_PCI_REGSZ_VER2\t0x2d4\n#define NV_PCI_REGSZ_VER3\t0x604\n#define NV_PCI_REGSZ_MAX\t0x604\n\n/* various timeout delays: all in usec */\n#define NV_TXRX_RESET_DELAY\t4\n#define NV_TXSTOP_DELAY1\t10\n#define NV_TXSTOP_DELAY1MAX\t500000\n#define NV_TXSTOP_DELAY2\t100\n#define NV_RXSTOP_DELAY1\t10\n#define NV_RXSTOP_DELAY1MAX\t500000\n#define NV_RXSTOP_DELAY2\t100\n#define NV_SETUP5_DELAY\t\t5\n#define NV_SETUP5_DELAYMAX\t50000\n#define NV_POWERUP_DELAY\t5\n#define NV_POWERUP_DELAYMAX\t5000\n#define NV_MIIBUSY_DELAY\t50\n#define NV_MIIPHY_DELAY\t10\n#define NV_MIIPHY_DELAYMAX\t10000\n#define NV_MAC_RESET_DELAY\t64\n\n#define NV_WAKEUPPATTERNS\t5\n#define NV_WAKEUPMASKENTRIES\t4\n\n/* General driver defaults */\n#define NV_WATCHDOG_TIMEO\t(5*HZ)\n\n#define RX_RING_DEFAULT\t\t512\n#define TX_RING_DEFAULT\t\t256\n#define RX_RING_MIN\t\t128\n#define TX_RING_MIN\t\t64\n#define RING_MAX_DESC_VER_1\t1024\n#define RING_MAX_DESC_VER_2_3\t16384\n\n/* rx/tx mac addr + type + vlan + align + slack*/\n#define NV_RX_HEADERS\t\t(64)\n/* even more slack. */\n#define NV_RX_ALLOC_PAD\t\t(64)\n\n/* maximum mtu size */\n#define NV_PKTLIMIT_1\tETH_DATA_LEN\t/* hard limit not known */\n#define NV_PKTLIMIT_2\t9100\t/* Actual limit according to NVidia: 9202 */\n\n#define OOM_REFILL\t(1+HZ/20)\n#define POLL_WAIT\t(1+HZ/100)\n#define LINK_TIMEOUT\t(3*HZ)\n#define STATS_INTERVAL\t(10*HZ)\n\n/*\n * desc_ver values:\n * The nic supports three different descriptor types:\n * - DESC_VER_1: Original\n * - DESC_VER_2: support for jumbo frames.\n * - DESC_VER_3: 64-bit format.\n */\n#define DESC_VER_1\t1\n#define DESC_VER_2\t2\n#define DESC_VER_3\t3\n\n/* PHY defines */\n#define PHY_OUI_MARVELL\t\t0x5043\n#define PHY_OUI_CICADA\t\t0x03f1\n#define PHY_OUI_VITESSE\t\t0x01c1\n#define PHY_OUI_REALTEK\t\t0x0732\n#define PHY_OUI_REALTEK2\t0x0020\n#define PHYID1_OUI_MASK\t0x03ff\n#define PHYID1_OUI_SHFT\t6\n#define PHYID2_OUI_MASK\t0xfc00\n#define PHYID2_OUI_SHFT\t10\n#define PHYID2_MODEL_MASK\t\t0x03f0\n#define PHY_MODEL_REALTEK_8211\t\t0x0110\n#define PHY_REV_MASK\t\t\t0x0001\n#define PHY_REV_REALTEK_8211B\t\t0x0000\n#define PHY_REV_REALTEK_8211C\t\t0x0001\n#define PHY_MODEL_REALTEK_8201\t\t0x0200\n#define PHY_MODEL_MARVELL_E3016\t\t0x0220\n#define PHY_MARVELL_E3016_INITMASK\t0x0300\n#define PHY_CICADA_INIT1\t0x0f000\n#define PHY_CICADA_INIT2\t0x0e00\n#define PHY_CICADA_INIT3\t0x01000\n#define PHY_CICADA_INIT4\t0x0200\n#define PHY_CICADA_INIT5\t0x0004\n#define PHY_CICADA_INIT6\t0x02000\n#define PHY_VITESSE_INIT_REG1\t0x1f\n#define PHY_VITESSE_INIT_REG2\t0x10\n#define PHY_VITESSE_INIT_REG3\t0x11\n#define PHY_VITESSE_INIT_REG4\t0x12\n#define PHY_VITESSE_INIT_MSK1\t0xc\n#define PHY_VITESSE_INIT_MSK2\t0x0180\n#define PHY_VITESSE_INIT1\t0x52b5\n#define PHY_VITESSE_INIT2\t0xaf8a\n#define PHY_VITESSE_INIT3\t0x8\n#define PHY_VITESSE_INIT4\t0x8f8a\n#define PHY_VITESSE_INIT5\t0xaf86\n#define PHY_VITESSE_INIT6\t0x8f86\n#define PHY_VITESSE_INIT7\t0xaf82\n#define PHY_VITESSE_INIT8\t0x0100\n#define PHY_VITESSE_INIT9\t0x8f82\n#define PHY_VITESSE_INIT10\t0x0\n#define PHY_REALTEK_INIT_REG1\t0x1f\n#define PHY_REALTEK_INIT_REG2\t0x19\n#define PHY_REALTEK_INIT_REG3\t0x13\n#define PHY_REALTEK_INIT_REG4\t0x14\n#define PHY_REALTEK_INIT_REG5\t0x18\n#define PHY_REALTEK_INIT_REG6\t0x11\n#define PHY_REALTEK_INIT_REG7\t0x01\n#define PHY_REALTEK_INIT1\t0x0000\n#define PHY_REALTEK_INIT2\t0x8e00\n#define PHY_REALTEK_INIT3\t0x0001\n#define PHY_REALTEK_INIT4\t0xad17\n#define PHY_REALTEK_INIT5\t0xfb54\n#define PHY_REALTEK_INIT6\t0xf5c7\n#define PHY_REALTEK_INIT7\t0x1000\n#define PHY_REALTEK_INIT8\t0x0003\n#define PHY_REALTEK_INIT9\t0x0008\n#define PHY_REALTEK_INIT10\t0x0005\n#define PHY_REALTEK_INIT11\t0x0200\n#define PHY_REALTEK_INIT_MSK1\t0x0003\n\n#define PHY_GIGABIT\t0x0100\n\n#define PHY_TIMEOUT\t0x1\n#define PHY_ERROR\t0x2\n\n#define PHY_100\t0x1\n#define PHY_1000\t0x2\n#define PHY_HALF\t0x100\n\n#define NV_PAUSEFRAME_RX_CAPABLE 0x0001\n#define NV_PAUSEFRAME_TX_CAPABLE 0x0002\n#define NV_PAUSEFRAME_RX_ENABLE  0x0004\n#define NV_PAUSEFRAME_TX_ENABLE  0x0008\n#define NV_PAUSEFRAME_RX_REQ     0x0010\n#define NV_PAUSEFRAME_TX_REQ     0x0020\n#define NV_PAUSEFRAME_AUTONEG    0x0040\n\n/* MSI/MSI-X defines */\n#define NV_MSI_X_MAX_VECTORS  8\n#define NV_MSI_X_VECTORS_MASK 0x000f\n#define NV_MSI_CAPABLE        0x0010\n#define NV_MSI_X_CAPABLE      0x0020\n#define NV_MSI_ENABLED        0x0040\n#define NV_MSI_X_ENABLED      0x0080\n\n#define NV_MSI_X_VECTOR_ALL   0x0\n#define NV_MSI_X_VECTOR_RX    0x0\n#define NV_MSI_X_VECTOR_TX    0x1\n#define NV_MSI_X_VECTOR_OTHER 0x2\n\n#define NV_MSI_PRIV_OFFSET 0x68\n#define NV_MSI_PRIV_VALUE  0xffffffff\n\n#define NV_RESTART_TX         0x1\n#define NV_RESTART_RX         0x2\n\n#define NV_TX_LIMIT_COUNT     16\n\n#define NV_DYNAMIC_THRESHOLD        4\n#define NV_DYNAMIC_MAX_QUIET_COUNT  2048\n\n/* statistics */\nstruct nv_ethtool_str {\n\tchar name[ETH_GSTRING_LEN];\n};\n\nstatic const struct nv_ethtool_str nv_estats_str[] = {\n\t{ \"tx_bytes\" }, /* includes Ethernet FCS CRC */\n\t{ \"tx_zero_rexmt\" },\n\t{ \"tx_one_rexmt\" },\n\t{ \"tx_many_rexmt\" },\n\t{ \"tx_late_collision\" },\n\t{ \"tx_fifo_errors\" },\n\t{ \"tx_carrier_errors\" },\n\t{ \"tx_excess_deferral\" },\n\t{ \"tx_retry_error\" },\n\t{ \"rx_frame_error\" },\n\t{ \"rx_extra_byte\" },\n\t{ \"rx_late_collision\" },\n\t{ \"rx_runt\" },\n\t{ \"rx_frame_too_long\" },\n\t{ \"rx_over_errors\" },\n\t{ \"rx_crc_errors\" },\n\t{ \"rx_frame_align_error\" },\n\t{ \"rx_length_error\" },\n\t{ \"rx_unicast\" },\n\t{ \"rx_multicast\" },\n\t{ \"rx_broadcast\" },\n\t{ \"rx_packets\" },\n\t{ \"rx_errors_total\" },\n\t{ \"tx_errors_total\" },\n\n\t/* version 2 stats */\n\t{ \"tx_deferral\" },\n\t{ \"tx_packets\" },\n\t{ \"rx_bytes\" }, /* includes Ethernet FCS CRC */\n\t{ \"tx_pause\" },\n\t{ \"rx_pause\" },\n\t{ \"rx_drop_frame\" },\n\n\t/* version 3 stats */\n\t{ \"tx_unicast\" },\n\t{ \"tx_multicast\" },\n\t{ \"tx_broadcast\" }\n};\n\nstruct nv_ethtool_stats {\n\tu64 tx_bytes; /* should be ifconfig->tx_bytes + 4*tx_packets */\n\tu64 tx_zero_rexmt;\n\tu64 tx_one_rexmt;\n\tu64 tx_many_rexmt;\n\tu64 tx_late_collision;\n\tu64 tx_fifo_errors;\n\tu64 tx_carrier_errors;\n\tu64 tx_excess_deferral;\n\tu64 tx_retry_error;\n\tu64 rx_frame_error;\n\tu64 rx_extra_byte;\n\tu64 rx_late_collision;\n\tu64 rx_runt;\n\tu64 rx_frame_too_long;\n\tu64 rx_over_errors;\n\tu64 rx_crc_errors;\n\tu64 rx_frame_align_error;\n\tu64 rx_length_error;\n\tu64 rx_unicast;\n\tu64 rx_multicast;\n\tu64 rx_broadcast;\n\tu64 rx_packets; /* should be ifconfig->rx_packets */\n\tu64 rx_errors_total;\n\tu64 tx_errors_total;\n\n\t/* version 2 stats */\n\tu64 tx_deferral;\n\tu64 tx_packets; /* should be ifconfig->tx_packets */\n\tu64 rx_bytes;   /* should be ifconfig->rx_bytes + 4*rx_packets */\n\tu64 tx_pause;\n\tu64 rx_pause;\n\tu64 rx_drop_frame;\n\n\t/* version 3 stats */\n\tu64 tx_unicast;\n\tu64 tx_multicast;\n\tu64 tx_broadcast;\n};\n\n#define NV_DEV_STATISTICS_V3_COUNT (sizeof(struct nv_ethtool_stats)/sizeof(u64))\n#define NV_DEV_STATISTICS_V2_COUNT (NV_DEV_STATISTICS_V3_COUNT - 3)\n#define NV_DEV_STATISTICS_V1_COUNT (NV_DEV_STATISTICS_V2_COUNT - 6)\n\n/* diagnostics */\n#define NV_TEST_COUNT_BASE 3\n#define NV_TEST_COUNT_EXTENDED 4\n\nstatic const struct nv_ethtool_str nv_etests_str[] = {\n\t{ \"link      (online/offline)\" },\n\t{ \"register  (offline)       \" },\n\t{ \"interrupt (offline)       \" },\n\t{ \"loopback  (offline)       \" }\n};\n\nstruct register_test {\n\t__u32 reg;\n\t__u32 mask;\n};\n\nstatic const struct register_test nv_registers_test[] = {\n\t{ NvRegUnknownSetupReg6, 0x01 },\n\t{ NvRegMisc1, 0x03c },\n\t{ NvRegOffloadConfig, 0x03ff },\n\t{ NvRegMulticastAddrA, 0xffffffff },\n\t{ NvRegTxWatermark, 0x0ff },\n\t{ NvRegWakeUpFlags, 0x07777 },\n\t{ 0, 0 }\n};\n\nstruct nv_skb_map {\n\tstruct sk_buff *skb;\n\tdma_addr_t dma;\n\tunsigned int dma_len:31;\n\tunsigned int dma_single:1;\n\tstruct ring_desc_ex *first_tx_desc;\n\tstruct nv_skb_map *next_tx_ctx;\n};\n\nstruct nv_txrx_stats {\n\tu64 stat_rx_packets;\n\tu64 stat_rx_bytes; /* not always available in HW */\n\tu64 stat_rx_missed_errors;\n\tu64 stat_rx_dropped;\n\tu64 stat_tx_packets; /* not always available in HW */\n\tu64 stat_tx_bytes;\n\tu64 stat_tx_dropped;\n};\n\n#define nv_txrx_stats_inc(member) \\\n\t\t__this_cpu_inc(np->txrx_stats->member)\n#define nv_txrx_stats_add(member, count) \\\n\t\t__this_cpu_add(np->txrx_stats->member, (count))\n\n/*\n * SMP locking:\n * All hardware access under netdev_priv(dev)->lock, except the performance\n * critical parts:\n * - rx is (pseudo-) lockless: it relies on the single-threading provided\n *\tby the arch code for interrupts.\n * - tx setup is lockless: it relies on netif_tx_lock. Actual submission\n *\tneeds netdev_priv(dev)->lock :-(\n * - set_multicast_list: preparation lockless, relies on netif_tx_lock.\n *\n * Hardware stats updates are protected by hwstats_lock:\n * - updated by nv_do_stats_poll (timer). This is meant to avoid\n *   integer wraparound in the NIC stats registers, at low frequency\n *   (0.1 Hz)\n * - updated by nv_get_ethtool_stats + nv_get_stats64\n *\n * Software stats are accessed only through 64b synchronization points\n * and are not subject to other synchronization techniques (single\n * update thread on the TX or RX paths).\n */\n\n/* in dev: base, irq */\nstruct fe_priv {\n\tspinlock_t lock;\n\n\tstruct net_device *dev;\n\tstruct napi_struct napi;\n\n\t/* hardware stats are updated in syscall and timer */\n\tspinlock_t hwstats_lock;\n\tstruct nv_ethtool_stats estats;\n\n\tint in_shutdown;\n\tu32 linkspeed;\n\tint duplex;\n\tint autoneg;\n\tint fixed_mode;\n\tint phyaddr;\n\tint wolenabled;\n\tunsigned int phy_oui;\n\tunsigned int phy_model;\n\tunsigned int phy_rev;\n\tu16 gigabit;\n\tint intr_test;\n\tint recover_error;\n\tint quiet_count;\n\n\t/* General data: RO fields */\n\tdma_addr_t ring_addr;\n\tstruct pci_dev *pci_dev;\n\tu32 orig_mac[2];\n\tu32 events;\n\tu32 irqmask;\n\tu32 desc_ver;\n\tu32 txrxctl_bits;\n\tu32 vlanctl_bits;\n\tu32 driver_data;\n\tu32 device_id;\n\tu32 register_size;\n\tu32 mac_in_use;\n\tint mgmt_version;\n\tint mgmt_sema;\n\n\tvoid __iomem *base;\n\n\t/* rx specific fields.\n\t * Locking: Within irq hander or disable_irq+spin_lock(&np->lock);\n\t */\n\tunion ring_type get_rx, put_rx, last_rx;\n\tstruct nv_skb_map *get_rx_ctx, *put_rx_ctx;\n\tstruct nv_skb_map *last_rx_ctx;\n\tstruct nv_skb_map *rx_skb;\n\n\tunion ring_type rx_ring;\n\tunsigned int rx_buf_sz;\n\tunsigned int pkt_limit;\n\tstruct timer_list oom_kick;\n\tstruct timer_list nic_poll;\n\tstruct timer_list stats_poll;\n\tu32 nic_poll_irq;\n\tint rx_ring_size;\n\n\t/* RX software stats */\n\tstruct u64_stats_sync swstats_rx_syncp;\n\tstruct nv_txrx_stats __percpu *txrx_stats;\n\n\t/* media detection workaround.\n\t * Locking: Within irq hander or disable_irq+spin_lock(&np->lock);\n\t */\n\tint need_linktimer;\n\tunsigned long link_timeout;\n\t/*\n\t * tx specific fields.\n\t */\n\tunion ring_type get_tx, put_tx, last_tx;\n\tstruct nv_skb_map *get_tx_ctx, *put_tx_ctx;\n\tstruct nv_skb_map *last_tx_ctx;\n\tstruct nv_skb_map *tx_skb;\n\n\tunion ring_type tx_ring;\n\tu32 tx_flags;\n\tint tx_ring_size;\n\tint tx_limit;\n\tu32 tx_pkts_in_progress;\n\tstruct nv_skb_map *tx_change_owner;\n\tstruct nv_skb_map *tx_end_flip;\n\tint tx_stop;\n\n\t/* TX software stats */\n\tstruct u64_stats_sync swstats_tx_syncp;\n\n\t/* msi/msi-x fields */\n\tu32 msi_flags;\n\tstruct msix_entry msi_x_entry[NV_MSI_X_MAX_VECTORS];\n\n\t/* flow control */\n\tu32 pause_flags;\n\n\t/* power saved state */\n\tu32 saved_config_space[NV_PCI_REGSZ_MAX/4];\n\n\t/* for different msi-x irq type */\n\tchar name_rx[IFNAMSIZ + 3];       /* -rx    */\n\tchar name_tx[IFNAMSIZ + 3];       /* -tx    */\n\tchar name_other[IFNAMSIZ + 6];    /* -other */\n};\n\n/*\n * Maximum number of loops until we assume that a bit in the irq mask\n * is stuck. Overridable with module param.\n */\nstatic int max_interrupt_work = 4;\n\n/*\n * Optimization can be either throuput mode or cpu mode\n *\n * Throughput Mode: Every tx and rx packet will generate an interrupt.\n * CPU Mode: Interrupts are controlled by a timer.\n */\nenum {\n\tNV_OPTIMIZATION_MODE_THROUGHPUT,\n\tNV_OPTIMIZATION_MODE_CPU,\n\tNV_OPTIMIZATION_MODE_DYNAMIC\n};\nstatic int optimization_mode = NV_OPTIMIZATION_MODE_DYNAMIC;\n\n/*\n * Poll interval for timer irq\n *\n * This interval determines how frequent an interrupt is generated.\n * The is value is determined by [(time_in_micro_secs * 100) / (2^10)]\n * Min = 0, and Max = 65535\n */\nstatic int poll_interval = -1;\n\n/*\n * MSI interrupts\n */\nenum {\n\tNV_MSI_INT_DISABLED,\n\tNV_MSI_INT_ENABLED\n};\nstatic int msi = NV_MSI_INT_ENABLED;\n\n/*\n * MSIX interrupts\n */\nenum {\n\tNV_MSIX_INT_DISABLED,\n\tNV_MSIX_INT_ENABLED\n};\nstatic int msix = NV_MSIX_INT_ENABLED;\n\n/*\n * DMA 64bit\n */\nenum {\n\tNV_DMA_64BIT_DISABLED,\n\tNV_DMA_64BIT_ENABLED\n};\nstatic int dma_64bit = NV_DMA_64BIT_ENABLED;\n\n/*\n * Debug output control for tx_timeout\n */\nstatic bool debug_tx_timeout = false;\n\n/*\n * Crossover Detection\n * Realtek 8201 phy + some OEM boards do not work properly.\n */\nenum {\n\tNV_CROSSOVER_DETECTION_DISABLED,\n\tNV_CROSSOVER_DETECTION_ENABLED\n};\nstatic int phy_cross = NV_CROSSOVER_DETECTION_DISABLED;\n\n/*\n * Power down phy when interface is down (persists through reboot;\n * older Linux and other OSes may not power it up again)\n */\nstatic int phy_power_down;\n\nstatic inline struct fe_priv *get_nvpriv(struct net_device *dev)\n{\n\treturn netdev_priv(dev);\n}\n\nstatic inline u8 __iomem *get_hwbase(struct net_device *dev)\n{\n\treturn ((struct fe_priv *)netdev_priv(dev))->base;\n}\n\nstatic inline void pci_push(u8 __iomem *base)\n{\n\t/* force out pending posted writes */\n\treadl(base);\n}\n\nstatic inline u32 nv_descr_getlength(struct ring_desc *prd, u32 v)\n{\n\treturn le32_to_cpu(prd->flaglen)\n\t\t& ((v == DESC_VER_1) ? LEN_MASK_V1 : LEN_MASK_V2);\n}\n\nstatic inline u32 nv_descr_getlength_ex(struct ring_desc_ex *prd, u32 v)\n{\n\treturn le32_to_cpu(prd->flaglen) & LEN_MASK_V2;\n}\n\nstatic bool nv_optimized(struct fe_priv *np)\n{\n\tif (np->desc_ver == DESC_VER_1 || np->desc_ver == DESC_VER_2)\n\t\treturn false;\n\treturn true;\n}\n\nstatic int reg_delay(struct net_device *dev, int offset, u32 mask, u32 target,\n\t\t     int delay, int delaymax)\n{\n\tu8 __iomem *base = get_hwbase(dev);\n\n\tpci_push(base);\n\tdo {\n\t\tudelay(delay);\n\t\tdelaymax -= delay;\n\t\tif (delaymax < 0)\n\t\t\treturn 1;\n\t} while ((readl(base + offset) & mask) != target);\n\treturn 0;\n}\n\n#define NV_SETUP_RX_RING 0x01\n#define NV_SETUP_TX_RING 0x02\n\nstatic inline u32 dma_low(dma_addr_t addr)\n{\n\treturn addr;\n}\n\nstatic inline u32 dma_high(dma_addr_t addr)\n{\n\treturn addr>>31>>1;\t/* 0 if 32bit, shift down by 32 if 64bit */\n}\n\nstatic void setup_hw_rings(struct net_device *dev, int rxtx_flags)\n{\n\tstruct fe_priv *np = get_nvpriv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\n\tif (!nv_optimized(np)) {\n\t\tif (rxtx_flags & NV_SETUP_RX_RING)\n\t\t\twritel(dma_low(np->ring_addr), base + NvRegRxRingPhysAddr);\n\t\tif (rxtx_flags & NV_SETUP_TX_RING)\n\t\t\twritel(dma_low(np->ring_addr + np->rx_ring_size*sizeof(struct ring_desc)), base + NvRegTxRingPhysAddr);\n\t} else {\n\t\tif (rxtx_flags & NV_SETUP_RX_RING) {\n\t\t\twritel(dma_low(np->ring_addr), base + NvRegRxRingPhysAddr);\n\t\t\twritel(dma_high(np->ring_addr), base + NvRegRxRingPhysAddrHigh);\n\t\t}\n\t\tif (rxtx_flags & NV_SETUP_TX_RING) {\n\t\t\twritel(dma_low(np->ring_addr + np->rx_ring_size*sizeof(struct ring_desc_ex)), base + NvRegTxRingPhysAddr);\n\t\t\twritel(dma_high(np->ring_addr + np->rx_ring_size*sizeof(struct ring_desc_ex)), base + NvRegTxRingPhysAddrHigh);\n\t\t}\n\t}\n}\n\nstatic void free_rings(struct net_device *dev)\n{\n\tstruct fe_priv *np = get_nvpriv(dev);\n\n\tif (!nv_optimized(np)) {\n\t\tif (np->rx_ring.orig)\n\t\t\tdma_free_coherent(&np->pci_dev->dev,\n\t\t\t\t\t  sizeof(struct ring_desc) *\n\t\t\t\t\t  (np->rx_ring_size +\n\t\t\t\t\t  np->tx_ring_size),\n\t\t\t\t\t  np->rx_ring.orig, np->ring_addr);\n\t} else {\n\t\tif (np->rx_ring.ex)\n\t\t\tdma_free_coherent(&np->pci_dev->dev,\n\t\t\t\t\t  sizeof(struct ring_desc_ex) *\n\t\t\t\t\t  (np->rx_ring_size +\n\t\t\t\t\t  np->tx_ring_size),\n\t\t\t\t\t  np->rx_ring.ex, np->ring_addr);\n\t}\n\tkfree(np->rx_skb);\n\tkfree(np->tx_skb);\n}\n\nstatic int using_multi_irqs(struct net_device *dev)\n{\n\tstruct fe_priv *np = get_nvpriv(dev);\n\n\tif (!(np->msi_flags & NV_MSI_X_ENABLED) ||\n\t    ((np->msi_flags & NV_MSI_X_ENABLED) &&\n\t     ((np->msi_flags & NV_MSI_X_VECTORS_MASK) == 0x1)))\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nstatic void nv_txrx_gate(struct net_device *dev, bool gate)\n{\n\tstruct fe_priv *np = get_nvpriv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 powerstate;\n\n\tif (!np->mac_in_use &&\n\t    (np->driver_data & DEV_HAS_POWER_CNTRL)) {\n\t\tpowerstate = readl(base + NvRegPowerState2);\n\t\tif (gate)\n\t\t\tpowerstate |= NVREG_POWERSTATE2_GATE_CLOCKS;\n\t\telse\n\t\t\tpowerstate &= ~NVREG_POWERSTATE2_GATE_CLOCKS;\n\t\twritel(powerstate, base + NvRegPowerState2);\n\t}\n}\n\nstatic void nv_enable_irq(struct net_device *dev)\n{\n\tstruct fe_priv *np = get_nvpriv(dev);\n\n\tif (!using_multi_irqs(dev)) {\n\t\tif (np->msi_flags & NV_MSI_X_ENABLED)\n\t\t\tenable_irq(np->msi_x_entry[NV_MSI_X_VECTOR_ALL].vector);\n\t\telse\n\t\t\tenable_irq(np->pci_dev->irq);\n\t} else {\n\t\tenable_irq(np->msi_x_entry[NV_MSI_X_VECTOR_RX].vector);\n\t\tenable_irq(np->msi_x_entry[NV_MSI_X_VECTOR_TX].vector);\n\t\tenable_irq(np->msi_x_entry[NV_MSI_X_VECTOR_OTHER].vector);\n\t}\n}\n\nstatic void nv_disable_irq(struct net_device *dev)\n{\n\tstruct fe_priv *np = get_nvpriv(dev);\n\n\tif (!using_multi_irqs(dev)) {\n\t\tif (np->msi_flags & NV_MSI_X_ENABLED)\n\t\t\tdisable_irq(np->msi_x_entry[NV_MSI_X_VECTOR_ALL].vector);\n\t\telse\n\t\t\tdisable_irq(np->pci_dev->irq);\n\t} else {\n\t\tdisable_irq(np->msi_x_entry[NV_MSI_X_VECTOR_RX].vector);\n\t\tdisable_irq(np->msi_x_entry[NV_MSI_X_VECTOR_TX].vector);\n\t\tdisable_irq(np->msi_x_entry[NV_MSI_X_VECTOR_OTHER].vector);\n\t}\n}\n\n/* In MSIX mode, a write to irqmask behaves as XOR */\nstatic void nv_enable_hw_interrupts(struct net_device *dev, u32 mask)\n{\n\tu8 __iomem *base = get_hwbase(dev);\n\n\twritel(mask, base + NvRegIrqMask);\n}\n\nstatic void nv_disable_hw_interrupts(struct net_device *dev, u32 mask)\n{\n\tstruct fe_priv *np = get_nvpriv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\n\tif (np->msi_flags & NV_MSI_X_ENABLED) {\n\t\twritel(mask, base + NvRegIrqMask);\n\t} else {\n\t\tif (np->msi_flags & NV_MSI_ENABLED)\n\t\t\twritel(0, base + NvRegMSIIrqMask);\n\t\twritel(0, base + NvRegIrqMask);\n\t}\n}\n\nstatic void nv_napi_enable(struct net_device *dev)\n{\n\tstruct fe_priv *np = get_nvpriv(dev);\n\n\tnapi_enable(&np->napi);\n}\n\nstatic void nv_napi_disable(struct net_device *dev)\n{\n\tstruct fe_priv *np = get_nvpriv(dev);\n\n\tnapi_disable(&np->napi);\n}\n\n#define MII_READ\t(-1)\n/* mii_rw: read/write a register on the PHY.\n *\n * Caller must guarantee serialization\n */\nstatic int mii_rw(struct net_device *dev, int addr, int miireg, int value)\n{\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 reg;\n\tint retval;\n\n\twritel(NVREG_MIISTAT_MASK_RW, base + NvRegMIIStatus);\n\n\treg = readl(base + NvRegMIIControl);\n\tif (reg & NVREG_MIICTL_INUSE) {\n\t\twritel(NVREG_MIICTL_INUSE, base + NvRegMIIControl);\n\t\tudelay(NV_MIIBUSY_DELAY);\n\t}\n\n\treg = (addr << NVREG_MIICTL_ADDRSHIFT) | miireg;\n\tif (value != MII_READ) {\n\t\twritel(value, base + NvRegMIIData);\n\t\treg |= NVREG_MIICTL_WRITE;\n\t}\n\twritel(reg, base + NvRegMIIControl);\n\n\tif (reg_delay(dev, NvRegMIIControl, NVREG_MIICTL_INUSE, 0,\n\t\t\tNV_MIIPHY_DELAY, NV_MIIPHY_DELAYMAX)) {\n\t\tretval = -1;\n\t} else if (value != MII_READ) {\n\t\t/* it was a write operation - fewer failures are detectable */\n\t\tretval = 0;\n\t} else if (readl(base + NvRegMIIStatus) & NVREG_MIISTAT_ERROR) {\n\t\tretval = -1;\n\t} else {\n\t\tretval = readl(base + NvRegMIIData);\n\t}\n\n\treturn retval;\n}\n\nstatic int phy_reset(struct net_device *dev, u32 bmcr_setup)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu32 miicontrol;\n\tunsigned int tries = 0;\n\n\tmiicontrol = BMCR_RESET | bmcr_setup;\n\tif (mii_rw(dev, np->phyaddr, MII_BMCR, miicontrol))\n\t\treturn -1;\n\n\t/* wait for 500ms */\n\tmsleep(500);\n\n\t/* must wait till reset is deasserted */\n\twhile (miicontrol & BMCR_RESET) {\n\t\tusleep_range(10000, 20000);\n\t\tmiicontrol = mii_rw(dev, np->phyaddr, MII_BMCR, MII_READ);\n\t\t/* FIXME: 100 tries seem excessive */\n\t\tif (tries++ > 100)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int init_realtek_8211b(struct net_device *dev, struct fe_priv *np)\n{\n\tstatic const struct {\n\t\tint reg;\n\t\tint init;\n\t} ri[] = {\n\t\t{ PHY_REALTEK_INIT_REG1, PHY_REALTEK_INIT1 },\n\t\t{ PHY_REALTEK_INIT_REG2, PHY_REALTEK_INIT2 },\n\t\t{ PHY_REALTEK_INIT_REG1, PHY_REALTEK_INIT3 },\n\t\t{ PHY_REALTEK_INIT_REG3, PHY_REALTEK_INIT4 },\n\t\t{ PHY_REALTEK_INIT_REG4, PHY_REALTEK_INIT5 },\n\t\t{ PHY_REALTEK_INIT_REG5, PHY_REALTEK_INIT6 },\n\t\t{ PHY_REALTEK_INIT_REG1, PHY_REALTEK_INIT1 },\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ri); i++) {\n\t\tif (mii_rw(dev, np->phyaddr, ri[i].reg, ri[i].init))\n\t\t\treturn PHY_ERROR;\n\t}\n\n\treturn 0;\n}\n\nstatic int init_realtek_8211c(struct net_device *dev, struct fe_priv *np)\n{\n\tu32 reg;\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 powerstate = readl(base + NvRegPowerState2);\n\n\t/* need to perform hw phy reset */\n\tpowerstate |= NVREG_POWERSTATE2_PHY_RESET;\n\twritel(powerstate, base + NvRegPowerState2);\n\tmsleep(25);\n\n\tpowerstate &= ~NVREG_POWERSTATE2_PHY_RESET;\n\twritel(powerstate, base + NvRegPowerState2);\n\tmsleep(25);\n\n\treg = mii_rw(dev, np->phyaddr, PHY_REALTEK_INIT_REG6, MII_READ);\n\treg |= PHY_REALTEK_INIT9;\n\tif (mii_rw(dev, np->phyaddr, PHY_REALTEK_INIT_REG6, reg))\n\t\treturn PHY_ERROR;\n\tif (mii_rw(dev, np->phyaddr,\n\t\t   PHY_REALTEK_INIT_REG1, PHY_REALTEK_INIT10))\n\t\treturn PHY_ERROR;\n\treg = mii_rw(dev, np->phyaddr, PHY_REALTEK_INIT_REG7, MII_READ);\n\tif (!(reg & PHY_REALTEK_INIT11)) {\n\t\treg |= PHY_REALTEK_INIT11;\n\t\tif (mii_rw(dev, np->phyaddr, PHY_REALTEK_INIT_REG7, reg))\n\t\t\treturn PHY_ERROR;\n\t}\n\tif (mii_rw(dev, np->phyaddr,\n\t\t   PHY_REALTEK_INIT_REG1, PHY_REALTEK_INIT1))\n\t\treturn PHY_ERROR;\n\n\treturn 0;\n}\n\nstatic int init_realtek_8201(struct net_device *dev, struct fe_priv *np)\n{\n\tu32 phy_reserved;\n\n\tif (np->driver_data & DEV_NEED_PHY_INIT_FIX) {\n\t\tphy_reserved = mii_rw(dev, np->phyaddr,\n\t\t\t\t      PHY_REALTEK_INIT_REG6, MII_READ);\n\t\tphy_reserved |= PHY_REALTEK_INIT7;\n\t\tif (mii_rw(dev, np->phyaddr,\n\t\t\t   PHY_REALTEK_INIT_REG6, phy_reserved))\n\t\t\treturn PHY_ERROR;\n\t}\n\n\treturn 0;\n}\n\nstatic int init_realtek_8201_cross(struct net_device *dev, struct fe_priv *np)\n{\n\tu32 phy_reserved;\n\n\tif (phy_cross == NV_CROSSOVER_DETECTION_DISABLED) {\n\t\tif (mii_rw(dev, np->phyaddr,\n\t\t\t   PHY_REALTEK_INIT_REG1, PHY_REALTEK_INIT3))\n\t\t\treturn PHY_ERROR;\n\t\tphy_reserved = mii_rw(dev, np->phyaddr,\n\t\t\t\t      PHY_REALTEK_INIT_REG2, MII_READ);\n\t\tphy_reserved &= ~PHY_REALTEK_INIT_MSK1;\n\t\tphy_reserved |= PHY_REALTEK_INIT3;\n\t\tif (mii_rw(dev, np->phyaddr,\n\t\t\t   PHY_REALTEK_INIT_REG2, phy_reserved))\n\t\t\treturn PHY_ERROR;\n\t\tif (mii_rw(dev, np->phyaddr,\n\t\t\t   PHY_REALTEK_INIT_REG1, PHY_REALTEK_INIT1))\n\t\t\treturn PHY_ERROR;\n\t}\n\n\treturn 0;\n}\n\nstatic int init_cicada(struct net_device *dev, struct fe_priv *np,\n\t\t       u32 phyinterface)\n{\n\tu32 phy_reserved;\n\n\tif (phyinterface & PHY_RGMII) {\n\t\tphy_reserved = mii_rw(dev, np->phyaddr, MII_RESV1, MII_READ);\n\t\tphy_reserved &= ~(PHY_CICADA_INIT1 | PHY_CICADA_INIT2);\n\t\tphy_reserved |= (PHY_CICADA_INIT3 | PHY_CICADA_INIT4);\n\t\tif (mii_rw(dev, np->phyaddr, MII_RESV1, phy_reserved))\n\t\t\treturn PHY_ERROR;\n\t\tphy_reserved = mii_rw(dev, np->phyaddr, MII_NCONFIG, MII_READ);\n\t\tphy_reserved |= PHY_CICADA_INIT5;\n\t\tif (mii_rw(dev, np->phyaddr, MII_NCONFIG, phy_reserved))\n\t\t\treturn PHY_ERROR;\n\t}\n\tphy_reserved = mii_rw(dev, np->phyaddr, MII_SREVISION, MII_READ);\n\tphy_reserved |= PHY_CICADA_INIT6;\n\tif (mii_rw(dev, np->phyaddr, MII_SREVISION, phy_reserved))\n\t\treturn PHY_ERROR;\n\n\treturn 0;\n}\n\nstatic int init_vitesse(struct net_device *dev, struct fe_priv *np)\n{\n\tu32 phy_reserved;\n\n\tif (mii_rw(dev, np->phyaddr,\n\t\t   PHY_VITESSE_INIT_REG1, PHY_VITESSE_INIT1))\n\t\treturn PHY_ERROR;\n\tif (mii_rw(dev, np->phyaddr,\n\t\t   PHY_VITESSE_INIT_REG2, PHY_VITESSE_INIT2))\n\t\treturn PHY_ERROR;\n\tphy_reserved = mii_rw(dev, np->phyaddr,\n\t\t\t      PHY_VITESSE_INIT_REG4, MII_READ);\n\tif (mii_rw(dev, np->phyaddr, PHY_VITESSE_INIT_REG4, phy_reserved))\n\t\treturn PHY_ERROR;\n\tphy_reserved = mii_rw(dev, np->phyaddr,\n\t\t\t      PHY_VITESSE_INIT_REG3, MII_READ);\n\tphy_reserved &= ~PHY_VITESSE_INIT_MSK1;\n\tphy_reserved |= PHY_VITESSE_INIT3;\n\tif (mii_rw(dev, np->phyaddr, PHY_VITESSE_INIT_REG3, phy_reserved))\n\t\treturn PHY_ERROR;\n\tif (mii_rw(dev, np->phyaddr,\n\t\t   PHY_VITESSE_INIT_REG2, PHY_VITESSE_INIT4))\n\t\treturn PHY_ERROR;\n\tif (mii_rw(dev, np->phyaddr,\n\t\t   PHY_VITESSE_INIT_REG2, PHY_VITESSE_INIT5))\n\t\treturn PHY_ERROR;\n\tphy_reserved = mii_rw(dev, np->phyaddr,\n\t\t\t      PHY_VITESSE_INIT_REG4, MII_READ);\n\tphy_reserved &= ~PHY_VITESSE_INIT_MSK1;\n\tphy_reserved |= PHY_VITESSE_INIT3;\n\tif (mii_rw(dev, np->phyaddr, PHY_VITESSE_INIT_REG4, phy_reserved))\n\t\treturn PHY_ERROR;\n\tphy_reserved = mii_rw(dev, np->phyaddr,\n\t\t\t      PHY_VITESSE_INIT_REG3, MII_READ);\n\tif (mii_rw(dev, np->phyaddr, PHY_VITESSE_INIT_REG3, phy_reserved))\n\t\treturn PHY_ERROR;\n\tif (mii_rw(dev, np->phyaddr,\n\t\t   PHY_VITESSE_INIT_REG2, PHY_VITESSE_INIT6))\n\t\treturn PHY_ERROR;\n\tif (mii_rw(dev, np->phyaddr,\n\t\t   PHY_VITESSE_INIT_REG2, PHY_VITESSE_INIT7))\n\t\treturn PHY_ERROR;\n\tphy_reserved = mii_rw(dev, np->phyaddr,\n\t\t\t      PHY_VITESSE_INIT_REG4, MII_READ);\n\tif (mii_rw(dev, np->phyaddr, PHY_VITESSE_INIT_REG4, phy_reserved))\n\t\treturn PHY_ERROR;\n\tphy_reserved = mii_rw(dev, np->phyaddr,\n\t\t\t      PHY_VITESSE_INIT_REG3, MII_READ);\n\tphy_reserved &= ~PHY_VITESSE_INIT_MSK2;\n\tphy_reserved |= PHY_VITESSE_INIT8;\n\tif (mii_rw(dev, np->phyaddr, PHY_VITESSE_INIT_REG3, phy_reserved))\n\t\treturn PHY_ERROR;\n\tif (mii_rw(dev, np->phyaddr,\n\t\t   PHY_VITESSE_INIT_REG2, PHY_VITESSE_INIT9))\n\t\treturn PHY_ERROR;\n\tif (mii_rw(dev, np->phyaddr,\n\t\t   PHY_VITESSE_INIT_REG1, PHY_VITESSE_INIT10))\n\t\treturn PHY_ERROR;\n\n\treturn 0;\n}\n\nstatic int phy_init(struct net_device *dev)\n{\n\tstruct fe_priv *np = get_nvpriv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 phyinterface;\n\tu32 mii_status, mii_control, mii_control_1000, reg;\n\n\t/* phy errata for E3016 phy */\n\tif (np->phy_model == PHY_MODEL_MARVELL_E3016) {\n\t\treg = mii_rw(dev, np->phyaddr, MII_NCONFIG, MII_READ);\n\t\treg &= ~PHY_MARVELL_E3016_INITMASK;\n\t\tif (mii_rw(dev, np->phyaddr, MII_NCONFIG, reg)) {\n\t\t\tnetdev_info(dev, \"%s: phy write to errata reg failed\\n\",\n\t\t\t\t    pci_name(np->pci_dev));\n\t\t\treturn PHY_ERROR;\n\t\t}\n\t}\n\tif (np->phy_oui == PHY_OUI_REALTEK) {\n\t\tif (np->phy_model == PHY_MODEL_REALTEK_8211 &&\n\t\t    np->phy_rev == PHY_REV_REALTEK_8211B) {\n\t\t\tif (init_realtek_8211b(dev, np)) {\n\t\t\t\tnetdev_info(dev, \"%s: phy init failed\\n\",\n\t\t\t\t\t    pci_name(np->pci_dev));\n\t\t\t\treturn PHY_ERROR;\n\t\t\t}\n\t\t} else if (np->phy_model == PHY_MODEL_REALTEK_8211 &&\n\t\t\t   np->phy_rev == PHY_REV_REALTEK_8211C) {\n\t\t\tif (init_realtek_8211c(dev, np)) {\n\t\t\t\tnetdev_info(dev, \"%s: phy init failed\\n\",\n\t\t\t\t\t    pci_name(np->pci_dev));\n\t\t\t\treturn PHY_ERROR;\n\t\t\t}\n\t\t} else if (np->phy_model == PHY_MODEL_REALTEK_8201) {\n\t\t\tif (init_realtek_8201(dev, np)) {\n\t\t\t\tnetdev_info(dev, \"%s: phy init failed\\n\",\n\t\t\t\t\t    pci_name(np->pci_dev));\n\t\t\t\treturn PHY_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* set advertise register */\n\treg = mii_rw(dev, np->phyaddr, MII_ADVERTISE, MII_READ);\n\treg |= (ADVERTISE_10HALF | ADVERTISE_10FULL |\n\t\tADVERTISE_100HALF | ADVERTISE_100FULL |\n\t\tADVERTISE_PAUSE_ASYM | ADVERTISE_PAUSE_CAP);\n\tif (mii_rw(dev, np->phyaddr, MII_ADVERTISE, reg)) {\n\t\tnetdev_info(dev, \"%s: phy write to advertise failed\\n\",\n\t\t\t    pci_name(np->pci_dev));\n\t\treturn PHY_ERROR;\n\t}\n\n\t/* get phy interface type */\n\tphyinterface = readl(base + NvRegPhyInterface);\n\n\t/* see if gigabit phy */\n\tmii_status = mii_rw(dev, np->phyaddr, MII_BMSR, MII_READ);\n\tif (mii_status & PHY_GIGABIT) {\n\t\tnp->gigabit = PHY_GIGABIT;\n\t\tmii_control_1000 = mii_rw(dev, np->phyaddr,\n\t\t\t\t\t  MII_CTRL1000, MII_READ);\n\t\tmii_control_1000 &= ~ADVERTISE_1000HALF;\n\t\tif (phyinterface & PHY_RGMII)\n\t\t\tmii_control_1000 |= ADVERTISE_1000FULL;\n\t\telse\n\t\t\tmii_control_1000 &= ~ADVERTISE_1000FULL;\n\n\t\tif (mii_rw(dev, np->phyaddr, MII_CTRL1000, mii_control_1000)) {\n\t\t\tnetdev_info(dev, \"%s: phy init failed\\n\",\n\t\t\t\t    pci_name(np->pci_dev));\n\t\t\treturn PHY_ERROR;\n\t\t}\n\t} else\n\t\tnp->gigabit = 0;\n\n\tmii_control = mii_rw(dev, np->phyaddr, MII_BMCR, MII_READ);\n\tmii_control |= BMCR_ANENABLE;\n\n\tif (np->phy_oui == PHY_OUI_REALTEK &&\n\t    np->phy_model == PHY_MODEL_REALTEK_8211 &&\n\t    np->phy_rev == PHY_REV_REALTEK_8211C) {\n\t\t/* start autoneg since we already performed hw reset above */\n\t\tmii_control |= BMCR_ANRESTART;\n\t\tif (mii_rw(dev, np->phyaddr, MII_BMCR, mii_control)) {\n\t\t\tnetdev_info(dev, \"%s: phy init failed\\n\",\n\t\t\t\t    pci_name(np->pci_dev));\n\t\t\treturn PHY_ERROR;\n\t\t}\n\t} else {\n\t\t/* reset the phy\n\t\t * (certain phys need bmcr to be setup with reset)\n\t\t */\n\t\tif (phy_reset(dev, mii_control)) {\n\t\t\tnetdev_info(dev, \"%s: phy reset failed\\n\",\n\t\t\t\t    pci_name(np->pci_dev));\n\t\t\treturn PHY_ERROR;\n\t\t}\n\t}\n\n\t/* phy vendor specific configuration */\n\tif (np->phy_oui == PHY_OUI_CICADA) {\n\t\tif (init_cicada(dev, np, phyinterface)) {\n\t\t\tnetdev_info(dev, \"%s: phy init failed\\n\",\n\t\t\t\t    pci_name(np->pci_dev));\n\t\t\treturn PHY_ERROR;\n\t\t}\n\t} else if (np->phy_oui == PHY_OUI_VITESSE) {\n\t\tif (init_vitesse(dev, np)) {\n\t\t\tnetdev_info(dev, \"%s: phy init failed\\n\",\n\t\t\t\t    pci_name(np->pci_dev));\n\t\t\treturn PHY_ERROR;\n\t\t}\n\t} else if (np->phy_oui == PHY_OUI_REALTEK) {\n\t\tif (np->phy_model == PHY_MODEL_REALTEK_8211 &&\n\t\t    np->phy_rev == PHY_REV_REALTEK_8211B) {\n\t\t\t/* reset could have cleared these out, set them back */\n\t\t\tif (init_realtek_8211b(dev, np)) {\n\t\t\t\tnetdev_info(dev, \"%s: phy init failed\\n\",\n\t\t\t\t\t    pci_name(np->pci_dev));\n\t\t\t\treturn PHY_ERROR;\n\t\t\t}\n\t\t} else if (np->phy_model == PHY_MODEL_REALTEK_8201) {\n\t\t\tif (init_realtek_8201(dev, np) ||\n\t\t\t    init_realtek_8201_cross(dev, np)) {\n\t\t\t\tnetdev_info(dev, \"%s: phy init failed\\n\",\n\t\t\t\t\t    pci_name(np->pci_dev));\n\t\t\t\treturn PHY_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* some phys clear out pause advertisement on reset, set it back */\n\tmii_rw(dev, np->phyaddr, MII_ADVERTISE, reg);\n\n\t/* restart auto negotiation, power down phy */\n\tmii_control = mii_rw(dev, np->phyaddr, MII_BMCR, MII_READ);\n\tmii_control |= (BMCR_ANRESTART | BMCR_ANENABLE);\n\tif (phy_power_down)\n\t\tmii_control |= BMCR_PDOWN;\n\tif (mii_rw(dev, np->phyaddr, MII_BMCR, mii_control))\n\t\treturn PHY_ERROR;\n\n\treturn 0;\n}\n\nstatic void nv_start_rx(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 rx_ctrl = readl(base + NvRegReceiverControl);\n\n\t/* Already running? Stop it. */\n\tif ((readl(base + NvRegReceiverControl) & NVREG_RCVCTL_START) && !np->mac_in_use) {\n\t\trx_ctrl &= ~NVREG_RCVCTL_START;\n\t\twritel(rx_ctrl, base + NvRegReceiverControl);\n\t\tpci_push(base);\n\t}\n\twritel(np->linkspeed, base + NvRegLinkSpeed);\n\tpci_push(base);\n\trx_ctrl |= NVREG_RCVCTL_START;\n\tif (np->mac_in_use)\n\t\trx_ctrl &= ~NVREG_RCVCTL_RX_PATH_EN;\n\twritel(rx_ctrl, base + NvRegReceiverControl);\n\tpci_push(base);\n}\n\nstatic void nv_stop_rx(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 rx_ctrl = readl(base + NvRegReceiverControl);\n\n\tif (!np->mac_in_use)\n\t\trx_ctrl &= ~NVREG_RCVCTL_START;\n\telse\n\t\trx_ctrl |= NVREG_RCVCTL_RX_PATH_EN;\n\twritel(rx_ctrl, base + NvRegReceiverControl);\n\tif (reg_delay(dev, NvRegReceiverStatus, NVREG_RCVSTAT_BUSY, 0,\n\t\t      NV_RXSTOP_DELAY1, NV_RXSTOP_DELAY1MAX))\n\t\tnetdev_info(dev, \"%s: ReceiverStatus remained busy\\n\",\n\t\t\t    __func__);\n\n\tudelay(NV_RXSTOP_DELAY2);\n\tif (!np->mac_in_use)\n\t\twritel(0, base + NvRegLinkSpeed);\n}\n\nstatic void nv_start_tx(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 tx_ctrl = readl(base + NvRegTransmitterControl);\n\n\ttx_ctrl |= NVREG_XMITCTL_START;\n\tif (np->mac_in_use)\n\t\ttx_ctrl &= ~NVREG_XMITCTL_TX_PATH_EN;\n\twritel(tx_ctrl, base + NvRegTransmitterControl);\n\tpci_push(base);\n}\n\nstatic void nv_stop_tx(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 tx_ctrl = readl(base + NvRegTransmitterControl);\n\n\tif (!np->mac_in_use)\n\t\ttx_ctrl &= ~NVREG_XMITCTL_START;\n\telse\n\t\ttx_ctrl |= NVREG_XMITCTL_TX_PATH_EN;\n\twritel(tx_ctrl, base + NvRegTransmitterControl);\n\tif (reg_delay(dev, NvRegTransmitterStatus, NVREG_XMITSTAT_BUSY, 0,\n\t\t      NV_TXSTOP_DELAY1, NV_TXSTOP_DELAY1MAX))\n\t\tnetdev_info(dev, \"%s: TransmitterStatus remained busy\\n\",\n\t\t\t    __func__);\n\n\tudelay(NV_TXSTOP_DELAY2);\n\tif (!np->mac_in_use)\n\t\twritel(readl(base + NvRegTransmitPoll) & NVREG_TRANSMITPOLL_MAC_ADDR_REV,\n\t\t       base + NvRegTransmitPoll);\n}\n\nstatic void nv_start_rxtx(struct net_device *dev)\n{\n\tnv_start_rx(dev);\n\tnv_start_tx(dev);\n}\n\nstatic void nv_stop_rxtx(struct net_device *dev)\n{\n\tnv_stop_rx(dev);\n\tnv_stop_tx(dev);\n}\n\nstatic void nv_txrx_reset(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\n\twritel(NVREG_TXRXCTL_BIT2 | NVREG_TXRXCTL_RESET | np->txrxctl_bits, base + NvRegTxRxControl);\n\tpci_push(base);\n\tudelay(NV_TXRX_RESET_DELAY);\n\twritel(NVREG_TXRXCTL_BIT2 | np->txrxctl_bits, base + NvRegTxRxControl);\n\tpci_push(base);\n}\n\nstatic void nv_mac_reset(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 temp1, temp2, temp3;\n\n\twritel(NVREG_TXRXCTL_BIT2 | NVREG_TXRXCTL_RESET | np->txrxctl_bits, base + NvRegTxRxControl);\n\tpci_push(base);\n\n\t/* save registers since they will be cleared on reset */\n\ttemp1 = readl(base + NvRegMacAddrA);\n\ttemp2 = readl(base + NvRegMacAddrB);\n\ttemp3 = readl(base + NvRegTransmitPoll);\n\n\twritel(NVREG_MAC_RESET_ASSERT, base + NvRegMacReset);\n\tpci_push(base);\n\tudelay(NV_MAC_RESET_DELAY);\n\twritel(0, base + NvRegMacReset);\n\tpci_push(base);\n\tudelay(NV_MAC_RESET_DELAY);\n\n\t/* restore saved registers */\n\twritel(temp1, base + NvRegMacAddrA);\n\twritel(temp2, base + NvRegMacAddrB);\n\twritel(temp3, base + NvRegTransmitPoll);\n\n\twritel(NVREG_TXRXCTL_BIT2 | np->txrxctl_bits, base + NvRegTxRxControl);\n\tpci_push(base);\n}\n\n/* Caller must appropriately lock netdev_priv(dev)->hwstats_lock */\nstatic void nv_update_stats(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\n\t/* If it happens that this is run in top-half context, then\n\t * replace the spin_lock of hwstats_lock with\n\t * spin_lock_irqsave() in calling functions. */\n\tWARN_ONCE(in_irq(), \"forcedeth: estats spin_lock(_bh) from top-half\");\n\tassert_spin_locked(&np->hwstats_lock);\n\n\t/* query hardware */\n\tnp->estats.tx_bytes += readl(base + NvRegTxCnt);\n\tnp->estats.tx_zero_rexmt += readl(base + NvRegTxZeroReXmt);\n\tnp->estats.tx_one_rexmt += readl(base + NvRegTxOneReXmt);\n\tnp->estats.tx_many_rexmt += readl(base + NvRegTxManyReXmt);\n\tnp->estats.tx_late_collision += readl(base + NvRegTxLateCol);\n\tnp->estats.tx_fifo_errors += readl(base + NvRegTxUnderflow);\n\tnp->estats.tx_carrier_errors += readl(base + NvRegTxLossCarrier);\n\tnp->estats.tx_excess_deferral += readl(base + NvRegTxExcessDef);\n\tnp->estats.tx_retry_error += readl(base + NvRegTxRetryErr);\n\tnp->estats.rx_frame_error += readl(base + NvRegRxFrameErr);\n\tnp->estats.rx_extra_byte += readl(base + NvRegRxExtraByte);\n\tnp->estats.rx_late_collision += readl(base + NvRegRxLateCol);\n\tnp->estats.rx_runt += readl(base + NvRegRxRunt);\n\tnp->estats.rx_frame_too_long += readl(base + NvRegRxFrameTooLong);\n\tnp->estats.rx_over_errors += readl(base + NvRegRxOverflow);\n\tnp->estats.rx_crc_errors += readl(base + NvRegRxFCSErr);\n\tnp->estats.rx_frame_align_error += readl(base + NvRegRxFrameAlignErr);\n\tnp->estats.rx_length_error += readl(base + NvRegRxLenErr);\n\tnp->estats.rx_unicast += readl(base + NvRegRxUnicast);\n\tnp->estats.rx_multicast += readl(base + NvRegRxMulticast);\n\tnp->estats.rx_broadcast += readl(base + NvRegRxBroadcast);\n\tnp->estats.rx_packets =\n\t\tnp->estats.rx_unicast +\n\t\tnp->estats.rx_multicast +\n\t\tnp->estats.rx_broadcast;\n\tnp->estats.rx_errors_total =\n\t\tnp->estats.rx_crc_errors +\n\t\tnp->estats.rx_over_errors +\n\t\tnp->estats.rx_frame_error +\n\t\t(np->estats.rx_frame_align_error - np->estats.rx_extra_byte) +\n\t\tnp->estats.rx_late_collision +\n\t\tnp->estats.rx_runt +\n\t\tnp->estats.rx_frame_too_long;\n\tnp->estats.tx_errors_total =\n\t\tnp->estats.tx_late_collision +\n\t\tnp->estats.tx_fifo_errors +\n\t\tnp->estats.tx_carrier_errors +\n\t\tnp->estats.tx_excess_deferral +\n\t\tnp->estats.tx_retry_error;\n\n\tif (np->driver_data & DEV_HAS_STATISTICS_V2) {\n\t\tnp->estats.tx_deferral += readl(base + NvRegTxDef);\n\t\tnp->estats.tx_packets += readl(base + NvRegTxFrame);\n\t\tnp->estats.rx_bytes += readl(base + NvRegRxCnt);\n\t\tnp->estats.tx_pause += readl(base + NvRegTxPause);\n\t\tnp->estats.rx_pause += readl(base + NvRegRxPause);\n\t\tnp->estats.rx_drop_frame += readl(base + NvRegRxDropFrame);\n\t\tnp->estats.rx_errors_total += np->estats.rx_drop_frame;\n\t}\n\n\tif (np->driver_data & DEV_HAS_STATISTICS_V3) {\n\t\tnp->estats.tx_unicast += readl(base + NvRegTxUnicast);\n\t\tnp->estats.tx_multicast += readl(base + NvRegTxMulticast);\n\t\tnp->estats.tx_broadcast += readl(base + NvRegTxBroadcast);\n\t}\n}\n\nstatic void nv_get_stats(int cpu, struct fe_priv *np,\n\t\t\t struct rtnl_link_stats64 *storage)\n{\n\tstruct nv_txrx_stats *src = per_cpu_ptr(np->txrx_stats, cpu);\n\tunsigned int syncp_start;\n\tu64 rx_packets, rx_bytes, rx_dropped, rx_missed_errors;\n\tu64 tx_packets, tx_bytes, tx_dropped;\n\n\tdo {\n\t\tsyncp_start = u64_stats_fetch_begin_irq(&np->swstats_rx_syncp);\n\t\trx_packets       = src->stat_rx_packets;\n\t\trx_bytes         = src->stat_rx_bytes;\n\t\trx_dropped       = src->stat_rx_dropped;\n\t\trx_missed_errors = src->stat_rx_missed_errors;\n\t} while (u64_stats_fetch_retry_irq(&np->swstats_rx_syncp, syncp_start));\n\n\tstorage->rx_packets       += rx_packets;\n\tstorage->rx_bytes         += rx_bytes;\n\tstorage->rx_dropped       += rx_dropped;\n\tstorage->rx_missed_errors += rx_missed_errors;\n\n\tdo {\n\t\tsyncp_start = u64_stats_fetch_begin_irq(&np->swstats_tx_syncp);\n\t\ttx_packets  = src->stat_tx_packets;\n\t\ttx_bytes    = src->stat_tx_bytes;\n\t\ttx_dropped  = src->stat_tx_dropped;\n\t} while (u64_stats_fetch_retry_irq(&np->swstats_tx_syncp, syncp_start));\n\n\tstorage->tx_packets += tx_packets;\n\tstorage->tx_bytes   += tx_bytes;\n\tstorage->tx_dropped += tx_dropped;\n}\n\n/*\n * nv_get_stats64: dev->ndo_get_stats64 function\n * Get latest stats value from the nic.\n * Called with read_lock(&dev_base_lock) held for read -\n * only synchronized against unregister_netdevice.\n */\nstatic void\nnv_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *storage)\n\t__acquires(&netdev_priv(dev)->hwstats_lock)\n\t__releases(&netdev_priv(dev)->hwstats_lock)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tint cpu;\n\n\t/*\n\t * Note: because HW stats are not always available and for\n\t * consistency reasons, the following ifconfig stats are\n\t * managed by software: rx_bytes, tx_bytes, rx_packets and\n\t * tx_packets. The related hardware stats reported by ethtool\n\t * should be equivalent to these ifconfig stats, with 4\n\t * additional bytes per packet (Ethernet FCS CRC), except for\n\t * tx_packets when TSO kicks in.\n\t */\n\n\t/* software stats */\n\tfor_each_online_cpu(cpu)\n\t\tnv_get_stats(cpu, np, storage);\n\n\t/* If the nic supports hw counters then retrieve latest values */\n\tif (np->driver_data & DEV_HAS_STATISTICS_V123) {\n\t\tspin_lock_bh(&np->hwstats_lock);\n\n\t\tnv_update_stats(dev);\n\n\t\t/* generic stats */\n\t\tstorage->rx_errors = np->estats.rx_errors_total;\n\t\tstorage->tx_errors = np->estats.tx_errors_total;\n\n\t\t/* meaningful only when NIC supports stats v3 */\n\t\tstorage->multicast = np->estats.rx_multicast;\n\n\t\t/* detailed rx_errors */\n\t\tstorage->rx_length_errors = np->estats.rx_length_error;\n\t\tstorage->rx_over_errors   = np->estats.rx_over_errors;\n\t\tstorage->rx_crc_errors    = np->estats.rx_crc_errors;\n\t\tstorage->rx_frame_errors  = np->estats.rx_frame_align_error;\n\t\tstorage->rx_fifo_errors   = np->estats.rx_drop_frame;\n\n\t\t/* detailed tx_errors */\n\t\tstorage->tx_carrier_errors = np->estats.tx_carrier_errors;\n\t\tstorage->tx_fifo_errors    = np->estats.tx_fifo_errors;\n\n\t\tspin_unlock_bh(&np->hwstats_lock);\n\t}\n}\n\n/*\n * nv_alloc_rx: fill rx ring entries.\n * Return 1 if the allocations for the skbs failed and the\n * rx engine is without Available descriptors\n */\nstatic int nv_alloc_rx(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tstruct ring_desc *less_rx;\n\n\tless_rx = np->get_rx.orig;\n\tif (less_rx-- == np->rx_ring.orig)\n\t\tless_rx = np->last_rx.orig;\n\n\twhile (np->put_rx.orig != less_rx) {\n\t\tstruct sk_buff *skb = netdev_alloc_skb(dev, np->rx_buf_sz + NV_RX_ALLOC_PAD);\n\t\tif (likely(skb)) {\n\t\t\tnp->put_rx_ctx->skb = skb;\n\t\t\tnp->put_rx_ctx->dma = dma_map_single(&np->pci_dev->dev,\n\t\t\t\t\t\t\t     skb->data,\n\t\t\t\t\t\t\t     skb_tailroom(skb),\n\t\t\t\t\t\t\t     DMA_FROM_DEVICE);\n\t\t\tif (unlikely(dma_mapping_error(&np->pci_dev->dev,\n\t\t\t\t\t\t       np->put_rx_ctx->dma))) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto packet_dropped;\n\t\t\t}\n\t\t\tnp->put_rx_ctx->dma_len = skb_tailroom(skb);\n\t\t\tnp->put_rx.orig->buf = cpu_to_le32(np->put_rx_ctx->dma);\n\t\t\twmb();\n\t\t\tnp->put_rx.orig->flaglen = cpu_to_le32(np->rx_buf_sz | NV_RX_AVAIL);\n\t\t\tif (unlikely(np->put_rx.orig++ == np->last_rx.orig))\n\t\t\t\tnp->put_rx.orig = np->rx_ring.orig;\n\t\t\tif (unlikely(np->put_rx_ctx++ == np->last_rx_ctx))\n\t\t\t\tnp->put_rx_ctx = np->rx_skb;\n\t\t} else {\npacket_dropped:\n\t\t\tu64_stats_update_begin(&np->swstats_rx_syncp);\n\t\t\tnv_txrx_stats_inc(stat_rx_dropped);\n\t\t\tu64_stats_update_end(&np->swstats_rx_syncp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int nv_alloc_rx_optimized(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tstruct ring_desc_ex *less_rx;\n\n\tless_rx = np->get_rx.ex;\n\tif (less_rx-- == np->rx_ring.ex)\n\t\tless_rx = np->last_rx.ex;\n\n\twhile (np->put_rx.ex != less_rx) {\n\t\tstruct sk_buff *skb = netdev_alloc_skb(dev, np->rx_buf_sz + NV_RX_ALLOC_PAD);\n\t\tif (likely(skb)) {\n\t\t\tnp->put_rx_ctx->skb = skb;\n\t\t\tnp->put_rx_ctx->dma = dma_map_single(&np->pci_dev->dev,\n\t\t\t\t\t\t\t     skb->data,\n\t\t\t\t\t\t\t     skb_tailroom(skb),\n\t\t\t\t\t\t\t     DMA_FROM_DEVICE);\n\t\t\tif (unlikely(dma_mapping_error(&np->pci_dev->dev,\n\t\t\t\t\t\t       np->put_rx_ctx->dma))) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto packet_dropped;\n\t\t\t}\n\t\t\tnp->put_rx_ctx->dma_len = skb_tailroom(skb);\n\t\t\tnp->put_rx.ex->bufhigh = cpu_to_le32(dma_high(np->put_rx_ctx->dma));\n\t\t\tnp->put_rx.ex->buflow = cpu_to_le32(dma_low(np->put_rx_ctx->dma));\n\t\t\twmb();\n\t\t\tnp->put_rx.ex->flaglen = cpu_to_le32(np->rx_buf_sz | NV_RX2_AVAIL);\n\t\t\tif (unlikely(np->put_rx.ex++ == np->last_rx.ex))\n\t\t\t\tnp->put_rx.ex = np->rx_ring.ex;\n\t\t\tif (unlikely(np->put_rx_ctx++ == np->last_rx_ctx))\n\t\t\t\tnp->put_rx_ctx = np->rx_skb;\n\t\t} else {\npacket_dropped:\n\t\t\tu64_stats_update_begin(&np->swstats_rx_syncp);\n\t\t\tnv_txrx_stats_inc(stat_rx_dropped);\n\t\t\tu64_stats_update_end(&np->swstats_rx_syncp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* If rx bufs are exhausted called after 50ms to attempt to refresh */\nstatic void nv_do_rx_refill(struct timer_list *t)\n{\n\tstruct fe_priv *np = from_timer(np, t, oom_kick);\n\n\t/* Just reschedule NAPI rx processing */\n\tnapi_schedule(&np->napi);\n}\n\nstatic void nv_init_rx(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tint i;\n\n\tnp->get_rx = np->rx_ring;\n\tnp->put_rx = np->rx_ring;\n\n\tif (!nv_optimized(np))\n\t\tnp->last_rx.orig = &np->rx_ring.orig[np->rx_ring_size-1];\n\telse\n\t\tnp->last_rx.ex = &np->rx_ring.ex[np->rx_ring_size-1];\n\tnp->get_rx_ctx = np->rx_skb;\n\tnp->put_rx_ctx = np->rx_skb;\n\tnp->last_rx_ctx = &np->rx_skb[np->rx_ring_size-1];\n\n\tfor (i = 0; i < np->rx_ring_size; i++) {\n\t\tif (!nv_optimized(np)) {\n\t\t\tnp->rx_ring.orig[i].flaglen = 0;\n\t\t\tnp->rx_ring.orig[i].buf = 0;\n\t\t} else {\n\t\t\tnp->rx_ring.ex[i].flaglen = 0;\n\t\t\tnp->rx_ring.ex[i].txvlan = 0;\n\t\t\tnp->rx_ring.ex[i].bufhigh = 0;\n\t\t\tnp->rx_ring.ex[i].buflow = 0;\n\t\t}\n\t\tnp->rx_skb[i].skb = NULL;\n\t\tnp->rx_skb[i].dma = 0;\n\t}\n}\n\nstatic void nv_init_tx(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tint i;\n\n\tnp->get_tx = np->tx_ring;\n\tnp->put_tx = np->tx_ring;\n\n\tif (!nv_optimized(np))\n\t\tnp->last_tx.orig = &np->tx_ring.orig[np->tx_ring_size-1];\n\telse\n\t\tnp->last_tx.ex = &np->tx_ring.ex[np->tx_ring_size-1];\n\tnp->get_tx_ctx = np->tx_skb;\n\tnp->put_tx_ctx = np->tx_skb;\n\tnp->last_tx_ctx = &np->tx_skb[np->tx_ring_size-1];\n\tnetdev_reset_queue(np->dev);\n\tnp->tx_pkts_in_progress = 0;\n\tnp->tx_change_owner = NULL;\n\tnp->tx_end_flip = NULL;\n\tnp->tx_stop = 0;\n\n\tfor (i = 0; i < np->tx_ring_size; i++) {\n\t\tif (!nv_optimized(np)) {\n\t\t\tnp->tx_ring.orig[i].flaglen = 0;\n\t\t\tnp->tx_ring.orig[i].buf = 0;\n\t\t} else {\n\t\t\tnp->tx_ring.ex[i].flaglen = 0;\n\t\t\tnp->tx_ring.ex[i].txvlan = 0;\n\t\t\tnp->tx_ring.ex[i].bufhigh = 0;\n\t\t\tnp->tx_ring.ex[i].buflow = 0;\n\t\t}\n\t\tnp->tx_skb[i].skb = NULL;\n\t\tnp->tx_skb[i].dma = 0;\n\t\tnp->tx_skb[i].dma_len = 0;\n\t\tnp->tx_skb[i].dma_single = 0;\n\t\tnp->tx_skb[i].first_tx_desc = NULL;\n\t\tnp->tx_skb[i].next_tx_ctx = NULL;\n\t}\n}\n\nstatic int nv_init_ring(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\n\tnv_init_tx(dev);\n\tnv_init_rx(dev);\n\n\tif (!nv_optimized(np))\n\t\treturn nv_alloc_rx(dev);\n\telse\n\t\treturn nv_alloc_rx_optimized(dev);\n}\n\nstatic void nv_unmap_txskb(struct fe_priv *np, struct nv_skb_map *tx_skb)\n{\n\tif (tx_skb->dma) {\n\t\tif (tx_skb->dma_single)\n\t\t\tdma_unmap_single(&np->pci_dev->dev, tx_skb->dma,\n\t\t\t\t\t tx_skb->dma_len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\telse\n\t\t\tdma_unmap_page(&np->pci_dev->dev, tx_skb->dma,\n\t\t\t\t       tx_skb->dma_len,\n\t\t\t\t       DMA_TO_DEVICE);\n\t\ttx_skb->dma = 0;\n\t}\n}\n\nstatic int nv_release_txskb(struct fe_priv *np, struct nv_skb_map *tx_skb)\n{\n\tnv_unmap_txskb(np, tx_skb);\n\tif (tx_skb->skb) {\n\t\tdev_kfree_skb_any(tx_skb->skb);\n\t\ttx_skb->skb = NULL;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void nv_drain_tx(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tunsigned int i;\n\n\tfor (i = 0; i < np->tx_ring_size; i++) {\n\t\tif (!nv_optimized(np)) {\n\t\t\tnp->tx_ring.orig[i].flaglen = 0;\n\t\t\tnp->tx_ring.orig[i].buf = 0;\n\t\t} else {\n\t\t\tnp->tx_ring.ex[i].flaglen = 0;\n\t\t\tnp->tx_ring.ex[i].txvlan = 0;\n\t\t\tnp->tx_ring.ex[i].bufhigh = 0;\n\t\t\tnp->tx_ring.ex[i].buflow = 0;\n\t\t}\n\t\tif (nv_release_txskb(np, &np->tx_skb[i])) {\n\t\t\tu64_stats_update_begin(&np->swstats_tx_syncp);\n\t\t\tnv_txrx_stats_inc(stat_tx_dropped);\n\t\t\tu64_stats_update_end(&np->swstats_tx_syncp);\n\t\t}\n\t\tnp->tx_skb[i].dma = 0;\n\t\tnp->tx_skb[i].dma_len = 0;\n\t\tnp->tx_skb[i].dma_single = 0;\n\t\tnp->tx_skb[i].first_tx_desc = NULL;\n\t\tnp->tx_skb[i].next_tx_ctx = NULL;\n\t}\n\tnp->tx_pkts_in_progress = 0;\n\tnp->tx_change_owner = NULL;\n\tnp->tx_end_flip = NULL;\n}\n\nstatic void nv_drain_rx(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tint i;\n\n\tfor (i = 0; i < np->rx_ring_size; i++) {\n\t\tif (!nv_optimized(np)) {\n\t\t\tnp->rx_ring.orig[i].flaglen = 0;\n\t\t\tnp->rx_ring.orig[i].buf = 0;\n\t\t} else {\n\t\t\tnp->rx_ring.ex[i].flaglen = 0;\n\t\t\tnp->rx_ring.ex[i].txvlan = 0;\n\t\t\tnp->rx_ring.ex[i].bufhigh = 0;\n\t\t\tnp->rx_ring.ex[i].buflow = 0;\n\t\t}\n\t\twmb();\n\t\tif (np->rx_skb[i].skb) {\n\t\t\tdma_unmap_single(&np->pci_dev->dev, np->rx_skb[i].dma,\n\t\t\t\t\t (skb_end_pointer(np->rx_skb[i].skb) -\n\t\t\t\t\t np->rx_skb[i].skb->data),\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(np->rx_skb[i].skb);\n\t\t\tnp->rx_skb[i].skb = NULL;\n\t\t}\n\t}\n}\n\nstatic void nv_drain_rxtx(struct net_device *dev)\n{\n\tnv_drain_tx(dev);\n\tnv_drain_rx(dev);\n}\n\nstatic inline u32 nv_get_empty_tx_slots(struct fe_priv *np)\n{\n\treturn (u32)(np->tx_ring_size - ((np->tx_ring_size + (np->put_tx_ctx - np->get_tx_ctx)) % np->tx_ring_size));\n}\n\nstatic void nv_legacybackoff_reseed(struct net_device *dev)\n{\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 reg;\n\tu32 low;\n\tint tx_status = 0;\n\n\treg = readl(base + NvRegSlotTime) & ~NVREG_SLOTTIME_MASK;\n\tget_random_bytes(&low, sizeof(low));\n\treg |= low & NVREG_SLOTTIME_MASK;\n\n\t/* Need to stop tx before change takes effect.\n\t * Caller has already gained np->lock.\n\t */\n\ttx_status = readl(base + NvRegTransmitterControl) & NVREG_XMITCTL_START;\n\tif (tx_status)\n\t\tnv_stop_tx(dev);\n\tnv_stop_rx(dev);\n\twritel(reg, base + NvRegSlotTime);\n\tif (tx_status)\n\t\tnv_start_tx(dev);\n\tnv_start_rx(dev);\n}\n\n/* Gear Backoff Seeds */\n#define BACKOFF_SEEDSET_ROWS\t8\n#define BACKOFF_SEEDSET_LFSRS\t15\n\n/* Known Good seed sets */\nstatic const u32 main_seedset[BACKOFF_SEEDSET_ROWS][BACKOFF_SEEDSET_LFSRS] = {\n\t{145, 155, 165, 175, 185, 196, 235, 245, 255, 265, 275, 285, 660, 690, 874},\n\t{245, 255, 265, 575, 385, 298, 335, 345, 355, 366, 375, 385, 761, 790, 974},\n\t{145, 155, 165, 175, 185, 196, 235, 245, 255, 265, 275, 285, 660, 690, 874},\n\t{245, 255, 265, 575, 385, 298, 335, 345, 355, 366, 375, 386, 761, 790, 974},\n\t{266, 265, 276, 585, 397, 208, 345, 355, 365, 376, 385, 396, 771, 700, 984},\n\t{266, 265, 276, 586, 397, 208, 346, 355, 365, 376, 285, 396, 771, 700, 984},\n\t{366, 365, 376, 686, 497, 308, 447, 455, 466, 476, 485, 496, 871, 800,  84},\n\t{466, 465, 476, 786, 597, 408, 547, 555, 566, 576, 585, 597, 971, 900, 184} };\n\nstatic const u32 gear_seedset[BACKOFF_SEEDSET_ROWS][BACKOFF_SEEDSET_LFSRS] = {\n\t{251, 262, 273, 324, 319, 508, 375, 364, 341, 371, 398, 193, 375,  30, 295},\n\t{351, 375, 373, 469, 551, 639, 477, 464, 441, 472, 498, 293, 476, 130, 395},\n\t{351, 375, 373, 469, 551, 639, 477, 464, 441, 472, 498, 293, 476, 130, 397},\n\t{251, 262, 273, 324, 319, 508, 375, 364, 341, 371, 398, 193, 375,  30, 295},\n\t{251, 262, 273, 324, 319, 508, 375, 364, 341, 371, 398, 193, 375,  30, 295},\n\t{351, 375, 373, 469, 551, 639, 477, 464, 441, 472, 498, 293, 476, 130, 395},\n\t{351, 375, 373, 469, 551, 639, 477, 464, 441, 472, 498, 293, 476, 130, 395},\n\t{351, 375, 373, 469, 551, 639, 477, 464, 441, 472, 498, 293, 476, 130, 395} };\n\nstatic void nv_gear_backoff_reseed(struct net_device *dev)\n{\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 miniseed1, miniseed2, miniseed2_reversed, miniseed3, miniseed3_reversed;\n\tu32 temp, seedset, combinedSeed;\n\tint i;\n\n\t/* Setup seed for free running LFSR */\n\t/* We are going to read the time stamp counter 3 times\n\t   and swizzle bits around to increase randomness */\n\tget_random_bytes(&miniseed1, sizeof(miniseed1));\n\tminiseed1 &= 0x0fff;\n\tif (miniseed1 == 0)\n\t\tminiseed1 = 0xabc;\n\n\tget_random_bytes(&miniseed2, sizeof(miniseed2));\n\tminiseed2 &= 0x0fff;\n\tif (miniseed2 == 0)\n\t\tminiseed2 = 0xabc;\n\tminiseed2_reversed =\n\t\t((miniseed2 & 0xF00) >> 8) |\n\t\t (miniseed2 & 0x0F0) |\n\t\t ((miniseed2 & 0x00F) << 8);\n\n\tget_random_bytes(&miniseed3, sizeof(miniseed3));\n\tminiseed3 &= 0x0fff;\n\tif (miniseed3 == 0)\n\t\tminiseed3 = 0xabc;\n\tminiseed3_reversed =\n\t\t((miniseed3 & 0xF00) >> 8) |\n\t\t (miniseed3 & 0x0F0) |\n\t\t ((miniseed3 & 0x00F) << 8);\n\n\tcombinedSeed = ((miniseed1 ^ miniseed2_reversed) << 12) |\n\t\t       (miniseed2 ^ miniseed3_reversed);\n\n\t/* Seeds can not be zero */\n\tif ((combinedSeed & NVREG_BKOFFCTRL_SEED_MASK) == 0)\n\t\tcombinedSeed |= 0x08;\n\tif ((combinedSeed & (NVREG_BKOFFCTRL_SEED_MASK << NVREG_BKOFFCTRL_GEAR)) == 0)\n\t\tcombinedSeed |= 0x8000;\n\n\t/* No need to disable tx here */\n\ttemp = NVREG_BKOFFCTRL_DEFAULT | (0 << NVREG_BKOFFCTRL_SELECT);\n\ttemp |= combinedSeed & NVREG_BKOFFCTRL_SEED_MASK;\n\ttemp |= combinedSeed >> NVREG_BKOFFCTRL_GEAR;\n\twritel(temp, base + NvRegBackOffControl);\n\n\t/* Setup seeds for all gear LFSRs. */\n\tget_random_bytes(&seedset, sizeof(seedset));\n\tseedset = seedset % BACKOFF_SEEDSET_ROWS;\n\tfor (i = 1; i <= BACKOFF_SEEDSET_LFSRS; i++) {\n\t\ttemp = NVREG_BKOFFCTRL_DEFAULT | (i << NVREG_BKOFFCTRL_SELECT);\n\t\ttemp |= main_seedset[seedset][i-1] & 0x3ff;\n\t\ttemp |= ((gear_seedset[seedset][i-1] & 0x3ff) << NVREG_BKOFFCTRL_GEAR);\n\t\twritel(temp, base + NvRegBackOffControl);\n\t}\n}\n\n/*\n * nv_start_xmit: dev->hard_start_xmit function\n * Called with netif_tx_lock held.\n */\nstatic netdev_tx_t nv_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu32 tx_flags = 0;\n\tu32 tx_flags_extra = (np->desc_ver == DESC_VER_1 ? NV_TX_LASTPACKET : NV_TX2_LASTPACKET);\n\tunsigned int fragments = skb_shinfo(skb)->nr_frags;\n\tunsigned int i;\n\tu32 offset = 0;\n\tu32 bcnt;\n\tu32 size = skb_headlen(skb);\n\tu32 entries = (size >> NV_TX2_TSO_MAX_SHIFT) + ((size & (NV_TX2_TSO_MAX_SIZE-1)) ? 1 : 0);\n\tu32 empty_slots;\n\tstruct ring_desc *put_tx;\n\tstruct ring_desc *start_tx;\n\tstruct ring_desc *prev_tx;\n\tstruct nv_skb_map *prev_tx_ctx;\n\tstruct nv_skb_map *tmp_tx_ctx = NULL, *start_tx_ctx = NULL;\n\tunsigned long flags;\n\tnetdev_tx_t ret = NETDEV_TX_OK;\n\n\t/* add fragments to entries count */\n\tfor (i = 0; i < fragments; i++) {\n\t\tu32 frag_size = skb_frag_size(&skb_shinfo(skb)->frags[i]);\n\n\t\tentries += (frag_size >> NV_TX2_TSO_MAX_SHIFT) +\n\t\t\t   ((frag_size & (NV_TX2_TSO_MAX_SIZE-1)) ? 1 : 0);\n\t}\n\n\tspin_lock_irqsave(&np->lock, flags);\n\tempty_slots = nv_get_empty_tx_slots(np);\n\tif (unlikely(empty_slots <= entries)) {\n\t\tnetif_stop_queue(dev);\n\t\tnp->tx_stop = 1;\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\n\t\t/* When normal packets and/or xmit_more packets fill up\n\t\t * tx_desc, it is necessary to trigger NIC tx reg.\n\t\t */\n\t\tret = NETDEV_TX_BUSY;\n\t\tgoto txkick;\n\t}\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\tstart_tx = put_tx = np->put_tx.orig;\n\n\t/* setup the header buffer */\n\tdo {\n\t\tbcnt = (size > NV_TX2_TSO_MAX_SIZE) ? NV_TX2_TSO_MAX_SIZE : size;\n\t\tnp->put_tx_ctx->dma = dma_map_single(&np->pci_dev->dev,\n\t\t\t\t\t\t     skb->data + offset, bcnt,\n\t\t\t\t\t\t     DMA_TO_DEVICE);\n\t\tif (unlikely(dma_mapping_error(&np->pci_dev->dev,\n\t\t\t\t\t       np->put_tx_ctx->dma))) {\n\t\t\t/* on DMA mapping error - drop the packet */\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tu64_stats_update_begin(&np->swstats_tx_syncp);\n\t\t\tnv_txrx_stats_inc(stat_tx_dropped);\n\t\t\tu64_stats_update_end(&np->swstats_tx_syncp);\n\n\t\t\tret = NETDEV_TX_OK;\n\n\t\t\tgoto dma_error;\n\t\t}\n\t\tnp->put_tx_ctx->dma_len = bcnt;\n\t\tnp->put_tx_ctx->dma_single = 1;\n\t\tput_tx->buf = cpu_to_le32(np->put_tx_ctx->dma);\n\t\tput_tx->flaglen = cpu_to_le32((bcnt-1) | tx_flags);\n\n\t\ttx_flags = np->tx_flags;\n\t\toffset += bcnt;\n\t\tsize -= bcnt;\n\t\tif (unlikely(put_tx++ == np->last_tx.orig))\n\t\t\tput_tx = np->tx_ring.orig;\n\t\tif (unlikely(np->put_tx_ctx++ == np->last_tx_ctx))\n\t\t\tnp->put_tx_ctx = np->tx_skb;\n\t} while (size);\n\n\t/* setup the fragments */\n\tfor (i = 0; i < fragments; i++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\t\tu32 frag_size = skb_frag_size(frag);\n\t\toffset = 0;\n\n\t\tdo {\n\t\t\tif (!start_tx_ctx)\n\t\t\t\tstart_tx_ctx = tmp_tx_ctx = np->put_tx_ctx;\n\n\t\t\tbcnt = (frag_size > NV_TX2_TSO_MAX_SIZE) ? NV_TX2_TSO_MAX_SIZE : frag_size;\n\t\t\tnp->put_tx_ctx->dma = skb_frag_dma_map(\n\t\t\t\t\t\t\t&np->pci_dev->dev,\n\t\t\t\t\t\t\tfrag, offset,\n\t\t\t\t\t\t\tbcnt,\n\t\t\t\t\t\t\tDMA_TO_DEVICE);\n\t\t\tif (unlikely(dma_mapping_error(&np->pci_dev->dev,\n\t\t\t\t\t\t       np->put_tx_ctx->dma))) {\n\n\t\t\t\t/* Unwind the mapped fragments */\n\t\t\t\tdo {\n\t\t\t\t\tnv_unmap_txskb(np, start_tx_ctx);\n\t\t\t\t\tif (unlikely(tmp_tx_ctx++ == np->last_tx_ctx))\n\t\t\t\t\t\ttmp_tx_ctx = np->tx_skb;\n\t\t\t\t} while (tmp_tx_ctx != np->put_tx_ctx);\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tnp->put_tx_ctx = start_tx_ctx;\n\t\t\t\tu64_stats_update_begin(&np->swstats_tx_syncp);\n\t\t\t\tnv_txrx_stats_inc(stat_tx_dropped);\n\t\t\t\tu64_stats_update_end(&np->swstats_tx_syncp);\n\n\t\t\t\tret = NETDEV_TX_OK;\n\n\t\t\t\tgoto dma_error;\n\t\t\t}\n\n\t\t\tnp->put_tx_ctx->dma_len = bcnt;\n\t\t\tnp->put_tx_ctx->dma_single = 0;\n\t\t\tput_tx->buf = cpu_to_le32(np->put_tx_ctx->dma);\n\t\t\tput_tx->flaglen = cpu_to_le32((bcnt-1) | tx_flags);\n\n\t\t\toffset += bcnt;\n\t\t\tfrag_size -= bcnt;\n\t\t\tif (unlikely(put_tx++ == np->last_tx.orig))\n\t\t\t\tput_tx = np->tx_ring.orig;\n\t\t\tif (unlikely(np->put_tx_ctx++ == np->last_tx_ctx))\n\t\t\t\tnp->put_tx_ctx = np->tx_skb;\n\t\t} while (frag_size);\n\t}\n\n\tif (unlikely(put_tx == np->tx_ring.orig))\n\t\tprev_tx = np->last_tx.orig;\n\telse\n\t\tprev_tx = put_tx - 1;\n\n\tif (unlikely(np->put_tx_ctx == np->tx_skb))\n\t\tprev_tx_ctx = np->last_tx_ctx;\n\telse\n\t\tprev_tx_ctx = np->put_tx_ctx - 1;\n\n\t/* set last fragment flag  */\n\tprev_tx->flaglen |= cpu_to_le32(tx_flags_extra);\n\n\t/* save skb in this slot's context area */\n\tprev_tx_ctx->skb = skb;\n\n\tif (skb_is_gso(skb))\n\t\ttx_flags_extra = NV_TX2_TSO | (skb_shinfo(skb)->gso_size << NV_TX2_TSO_SHIFT);\n\telse\n\t\ttx_flags_extra = skb->ip_summed == CHECKSUM_PARTIAL ?\n\t\t\t NV_TX2_CHECKSUM_L3 | NV_TX2_CHECKSUM_L4 : 0;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\t/* set tx flags */\n\tstart_tx->flaglen |= cpu_to_le32(tx_flags | tx_flags_extra);\n\n\tnetdev_sent_queue(np->dev, skb->len);\n\n\tskb_tx_timestamp(skb);\n\n\tnp->put_tx.orig = put_tx;\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n\ntxkick:\n\tif (netif_queue_stopped(dev) || !netdev_xmit_more()) {\n\t\tu32 txrxctl_kick;\ndma_error:\n\t\ttxrxctl_kick = NVREG_TXRXCTL_KICK | np->txrxctl_bits;\n\t\twritel(txrxctl_kick, get_hwbase(dev) + NvRegTxRxControl);\n\t}\n\n\treturn ret;\n}\n\nstatic netdev_tx_t nv_start_xmit_optimized(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu32 tx_flags = 0;\n\tu32 tx_flags_extra;\n\tunsigned int fragments = skb_shinfo(skb)->nr_frags;\n\tunsigned int i;\n\tu32 offset = 0;\n\tu32 bcnt;\n\tu32 size = skb_headlen(skb);\n\tu32 entries = (size >> NV_TX2_TSO_MAX_SHIFT) + ((size & (NV_TX2_TSO_MAX_SIZE-1)) ? 1 : 0);\n\tu32 empty_slots;\n\tstruct ring_desc_ex *put_tx;\n\tstruct ring_desc_ex *start_tx;\n\tstruct ring_desc_ex *prev_tx;\n\tstruct nv_skb_map *prev_tx_ctx;\n\tstruct nv_skb_map *start_tx_ctx = NULL;\n\tstruct nv_skb_map *tmp_tx_ctx = NULL;\n\tunsigned long flags;\n\tnetdev_tx_t ret = NETDEV_TX_OK;\n\n\t/* add fragments to entries count */\n\tfor (i = 0; i < fragments; i++) {\n\t\tu32 frag_size = skb_frag_size(&skb_shinfo(skb)->frags[i]);\n\n\t\tentries += (frag_size >> NV_TX2_TSO_MAX_SHIFT) +\n\t\t\t   ((frag_size & (NV_TX2_TSO_MAX_SIZE-1)) ? 1 : 0);\n\t}\n\n\tspin_lock_irqsave(&np->lock, flags);\n\tempty_slots = nv_get_empty_tx_slots(np);\n\tif (unlikely(empty_slots <= entries)) {\n\t\tnetif_stop_queue(dev);\n\t\tnp->tx_stop = 1;\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\n\t\t/* When normal packets and/or xmit_more packets fill up\n\t\t * tx_desc, it is necessary to trigger NIC tx reg.\n\t\t */\n\t\tret = NETDEV_TX_BUSY;\n\n\t\tgoto txkick;\n\t}\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\tstart_tx = put_tx = np->put_tx.ex;\n\tstart_tx_ctx = np->put_tx_ctx;\n\n\t/* setup the header buffer */\n\tdo {\n\t\tbcnt = (size > NV_TX2_TSO_MAX_SIZE) ? NV_TX2_TSO_MAX_SIZE : size;\n\t\tnp->put_tx_ctx->dma = dma_map_single(&np->pci_dev->dev,\n\t\t\t\t\t\t     skb->data + offset, bcnt,\n\t\t\t\t\t\t     DMA_TO_DEVICE);\n\t\tif (unlikely(dma_mapping_error(&np->pci_dev->dev,\n\t\t\t\t\t       np->put_tx_ctx->dma))) {\n\t\t\t/* on DMA mapping error - drop the packet */\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tu64_stats_update_begin(&np->swstats_tx_syncp);\n\t\t\tnv_txrx_stats_inc(stat_tx_dropped);\n\t\t\tu64_stats_update_end(&np->swstats_tx_syncp);\n\n\t\t\tret = NETDEV_TX_OK;\n\n\t\t\tgoto dma_error;\n\t\t}\n\t\tnp->put_tx_ctx->dma_len = bcnt;\n\t\tnp->put_tx_ctx->dma_single = 1;\n\t\tput_tx->bufhigh = cpu_to_le32(dma_high(np->put_tx_ctx->dma));\n\t\tput_tx->buflow = cpu_to_le32(dma_low(np->put_tx_ctx->dma));\n\t\tput_tx->flaglen = cpu_to_le32((bcnt-1) | tx_flags);\n\n\t\ttx_flags = NV_TX2_VALID;\n\t\toffset += bcnt;\n\t\tsize -= bcnt;\n\t\tif (unlikely(put_tx++ == np->last_tx.ex))\n\t\t\tput_tx = np->tx_ring.ex;\n\t\tif (unlikely(np->put_tx_ctx++ == np->last_tx_ctx))\n\t\t\tnp->put_tx_ctx = np->tx_skb;\n\t} while (size);\n\n\t/* setup the fragments */\n\tfor (i = 0; i < fragments; i++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\t\tu32 frag_size = skb_frag_size(frag);\n\t\toffset = 0;\n\n\t\tdo {\n\t\t\tbcnt = (frag_size > NV_TX2_TSO_MAX_SIZE) ? NV_TX2_TSO_MAX_SIZE : frag_size;\n\t\t\tif (!start_tx_ctx)\n\t\t\t\tstart_tx_ctx = tmp_tx_ctx = np->put_tx_ctx;\n\t\t\tnp->put_tx_ctx->dma = skb_frag_dma_map(\n\t\t\t\t\t\t\t&np->pci_dev->dev,\n\t\t\t\t\t\t\tfrag, offset,\n\t\t\t\t\t\t\tbcnt,\n\t\t\t\t\t\t\tDMA_TO_DEVICE);\n\n\t\t\tif (unlikely(dma_mapping_error(&np->pci_dev->dev,\n\t\t\t\t\t\t       np->put_tx_ctx->dma))) {\n\n\t\t\t\t/* Unwind the mapped fragments */\n\t\t\t\tdo {\n\t\t\t\t\tnv_unmap_txskb(np, start_tx_ctx);\n\t\t\t\t\tif (unlikely(tmp_tx_ctx++ == np->last_tx_ctx))\n\t\t\t\t\t\ttmp_tx_ctx = np->tx_skb;\n\t\t\t\t} while (tmp_tx_ctx != np->put_tx_ctx);\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tnp->put_tx_ctx = start_tx_ctx;\n\t\t\t\tu64_stats_update_begin(&np->swstats_tx_syncp);\n\t\t\t\tnv_txrx_stats_inc(stat_tx_dropped);\n\t\t\t\tu64_stats_update_end(&np->swstats_tx_syncp);\n\n\t\t\t\tret = NETDEV_TX_OK;\n\n\t\t\t\tgoto dma_error;\n\t\t\t}\n\t\t\tnp->put_tx_ctx->dma_len = bcnt;\n\t\t\tnp->put_tx_ctx->dma_single = 0;\n\t\t\tput_tx->bufhigh = cpu_to_le32(dma_high(np->put_tx_ctx->dma));\n\t\t\tput_tx->buflow = cpu_to_le32(dma_low(np->put_tx_ctx->dma));\n\t\t\tput_tx->flaglen = cpu_to_le32((bcnt-1) | tx_flags);\n\n\t\t\toffset += bcnt;\n\t\t\tfrag_size -= bcnt;\n\t\t\tif (unlikely(put_tx++ == np->last_tx.ex))\n\t\t\t\tput_tx = np->tx_ring.ex;\n\t\t\tif (unlikely(np->put_tx_ctx++ == np->last_tx_ctx))\n\t\t\t\tnp->put_tx_ctx = np->tx_skb;\n\t\t} while (frag_size);\n\t}\n\n\tif (unlikely(put_tx == np->tx_ring.ex))\n\t\tprev_tx = np->last_tx.ex;\n\telse\n\t\tprev_tx = put_tx - 1;\n\n\tif (unlikely(np->put_tx_ctx == np->tx_skb))\n\t\tprev_tx_ctx = np->last_tx_ctx;\n\telse\n\t\tprev_tx_ctx = np->put_tx_ctx - 1;\n\n\t/* set last fragment flag  */\n\tprev_tx->flaglen |= cpu_to_le32(NV_TX2_LASTPACKET);\n\n\t/* save skb in this slot's context area */\n\tprev_tx_ctx->skb = skb;\n\n\tif (skb_is_gso(skb))\n\t\ttx_flags_extra = NV_TX2_TSO | (skb_shinfo(skb)->gso_size << NV_TX2_TSO_SHIFT);\n\telse\n\t\ttx_flags_extra = skb->ip_summed == CHECKSUM_PARTIAL ?\n\t\t\t NV_TX2_CHECKSUM_L3 | NV_TX2_CHECKSUM_L4 : 0;\n\n\t/* vlan tag */\n\tif (skb_vlan_tag_present(skb))\n\t\tstart_tx->txvlan = cpu_to_le32(NV_TX3_VLAN_TAG_PRESENT |\n\t\t\t\t\tskb_vlan_tag_get(skb));\n\telse\n\t\tstart_tx->txvlan = 0;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\tif (np->tx_limit) {\n\t\t/* Limit the number of outstanding tx. Setup all fragments, but\n\t\t * do not set the VALID bit on the first descriptor. Save a pointer\n\t\t * to that descriptor and also for next skb_map element.\n\t\t */\n\n\t\tif (np->tx_pkts_in_progress == NV_TX_LIMIT_COUNT) {\n\t\t\tif (!np->tx_change_owner)\n\t\t\t\tnp->tx_change_owner = start_tx_ctx;\n\n\t\t\t/* remove VALID bit */\n\t\t\ttx_flags &= ~NV_TX2_VALID;\n\t\t\tstart_tx_ctx->first_tx_desc = start_tx;\n\t\t\tstart_tx_ctx->next_tx_ctx = np->put_tx_ctx;\n\t\t\tnp->tx_end_flip = np->put_tx_ctx;\n\t\t} else {\n\t\t\tnp->tx_pkts_in_progress++;\n\t\t}\n\t}\n\n\t/* set tx flags */\n\tstart_tx->flaglen |= cpu_to_le32(tx_flags | tx_flags_extra);\n\n\tnetdev_sent_queue(np->dev, skb->len);\n\n\tskb_tx_timestamp(skb);\n\n\tnp->put_tx.ex = put_tx;\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n\ntxkick:\n\tif (netif_queue_stopped(dev) || !netdev_xmit_more()) {\n\t\tu32 txrxctl_kick;\ndma_error:\n\t\ttxrxctl_kick = NVREG_TXRXCTL_KICK | np->txrxctl_bits;\n\t\twritel(txrxctl_kick, get_hwbase(dev) + NvRegTxRxControl);\n\t}\n\n\treturn ret;\n}\n\nstatic inline void nv_tx_flip_ownership(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\n\tnp->tx_pkts_in_progress--;\n\tif (np->tx_change_owner) {\n\t\tnp->tx_change_owner->first_tx_desc->flaglen |=\n\t\t\tcpu_to_le32(NV_TX2_VALID);\n\t\tnp->tx_pkts_in_progress++;\n\n\t\tnp->tx_change_owner = np->tx_change_owner->next_tx_ctx;\n\t\tif (np->tx_change_owner == np->tx_end_flip)\n\t\t\tnp->tx_change_owner = NULL;\n\n\t\twritel(NVREG_TXRXCTL_KICK|np->txrxctl_bits, get_hwbase(dev) + NvRegTxRxControl);\n\t}\n}\n\n/*\n * nv_tx_done: check for completed packets, release the skbs.\n *\n * Caller must own np->lock.\n */\nstatic int nv_tx_done(struct net_device *dev, int limit)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu32 flags;\n\tint tx_work = 0;\n\tstruct ring_desc *orig_get_tx = np->get_tx.orig;\n\tunsigned int bytes_compl = 0;\n\n\twhile ((np->get_tx.orig != np->put_tx.orig) &&\n\t       !((flags = le32_to_cpu(np->get_tx.orig->flaglen)) & NV_TX_VALID) &&\n\t       (tx_work < limit)) {\n\n\t\tnv_unmap_txskb(np, np->get_tx_ctx);\n\n\t\tif (np->desc_ver == DESC_VER_1) {\n\t\t\tif (flags & NV_TX_LASTPACKET) {\n\t\t\t\tif (unlikely(flags & NV_TX_ERROR)) {\n\t\t\t\t\tif ((flags & NV_TX_RETRYERROR)\n\t\t\t\t\t    && !(flags & NV_TX_RETRYCOUNT_MASK))\n\t\t\t\t\t\tnv_legacybackoff_reseed(dev);\n\t\t\t\t} else {\n\t\t\t\t\tunsigned int len;\n\n\t\t\t\t\tu64_stats_update_begin(&np->swstats_tx_syncp);\n\t\t\t\t\tnv_txrx_stats_inc(stat_tx_packets);\n\t\t\t\t\tlen = np->get_tx_ctx->skb->len;\n\t\t\t\t\tnv_txrx_stats_add(stat_tx_bytes, len);\n\t\t\t\t\tu64_stats_update_end(&np->swstats_tx_syncp);\n\t\t\t\t}\n\t\t\t\tbytes_compl += np->get_tx_ctx->skb->len;\n\t\t\t\tdev_kfree_skb_any(np->get_tx_ctx->skb);\n\t\t\t\tnp->get_tx_ctx->skb = NULL;\n\t\t\t\ttx_work++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (flags & NV_TX2_LASTPACKET) {\n\t\t\t\tif (unlikely(flags & NV_TX2_ERROR)) {\n\t\t\t\t\tif ((flags & NV_TX2_RETRYERROR)\n\t\t\t\t\t    && !(flags & NV_TX2_RETRYCOUNT_MASK))\n\t\t\t\t\t\tnv_legacybackoff_reseed(dev);\n\t\t\t\t} else {\n\t\t\t\t\tunsigned int len;\n\n\t\t\t\t\tu64_stats_update_begin(&np->swstats_tx_syncp);\n\t\t\t\t\tnv_txrx_stats_inc(stat_tx_packets);\n\t\t\t\t\tlen = np->get_tx_ctx->skb->len;\n\t\t\t\t\tnv_txrx_stats_add(stat_tx_bytes, len);\n\t\t\t\t\tu64_stats_update_end(&np->swstats_tx_syncp);\n\t\t\t\t}\n\t\t\t\tbytes_compl += np->get_tx_ctx->skb->len;\n\t\t\t\tdev_kfree_skb_any(np->get_tx_ctx->skb);\n\t\t\t\tnp->get_tx_ctx->skb = NULL;\n\t\t\t\ttx_work++;\n\t\t\t}\n\t\t}\n\t\tif (unlikely(np->get_tx.orig++ == np->last_tx.orig))\n\t\t\tnp->get_tx.orig = np->tx_ring.orig;\n\t\tif (unlikely(np->get_tx_ctx++ == np->last_tx_ctx))\n\t\t\tnp->get_tx_ctx = np->tx_skb;\n\t}\n\n\tnetdev_completed_queue(np->dev, tx_work, bytes_compl);\n\n\tif (unlikely((np->tx_stop == 1) && (np->get_tx.orig != orig_get_tx))) {\n\t\tnp->tx_stop = 0;\n\t\tnetif_wake_queue(dev);\n\t}\n\treturn tx_work;\n}\n\nstatic int nv_tx_done_optimized(struct net_device *dev, int limit)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu32 flags;\n\tint tx_work = 0;\n\tstruct ring_desc_ex *orig_get_tx = np->get_tx.ex;\n\tunsigned long bytes_cleaned = 0;\n\n\twhile ((np->get_tx.ex != np->put_tx.ex) &&\n\t       !((flags = le32_to_cpu(np->get_tx.ex->flaglen)) & NV_TX2_VALID) &&\n\t       (tx_work < limit)) {\n\n\t\tnv_unmap_txskb(np, np->get_tx_ctx);\n\n\t\tif (flags & NV_TX2_LASTPACKET) {\n\t\t\tif (unlikely(flags & NV_TX2_ERROR)) {\n\t\t\t\tif ((flags & NV_TX2_RETRYERROR)\n\t\t\t\t    && !(flags & NV_TX2_RETRYCOUNT_MASK)) {\n\t\t\t\t\tif (np->driver_data & DEV_HAS_GEAR_MODE)\n\t\t\t\t\t\tnv_gear_backoff_reseed(dev);\n\t\t\t\t\telse\n\t\t\t\t\t\tnv_legacybackoff_reseed(dev);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tunsigned int len;\n\n\t\t\t\tu64_stats_update_begin(&np->swstats_tx_syncp);\n\t\t\t\tnv_txrx_stats_inc(stat_tx_packets);\n\t\t\t\tlen = np->get_tx_ctx->skb->len;\n\t\t\t\tnv_txrx_stats_add(stat_tx_bytes, len);\n\t\t\t\tu64_stats_update_end(&np->swstats_tx_syncp);\n\t\t\t}\n\n\t\t\tbytes_cleaned += np->get_tx_ctx->skb->len;\n\t\t\tdev_kfree_skb_any(np->get_tx_ctx->skb);\n\t\t\tnp->get_tx_ctx->skb = NULL;\n\t\t\ttx_work++;\n\n\t\t\tif (np->tx_limit)\n\t\t\t\tnv_tx_flip_ownership(dev);\n\t\t}\n\n\t\tif (unlikely(np->get_tx.ex++ == np->last_tx.ex))\n\t\t\tnp->get_tx.ex = np->tx_ring.ex;\n\t\tif (unlikely(np->get_tx_ctx++ == np->last_tx_ctx))\n\t\t\tnp->get_tx_ctx = np->tx_skb;\n\t}\n\n\tnetdev_completed_queue(np->dev, tx_work, bytes_cleaned);\n\n\tif (unlikely((np->tx_stop == 1) && (np->get_tx.ex != orig_get_tx))) {\n\t\tnp->tx_stop = 0;\n\t\tnetif_wake_queue(dev);\n\t}\n\treturn tx_work;\n}\n\n/*\n * nv_tx_timeout: dev->tx_timeout function\n * Called with netif_tx_lock held.\n */\nstatic void nv_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 status;\n\tunion ring_type put_tx;\n\tint saved_tx_limit;\n\n\tif (np->msi_flags & NV_MSI_X_ENABLED)\n\t\tstatus = readl(base + NvRegMSIXIrqStatus) & NVREG_IRQSTAT_MASK;\n\telse\n\t\tstatus = readl(base + NvRegIrqStatus) & NVREG_IRQSTAT_MASK;\n\n\tnetdev_warn(dev, \"Got tx_timeout. irq status: %08x\\n\", status);\n\n\tif (unlikely(debug_tx_timeout)) {\n\t\tint i;\n\n\t\tnetdev_info(dev, \"Ring at %lx\\n\", (unsigned long)np->ring_addr);\n\t\tnetdev_info(dev, \"Dumping tx registers\\n\");\n\t\tfor (i = 0; i <= np->register_size; i += 32) {\n\t\t\tnetdev_info(dev,\n\t\t\t\t    \"%3x: %08x %08x %08x %08x \"\n\t\t\t\t    \"%08x %08x %08x %08x\\n\",\n\t\t\t\t    i,\n\t\t\t\t    readl(base + i + 0), readl(base + i + 4),\n\t\t\t\t    readl(base + i + 8), readl(base + i + 12),\n\t\t\t\t    readl(base + i + 16), readl(base + i + 20),\n\t\t\t\t    readl(base + i + 24), readl(base + i + 28));\n\t\t}\n\t\tnetdev_info(dev, \"Dumping tx ring\\n\");\n\t\tfor (i = 0; i < np->tx_ring_size; i += 4) {\n\t\t\tif (!nv_optimized(np)) {\n\t\t\t\tnetdev_info(dev,\n\t\t\t\t\t    \"%03x: %08x %08x // %08x %08x \"\n\t\t\t\t\t    \"// %08x %08x // %08x %08x\\n\",\n\t\t\t\t\t    i,\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.orig[i].buf),\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.orig[i].flaglen),\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.orig[i+1].buf),\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.orig[i+1].flaglen),\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.orig[i+2].buf),\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.orig[i+2].flaglen),\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.orig[i+3].buf),\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.orig[i+3].flaglen));\n\t\t\t} else {\n\t\t\t\tnetdev_info(dev,\n\t\t\t\t\t    \"%03x: %08x %08x %08x \"\n\t\t\t\t\t    \"// %08x %08x %08x \"\n\t\t\t\t\t    \"// %08x %08x %08x \"\n\t\t\t\t\t    \"// %08x %08x %08x\\n\",\n\t\t\t\t\t    i,\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.ex[i].bufhigh),\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.ex[i].buflow),\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.ex[i].flaglen),\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.ex[i+1].bufhigh),\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.ex[i+1].buflow),\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.ex[i+1].flaglen),\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.ex[i+2].bufhigh),\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.ex[i+2].buflow),\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.ex[i+2].flaglen),\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.ex[i+3].bufhigh),\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.ex[i+3].buflow),\n\t\t\t\t\t    le32_to_cpu(np->tx_ring.ex[i+3].flaglen));\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock_irq(&np->lock);\n\n\t/* 1) stop tx engine */\n\tnv_stop_tx(dev);\n\n\t/* 2) complete any outstanding tx and do not give HW any limited tx pkts */\n\tsaved_tx_limit = np->tx_limit;\n\tnp->tx_limit = 0; /* prevent giving HW any limited pkts */\n\tnp->tx_stop = 0;  /* prevent waking tx queue */\n\tif (!nv_optimized(np))\n\t\tnv_tx_done(dev, np->tx_ring_size);\n\telse\n\t\tnv_tx_done_optimized(dev, np->tx_ring_size);\n\n\t/* save current HW position */\n\tif (np->tx_change_owner)\n\t\tput_tx.ex = np->tx_change_owner->first_tx_desc;\n\telse\n\t\tput_tx = np->put_tx;\n\n\t/* 3) clear all tx state */\n\tnv_drain_tx(dev);\n\tnv_init_tx(dev);\n\n\t/* 4) restore state to current HW position */\n\tnp->get_tx = np->put_tx = put_tx;\n\tnp->tx_limit = saved_tx_limit;\n\n\t/* 5) restart tx engine */\n\tnv_start_tx(dev);\n\tnetif_wake_queue(dev);\n\tspin_unlock_irq(&np->lock);\n}\n\n/*\n * Called when the nic notices a mismatch between the actual data len on the\n * wire and the len indicated in the 802 header\n */\nstatic int nv_getlen(struct net_device *dev, void *packet, int datalen)\n{\n\tint hdrlen;\t/* length of the 802 header */\n\tint protolen;\t/* length as stored in the proto field */\n\n\t/* 1) calculate len according to header */\n\tif (((struct vlan_ethhdr *)packet)->h_vlan_proto == htons(ETH_P_8021Q)) {\n\t\tprotolen = ntohs(((struct vlan_ethhdr *)packet)->h_vlan_encapsulated_proto);\n\t\thdrlen = VLAN_HLEN;\n\t} else {\n\t\tprotolen = ntohs(((struct ethhdr *)packet)->h_proto);\n\t\thdrlen = ETH_HLEN;\n\t}\n\tif (protolen > ETH_DATA_LEN)\n\t\treturn datalen; /* Value in proto field not a len, no checks possible */\n\n\tprotolen += hdrlen;\n\t/* consistency checks: */\n\tif (datalen > ETH_ZLEN) {\n\t\tif (datalen >= protolen) {\n\t\t\t/* more data on wire than in 802 header, trim of\n\t\t\t * additional data.\n\t\t\t */\n\t\t\treturn protolen;\n\t\t} else {\n\t\t\t/* less data on wire than mentioned in header.\n\t\t\t * Discard the packet.\n\t\t\t */\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t/* short packet. Accept only if 802 values are also short */\n\t\tif (protolen > ETH_ZLEN) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn datalen;\n\t}\n}\n\nstatic void rx_missing_handler(u32 flags, struct fe_priv *np)\n{\n\tif (flags & NV_RX_MISSEDFRAME) {\n\t\tu64_stats_update_begin(&np->swstats_rx_syncp);\n\t\tnv_txrx_stats_inc(stat_rx_missed_errors);\n\t\tu64_stats_update_end(&np->swstats_rx_syncp);\n\t}\n}\n\nstatic int nv_rx_process(struct net_device *dev, int limit)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu32 flags;\n\tint rx_work = 0;\n\tstruct sk_buff *skb;\n\tint len;\n\n\twhile ((np->get_rx.orig != np->put_rx.orig) &&\n\t      !((flags = le32_to_cpu(np->get_rx.orig->flaglen)) & NV_RX_AVAIL) &&\n\t\t(rx_work < limit)) {\n\n\t\t/*\n\t\t * the packet is for us - immediately tear down the pci mapping.\n\t\t * TODO: check if a prefetch of the first cacheline improves\n\t\t * the performance.\n\t\t */\n\t\tdma_unmap_single(&np->pci_dev->dev, np->get_rx_ctx->dma,\n\t\t\t\t np->get_rx_ctx->dma_len,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tskb = np->get_rx_ctx->skb;\n\t\tnp->get_rx_ctx->skb = NULL;\n\n\t\t/* look at what we actually got: */\n\t\tif (np->desc_ver == DESC_VER_1) {\n\t\t\tif (likely(flags & NV_RX_DESCRIPTORVALID)) {\n\t\t\t\tlen = flags & LEN_MASK_V1;\n\t\t\t\tif (unlikely(flags & NV_RX_ERROR)) {\n\t\t\t\t\tif ((flags & NV_RX_ERROR_MASK) == NV_RX_ERROR4) {\n\t\t\t\t\t\tlen = nv_getlen(dev, skb->data, len);\n\t\t\t\t\t\tif (len < 0) {\n\t\t\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\t\t\t\tgoto next_pkt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* framing errors are soft errors */\n\t\t\t\t\telse if ((flags & NV_RX_ERROR_MASK) == NV_RX_FRAMINGERR) {\n\t\t\t\t\t\tif (flags & NV_RX_SUBTRACT1)\n\t\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t\t/* the rest are hard errors */\n\t\t\t\t\telse {\n\t\t\t\t\t\trx_missing_handler(flags, np);\n\t\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\t\t\tgoto next_pkt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tgoto next_pkt;\n\t\t\t}\n\t\t} else {\n\t\t\tif (likely(flags & NV_RX2_DESCRIPTORVALID)) {\n\t\t\t\tlen = flags & LEN_MASK_V2;\n\t\t\t\tif (unlikely(flags & NV_RX2_ERROR)) {\n\t\t\t\t\tif ((flags & NV_RX2_ERROR_MASK) == NV_RX2_ERROR4) {\n\t\t\t\t\t\tlen = nv_getlen(dev, skb->data, len);\n\t\t\t\t\t\tif (len < 0) {\n\t\t\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\t\t\t\tgoto next_pkt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* framing errors are soft errors */\n\t\t\t\t\telse if ((flags & NV_RX2_ERROR_MASK) == NV_RX2_FRAMINGERR) {\n\t\t\t\t\t\tif (flags & NV_RX2_SUBTRACT1)\n\t\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t\t/* the rest are hard errors */\n\t\t\t\t\telse {\n\t\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\t\t\tgoto next_pkt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (((flags & NV_RX2_CHECKSUMMASK) == NV_RX2_CHECKSUM_IP_TCP) || /*ip and tcp */\n\t\t\t\t    ((flags & NV_RX2_CHECKSUMMASK) == NV_RX2_CHECKSUM_IP_UDP))   /*ip and udp */\n\t\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\t} else {\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tgoto next_pkt;\n\t\t\t}\n\t\t}\n\t\t/* got a valid packet - forward it to the network core */\n\t\tskb_put(skb, len);\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tnapi_gro_receive(&np->napi, skb);\n\t\tu64_stats_update_begin(&np->swstats_rx_syncp);\n\t\tnv_txrx_stats_inc(stat_rx_packets);\n\t\tnv_txrx_stats_add(stat_rx_bytes, len);\n\t\tu64_stats_update_end(&np->swstats_rx_syncp);\nnext_pkt:\n\t\tif (unlikely(np->get_rx.orig++ == np->last_rx.orig))\n\t\t\tnp->get_rx.orig = np->rx_ring.orig;\n\t\tif (unlikely(np->get_rx_ctx++ == np->last_rx_ctx))\n\t\t\tnp->get_rx_ctx = np->rx_skb;\n\n\t\trx_work++;\n\t}\n\n\treturn rx_work;\n}\n\nstatic int nv_rx_process_optimized(struct net_device *dev, int limit)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu32 flags;\n\tu32 vlanflags = 0;\n\tint rx_work = 0;\n\tstruct sk_buff *skb;\n\tint len;\n\n\twhile ((np->get_rx.ex != np->put_rx.ex) &&\n\t      !((flags = le32_to_cpu(np->get_rx.ex->flaglen)) & NV_RX2_AVAIL) &&\n\t      (rx_work < limit)) {\n\n\t\t/*\n\t\t * the packet is for us - immediately tear down the pci mapping.\n\t\t * TODO: check if a prefetch of the first cacheline improves\n\t\t * the performance.\n\t\t */\n\t\tdma_unmap_single(&np->pci_dev->dev, np->get_rx_ctx->dma,\n\t\t\t\t np->get_rx_ctx->dma_len,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tskb = np->get_rx_ctx->skb;\n\t\tnp->get_rx_ctx->skb = NULL;\n\n\t\t/* look at what we actually got: */\n\t\tif (likely(flags & NV_RX2_DESCRIPTORVALID)) {\n\t\t\tlen = flags & LEN_MASK_V2;\n\t\t\tif (unlikely(flags & NV_RX2_ERROR)) {\n\t\t\t\tif ((flags & NV_RX2_ERROR_MASK) == NV_RX2_ERROR4) {\n\t\t\t\t\tlen = nv_getlen(dev, skb->data, len);\n\t\t\t\t\tif (len < 0) {\n\t\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\t\t\tgoto next_pkt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* framing errors are soft errors */\n\t\t\t\telse if ((flags & NV_RX2_ERROR_MASK) == NV_RX2_FRAMINGERR) {\n\t\t\t\t\tif (flags & NV_RX2_SUBTRACT1)\n\t\t\t\t\t\tlen--;\n\t\t\t\t}\n\t\t\t\t/* the rest are hard errors */\n\t\t\t\telse {\n\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\t\tgoto next_pkt;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (((flags & NV_RX2_CHECKSUMMASK) == NV_RX2_CHECKSUM_IP_TCP) || /*ip and tcp */\n\t\t\t    ((flags & NV_RX2_CHECKSUMMASK) == NV_RX2_CHECKSUM_IP_UDP))   /*ip and udp */\n\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\t\t\t/* got a valid packet - forward it to the network core */\n\t\t\tskb_put(skb, len);\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tprefetch(skb->data);\n\n\t\t\tvlanflags = le32_to_cpu(np->get_rx.ex->buflow);\n\n\t\t\t/*\n\t\t\t * There's need to check for NETIF_F_HW_VLAN_CTAG_RX\n\t\t\t * here. Even if vlan rx accel is disabled,\n\t\t\t * NV_RX3_VLAN_TAG_PRESENT is pseudo randomly set.\n\t\t\t */\n\t\t\tif (dev->features & NETIF_F_HW_VLAN_CTAG_RX &&\n\t\t\t    vlanflags & NV_RX3_VLAN_TAG_PRESENT) {\n\t\t\t\tu16 vid = vlanflags & NV_RX3_VLAN_TAG_MASK;\n\n\t\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);\n\t\t\t}\n\t\t\tnapi_gro_receive(&np->napi, skb);\n\t\t\tu64_stats_update_begin(&np->swstats_rx_syncp);\n\t\t\tnv_txrx_stats_inc(stat_rx_packets);\n\t\t\tnv_txrx_stats_add(stat_rx_bytes, len);\n\t\t\tu64_stats_update_end(&np->swstats_rx_syncp);\n\t\t} else {\n\t\t\tdev_kfree_skb(skb);\n\t\t}\nnext_pkt:\n\t\tif (unlikely(np->get_rx.ex++ == np->last_rx.ex))\n\t\t\tnp->get_rx.ex = np->rx_ring.ex;\n\t\tif (unlikely(np->get_rx_ctx++ == np->last_rx_ctx))\n\t\t\tnp->get_rx_ctx = np->rx_skb;\n\n\t\trx_work++;\n\t}\n\n\treturn rx_work;\n}\n\nstatic void set_bufsize(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\n\tif (dev->mtu <= ETH_DATA_LEN)\n\t\tnp->rx_buf_sz = ETH_DATA_LEN + NV_RX_HEADERS;\n\telse\n\t\tnp->rx_buf_sz = dev->mtu + NV_RX_HEADERS;\n}\n\n/*\n * nv_change_mtu: dev->change_mtu function\n * Called with dev_base_lock held for read.\n */\nstatic int nv_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tint old_mtu;\n\n\told_mtu = dev->mtu;\n\tdev->mtu = new_mtu;\n\n\t/* return early if the buffer sizes will not change */\n\tif (old_mtu <= ETH_DATA_LEN && new_mtu <= ETH_DATA_LEN)\n\t\treturn 0;\n\n\t/* synchronized against open : rtnl_lock() held by caller */\n\tif (netif_running(dev)) {\n\t\tu8 __iomem *base = get_hwbase(dev);\n\t\t/*\n\t\t * It seems that the nic preloads valid ring entries into an\n\t\t * internal buffer. The procedure for flushing everything is\n\t\t * guessed, there is probably a simpler approach.\n\t\t * Changing the MTU is a rare event, it shouldn't matter.\n\t\t */\n\t\tnv_disable_irq(dev);\n\t\tnv_napi_disable(dev);\n\t\tnetif_tx_lock_bh(dev);\n\t\tnetif_addr_lock(dev);\n\t\tspin_lock(&np->lock);\n\t\t/* stop engines */\n\t\tnv_stop_rxtx(dev);\n\t\tnv_txrx_reset(dev);\n\t\t/* drain rx queue */\n\t\tnv_drain_rxtx(dev);\n\t\t/* reinit driver view of the rx queue */\n\t\tset_bufsize(dev);\n\t\tif (nv_init_ring(dev)) {\n\t\t\tif (!np->in_shutdown)\n\t\t\t\tmod_timer(&np->oom_kick, jiffies + OOM_REFILL);\n\t\t}\n\t\t/* reinit nic view of the rx queue */\n\t\twritel(np->rx_buf_sz, base + NvRegOffloadConfig);\n\t\tsetup_hw_rings(dev, NV_SETUP_RX_RING | NV_SETUP_TX_RING);\n\t\twritel(((np->rx_ring_size-1) << NVREG_RINGSZ_RXSHIFT) + ((np->tx_ring_size-1) << NVREG_RINGSZ_TXSHIFT),\n\t\t\tbase + NvRegRingSizes);\n\t\tpci_push(base);\n\t\twritel(NVREG_TXRXCTL_KICK|np->txrxctl_bits, get_hwbase(dev) + NvRegTxRxControl);\n\t\tpci_push(base);\n\n\t\t/* restart rx engine */\n\t\tnv_start_rxtx(dev);\n\t\tspin_unlock(&np->lock);\n\t\tnetif_addr_unlock(dev);\n\t\tnetif_tx_unlock_bh(dev);\n\t\tnv_napi_enable(dev);\n\t\tnv_enable_irq(dev);\n\t}\n\treturn 0;\n}\n\nstatic void nv_copy_mac_to_hw(struct net_device *dev)\n{\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 mac[2];\n\n\tmac[0] = (dev->dev_addr[0] << 0) + (dev->dev_addr[1] << 8) +\n\t\t\t(dev->dev_addr[2] << 16) + (dev->dev_addr[3] << 24);\n\tmac[1] = (dev->dev_addr[4] << 0) + (dev->dev_addr[5] << 8);\n\n\twritel(mac[0], base + NvRegMacAddrA);\n\twritel(mac[1], base + NvRegMacAddrB);\n}\n\n/*\n * nv_set_mac_address: dev->set_mac_address function\n * Called with rtnl_lock() held.\n */\nstatic int nv_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tstruct sockaddr *macaddr = (struct sockaddr *)addr;\n\n\tif (!is_valid_ether_addr(macaddr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* synchronized against open : rtnl_lock() held by caller */\n\tmemcpy(dev->dev_addr, macaddr->sa_data, ETH_ALEN);\n\n\tif (netif_running(dev)) {\n\t\tnetif_tx_lock_bh(dev);\n\t\tnetif_addr_lock(dev);\n\t\tspin_lock_irq(&np->lock);\n\n\t\t/* stop rx engine */\n\t\tnv_stop_rx(dev);\n\n\t\t/* set mac address */\n\t\tnv_copy_mac_to_hw(dev);\n\n\t\t/* restart rx engine */\n\t\tnv_start_rx(dev);\n\t\tspin_unlock_irq(&np->lock);\n\t\tnetif_addr_unlock(dev);\n\t\tnetif_tx_unlock_bh(dev);\n\t} else {\n\t\tnv_copy_mac_to_hw(dev);\n\t}\n\treturn 0;\n}\n\n/*\n * nv_set_multicast: dev->set_multicast function\n * Called with netif_tx_lock held.\n */\nstatic void nv_set_multicast(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 addr[2];\n\tu32 mask[2];\n\tu32 pff = readl(base + NvRegPacketFilterFlags) & NVREG_PFF_PAUSE_RX;\n\n\tmemset(addr, 0, sizeof(addr));\n\tmemset(mask, 0, sizeof(mask));\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tpff |= NVREG_PFF_PROMISC;\n\t} else {\n\t\tpff |= NVREG_PFF_MYADDR;\n\n\t\tif (dev->flags & IFF_ALLMULTI || !netdev_mc_empty(dev)) {\n\t\t\tu32 alwaysOff[2];\n\t\t\tu32 alwaysOn[2];\n\n\t\t\talwaysOn[0] = alwaysOn[1] = alwaysOff[0] = alwaysOff[1] = 0xffffffff;\n\t\t\tif (dev->flags & IFF_ALLMULTI) {\n\t\t\t\talwaysOn[0] = alwaysOn[1] = alwaysOff[0] = alwaysOff[1] = 0;\n\t\t\t} else {\n\t\t\t\tstruct netdev_hw_addr *ha;\n\n\t\t\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\t\t\tunsigned char *hw_addr = ha->addr;\n\t\t\t\t\tu32 a, b;\n\n\t\t\t\t\ta = le32_to_cpu(*(__le32 *) hw_addr);\n\t\t\t\t\tb = le16_to_cpu(*(__le16 *) (&hw_addr[4]));\n\t\t\t\t\talwaysOn[0] &= a;\n\t\t\t\t\talwaysOff[0] &= ~a;\n\t\t\t\t\talwaysOn[1] &= b;\n\t\t\t\t\talwaysOff[1] &= ~b;\n\t\t\t\t}\n\t\t\t}\n\t\t\taddr[0] = alwaysOn[0];\n\t\t\taddr[1] = alwaysOn[1];\n\t\t\tmask[0] = alwaysOn[0] | alwaysOff[0];\n\t\t\tmask[1] = alwaysOn[1] | alwaysOff[1];\n\t\t} else {\n\t\t\tmask[0] = NVREG_MCASTMASKA_NONE;\n\t\t\tmask[1] = NVREG_MCASTMASKB_NONE;\n\t\t}\n\t}\n\taddr[0] |= NVREG_MCASTADDRA_FORCE;\n\tpff |= NVREG_PFF_ALWAYS;\n\tspin_lock_irq(&np->lock);\n\tnv_stop_rx(dev);\n\twritel(addr[0], base + NvRegMulticastAddrA);\n\twritel(addr[1], base + NvRegMulticastAddrB);\n\twritel(mask[0], base + NvRegMulticastMaskA);\n\twritel(mask[1], base + NvRegMulticastMaskB);\n\twritel(pff, base + NvRegPacketFilterFlags);\n\tnv_start_rx(dev);\n\tspin_unlock_irq(&np->lock);\n}\n\nstatic void nv_update_pause(struct net_device *dev, u32 pause_flags)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\n\tnp->pause_flags &= ~(NV_PAUSEFRAME_TX_ENABLE | NV_PAUSEFRAME_RX_ENABLE);\n\n\tif (np->pause_flags & NV_PAUSEFRAME_RX_CAPABLE) {\n\t\tu32 pff = readl(base + NvRegPacketFilterFlags) & ~NVREG_PFF_PAUSE_RX;\n\t\tif (pause_flags & NV_PAUSEFRAME_RX_ENABLE) {\n\t\t\twritel(pff|NVREG_PFF_PAUSE_RX, base + NvRegPacketFilterFlags);\n\t\t\tnp->pause_flags |= NV_PAUSEFRAME_RX_ENABLE;\n\t\t} else {\n\t\t\twritel(pff, base + NvRegPacketFilterFlags);\n\t\t}\n\t}\n\tif (np->pause_flags & NV_PAUSEFRAME_TX_CAPABLE) {\n\t\tu32 regmisc = readl(base + NvRegMisc1) & ~NVREG_MISC1_PAUSE_TX;\n\t\tif (pause_flags & NV_PAUSEFRAME_TX_ENABLE) {\n\t\t\tu32 pause_enable = NVREG_TX_PAUSEFRAME_ENABLE_V1;\n\t\t\tif (np->driver_data & DEV_HAS_PAUSEFRAME_TX_V2)\n\t\t\t\tpause_enable = NVREG_TX_PAUSEFRAME_ENABLE_V2;\n\t\t\tif (np->driver_data & DEV_HAS_PAUSEFRAME_TX_V3) {\n\t\t\t\tpause_enable = NVREG_TX_PAUSEFRAME_ENABLE_V3;\n\t\t\t\t/* limit the number of tx pause frames to a default of 8 */\n\t\t\t\twritel(readl(base + NvRegTxPauseFrameLimit)|NVREG_TX_PAUSEFRAMELIMIT_ENABLE, base + NvRegTxPauseFrameLimit);\n\t\t\t}\n\t\t\twritel(pause_enable,  base + NvRegTxPauseFrame);\n\t\t\twritel(regmisc|NVREG_MISC1_PAUSE_TX, base + NvRegMisc1);\n\t\t\tnp->pause_flags |= NV_PAUSEFRAME_TX_ENABLE;\n\t\t} else {\n\t\t\twritel(NVREG_TX_PAUSEFRAME_DISABLE,  base + NvRegTxPauseFrame);\n\t\t\twritel(regmisc, base + NvRegMisc1);\n\t\t}\n\t}\n}\n\nstatic void nv_force_linkspeed(struct net_device *dev, int speed, int duplex)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 phyreg, txreg;\n\tint mii_status;\n\n\tnp->linkspeed = NVREG_LINKSPEED_FORCE|speed;\n\tnp->duplex = duplex;\n\n\t/* see if gigabit phy */\n\tmii_status = mii_rw(dev, np->phyaddr, MII_BMSR, MII_READ);\n\tif (mii_status & PHY_GIGABIT) {\n\t\tnp->gigabit = PHY_GIGABIT;\n\t\tphyreg = readl(base + NvRegSlotTime);\n\t\tphyreg &= ~(0x3FF00);\n\t\tif ((np->linkspeed & 0xFFF) == NVREG_LINKSPEED_10)\n\t\t\tphyreg |= NVREG_SLOTTIME_10_100_FULL;\n\t\telse if ((np->linkspeed & 0xFFF) == NVREG_LINKSPEED_100)\n\t\t\tphyreg |= NVREG_SLOTTIME_10_100_FULL;\n\t\telse if ((np->linkspeed & 0xFFF) == NVREG_LINKSPEED_1000)\n\t\t\tphyreg |= NVREG_SLOTTIME_1000_FULL;\n\t\twritel(phyreg, base + NvRegSlotTime);\n\t}\n\n\tphyreg = readl(base + NvRegPhyInterface);\n\tphyreg &= ~(PHY_HALF|PHY_100|PHY_1000);\n\tif (np->duplex == 0)\n\t\tphyreg |= PHY_HALF;\n\tif ((np->linkspeed & NVREG_LINKSPEED_MASK) == NVREG_LINKSPEED_100)\n\t\tphyreg |= PHY_100;\n\telse if ((np->linkspeed & NVREG_LINKSPEED_MASK) ==\n\t\t\t\t\t\t\tNVREG_LINKSPEED_1000)\n\t\tphyreg |= PHY_1000;\n\twritel(phyreg, base + NvRegPhyInterface);\n\n\tif (phyreg & PHY_RGMII) {\n\t\tif ((np->linkspeed & NVREG_LINKSPEED_MASK) ==\n\t\t\t\t\t\t\tNVREG_LINKSPEED_1000)\n\t\t\ttxreg = NVREG_TX_DEFERRAL_RGMII_1000;\n\t\telse\n\t\t\ttxreg = NVREG_TX_DEFERRAL_RGMII_10_100;\n\t} else {\n\t\ttxreg = NVREG_TX_DEFERRAL_DEFAULT;\n\t}\n\twritel(txreg, base + NvRegTxDeferral);\n\n\tif (np->desc_ver == DESC_VER_1) {\n\t\ttxreg = NVREG_TX_WM_DESC1_DEFAULT;\n\t} else {\n\t\tif ((np->linkspeed & NVREG_LINKSPEED_MASK) ==\n\t\t\t\t\t NVREG_LINKSPEED_1000)\n\t\t\ttxreg = NVREG_TX_WM_DESC2_3_1000;\n\t\telse\n\t\t\ttxreg = NVREG_TX_WM_DESC2_3_DEFAULT;\n\t}\n\twritel(txreg, base + NvRegTxWatermark);\n\n\twritel(NVREG_MISC1_FORCE | (np->duplex ? 0 : NVREG_MISC1_HD),\n\t\t\tbase + NvRegMisc1);\n\tpci_push(base);\n\twritel(np->linkspeed, base + NvRegLinkSpeed);\n\tpci_push(base);\n}\n\n/**\n * nv_update_linkspeed - Setup the MAC according to the link partner\n * @dev: Network device to be configured\n *\n * The function queries the PHY and checks if there is a link partner.\n * If yes, then it sets up the MAC accordingly. Otherwise, the MAC is\n * set to 10 MBit HD.\n *\n * The function returns 0 if there is no link partner and 1 if there is\n * a good link partner.\n */\nstatic int nv_update_linkspeed(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tint adv = 0;\n\tint lpa = 0;\n\tint adv_lpa, adv_pause, lpa_pause;\n\tint newls = np->linkspeed;\n\tint newdup = np->duplex;\n\tint mii_status;\n\tu32 bmcr;\n\tint retval = 0;\n\tu32 control_1000, status_1000, phyreg, pause_flags, txreg;\n\tu32 txrxFlags = 0;\n\tu32 phy_exp;\n\n\t/* If device loopback is enabled, set carrier on and enable max link\n\t * speed.\n\t */\n\tbmcr = mii_rw(dev, np->phyaddr, MII_BMCR, MII_READ);\n\tif (bmcr & BMCR_LOOPBACK) {\n\t\tif (netif_running(dev)) {\n\t\t\tnv_force_linkspeed(dev, NVREG_LINKSPEED_1000, 1);\n\t\t\tif (!netif_carrier_ok(dev))\n\t\t\t\tnetif_carrier_on(dev);\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/* BMSR_LSTATUS is latched, read it twice:\n\t * we want the current value.\n\t */\n\tmii_rw(dev, np->phyaddr, MII_BMSR, MII_READ);\n\tmii_status = mii_rw(dev, np->phyaddr, MII_BMSR, MII_READ);\n\n\tif (!(mii_status & BMSR_LSTATUS)) {\n\t\tnewls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_10;\n\t\tnewdup = 0;\n\t\tretval = 0;\n\t\tgoto set_speed;\n\t}\n\n\tif (np->autoneg == 0) {\n\t\tif (np->fixed_mode & LPA_100FULL) {\n\t\t\tnewls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_100;\n\t\t\tnewdup = 1;\n\t\t} else if (np->fixed_mode & LPA_100HALF) {\n\t\t\tnewls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_100;\n\t\t\tnewdup = 0;\n\t\t} else if (np->fixed_mode & LPA_10FULL) {\n\t\t\tnewls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_10;\n\t\t\tnewdup = 1;\n\t\t} else {\n\t\t\tnewls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_10;\n\t\t\tnewdup = 0;\n\t\t}\n\t\tretval = 1;\n\t\tgoto set_speed;\n\t}\n\t/* check auto negotiation is complete */\n\tif (!(mii_status & BMSR_ANEGCOMPLETE)) {\n\t\t/* still in autonegotiation - configure nic for 10 MBit HD and wait. */\n\t\tnewls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_10;\n\t\tnewdup = 0;\n\t\tretval = 0;\n\t\tgoto set_speed;\n\t}\n\n\tadv = mii_rw(dev, np->phyaddr, MII_ADVERTISE, MII_READ);\n\tlpa = mii_rw(dev, np->phyaddr, MII_LPA, MII_READ);\n\n\tretval = 1;\n\tif (np->gigabit == PHY_GIGABIT) {\n\t\tcontrol_1000 = mii_rw(dev, np->phyaddr, MII_CTRL1000, MII_READ);\n\t\tstatus_1000 = mii_rw(dev, np->phyaddr, MII_STAT1000, MII_READ);\n\n\t\tif ((control_1000 & ADVERTISE_1000FULL) &&\n\t\t\t(status_1000 & LPA_1000FULL)) {\n\t\t\tnewls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_1000;\n\t\t\tnewdup = 1;\n\t\t\tgoto set_speed;\n\t\t}\n\t}\n\n\t/* FIXME: handle parallel detection properly */\n\tadv_lpa = lpa & adv;\n\tif (adv_lpa & LPA_100FULL) {\n\t\tnewls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_100;\n\t\tnewdup = 1;\n\t} else if (adv_lpa & LPA_100HALF) {\n\t\tnewls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_100;\n\t\tnewdup = 0;\n\t} else if (adv_lpa & LPA_10FULL) {\n\t\tnewls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_10;\n\t\tnewdup = 1;\n\t} else if (adv_lpa & LPA_10HALF) {\n\t\tnewls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_10;\n\t\tnewdup = 0;\n\t} else {\n\t\tnewls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_10;\n\t\tnewdup = 0;\n\t}\n\nset_speed:\n\tif (np->duplex == newdup && np->linkspeed == newls)\n\t\treturn retval;\n\n\tnp->duplex = newdup;\n\tnp->linkspeed = newls;\n\n\t/* The transmitter and receiver must be restarted for safe update */\n\tif (readl(base + NvRegTransmitterControl) & NVREG_XMITCTL_START) {\n\t\ttxrxFlags |= NV_RESTART_TX;\n\t\tnv_stop_tx(dev);\n\t}\n\tif (readl(base + NvRegReceiverControl) & NVREG_RCVCTL_START) {\n\t\ttxrxFlags |= NV_RESTART_RX;\n\t\tnv_stop_rx(dev);\n\t}\n\n\tif (np->gigabit == PHY_GIGABIT) {\n\t\tphyreg = readl(base + NvRegSlotTime);\n\t\tphyreg &= ~(0x3FF00);\n\t\tif (((np->linkspeed & 0xFFF) == NVREG_LINKSPEED_10) ||\n\t\t    ((np->linkspeed & 0xFFF) == NVREG_LINKSPEED_100))\n\t\t\tphyreg |= NVREG_SLOTTIME_10_100_FULL;\n\t\telse if ((np->linkspeed & 0xFFF) == NVREG_LINKSPEED_1000)\n\t\t\tphyreg |= NVREG_SLOTTIME_1000_FULL;\n\t\twritel(phyreg, base + NvRegSlotTime);\n\t}\n\n\tphyreg = readl(base + NvRegPhyInterface);\n\tphyreg &= ~(PHY_HALF|PHY_100|PHY_1000);\n\tif (np->duplex == 0)\n\t\tphyreg |= PHY_HALF;\n\tif ((np->linkspeed & NVREG_LINKSPEED_MASK) == NVREG_LINKSPEED_100)\n\t\tphyreg |= PHY_100;\n\telse if ((np->linkspeed & NVREG_LINKSPEED_MASK) == NVREG_LINKSPEED_1000)\n\t\tphyreg |= PHY_1000;\n\twritel(phyreg, base + NvRegPhyInterface);\n\n\tphy_exp = mii_rw(dev, np->phyaddr, MII_EXPANSION, MII_READ) & EXPANSION_NWAY; /* autoneg capable */\n\tif (phyreg & PHY_RGMII) {\n\t\tif ((np->linkspeed & NVREG_LINKSPEED_MASK) == NVREG_LINKSPEED_1000) {\n\t\t\ttxreg = NVREG_TX_DEFERRAL_RGMII_1000;\n\t\t} else {\n\t\t\tif (!phy_exp && !np->duplex && (np->driver_data & DEV_HAS_COLLISION_FIX)) {\n\t\t\t\tif ((np->linkspeed & NVREG_LINKSPEED_MASK) == NVREG_LINKSPEED_10)\n\t\t\t\t\ttxreg = NVREG_TX_DEFERRAL_RGMII_STRETCH_10;\n\t\t\t\telse\n\t\t\t\t\ttxreg = NVREG_TX_DEFERRAL_RGMII_STRETCH_100;\n\t\t\t} else {\n\t\t\t\ttxreg = NVREG_TX_DEFERRAL_RGMII_10_100;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!phy_exp && !np->duplex && (np->driver_data & DEV_HAS_COLLISION_FIX))\n\t\t\ttxreg = NVREG_TX_DEFERRAL_MII_STRETCH;\n\t\telse\n\t\t\ttxreg = NVREG_TX_DEFERRAL_DEFAULT;\n\t}\n\twritel(txreg, base + NvRegTxDeferral);\n\n\tif (np->desc_ver == DESC_VER_1) {\n\t\ttxreg = NVREG_TX_WM_DESC1_DEFAULT;\n\t} else {\n\t\tif ((np->linkspeed & NVREG_LINKSPEED_MASK) == NVREG_LINKSPEED_1000)\n\t\t\ttxreg = NVREG_TX_WM_DESC2_3_1000;\n\t\telse\n\t\t\ttxreg = NVREG_TX_WM_DESC2_3_DEFAULT;\n\t}\n\twritel(txreg, base + NvRegTxWatermark);\n\n\twritel(NVREG_MISC1_FORCE | (np->duplex ? 0 : NVREG_MISC1_HD),\n\t\tbase + NvRegMisc1);\n\tpci_push(base);\n\twritel(np->linkspeed, base + NvRegLinkSpeed);\n\tpci_push(base);\n\n\tpause_flags = 0;\n\t/* setup pause frame */\n\tif (netif_running(dev) && (np->duplex != 0)) {\n\t\tif (np->autoneg && np->pause_flags & NV_PAUSEFRAME_AUTONEG) {\n\t\t\tadv_pause = adv & (ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);\n\t\t\tlpa_pause = lpa & (LPA_PAUSE_CAP | LPA_PAUSE_ASYM);\n\n\t\t\tswitch (adv_pause) {\n\t\t\tcase ADVERTISE_PAUSE_CAP:\n\t\t\t\tif (lpa_pause & LPA_PAUSE_CAP) {\n\t\t\t\t\tpause_flags |= NV_PAUSEFRAME_RX_ENABLE;\n\t\t\t\t\tif (np->pause_flags & NV_PAUSEFRAME_TX_REQ)\n\t\t\t\t\t\tpause_flags |= NV_PAUSEFRAME_TX_ENABLE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ADVERTISE_PAUSE_ASYM:\n\t\t\t\tif (lpa_pause == (LPA_PAUSE_CAP | LPA_PAUSE_ASYM))\n\t\t\t\t\tpause_flags |= NV_PAUSEFRAME_TX_ENABLE;\n\t\t\t\tbreak;\n\t\t\tcase ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM:\n\t\t\t\tif (lpa_pause & LPA_PAUSE_CAP) {\n\t\t\t\t\tpause_flags |=  NV_PAUSEFRAME_RX_ENABLE;\n\t\t\t\t\tif (np->pause_flags & NV_PAUSEFRAME_TX_REQ)\n\t\t\t\t\t\tpause_flags |= NV_PAUSEFRAME_TX_ENABLE;\n\t\t\t\t}\n\t\t\t\tif (lpa_pause == LPA_PAUSE_ASYM)\n\t\t\t\t\tpause_flags |= NV_PAUSEFRAME_RX_ENABLE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tpause_flags = np->pause_flags;\n\t\t}\n\t}\n\tnv_update_pause(dev, pause_flags);\n\n\tif (txrxFlags & NV_RESTART_TX)\n\t\tnv_start_tx(dev);\n\tif (txrxFlags & NV_RESTART_RX)\n\t\tnv_start_rx(dev);\n\n\treturn retval;\n}\n\nstatic void nv_linkchange(struct net_device *dev)\n{\n\tif (nv_update_linkspeed(dev)) {\n\t\tif (!netif_carrier_ok(dev)) {\n\t\t\tnetif_carrier_on(dev);\n\t\t\tnetdev_info(dev, \"link up\\n\");\n\t\t\tnv_txrx_gate(dev, false);\n\t\t\tnv_start_rx(dev);\n\t\t}\n\t} else {\n\t\tif (netif_carrier_ok(dev)) {\n\t\t\tnetif_carrier_off(dev);\n\t\t\tnetdev_info(dev, \"link down\\n\");\n\t\t\tnv_txrx_gate(dev, true);\n\t\t\tnv_stop_rx(dev);\n\t\t}\n\t}\n}\n\nstatic void nv_link_irq(struct net_device *dev)\n{\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 miistat;\n\n\tmiistat = readl(base + NvRegMIIStatus);\n\twritel(NVREG_MIISTAT_LINKCHANGE, base + NvRegMIIStatus);\n\n\tif (miistat & (NVREG_MIISTAT_LINKCHANGE))\n\t\tnv_linkchange(dev);\n}\n\nstatic void nv_msi_workaround(struct fe_priv *np)\n{\n\n\t/* Need to toggle the msi irq mask within the ethernet device,\n\t * otherwise, future interrupts will not be detected.\n\t */\n\tif (np->msi_flags & NV_MSI_ENABLED) {\n\t\tu8 __iomem *base = np->base;\n\n\t\twritel(0, base + NvRegMSIIrqMask);\n\t\twritel(NVREG_MSI_VECTOR_0_ENABLED, base + NvRegMSIIrqMask);\n\t}\n}\n\nstatic inline int nv_change_interrupt_mode(struct net_device *dev, int total_work)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\n\tif (optimization_mode == NV_OPTIMIZATION_MODE_DYNAMIC) {\n\t\tif (total_work > NV_DYNAMIC_THRESHOLD) {\n\t\t\t/* transition to poll based interrupts */\n\t\t\tnp->quiet_count = 0;\n\t\t\tif (np->irqmask != NVREG_IRQMASK_CPU) {\n\t\t\t\tnp->irqmask = NVREG_IRQMASK_CPU;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (np->quiet_count < NV_DYNAMIC_MAX_QUIET_COUNT) {\n\t\t\t\tnp->quiet_count++;\n\t\t\t} else {\n\t\t\t\t/* reached a period of low activity, switch\n\t\t\t\t   to per tx/rx packet interrupts */\n\t\t\t\tif (np->irqmask != NVREG_IRQMASK_THROUGHPUT) {\n\t\t\t\t\tnp->irqmask = NVREG_IRQMASK_THROUGHPUT;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic irqreturn_t nv_nic_irq(int foo, void *data)\n{\n\tstruct net_device *dev = (struct net_device *) data;\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\n\tif (!(np->msi_flags & NV_MSI_X_ENABLED)) {\n\t\tnp->events = readl(base + NvRegIrqStatus);\n\t\twritel(np->events, base + NvRegIrqStatus);\n\t} else {\n\t\tnp->events = readl(base + NvRegMSIXIrqStatus);\n\t\twritel(np->events, base + NvRegMSIXIrqStatus);\n\t}\n\tif (!(np->events & np->irqmask))\n\t\treturn IRQ_NONE;\n\n\tnv_msi_workaround(np);\n\n\tif (napi_schedule_prep(&np->napi)) {\n\t\t/*\n\t\t * Disable further irq's (msix not enabled with napi)\n\t\t */\n\t\twritel(0, base + NvRegIrqMask);\n\t\t__napi_schedule(&np->napi);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n/* All _optimized functions are used to help increase performance\n * (reduce CPU and increase throughput). They use descripter version 3,\n * compiler directives, and reduce memory accesses.\n */\nstatic irqreturn_t nv_nic_irq_optimized(int foo, void *data)\n{\n\tstruct net_device *dev = (struct net_device *) data;\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\n\tif (!(np->msi_flags & NV_MSI_X_ENABLED)) {\n\t\tnp->events = readl(base + NvRegIrqStatus);\n\t\twritel(np->events, base + NvRegIrqStatus);\n\t} else {\n\t\tnp->events = readl(base + NvRegMSIXIrqStatus);\n\t\twritel(np->events, base + NvRegMSIXIrqStatus);\n\t}\n\tif (!(np->events & np->irqmask))\n\t\treturn IRQ_NONE;\n\n\tnv_msi_workaround(np);\n\n\tif (napi_schedule_prep(&np->napi)) {\n\t\t/*\n\t\t * Disable further irq's (msix not enabled with napi)\n\t\t */\n\t\twritel(0, base + NvRegIrqMask);\n\t\t__napi_schedule(&np->napi);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t nv_nic_irq_tx(int foo, void *data)\n{\n\tstruct net_device *dev = (struct net_device *) data;\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 events;\n\tint i;\n\tunsigned long flags;\n\n\tfor (i = 0;; i++) {\n\t\tevents = readl(base + NvRegMSIXIrqStatus) & NVREG_IRQ_TX_ALL;\n\t\twritel(events, base + NvRegMSIXIrqStatus);\n\t\tnetdev_dbg(dev, \"tx irq events: %08x\\n\", events);\n\t\tif (!(events & np->irqmask))\n\t\t\tbreak;\n\n\t\tspin_lock_irqsave(&np->lock, flags);\n\t\tnv_tx_done_optimized(dev, TX_WORK_PER_LOOP);\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\n\t\tif (unlikely(i > max_interrupt_work)) {\n\t\t\tspin_lock_irqsave(&np->lock, flags);\n\t\t\t/* disable interrupts on the nic */\n\t\t\twritel(NVREG_IRQ_TX_ALL, base + NvRegIrqMask);\n\t\t\tpci_push(base);\n\n\t\t\tif (!np->in_shutdown) {\n\t\t\t\tnp->nic_poll_irq |= NVREG_IRQ_TX_ALL;\n\t\t\t\tmod_timer(&np->nic_poll, jiffies + POLL_WAIT);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\t\tnetdev_dbg(dev, \"%s: too many iterations (%d)\\n\",\n\t\t\t\t   __func__, i);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn IRQ_RETVAL(i);\n}\n\nstatic int nv_napi_poll(struct napi_struct *napi, int budget)\n{\n\tstruct fe_priv *np = container_of(napi, struct fe_priv, napi);\n\tstruct net_device *dev = np->dev;\n\tu8 __iomem *base = get_hwbase(dev);\n\tunsigned long flags;\n\tint retcode;\n\tint rx_count, tx_work = 0, rx_work = 0;\n\n\tdo {\n\t\tif (!nv_optimized(np)) {\n\t\t\tspin_lock_irqsave(&np->lock, flags);\n\t\t\ttx_work += nv_tx_done(dev, np->tx_ring_size);\n\t\t\tspin_unlock_irqrestore(&np->lock, flags);\n\n\t\t\trx_count = nv_rx_process(dev, budget - rx_work);\n\t\t\tretcode = nv_alloc_rx(dev);\n\t\t} else {\n\t\t\tspin_lock_irqsave(&np->lock, flags);\n\t\t\ttx_work += nv_tx_done_optimized(dev, np->tx_ring_size);\n\t\t\tspin_unlock_irqrestore(&np->lock, flags);\n\n\t\t\trx_count = nv_rx_process_optimized(dev,\n\t\t\t    budget - rx_work);\n\t\t\tretcode = nv_alloc_rx_optimized(dev);\n\t\t}\n\t} while (retcode == 0 &&\n\t\t rx_count > 0 && (rx_work += rx_count) < budget);\n\n\tif (retcode) {\n\t\tspin_lock_irqsave(&np->lock, flags);\n\t\tif (!np->in_shutdown)\n\t\t\tmod_timer(&np->oom_kick, jiffies + OOM_REFILL);\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t}\n\n\tnv_change_interrupt_mode(dev, tx_work + rx_work);\n\n\tif (unlikely(np->events & NVREG_IRQ_LINK)) {\n\t\tspin_lock_irqsave(&np->lock, flags);\n\t\tnv_link_irq(dev);\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t}\n\tif (unlikely(np->need_linktimer && time_after(jiffies, np->link_timeout))) {\n\t\tspin_lock_irqsave(&np->lock, flags);\n\t\tnv_linkchange(dev);\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\tnp->link_timeout = jiffies + LINK_TIMEOUT;\n\t}\n\tif (unlikely(np->events & NVREG_IRQ_RECOVER_ERROR)) {\n\t\tspin_lock_irqsave(&np->lock, flags);\n\t\tif (!np->in_shutdown) {\n\t\t\tnp->nic_poll_irq = np->irqmask;\n\t\t\tnp->recover_error = 1;\n\t\t\tmod_timer(&np->nic_poll, jiffies + POLL_WAIT);\n\t\t}\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\tnapi_complete(napi);\n\t\treturn rx_work;\n\t}\n\n\tif (rx_work < budget) {\n\t\t/* re-enable interrupts\n\t\t   (msix not enabled in napi) */\n\t\tnapi_complete_done(napi, rx_work);\n\n\t\twritel(np->irqmask, base + NvRegIrqMask);\n\t}\n\treturn rx_work;\n}\n\nstatic irqreturn_t nv_nic_irq_rx(int foo, void *data)\n{\n\tstruct net_device *dev = (struct net_device *) data;\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 events;\n\tint i;\n\tunsigned long flags;\n\n\tfor (i = 0;; i++) {\n\t\tevents = readl(base + NvRegMSIXIrqStatus) & NVREG_IRQ_RX_ALL;\n\t\twritel(events, base + NvRegMSIXIrqStatus);\n\t\tnetdev_dbg(dev, \"rx irq events: %08x\\n\", events);\n\t\tif (!(events & np->irqmask))\n\t\t\tbreak;\n\n\t\tif (nv_rx_process_optimized(dev, RX_WORK_PER_LOOP)) {\n\t\t\tif (unlikely(nv_alloc_rx_optimized(dev))) {\n\t\t\t\tspin_lock_irqsave(&np->lock, flags);\n\t\t\t\tif (!np->in_shutdown)\n\t\t\t\t\tmod_timer(&np->oom_kick, jiffies + OOM_REFILL);\n\t\t\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\t\t}\n\t\t}\n\n\t\tif (unlikely(i > max_interrupt_work)) {\n\t\t\tspin_lock_irqsave(&np->lock, flags);\n\t\t\t/* disable interrupts on the nic */\n\t\t\twritel(NVREG_IRQ_RX_ALL, base + NvRegIrqMask);\n\t\t\tpci_push(base);\n\n\t\t\tif (!np->in_shutdown) {\n\t\t\t\tnp->nic_poll_irq |= NVREG_IRQ_RX_ALL;\n\t\t\t\tmod_timer(&np->nic_poll, jiffies + POLL_WAIT);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\t\tnetdev_dbg(dev, \"%s: too many iterations (%d)\\n\",\n\t\t\t\t   __func__, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn IRQ_RETVAL(i);\n}\n\nstatic irqreturn_t nv_nic_irq_other(int foo, void *data)\n{\n\tstruct net_device *dev = (struct net_device *) data;\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 events;\n\tint i;\n\tunsigned long flags;\n\n\tfor (i = 0;; i++) {\n\t\tevents = readl(base + NvRegMSIXIrqStatus) & NVREG_IRQ_OTHER;\n\t\twritel(events, base + NvRegMSIXIrqStatus);\n\t\tnetdev_dbg(dev, \"irq events: %08x\\n\", events);\n\t\tif (!(events & np->irqmask))\n\t\t\tbreak;\n\n\t\t/* check tx in case we reached max loop limit in tx isr */\n\t\tspin_lock_irqsave(&np->lock, flags);\n\t\tnv_tx_done_optimized(dev, TX_WORK_PER_LOOP);\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\n\t\tif (events & NVREG_IRQ_LINK) {\n\t\t\tspin_lock_irqsave(&np->lock, flags);\n\t\t\tnv_link_irq(dev);\n\t\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\t}\n\t\tif (np->need_linktimer && time_after(jiffies, np->link_timeout)) {\n\t\t\tspin_lock_irqsave(&np->lock, flags);\n\t\t\tnv_linkchange(dev);\n\t\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\t\tnp->link_timeout = jiffies + LINK_TIMEOUT;\n\t\t}\n\t\tif (events & NVREG_IRQ_RECOVER_ERROR) {\n\t\t\tspin_lock_irqsave(&np->lock, flags);\n\t\t\t/* disable interrupts on the nic */\n\t\t\twritel(NVREG_IRQ_OTHER, base + NvRegIrqMask);\n\t\t\tpci_push(base);\n\n\t\t\tif (!np->in_shutdown) {\n\t\t\t\tnp->nic_poll_irq |= NVREG_IRQ_OTHER;\n\t\t\t\tnp->recover_error = 1;\n\t\t\t\tmod_timer(&np->nic_poll, jiffies + POLL_WAIT);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(i > max_interrupt_work)) {\n\t\t\tspin_lock_irqsave(&np->lock, flags);\n\t\t\t/* disable interrupts on the nic */\n\t\t\twritel(NVREG_IRQ_OTHER, base + NvRegIrqMask);\n\t\t\tpci_push(base);\n\n\t\t\tif (!np->in_shutdown) {\n\t\t\t\tnp->nic_poll_irq |= NVREG_IRQ_OTHER;\n\t\t\t\tmod_timer(&np->nic_poll, jiffies + POLL_WAIT);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\t\tnetdev_dbg(dev, \"%s: too many iterations (%d)\\n\",\n\t\t\t\t   __func__, i);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn IRQ_RETVAL(i);\n}\n\nstatic irqreturn_t nv_nic_irq_test(int foo, void *data)\n{\n\tstruct net_device *dev = (struct net_device *) data;\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 events;\n\n\tif (!(np->msi_flags & NV_MSI_X_ENABLED)) {\n\t\tevents = readl(base + NvRegIrqStatus) & NVREG_IRQSTAT_MASK;\n\t\twritel(events & NVREG_IRQ_TIMER, base + NvRegIrqStatus);\n\t} else {\n\t\tevents = readl(base + NvRegMSIXIrqStatus) & NVREG_IRQSTAT_MASK;\n\t\twritel(events & NVREG_IRQ_TIMER, base + NvRegMSIXIrqStatus);\n\t}\n\tpci_push(base);\n\tif (!(events & NVREG_IRQ_TIMER))\n\t\treturn IRQ_RETVAL(0);\n\n\tnv_msi_workaround(np);\n\n\tspin_lock(&np->lock);\n\tnp->intr_test = 1;\n\tspin_unlock(&np->lock);\n\n\treturn IRQ_RETVAL(1);\n}\n\nstatic void set_msix_vector_map(struct net_device *dev, u32 vector, u32 irqmask)\n{\n\tu8 __iomem *base = get_hwbase(dev);\n\tint i;\n\tu32 msixmap = 0;\n\n\t/* Each interrupt bit can be mapped to a MSIX vector (4 bits).\n\t * MSIXMap0 represents the first 8 interrupts and MSIXMap1 represents\n\t * the remaining 8 interrupts.\n\t */\n\tfor (i = 0; i < 8; i++) {\n\t\tif ((irqmask >> i) & 0x1)\n\t\t\tmsixmap |= vector << (i << 2);\n\t}\n\twritel(readl(base + NvRegMSIXMap0) | msixmap, base + NvRegMSIXMap0);\n\n\tmsixmap = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tif ((irqmask >> (i + 8)) & 0x1)\n\t\t\tmsixmap |= vector << (i << 2);\n\t}\n\twritel(readl(base + NvRegMSIXMap1) | msixmap, base + NvRegMSIXMap1);\n}\n\nstatic int nv_request_irq(struct net_device *dev, int intr_test)\n{\n\tstruct fe_priv *np = get_nvpriv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tint ret;\n\tint i;\n\tirqreturn_t (*handler)(int foo, void *data);\n\n\tif (intr_test) {\n\t\thandler = nv_nic_irq_test;\n\t} else {\n\t\tif (nv_optimized(np))\n\t\t\thandler = nv_nic_irq_optimized;\n\t\telse\n\t\t\thandler = nv_nic_irq;\n\t}\n\n\tif (np->msi_flags & NV_MSI_X_CAPABLE) {\n\t\tfor (i = 0; i < (np->msi_flags & NV_MSI_X_VECTORS_MASK); i++)\n\t\t\tnp->msi_x_entry[i].entry = i;\n\t\tret = pci_enable_msix_range(np->pci_dev,\n\t\t\t\t\t    np->msi_x_entry,\n\t\t\t\t\t    np->msi_flags & NV_MSI_X_VECTORS_MASK,\n\t\t\t\t\t    np->msi_flags & NV_MSI_X_VECTORS_MASK);\n\t\tif (ret > 0) {\n\t\t\tnp->msi_flags |= NV_MSI_X_ENABLED;\n\t\t\tif (optimization_mode == NV_OPTIMIZATION_MODE_THROUGHPUT && !intr_test) {\n\t\t\t\t/* Request irq for rx handling */\n\t\t\t\tsprintf(np->name_rx, \"%s-rx\", dev->name);\n\t\t\t\tret = request_irq(np->msi_x_entry[NV_MSI_X_VECTOR_RX].vector,\n\t\t\t\t\t\t  nv_nic_irq_rx, IRQF_SHARED, np->name_rx, dev);\n\t\t\t\tif (ret) {\n\t\t\t\t\tnetdev_info(dev,\n\t\t\t\t\t\t    \"request_irq failed for rx %d\\n\",\n\t\t\t\t\t\t    ret);\n\t\t\t\t\tpci_disable_msix(np->pci_dev);\n\t\t\t\t\tnp->msi_flags &= ~NV_MSI_X_ENABLED;\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\t/* Request irq for tx handling */\n\t\t\t\tsprintf(np->name_tx, \"%s-tx\", dev->name);\n\t\t\t\tret = request_irq(np->msi_x_entry[NV_MSI_X_VECTOR_TX].vector,\n\t\t\t\t\t\t  nv_nic_irq_tx, IRQF_SHARED, np->name_tx, dev);\n\t\t\t\tif (ret) {\n\t\t\t\t\tnetdev_info(dev,\n\t\t\t\t\t\t    \"request_irq failed for tx %d\\n\",\n\t\t\t\t\t\t    ret);\n\t\t\t\t\tpci_disable_msix(np->pci_dev);\n\t\t\t\t\tnp->msi_flags &= ~NV_MSI_X_ENABLED;\n\t\t\t\t\tgoto out_free_rx;\n\t\t\t\t}\n\t\t\t\t/* Request irq for link and timer handling */\n\t\t\t\tsprintf(np->name_other, \"%s-other\", dev->name);\n\t\t\t\tret = request_irq(np->msi_x_entry[NV_MSI_X_VECTOR_OTHER].vector,\n\t\t\t\t\t\t  nv_nic_irq_other, IRQF_SHARED, np->name_other, dev);\n\t\t\t\tif (ret) {\n\t\t\t\t\tnetdev_info(dev,\n\t\t\t\t\t\t    \"request_irq failed for link %d\\n\",\n\t\t\t\t\t\t    ret);\n\t\t\t\t\tpci_disable_msix(np->pci_dev);\n\t\t\t\t\tnp->msi_flags &= ~NV_MSI_X_ENABLED;\n\t\t\t\t\tgoto out_free_tx;\n\t\t\t\t}\n\t\t\t\t/* map interrupts to their respective vector */\n\t\t\t\twritel(0, base + NvRegMSIXMap0);\n\t\t\t\twritel(0, base + NvRegMSIXMap1);\n\t\t\t\tset_msix_vector_map(dev, NV_MSI_X_VECTOR_RX, NVREG_IRQ_RX_ALL);\n\t\t\t\tset_msix_vector_map(dev, NV_MSI_X_VECTOR_TX, NVREG_IRQ_TX_ALL);\n\t\t\t\tset_msix_vector_map(dev, NV_MSI_X_VECTOR_OTHER, NVREG_IRQ_OTHER);\n\t\t\t} else {\n\t\t\t\t/* Request irq for all interrupts */\n\t\t\t\tret = request_irq(np->msi_x_entry[NV_MSI_X_VECTOR_ALL].vector,\n\t\t\t\t\t\t  handler, IRQF_SHARED, dev->name, dev);\n\t\t\t\tif (ret) {\n\t\t\t\t\tnetdev_info(dev,\n\t\t\t\t\t\t    \"request_irq failed %d\\n\",\n\t\t\t\t\t\t    ret);\n\t\t\t\t\tpci_disable_msix(np->pci_dev);\n\t\t\t\t\tnp->msi_flags &= ~NV_MSI_X_ENABLED;\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\n\t\t\t\t/* map interrupts to vector 0 */\n\t\t\t\twritel(0, base + NvRegMSIXMap0);\n\t\t\t\twritel(0, base + NvRegMSIXMap1);\n\t\t\t}\n\t\t\tnetdev_info(dev, \"MSI-X enabled\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (np->msi_flags & NV_MSI_CAPABLE) {\n\t\tret = pci_enable_msi(np->pci_dev);\n\t\tif (ret == 0) {\n\t\t\tnp->msi_flags |= NV_MSI_ENABLED;\n\t\t\tret = request_irq(np->pci_dev->irq, handler, IRQF_SHARED, dev->name, dev);\n\t\t\tif (ret) {\n\t\t\t\tnetdev_info(dev, \"request_irq failed %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\tpci_disable_msi(np->pci_dev);\n\t\t\t\tnp->msi_flags &= ~NV_MSI_ENABLED;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\t/* map interrupts to vector 0 */\n\t\t\twritel(0, base + NvRegMSIMap0);\n\t\t\twritel(0, base + NvRegMSIMap1);\n\t\t\t/* enable msi vector 0 */\n\t\t\twritel(NVREG_MSI_VECTOR_0_ENABLED, base + NvRegMSIIrqMask);\n\t\t\tnetdev_info(dev, \"MSI enabled\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (request_irq(np->pci_dev->irq, handler, IRQF_SHARED, dev->name, dev) != 0)\n\t\tgoto out_err;\n\n\treturn 0;\nout_free_tx:\n\tfree_irq(np->msi_x_entry[NV_MSI_X_VECTOR_TX].vector, dev);\nout_free_rx:\n\tfree_irq(np->msi_x_entry[NV_MSI_X_VECTOR_RX].vector, dev);\nout_err:\n\treturn 1;\n}\n\nstatic void nv_free_irq(struct net_device *dev)\n{\n\tstruct fe_priv *np = get_nvpriv(dev);\n\tint i;\n\n\tif (np->msi_flags & NV_MSI_X_ENABLED) {\n\t\tfor (i = 0; i < (np->msi_flags & NV_MSI_X_VECTORS_MASK); i++)\n\t\t\tfree_irq(np->msi_x_entry[i].vector, dev);\n\t\tpci_disable_msix(np->pci_dev);\n\t\tnp->msi_flags &= ~NV_MSI_X_ENABLED;\n\t} else {\n\t\tfree_irq(np->pci_dev->irq, dev);\n\t\tif (np->msi_flags & NV_MSI_ENABLED) {\n\t\t\tpci_disable_msi(np->pci_dev);\n\t\t\tnp->msi_flags &= ~NV_MSI_ENABLED;\n\t\t}\n\t}\n}\n\nstatic void nv_do_nic_poll(struct timer_list *t)\n{\n\tstruct fe_priv *np = from_timer(np, t, nic_poll);\n\tstruct net_device *dev = np->dev;\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 mask = 0;\n\tunsigned long flags;\n\tunsigned int irq = 0;\n\n\t/*\n\t * First disable irq(s) and then\n\t * reenable interrupts on the nic, we have to do this before calling\n\t * nv_nic_irq because that may decide to do otherwise\n\t */\n\n\tif (!using_multi_irqs(dev)) {\n\t\tif (np->msi_flags & NV_MSI_X_ENABLED)\n\t\t\tirq = np->msi_x_entry[NV_MSI_X_VECTOR_ALL].vector;\n\t\telse\n\t\t\tirq = np->pci_dev->irq;\n\t\tmask = np->irqmask;\n\t} else {\n\t\tif (np->nic_poll_irq & NVREG_IRQ_RX_ALL) {\n\t\t\tirq = np->msi_x_entry[NV_MSI_X_VECTOR_RX].vector;\n\t\t\tmask |= NVREG_IRQ_RX_ALL;\n\t\t}\n\t\tif (np->nic_poll_irq & NVREG_IRQ_TX_ALL) {\n\t\t\tirq = np->msi_x_entry[NV_MSI_X_VECTOR_TX].vector;\n\t\t\tmask |= NVREG_IRQ_TX_ALL;\n\t\t}\n\t\tif (np->nic_poll_irq & NVREG_IRQ_OTHER) {\n\t\t\tirq = np->msi_x_entry[NV_MSI_X_VECTOR_OTHER].vector;\n\t\t\tmask |= NVREG_IRQ_OTHER;\n\t\t}\n\t}\n\n\tdisable_irq_nosync_lockdep_irqsave(irq, &flags);\n\tsynchronize_irq(irq);\n\n\tif (np->recover_error) {\n\t\tnp->recover_error = 0;\n\t\tnetdev_info(dev, \"MAC in recoverable error state\\n\");\n\t\tif (netif_running(dev)) {\n\t\t\tnetif_tx_lock_bh(dev);\n\t\t\tnetif_addr_lock(dev);\n\t\t\tspin_lock(&np->lock);\n\t\t\t/* stop engines */\n\t\t\tnv_stop_rxtx(dev);\n\t\t\tif (np->driver_data & DEV_HAS_POWER_CNTRL)\n\t\t\t\tnv_mac_reset(dev);\n\t\t\tnv_txrx_reset(dev);\n\t\t\t/* drain rx queue */\n\t\t\tnv_drain_rxtx(dev);\n\t\t\t/* reinit driver view of the rx queue */\n\t\t\tset_bufsize(dev);\n\t\t\tif (nv_init_ring(dev)) {\n\t\t\t\tif (!np->in_shutdown)\n\t\t\t\t\tmod_timer(&np->oom_kick, jiffies + OOM_REFILL);\n\t\t\t}\n\t\t\t/* reinit nic view of the rx queue */\n\t\t\twritel(np->rx_buf_sz, base + NvRegOffloadConfig);\n\t\t\tsetup_hw_rings(dev, NV_SETUP_RX_RING | NV_SETUP_TX_RING);\n\t\t\twritel(((np->rx_ring_size-1) << NVREG_RINGSZ_RXSHIFT) + ((np->tx_ring_size-1) << NVREG_RINGSZ_TXSHIFT),\n\t\t\t\tbase + NvRegRingSizes);\n\t\t\tpci_push(base);\n\t\t\twritel(NVREG_TXRXCTL_KICK|np->txrxctl_bits, get_hwbase(dev) + NvRegTxRxControl);\n\t\t\tpci_push(base);\n\t\t\t/* clear interrupts */\n\t\t\tif (!(np->msi_flags & NV_MSI_X_ENABLED))\n\t\t\t\twritel(NVREG_IRQSTAT_MASK, base + NvRegIrqStatus);\n\t\t\telse\n\t\t\t\twritel(NVREG_IRQSTAT_MASK, base + NvRegMSIXIrqStatus);\n\n\t\t\t/* restart rx engine */\n\t\t\tnv_start_rxtx(dev);\n\t\t\tspin_unlock(&np->lock);\n\t\t\tnetif_addr_unlock(dev);\n\t\t\tnetif_tx_unlock_bh(dev);\n\t\t}\n\t}\n\n\twritel(mask, base + NvRegIrqMask);\n\tpci_push(base);\n\n\tif (!using_multi_irqs(dev)) {\n\t\tnp->nic_poll_irq = 0;\n\t\tif (nv_optimized(np))\n\t\t\tnv_nic_irq_optimized(0, dev);\n\t\telse\n\t\t\tnv_nic_irq(0, dev);\n\t} else {\n\t\tif (np->nic_poll_irq & NVREG_IRQ_RX_ALL) {\n\t\t\tnp->nic_poll_irq &= ~NVREG_IRQ_RX_ALL;\n\t\t\tnv_nic_irq_rx(0, dev);\n\t\t}\n\t\tif (np->nic_poll_irq & NVREG_IRQ_TX_ALL) {\n\t\t\tnp->nic_poll_irq &= ~NVREG_IRQ_TX_ALL;\n\t\t\tnv_nic_irq_tx(0, dev);\n\t\t}\n\t\tif (np->nic_poll_irq & NVREG_IRQ_OTHER) {\n\t\t\tnp->nic_poll_irq &= ~NVREG_IRQ_OTHER;\n\t\t\tnv_nic_irq_other(0, dev);\n\t\t}\n\t}\n\n\tenable_irq_lockdep_irqrestore(irq, &flags);\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void nv_poll_controller(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\n\tnv_do_nic_poll(&np->nic_poll);\n}\n#endif\n\nstatic void nv_do_stats_poll(struct timer_list *t)\n\t__acquires(&netdev_priv(dev)->hwstats_lock)\n\t__releases(&netdev_priv(dev)->hwstats_lock)\n{\n\tstruct fe_priv *np = from_timer(np, t, stats_poll);\n\tstruct net_device *dev = np->dev;\n\n\t/* If lock is currently taken, the stats are being refreshed\n\t * and hence fresh enough */\n\tif (spin_trylock(&np->hwstats_lock)) {\n\t\tnv_update_stats(dev);\n\t\tspin_unlock(&np->hwstats_lock);\n\t}\n\n\tif (!np->in_shutdown)\n\t\tmod_timer(&np->stats_poll,\n\t\t\tround_jiffies(jiffies + STATS_INTERVAL));\n}\n\nstatic void nv_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrlcpy(info->version, FORCEDETH_VERSION, sizeof(info->version));\n\tstrlcpy(info->bus_info, pci_name(np->pci_dev), sizeof(info->bus_info));\n}\n\nstatic void nv_get_wol(struct net_device *dev, struct ethtool_wolinfo *wolinfo)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\twolinfo->supported = WAKE_MAGIC;\n\n\tspin_lock_irq(&np->lock);\n\tif (np->wolenabled)\n\t\twolinfo->wolopts = WAKE_MAGIC;\n\tspin_unlock_irq(&np->lock);\n}\n\nstatic int nv_set_wol(struct net_device *dev, struct ethtool_wolinfo *wolinfo)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 flags = 0;\n\n\tif (wolinfo->wolopts == 0) {\n\t\tnp->wolenabled = 0;\n\t} else if (wolinfo->wolopts & WAKE_MAGIC) {\n\t\tnp->wolenabled = 1;\n\t\tflags = NVREG_WAKEUPFLAGS_ENABLE;\n\t}\n\tif (netif_running(dev)) {\n\t\tspin_lock_irq(&np->lock);\n\t\twritel(flags, base + NvRegWakeUpFlags);\n\t\tspin_unlock_irq(&np->lock);\n\t}\n\tdevice_set_wakeup_enable(&np->pci_dev->dev, np->wolenabled);\n\treturn 0;\n}\n\nstatic int nv_get_link_ksettings(struct net_device *dev,\n\t\t\t\t struct ethtool_link_ksettings *cmd)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu32 speed, supported, advertising;\n\tint adv;\n\n\tspin_lock_irq(&np->lock);\n\tcmd->base.port = PORT_MII;\n\tif (!netif_running(dev)) {\n\t\t/* We do not track link speed / duplex setting if the\n\t\t * interface is disabled. Force a link check */\n\t\tif (nv_update_linkspeed(dev)) {\n\t\t\tnetif_carrier_on(dev);\n\t\t} else {\n\t\t\tnetif_carrier_off(dev);\n\t\t}\n\t}\n\n\tif (netif_carrier_ok(dev)) {\n\t\tswitch (np->linkspeed & (NVREG_LINKSPEED_MASK)) {\n\t\tcase NVREG_LINKSPEED_10:\n\t\t\tspeed = SPEED_10;\n\t\t\tbreak;\n\t\tcase NVREG_LINKSPEED_100:\n\t\t\tspeed = SPEED_100;\n\t\t\tbreak;\n\t\tcase NVREG_LINKSPEED_1000:\n\t\t\tspeed = SPEED_1000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tspeed = -1;\n\t\t\tbreak;\n\t\t}\n\t\tcmd->base.duplex = DUPLEX_HALF;\n\t\tif (np->duplex)\n\t\t\tcmd->base.duplex = DUPLEX_FULL;\n\t} else {\n\t\tspeed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\tcmd->base.speed = speed;\n\tcmd->base.autoneg = np->autoneg;\n\n\tadvertising = ADVERTISED_MII;\n\tif (np->autoneg) {\n\t\tadvertising |= ADVERTISED_Autoneg;\n\t\tadv = mii_rw(dev, np->phyaddr, MII_ADVERTISE, MII_READ);\n\t\tif (adv & ADVERTISE_10HALF)\n\t\t\tadvertising |= ADVERTISED_10baseT_Half;\n\t\tif (adv & ADVERTISE_10FULL)\n\t\t\tadvertising |= ADVERTISED_10baseT_Full;\n\t\tif (adv & ADVERTISE_100HALF)\n\t\t\tadvertising |= ADVERTISED_100baseT_Half;\n\t\tif (adv & ADVERTISE_100FULL)\n\t\t\tadvertising |= ADVERTISED_100baseT_Full;\n\t\tif (np->gigabit == PHY_GIGABIT) {\n\t\t\tadv = mii_rw(dev, np->phyaddr, MII_CTRL1000, MII_READ);\n\t\t\tif (adv & ADVERTISE_1000FULL)\n\t\t\t\tadvertising |= ADVERTISED_1000baseT_Full;\n\t\t}\n\t}\n\tsupported = (SUPPORTED_Autoneg |\n\t\tSUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |\n\t\tSUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |\n\t\tSUPPORTED_MII);\n\tif (np->gigabit == PHY_GIGABIT)\n\t\tsupported |= SUPPORTED_1000baseT_Full;\n\n\tcmd->base.phy_address = np->phyaddr;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\t/* ignore maxtxpkt, maxrxpkt for now */\n\tspin_unlock_irq(&np->lock);\n\treturn 0;\n}\n\nstatic int nv_set_link_ksettings(struct net_device *dev,\n\t\t\t\t const struct ethtool_link_ksettings *cmd)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu32 speed = cmd->base.speed;\n\tu32 advertising;\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\tif (cmd->base.port != PORT_MII)\n\t\treturn -EINVAL;\n\tif (cmd->base.phy_address != np->phyaddr) {\n\t\t/* TODO: support switching between multiple phys. Should be\n\t\t * trivial, but not enabled due to lack of test hardware. */\n\t\treturn -EINVAL;\n\t}\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\tu32 mask;\n\n\t\tmask = ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full |\n\t\t\t  ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full;\n\t\tif (np->gigabit == PHY_GIGABIT)\n\t\t\tmask |= ADVERTISED_1000baseT_Full;\n\n\t\tif ((advertising & mask) == 0)\n\t\t\treturn -EINVAL;\n\n\t} else if (cmd->base.autoneg == AUTONEG_DISABLE) {\n\t\t/* Note: autonegotiation disable, speed 1000 intentionally\n\t\t * forbidden - no one should need that. */\n\n\t\tif (speed != SPEED_10 && speed != SPEED_100)\n\t\t\treturn -EINVAL;\n\t\tif (cmd->base.duplex != DUPLEX_HALF &&\n\t\t    cmd->base.duplex != DUPLEX_FULL)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tnetif_carrier_off(dev);\n\tif (netif_running(dev)) {\n\t\tunsigned long flags;\n\n\t\tnv_disable_irq(dev);\n\t\tnetif_tx_lock_bh(dev);\n\t\tnetif_addr_lock(dev);\n\t\t/* with plain spinlock lockdep complains */\n\t\tspin_lock_irqsave(&np->lock, flags);\n\t\t/* stop engines */\n\t\t/* FIXME:\n\t\t * this can take some time, and interrupts are disabled\n\t\t * due to spin_lock_irqsave, but let's hope no daemon\n\t\t * is going to change the settings very often...\n\t\t * Worst case:\n\t\t * NV_RXSTOP_DELAY1MAX + NV_TXSTOP_DELAY1MAX\n\t\t * + some minor delays, which is up to a second approximately\n\t\t */\n\t\tnv_stop_rxtx(dev);\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\tnetif_addr_unlock(dev);\n\t\tnetif_tx_unlock_bh(dev);\n\t}\n\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\tint adv, bmcr;\n\n\t\tnp->autoneg = 1;\n\n\t\t/* advertise only what has been requested */\n\t\tadv = mii_rw(dev, np->phyaddr, MII_ADVERTISE, MII_READ);\n\t\tadv &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4 | ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);\n\t\tif (advertising & ADVERTISED_10baseT_Half)\n\t\t\tadv |= ADVERTISE_10HALF;\n\t\tif (advertising & ADVERTISED_10baseT_Full)\n\t\t\tadv |= ADVERTISE_10FULL;\n\t\tif (advertising & ADVERTISED_100baseT_Half)\n\t\t\tadv |= ADVERTISE_100HALF;\n\t\tif (advertising & ADVERTISED_100baseT_Full)\n\t\t\tadv |= ADVERTISE_100FULL;\n\t\tif (np->pause_flags & NV_PAUSEFRAME_RX_REQ)  /* for rx we set both advertisements but disable tx pause */\n\t\t\tadv |=  ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;\n\t\tif (np->pause_flags & NV_PAUSEFRAME_TX_REQ)\n\t\t\tadv |=  ADVERTISE_PAUSE_ASYM;\n\t\tmii_rw(dev, np->phyaddr, MII_ADVERTISE, adv);\n\n\t\tif (np->gigabit == PHY_GIGABIT) {\n\t\t\tadv = mii_rw(dev, np->phyaddr, MII_CTRL1000, MII_READ);\n\t\t\tadv &= ~ADVERTISE_1000FULL;\n\t\t\tif (advertising & ADVERTISED_1000baseT_Full)\n\t\t\t\tadv |= ADVERTISE_1000FULL;\n\t\t\tmii_rw(dev, np->phyaddr, MII_CTRL1000, adv);\n\t\t}\n\n\t\tif (netif_running(dev))\n\t\t\tnetdev_info(dev, \"link down\\n\");\n\t\tbmcr = mii_rw(dev, np->phyaddr, MII_BMCR, MII_READ);\n\t\tif (np->phy_model == PHY_MODEL_MARVELL_E3016) {\n\t\t\tbmcr |= BMCR_ANENABLE;\n\t\t\t/* reset the phy in order for settings to stick,\n\t\t\t * and cause autoneg to start */\n\t\t\tif (phy_reset(dev, bmcr)) {\n\t\t\t\tnetdev_info(dev, \"phy reset failed\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tbmcr |= (BMCR_ANENABLE | BMCR_ANRESTART);\n\t\t\tmii_rw(dev, np->phyaddr, MII_BMCR, bmcr);\n\t\t}\n\t} else {\n\t\tint adv, bmcr;\n\n\t\tnp->autoneg = 0;\n\n\t\tadv = mii_rw(dev, np->phyaddr, MII_ADVERTISE, MII_READ);\n\t\tadv &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4 | ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);\n\t\tif (speed == SPEED_10 && cmd->base.duplex == DUPLEX_HALF)\n\t\t\tadv |= ADVERTISE_10HALF;\n\t\tif (speed == SPEED_10 && cmd->base.duplex == DUPLEX_FULL)\n\t\t\tadv |= ADVERTISE_10FULL;\n\t\tif (speed == SPEED_100 && cmd->base.duplex == DUPLEX_HALF)\n\t\t\tadv |= ADVERTISE_100HALF;\n\t\tif (speed == SPEED_100 && cmd->base.duplex == DUPLEX_FULL)\n\t\t\tadv |= ADVERTISE_100FULL;\n\t\tnp->pause_flags &= ~(NV_PAUSEFRAME_AUTONEG|NV_PAUSEFRAME_RX_ENABLE|NV_PAUSEFRAME_TX_ENABLE);\n\t\tif (np->pause_flags & NV_PAUSEFRAME_RX_REQ) {/* for rx we set both advertisements but disable tx pause */\n\t\t\tadv |=  ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;\n\t\t\tnp->pause_flags |= NV_PAUSEFRAME_RX_ENABLE;\n\t\t}\n\t\tif (np->pause_flags & NV_PAUSEFRAME_TX_REQ) {\n\t\t\tadv |=  ADVERTISE_PAUSE_ASYM;\n\t\t\tnp->pause_flags |= NV_PAUSEFRAME_TX_ENABLE;\n\t\t}\n\t\tmii_rw(dev, np->phyaddr, MII_ADVERTISE, adv);\n\t\tnp->fixed_mode = adv;\n\n\t\tif (np->gigabit == PHY_GIGABIT) {\n\t\t\tadv = mii_rw(dev, np->phyaddr, MII_CTRL1000, MII_READ);\n\t\t\tadv &= ~ADVERTISE_1000FULL;\n\t\t\tmii_rw(dev, np->phyaddr, MII_CTRL1000, adv);\n\t\t}\n\n\t\tbmcr = mii_rw(dev, np->phyaddr, MII_BMCR, MII_READ);\n\t\tbmcr &= ~(BMCR_ANENABLE|BMCR_SPEED100|BMCR_SPEED1000|BMCR_FULLDPLX);\n\t\tif (np->fixed_mode & (ADVERTISE_10FULL|ADVERTISE_100FULL))\n\t\t\tbmcr |= BMCR_FULLDPLX;\n\t\tif (np->fixed_mode & (ADVERTISE_100HALF|ADVERTISE_100FULL))\n\t\t\tbmcr |= BMCR_SPEED100;\n\t\tif (np->phy_oui == PHY_OUI_MARVELL) {\n\t\t\t/* reset the phy in order for forced mode settings to stick */\n\t\t\tif (phy_reset(dev, bmcr)) {\n\t\t\t\tnetdev_info(dev, \"phy reset failed\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tmii_rw(dev, np->phyaddr, MII_BMCR, bmcr);\n\t\t\tif (netif_running(dev)) {\n\t\t\t\t/* Wait a bit and then reconfigure the nic. */\n\t\t\t\tudelay(10);\n\t\t\t\tnv_linkchange(dev);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (netif_running(dev)) {\n\t\tnv_start_rxtx(dev);\n\t\tnv_enable_irq(dev);\n\t}\n\n\treturn 0;\n}\n\n#define FORCEDETH_REGS_VER\t1\n\nstatic int nv_get_regs_len(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\treturn np->register_size;\n}\n\nstatic void nv_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *buf)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 *rbuf = buf;\n\tint i;\n\n\tregs->version = FORCEDETH_REGS_VER;\n\tspin_lock_irq(&np->lock);\n\tfor (i = 0; i < np->register_size/sizeof(u32); i++)\n\t\trbuf[i] = readl(base + i*sizeof(u32));\n\tspin_unlock_irq(&np->lock);\n}\n\nstatic int nv_nway_reset(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tint ret;\n\n\tif (np->autoneg) {\n\t\tint bmcr;\n\n\t\tnetif_carrier_off(dev);\n\t\tif (netif_running(dev)) {\n\t\t\tnv_disable_irq(dev);\n\t\t\tnetif_tx_lock_bh(dev);\n\t\t\tnetif_addr_lock(dev);\n\t\t\tspin_lock(&np->lock);\n\t\t\t/* stop engines */\n\t\t\tnv_stop_rxtx(dev);\n\t\t\tspin_unlock(&np->lock);\n\t\t\tnetif_addr_unlock(dev);\n\t\t\tnetif_tx_unlock_bh(dev);\n\t\t\tnetdev_info(dev, \"link down\\n\");\n\t\t}\n\n\t\tbmcr = mii_rw(dev, np->phyaddr, MII_BMCR, MII_READ);\n\t\tif (np->phy_model == PHY_MODEL_MARVELL_E3016) {\n\t\t\tbmcr |= BMCR_ANENABLE;\n\t\t\t/* reset the phy in order for settings to stick*/\n\t\t\tif (phy_reset(dev, bmcr)) {\n\t\t\t\tnetdev_info(dev, \"phy reset failed\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tbmcr |= (BMCR_ANENABLE | BMCR_ANRESTART);\n\t\t\tmii_rw(dev, np->phyaddr, MII_BMCR, bmcr);\n\t\t}\n\n\t\tif (netif_running(dev)) {\n\t\t\tnv_start_rxtx(dev);\n\t\t\tnv_enable_irq(dev);\n\t\t}\n\t\tret = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void nv_get_ringparam(struct net_device *dev, struct ethtool_ringparam* ring)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\n\tring->rx_max_pending = (np->desc_ver == DESC_VER_1) ? RING_MAX_DESC_VER_1 : RING_MAX_DESC_VER_2_3;\n\tring->tx_max_pending = (np->desc_ver == DESC_VER_1) ? RING_MAX_DESC_VER_1 : RING_MAX_DESC_VER_2_3;\n\n\tring->rx_pending = np->rx_ring_size;\n\tring->tx_pending = np->tx_ring_size;\n}\n\nstatic int nv_set_ringparam(struct net_device *dev, struct ethtool_ringparam* ring)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tu8 *rxtx_ring, *rx_skbuff, *tx_skbuff;\n\tdma_addr_t ring_addr;\n\n\tif (ring->rx_pending < RX_RING_MIN ||\n\t    ring->tx_pending < TX_RING_MIN ||\n\t    ring->rx_mini_pending != 0 ||\n\t    ring->rx_jumbo_pending != 0 ||\n\t    (np->desc_ver == DESC_VER_1 &&\n\t     (ring->rx_pending > RING_MAX_DESC_VER_1 ||\n\t      ring->tx_pending > RING_MAX_DESC_VER_1)) ||\n\t    (np->desc_ver != DESC_VER_1 &&\n\t     (ring->rx_pending > RING_MAX_DESC_VER_2_3 ||\n\t      ring->tx_pending > RING_MAX_DESC_VER_2_3))) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* allocate new rings */\n\tif (!nv_optimized(np)) {\n\t\trxtx_ring = dma_alloc_coherent(&np->pci_dev->dev,\n\t\t\t\t\t       sizeof(struct ring_desc) *\n\t\t\t\t\t       (ring->rx_pending +\n\t\t\t\t\t       ring->tx_pending),\n\t\t\t\t\t       &ring_addr, GFP_ATOMIC);\n\t} else {\n\t\trxtx_ring = dma_alloc_coherent(&np->pci_dev->dev,\n\t\t\t\t\t       sizeof(struct ring_desc_ex) *\n\t\t\t\t\t       (ring->rx_pending +\n\t\t\t\t\t       ring->tx_pending),\n\t\t\t\t\t       &ring_addr, GFP_ATOMIC);\n\t}\n\trx_skbuff = kmalloc_array(ring->rx_pending, sizeof(struct nv_skb_map),\n\t\t\t\t  GFP_KERNEL);\n\ttx_skbuff = kmalloc_array(ring->tx_pending, sizeof(struct nv_skb_map),\n\t\t\t\t  GFP_KERNEL);\n\tif (!rxtx_ring || !rx_skbuff || !tx_skbuff) {\n\t\t/* fall back to old rings */\n\t\tif (!nv_optimized(np)) {\n\t\t\tif (rxtx_ring)\n\t\t\t\tdma_free_coherent(&np->pci_dev->dev,\n\t\t\t\t\t\t  sizeof(struct ring_desc) *\n\t\t\t\t\t\t  (ring->rx_pending +\n\t\t\t\t\t\t  ring->tx_pending),\n\t\t\t\t\t\t  rxtx_ring, ring_addr);\n\t\t} else {\n\t\t\tif (rxtx_ring)\n\t\t\t\tdma_free_coherent(&np->pci_dev->dev,\n\t\t\t\t\t\t  sizeof(struct ring_desc_ex) *\n\t\t\t\t\t\t  (ring->rx_pending +\n\t\t\t\t\t\t  ring->tx_pending),\n\t\t\t\t\t\t  rxtx_ring, ring_addr);\n\t\t}\n\n\t\tkfree(rx_skbuff);\n\t\tkfree(tx_skbuff);\n\t\tgoto exit;\n\t}\n\n\tif (netif_running(dev)) {\n\t\tnv_disable_irq(dev);\n\t\tnv_napi_disable(dev);\n\t\tnetif_tx_lock_bh(dev);\n\t\tnetif_addr_lock(dev);\n\t\tspin_lock(&np->lock);\n\t\t/* stop engines */\n\t\tnv_stop_rxtx(dev);\n\t\tnv_txrx_reset(dev);\n\t\t/* drain queues */\n\t\tnv_drain_rxtx(dev);\n\t\t/* delete queues */\n\t\tfree_rings(dev);\n\t}\n\n\t/* set new values */\n\tnp->rx_ring_size = ring->rx_pending;\n\tnp->tx_ring_size = ring->tx_pending;\n\n\tif (!nv_optimized(np)) {\n\t\tnp->rx_ring.orig = (struct ring_desc *)rxtx_ring;\n\t\tnp->tx_ring.orig = &np->rx_ring.orig[np->rx_ring_size];\n\t} else {\n\t\tnp->rx_ring.ex = (struct ring_desc_ex *)rxtx_ring;\n\t\tnp->tx_ring.ex = &np->rx_ring.ex[np->rx_ring_size];\n\t}\n\tnp->rx_skb = (struct nv_skb_map *)rx_skbuff;\n\tnp->tx_skb = (struct nv_skb_map *)tx_skbuff;\n\tnp->ring_addr = ring_addr;\n\n\tmemset(np->rx_skb, 0, sizeof(struct nv_skb_map) * np->rx_ring_size);\n\tmemset(np->tx_skb, 0, sizeof(struct nv_skb_map) * np->tx_ring_size);\n\n\tif (netif_running(dev)) {\n\t\t/* reinit driver view of the queues */\n\t\tset_bufsize(dev);\n\t\tif (nv_init_ring(dev)) {\n\t\t\tif (!np->in_shutdown)\n\t\t\t\tmod_timer(&np->oom_kick, jiffies + OOM_REFILL);\n\t\t}\n\n\t\t/* reinit nic view of the queues */\n\t\twritel(np->rx_buf_sz, base + NvRegOffloadConfig);\n\t\tsetup_hw_rings(dev, NV_SETUP_RX_RING | NV_SETUP_TX_RING);\n\t\twritel(((np->rx_ring_size-1) << NVREG_RINGSZ_RXSHIFT) + ((np->tx_ring_size-1) << NVREG_RINGSZ_TXSHIFT),\n\t\t\tbase + NvRegRingSizes);\n\t\tpci_push(base);\n\t\twritel(NVREG_TXRXCTL_KICK|np->txrxctl_bits, get_hwbase(dev) + NvRegTxRxControl);\n\t\tpci_push(base);\n\n\t\t/* restart engines */\n\t\tnv_start_rxtx(dev);\n\t\tspin_unlock(&np->lock);\n\t\tnetif_addr_unlock(dev);\n\t\tnetif_tx_unlock_bh(dev);\n\t\tnv_napi_enable(dev);\n\t\tnv_enable_irq(dev);\n\t}\n\treturn 0;\nexit:\n\treturn -ENOMEM;\n}\n\nstatic void nv_get_pauseparam(struct net_device *dev, struct ethtool_pauseparam* pause)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\n\tpause->autoneg = (np->pause_flags & NV_PAUSEFRAME_AUTONEG) != 0;\n\tpause->rx_pause = (np->pause_flags & NV_PAUSEFRAME_RX_ENABLE) != 0;\n\tpause->tx_pause = (np->pause_flags & NV_PAUSEFRAME_TX_ENABLE) != 0;\n}\n\nstatic int nv_set_pauseparam(struct net_device *dev, struct ethtool_pauseparam* pause)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tint adv, bmcr;\n\n\tif ((!np->autoneg && np->duplex == 0) ||\n\t    (np->autoneg && !pause->autoneg && np->duplex == 0)) {\n\t\tnetdev_info(dev, \"can not set pause settings when forced link is in half duplex\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (pause->tx_pause && !(np->pause_flags & NV_PAUSEFRAME_TX_CAPABLE)) {\n\t\tnetdev_info(dev, \"hardware does not support tx pause frames\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnetif_carrier_off(dev);\n\tif (netif_running(dev)) {\n\t\tnv_disable_irq(dev);\n\t\tnetif_tx_lock_bh(dev);\n\t\tnetif_addr_lock(dev);\n\t\tspin_lock(&np->lock);\n\t\t/* stop engines */\n\t\tnv_stop_rxtx(dev);\n\t\tspin_unlock(&np->lock);\n\t\tnetif_addr_unlock(dev);\n\t\tnetif_tx_unlock_bh(dev);\n\t}\n\n\tnp->pause_flags &= ~(NV_PAUSEFRAME_RX_REQ|NV_PAUSEFRAME_TX_REQ);\n\tif (pause->rx_pause)\n\t\tnp->pause_flags |= NV_PAUSEFRAME_RX_REQ;\n\tif (pause->tx_pause)\n\t\tnp->pause_flags |= NV_PAUSEFRAME_TX_REQ;\n\n\tif (np->autoneg && pause->autoneg) {\n\t\tnp->pause_flags |= NV_PAUSEFRAME_AUTONEG;\n\n\t\tadv = mii_rw(dev, np->phyaddr, MII_ADVERTISE, MII_READ);\n\t\tadv &= ~(ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);\n\t\tif (np->pause_flags & NV_PAUSEFRAME_RX_REQ) /* for rx we set both advertisements but disable tx pause */\n\t\t\tadv |=  ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;\n\t\tif (np->pause_flags & NV_PAUSEFRAME_TX_REQ)\n\t\t\tadv |=  ADVERTISE_PAUSE_ASYM;\n\t\tmii_rw(dev, np->phyaddr, MII_ADVERTISE, adv);\n\n\t\tif (netif_running(dev))\n\t\t\tnetdev_info(dev, \"link down\\n\");\n\t\tbmcr = mii_rw(dev, np->phyaddr, MII_BMCR, MII_READ);\n\t\tbmcr |= (BMCR_ANENABLE | BMCR_ANRESTART);\n\t\tmii_rw(dev, np->phyaddr, MII_BMCR, bmcr);\n\t} else {\n\t\tnp->pause_flags &= ~(NV_PAUSEFRAME_AUTONEG|NV_PAUSEFRAME_RX_ENABLE|NV_PAUSEFRAME_TX_ENABLE);\n\t\tif (pause->rx_pause)\n\t\t\tnp->pause_flags |= NV_PAUSEFRAME_RX_ENABLE;\n\t\tif (pause->tx_pause)\n\t\t\tnp->pause_flags |= NV_PAUSEFRAME_TX_ENABLE;\n\n\t\tif (!netif_running(dev))\n\t\t\tnv_update_linkspeed(dev);\n\t\telse\n\t\t\tnv_update_pause(dev, np->pause_flags);\n\t}\n\n\tif (netif_running(dev)) {\n\t\tnv_start_rxtx(dev);\n\t\tnv_enable_irq(dev);\n\t}\n\treturn 0;\n}\n\nstatic int nv_set_loopback(struct net_device *dev, netdev_features_t features)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tunsigned long flags;\n\tu32 miicontrol;\n\tint err, retval = 0;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\tmiicontrol = mii_rw(dev, np->phyaddr, MII_BMCR, MII_READ);\n\tif (features & NETIF_F_LOOPBACK) {\n\t\tif (miicontrol & BMCR_LOOPBACK) {\n\t\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\t\tnetdev_info(dev, \"Loopback already enabled\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tnv_disable_irq(dev);\n\t\t/* Turn on loopback mode */\n\t\tmiicontrol |= BMCR_LOOPBACK | BMCR_FULLDPLX | BMCR_SPEED1000;\n\t\terr = mii_rw(dev, np->phyaddr, MII_BMCR, miicontrol);\n\t\tif (err) {\n\t\t\tretval = PHY_ERROR;\n\t\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\t\tphy_init(dev);\n\t\t} else {\n\t\t\tif (netif_running(dev)) {\n\t\t\t\t/* Force 1000 Mbps full-duplex */\n\t\t\t\tnv_force_linkspeed(dev, NVREG_LINKSPEED_1000,\n\t\t\t\t\t\t\t\t\t 1);\n\t\t\t\t/* Force link up */\n\t\t\t\tnetif_carrier_on(dev);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\t\tnetdev_info(dev,\n\t\t\t\t\"Internal PHY loopback mode enabled.\\n\");\n\t\t}\n\t} else {\n\t\tif (!(miicontrol & BMCR_LOOPBACK)) {\n\t\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\t\tnetdev_info(dev, \"Loopback already disabled\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tnv_disable_irq(dev);\n\t\t/* Turn off loopback */\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\tnetdev_info(dev, \"Internal PHY loopback mode disabled.\\n\");\n\t\tphy_init(dev);\n\t}\n\tmsleep(500);\n\tspin_lock_irqsave(&np->lock, flags);\n\tnv_enable_irq(dev);\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\treturn retval;\n}\n\nstatic netdev_features_t nv_fix_features(struct net_device *dev,\n\tnetdev_features_t features)\n{\n\t/* vlan is dependent on rx checksum offload */\n\tif (features & (NETIF_F_HW_VLAN_CTAG_TX|NETIF_F_HW_VLAN_CTAG_RX))\n\t\tfeatures |= NETIF_F_RXCSUM;\n\n\treturn features;\n}\n\nstatic void nv_vlan_mode(struct net_device *dev, netdev_features_t features)\n{\n\tstruct fe_priv *np = get_nvpriv(dev);\n\n\tspin_lock_irq(&np->lock);\n\n\tif (features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tnp->txrxctl_bits |= NVREG_TXRXCTL_VLANSTRIP;\n\telse\n\t\tnp->txrxctl_bits &= ~NVREG_TXRXCTL_VLANSTRIP;\n\n\tif (features & NETIF_F_HW_VLAN_CTAG_TX)\n\t\tnp->txrxctl_bits |= NVREG_TXRXCTL_VLANINS;\n\telse\n\t\tnp->txrxctl_bits &= ~NVREG_TXRXCTL_VLANINS;\n\n\twritel(np->txrxctl_bits, get_hwbase(dev) + NvRegTxRxControl);\n\n\tspin_unlock_irq(&np->lock);\n}\n\nstatic int nv_set_features(struct net_device *dev, netdev_features_t features)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tnetdev_features_t changed = dev->features ^ features;\n\tint retval;\n\n\tif ((changed & NETIF_F_LOOPBACK) && netif_running(dev)) {\n\t\tretval = nv_set_loopback(dev, features);\n\t\tif (retval != 0)\n\t\t\treturn retval;\n\t}\n\n\tif (changed & NETIF_F_RXCSUM) {\n\t\tspin_lock_irq(&np->lock);\n\n\t\tif (features & NETIF_F_RXCSUM)\n\t\t\tnp->txrxctl_bits |= NVREG_TXRXCTL_RXCHECK;\n\t\telse\n\t\t\tnp->txrxctl_bits &= ~NVREG_TXRXCTL_RXCHECK;\n\n\t\tif (netif_running(dev))\n\t\t\twritel(np->txrxctl_bits, base + NvRegTxRxControl);\n\n\t\tspin_unlock_irq(&np->lock);\n\t}\n\n\tif (changed & (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX))\n\t\tnv_vlan_mode(dev, features);\n\n\treturn 0;\n}\n\nstatic int nv_get_sset_count(struct net_device *dev, int sset)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\n\tswitch (sset) {\n\tcase ETH_SS_TEST:\n\t\tif (np->driver_data & DEV_HAS_TEST_EXTENDED)\n\t\t\treturn NV_TEST_COUNT_EXTENDED;\n\t\telse\n\t\t\treturn NV_TEST_COUNT_BASE;\n\tcase ETH_SS_STATS:\n\t\tif (np->driver_data & DEV_HAS_STATISTICS_V3)\n\t\t\treturn NV_DEV_STATISTICS_V3_COUNT;\n\t\telse if (np->driver_data & DEV_HAS_STATISTICS_V2)\n\t\t\treturn NV_DEV_STATISTICS_V2_COUNT;\n\t\telse if (np->driver_data & DEV_HAS_STATISTICS_V1)\n\t\t\treturn NV_DEV_STATISTICS_V1_COUNT;\n\t\telse\n\t\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void nv_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t struct ethtool_stats *estats, u64 *buffer)\n\t__acquires(&netdev_priv(dev)->hwstats_lock)\n\t__releases(&netdev_priv(dev)->hwstats_lock)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\n\tspin_lock_bh(&np->hwstats_lock);\n\tnv_update_stats(dev);\n\tmemcpy(buffer, &np->estats,\n\t       nv_get_sset_count(dev, ETH_SS_STATS)*sizeof(u64));\n\tspin_unlock_bh(&np->hwstats_lock);\n}\n\nstatic int nv_link_test(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tint mii_status;\n\n\tmii_rw(dev, np->phyaddr, MII_BMSR, MII_READ);\n\tmii_status = mii_rw(dev, np->phyaddr, MII_BMSR, MII_READ);\n\n\t/* check phy link status */\n\tif (!(mii_status & BMSR_LSTATUS))\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nstatic int nv_register_test(struct net_device *dev)\n{\n\tu8 __iomem *base = get_hwbase(dev);\n\tint i = 0;\n\tu32 orig_read, new_read;\n\n\tdo {\n\t\torig_read = readl(base + nv_registers_test[i].reg);\n\n\t\t/* xor with mask to toggle bits */\n\t\torig_read ^= nv_registers_test[i].mask;\n\n\t\twritel(orig_read, base + nv_registers_test[i].reg);\n\n\t\tnew_read = readl(base + nv_registers_test[i].reg);\n\n\t\tif ((new_read & nv_registers_test[i].mask) != (orig_read & nv_registers_test[i].mask))\n\t\t\treturn 0;\n\n\t\t/* restore original value */\n\t\torig_read ^= nv_registers_test[i].mask;\n\t\twritel(orig_read, base + nv_registers_test[i].reg);\n\n\t} while (nv_registers_test[++i].reg != 0);\n\n\treturn 1;\n}\n\nstatic int nv_interrupt_test(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tint ret = 1;\n\tint testcnt;\n\tu32 save_msi_flags, save_poll_interval = 0;\n\n\tif (netif_running(dev)) {\n\t\t/* free current irq */\n\t\tnv_free_irq(dev);\n\t\tsave_poll_interval = readl(base+NvRegPollingInterval);\n\t}\n\n\t/* flag to test interrupt handler */\n\tnp->intr_test = 0;\n\n\t/* setup test irq */\n\tsave_msi_flags = np->msi_flags;\n\tnp->msi_flags &= ~NV_MSI_X_VECTORS_MASK;\n\tnp->msi_flags |= 0x001; /* setup 1 vector */\n\tif (nv_request_irq(dev, 1))\n\t\treturn 0;\n\n\t/* setup timer interrupt */\n\twritel(NVREG_POLL_DEFAULT_CPU, base + NvRegPollingInterval);\n\twritel(NVREG_UNKSETUP6_VAL, base + NvRegUnknownSetupReg6);\n\n\tnv_enable_hw_interrupts(dev, NVREG_IRQ_TIMER);\n\n\t/* wait for at least one interrupt */\n\tmsleep(100);\n\n\tspin_lock_irq(&np->lock);\n\n\t/* flag should be set within ISR */\n\ttestcnt = np->intr_test;\n\tif (!testcnt)\n\t\tret = 2;\n\n\tnv_disable_hw_interrupts(dev, NVREG_IRQ_TIMER);\n\tif (!(np->msi_flags & NV_MSI_X_ENABLED))\n\t\twritel(NVREG_IRQSTAT_MASK, base + NvRegIrqStatus);\n\telse\n\t\twritel(NVREG_IRQSTAT_MASK, base + NvRegMSIXIrqStatus);\n\n\tspin_unlock_irq(&np->lock);\n\n\tnv_free_irq(dev);\n\n\tnp->msi_flags = save_msi_flags;\n\n\tif (netif_running(dev)) {\n\t\twritel(save_poll_interval, base + NvRegPollingInterval);\n\t\twritel(NVREG_UNKSETUP6_VAL, base + NvRegUnknownSetupReg6);\n\t\t/* restore original irq */\n\t\tif (nv_request_irq(dev, 0))\n\t\t\treturn 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int nv_loopback_test(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tstruct sk_buff *tx_skb, *rx_skb;\n\tdma_addr_t test_dma_addr;\n\tu32 tx_flags_extra = (np->desc_ver == DESC_VER_1 ? NV_TX_LASTPACKET : NV_TX2_LASTPACKET);\n\tu32 flags;\n\tint len, i, pkt_len;\n\tu8 *pkt_data;\n\tu32 filter_flags = 0;\n\tu32 misc1_flags = 0;\n\tint ret = 1;\n\n\tif (netif_running(dev)) {\n\t\tnv_disable_irq(dev);\n\t\tfilter_flags = readl(base + NvRegPacketFilterFlags);\n\t\tmisc1_flags = readl(base + NvRegMisc1);\n\t} else {\n\t\tnv_txrx_reset(dev);\n\t}\n\n\t/* reinit driver view of the rx queue */\n\tset_bufsize(dev);\n\tnv_init_ring(dev);\n\n\t/* setup hardware for loopback */\n\twritel(NVREG_MISC1_FORCE, base + NvRegMisc1);\n\twritel(NVREG_PFF_ALWAYS | NVREG_PFF_LOOPBACK, base + NvRegPacketFilterFlags);\n\n\t/* reinit nic view of the rx queue */\n\twritel(np->rx_buf_sz, base + NvRegOffloadConfig);\n\tsetup_hw_rings(dev, NV_SETUP_RX_RING | NV_SETUP_TX_RING);\n\twritel(((np->rx_ring_size-1) << NVREG_RINGSZ_RXSHIFT) + ((np->tx_ring_size-1) << NVREG_RINGSZ_TXSHIFT),\n\t\tbase + NvRegRingSizes);\n\tpci_push(base);\n\n\t/* restart rx engine */\n\tnv_start_rxtx(dev);\n\n\t/* setup packet for tx */\n\tpkt_len = ETH_DATA_LEN;\n\ttx_skb = netdev_alloc_skb(dev, pkt_len);\n\tif (!tx_skb) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\ttest_dma_addr = dma_map_single(&np->pci_dev->dev, tx_skb->data,\n\t\t\t\t       skb_tailroom(tx_skb),\n\t\t\t\t       DMA_FROM_DEVICE);\n\tif (unlikely(dma_mapping_error(&np->pci_dev->dev,\n\t\t\t\t       test_dma_addr))) {\n\t\tdev_kfree_skb_any(tx_skb);\n\t\tgoto out;\n\t}\n\tpkt_data = skb_put(tx_skb, pkt_len);\n\tfor (i = 0; i < pkt_len; i++)\n\t\tpkt_data[i] = (u8)(i & 0xff);\n\n\tif (!nv_optimized(np)) {\n\t\tnp->tx_ring.orig[0].buf = cpu_to_le32(test_dma_addr);\n\t\tnp->tx_ring.orig[0].flaglen = cpu_to_le32((pkt_len-1) | np->tx_flags | tx_flags_extra);\n\t} else {\n\t\tnp->tx_ring.ex[0].bufhigh = cpu_to_le32(dma_high(test_dma_addr));\n\t\tnp->tx_ring.ex[0].buflow = cpu_to_le32(dma_low(test_dma_addr));\n\t\tnp->tx_ring.ex[0].flaglen = cpu_to_le32((pkt_len-1) | np->tx_flags | tx_flags_extra);\n\t}\n\twritel(NVREG_TXRXCTL_KICK|np->txrxctl_bits, get_hwbase(dev) + NvRegTxRxControl);\n\tpci_push(get_hwbase(dev));\n\n\tmsleep(500);\n\n\t/* check for rx of the packet */\n\tif (!nv_optimized(np)) {\n\t\tflags = le32_to_cpu(np->rx_ring.orig[0].flaglen);\n\t\tlen = nv_descr_getlength(&np->rx_ring.orig[0], np->desc_ver);\n\n\t} else {\n\t\tflags = le32_to_cpu(np->rx_ring.ex[0].flaglen);\n\t\tlen = nv_descr_getlength_ex(&np->rx_ring.ex[0], np->desc_ver);\n\t}\n\n\tif (flags & NV_RX_AVAIL) {\n\t\tret = 0;\n\t} else if (np->desc_ver == DESC_VER_1) {\n\t\tif (flags & NV_RX_ERROR)\n\t\t\tret = 0;\n\t} else {\n\t\tif (flags & NV_RX2_ERROR)\n\t\t\tret = 0;\n\t}\n\n\tif (ret) {\n\t\tif (len != pkt_len) {\n\t\t\tret = 0;\n\t\t} else {\n\t\t\trx_skb = np->rx_skb[0].skb;\n\t\t\tfor (i = 0; i < pkt_len; i++) {\n\t\t\t\tif (rx_skb->data[i] != (u8)(i & 0xff)) {\n\t\t\t\t\tret = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdma_unmap_single(&np->pci_dev->dev, test_dma_addr,\n\t\t\t (skb_end_pointer(tx_skb) - tx_skb->data),\n\t\t\t DMA_TO_DEVICE);\n\tdev_kfree_skb_any(tx_skb);\n out:\n\t/* stop engines */\n\tnv_stop_rxtx(dev);\n\tnv_txrx_reset(dev);\n\t/* drain rx queue */\n\tnv_drain_rxtx(dev);\n\n\tif (netif_running(dev)) {\n\t\twritel(misc1_flags, base + NvRegMisc1);\n\t\twritel(filter_flags, base + NvRegPacketFilterFlags);\n\t\tnv_enable_irq(dev);\n\t}\n\n\treturn ret;\n}\n\nstatic void nv_self_test(struct net_device *dev, struct ethtool_test *test, u64 *buffer)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tint result, count;\n\n\tcount = nv_get_sset_count(dev, ETH_SS_TEST);\n\tmemset(buffer, 0, count * sizeof(u64));\n\n\tif (!nv_link_test(dev)) {\n\t\ttest->flags |= ETH_TEST_FL_FAILED;\n\t\tbuffer[0] = 1;\n\t}\n\n\tif (test->flags & ETH_TEST_FL_OFFLINE) {\n\t\tif (netif_running(dev)) {\n\t\t\tnetif_stop_queue(dev);\n\t\t\tnv_napi_disable(dev);\n\t\t\tnetif_tx_lock_bh(dev);\n\t\t\tnetif_addr_lock(dev);\n\t\t\tspin_lock_irq(&np->lock);\n\t\t\tnv_disable_hw_interrupts(dev, np->irqmask);\n\t\t\tif (!(np->msi_flags & NV_MSI_X_ENABLED))\n\t\t\t\twritel(NVREG_IRQSTAT_MASK, base + NvRegIrqStatus);\n\t\t\telse\n\t\t\t\twritel(NVREG_IRQSTAT_MASK, base + NvRegMSIXIrqStatus);\n\t\t\t/* stop engines */\n\t\t\tnv_stop_rxtx(dev);\n\t\t\tnv_txrx_reset(dev);\n\t\t\t/* drain rx queue */\n\t\t\tnv_drain_rxtx(dev);\n\t\t\tspin_unlock_irq(&np->lock);\n\t\t\tnetif_addr_unlock(dev);\n\t\t\tnetif_tx_unlock_bh(dev);\n\t\t}\n\n\t\tif (!nv_register_test(dev)) {\n\t\t\ttest->flags |= ETH_TEST_FL_FAILED;\n\t\t\tbuffer[1] = 1;\n\t\t}\n\n\t\tresult = nv_interrupt_test(dev);\n\t\tif (result != 1) {\n\t\t\ttest->flags |= ETH_TEST_FL_FAILED;\n\t\t\tbuffer[2] = 1;\n\t\t}\n\t\tif (result == 0) {\n\t\t\t/* bail out */\n\t\t\treturn;\n\t\t}\n\n\t\tif (count > NV_TEST_COUNT_BASE && !nv_loopback_test(dev)) {\n\t\t\ttest->flags |= ETH_TEST_FL_FAILED;\n\t\t\tbuffer[3] = 1;\n\t\t}\n\n\t\tif (netif_running(dev)) {\n\t\t\t/* reinit driver view of the rx queue */\n\t\t\tset_bufsize(dev);\n\t\t\tif (nv_init_ring(dev)) {\n\t\t\t\tif (!np->in_shutdown)\n\t\t\t\t\tmod_timer(&np->oom_kick, jiffies + OOM_REFILL);\n\t\t\t}\n\t\t\t/* reinit nic view of the rx queue */\n\t\t\twritel(np->rx_buf_sz, base + NvRegOffloadConfig);\n\t\t\tsetup_hw_rings(dev, NV_SETUP_RX_RING | NV_SETUP_TX_RING);\n\t\t\twritel(((np->rx_ring_size-1) << NVREG_RINGSZ_RXSHIFT) + ((np->tx_ring_size-1) << NVREG_RINGSZ_TXSHIFT),\n\t\t\t\tbase + NvRegRingSizes);\n\t\t\tpci_push(base);\n\t\t\twritel(NVREG_TXRXCTL_KICK|np->txrxctl_bits, get_hwbase(dev) + NvRegTxRxControl);\n\t\t\tpci_push(base);\n\t\t\t/* restart rx engine */\n\t\t\tnv_start_rxtx(dev);\n\t\t\tnetif_start_queue(dev);\n\t\t\tnv_napi_enable(dev);\n\t\t\tnv_enable_hw_interrupts(dev, np->irqmask);\n\t\t}\n\t}\n}\n\nstatic void nv_get_strings(struct net_device *dev, u32 stringset, u8 *buffer)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(buffer, &nv_estats_str, nv_get_sset_count(dev, ETH_SS_STATS)*sizeof(struct nv_ethtool_str));\n\t\tbreak;\n\tcase ETH_SS_TEST:\n\t\tmemcpy(buffer, &nv_etests_str, nv_get_sset_count(dev, ETH_SS_TEST)*sizeof(struct nv_ethtool_str));\n\t\tbreak;\n\t}\n}\n\nstatic const struct ethtool_ops ops = {\n\t.get_drvinfo = nv_get_drvinfo,\n\t.get_link = ethtool_op_get_link,\n\t.get_wol = nv_get_wol,\n\t.set_wol = nv_set_wol,\n\t.get_regs_len = nv_get_regs_len,\n\t.get_regs = nv_get_regs,\n\t.nway_reset = nv_nway_reset,\n\t.get_ringparam = nv_get_ringparam,\n\t.set_ringparam = nv_set_ringparam,\n\t.get_pauseparam = nv_get_pauseparam,\n\t.set_pauseparam = nv_set_pauseparam,\n\t.get_strings = nv_get_strings,\n\t.get_ethtool_stats = nv_get_ethtool_stats,\n\t.get_sset_count = nv_get_sset_count,\n\t.self_test = nv_self_test,\n\t.get_ts_info = ethtool_op_get_ts_info,\n\t.get_link_ksettings = nv_get_link_ksettings,\n\t.set_link_ksettings = nv_set_link_ksettings,\n};\n\n/* The mgmt unit and driver use a semaphore to access the phy during init */\nstatic int nv_mgmt_acquire_sema(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tint i;\n\tu32 tx_ctrl, mgmt_sema;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tmgmt_sema = readl(base + NvRegTransmitterControl) & NVREG_XMITCTL_MGMT_SEMA_MASK;\n\t\tif (mgmt_sema == NVREG_XMITCTL_MGMT_SEMA_FREE)\n\t\t\tbreak;\n\t\tmsleep(500);\n\t}\n\n\tif (mgmt_sema != NVREG_XMITCTL_MGMT_SEMA_FREE)\n\t\treturn 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\ttx_ctrl = readl(base + NvRegTransmitterControl);\n\t\ttx_ctrl |= NVREG_XMITCTL_HOST_SEMA_ACQ;\n\t\twritel(tx_ctrl, base + NvRegTransmitterControl);\n\n\t\t/* verify that semaphore was acquired */\n\t\ttx_ctrl = readl(base + NvRegTransmitterControl);\n\t\tif (((tx_ctrl & NVREG_XMITCTL_HOST_SEMA_MASK) == NVREG_XMITCTL_HOST_SEMA_ACQ) &&\n\t\t    ((tx_ctrl & NVREG_XMITCTL_MGMT_SEMA_MASK) == NVREG_XMITCTL_MGMT_SEMA_FREE)) {\n\t\t\tnp->mgmt_sema = 1;\n\t\t\treturn 1;\n\t\t} else\n\t\t\tudelay(50);\n\t}\n\n\treturn 0;\n}\n\nstatic void nv_mgmt_release_sema(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 tx_ctrl;\n\n\tif (np->driver_data & DEV_HAS_MGMT_UNIT) {\n\t\tif (np->mgmt_sema) {\n\t\t\ttx_ctrl = readl(base + NvRegTransmitterControl);\n\t\t\ttx_ctrl &= ~NVREG_XMITCTL_HOST_SEMA_ACQ;\n\t\t\twritel(tx_ctrl, base + NvRegTransmitterControl);\n\t\t}\n\t}\n}\n\n\nstatic int nv_mgmt_get_version(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tu32 data_ready = readl(base + NvRegTransmitterControl);\n\tu32 data_ready2 = 0;\n\tunsigned long start;\n\tint ready = 0;\n\n\twritel(NVREG_MGMTUNITGETVERSION, base + NvRegMgmtUnitGetVersion);\n\twritel(data_ready ^ NVREG_XMITCTL_DATA_START, base + NvRegTransmitterControl);\n\tstart = jiffies;\n\twhile (time_before(jiffies, start + 5*HZ)) {\n\t\tdata_ready2 = readl(base + NvRegTransmitterControl);\n\t\tif ((data_ready & NVREG_XMITCTL_DATA_READY) != (data_ready2 & NVREG_XMITCTL_DATA_READY)) {\n\t\t\tready = 1;\n\t\t\tbreak;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\n\tif (!ready || (data_ready2 & NVREG_XMITCTL_DATA_ERROR))\n\t\treturn 0;\n\n\tnp->mgmt_version = readl(base + NvRegMgmtUnitVersion) & NVREG_MGMTUNITVERSION;\n\n\treturn 1;\n}\n\nstatic int nv_open(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tint ret = 1;\n\tint oom, i;\n\tu32 low;\n\n\t/* power up phy */\n\tmii_rw(dev, np->phyaddr, MII_BMCR,\n\t       mii_rw(dev, np->phyaddr, MII_BMCR, MII_READ) & ~BMCR_PDOWN);\n\n\tnv_txrx_gate(dev, false);\n\t/* erase previous misconfiguration */\n\tif (np->driver_data & DEV_HAS_POWER_CNTRL)\n\t\tnv_mac_reset(dev);\n\twritel(NVREG_MCASTADDRA_FORCE, base + NvRegMulticastAddrA);\n\twritel(0, base + NvRegMulticastAddrB);\n\twritel(NVREG_MCASTMASKA_NONE, base + NvRegMulticastMaskA);\n\twritel(NVREG_MCASTMASKB_NONE, base + NvRegMulticastMaskB);\n\twritel(0, base + NvRegPacketFilterFlags);\n\n\twritel(0, base + NvRegTransmitterControl);\n\twritel(0, base + NvRegReceiverControl);\n\n\twritel(0, base + NvRegAdapterControl);\n\n\tif (np->pause_flags & NV_PAUSEFRAME_TX_CAPABLE)\n\t\twritel(NVREG_TX_PAUSEFRAME_DISABLE,  base + NvRegTxPauseFrame);\n\n\t/* initialize descriptor rings */\n\tset_bufsize(dev);\n\toom = nv_init_ring(dev);\n\n\twritel(0, base + NvRegLinkSpeed);\n\twritel(readl(base + NvRegTransmitPoll) & NVREG_TRANSMITPOLL_MAC_ADDR_REV, base + NvRegTransmitPoll);\n\tnv_txrx_reset(dev);\n\twritel(0, base + NvRegUnknownSetupReg6);\n\n\tnp->in_shutdown = 0;\n\n\t/* give hw rings */\n\tsetup_hw_rings(dev, NV_SETUP_RX_RING | NV_SETUP_TX_RING);\n\twritel(((np->rx_ring_size-1) << NVREG_RINGSZ_RXSHIFT) + ((np->tx_ring_size-1) << NVREG_RINGSZ_TXSHIFT),\n\t\tbase + NvRegRingSizes);\n\n\twritel(np->linkspeed, base + NvRegLinkSpeed);\n\tif (np->desc_ver == DESC_VER_1)\n\t\twritel(NVREG_TX_WM_DESC1_DEFAULT, base + NvRegTxWatermark);\n\telse\n\t\twritel(NVREG_TX_WM_DESC2_3_DEFAULT, base + NvRegTxWatermark);\n\twritel(np->txrxctl_bits, base + NvRegTxRxControl);\n\twritel(np->vlanctl_bits, base + NvRegVlanControl);\n\tpci_push(base);\n\twritel(NVREG_TXRXCTL_BIT1|np->txrxctl_bits, base + NvRegTxRxControl);\n\tif (reg_delay(dev, NvRegUnknownSetupReg5,\n\t\t      NVREG_UNKSETUP5_BIT31, NVREG_UNKSETUP5_BIT31,\n\t\t      NV_SETUP5_DELAY, NV_SETUP5_DELAYMAX))\n\t\tnetdev_info(dev,\n\t\t\t    \"%s: SetupReg5, Bit 31 remained off\\n\", __func__);\n\n\twritel(0, base + NvRegMIIMask);\n\twritel(NVREG_IRQSTAT_MASK, base + NvRegIrqStatus);\n\twritel(NVREG_MIISTAT_MASK_ALL, base + NvRegMIIStatus);\n\n\twritel(NVREG_MISC1_FORCE | NVREG_MISC1_HD, base + NvRegMisc1);\n\twritel(readl(base + NvRegTransmitterStatus), base + NvRegTransmitterStatus);\n\twritel(NVREG_PFF_ALWAYS, base + NvRegPacketFilterFlags);\n\twritel(np->rx_buf_sz, base + NvRegOffloadConfig);\n\n\twritel(readl(base + NvRegReceiverStatus), base + NvRegReceiverStatus);\n\n\tget_random_bytes(&low, sizeof(low));\n\tlow &= NVREG_SLOTTIME_MASK;\n\tif (np->desc_ver == DESC_VER_1) {\n\t\twritel(low|NVREG_SLOTTIME_DEFAULT, base + NvRegSlotTime);\n\t} else {\n\t\tif (!(np->driver_data & DEV_HAS_GEAR_MODE)) {\n\t\t\t/* setup legacy backoff */\n\t\t\twritel(NVREG_SLOTTIME_LEGBF_ENABLED|NVREG_SLOTTIME_10_100_FULL|low, base + NvRegSlotTime);\n\t\t} else {\n\t\t\twritel(NVREG_SLOTTIME_10_100_FULL, base + NvRegSlotTime);\n\t\t\tnv_gear_backoff_reseed(dev);\n\t\t}\n\t}\n\twritel(NVREG_TX_DEFERRAL_DEFAULT, base + NvRegTxDeferral);\n\twritel(NVREG_RX_DEFERRAL_DEFAULT, base + NvRegRxDeferral);\n\tif (poll_interval == -1) {\n\t\tif (optimization_mode == NV_OPTIMIZATION_MODE_THROUGHPUT)\n\t\t\twritel(NVREG_POLL_DEFAULT_THROUGHPUT, base + NvRegPollingInterval);\n\t\telse\n\t\t\twritel(NVREG_POLL_DEFAULT_CPU, base + NvRegPollingInterval);\n\t} else\n\t\twritel(poll_interval & 0xFFFF, base + NvRegPollingInterval);\n\twritel(NVREG_UNKSETUP6_VAL, base + NvRegUnknownSetupReg6);\n\twritel((np->phyaddr << NVREG_ADAPTCTL_PHYSHIFT)|NVREG_ADAPTCTL_PHYVALID|NVREG_ADAPTCTL_RUNNING,\n\t\t\tbase + NvRegAdapterControl);\n\twritel(NVREG_MIISPEED_BIT8|NVREG_MIIDELAY, base + NvRegMIISpeed);\n\twritel(NVREG_MII_LINKCHANGE, base + NvRegMIIMask);\n\tif (np->wolenabled)\n\t\twritel(NVREG_WAKEUPFLAGS_ENABLE , base + NvRegWakeUpFlags);\n\n\ti = readl(base + NvRegPowerState);\n\tif ((i & NVREG_POWERSTATE_POWEREDUP) == 0)\n\t\twritel(NVREG_POWERSTATE_POWEREDUP|i, base + NvRegPowerState);\n\n\tpci_push(base);\n\tudelay(10);\n\twritel(readl(base + NvRegPowerState) | NVREG_POWERSTATE_VALID, base + NvRegPowerState);\n\n\tnv_disable_hw_interrupts(dev, np->irqmask);\n\tpci_push(base);\n\twritel(NVREG_MIISTAT_MASK_ALL, base + NvRegMIIStatus);\n\twritel(NVREG_IRQSTAT_MASK, base + NvRegIrqStatus);\n\tpci_push(base);\n\n\tif (nv_request_irq(dev, 0))\n\t\tgoto out_drain;\n\n\t/* ask for interrupts */\n\tnv_enable_hw_interrupts(dev, np->irqmask);\n\n\tspin_lock_irq(&np->lock);\n\twritel(NVREG_MCASTADDRA_FORCE, base + NvRegMulticastAddrA);\n\twritel(0, base + NvRegMulticastAddrB);\n\twritel(NVREG_MCASTMASKA_NONE, base + NvRegMulticastMaskA);\n\twritel(NVREG_MCASTMASKB_NONE, base + NvRegMulticastMaskB);\n\twritel(NVREG_PFF_ALWAYS|NVREG_PFF_MYADDR, base + NvRegPacketFilterFlags);\n\t/* One manual link speed update: Interrupts are enabled, future link\n\t * speed changes cause interrupts and are handled by nv_link_irq().\n\t */\n\treadl(base + NvRegMIIStatus);\n\twritel(NVREG_MIISTAT_MASK_ALL, base + NvRegMIIStatus);\n\n\t/* set linkspeed to invalid value, thus force nv_update_linkspeed\n\t * to init hw */\n\tnp->linkspeed = 0;\n\tret = nv_update_linkspeed(dev);\n\tnv_start_rxtx(dev);\n\tnetif_start_queue(dev);\n\tnv_napi_enable(dev);\n\n\tif (ret) {\n\t\tnetif_carrier_on(dev);\n\t} else {\n\t\tnetdev_info(dev, \"no link during initialization\\n\");\n\t\tnetif_carrier_off(dev);\n\t}\n\tif (oom)\n\t\tmod_timer(&np->oom_kick, jiffies + OOM_REFILL);\n\n\t/* start statistics timer */\n\tif (np->driver_data & (DEV_HAS_STATISTICS_V1|DEV_HAS_STATISTICS_V2|DEV_HAS_STATISTICS_V3))\n\t\tmod_timer(&np->stats_poll,\n\t\t\tround_jiffies(jiffies + STATS_INTERVAL));\n\n\tspin_unlock_irq(&np->lock);\n\n\t/* If the loopback feature was set while the device was down, make sure\n\t * that it's set correctly now.\n\t */\n\tif (dev->features & NETIF_F_LOOPBACK)\n\t\tnv_set_loopback(dev, dev->features);\n\n\treturn 0;\nout_drain:\n\tnv_drain_rxtx(dev);\n\treturn ret;\n}\n\nstatic int nv_close(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base;\n\n\tspin_lock_irq(&np->lock);\n\tnp->in_shutdown = 1;\n\tspin_unlock_irq(&np->lock);\n\tnv_napi_disable(dev);\n\tsynchronize_irq(np->pci_dev->irq);\n\n\tdel_timer_sync(&np->oom_kick);\n\tdel_timer_sync(&np->nic_poll);\n\tdel_timer_sync(&np->stats_poll);\n\n\tnetif_stop_queue(dev);\n\tspin_lock_irq(&np->lock);\n\tnv_update_pause(dev, 0); /* otherwise stop_tx bricks NIC */\n\tnv_stop_rxtx(dev);\n\tnv_txrx_reset(dev);\n\n\t/* disable interrupts on the nic or we will lock up */\n\tbase = get_hwbase(dev);\n\tnv_disable_hw_interrupts(dev, np->irqmask);\n\tpci_push(base);\n\n\tspin_unlock_irq(&np->lock);\n\n\tnv_free_irq(dev);\n\n\tnv_drain_rxtx(dev);\n\n\tif (np->wolenabled || !phy_power_down) {\n\t\tnv_txrx_gate(dev, false);\n\t\twritel(NVREG_PFF_ALWAYS|NVREG_PFF_MYADDR, base + NvRegPacketFilterFlags);\n\t\tnv_start_rx(dev);\n\t} else {\n\t\t/* power down phy */\n\t\tmii_rw(dev, np->phyaddr, MII_BMCR,\n\t\t       mii_rw(dev, np->phyaddr, MII_BMCR, MII_READ)|BMCR_PDOWN);\n\t\tnv_txrx_gate(dev, true);\n\t}\n\n\t/* FIXME: power down nic */\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops nv_netdev_ops = {\n\t.ndo_open\t\t= nv_open,\n\t.ndo_stop\t\t= nv_close,\n\t.ndo_get_stats64\t= nv_get_stats64,\n\t.ndo_start_xmit\t\t= nv_start_xmit,\n\t.ndo_tx_timeout\t\t= nv_tx_timeout,\n\t.ndo_change_mtu\t\t= nv_change_mtu,\n\t.ndo_fix_features\t= nv_fix_features,\n\t.ndo_set_features\t= nv_set_features,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= nv_set_mac_address,\n\t.ndo_set_rx_mode\t= nv_set_multicast,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= nv_poll_controller,\n#endif\n};\n\nstatic const struct net_device_ops nv_netdev_ops_optimized = {\n\t.ndo_open\t\t= nv_open,\n\t.ndo_stop\t\t= nv_close,\n\t.ndo_get_stats64\t= nv_get_stats64,\n\t.ndo_start_xmit\t\t= nv_start_xmit_optimized,\n\t.ndo_tx_timeout\t\t= nv_tx_timeout,\n\t.ndo_change_mtu\t\t= nv_change_mtu,\n\t.ndo_fix_features\t= nv_fix_features,\n\t.ndo_set_features\t= nv_set_features,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= nv_set_mac_address,\n\t.ndo_set_rx_mode\t= nv_set_multicast,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= nv_poll_controller,\n#endif\n};\n\nstatic int nv_probe(struct pci_dev *pci_dev, const struct pci_device_id *id)\n{\n\tstruct net_device *dev;\n\tstruct fe_priv *np;\n\tunsigned long addr;\n\tu8 __iomem *base;\n\tint err, i;\n\tu32 powerstate, txreg;\n\tu32 phystate_orig = 0, phystate;\n\tint phyinitialized = 0;\n\tstatic int printed_version;\n\n\tif (!printed_version++)\n\t\tpr_info(\"Reverse Engineered nForce ethernet driver. Version %s.\\n\",\n\t\t\tFORCEDETH_VERSION);\n\n\tdev = alloc_etherdev(sizeof(struct fe_priv));\n\terr = -ENOMEM;\n\tif (!dev)\n\t\tgoto out;\n\n\tnp = netdev_priv(dev);\n\tnp->dev = dev;\n\tnp->pci_dev = pci_dev;\n\tspin_lock_init(&np->lock);\n\tspin_lock_init(&np->hwstats_lock);\n\tSET_NETDEV_DEV(dev, &pci_dev->dev);\n\tu64_stats_init(&np->swstats_rx_syncp);\n\tu64_stats_init(&np->swstats_tx_syncp);\n\tnp->txrx_stats = alloc_percpu(struct nv_txrx_stats);\n\tif (!np->txrx_stats) {\n\t\tpr_err(\"np->txrx_stats, alloc memory error.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out_alloc_percpu;\n\t}\n\n\ttimer_setup(&np->oom_kick, nv_do_rx_refill, 0);\n\ttimer_setup(&np->nic_poll, nv_do_nic_poll, 0);\n\ttimer_setup(&np->stats_poll, nv_do_stats_poll, TIMER_DEFERRABLE);\n\n\terr = pci_enable_device(pci_dev);\n\tif (err)\n\t\tgoto out_free;\n\n\tpci_set_master(pci_dev);\n\n\terr = pci_request_regions(pci_dev, DRV_NAME);\n\tif (err < 0)\n\t\tgoto out_disable;\n\n\tif (id->driver_data & (DEV_HAS_VLAN|DEV_HAS_MSI_X|DEV_HAS_POWER_CNTRL|DEV_HAS_STATISTICS_V2|DEV_HAS_STATISTICS_V3))\n\t\tnp->register_size = NV_PCI_REGSZ_VER3;\n\telse if (id->driver_data & DEV_HAS_STATISTICS_V1)\n\t\tnp->register_size = NV_PCI_REGSZ_VER2;\n\telse\n\t\tnp->register_size = NV_PCI_REGSZ_VER1;\n\n\terr = -EINVAL;\n\taddr = 0;\n\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\n\t\tif (pci_resource_flags(pci_dev, i) & IORESOURCE_MEM &&\n\t\t\t\tpci_resource_len(pci_dev, i) >= np->register_size) {\n\t\t\taddr = pci_resource_start(pci_dev, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == DEVICE_COUNT_RESOURCE) {\n\t\tdev_info(&pci_dev->dev, \"Couldn't find register window\\n\");\n\t\tgoto out_relreg;\n\t}\n\n\t/* copy of driver data */\n\tnp->driver_data = id->driver_data;\n\t/* copy of device id */\n\tnp->device_id = id->device;\n\n\t/* handle different descriptor versions */\n\tif (id->driver_data & DEV_HAS_HIGH_DMA) {\n\t\t/* packet format 3: supports 40-bit addressing */\n\t\tnp->desc_ver = DESC_VER_3;\n\t\tnp->txrxctl_bits = NVREG_TXRXCTL_DESC_3;\n\t\tif (dma_64bit) {\n\t\t\tif (pci_set_dma_mask(pci_dev, DMA_BIT_MASK(39)))\n\t\t\t\tdev_info(&pci_dev->dev,\n\t\t\t\t\t \"64-bit DMA failed, using 32-bit addressing\\n\");\n\t\t\telse\n\t\t\t\tdev->features |= NETIF_F_HIGHDMA;\n\t\t\tif (pci_set_consistent_dma_mask(pci_dev, DMA_BIT_MASK(39))) {\n\t\t\t\tdev_info(&pci_dev->dev,\n\t\t\t\t\t \"64-bit DMA (consistent) failed, using 32-bit ring buffers\\n\");\n\t\t\t}\n\t\t}\n\t} else if (id->driver_data & DEV_HAS_LARGEDESC) {\n\t\t/* packet format 2: supports jumbo frames */\n\t\tnp->desc_ver = DESC_VER_2;\n\t\tnp->txrxctl_bits = NVREG_TXRXCTL_DESC_2;\n\t} else {\n\t\t/* original packet format */\n\t\tnp->desc_ver = DESC_VER_1;\n\t\tnp->txrxctl_bits = NVREG_TXRXCTL_DESC_1;\n\t}\n\n\tnp->pkt_limit = NV_PKTLIMIT_1;\n\tif (id->driver_data & DEV_HAS_LARGEDESC)\n\t\tnp->pkt_limit = NV_PKTLIMIT_2;\n\n\tif (id->driver_data & DEV_HAS_CHECKSUM) {\n\t\tnp->txrxctl_bits |= NVREG_TXRXCTL_RXCHECK;\n\t\tdev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_SG |\n\t\t\tNETIF_F_TSO | NETIF_F_RXCSUM;\n\t}\n\n\tnp->vlanctl_bits = 0;\n\tif (id->driver_data & DEV_HAS_VLAN) {\n\t\tnp->vlanctl_bits = NVREG_VLANCONTROL_ENABLE;\n\t\tdev->hw_features |= NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t\t    NETIF_F_HW_VLAN_CTAG_TX;\n\t}\n\n\tdev->features |= dev->hw_features;\n\n\t/* Add loopback capability to the device. */\n\tdev->hw_features |= NETIF_F_LOOPBACK;\n\n\t/* MTU range: 64 - 1500 or 9100 */\n\tdev->min_mtu = ETH_ZLEN + ETH_FCS_LEN;\n\tdev->max_mtu = np->pkt_limit;\n\n\tnp->pause_flags = NV_PAUSEFRAME_RX_CAPABLE | NV_PAUSEFRAME_RX_REQ | NV_PAUSEFRAME_AUTONEG;\n\tif ((id->driver_data & DEV_HAS_PAUSEFRAME_TX_V1) ||\n\t    (id->driver_data & DEV_HAS_PAUSEFRAME_TX_V2) ||\n\t    (id->driver_data & DEV_HAS_PAUSEFRAME_TX_V3)) {\n\t\tnp->pause_flags |= NV_PAUSEFRAME_TX_CAPABLE | NV_PAUSEFRAME_TX_REQ;\n\t}\n\n\terr = -ENOMEM;\n\tnp->base = ioremap(addr, np->register_size);\n\tif (!np->base)\n\t\tgoto out_relreg;\n\n\tnp->rx_ring_size = RX_RING_DEFAULT;\n\tnp->tx_ring_size = TX_RING_DEFAULT;\n\n\tif (!nv_optimized(np)) {\n\t\tnp->rx_ring.orig = dma_alloc_coherent(&pci_dev->dev,\n\t\t\t\t\t\t      sizeof(struct ring_desc) *\n\t\t\t\t\t\t      (np->rx_ring_size +\n\t\t\t\t\t\t      np->tx_ring_size),\n\t\t\t\t\t\t      &np->ring_addr,\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!np->rx_ring.orig)\n\t\t\tgoto out_unmap;\n\t\tnp->tx_ring.orig = &np->rx_ring.orig[np->rx_ring_size];\n\t} else {\n\t\tnp->rx_ring.ex = dma_alloc_coherent(&pci_dev->dev,\n\t\t\t\t\t\t    sizeof(struct ring_desc_ex) *\n\t\t\t\t\t\t    (np->rx_ring_size +\n\t\t\t\t\t\t    np->tx_ring_size),\n\t\t\t\t\t\t    &np->ring_addr, GFP_KERNEL);\n\t\tif (!np->rx_ring.ex)\n\t\t\tgoto out_unmap;\n\t\tnp->tx_ring.ex = &np->rx_ring.ex[np->rx_ring_size];\n\t}\n\tnp->rx_skb = kcalloc(np->rx_ring_size, sizeof(struct nv_skb_map), GFP_KERNEL);\n\tnp->tx_skb = kcalloc(np->tx_ring_size, sizeof(struct nv_skb_map), GFP_KERNEL);\n\tif (!np->rx_skb || !np->tx_skb)\n\t\tgoto out_freering;\n\n\tif (!nv_optimized(np))\n\t\tdev->netdev_ops = &nv_netdev_ops;\n\telse\n\t\tdev->netdev_ops = &nv_netdev_ops_optimized;\n\n\tnetif_napi_add(dev, &np->napi, nv_napi_poll, RX_WORK_PER_LOOP);\n\tdev->ethtool_ops = &ops;\n\tdev->watchdog_timeo = NV_WATCHDOG_TIMEO;\n\n\tpci_set_drvdata(pci_dev, dev);\n\n\t/* read the mac address */\n\tbase = get_hwbase(dev);\n\tnp->orig_mac[0] = readl(base + NvRegMacAddrA);\n\tnp->orig_mac[1] = readl(base + NvRegMacAddrB);\n\n\t/* check the workaround bit for correct mac address order */\n\ttxreg = readl(base + NvRegTransmitPoll);\n\tif (id->driver_data & DEV_HAS_CORRECT_MACADDR) {\n\t\t/* mac address is already in correct order */\n\t\tdev->dev_addr[0] = (np->orig_mac[0] >>  0) & 0xff;\n\t\tdev->dev_addr[1] = (np->orig_mac[0] >>  8) & 0xff;\n\t\tdev->dev_addr[2] = (np->orig_mac[0] >> 16) & 0xff;\n\t\tdev->dev_addr[3] = (np->orig_mac[0] >> 24) & 0xff;\n\t\tdev->dev_addr[4] = (np->orig_mac[1] >>  0) & 0xff;\n\t\tdev->dev_addr[5] = (np->orig_mac[1] >>  8) & 0xff;\n\t} else if (txreg & NVREG_TRANSMITPOLL_MAC_ADDR_REV) {\n\t\t/* mac address is already in correct order */\n\t\tdev->dev_addr[0] = (np->orig_mac[0] >>  0) & 0xff;\n\t\tdev->dev_addr[1] = (np->orig_mac[0] >>  8) & 0xff;\n\t\tdev->dev_addr[2] = (np->orig_mac[0] >> 16) & 0xff;\n\t\tdev->dev_addr[3] = (np->orig_mac[0] >> 24) & 0xff;\n\t\tdev->dev_addr[4] = (np->orig_mac[1] >>  0) & 0xff;\n\t\tdev->dev_addr[5] = (np->orig_mac[1] >>  8) & 0xff;\n\t\t/*\n\t\t * Set orig mac address back to the reversed version.\n\t\t * This flag will be cleared during low power transition.\n\t\t * Therefore, we should always put back the reversed address.\n\t\t */\n\t\tnp->orig_mac[0] = (dev->dev_addr[5] << 0) + (dev->dev_addr[4] << 8) +\n\t\t\t(dev->dev_addr[3] << 16) + (dev->dev_addr[2] << 24);\n\t\tnp->orig_mac[1] = (dev->dev_addr[1] << 0) + (dev->dev_addr[0] << 8);\n\t} else {\n\t\t/* need to reverse mac address to correct order */\n\t\tdev->dev_addr[0] = (np->orig_mac[1] >>  8) & 0xff;\n\t\tdev->dev_addr[1] = (np->orig_mac[1] >>  0) & 0xff;\n\t\tdev->dev_addr[2] = (np->orig_mac[0] >> 24) & 0xff;\n\t\tdev->dev_addr[3] = (np->orig_mac[0] >> 16) & 0xff;\n\t\tdev->dev_addr[4] = (np->orig_mac[0] >>  8) & 0xff;\n\t\tdev->dev_addr[5] = (np->orig_mac[0] >>  0) & 0xff;\n\t\twritel(txreg|NVREG_TRANSMITPOLL_MAC_ADDR_REV, base + NvRegTransmitPoll);\n\t\tdev_dbg(&pci_dev->dev,\n\t\t\t\"%s: set workaround bit for reversed mac addr\\n\",\n\t\t\t__func__);\n\t}\n\n\tif (!is_valid_ether_addr(dev->dev_addr)) {\n\t\t/*\n\t\t * Bad mac address. At least one bios sets the mac address\n\t\t * to 01:23:45:67:89:ab\n\t\t */\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"Invalid MAC address detected: %pM - Please complain to your hardware vendor.\\n\",\n\t\t\tdev->dev_addr);\n\t\teth_hw_addr_random(dev);\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"Using random MAC address: %pM\\n\", dev->dev_addr);\n\t}\n\n\t/* set mac address */\n\tnv_copy_mac_to_hw(dev);\n\n\t/* disable WOL */\n\twritel(0, base + NvRegWakeUpFlags);\n\tnp->wolenabled = 0;\n\tdevice_set_wakeup_enable(&pci_dev->dev, false);\n\n\tif (id->driver_data & DEV_HAS_POWER_CNTRL) {\n\n\t\t/* take phy and nic out of low power mode */\n\t\tpowerstate = readl(base + NvRegPowerState2);\n\t\tpowerstate &= ~NVREG_POWERSTATE2_POWERUP_MASK;\n\t\tif ((id->driver_data & DEV_NEED_LOW_POWER_FIX) &&\n\t\t    pci_dev->revision >= 0xA3)\n\t\t\tpowerstate |= NVREG_POWERSTATE2_POWERUP_REV_A3;\n\t\twritel(powerstate, base + NvRegPowerState2);\n\t}\n\n\tif (np->desc_ver == DESC_VER_1)\n\t\tnp->tx_flags = NV_TX_VALID;\n\telse\n\t\tnp->tx_flags = NV_TX2_VALID;\n\n\tnp->msi_flags = 0;\n\tif ((id->driver_data & DEV_HAS_MSI) && msi)\n\t\tnp->msi_flags |= NV_MSI_CAPABLE;\n\n\tif ((id->driver_data & DEV_HAS_MSI_X) && msix) {\n\t\t/* msix has had reported issues when modifying irqmask\n\t\t   as in the case of napi, therefore, disable for now\n\t\t*/\n#if 0\n\t\tnp->msi_flags |= NV_MSI_X_CAPABLE;\n#endif\n\t}\n\n\tif (optimization_mode == NV_OPTIMIZATION_MODE_CPU) {\n\t\tnp->irqmask = NVREG_IRQMASK_CPU;\n\t\tif (np->msi_flags & NV_MSI_X_CAPABLE) /* set number of vectors */\n\t\t\tnp->msi_flags |= 0x0001;\n\t} else if (optimization_mode == NV_OPTIMIZATION_MODE_DYNAMIC &&\n\t\t   !(id->driver_data & DEV_NEED_TIMERIRQ)) {\n\t\t/* start off in throughput mode */\n\t\tnp->irqmask = NVREG_IRQMASK_THROUGHPUT;\n\t\t/* remove support for msix mode */\n\t\tnp->msi_flags &= ~NV_MSI_X_CAPABLE;\n\t} else {\n\t\toptimization_mode = NV_OPTIMIZATION_MODE_THROUGHPUT;\n\t\tnp->irqmask = NVREG_IRQMASK_THROUGHPUT;\n\t\tif (np->msi_flags & NV_MSI_X_CAPABLE) /* set number of vectors */\n\t\t\tnp->msi_flags |= 0x0003;\n\t}\n\n\tif (id->driver_data & DEV_NEED_TIMERIRQ)\n\t\tnp->irqmask |= NVREG_IRQ_TIMER;\n\tif (id->driver_data & DEV_NEED_LINKTIMER) {\n\t\tnp->need_linktimer = 1;\n\t\tnp->link_timeout = jiffies + LINK_TIMEOUT;\n\t} else {\n\t\tnp->need_linktimer = 0;\n\t}\n\n\t/* Limit the number of tx's outstanding for hw bug */\n\tif (id->driver_data & DEV_NEED_TX_LIMIT) {\n\t\tnp->tx_limit = 1;\n\t\tif (((id->driver_data & DEV_NEED_TX_LIMIT2) == DEV_NEED_TX_LIMIT2) &&\n\t\t    pci_dev->revision >= 0xA2)\n\t\t\tnp->tx_limit = 0;\n\t}\n\n\t/* clear phy state and temporarily halt phy interrupts */\n\twritel(0, base + NvRegMIIMask);\n\tphystate = readl(base + NvRegAdapterControl);\n\tif (phystate & NVREG_ADAPTCTL_RUNNING) {\n\t\tphystate_orig = 1;\n\t\tphystate &= ~NVREG_ADAPTCTL_RUNNING;\n\t\twritel(phystate, base + NvRegAdapterControl);\n\t}\n\twritel(NVREG_MIISTAT_MASK_ALL, base + NvRegMIIStatus);\n\n\tif (id->driver_data & DEV_HAS_MGMT_UNIT) {\n\t\t/* management unit running on the mac? */\n\t\tif ((readl(base + NvRegTransmitterControl) & NVREG_XMITCTL_MGMT_ST) &&\n\t\t    (readl(base + NvRegTransmitterControl) & NVREG_XMITCTL_SYNC_PHY_INIT) &&\n\t\t    nv_mgmt_acquire_sema(dev) &&\n\t\t    nv_mgmt_get_version(dev)) {\n\t\t\tnp->mac_in_use = 1;\n\t\t\tif (np->mgmt_version > 0)\n\t\t\t\tnp->mac_in_use = readl(base + NvRegMgmtUnitControl) & NVREG_MGMTUNITCONTROL_INUSE;\n\t\t\t/* management unit setup the phy already? */\n\t\t\tif (np->mac_in_use &&\n\t\t\t    ((readl(base + NvRegTransmitterControl) & NVREG_XMITCTL_SYNC_MASK) ==\n\t\t\t     NVREG_XMITCTL_SYNC_PHY_INIT)) {\n\t\t\t\t/* phy is inited by mgmt unit */\n\t\t\t\tphyinitialized = 1;\n\t\t\t} else {\n\t\t\t\t/* we need to init the phy */\n\t\t\t}\n\t\t}\n\t}\n\n\t/* find a suitable phy */\n\tfor (i = 1; i <= 32; i++) {\n\t\tint id1, id2;\n\t\tint phyaddr = i & 0x1F;\n\n\t\tspin_lock_irq(&np->lock);\n\t\tid1 = mii_rw(dev, phyaddr, MII_PHYSID1, MII_READ);\n\t\tspin_unlock_irq(&np->lock);\n\t\tif (id1 < 0 || id1 == 0xffff)\n\t\t\tcontinue;\n\t\tspin_lock_irq(&np->lock);\n\t\tid2 = mii_rw(dev, phyaddr, MII_PHYSID2, MII_READ);\n\t\tspin_unlock_irq(&np->lock);\n\t\tif (id2 < 0 || id2 == 0xffff)\n\t\t\tcontinue;\n\n\t\tnp->phy_model = id2 & PHYID2_MODEL_MASK;\n\t\tid1 = (id1 & PHYID1_OUI_MASK) << PHYID1_OUI_SHFT;\n\t\tid2 = (id2 & PHYID2_OUI_MASK) >> PHYID2_OUI_SHFT;\n\t\tnp->phyaddr = phyaddr;\n\t\tnp->phy_oui = id1 | id2;\n\n\t\t/* Realtek hardcoded phy id1 to all zero's on certain phys */\n\t\tif (np->phy_oui == PHY_OUI_REALTEK2)\n\t\t\tnp->phy_oui = PHY_OUI_REALTEK;\n\t\t/* Setup phy revision for Realtek */\n\t\tif (np->phy_oui == PHY_OUI_REALTEK && np->phy_model == PHY_MODEL_REALTEK_8211)\n\t\t\tnp->phy_rev = mii_rw(dev, phyaddr, MII_RESV1, MII_READ) & PHY_REV_MASK;\n\n\t\tbreak;\n\t}\n\tif (i == 33) {\n\t\tdev_info(&pci_dev->dev, \"open: Could not find a valid PHY\\n\");\n\t\tgoto out_error;\n\t}\n\n\tif (!phyinitialized) {\n\t\t/* reset it */\n\t\tphy_init(dev);\n\t} else {\n\t\t/* see if it is a gigabit phy */\n\t\tu32 mii_status = mii_rw(dev, np->phyaddr, MII_BMSR, MII_READ);\n\t\tif (mii_status & PHY_GIGABIT)\n\t\t\tnp->gigabit = PHY_GIGABIT;\n\t}\n\n\t/* set default link speed settings */\n\tnp->linkspeed = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_10;\n\tnp->duplex = 0;\n\tnp->autoneg = 1;\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tdev_info(&pci_dev->dev, \"unable to register netdev: %d\\n\", err);\n\t\tgoto out_error;\n\t}\n\n\tnetif_carrier_off(dev);\n\n\t/* Some NICs freeze when TX pause is enabled while NIC is\n\t * down, and this stays across warm reboots. The sequence\n\t * below should be enough to recover from that state.\n\t */\n\tnv_update_pause(dev, 0);\n\tnv_start_tx(dev);\n\tnv_stop_tx(dev);\n\n\tif (id->driver_data & DEV_HAS_VLAN)\n\t\tnv_vlan_mode(dev, dev->features);\n\n\tdev_info(&pci_dev->dev, \"ifname %s, PHY OUI 0x%x @ %d, addr %pM\\n\",\n\t\t dev->name, np->phy_oui, np->phyaddr, dev->dev_addr);\n\n\tdev_info(&pci_dev->dev, \"%s%s%s%s%s%s%s%s%s%s%sdesc-v%u\\n\",\n\t\t dev->features & NETIF_F_HIGHDMA ? \"highdma \" : \"\",\n\t\t dev->features & (NETIF_F_IP_CSUM | NETIF_F_SG) ?\n\t\t\t\"csum \" : \"\",\n\t\t dev->features & (NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t\t  NETIF_F_HW_VLAN_CTAG_TX) ?\n\t\t\t\"vlan \" : \"\",\n\t\t dev->features & (NETIF_F_LOOPBACK) ?\n\t\t\t\"loopback \" : \"\",\n\t\t id->driver_data & DEV_HAS_POWER_CNTRL ? \"pwrctl \" : \"\",\n\t\t id->driver_data & DEV_HAS_MGMT_UNIT ? \"mgmt \" : \"\",\n\t\t id->driver_data & DEV_NEED_TIMERIRQ ? \"timirq \" : \"\",\n\t\t np->gigabit == PHY_GIGABIT ? \"gbit \" : \"\",\n\t\t np->need_linktimer ? \"lnktim \" : \"\",\n\t\t np->msi_flags & NV_MSI_CAPABLE ? \"msi \" : \"\",\n\t\t np->msi_flags & NV_MSI_X_CAPABLE ? \"msi-x \" : \"\",\n\t\t np->desc_ver);\n\n\treturn 0;\n\nout_error:\n\tif (phystate_orig)\n\t\twritel(phystate|NVREG_ADAPTCTL_RUNNING, base + NvRegAdapterControl);\nout_freering:\n\tfree_rings(dev);\nout_unmap:\n\tiounmap(get_hwbase(dev));\nout_relreg:\n\tpci_release_regions(pci_dev);\nout_disable:\n\tpci_disable_device(pci_dev);\nout_free:\n\tfree_percpu(np->txrx_stats);\nout_alloc_percpu:\n\tfree_netdev(dev);\nout:\n\treturn err;\n}\n\nstatic void nv_restore_phy(struct net_device *dev)\n{\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu16 phy_reserved, mii_control;\n\n\tif (np->phy_oui == PHY_OUI_REALTEK &&\n\t    np->phy_model == PHY_MODEL_REALTEK_8201 &&\n\t    phy_cross == NV_CROSSOVER_DETECTION_DISABLED) {\n\t\tmii_rw(dev, np->phyaddr, PHY_REALTEK_INIT_REG1, PHY_REALTEK_INIT3);\n\t\tphy_reserved = mii_rw(dev, np->phyaddr, PHY_REALTEK_INIT_REG2, MII_READ);\n\t\tphy_reserved &= ~PHY_REALTEK_INIT_MSK1;\n\t\tphy_reserved |= PHY_REALTEK_INIT8;\n\t\tmii_rw(dev, np->phyaddr, PHY_REALTEK_INIT_REG2, phy_reserved);\n\t\tmii_rw(dev, np->phyaddr, PHY_REALTEK_INIT_REG1, PHY_REALTEK_INIT1);\n\n\t\t/* restart auto negotiation */\n\t\tmii_control = mii_rw(dev, np->phyaddr, MII_BMCR, MII_READ);\n\t\tmii_control |= (BMCR_ANRESTART | BMCR_ANENABLE);\n\t\tmii_rw(dev, np->phyaddr, MII_BMCR, mii_control);\n\t}\n}\n\nstatic void nv_restore_mac_addr(struct pci_dev *pci_dev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pci_dev);\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\n\t/* special op: write back the misordered MAC address - otherwise\n\t * the next nv_probe would see a wrong address.\n\t */\n\twritel(np->orig_mac[0], base + NvRegMacAddrA);\n\twritel(np->orig_mac[1], base + NvRegMacAddrB);\n\twritel(readl(base + NvRegTransmitPoll) & ~NVREG_TRANSMITPOLL_MAC_ADDR_REV,\n\t       base + NvRegTransmitPoll);\n}\n\nstatic void nv_remove(struct pci_dev *pci_dev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pci_dev);\n\tstruct fe_priv *np = netdev_priv(dev);\n\n\tfree_percpu(np->txrx_stats);\n\n\tunregister_netdev(dev);\n\n\tnv_restore_mac_addr(pci_dev);\n\n\t/* restore any phy related changes */\n\tnv_restore_phy(dev);\n\n\tnv_mgmt_release_sema(dev);\n\n\t/* free all structures */\n\tfree_rings(dev);\n\tiounmap(get_hwbase(dev));\n\tpci_release_regions(pci_dev);\n\tpci_disable_device(pci_dev);\n\tfree_netdev(dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int nv_suspend(struct device *device)\n{\n\tstruct net_device *dev = dev_get_drvdata(device);\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tint i;\n\n\tif (netif_running(dev)) {\n\t\t/* Gross. */\n\t\tnv_close(dev);\n\t}\n\tnetif_device_detach(dev);\n\n\t/* save non-pci configuration space */\n\tfor (i = 0; i <= np->register_size/sizeof(u32); i++)\n\t\tnp->saved_config_space[i] = readl(base + i*sizeof(u32));\n\n\treturn 0;\n}\n\nstatic int nv_resume(struct device *device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct fe_priv *np = netdev_priv(dev);\n\tu8 __iomem *base = get_hwbase(dev);\n\tint i, rc = 0;\n\n\t/* restore non-pci configuration space */\n\tfor (i = 0; i <= np->register_size/sizeof(u32); i++)\n\t\twritel(np->saved_config_space[i], base+i*sizeof(u32));\n\n\tif (np->driver_data & DEV_NEED_MSI_FIX)\n\t\tpci_write_config_dword(pdev, NV_MSI_PRIV_OFFSET, NV_MSI_PRIV_VALUE);\n\n\t/* restore phy state, including autoneg */\n\tphy_init(dev);\n\n\tnetif_device_attach(dev);\n\tif (netif_running(dev)) {\n\t\trc = nv_open(dev);\n\t\tnv_set_multicast(dev);\n\t}\n\treturn rc;\n}\n\nstatic SIMPLE_DEV_PM_OPS(nv_pm_ops, nv_suspend, nv_resume);\n#define NV_PM_OPS (&nv_pm_ops)\n\n#else\n#define NV_PM_OPS NULL\n#endif /* CONFIG_PM_SLEEP */\n\n#ifdef CONFIG_PM\nstatic void nv_shutdown(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct fe_priv *np = netdev_priv(dev);\n\n\tif (netif_running(dev))\n\t\tnv_close(dev);\n\n\t/*\n\t * Restore the MAC so a kernel started by kexec won't get confused.\n\t * If we really go for poweroff, we must not restore the MAC,\n\t * otherwise the MAC for WOL will be reversed at least on some boards.\n\t */\n\tif (system_state != SYSTEM_POWER_OFF)\n\t\tnv_restore_mac_addr(pdev);\n\n\tpci_disable_device(pdev);\n\t/*\n\t * Apparently it is not possible to reinitialise from D3 hot,\n\t * only put the device into D3 if we really go for poweroff.\n\t */\n\tif (system_state == SYSTEM_POWER_OFF) {\n\t\tpci_wake_from_d3(pdev, np->wolenabled);\n\t\tpci_set_power_state(pdev, PCI_D3hot);\n\t}\n}\n#else\n#define nv_shutdown NULL\n#endif /* CONFIG_PM */\n\nstatic const struct pci_device_id pci_tbl[] = {\n\t{\t/* nForce Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x01C3),\n\t\t.driver_data = DEV_NEED_TIMERIRQ|DEV_NEED_LINKTIMER,\n\t},\n\t{\t/* nForce2 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0066),\n\t\t.driver_data = DEV_NEED_TIMERIRQ|DEV_NEED_LINKTIMER,\n\t},\n\t{\t/* nForce3 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x00D6),\n\t\t.driver_data = DEV_NEED_TIMERIRQ|DEV_NEED_LINKTIMER,\n\t},\n\t{\t/* nForce3 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0086),\n\t\t.driver_data = DEV_NEED_TIMERIRQ|DEV_NEED_LINKTIMER|DEV_HAS_LARGEDESC|DEV_HAS_CHECKSUM,\n\t},\n\t{\t/* nForce3 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x008C),\n\t\t.driver_data = DEV_NEED_TIMERIRQ|DEV_NEED_LINKTIMER|DEV_HAS_LARGEDESC|DEV_HAS_CHECKSUM,\n\t},\n\t{\t/* nForce3 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x00E6),\n\t\t.driver_data = DEV_NEED_TIMERIRQ|DEV_NEED_LINKTIMER|DEV_HAS_LARGEDESC|DEV_HAS_CHECKSUM,\n\t},\n\t{\t/* nForce3 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x00DF),\n\t\t.driver_data = DEV_NEED_TIMERIRQ|DEV_NEED_LINKTIMER|DEV_HAS_LARGEDESC|DEV_HAS_CHECKSUM,\n\t},\n\t{\t/* CK804 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0056),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_LARGEDESC|DEV_HAS_CHECKSUM|DEV_HAS_HIGH_DMA|DEV_HAS_STATISTICS_V1|DEV_NEED_TX_LIMIT,\n\t},\n\t{\t/* CK804 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0057),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_LARGEDESC|DEV_HAS_CHECKSUM|DEV_HAS_HIGH_DMA|DEV_HAS_STATISTICS_V1|DEV_NEED_TX_LIMIT,\n\t},\n\t{\t/* MCP04 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0037),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_LARGEDESC|DEV_HAS_CHECKSUM|DEV_HAS_HIGH_DMA|DEV_HAS_STATISTICS_V1|DEV_NEED_TX_LIMIT,\n\t},\n\t{\t/* MCP04 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0038),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_LARGEDESC|DEV_HAS_CHECKSUM|DEV_HAS_HIGH_DMA|DEV_HAS_STATISTICS_V1|DEV_NEED_TX_LIMIT,\n\t},\n\t{\t/* MCP51 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0268),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_HIGH_DMA|DEV_HAS_POWER_CNTRL|DEV_HAS_STATISTICS_V1|DEV_NEED_LOW_POWER_FIX,\n\t},\n\t{\t/* MCP51 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0269),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_HIGH_DMA|DEV_HAS_POWER_CNTRL|DEV_HAS_STATISTICS_V1|DEV_NEED_LOW_POWER_FIX,\n\t},\n\t{\t/* MCP55 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0372),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_LARGEDESC|DEV_HAS_CHECKSUM|DEV_HAS_HIGH_DMA|DEV_HAS_VLAN|DEV_HAS_MSI|DEV_HAS_MSI_X|DEV_HAS_POWER_CNTRL|DEV_HAS_PAUSEFRAME_TX_V1|DEV_HAS_STATISTICS_V12|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_NEED_TX_LIMIT|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP55 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0373),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_LARGEDESC|DEV_HAS_CHECKSUM|DEV_HAS_HIGH_DMA|DEV_HAS_VLAN|DEV_HAS_MSI|DEV_HAS_MSI_X|DEV_HAS_POWER_CNTRL|DEV_HAS_PAUSEFRAME_TX_V1|DEV_HAS_STATISTICS_V12|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_NEED_TX_LIMIT|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP61 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x03E5),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_HIGH_DMA|DEV_HAS_POWER_CNTRL|DEV_HAS_MSI|DEV_HAS_PAUSEFRAME_TX_V1|DEV_HAS_STATISTICS_V12|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP61 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x03E6),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_HIGH_DMA|DEV_HAS_POWER_CNTRL|DEV_HAS_MSI|DEV_HAS_PAUSEFRAME_TX_V1|DEV_HAS_STATISTICS_V12|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP61 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x03EE),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_HIGH_DMA|DEV_HAS_POWER_CNTRL|DEV_HAS_MSI|DEV_HAS_PAUSEFRAME_TX_V1|DEV_HAS_STATISTICS_V12|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP61 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x03EF),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_HIGH_DMA|DEV_HAS_POWER_CNTRL|DEV_HAS_MSI|DEV_HAS_PAUSEFRAME_TX_V1|DEV_HAS_STATISTICS_V12|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP65 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0450),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_LARGEDESC|DEV_HAS_HIGH_DMA|DEV_HAS_POWER_CNTRL|DEV_HAS_MSI|DEV_HAS_PAUSEFRAME_TX_V1|DEV_HAS_STATISTICS_V12|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_NEED_TX_LIMIT|DEV_HAS_GEAR_MODE|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP65 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0451),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_LARGEDESC|DEV_HAS_HIGH_DMA|DEV_HAS_POWER_CNTRL|DEV_HAS_MSI|DEV_HAS_PAUSEFRAME_TX_V1|DEV_HAS_STATISTICS_V12|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_NEED_TX_LIMIT|DEV_HAS_GEAR_MODE|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP65 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0452),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_LARGEDESC|DEV_HAS_HIGH_DMA|DEV_HAS_POWER_CNTRL|DEV_HAS_MSI|DEV_HAS_PAUSEFRAME_TX_V1|DEV_HAS_STATISTICS_V12|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_NEED_TX_LIMIT|DEV_HAS_GEAR_MODE|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP65 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0453),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_LARGEDESC|DEV_HAS_HIGH_DMA|DEV_HAS_POWER_CNTRL|DEV_HAS_MSI|DEV_HAS_PAUSEFRAME_TX_V1|DEV_HAS_STATISTICS_V12|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_NEED_TX_LIMIT|DEV_HAS_GEAR_MODE|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP67 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x054C),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_HIGH_DMA|DEV_HAS_POWER_CNTRL|DEV_HAS_MSI|DEV_HAS_PAUSEFRAME_TX_V1|DEV_HAS_STATISTICS_V12|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_HAS_GEAR_MODE|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP67 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x054D),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_HIGH_DMA|DEV_HAS_POWER_CNTRL|DEV_HAS_MSI|DEV_HAS_PAUSEFRAME_TX_V1|DEV_HAS_STATISTICS_V12|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_HAS_GEAR_MODE|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP67 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x054E),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_HIGH_DMA|DEV_HAS_POWER_CNTRL|DEV_HAS_MSI|DEV_HAS_PAUSEFRAME_TX_V1|DEV_HAS_STATISTICS_V12|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_HAS_GEAR_MODE|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP67 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x054F),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_HIGH_DMA|DEV_HAS_POWER_CNTRL|DEV_HAS_MSI|DEV_HAS_PAUSEFRAME_TX_V1|DEV_HAS_STATISTICS_V12|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_HAS_GEAR_MODE|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP73 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x07DC),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_HIGH_DMA|DEV_HAS_POWER_CNTRL|DEV_HAS_MSI|DEV_HAS_PAUSEFRAME_TX_V1|DEV_HAS_STATISTICS_V12|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_HAS_COLLISION_FIX|DEV_HAS_GEAR_MODE|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP73 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x07DD),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_HIGH_DMA|DEV_HAS_POWER_CNTRL|DEV_HAS_MSI|DEV_HAS_PAUSEFRAME_TX_V1|DEV_HAS_STATISTICS_V12|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_HAS_COLLISION_FIX|DEV_HAS_GEAR_MODE|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP73 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x07DE),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_HIGH_DMA|DEV_HAS_POWER_CNTRL|DEV_HAS_MSI|DEV_HAS_PAUSEFRAME_TX_V1|DEV_HAS_STATISTICS_V12|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_HAS_COLLISION_FIX|DEV_HAS_GEAR_MODE|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP73 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x07DF),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_HIGH_DMA|DEV_HAS_POWER_CNTRL|DEV_HAS_MSI|DEV_HAS_PAUSEFRAME_TX_V1|DEV_HAS_STATISTICS_V12|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_HAS_COLLISION_FIX|DEV_HAS_GEAR_MODE|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP77 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0760),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_CHECKSUM|DEV_HAS_HIGH_DMA|DEV_HAS_MSI|DEV_HAS_POWER_CNTRL|DEV_HAS_PAUSEFRAME_TX_V2|DEV_HAS_STATISTICS_V123|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_HAS_COLLISION_FIX|DEV_NEED_TX_LIMIT2|DEV_HAS_GEAR_MODE|DEV_NEED_PHY_INIT_FIX|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP77 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0761),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_CHECKSUM|DEV_HAS_HIGH_DMA|DEV_HAS_MSI|DEV_HAS_POWER_CNTRL|DEV_HAS_PAUSEFRAME_TX_V2|DEV_HAS_STATISTICS_V123|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_HAS_COLLISION_FIX|DEV_NEED_TX_LIMIT2|DEV_HAS_GEAR_MODE|DEV_NEED_PHY_INIT_FIX|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP77 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0762),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_CHECKSUM|DEV_HAS_HIGH_DMA|DEV_HAS_MSI|DEV_HAS_POWER_CNTRL|DEV_HAS_PAUSEFRAME_TX_V2|DEV_HAS_STATISTICS_V123|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_HAS_COLLISION_FIX|DEV_NEED_TX_LIMIT2|DEV_HAS_GEAR_MODE|DEV_NEED_PHY_INIT_FIX|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP77 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0763),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_CHECKSUM|DEV_HAS_HIGH_DMA|DEV_HAS_MSI|DEV_HAS_POWER_CNTRL|DEV_HAS_PAUSEFRAME_TX_V2|DEV_HAS_STATISTICS_V123|DEV_HAS_TEST_EXTENDED|DEV_HAS_MGMT_UNIT|DEV_HAS_CORRECT_MACADDR|DEV_HAS_COLLISION_FIX|DEV_NEED_TX_LIMIT2|DEV_HAS_GEAR_MODE|DEV_NEED_PHY_INIT_FIX|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP79 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0AB0),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_LARGEDESC|DEV_HAS_CHECKSUM|DEV_HAS_HIGH_DMA|DEV_HAS_MSI|DEV_HAS_POWER_CNTRL|DEV_HAS_PAUSEFRAME_TX_V3|DEV_HAS_STATISTICS_V123|DEV_HAS_TEST_EXTENDED|DEV_HAS_CORRECT_MACADDR|DEV_HAS_COLLISION_FIX|DEV_NEED_TX_LIMIT2|DEV_HAS_GEAR_MODE|DEV_NEED_PHY_INIT_FIX|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP79 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0AB1),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_LARGEDESC|DEV_HAS_CHECKSUM|DEV_HAS_HIGH_DMA|DEV_HAS_MSI|DEV_HAS_POWER_CNTRL|DEV_HAS_PAUSEFRAME_TX_V3|DEV_HAS_STATISTICS_V123|DEV_HAS_TEST_EXTENDED|DEV_HAS_CORRECT_MACADDR|DEV_HAS_COLLISION_FIX|DEV_NEED_TX_LIMIT2|DEV_HAS_GEAR_MODE|DEV_NEED_PHY_INIT_FIX|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP79 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0AB2),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_LARGEDESC|DEV_HAS_CHECKSUM|DEV_HAS_HIGH_DMA|DEV_HAS_MSI|DEV_HAS_POWER_CNTRL|DEV_HAS_PAUSEFRAME_TX_V3|DEV_HAS_STATISTICS_V123|DEV_HAS_TEST_EXTENDED|DEV_HAS_CORRECT_MACADDR|DEV_HAS_COLLISION_FIX|DEV_NEED_TX_LIMIT2|DEV_HAS_GEAR_MODE|DEV_NEED_PHY_INIT_FIX|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP79 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0AB3),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_LARGEDESC|DEV_HAS_CHECKSUM|DEV_HAS_HIGH_DMA|DEV_HAS_MSI|DEV_HAS_POWER_CNTRL|DEV_HAS_PAUSEFRAME_TX_V3|DEV_HAS_STATISTICS_V123|DEV_HAS_TEST_EXTENDED|DEV_HAS_CORRECT_MACADDR|DEV_HAS_COLLISION_FIX|DEV_NEED_TX_LIMIT2|DEV_HAS_GEAR_MODE|DEV_NEED_PHY_INIT_FIX|DEV_NEED_MSI_FIX,\n\t},\n\t{\t/* MCP89 Ethernet Controller */\n\t\tPCI_DEVICE(0x10DE, 0x0D7D),\n\t\t.driver_data = DEV_NEED_LINKTIMER|DEV_HAS_LARGEDESC|DEV_HAS_CHECKSUM|DEV_HAS_HIGH_DMA|DEV_HAS_MSI|DEV_HAS_POWER_CNTRL|DEV_HAS_PAUSEFRAME_TX_V3|DEV_HAS_STATISTICS_V123|DEV_HAS_TEST_EXTENDED|DEV_HAS_CORRECT_MACADDR|DEV_HAS_COLLISION_FIX|DEV_HAS_GEAR_MODE|DEV_NEED_PHY_INIT_FIX,\n\t},\n\t{0,},\n};\n\nstatic struct pci_driver forcedeth_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= pci_tbl,\n\t.probe\t\t= nv_probe,\n\t.remove\t\t= nv_remove,\n\t.shutdown\t= nv_shutdown,\n\t.driver.pm\t= NV_PM_OPS,\n};\n\nmodule_param(max_interrupt_work, int, 0);\nMODULE_PARM_DESC(max_interrupt_work, \"forcedeth maximum events handled per interrupt\");\nmodule_param(optimization_mode, int, 0);\nMODULE_PARM_DESC(optimization_mode, \"In throughput mode (0), every tx & rx packet will generate an interrupt. In CPU mode (1), interrupts are controlled by a timer. In dynamic mode (2), the mode toggles between throughput and CPU mode based on network load.\");\nmodule_param(poll_interval, int, 0);\nMODULE_PARM_DESC(poll_interval, \"Interval determines how frequent timer interrupt is generated by [(time_in_micro_secs * 100) / (2^10)]. Min is 0 and Max is 65535.\");\nmodule_param(msi, int, 0);\nMODULE_PARM_DESC(msi, \"MSI interrupts are enabled by setting to 1 and disabled by setting to 0.\");\nmodule_param(msix, int, 0);\nMODULE_PARM_DESC(msix, \"MSIX interrupts are enabled by setting to 1 and disabled by setting to 0.\");\nmodule_param(dma_64bit, int, 0);\nMODULE_PARM_DESC(dma_64bit, \"High DMA is enabled by setting to 1 and disabled by setting to 0.\");\nmodule_param(phy_cross, int, 0);\nMODULE_PARM_DESC(phy_cross, \"Phy crossover detection for Realtek 8201 phy is enabled by setting to 1 and disabled by setting to 0.\");\nmodule_param(phy_power_down, int, 0);\nMODULE_PARM_DESC(phy_power_down, \"Power down phy and disable link when interface is down (1), or leave phy powered up (0).\");\nmodule_param(debug_tx_timeout, bool, 0);\nMODULE_PARM_DESC(debug_tx_timeout,\n\t\t \"Dump tx related registers and ring when tx_timeout happens\");\n\nmodule_pci_driver(forcedeth_pci_driver);\nMODULE_AUTHOR(\"Manfred Spraul <manfred@colorfullife.com>\");\nMODULE_DESCRIPTION(\"Reverse Engineered nForce ethernet driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, pci_tbl);\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 3211}, "message": "set_param_user_data: no type for 'dev->qdisc->handle'"}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/nvidia/forcedeth.c", "reportHash": "d7fa421f536d306f482fbc31a2ac7950", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3211}, "message": "set_param_user_data: no type for 'dev->qdisc->limit'"}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/nvidia/forcedeth.c", "reportHash": "33abd6ad39eceb632211f851c3844d31", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3211}, "message": "set_param_user_data: no type for 'dev->qdisc->parent'"}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/nvidia/forcedeth.c", "reportHash": "09672b64446cf20c2248528570cc0516", "checkerName": "smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4752}, "message": "warn: potential spectre issue 'np->rx_ring.orig' [r]"}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/nvidia/forcedeth.c", "reportHash": "d8c0dba516c5c4ff7338880d1df00284", "checkerName": "check_spectre", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4755}, "message": "warn: potential spectre issue 'np->rx_ring.ex' [r]"}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/nvidia/forcedeth.c", "reportHash": "66a1c09e40ad8f174bc33431f21d9b0b", "checkerName": "check_spectre", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
