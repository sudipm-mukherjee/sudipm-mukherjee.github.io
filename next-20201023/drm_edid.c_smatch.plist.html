<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/gpu/drm/drm_edid.c", "content": "/*\n * Copyright (c) 2006 Luc Verhaegen (quirks list)\n * Copyright (c) 2007-2008 Intel Corporation\n *   Jesse Barnes <jesse.barnes@intel.com>\n * Copyright 2010 Red Hat, Inc.\n *\n * DDC probing routines (drm_ddc_read & drm_do_probe_ddc_edid) originally from\n * FB layer.\n *   Copyright (C) 2006 Dennis Munsie <dmunsie@cecropia.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sub license,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the\n * next paragraph) shall be included in all copies or substantial portions\n * of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n#include <linux/hdmi.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/vga_switcheroo.h>\n\n#include <drm/drm_displayid.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_print.h>\n#include <drm/drm_scdc_helper.h>\n\n#include \"drm_crtc_internal.h\"\n\n#define version_greater(edid, maj, min) \\\n\t(((edid)->version > (maj)) || \\\n\t ((edid)->version == (maj) && (edid)->revision > (min)))\n\n#define EDID_EST_TIMINGS 16\n#define EDID_STD_TIMINGS 8\n#define EDID_DETAILED_TIMINGS 4\n\n/*\n * EDID blocks out in the wild have a variety of bugs, try to collect\n * them here (note that userspace may work around broken monitors first,\n * but fixes should make their way here so that the kernel \"just works\"\n * on as many displays as possible).\n */\n\n/* First detailed mode wrong, use largest 60Hz mode */\n#define EDID_QUIRK_PREFER_LARGE_60\t\t(1 << 0)\n/* Reported 135MHz pixel clock is too high, needs adjustment */\n#define EDID_QUIRK_135_CLOCK_TOO_HIGH\t\t(1 << 1)\n/* Prefer the largest mode at 75 Hz */\n#define EDID_QUIRK_PREFER_LARGE_75\t\t(1 << 2)\n/* Detail timing is in cm not mm */\n#define EDID_QUIRK_DETAILED_IN_CM\t\t(1 << 3)\n/* Detailed timing descriptors have bogus size values, so just take the\n * maximum size and use that.\n */\n#define EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE\t(1 << 4)\n/* use +hsync +vsync for detailed mode */\n#define EDID_QUIRK_DETAILED_SYNC_PP\t\t(1 << 6)\n/* Force reduced-blanking timings for detailed modes */\n#define EDID_QUIRK_FORCE_REDUCED_BLANKING\t(1 << 7)\n/* Force 8bpc */\n#define EDID_QUIRK_FORCE_8BPC\t\t\t(1 << 8)\n/* Force 12bpc */\n#define EDID_QUIRK_FORCE_12BPC\t\t\t(1 << 9)\n/* Force 6bpc */\n#define EDID_QUIRK_FORCE_6BPC\t\t\t(1 << 10)\n/* Force 10bpc */\n#define EDID_QUIRK_FORCE_10BPC\t\t\t(1 << 11)\n/* Non desktop display (i.e. HMD) */\n#define EDID_QUIRK_NON_DESKTOP\t\t\t(1 << 12)\n\nstruct detailed_mode_closure {\n\tstruct drm_connector *connector;\n\tstruct edid *edid;\n\tbool preferred;\n\tu32 quirks;\n\tint modes;\n};\n\n#define LEVEL_DMT\t0\n#define LEVEL_GTF\t1\n#define LEVEL_GTF2\t2\n#define LEVEL_CVT\t3\n\nstatic const struct edid_quirk {\n\tchar vendor[4];\n\tint product_id;\n\tu32 quirks;\n} edid_quirk_list[] = {\n\t/* Acer AL1706 */\n\t{ \"ACR\", 44358, EDID_QUIRK_PREFER_LARGE_60 },\n\t/* Acer F51 */\n\t{ \"API\", 0x7602, EDID_QUIRK_PREFER_LARGE_60 },\n\n\t/* AEO model 0 reports 8 bpc, but is a 6 bpc panel */\n\t{ \"AEO\", 0, EDID_QUIRK_FORCE_6BPC },\n\n\t/* BOE model on HP Pavilion 15-n233sl reports 8 bpc, but is a 6 bpc panel */\n\t{ \"BOE\", 0x78b, EDID_QUIRK_FORCE_6BPC },\n\n\t/* CPT panel of Asus UX303LA reports 8 bpc, but is a 6 bpc panel */\n\t{ \"CPT\", 0x17df, EDID_QUIRK_FORCE_6BPC },\n\n\t/* SDC panel of Lenovo B50-80 reports 8 bpc, but is a 6 bpc panel */\n\t{ \"SDC\", 0x3652, EDID_QUIRK_FORCE_6BPC },\n\n\t/* BOE model 0x0771 reports 8 bpc, but is a 6 bpc panel */\n\t{ \"BOE\", 0x0771, EDID_QUIRK_FORCE_6BPC },\n\n\t/* Belinea 10 15 55 */\n\t{ \"MAX\", 1516, EDID_QUIRK_PREFER_LARGE_60 },\n\t{ \"MAX\", 0x77e, EDID_QUIRK_PREFER_LARGE_60 },\n\n\t/* Envision Peripherals, Inc. EN-7100e */\n\t{ \"EPI\", 59264, EDID_QUIRK_135_CLOCK_TOO_HIGH },\n\t/* Envision EN2028 */\n\t{ \"EPI\", 8232, EDID_QUIRK_PREFER_LARGE_60 },\n\n\t/* Funai Electronics PM36B */\n\t{ \"FCM\", 13600, EDID_QUIRK_PREFER_LARGE_75 |\n\t  EDID_QUIRK_DETAILED_IN_CM },\n\n\t/* LGD panel of HP zBook 17 G2, eDP 10 bpc, but reports unknown bpc */\n\t{ \"LGD\", 764, EDID_QUIRK_FORCE_10BPC },\n\n\t/* LG Philips LCD LP154W01-A5 */\n\t{ \"LPL\", 0, EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE },\n\t{ \"LPL\", 0x2a00, EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE },\n\n\t/* Samsung SyncMaster 205BW.  Note: irony */\n\t{ \"SAM\", 541, EDID_QUIRK_DETAILED_SYNC_PP },\n\t/* Samsung SyncMaster 22[5-6]BW */\n\t{ \"SAM\", 596, EDID_QUIRK_PREFER_LARGE_60 },\n\t{ \"SAM\", 638, EDID_QUIRK_PREFER_LARGE_60 },\n\n\t/* Sony PVM-2541A does up to 12 bpc, but only reports max 8 bpc */\n\t{ \"SNY\", 0x2541, EDID_QUIRK_FORCE_12BPC },\n\n\t/* ViewSonic VA2026w */\n\t{ \"VSC\", 5020, EDID_QUIRK_FORCE_REDUCED_BLANKING },\n\n\t/* Medion MD 30217 PG */\n\t{ \"MED\", 0x7b8, EDID_QUIRK_PREFER_LARGE_75 },\n\n\t/* Lenovo G50 */\n\t{ \"SDC\", 18514, EDID_QUIRK_FORCE_6BPC },\n\n\t/* Panel in Samsung NP700G7A-S01PL notebook reports 6bpc */\n\t{ \"SEC\", 0xd033, EDID_QUIRK_FORCE_8BPC },\n\n\t/* Rotel RSX-1058 forwards sink's EDID but only does HDMI 1.1*/\n\t{ \"ETR\", 13896, EDID_QUIRK_FORCE_8BPC },\n\n\t/* Valve Index Headset */\n\t{ \"VLV\", 0x91a8, EDID_QUIRK_NON_DESKTOP },\n\t{ \"VLV\", 0x91b0, EDID_QUIRK_NON_DESKTOP },\n\t{ \"VLV\", 0x91b1, EDID_QUIRK_NON_DESKTOP },\n\t{ \"VLV\", 0x91b2, EDID_QUIRK_NON_DESKTOP },\n\t{ \"VLV\", 0x91b3, EDID_QUIRK_NON_DESKTOP },\n\t{ \"VLV\", 0x91b4, EDID_QUIRK_NON_DESKTOP },\n\t{ \"VLV\", 0x91b5, EDID_QUIRK_NON_DESKTOP },\n\t{ \"VLV\", 0x91b6, EDID_QUIRK_NON_DESKTOP },\n\t{ \"VLV\", 0x91b7, EDID_QUIRK_NON_DESKTOP },\n\t{ \"VLV\", 0x91b8, EDID_QUIRK_NON_DESKTOP },\n\t{ \"VLV\", 0x91b9, EDID_QUIRK_NON_DESKTOP },\n\t{ \"VLV\", 0x91ba, EDID_QUIRK_NON_DESKTOP },\n\t{ \"VLV\", 0x91bb, EDID_QUIRK_NON_DESKTOP },\n\t{ \"VLV\", 0x91bc, EDID_QUIRK_NON_DESKTOP },\n\t{ \"VLV\", 0x91bd, EDID_QUIRK_NON_DESKTOP },\n\t{ \"VLV\", 0x91be, EDID_QUIRK_NON_DESKTOP },\n\t{ \"VLV\", 0x91bf, EDID_QUIRK_NON_DESKTOP },\n\n\t/* HTC Vive and Vive Pro VR Headsets */\n\t{ \"HVR\", 0xaa01, EDID_QUIRK_NON_DESKTOP },\n\t{ \"HVR\", 0xaa02, EDID_QUIRK_NON_DESKTOP },\n\n\t/* Oculus Rift DK1, DK2, CV1 and Rift S VR Headsets */\n\t{ \"OVR\", 0x0001, EDID_QUIRK_NON_DESKTOP },\n\t{ \"OVR\", 0x0003, EDID_QUIRK_NON_DESKTOP },\n\t{ \"OVR\", 0x0004, EDID_QUIRK_NON_DESKTOP },\n\t{ \"OVR\", 0x0012, EDID_QUIRK_NON_DESKTOP },\n\n\t/* Windows Mixed Reality Headsets */\n\t{ \"ACR\", 0x7fce, EDID_QUIRK_NON_DESKTOP },\n\t{ \"HPN\", 0x3515, EDID_QUIRK_NON_DESKTOP },\n\t{ \"LEN\", 0x0408, EDID_QUIRK_NON_DESKTOP },\n\t{ \"LEN\", 0xb800, EDID_QUIRK_NON_DESKTOP },\n\t{ \"FUJ\", 0x1970, EDID_QUIRK_NON_DESKTOP },\n\t{ \"DEL\", 0x7fce, EDID_QUIRK_NON_DESKTOP },\n\t{ \"SEC\", 0x144a, EDID_QUIRK_NON_DESKTOP },\n\t{ \"AUS\", 0xc102, EDID_QUIRK_NON_DESKTOP },\n\n\t/* Sony PlayStation VR Headset */\n\t{ \"SNY\", 0x0704, EDID_QUIRK_NON_DESKTOP },\n\n\t/* Sensics VR Headsets */\n\t{ \"SEN\", 0x1019, EDID_QUIRK_NON_DESKTOP },\n\n\t/* OSVR HDK and HDK2 VR Headsets */\n\t{ \"SVR\", 0x1019, EDID_QUIRK_NON_DESKTOP },\n};\n\n/*\n * Autogenerated from the DMT spec.\n * This table is copied from xfree86/modes/xf86EdidModes.c.\n */\nstatic const struct drm_display_mode drm_dmt_modes[] = {\n\t/* 0x01 - 640x350@85Hz */\n\t{ DRM_MODE(\"640x350\", DRM_MODE_TYPE_DRIVER, 31500, 640, 672,\n\t\t   736, 832, 0, 350, 382, 385, 445, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x02 - 640x400@85Hz */\n\t{ DRM_MODE(\"640x400\", DRM_MODE_TYPE_DRIVER, 31500, 640, 672,\n\t\t   736, 832, 0, 400, 401, 404, 445, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x03 - 720x400@85Hz */\n\t{ DRM_MODE(\"720x400\", DRM_MODE_TYPE_DRIVER, 35500, 720, 756,\n\t\t   828, 936, 0, 400, 401, 404, 446, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x04 - 640x480@60Hz */\n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 25175, 640, 656,\n\t\t   752, 800, 0, 480, 490, 492, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x05 - 640x480@72Hz */\n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 31500, 640, 664,\n\t\t   704, 832, 0, 480, 489, 492, 520, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x06 - 640x480@75Hz */\n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 31500, 640, 656,\n\t\t   720, 840, 0, 480, 481, 484, 500, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x07 - 640x480@85Hz */\n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 36000, 640, 696,\n\t\t   752, 832, 0, 480, 481, 484, 509, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x08 - 800x600@56Hz */\n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 36000, 800, 824,\n\t\t   896, 1024, 0, 600, 601, 603, 625, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x09 - 800x600@60Hz */\n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 40000, 800, 840,\n\t\t   968, 1056, 0, 600, 601, 605, 628, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x0a - 800x600@72Hz */\n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 50000, 800, 856,\n\t\t   976, 1040, 0, 600, 637, 643, 666, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x0b - 800x600@75Hz */\n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 49500, 800, 816,\n\t\t   896, 1056, 0, 600, 601, 604, 625, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x0c - 800x600@85Hz */\n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 56250, 800, 832,\n\t\t   896, 1048, 0, 600, 601, 604, 631, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x0d - 800x600@120Hz RB */\n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 73250, 800, 848,\n\t\t   880, 960, 0, 600, 603, 607, 636, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x0e - 848x480@60Hz */\n\t{ DRM_MODE(\"848x480\", DRM_MODE_TYPE_DRIVER, 33750, 848, 864,\n\t\t   976, 1088, 0, 480, 486, 494, 517, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x0f - 1024x768@43Hz, interlace */\n\t{ DRM_MODE(\"1024x768i\", DRM_MODE_TYPE_DRIVER, 44900, 1024, 1032,\n\t\t   1208, 1264, 0, 768, 768, 776, 817, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE) },\n\t/* 0x10 - 1024x768@60Hz */\n\t{ DRM_MODE(\"1024x768\", DRM_MODE_TYPE_DRIVER, 65000, 1024, 1048,\n\t\t   1184, 1344, 0, 768, 771, 777, 806, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x11 - 1024x768@70Hz */\n\t{ DRM_MODE(\"1024x768\", DRM_MODE_TYPE_DRIVER, 75000, 1024, 1048,\n\t\t   1184, 1328, 0, 768, 771, 777, 806, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x12 - 1024x768@75Hz */\n\t{ DRM_MODE(\"1024x768\", DRM_MODE_TYPE_DRIVER, 78750, 1024, 1040,\n\t\t   1136, 1312, 0, 768, 769, 772, 800, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x13 - 1024x768@85Hz */\n\t{ DRM_MODE(\"1024x768\", DRM_MODE_TYPE_DRIVER, 94500, 1024, 1072,\n\t\t   1168, 1376, 0, 768, 769, 772, 808, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x14 - 1024x768@120Hz RB */\n\t{ DRM_MODE(\"1024x768\", DRM_MODE_TYPE_DRIVER, 115500, 1024, 1072,\n\t\t   1104, 1184, 0, 768, 771, 775, 813, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x15 - 1152x864@75Hz */\n\t{ DRM_MODE(\"1152x864\", DRM_MODE_TYPE_DRIVER, 108000, 1152, 1216,\n\t\t   1344, 1600, 0, 864, 865, 868, 900, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x55 - 1280x720@60Hz */\n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,\n\t\t   1430, 1650, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x16 - 1280x768@60Hz RB */\n\t{ DRM_MODE(\"1280x768\", DRM_MODE_TYPE_DRIVER, 68250, 1280, 1328,\n\t\t   1360, 1440, 0, 768, 771, 778, 790, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x17 - 1280x768@60Hz */\n\t{ DRM_MODE(\"1280x768\", DRM_MODE_TYPE_DRIVER, 79500, 1280, 1344,\n\t\t   1472, 1664, 0, 768, 771, 778, 798, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x18 - 1280x768@75Hz */\n\t{ DRM_MODE(\"1280x768\", DRM_MODE_TYPE_DRIVER, 102250, 1280, 1360,\n\t\t   1488, 1696, 0, 768, 771, 778, 805, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x19 - 1280x768@85Hz */\n\t{ DRM_MODE(\"1280x768\", DRM_MODE_TYPE_DRIVER, 117500, 1280, 1360,\n\t\t   1496, 1712, 0, 768, 771, 778, 809, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x1a - 1280x768@120Hz RB */\n\t{ DRM_MODE(\"1280x768\", DRM_MODE_TYPE_DRIVER, 140250, 1280, 1328,\n\t\t   1360, 1440, 0, 768, 771, 778, 813, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x1b - 1280x800@60Hz RB */\n\t{ DRM_MODE(\"1280x800\", DRM_MODE_TYPE_DRIVER, 71000, 1280, 1328,\n\t\t   1360, 1440, 0, 800, 803, 809, 823, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x1c - 1280x800@60Hz */\n\t{ DRM_MODE(\"1280x800\", DRM_MODE_TYPE_DRIVER, 83500, 1280, 1352,\n\t\t   1480, 1680, 0, 800, 803, 809, 831, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x1d - 1280x800@75Hz */\n\t{ DRM_MODE(\"1280x800\", DRM_MODE_TYPE_DRIVER, 106500, 1280, 1360,\n\t\t   1488, 1696, 0, 800, 803, 809, 838, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x1e - 1280x800@85Hz */\n\t{ DRM_MODE(\"1280x800\", DRM_MODE_TYPE_DRIVER, 122500, 1280, 1360,\n\t\t   1496, 1712, 0, 800, 803, 809, 843, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x1f - 1280x800@120Hz RB */\n\t{ DRM_MODE(\"1280x800\", DRM_MODE_TYPE_DRIVER, 146250, 1280, 1328,\n\t\t   1360, 1440, 0, 800, 803, 809, 847, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x20 - 1280x960@60Hz */\n\t{ DRM_MODE(\"1280x960\", DRM_MODE_TYPE_DRIVER, 108000, 1280, 1376,\n\t\t   1488, 1800, 0, 960, 961, 964, 1000, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x21 - 1280x960@85Hz */\n\t{ DRM_MODE(\"1280x960\", DRM_MODE_TYPE_DRIVER, 148500, 1280, 1344,\n\t\t   1504, 1728, 0, 960, 961, 964, 1011, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x22 - 1280x960@120Hz RB */\n\t{ DRM_MODE(\"1280x960\", DRM_MODE_TYPE_DRIVER, 175500, 1280, 1328,\n\t\t   1360, 1440, 0, 960, 963, 967, 1017, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x23 - 1280x1024@60Hz */\n\t{ DRM_MODE(\"1280x1024\", DRM_MODE_TYPE_DRIVER, 108000, 1280, 1328,\n\t\t   1440, 1688, 0, 1024, 1025, 1028, 1066, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x24 - 1280x1024@75Hz */\n\t{ DRM_MODE(\"1280x1024\", DRM_MODE_TYPE_DRIVER, 135000, 1280, 1296,\n\t\t   1440, 1688, 0, 1024, 1025, 1028, 1066, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x25 - 1280x1024@85Hz */\n\t{ DRM_MODE(\"1280x1024\", DRM_MODE_TYPE_DRIVER, 157500, 1280, 1344,\n\t\t   1504, 1728, 0, 1024, 1025, 1028, 1072, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x26 - 1280x1024@120Hz RB */\n\t{ DRM_MODE(\"1280x1024\", DRM_MODE_TYPE_DRIVER, 187250, 1280, 1328,\n\t\t   1360, 1440, 0, 1024, 1027, 1034, 1084, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x27 - 1360x768@60Hz */\n\t{ DRM_MODE(\"1360x768\", DRM_MODE_TYPE_DRIVER, 85500, 1360, 1424,\n\t\t   1536, 1792, 0, 768, 771, 777, 795, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x28 - 1360x768@120Hz RB */\n\t{ DRM_MODE(\"1360x768\", DRM_MODE_TYPE_DRIVER, 148250, 1360, 1408,\n\t\t   1440, 1520, 0, 768, 771, 776, 813, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x51 - 1366x768@60Hz */\n\t{ DRM_MODE(\"1366x768\", DRM_MODE_TYPE_DRIVER, 85500, 1366, 1436,\n\t\t   1579, 1792, 0, 768, 771, 774, 798, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x56 - 1366x768@60Hz */\n\t{ DRM_MODE(\"1366x768\", DRM_MODE_TYPE_DRIVER, 72000, 1366, 1380,\n\t\t   1436, 1500, 0, 768, 769, 772, 800, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x29 - 1400x1050@60Hz RB */\n\t{ DRM_MODE(\"1400x1050\", DRM_MODE_TYPE_DRIVER, 101000, 1400, 1448,\n\t\t   1480, 1560, 0, 1050, 1053, 1057, 1080, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x2a - 1400x1050@60Hz */\n\t{ DRM_MODE(\"1400x1050\", DRM_MODE_TYPE_DRIVER, 121750, 1400, 1488,\n\t\t   1632, 1864, 0, 1050, 1053, 1057, 1089, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x2b - 1400x1050@75Hz */\n\t{ DRM_MODE(\"1400x1050\", DRM_MODE_TYPE_DRIVER, 156000, 1400, 1504,\n\t\t   1648, 1896, 0, 1050, 1053, 1057, 1099, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x2c - 1400x1050@85Hz */\n\t{ DRM_MODE(\"1400x1050\", DRM_MODE_TYPE_DRIVER, 179500, 1400, 1504,\n\t\t   1656, 1912, 0, 1050, 1053, 1057, 1105, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x2d - 1400x1050@120Hz RB */\n\t{ DRM_MODE(\"1400x1050\", DRM_MODE_TYPE_DRIVER, 208000, 1400, 1448,\n\t\t   1480, 1560, 0, 1050, 1053, 1057, 1112, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x2e - 1440x900@60Hz RB */\n\t{ DRM_MODE(\"1440x900\", DRM_MODE_TYPE_DRIVER, 88750, 1440, 1488,\n\t\t   1520, 1600, 0, 900, 903, 909, 926, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x2f - 1440x900@60Hz */\n\t{ DRM_MODE(\"1440x900\", DRM_MODE_TYPE_DRIVER, 106500, 1440, 1520,\n\t\t   1672, 1904, 0, 900, 903, 909, 934, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x30 - 1440x900@75Hz */\n\t{ DRM_MODE(\"1440x900\", DRM_MODE_TYPE_DRIVER, 136750, 1440, 1536,\n\t\t   1688, 1936, 0, 900, 903, 909, 942, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x31 - 1440x900@85Hz */\n\t{ DRM_MODE(\"1440x900\", DRM_MODE_TYPE_DRIVER, 157000, 1440, 1544,\n\t\t   1696, 1952, 0, 900, 903, 909, 948, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x32 - 1440x900@120Hz RB */\n\t{ DRM_MODE(\"1440x900\", DRM_MODE_TYPE_DRIVER, 182750, 1440, 1488,\n\t\t   1520, 1600, 0, 900, 903, 909, 953, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x53 - 1600x900@60Hz */\n\t{ DRM_MODE(\"1600x900\", DRM_MODE_TYPE_DRIVER, 108000, 1600, 1624,\n\t\t   1704, 1800, 0, 900, 901, 904, 1000, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x33 - 1600x1200@60Hz */\n\t{ DRM_MODE(\"1600x1200\", DRM_MODE_TYPE_DRIVER, 162000, 1600, 1664,\n\t\t   1856, 2160, 0, 1200, 1201, 1204, 1250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x34 - 1600x1200@65Hz */\n\t{ DRM_MODE(\"1600x1200\", DRM_MODE_TYPE_DRIVER, 175500, 1600, 1664,\n\t\t   1856, 2160, 0, 1200, 1201, 1204, 1250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x35 - 1600x1200@70Hz */\n\t{ DRM_MODE(\"1600x1200\", DRM_MODE_TYPE_DRIVER, 189000, 1600, 1664,\n\t\t   1856, 2160, 0, 1200, 1201, 1204, 1250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x36 - 1600x1200@75Hz */\n\t{ DRM_MODE(\"1600x1200\", DRM_MODE_TYPE_DRIVER, 202500, 1600, 1664,\n\t\t   1856, 2160, 0, 1200, 1201, 1204, 1250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x37 - 1600x1200@85Hz */\n\t{ DRM_MODE(\"1600x1200\", DRM_MODE_TYPE_DRIVER, 229500, 1600, 1664,\n\t\t   1856, 2160, 0, 1200, 1201, 1204, 1250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x38 - 1600x1200@120Hz RB */\n\t{ DRM_MODE(\"1600x1200\", DRM_MODE_TYPE_DRIVER, 268250, 1600, 1648,\n\t\t   1680, 1760, 0, 1200, 1203, 1207, 1271, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x39 - 1680x1050@60Hz RB */\n\t{ DRM_MODE(\"1680x1050\", DRM_MODE_TYPE_DRIVER, 119000, 1680, 1728,\n\t\t   1760, 1840, 0, 1050, 1053, 1059, 1080, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x3a - 1680x1050@60Hz */\n\t{ DRM_MODE(\"1680x1050\", DRM_MODE_TYPE_DRIVER, 146250, 1680, 1784,\n\t\t   1960, 2240, 0, 1050, 1053, 1059, 1089, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x3b - 1680x1050@75Hz */\n\t{ DRM_MODE(\"1680x1050\", DRM_MODE_TYPE_DRIVER, 187000, 1680, 1800,\n\t\t   1976, 2272, 0, 1050, 1053, 1059, 1099, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x3c - 1680x1050@85Hz */\n\t{ DRM_MODE(\"1680x1050\", DRM_MODE_TYPE_DRIVER, 214750, 1680, 1808,\n\t\t   1984, 2288, 0, 1050, 1053, 1059, 1105, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x3d - 1680x1050@120Hz RB */\n\t{ DRM_MODE(\"1680x1050\", DRM_MODE_TYPE_DRIVER, 245500, 1680, 1728,\n\t\t   1760, 1840, 0, 1050, 1053, 1059, 1112, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x3e - 1792x1344@60Hz */\n\t{ DRM_MODE(\"1792x1344\", DRM_MODE_TYPE_DRIVER, 204750, 1792, 1920,\n\t\t   2120, 2448, 0, 1344, 1345, 1348, 1394, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x3f - 1792x1344@75Hz */\n\t{ DRM_MODE(\"1792x1344\", DRM_MODE_TYPE_DRIVER, 261000, 1792, 1888,\n\t\t   2104, 2456, 0, 1344, 1345, 1348, 1417, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x40 - 1792x1344@120Hz RB */\n\t{ DRM_MODE(\"1792x1344\", DRM_MODE_TYPE_DRIVER, 333250, 1792, 1840,\n\t\t   1872, 1952, 0, 1344, 1347, 1351, 1423, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x41 - 1856x1392@60Hz */\n\t{ DRM_MODE(\"1856x1392\", DRM_MODE_TYPE_DRIVER, 218250, 1856, 1952,\n\t\t   2176, 2528, 0, 1392, 1393, 1396, 1439, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x42 - 1856x1392@75Hz */\n\t{ DRM_MODE(\"1856x1392\", DRM_MODE_TYPE_DRIVER, 288000, 1856, 1984,\n\t\t   2208, 2560, 0, 1392, 1393, 1396, 1500, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x43 - 1856x1392@120Hz RB */\n\t{ DRM_MODE(\"1856x1392\", DRM_MODE_TYPE_DRIVER, 356500, 1856, 1904,\n\t\t   1936, 2016, 0, 1392, 1395, 1399, 1474, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x52 - 1920x1080@60Hz */\n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x44 - 1920x1200@60Hz RB */\n\t{ DRM_MODE(\"1920x1200\", DRM_MODE_TYPE_DRIVER, 154000, 1920, 1968,\n\t\t   2000, 2080, 0, 1200, 1203, 1209, 1235, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x45 - 1920x1200@60Hz */\n\t{ DRM_MODE(\"1920x1200\", DRM_MODE_TYPE_DRIVER, 193250, 1920, 2056,\n\t\t   2256, 2592, 0, 1200, 1203, 1209, 1245, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x46 - 1920x1200@75Hz */\n\t{ DRM_MODE(\"1920x1200\", DRM_MODE_TYPE_DRIVER, 245250, 1920, 2056,\n\t\t   2264, 2608, 0, 1200, 1203, 1209, 1255, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x47 - 1920x1200@85Hz */\n\t{ DRM_MODE(\"1920x1200\", DRM_MODE_TYPE_DRIVER, 281250, 1920, 2064,\n\t\t   2272, 2624, 0, 1200, 1203, 1209, 1262, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x48 - 1920x1200@120Hz RB */\n\t{ DRM_MODE(\"1920x1200\", DRM_MODE_TYPE_DRIVER, 317000, 1920, 1968,\n\t\t   2000, 2080, 0, 1200, 1203, 1209, 1271, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x49 - 1920x1440@60Hz */\n\t{ DRM_MODE(\"1920x1440\", DRM_MODE_TYPE_DRIVER, 234000, 1920, 2048,\n\t\t   2256, 2600, 0, 1440, 1441, 1444, 1500, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x4a - 1920x1440@75Hz */\n\t{ DRM_MODE(\"1920x1440\", DRM_MODE_TYPE_DRIVER, 297000, 1920, 2064,\n\t\t   2288, 2640, 0, 1440, 1441, 1444, 1500, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x4b - 1920x1440@120Hz RB */\n\t{ DRM_MODE(\"1920x1440\", DRM_MODE_TYPE_DRIVER, 380500, 1920, 1968,\n\t\t   2000, 2080, 0, 1440, 1443, 1447, 1525, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x54 - 2048x1152@60Hz */\n\t{ DRM_MODE(\"2048x1152\", DRM_MODE_TYPE_DRIVER, 162000, 2048, 2074,\n\t\t   2154, 2250, 0, 1152, 1153, 1156, 1200, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x4c - 2560x1600@60Hz RB */\n\t{ DRM_MODE(\"2560x1600\", DRM_MODE_TYPE_DRIVER, 268500, 2560, 2608,\n\t\t   2640, 2720, 0, 1600, 1603, 1609, 1646, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x4d - 2560x1600@60Hz */\n\t{ DRM_MODE(\"2560x1600\", DRM_MODE_TYPE_DRIVER, 348500, 2560, 2752,\n\t\t   3032, 3504, 0, 1600, 1603, 1609, 1658, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x4e - 2560x1600@75Hz */\n\t{ DRM_MODE(\"2560x1600\", DRM_MODE_TYPE_DRIVER, 443250, 2560, 2768,\n\t\t   3048, 3536, 0, 1600, 1603, 1609, 1672, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x4f - 2560x1600@85Hz */\n\t{ DRM_MODE(\"2560x1600\", DRM_MODE_TYPE_DRIVER, 505250, 2560, 2768,\n\t\t   3048, 3536, 0, 1600, 1603, 1609, 1682, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },\n\t/* 0x50 - 2560x1600@120Hz RB */\n\t{ DRM_MODE(\"2560x1600\", DRM_MODE_TYPE_DRIVER, 552750, 2560, 2608,\n\t\t   2640, 2720, 0, 1600, 1603, 1609, 1694, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x57 - 4096x2160@60Hz RB */\n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 556744, 4096, 4104,\n\t\t   4136, 4176, 0, 2160, 2208, 2216, 2222, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n\t/* 0x58 - 4096x2160@59.94Hz RB */\n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 556188, 4096, 4104,\n\t\t   4136, 4176, 0, 2160, 2208, 2216, 2222, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },\n};\n\n/*\n * These more or less come from the DMT spec.  The 720x400 modes are\n * inferred from historical 80x25 practice.  The 640x480@67 and 832x624@75\n * modes are old-school Mac modes.  The EDID spec says the 1152x864@75 mode\n * should be 1152x870, again for the Mac, but instead we use the x864 DMT\n * mode.\n *\n * The DMT modes have been fact-checked; the rest are mild guesses.\n */\nstatic const struct drm_display_mode edid_est_modes[] = {\n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 40000, 800, 840,\n\t\t   968, 1056, 0, 600, 601, 605, 628, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) }, /* 800x600@60Hz */\n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 36000, 800, 824,\n\t\t   896, 1024, 0, 600, 601, 603,  625, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) }, /* 800x600@56Hz */\n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 31500, 640, 656,\n\t\t   720, 840, 0, 480, 481, 484, 500, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) }, /* 640x480@75Hz */\n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 31500, 640, 664,\n\t\t   704,  832, 0, 480, 489, 492, 520, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) }, /* 640x480@72Hz */\n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 30240, 640, 704,\n\t\t   768,  864, 0, 480, 483, 486, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) }, /* 640x480@67Hz */\n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 25175, 640, 656,\n\t\t   752, 800, 0, 480, 490, 492, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) }, /* 640x480@60Hz */\n\t{ DRM_MODE(\"720x400\", DRM_MODE_TYPE_DRIVER, 35500, 720, 738,\n\t\t   846, 900, 0, 400, 421, 423,  449, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) }, /* 720x400@88Hz */\n\t{ DRM_MODE(\"720x400\", DRM_MODE_TYPE_DRIVER, 28320, 720, 738,\n\t\t   846,  900, 0, 400, 412, 414, 449, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) }, /* 720x400@70Hz */\n\t{ DRM_MODE(\"1280x1024\", DRM_MODE_TYPE_DRIVER, 135000, 1280, 1296,\n\t\t   1440, 1688, 0, 1024, 1025, 1028, 1066, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) }, /* 1280x1024@75Hz */\n\t{ DRM_MODE(\"1024x768\", DRM_MODE_TYPE_DRIVER, 78750, 1024, 1040,\n\t\t   1136, 1312, 0,  768, 769, 772, 800, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) }, /* 1024x768@75Hz */\n\t{ DRM_MODE(\"1024x768\", DRM_MODE_TYPE_DRIVER, 75000, 1024, 1048,\n\t\t   1184, 1328, 0,  768, 771, 777, 806, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) }, /* 1024x768@70Hz */\n\t{ DRM_MODE(\"1024x768\", DRM_MODE_TYPE_DRIVER, 65000, 1024, 1048,\n\t\t   1184, 1344, 0,  768, 771, 777, 806, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) }, /* 1024x768@60Hz */\n\t{ DRM_MODE(\"1024x768i\", DRM_MODE_TYPE_DRIVER,44900, 1024, 1032,\n\t\t   1208, 1264, 0, 768, 768, 776, 817, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC | DRM_MODE_FLAG_INTERLACE) }, /* 1024x768@43Hz */\n\t{ DRM_MODE(\"832x624\", DRM_MODE_TYPE_DRIVER, 57284, 832, 864,\n\t\t   928, 1152, 0, 624, 625, 628, 667, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) }, /* 832x624@75Hz */\n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 49500, 800, 816,\n\t\t   896, 1056, 0, 600, 601, 604,  625, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) }, /* 800x600@75Hz */\n\t{ DRM_MODE(\"800x600\", DRM_MODE_TYPE_DRIVER, 50000, 800, 856,\n\t\t   976, 1040, 0, 600, 637, 643, 666, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) }, /* 800x600@72Hz */\n\t{ DRM_MODE(\"1152x864\", DRM_MODE_TYPE_DRIVER, 108000, 1152, 1216,\n\t\t   1344, 1600, 0,  864, 865, 868, 900, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) }, /* 1152x864@75Hz */\n};\n\nstruct minimode {\n\tshort w;\n\tshort h;\n\tshort r;\n\tshort rb;\n};\n\nstatic const struct minimode est3_modes[] = {\n\t/* byte 6 */\n\t{ 640, 350, 85, 0 },\n\t{ 640, 400, 85, 0 },\n\t{ 720, 400, 85, 0 },\n\t{ 640, 480, 85, 0 },\n\t{ 848, 480, 60, 0 },\n\t{ 800, 600, 85, 0 },\n\t{ 1024, 768, 85, 0 },\n\t{ 1152, 864, 75, 0 },\n\t/* byte 7 */\n\t{ 1280, 768, 60, 1 },\n\t{ 1280, 768, 60, 0 },\n\t{ 1280, 768, 75, 0 },\n\t{ 1280, 768, 85, 0 },\n\t{ 1280, 960, 60, 0 },\n\t{ 1280, 960, 85, 0 },\n\t{ 1280, 1024, 60, 0 },\n\t{ 1280, 1024, 85, 0 },\n\t/* byte 8 */\n\t{ 1360, 768, 60, 0 },\n\t{ 1440, 900, 60, 1 },\n\t{ 1440, 900, 60, 0 },\n\t{ 1440, 900, 75, 0 },\n\t{ 1440, 900, 85, 0 },\n\t{ 1400, 1050, 60, 1 },\n\t{ 1400, 1050, 60, 0 },\n\t{ 1400, 1050, 75, 0 },\n\t/* byte 9 */\n\t{ 1400, 1050, 85, 0 },\n\t{ 1680, 1050, 60, 1 },\n\t{ 1680, 1050, 60, 0 },\n\t{ 1680, 1050, 75, 0 },\n\t{ 1680, 1050, 85, 0 },\n\t{ 1600, 1200, 60, 0 },\n\t{ 1600, 1200, 65, 0 },\n\t{ 1600, 1200, 70, 0 },\n\t/* byte 10 */\n\t{ 1600, 1200, 75, 0 },\n\t{ 1600, 1200, 85, 0 },\n\t{ 1792, 1344, 60, 0 },\n\t{ 1792, 1344, 75, 0 },\n\t{ 1856, 1392, 60, 0 },\n\t{ 1856, 1392, 75, 0 },\n\t{ 1920, 1200, 60, 1 },\n\t{ 1920, 1200, 60, 0 },\n\t/* byte 11 */\n\t{ 1920, 1200, 75, 0 },\n\t{ 1920, 1200, 85, 0 },\n\t{ 1920, 1440, 60, 0 },\n\t{ 1920, 1440, 75, 0 },\n};\n\nstatic const struct minimode extra_modes[] = {\n\t{ 1024, 576,  60, 0 },\n\t{ 1366, 768,  60, 0 },\n\t{ 1600, 900,  60, 0 },\n\t{ 1680, 945,  60, 0 },\n\t{ 1920, 1080, 60, 0 },\n\t{ 2048, 1152, 60, 0 },\n\t{ 2048, 1536, 60, 0 },\n};\n\n/*\n * From CEA/CTA-861 spec.\n *\n * Do not access directly, instead always use cea_mode_for_vic().\n */\nstatic const struct drm_display_mode edid_cea_modes_1[] = {\n\t/* 1 - 640x480@60Hz 4:3 */\n\t{ DRM_MODE(\"640x480\", DRM_MODE_TYPE_DRIVER, 25175, 640, 656,\n\t\t   752, 800, 0, 480, 490, 492, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 2 - 720x480@60Hz 4:3 */\n\t{ DRM_MODE(\"720x480\", DRM_MODE_TYPE_DRIVER, 27000, 720, 736,\n\t\t   798, 858, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 3 - 720x480@60Hz 16:9 */\n\t{ DRM_MODE(\"720x480\", DRM_MODE_TYPE_DRIVER, 27000, 720, 736,\n\t\t   798, 858, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 4 - 1280x720@60Hz 16:9 */\n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,\n\t\t   1430, 1650, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 5 - 1920x1080i@60Hz 16:9 */\n\t{ DRM_MODE(\"1920x1080i\", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1094, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 6 - 720(1440)x480i@60Hz 4:3 */\n\t{ DRM_MODE(\"720x480i\", DRM_MODE_TYPE_DRIVER, 13500, 720, 739,\n\t\t   801, 858, 0, 480, 488, 494, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 7 - 720(1440)x480i@60Hz 16:9 */\n\t{ DRM_MODE(\"720x480i\", DRM_MODE_TYPE_DRIVER, 13500, 720, 739,\n\t\t   801, 858, 0, 480, 488, 494, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 8 - 720(1440)x240@60Hz 4:3 */\n\t{ DRM_MODE(\"720x240\", DRM_MODE_TYPE_DRIVER, 13500, 720, 739,\n\t\t   801, 858, 0, 240, 244, 247, 262, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 9 - 720(1440)x240@60Hz 16:9 */\n\t{ DRM_MODE(\"720x240\", DRM_MODE_TYPE_DRIVER, 13500, 720, 739,\n\t\t   801, 858, 0, 240, 244, 247, 262, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 10 - 2880x480i@60Hz 4:3 */\n\t{ DRM_MODE(\"2880x480i\", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,\n\t\t   3204, 3432, 0, 480, 488, 494, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 11 - 2880x480i@60Hz 16:9 */\n\t{ DRM_MODE(\"2880x480i\", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,\n\t\t   3204, 3432, 0, 480, 488, 494, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 12 - 2880x240@60Hz 4:3 */\n\t{ DRM_MODE(\"2880x240\", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,\n\t\t   3204, 3432, 0, 240, 244, 247, 262, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 13 - 2880x240@60Hz 16:9 */\n\t{ DRM_MODE(\"2880x240\", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,\n\t\t   3204, 3432, 0, 240, 244, 247, 262, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 14 - 1440x480@60Hz 4:3 */\n\t{ DRM_MODE(\"1440x480\", DRM_MODE_TYPE_DRIVER, 54000, 1440, 1472,\n\t\t   1596, 1716, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 15 - 1440x480@60Hz 16:9 */\n\t{ DRM_MODE(\"1440x480\", DRM_MODE_TYPE_DRIVER, 54000, 1440, 1472,\n\t\t   1596, 1716, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 16 - 1920x1080@60Hz 16:9 */\n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 17 - 720x576@50Hz 4:3 */\n\t{ DRM_MODE(\"720x576\", DRM_MODE_TYPE_DRIVER, 27000, 720, 732,\n\t\t   796, 864, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 18 - 720x576@50Hz 16:9 */\n\t{ DRM_MODE(\"720x576\", DRM_MODE_TYPE_DRIVER, 27000, 720, 732,\n\t\t   796, 864, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 19 - 1280x720@50Hz 16:9 */\n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1720,\n\t\t   1760, 1980, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 20 - 1920x1080i@50Hz 16:9 */\n\t{ DRM_MODE(\"1920x1080i\", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,\n\t\t   2492, 2640, 0, 1080, 1084, 1094, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 21 - 720(1440)x576i@50Hz 4:3 */\n\t{ DRM_MODE(\"720x576i\", DRM_MODE_TYPE_DRIVER, 13500, 720, 732,\n\t\t   795, 864, 0, 576, 580, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 22 - 720(1440)x576i@50Hz 16:9 */\n\t{ DRM_MODE(\"720x576i\", DRM_MODE_TYPE_DRIVER, 13500, 720, 732,\n\t\t   795, 864, 0, 576, 580, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 23 - 720(1440)x288@50Hz 4:3 */\n\t{ DRM_MODE(\"720x288\", DRM_MODE_TYPE_DRIVER, 13500, 720, 732,\n\t\t   795, 864, 0, 288, 290, 293, 312, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 24 - 720(1440)x288@50Hz 16:9 */\n\t{ DRM_MODE(\"720x288\", DRM_MODE_TYPE_DRIVER, 13500, 720, 732,\n\t\t   795, 864, 0, 288, 290, 293, 312, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 25 - 2880x576i@50Hz 4:3 */\n\t{ DRM_MODE(\"2880x576i\", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,\n\t\t   3180, 3456, 0, 576, 580, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 26 - 2880x576i@50Hz 16:9 */\n\t{ DRM_MODE(\"2880x576i\", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,\n\t\t   3180, 3456, 0, 576, 580, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 27 - 2880x288@50Hz 4:3 */\n\t{ DRM_MODE(\"2880x288\", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,\n\t\t   3180, 3456, 0, 288, 290, 293, 312, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 28 - 2880x288@50Hz 16:9 */\n\t{ DRM_MODE(\"2880x288\", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,\n\t\t   3180, 3456, 0, 288, 290, 293, 312, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 29 - 1440x576@50Hz 4:3 */\n\t{ DRM_MODE(\"1440x576\", DRM_MODE_TYPE_DRIVER, 54000, 1440, 1464,\n\t\t   1592, 1728, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 30 - 1440x576@50Hz 16:9 */\n\t{ DRM_MODE(\"1440x576\", DRM_MODE_TYPE_DRIVER, 54000, 1440, 1464,\n\t\t   1592, 1728, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 31 - 1920x1080@50Hz 16:9 */\n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2448,\n\t\t   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 32 - 1920x1080@24Hz 16:9 */\n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2558,\n\t\t   2602, 2750, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 33 - 1920x1080@25Hz 16:9 */\n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,\n\t\t   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 34 - 1920x1080@30Hz 16:9 */\n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 35 - 2880x480@60Hz 4:3 */\n\t{ DRM_MODE(\"2880x480\", DRM_MODE_TYPE_DRIVER, 108000, 2880, 2944,\n\t\t   3192, 3432, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 36 - 2880x480@60Hz 16:9 */\n\t{ DRM_MODE(\"2880x480\", DRM_MODE_TYPE_DRIVER, 108000, 2880, 2944,\n\t\t   3192, 3432, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 37 - 2880x576@50Hz 4:3 */\n\t{ DRM_MODE(\"2880x576\", DRM_MODE_TYPE_DRIVER, 108000, 2880, 2928,\n\t\t   3184, 3456, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 38 - 2880x576@50Hz 16:9 */\n\t{ DRM_MODE(\"2880x576\", DRM_MODE_TYPE_DRIVER, 108000, 2880, 2928,\n\t\t   3184, 3456, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 39 - 1920x1080i@50Hz 16:9 */\n\t{ DRM_MODE(\"1920x1080i\", DRM_MODE_TYPE_DRIVER, 72000, 1920, 1952,\n\t\t   2120, 2304, 0, 1080, 1126, 1136, 1250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 40 - 1920x1080i@100Hz 16:9 */\n\t{ DRM_MODE(\"1920x1080i\", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2448,\n\t\t   2492, 2640, 0, 1080, 1084, 1094, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 41 - 1280x720@100Hz 16:9 */\n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 148500, 1280, 1720,\n\t\t   1760, 1980, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 42 - 720x576@100Hz 4:3 */\n\t{ DRM_MODE(\"720x576\", DRM_MODE_TYPE_DRIVER, 54000, 720, 732,\n\t\t   796, 864, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 43 - 720x576@100Hz 16:9 */\n\t{ DRM_MODE(\"720x576\", DRM_MODE_TYPE_DRIVER, 54000, 720, 732,\n\t\t   796, 864, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 44 - 720(1440)x576i@100Hz 4:3 */\n\t{ DRM_MODE(\"720x576i\", DRM_MODE_TYPE_DRIVER, 27000, 720, 732,\n\t\t   795, 864, 0, 576, 580, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 45 - 720(1440)x576i@100Hz 16:9 */\n\t{ DRM_MODE(\"720x576i\", DRM_MODE_TYPE_DRIVER, 27000, 720, 732,\n\t\t   795, 864, 0, 576, 580, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 46 - 1920x1080i@120Hz 16:9 */\n\t{ DRM_MODE(\"1920x1080i\", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1094, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 47 - 1280x720@120Hz 16:9 */\n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 148500, 1280, 1390,\n\t\t   1430, 1650, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 48 - 720x480@120Hz 4:3 */\n\t{ DRM_MODE(\"720x480\", DRM_MODE_TYPE_DRIVER, 54000, 720, 736,\n\t\t   798, 858, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 49 - 720x480@120Hz 16:9 */\n\t{ DRM_MODE(\"720x480\", DRM_MODE_TYPE_DRIVER, 54000, 720, 736,\n\t\t   798, 858, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 50 - 720(1440)x480i@120Hz 4:3 */\n\t{ DRM_MODE(\"720x480i\", DRM_MODE_TYPE_DRIVER, 27000, 720, 739,\n\t\t   801, 858, 0, 480, 488, 494, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 51 - 720(1440)x480i@120Hz 16:9 */\n\t{ DRM_MODE(\"720x480i\", DRM_MODE_TYPE_DRIVER, 27000, 720, 739,\n\t\t   801, 858, 0, 480, 488, 494, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 52 - 720x576@200Hz 4:3 */\n\t{ DRM_MODE(\"720x576\", DRM_MODE_TYPE_DRIVER, 108000, 720, 732,\n\t\t   796, 864, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 53 - 720x576@200Hz 16:9 */\n\t{ DRM_MODE(\"720x576\", DRM_MODE_TYPE_DRIVER, 108000, 720, 732,\n\t\t   796, 864, 0, 576, 581, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 54 - 720(1440)x576i@200Hz 4:3 */\n\t{ DRM_MODE(\"720x576i\", DRM_MODE_TYPE_DRIVER, 54000, 720, 732,\n\t\t   795, 864, 0, 576, 580, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 55 - 720(1440)x576i@200Hz 16:9 */\n\t{ DRM_MODE(\"720x576i\", DRM_MODE_TYPE_DRIVER, 54000, 720, 732,\n\t\t   795, 864, 0, 576, 580, 586, 625, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 56 - 720x480@240Hz 4:3 */\n\t{ DRM_MODE(\"720x480\", DRM_MODE_TYPE_DRIVER, 108000, 720, 736,\n\t\t   798, 858, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 57 - 720x480@240Hz 16:9 */\n\t{ DRM_MODE(\"720x480\", DRM_MODE_TYPE_DRIVER, 108000, 720, 736,\n\t\t   798, 858, 0, 480, 489, 495, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 58 - 720(1440)x480i@240Hz 4:3 */\n\t{ DRM_MODE(\"720x480i\", DRM_MODE_TYPE_DRIVER, 54000, 720, 739,\n\t\t   801, 858, 0, 480, 488, 494, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },\n\t/* 59 - 720(1440)x480i@240Hz 16:9 */\n\t{ DRM_MODE(\"720x480i\", DRM_MODE_TYPE_DRIVER, 54000, 720, 739,\n\t\t   801, 858, 0, 480, 488, 494, 525, 0,\n\t\t   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |\n\t\t   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 60 - 1280x720@24Hz 16:9 */\n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 59400, 1280, 3040,\n\t\t   3080, 3300, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 61 - 1280x720@25Hz 16:9 */\n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 3700,\n\t\t   3740, 3960, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 62 - 1280x720@30Hz 16:9 */\n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 3040,\n\t\t   3080, 3300, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 63 - 1920x1080@120Hz 16:9 */\n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 297000, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 64 - 1920x1080@100Hz 16:9 */\n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 297000, 1920, 2448,\n\t\t   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 65 - 1280x720@24Hz 64:27 */\n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 59400, 1280, 3040,\n\t\t   3080, 3300, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 66 - 1280x720@25Hz 64:27 */\n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 3700,\n\t\t   3740, 3960, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 67 - 1280x720@30Hz 64:27 */\n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 3040,\n\t\t   3080, 3300, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 68 - 1280x720@50Hz 64:27 */\n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1720,\n\t\t   1760, 1980, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 69 - 1280x720@60Hz 64:27 */\n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,\n\t\t   1430, 1650, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 70 - 1280x720@100Hz 64:27 */\n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 148500, 1280, 1720,\n\t\t   1760, 1980, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 71 - 1280x720@120Hz 64:27 */\n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 148500, 1280, 1390,\n\t\t   1430, 1650, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 72 - 1920x1080@24Hz 64:27 */\n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2558,\n\t\t   2602, 2750, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 73 - 1920x1080@25Hz 64:27 */\n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,\n\t\t   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 74 - 1920x1080@30Hz 64:27 */\n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 75 - 1920x1080@50Hz 64:27 */\n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2448,\n\t\t   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 76 - 1920x1080@60Hz 64:27 */\n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 77 - 1920x1080@100Hz 64:27 */\n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 297000, 1920, 2448,\n\t\t   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 78 - 1920x1080@120Hz 64:27 */\n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 297000, 1920, 2008,\n\t\t   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 79 - 1680x720@24Hz 64:27 */\n\t{ DRM_MODE(\"1680x720\", DRM_MODE_TYPE_DRIVER, 59400, 1680, 3040,\n\t\t   3080, 3300, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 80 - 1680x720@25Hz 64:27 */\n\t{ DRM_MODE(\"1680x720\", DRM_MODE_TYPE_DRIVER, 59400, 1680, 2908,\n\t\t   2948, 3168, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 81 - 1680x720@30Hz 64:27 */\n\t{ DRM_MODE(\"1680x720\", DRM_MODE_TYPE_DRIVER, 59400, 1680, 2380,\n\t\t   2420, 2640, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 82 - 1680x720@50Hz 64:27 */\n\t{ DRM_MODE(\"1680x720\", DRM_MODE_TYPE_DRIVER, 82500, 1680, 1940,\n\t\t   1980, 2200, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 83 - 1680x720@60Hz 64:27 */\n\t{ DRM_MODE(\"1680x720\", DRM_MODE_TYPE_DRIVER, 99000, 1680, 1940,\n\t\t   1980, 2200, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 84 - 1680x720@100Hz 64:27 */\n\t{ DRM_MODE(\"1680x720\", DRM_MODE_TYPE_DRIVER, 165000, 1680, 1740,\n\t\t   1780, 2000, 0, 720, 725, 730, 825, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 85 - 1680x720@120Hz 64:27 */\n\t{ DRM_MODE(\"1680x720\", DRM_MODE_TYPE_DRIVER, 198000, 1680, 1740,\n\t\t   1780, 2000, 0, 720, 725, 730, 825, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 86 - 2560x1080@24Hz 64:27 */\n\t{ DRM_MODE(\"2560x1080\", DRM_MODE_TYPE_DRIVER, 99000, 2560, 3558,\n\t\t   3602, 3750, 0, 1080, 1084, 1089, 1100, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 87 - 2560x1080@25Hz 64:27 */\n\t{ DRM_MODE(\"2560x1080\", DRM_MODE_TYPE_DRIVER, 90000, 2560, 3008,\n\t\t   3052, 3200, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 88 - 2560x1080@30Hz 64:27 */\n\t{ DRM_MODE(\"2560x1080\", DRM_MODE_TYPE_DRIVER, 118800, 2560, 3328,\n\t\t   3372, 3520, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 89 - 2560x1080@50Hz 64:27 */\n\t{ DRM_MODE(\"2560x1080\", DRM_MODE_TYPE_DRIVER, 185625, 2560, 3108,\n\t\t   3152, 3300, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 90 - 2560x1080@60Hz 64:27 */\n\t{ DRM_MODE(\"2560x1080\", DRM_MODE_TYPE_DRIVER, 198000, 2560, 2808,\n\t\t   2852, 3000, 0, 1080, 1084, 1089, 1100, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 91 - 2560x1080@100Hz 64:27 */\n\t{ DRM_MODE(\"2560x1080\", DRM_MODE_TYPE_DRIVER, 371250, 2560, 2778,\n\t\t   2822, 2970, 0, 1080, 1084, 1089, 1250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 92 - 2560x1080@120Hz 64:27 */\n\t{ DRM_MODE(\"2560x1080\", DRM_MODE_TYPE_DRIVER, 495000, 2560, 3108,\n\t\t   3152, 3300, 0, 1080, 1084, 1089, 1250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 93 - 3840x2160@24Hz 16:9 */\n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 297000, 3840, 5116,\n\t\t   5204, 5500, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 94 - 3840x2160@25Hz 16:9 */\n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 297000, 3840, 4896,\n\t\t   4984, 5280, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 95 - 3840x2160@30Hz 16:9 */\n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 297000, 3840, 4016,\n\t\t   4104, 4400, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 96 - 3840x2160@50Hz 16:9 */\n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 594000, 3840, 4896,\n\t\t   4984, 5280, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 97 - 3840x2160@60Hz 16:9 */\n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 594000, 3840, 4016,\n\t\t   4104, 4400, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 98 - 4096x2160@24Hz 256:135 */\n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 297000, 4096, 5116,\n\t\t   5204, 5500, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },\n\t/* 99 - 4096x2160@25Hz 256:135 */\n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 297000, 4096, 5064,\n\t\t   5152, 5280, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },\n\t/* 100 - 4096x2160@30Hz 256:135 */\n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 297000, 4096, 4184,\n\t\t   4272, 4400, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },\n\t/* 101 - 4096x2160@50Hz 256:135 */\n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 594000, 4096, 5064,\n\t\t   5152, 5280, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },\n\t/* 102 - 4096x2160@60Hz 256:135 */\n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 594000, 4096, 4184,\n\t\t   4272, 4400, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },\n\t/* 103 - 3840x2160@24Hz 64:27 */\n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 297000, 3840, 5116,\n\t\t   5204, 5500, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 104 - 3840x2160@25Hz 64:27 */\n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 297000, 3840, 4896,\n\t\t   4984, 5280, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 105 - 3840x2160@30Hz 64:27 */\n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 297000, 3840, 4016,\n\t\t   4104, 4400, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 106 - 3840x2160@50Hz 64:27 */\n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 594000, 3840, 4896,\n\t\t   4984, 5280, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 107 - 3840x2160@60Hz 64:27 */\n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 594000, 3840, 4016,\n\t\t   4104, 4400, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 108 - 1280x720@48Hz 16:9 */\n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 90000, 1280, 2240,\n\t\t   2280, 2500, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 109 - 1280x720@48Hz 64:27 */\n\t{ DRM_MODE(\"1280x720\", DRM_MODE_TYPE_DRIVER, 90000, 1280, 2240,\n\t\t   2280, 2500, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 110 - 1680x720@48Hz 64:27 */\n\t{ DRM_MODE(\"1680x720\", DRM_MODE_TYPE_DRIVER, 99000, 1680, 2490,\n\t\t   2530, 2750, 0, 720, 725, 730, 750, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 111 - 1920x1080@48Hz 16:9 */\n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2558,\n\t\t   2602, 2750, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 112 - 1920x1080@48Hz 64:27 */\n\t{ DRM_MODE(\"1920x1080\", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2558,\n\t\t   2602, 2750, 0, 1080, 1084, 1089, 1125, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 113 - 2560x1080@48Hz 64:27 */\n\t{ DRM_MODE(\"2560x1080\", DRM_MODE_TYPE_DRIVER, 198000, 2560, 3558,\n\t\t   3602, 3750, 0, 1080, 1084, 1089, 1100, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 114 - 3840x2160@48Hz 16:9 */\n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 594000, 3840, 5116,\n\t\t   5204, 5500, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 115 - 4096x2160@48Hz 256:135 */\n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 594000, 4096, 5116,\n\t\t   5204, 5500, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },\n\t/* 116 - 3840x2160@48Hz 64:27 */\n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 594000, 3840, 5116,\n\t\t   5204, 5500, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 117 - 3840x2160@100Hz 16:9 */\n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 1188000, 3840, 4896,\n\t\t   4984, 5280, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 118 - 3840x2160@120Hz 16:9 */\n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 1188000, 3840, 4016,\n\t\t   4104, 4400, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 119 - 3840x2160@100Hz 64:27 */\n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 1188000, 3840, 4896,\n\t\t   4984, 5280, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 120 - 3840x2160@120Hz 64:27 */\n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 1188000, 3840, 4016,\n\t\t   4104, 4400, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 121 - 5120x2160@24Hz 64:27 */\n\t{ DRM_MODE(\"5120x2160\", DRM_MODE_TYPE_DRIVER, 396000, 5120, 7116,\n\t\t   7204, 7500, 0, 2160, 2168, 2178, 2200, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 122 - 5120x2160@25Hz 64:27 */\n\t{ DRM_MODE(\"5120x2160\", DRM_MODE_TYPE_DRIVER, 396000, 5120, 6816,\n\t\t   6904, 7200, 0, 2160, 2168, 2178, 2200, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 123 - 5120x2160@30Hz 64:27 */\n\t{ DRM_MODE(\"5120x2160\", DRM_MODE_TYPE_DRIVER, 396000, 5120, 5784,\n\t\t   5872, 6000, 0, 2160, 2168, 2178, 2200, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 124 - 5120x2160@48Hz 64:27 */\n\t{ DRM_MODE(\"5120x2160\", DRM_MODE_TYPE_DRIVER, 742500, 5120, 5866,\n\t\t   5954, 6250, 0, 2160, 2168, 2178, 2475, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 125 - 5120x2160@50Hz 64:27 */\n\t{ DRM_MODE(\"5120x2160\", DRM_MODE_TYPE_DRIVER, 742500, 5120, 6216,\n\t\t   6304, 6600, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 126 - 5120x2160@60Hz 64:27 */\n\t{ DRM_MODE(\"5120x2160\", DRM_MODE_TYPE_DRIVER, 742500, 5120, 5284,\n\t\t   5372, 5500, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 127 - 5120x2160@100Hz 64:27 */\n\t{ DRM_MODE(\"5120x2160\", DRM_MODE_TYPE_DRIVER, 1485000, 5120, 6216,\n\t\t   6304, 6600, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n};\n\n/*\n * From CEA/CTA-861 spec.\n *\n * Do not access directly, instead always use cea_mode_for_vic().\n */\nstatic const struct drm_display_mode edid_cea_modes_193[] = {\n\t/* 193 - 5120x2160@120Hz 64:27 */\n\t{ DRM_MODE(\"5120x2160\", DRM_MODE_TYPE_DRIVER, 1485000, 5120, 5284,\n\t\t   5372, 5500, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 194 - 7680x4320@24Hz 16:9 */\n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 1188000, 7680, 10232,\n\t\t   10408, 11000, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 195 - 7680x4320@25Hz 16:9 */\n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 1188000, 7680, 10032,\n\t\t   10208, 10800, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 196 - 7680x4320@30Hz 16:9 */\n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 1188000, 7680, 8232,\n\t\t   8408, 9000, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 197 - 7680x4320@48Hz 16:9 */\n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 2376000, 7680, 10232,\n\t\t   10408, 11000, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 198 - 7680x4320@50Hz 16:9 */\n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 2376000, 7680, 10032,\n\t\t   10208, 10800, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 199 - 7680x4320@60Hz 16:9 */\n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 2376000, 7680, 8232,\n\t\t   8408, 9000, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 200 - 7680x4320@100Hz 16:9 */\n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 4752000, 7680, 9792,\n\t\t   9968, 10560, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 201 - 7680x4320@120Hz 16:9 */\n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 4752000, 7680, 8032,\n\t\t   8208, 8800, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 202 - 7680x4320@24Hz 64:27 */\n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 1188000, 7680, 10232,\n\t\t   10408, 11000, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 203 - 7680x4320@25Hz 64:27 */\n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 1188000, 7680, 10032,\n\t\t   10208, 10800, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 204 - 7680x4320@30Hz 64:27 */\n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 1188000, 7680, 8232,\n\t\t   8408, 9000, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 205 - 7680x4320@48Hz 64:27 */\n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 2376000, 7680, 10232,\n\t\t   10408, 11000, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 206 - 7680x4320@50Hz 64:27 */\n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 2376000, 7680, 10032,\n\t\t   10208, 10800, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 207 - 7680x4320@60Hz 64:27 */\n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 2376000, 7680, 8232,\n\t\t   8408, 9000, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 208 - 7680x4320@100Hz 64:27 */\n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 4752000, 7680, 9792,\n\t\t   9968, 10560, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 209 - 7680x4320@120Hz 64:27 */\n\t{ DRM_MODE(\"7680x4320\", DRM_MODE_TYPE_DRIVER, 4752000, 7680, 8032,\n\t\t   8208, 8800, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 210 - 10240x4320@24Hz 64:27 */\n\t{ DRM_MODE(\"10240x4320\", DRM_MODE_TYPE_DRIVER, 1485000, 10240, 11732,\n\t\t   11908, 12500, 0, 4320, 4336, 4356, 4950, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 211 - 10240x4320@25Hz 64:27 */\n\t{ DRM_MODE(\"10240x4320\", DRM_MODE_TYPE_DRIVER, 1485000, 10240, 12732,\n\t\t   12908, 13500, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 212 - 10240x4320@30Hz 64:27 */\n\t{ DRM_MODE(\"10240x4320\", DRM_MODE_TYPE_DRIVER, 1485000, 10240, 10528,\n\t\t   10704, 11000, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 213 - 10240x4320@48Hz 64:27 */\n\t{ DRM_MODE(\"10240x4320\", DRM_MODE_TYPE_DRIVER, 2970000, 10240, 11732,\n\t\t   11908, 12500, 0, 4320, 4336, 4356, 4950, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 214 - 10240x4320@50Hz 64:27 */\n\t{ DRM_MODE(\"10240x4320\", DRM_MODE_TYPE_DRIVER, 2970000, 10240, 12732,\n\t\t   12908, 13500, 0, 4320, 4336, 4356, 4400, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 215 - 10240x4320@60Hz 64:27 */\n\t{ DRM_MODE(\"10240x4320\", DRM_MODE_TYPE_DRIVER, 2970000, 10240, 10528,\n\t\t   10704, 11000, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 216 - 10240x4320@100Hz 64:27 */\n\t{ DRM_MODE(\"10240x4320\", DRM_MODE_TYPE_DRIVER, 5940000, 10240, 12432,\n\t\t   12608, 13200, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 217 - 10240x4320@120Hz 64:27 */\n\t{ DRM_MODE(\"10240x4320\", DRM_MODE_TYPE_DRIVER, 5940000, 10240, 10528,\n\t\t   10704, 11000, 0, 4320, 4336, 4356, 4500, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },\n\t/* 218 - 4096x2160@100Hz 256:135 */\n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 1188000, 4096, 4896,\n\t\t   4984, 5280, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },\n\t/* 219 - 4096x2160@120Hz 256:135 */\n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 1188000, 4096, 4184,\n\t\t   4272, 4400, 0, 2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },\n};\n\n/*\n * HDMI 1.4 4k modes. Index using the VIC.\n */\nstatic const struct drm_display_mode edid_4k_modes[] = {\n\t/* 0 - dummy, VICs start at 1 */\n\t{ },\n\t/* 1 - 3840x2160@30Hz */\n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 297000,\n\t\t   3840, 4016, 4104, 4400, 0,\n\t\t   2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 2 - 3840x2160@25Hz */\n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 297000,\n\t\t   3840, 4896, 4984, 5280, 0,\n\t\t   2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 3 - 3840x2160@24Hz */\n\t{ DRM_MODE(\"3840x2160\", DRM_MODE_TYPE_DRIVER, 297000,\n\t\t   3840, 5116, 5204, 5500, 0,\n\t\t   2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },\n\t/* 4 - 4096x2160@24Hz (SMPTE) */\n\t{ DRM_MODE(\"4096x2160\", DRM_MODE_TYPE_DRIVER, 297000,\n\t\t   4096, 5116, 5204, 5500, 0,\n\t\t   2160, 2168, 2178, 2250, 0,\n\t\t   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),\n\t  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },\n};\n\n/*** DDC fetch and block validation ***/\n\nstatic const u8 edid_header[] = {\n\t0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00\n};\n\n/**\n * drm_edid_header_is_valid - sanity check the header of the base EDID block\n * @raw_edid: pointer to raw base EDID block\n *\n * Sanity check the header of the base EDID block.\n *\n * Return: 8 if the header is perfect, down to 0 if it's totally wrong.\n */\nint drm_edid_header_is_valid(const u8 *raw_edid)\n{\n\tint i, score = 0;\n\n\tfor (i = 0; i < sizeof(edid_header); i++)\n\t\tif (raw_edid[i] == edid_header[i])\n\t\t\tscore++;\n\n\treturn score;\n}\nEXPORT_SYMBOL(drm_edid_header_is_valid);\n\nstatic int edid_fixup __read_mostly = 6;\nmodule_param_named(edid_fixup, edid_fixup, int, 0400);\nMODULE_PARM_DESC(edid_fixup,\n\t\t \"Minimum number of valid EDID header bytes (0-8, default 6)\");\n\nstatic int validate_displayid(u8 *displayid, int length, int idx);\n\nstatic int drm_edid_block_checksum(const u8 *raw_edid)\n{\n\tint i;\n\tu8 csum = 0, crc = 0;\n\n\tfor (i = 0; i < EDID_LENGTH - 1; i++)\n\t\tcsum += raw_edid[i];\n\n\tcrc = 0x100 - csum;\n\n\treturn crc;\n}\n\nstatic bool drm_edid_block_checksum_diff(const u8 *raw_edid, u8 real_checksum)\n{\n\tif (raw_edid[EDID_LENGTH - 1] != real_checksum)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic bool drm_edid_is_zero(const u8 *in_edid, int length)\n{\n\tif (memchr_inv(in_edid, 0, length))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * drm_edid_are_equal - compare two edid blobs.\n * @edid1: pointer to first blob\n * @edid2: pointer to second blob\n * This helper can be used during probing to determine if\n * edid had changed.\n */\nbool drm_edid_are_equal(const struct edid *edid1, const struct edid *edid2)\n{\n\tint edid1_len, edid2_len;\n\tbool edid1_present = edid1 != NULL;\n\tbool edid2_present = edid2 != NULL;\n\n\tif (edid1_present != edid2_present)\n\t\treturn false;\n\n\tif (edid1) {\n\t\tedid1_len = EDID_LENGTH * (1 + edid1->extensions);\n\t\tedid2_len = EDID_LENGTH * (1 + edid2->extensions);\n\n\t\tif (edid1_len != edid2_len)\n\t\t\treturn false;\n\n\t\tif (memcmp(edid1, edid2, edid1_len))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(drm_edid_are_equal);\n\n/**\n * drm_edid_block_valid - Sanity check the EDID block (base or extension)\n * @raw_edid: pointer to raw EDID block\n * @block: type of block to validate (0 for base, extension otherwise)\n * @print_bad_edid: if true, dump bad EDID blocks to the console\n * @edid_corrupt: if true, the header or checksum is invalid\n *\n * Validate a base or extension EDID block and optionally dump bad blocks to\n * the console.\n *\n * Return: True if the block is valid, false otherwise.\n */\nbool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid,\n\t\t\t  bool *edid_corrupt)\n{\n\tu8 csum;\n\tstruct edid *edid = (struct edid *)raw_edid;\n\n\tif (WARN_ON(!raw_edid))\n\t\treturn false;\n\n\tif (edid_fixup > 8 || edid_fixup < 0)\n\t\tedid_fixup = 6;\n\n\tif (block == 0) {\n\t\tint score = drm_edid_header_is_valid(raw_edid);\n\n\t\tif (score == 8) {\n\t\t\tif (edid_corrupt)\n\t\t\t\t*edid_corrupt = false;\n\t\t} else if (score >= edid_fixup) {\n\t\t\t/* Displayport Link CTS Core 1.2 rev1.1 test 4.2.2.6\n\t\t\t * The corrupt flag needs to be set here otherwise, the\n\t\t\t * fix-up code here will correct the problem, the\n\t\t\t * checksum is correct and the test fails\n\t\t\t */\n\t\t\tif (edid_corrupt)\n\t\t\t\t*edid_corrupt = true;\n\t\t\tDRM_DEBUG(\"Fixing EDID header, your hardware may be failing\\n\");\n\t\t\tmemcpy(raw_edid, edid_header, sizeof(edid_header));\n\t\t} else {\n\t\t\tif (edid_corrupt)\n\t\t\t\t*edid_corrupt = true;\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\tcsum = drm_edid_block_checksum(raw_edid);\n\tif (drm_edid_block_checksum_diff(raw_edid, csum)) {\n\t\tif (edid_corrupt)\n\t\t\t*edid_corrupt = true;\n\n\t\t/* allow CEA to slide through, switches mangle this */\n\t\tif (raw_edid[0] == CEA_EXT) {\n\t\t\tDRM_DEBUG(\"EDID checksum is invalid, remainder is %d\\n\", csum);\n\t\t\tDRM_DEBUG(\"Assuming a KVM switch modified the CEA block but left the original checksum\\n\");\n\t\t} else {\n\t\t\tif (print_bad_edid)\n\t\t\t\tDRM_NOTE(\"EDID checksum is invalid, remainder is %d\\n\", csum);\n\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\t/* per-block-type checks */\n\tswitch (raw_edid[0]) {\n\tcase 0: /* base */\n\t\tif (edid->version != 1) {\n\t\t\tDRM_NOTE(\"EDID has major version %d, instead of 1\\n\", edid->version);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (edid->revision > 4)\n\t\t\tDRM_DEBUG(\"EDID minor > 4, assuming backward compatibility\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn true;\n\nbad:\n\tif (print_bad_edid) {\n\t\tif (drm_edid_is_zero(raw_edid, EDID_LENGTH)) {\n\t\t\tpr_notice(\"EDID block is all zeroes\\n\");\n\t\t} else {\n\t\t\tpr_notice(\"Raw EDID:\\n\");\n\t\t\tprint_hex_dump(KERN_NOTICE,\n\t\t\t\t       \" \\t\", DUMP_PREFIX_NONE, 16, 1,\n\t\t\t\t       raw_edid, EDID_LENGTH, false);\n\t\t}\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL(drm_edid_block_valid);\n\n/**\n * drm_edid_is_valid - sanity check EDID data\n * @edid: EDID data\n *\n * Sanity-check an entire EDID record (including extensions)\n *\n * Return: True if the EDID data is valid, false otherwise.\n */\nbool drm_edid_is_valid(struct edid *edid)\n{\n\tint i;\n\tu8 *raw = (u8 *)edid;\n\n\tif (!edid)\n\t\treturn false;\n\n\tfor (i = 0; i <= edid->extensions; i++)\n\t\tif (!drm_edid_block_valid(raw + i * EDID_LENGTH, i, true, NULL))\n\t\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL(drm_edid_is_valid);\n\n#define DDC_SEGMENT_ADDR 0x30\n/**\n * drm_do_probe_ddc_edid() - get EDID information via I2C\n * @data: I2C device adapter\n * @buf: EDID data buffer to be filled\n * @block: 128 byte EDID block to start fetching from\n * @len: EDID data buffer length to fetch\n *\n * Try to fetch EDID information by calling I2C driver functions.\n *\n * Return: 0 on success or -1 on failure.\n */\nstatic int\ndrm_do_probe_ddc_edid(void *data, u8 *buf, unsigned int block, size_t len)\n{\n\tstruct i2c_adapter *adapter = data;\n\tunsigned char start = block * EDID_LENGTH;\n\tunsigned char segment = block >> 1;\n\tunsigned char xfers = segment ? 3 : 2;\n\tint ret, retries = 5;\n\n\t/*\n\t * The core I2C driver will automatically retry the transfer if the\n\t * adapter reports EAGAIN. However, we find that bit-banging transfers\n\t * are susceptible to errors under a heavily loaded machine and\n\t * generate spurious NAKs and timeouts. Retrying the transfer\n\t * of the individual block a few times seems to overcome this.\n\t */\n\tdo {\n\t\tstruct i2c_msg msgs[] = {\n\t\t\t{\n\t\t\t\t.addr\t= DDC_SEGMENT_ADDR,\n\t\t\t\t.flags\t= 0,\n\t\t\t\t.len\t= 1,\n\t\t\t\t.buf\t= &segment,\n\t\t\t}, {\n\t\t\t\t.addr\t= DDC_ADDR,\n\t\t\t\t.flags\t= 0,\n\t\t\t\t.len\t= 1,\n\t\t\t\t.buf\t= &start,\n\t\t\t}, {\n\t\t\t\t.addr\t= DDC_ADDR,\n\t\t\t\t.flags\t= I2C_M_RD,\n\t\t\t\t.len\t= len,\n\t\t\t\t.buf\t= buf,\n\t\t\t}\n\t\t};\n\n\t\t/*\n\t\t * Avoid sending the segment addr to not upset non-compliant\n\t\t * DDC monitors.\n\t\t */\n\t\tret = i2c_transfer(adapter, &msgs[3 - xfers], xfers);\n\n\t\tif (ret == -ENXIO) {\n\t\t\tDRM_DEBUG_KMS(\"drm: skipping non-existent adapter %s\\n\",\n\t\t\t\t\tadapter->name);\n\t\t\tbreak;\n\t\t}\n\t} while (ret != xfers && --retries);\n\n\treturn ret == xfers ? 0 : -1;\n}\n\nstatic void connector_bad_edid(struct drm_connector *connector,\n\t\t\t       u8 *edid, int num_blocks)\n{\n\tint i;\n\tu8 num_of_ext = edid[0x7e];\n\n\t/* Calculate real checksum for the last edid extension block data */\n\tconnector->real_edid_checksum =\n\t\tdrm_edid_block_checksum(edid + num_of_ext * EDID_LENGTH);\n\n\tif (connector->bad_edid_counter++ && !drm_debug_enabled(DRM_UT_KMS))\n\t\treturn;\n\n\tdrm_warn(connector->dev, \"%s: EDID is invalid:\\n\", connector->name);\n\tfor (i = 0; i < num_blocks; i++) {\n\t\tu8 *block = edid + i * EDID_LENGTH;\n\t\tchar prefix[20];\n\n\t\tif (drm_edid_is_zero(block, EDID_LENGTH))\n\t\t\tsprintf(prefix, \"\\t[%02x] ZERO \", i);\n\t\telse if (!drm_edid_block_valid(block, i, false, NULL))\n\t\t\tsprintf(prefix, \"\\t[%02x] BAD  \", i);\n\t\telse\n\t\t\tsprintf(prefix, \"\\t[%02x] GOOD \", i);\n\n\t\tprint_hex_dump(KERN_WARNING,\n\t\t\t       prefix, DUMP_PREFIX_NONE, 16, 1,\n\t\t\t       block, EDID_LENGTH, false);\n\t}\n}\n\n/* Get override or firmware EDID */\nstatic struct edid *drm_get_override_edid(struct drm_connector *connector)\n{\n\tstruct edid *override = NULL;\n\n\tif (connector->override_edid)\n\t\toverride = drm_edid_duplicate(connector->edid_blob_ptr->data);\n\n\tif (!override)\n\t\toverride = drm_load_edid_firmware(connector);\n\n\treturn IS_ERR(override) ? NULL : override;\n}\n\n/**\n * drm_add_override_edid_modes - add modes from override/firmware EDID\n * @connector: connector we're probing\n *\n * Add modes from the override/firmware EDID, if available. Only to be used from\n * drm_helper_probe_single_connector_modes() as a fallback for when DDC probe\n * failed during drm_get_edid() and caused the override/firmware EDID to be\n * skipped.\n *\n * Return: The number of modes added or 0 if we couldn't find any.\n */\nint drm_add_override_edid_modes(struct drm_connector *connector)\n{\n\tstruct edid *override;\n\tint num_modes = 0;\n\n\toverride = drm_get_override_edid(connector);\n\tif (override) {\n\t\tdrm_connector_update_edid_property(connector, override);\n\t\tnum_modes = drm_add_edid_modes(connector, override);\n\t\tkfree(override);\n\n\t\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:%s] adding %d modes via fallback override/firmware EDID\\n\",\n\t\t\t      connector->base.id, connector->name, num_modes);\n\t}\n\n\treturn num_modes;\n}\nEXPORT_SYMBOL(drm_add_override_edid_modes);\n\n/**\n * drm_do_get_edid - get EDID data using a custom EDID block read function\n * @connector: connector we're probing\n * @get_edid_block: EDID block read function\n * @data: private data passed to the block read function\n *\n * When the I2C adapter connected to the DDC bus is hidden behind a device that\n * exposes a different interface to read EDID blocks this function can be used\n * to get EDID data using a custom block read function.\n *\n * As in the general case the DDC bus is accessible by the kernel at the I2C\n * level, drivers must make all reasonable efforts to expose it as an I2C\n * adapter and use drm_get_edid() instead of abusing this function.\n *\n * The EDID may be overridden using debugfs override_edid or firmare EDID\n * (drm_load_edid_firmware() and drm.edid_firmware parameter), in this priority\n * order. Having either of them bypasses actual EDID reads.\n *\n * Return: Pointer to valid EDID or NULL if we couldn't find any.\n */\nstruct edid *drm_do_get_edid(struct drm_connector *connector,\n\tint (*get_edid_block)(void *data, u8 *buf, unsigned int block,\n\t\t\t      size_t len),\n\tvoid *data)\n{\n\tint i, j = 0, valid_extensions = 0;\n\tu8 *edid, *new;\n\tstruct edid *override;\n\n\toverride = drm_get_override_edid(connector);\n\tif (override)\n\t\treturn override;\n\n\tif ((edid = kmalloc(EDID_LENGTH, GFP_KERNEL)) == NULL)\n\t\treturn NULL;\n\n\t/* base block fetch */\n\tfor (i = 0; i < 4; i++) {\n\t\tif (get_edid_block(data, edid, 0, EDID_LENGTH))\n\t\t\tgoto out;\n\t\tif (drm_edid_block_valid(edid, 0, false,\n\t\t\t\t\t &connector->edid_corrupt))\n\t\t\tbreak;\n\t\tif (i == 0 && drm_edid_is_zero(edid, EDID_LENGTH)) {\n\t\t\tconnector->null_edid_counter++;\n\t\t\tgoto carp;\n\t\t}\n\t}\n\tif (i == 4)\n\t\tgoto carp;\n\n\t/* if there's no extensions, we're done */\n\tvalid_extensions = edid[0x7e];\n\tif (valid_extensions == 0)\n\t\treturn (struct edid *)edid;\n\n\tnew = krealloc(edid, (valid_extensions + 1) * EDID_LENGTH, GFP_KERNEL);\n\tif (!new)\n\t\tgoto out;\n\tedid = new;\n\n\tfor (j = 1; j <= edid[0x7e]; j++) {\n\t\tu8 *block = edid + j * EDID_LENGTH;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (get_edid_block(data, block, j, EDID_LENGTH))\n\t\t\t\tgoto out;\n\t\t\tif (drm_edid_block_valid(block, j, false, NULL))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == 4)\n\t\t\tvalid_extensions--;\n\t}\n\n\tif (valid_extensions != edid[0x7e]) {\n\t\tu8 *base;\n\n\t\tconnector_bad_edid(connector, edid, edid[0x7e] + 1);\n\n\t\tedid[EDID_LENGTH-1] += edid[0x7e] - valid_extensions;\n\t\tedid[0x7e] = valid_extensions;\n\n\t\tnew = kmalloc_array(valid_extensions + 1, EDID_LENGTH,\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!new)\n\t\t\tgoto out;\n\n\t\tbase = new;\n\t\tfor (i = 0; i <= edid[0x7e]; i++) {\n\t\t\tu8 *block = edid + i * EDID_LENGTH;\n\n\t\t\tif (!drm_edid_block_valid(block, i, false, NULL))\n\t\t\t\tcontinue;\n\n\t\t\tmemcpy(base, block, EDID_LENGTH);\n\t\t\tbase += EDID_LENGTH;\n\t\t}\n\n\t\tkfree(edid);\n\t\tedid = new;\n\t}\n\n\treturn (struct edid *)edid;\n\ncarp:\n\tconnector_bad_edid(connector, edid, 1);\nout:\n\tkfree(edid);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(drm_do_get_edid);\n\n/**\n * drm_probe_ddc() - probe DDC presence\n * @adapter: I2C adapter to probe\n *\n * Return: True on success, false on failure.\n */\nbool\ndrm_probe_ddc(struct i2c_adapter *adapter)\n{\n\tunsigned char out;\n\n\treturn (drm_do_probe_ddc_edid(adapter, &out, 0, 1) == 0);\n}\nEXPORT_SYMBOL(drm_probe_ddc);\n\n/**\n * drm_get_edid - get EDID data, if available\n * @connector: connector we're probing\n * @adapter: I2C adapter to use for DDC\n *\n * Poke the given I2C channel to grab EDID data if possible.  If found,\n * attach it to the connector.\n *\n * Return: Pointer to valid EDID or NULL if we couldn't find any.\n */\nstruct edid *drm_get_edid(struct drm_connector *connector,\n\t\t\t  struct i2c_adapter *adapter)\n{\n\tstruct edid *edid;\n\n\tif (connector->force == DRM_FORCE_OFF)\n\t\treturn NULL;\n\n\tif (connector->force == DRM_FORCE_UNSPECIFIED && !drm_probe_ddc(adapter))\n\t\treturn NULL;\n\n\tedid = drm_do_get_edid(connector, drm_do_probe_ddc_edid, adapter);\n\tdrm_connector_update_edid_property(connector, edid);\n\treturn edid;\n}\nEXPORT_SYMBOL(drm_get_edid);\n\n/**\n * drm_get_edid_switcheroo - get EDID data for a vga_switcheroo output\n * @connector: connector we're probing\n * @adapter: I2C adapter to use for DDC\n *\n * Wrapper around drm_get_edid() for laptops with dual GPUs using one set of\n * outputs. The wrapper adds the requisite vga_switcheroo calls to temporarily\n * switch DDC to the GPU which is retrieving EDID.\n *\n * Return: Pointer to valid EDID or %NULL if we couldn't find any.\n */\nstruct edid *drm_get_edid_switcheroo(struct drm_connector *connector,\n\t\t\t\t     struct i2c_adapter *adapter)\n{\n\tstruct pci_dev *pdev = connector->dev->pdev;\n\tstruct edid *edid;\n\n\tvga_switcheroo_lock_ddc(pdev);\n\tedid = drm_get_edid(connector, adapter);\n\tvga_switcheroo_unlock_ddc(pdev);\n\n\treturn edid;\n}\nEXPORT_SYMBOL(drm_get_edid_switcheroo);\n\n/**\n * drm_edid_duplicate - duplicate an EDID and the extensions\n * @edid: EDID to duplicate\n *\n * Return: Pointer to duplicated EDID or NULL on allocation failure.\n */\nstruct edid *drm_edid_duplicate(const struct edid *edid)\n{\n\treturn kmemdup(edid, (edid->extensions + 1) * EDID_LENGTH, GFP_KERNEL);\n}\nEXPORT_SYMBOL(drm_edid_duplicate);\n\n/*** EDID parsing ***/\n\n/**\n * edid_vendor - match a string against EDID's obfuscated vendor field\n * @edid: EDID to match\n * @vendor: vendor string\n *\n * Returns true if @vendor is in @edid, false otherwise\n */\nstatic bool edid_vendor(const struct edid *edid, const char *vendor)\n{\n\tchar edid_vendor[3];\n\n\tedid_vendor[0] = ((edid->mfg_id[0] & 0x7c) >> 2) + '@';\n\tedid_vendor[1] = (((edid->mfg_id[0] & 0x3) << 3) |\n\t\t\t  ((edid->mfg_id[1] & 0xe0) >> 5)) + '@';\n\tedid_vendor[2] = (edid->mfg_id[1] & 0x1f) + '@';\n\n\treturn !strncmp(edid_vendor, vendor, 3);\n}\n\n/**\n * edid_get_quirks - return quirk flags for a given EDID\n * @edid: EDID to process\n *\n * This tells subsequent routines what fixes they need to apply.\n */\nstatic u32 edid_get_quirks(const struct edid *edid)\n{\n\tconst struct edid_quirk *quirk;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(edid_quirk_list); i++) {\n\t\tquirk = &edid_quirk_list[i];\n\n\t\tif (edid_vendor(edid, quirk->vendor) &&\n\t\t    (EDID_PRODUCT_ID(edid) == quirk->product_id))\n\t\t\treturn quirk->quirks;\n\t}\n\n\treturn 0;\n}\n\n#define MODE_SIZE(m) ((m)->hdisplay * (m)->vdisplay)\n#define MODE_REFRESH_DIFF(c,t) (abs((c) - (t)))\n\n/**\n * edid_fixup_preferred - set preferred modes based on quirk list\n * @connector: has mode list to fix up\n * @quirks: quirks list\n *\n * Walk the mode list for @connector, clearing the preferred status\n * on existing modes and setting it anew for the right mode ala @quirks.\n */\nstatic void edid_fixup_preferred(struct drm_connector *connector,\n\t\t\t\t u32 quirks)\n{\n\tstruct drm_display_mode *t, *cur_mode, *preferred_mode;\n\tint target_refresh = 0;\n\tint cur_vrefresh, preferred_vrefresh;\n\n\tif (list_empty(&connector->probed_modes))\n\t\treturn;\n\n\tif (quirks & EDID_QUIRK_PREFER_LARGE_60)\n\t\ttarget_refresh = 60;\n\tif (quirks & EDID_QUIRK_PREFER_LARGE_75)\n\t\ttarget_refresh = 75;\n\n\tpreferred_mode = list_first_entry(&connector->probed_modes,\n\t\t\t\t\t  struct drm_display_mode, head);\n\n\tlist_for_each_entry_safe(cur_mode, t, &connector->probed_modes, head) {\n\t\tcur_mode->type &= ~DRM_MODE_TYPE_PREFERRED;\n\n\t\tif (cur_mode == preferred_mode)\n\t\t\tcontinue;\n\n\t\t/* Largest mode is preferred */\n\t\tif (MODE_SIZE(cur_mode) > MODE_SIZE(preferred_mode))\n\t\t\tpreferred_mode = cur_mode;\n\n\t\tcur_vrefresh = drm_mode_vrefresh(cur_mode);\n\t\tpreferred_vrefresh = drm_mode_vrefresh(preferred_mode);\n\t\t/* At a given size, try to get closest to target refresh */\n\t\tif ((MODE_SIZE(cur_mode) == MODE_SIZE(preferred_mode)) &&\n\t\t    MODE_REFRESH_DIFF(cur_vrefresh, target_refresh) <\n\t\t    MODE_REFRESH_DIFF(preferred_vrefresh, target_refresh)) {\n\t\t\tpreferred_mode = cur_mode;\n\t\t}\n\t}\n\n\tpreferred_mode->type |= DRM_MODE_TYPE_PREFERRED;\n}\n\nstatic bool\nmode_is_rb(const struct drm_display_mode *mode)\n{\n\treturn (mode->htotal - mode->hdisplay == 160) &&\n\t       (mode->hsync_end - mode->hdisplay == 80) &&\n\t       (mode->hsync_end - mode->hsync_start == 32) &&\n\t       (mode->vsync_start - mode->vdisplay == 3);\n}\n\n/*\n * drm_mode_find_dmt - Create a copy of a mode if present in DMT\n * @dev: Device to duplicate against\n * @hsize: Mode width\n * @vsize: Mode height\n * @fresh: Mode refresh rate\n * @rb: Mode reduced-blanking-ness\n *\n * Walk the DMT mode list looking for a match for the given parameters.\n *\n * Return: A newly allocated copy of the mode, or NULL if not found.\n */\nstruct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,\n\t\t\t\t\t   int hsize, int vsize, int fresh,\n\t\t\t\t\t   bool rb)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(drm_dmt_modes); i++) {\n\t\tconst struct drm_display_mode *ptr = &drm_dmt_modes[i];\n\n\t\tif (hsize != ptr->hdisplay)\n\t\t\tcontinue;\n\t\tif (vsize != ptr->vdisplay)\n\t\t\tcontinue;\n\t\tif (fresh != drm_mode_vrefresh(ptr))\n\t\t\tcontinue;\n\t\tif (rb != mode_is_rb(ptr))\n\t\t\tcontinue;\n\n\t\treturn drm_mode_duplicate(dev, ptr);\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(drm_mode_find_dmt);\n\nstatic bool is_display_descriptor(const u8 d[18], u8 tag)\n{\n\treturn d[0] == 0x00 && d[1] == 0x00 &&\n\t\td[2] == 0x00 && d[3] == tag;\n}\n\nstatic bool is_detailed_timing_descriptor(const u8 d[18])\n{\n\treturn d[0] != 0x00 || d[1] != 0x00;\n}\n\ntypedef void detailed_cb(struct detailed_timing *timing, void *closure);\n\nstatic void\ncea_for_each_detailed_block(u8 *ext, detailed_cb *cb, void *closure)\n{\n\tint i, n;\n\tu8 d = ext[0x02];\n\tu8 *det_base = ext + d;\n\n\tif (d < 4 || d > 127)\n\t\treturn;\n\n\tn = (127 - d) / 18;\n\tfor (i = 0; i < n; i++)\n\t\tcb((struct detailed_timing *)(det_base + 18 * i), closure);\n}\n\nstatic void\nvtb_for_each_detailed_block(u8 *ext, detailed_cb *cb, void *closure)\n{\n\tunsigned int i, n = min((int)ext[0x02], 6);\n\tu8 *det_base = ext + 5;\n\n\tif (ext[0x01] != 1)\n\t\treturn; /* unknown version */\n\n\tfor (i = 0; i < n; i++)\n\t\tcb((struct detailed_timing *)(det_base + 18 * i), closure);\n}\n\nstatic void\ndrm_for_each_detailed_block(u8 *raw_edid, detailed_cb *cb, void *closure)\n{\n\tint i;\n\tstruct edid *edid = (struct edid *)raw_edid;\n\n\tif (edid == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < EDID_DETAILED_TIMINGS; i++)\n\t\tcb(&(edid->detailed_timings[i]), closure);\n\n\tfor (i = 1; i <= raw_edid[0x7e]; i++) {\n\t\tu8 *ext = raw_edid + (i * EDID_LENGTH);\n\n\t\tswitch (*ext) {\n\t\tcase CEA_EXT:\n\t\t\tcea_for_each_detailed_block(ext, cb, closure);\n\t\t\tbreak;\n\t\tcase VTB_EXT:\n\t\t\tvtb_for_each_detailed_block(ext, cb, closure);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void\nis_rb(struct detailed_timing *t, void *data)\n{\n\tu8 *r = (u8 *)t;\n\n\tif (!is_display_descriptor(r, EDID_DETAIL_MONITOR_RANGE))\n\t\treturn;\n\n\tif (r[15] & 0x10)\n\t\t*(bool *)data = true;\n}\n\n/* EDID 1.4 defines this explicitly.  For EDID 1.3, we guess, badly. */\nstatic bool\ndrm_monitor_supports_rb(struct edid *edid)\n{\n\tif (edid->revision >= 4) {\n\t\tbool ret = false;\n\n\t\tdrm_for_each_detailed_block((u8 *)edid, is_rb, &ret);\n\t\treturn ret;\n\t}\n\n\treturn ((edid->input & DRM_EDID_INPUT_DIGITAL) != 0);\n}\n\nstatic void\nfind_gtf2(struct detailed_timing *t, void *data)\n{\n\tu8 *r = (u8 *)t;\n\n\tif (!is_display_descriptor(r, EDID_DETAIL_MONITOR_RANGE))\n\t\treturn;\n\n\tif (r[10] == 0x02)\n\t\t*(u8 **)data = r;\n}\n\n/* Secondary GTF curve kicks in above some break frequency */\nstatic int\ndrm_gtf2_hbreak(struct edid *edid)\n{\n\tu8 *r = NULL;\n\n\tdrm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);\n\treturn r ? (r[12] * 2) : 0;\n}\n\nstatic int\ndrm_gtf2_2c(struct edid *edid)\n{\n\tu8 *r = NULL;\n\n\tdrm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);\n\treturn r ? r[13] : 0;\n}\n\nstatic int\ndrm_gtf2_m(struct edid *edid)\n{\n\tu8 *r = NULL;\n\n\tdrm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);\n\treturn r ? (r[15] << 8) + r[14] : 0;\n}\n\nstatic int\ndrm_gtf2_k(struct edid *edid)\n{\n\tu8 *r = NULL;\n\n\tdrm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);\n\treturn r ? r[16] : 0;\n}\n\nstatic int\ndrm_gtf2_2j(struct edid *edid)\n{\n\tu8 *r = NULL;\n\n\tdrm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);\n\treturn r ? r[17] : 0;\n}\n\n/**\n * standard_timing_level - get std. timing level(CVT/GTF/DMT)\n * @edid: EDID block to scan\n */\nstatic int standard_timing_level(struct edid *edid)\n{\n\tif (edid->revision >= 2) {\n\t\tif (edid->revision >= 4 && (edid->features & DRM_EDID_FEATURE_DEFAULT_GTF))\n\t\t\treturn LEVEL_CVT;\n\t\tif (drm_gtf2_hbreak(edid))\n\t\t\treturn LEVEL_GTF2;\n\t\tif (edid->features & DRM_EDID_FEATURE_DEFAULT_GTF)\n\t\t\treturn LEVEL_GTF;\n\t}\n\treturn LEVEL_DMT;\n}\n\n/*\n * 0 is reserved.  The spec says 0x01 fill for unused timings.  Some old\n * monitors fill with ascii space (0x20) instead.\n */\nstatic int\nbad_std_timing(u8 a, u8 b)\n{\n\treturn (a == 0x00 && b == 0x00) ||\n\t       (a == 0x01 && b == 0x01) ||\n\t       (a == 0x20 && b == 0x20);\n}\n\nstatic int drm_mode_hsync(const struct drm_display_mode *mode)\n{\n\tif (mode->htotal <= 0)\n\t\treturn 0;\n\n\treturn DIV_ROUND_CLOSEST(mode->clock, mode->htotal);\n}\n\n/**\n * drm_mode_std - convert standard mode info (width, height, refresh) into mode\n * @connector: connector of for the EDID block\n * @edid: EDID block to scan\n * @t: standard timing params\n *\n * Take the standard timing params (in this case width, aspect, and refresh)\n * and convert them into a real mode using CVT/GTF/DMT.\n */\nstatic struct drm_display_mode *\ndrm_mode_std(struct drm_connector *connector, struct edid *edid,\n\t     struct std_timing *t)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_display_mode *m, *mode = NULL;\n\tint hsize, vsize;\n\tint vrefresh_rate;\n\tunsigned aspect_ratio = (t->vfreq_aspect & EDID_TIMING_ASPECT_MASK)\n\t\t>> EDID_TIMING_ASPECT_SHIFT;\n\tunsigned vfreq = (t->vfreq_aspect & EDID_TIMING_VFREQ_MASK)\n\t\t>> EDID_TIMING_VFREQ_SHIFT;\n\tint timing_level = standard_timing_level(edid);\n\n\tif (bad_std_timing(t->hsize, t->vfreq_aspect))\n\t\treturn NULL;\n\n\t/* According to the EDID spec, the hdisplay = hsize * 8 + 248 */\n\thsize = t->hsize * 8 + 248;\n\t/* vrefresh_rate = vfreq + 60 */\n\tvrefresh_rate = vfreq + 60;\n\t/* the vdisplay is calculated based on the aspect ratio */\n\tif (aspect_ratio == 0) {\n\t\tif (edid->revision < 3)\n\t\t\tvsize = hsize;\n\t\telse\n\t\t\tvsize = (hsize * 10) / 16;\n\t} else if (aspect_ratio == 1)\n\t\tvsize = (hsize * 3) / 4;\n\telse if (aspect_ratio == 2)\n\t\tvsize = (hsize * 4) / 5;\n\telse\n\t\tvsize = (hsize * 9) / 16;\n\n\t/* HDTV hack, part 1 */\n\tif (vrefresh_rate == 60 &&\n\t    ((hsize == 1360 && vsize == 765) ||\n\t     (hsize == 1368 && vsize == 769))) {\n\t\thsize = 1366;\n\t\tvsize = 768;\n\t}\n\n\t/*\n\t * If this connector already has a mode for this size and refresh\n\t * rate (because it came from detailed or CVT info), use that\n\t * instead.  This way we don't have to guess at interlace or\n\t * reduced blanking.\n\t */\n\tlist_for_each_entry(m, &connector->probed_modes, head)\n\t\tif (m->hdisplay == hsize && m->vdisplay == vsize &&\n\t\t    drm_mode_vrefresh(m) == vrefresh_rate)\n\t\t\treturn NULL;\n\n\t/* HDTV hack, part 2 */\n\tif (hsize == 1366 && vsize == 768 && vrefresh_rate == 60) {\n\t\tmode = drm_cvt_mode(dev, 1366, 768, vrefresh_rate, 0, 0,\n\t\t\t\t    false);\n\t\tif (!mode)\n\t\t\treturn NULL;\n\t\tmode->hdisplay = 1366;\n\t\tmode->hsync_start = mode->hsync_start - 1;\n\t\tmode->hsync_end = mode->hsync_end - 1;\n\t\treturn mode;\n\t}\n\n\t/* check whether it can be found in default mode table */\n\tif (drm_monitor_supports_rb(edid)) {\n\t\tmode = drm_mode_find_dmt(dev, hsize, vsize, vrefresh_rate,\n\t\t\t\t\t true);\n\t\tif (mode)\n\t\t\treturn mode;\n\t}\n\tmode = drm_mode_find_dmt(dev, hsize, vsize, vrefresh_rate, false);\n\tif (mode)\n\t\treturn mode;\n\n\t/* okay, generate it */\n\tswitch (timing_level) {\n\tcase LEVEL_DMT:\n\t\tbreak;\n\tcase LEVEL_GTF:\n\t\tmode = drm_gtf_mode(dev, hsize, vsize, vrefresh_rate, 0, 0);\n\t\tbreak;\n\tcase LEVEL_GTF2:\n\t\t/*\n\t\t * This is potentially wrong if there's ever a monitor with\n\t\t * more than one ranges section, each claiming a different\n\t\t * secondary GTF curve.  Please don't do that.\n\t\t */\n\t\tmode = drm_gtf_mode(dev, hsize, vsize, vrefresh_rate, 0, 0);\n\t\tif (!mode)\n\t\t\treturn NULL;\n\t\tif (drm_mode_hsync(mode) > drm_gtf2_hbreak(edid)) {\n\t\t\tdrm_mode_destroy(dev, mode);\n\t\t\tmode = drm_gtf_mode_complex(dev, hsize, vsize,\n\t\t\t\t\t\t    vrefresh_rate, 0, 0,\n\t\t\t\t\t\t    drm_gtf2_m(edid),\n\t\t\t\t\t\t    drm_gtf2_2c(edid),\n\t\t\t\t\t\t    drm_gtf2_k(edid),\n\t\t\t\t\t\t    drm_gtf2_2j(edid));\n\t\t}\n\t\tbreak;\n\tcase LEVEL_CVT:\n\t\tmode = drm_cvt_mode(dev, hsize, vsize, vrefresh_rate, 0, 0,\n\t\t\t\t    false);\n\t\tbreak;\n\t}\n\treturn mode;\n}\n\n/*\n * EDID is delightfully ambiguous about how interlaced modes are to be\n * encoded.  Our internal representation is of frame height, but some\n * HDTV detailed timings are encoded as field height.\n *\n * The format list here is from CEA, in frame size.  Technically we\n * should be checking refresh rate too.  Whatever.\n */\nstatic void\ndrm_mode_do_interlace_quirk(struct drm_display_mode *mode,\n\t\t\t    struct detailed_pixel_timing *pt)\n{\n\tint i;\n\tstatic const struct {\n\t\tint w, h;\n\t} cea_interlaced[] = {\n\t\t{ 1920, 1080 },\n\t\t{  720,  480 },\n\t\t{ 1440,  480 },\n\t\t{ 2880,  480 },\n\t\t{  720,  576 },\n\t\t{ 1440,  576 },\n\t\t{ 2880,  576 },\n\t};\n\n\tif (!(pt->misc & DRM_EDID_PT_INTERLACED))\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(cea_interlaced); i++) {\n\t\tif ((mode->hdisplay == cea_interlaced[i].w) &&\n\t\t    (mode->vdisplay == cea_interlaced[i].h / 2)) {\n\t\t\tmode->vdisplay *= 2;\n\t\t\tmode->vsync_start *= 2;\n\t\t\tmode->vsync_end *= 2;\n\t\t\tmode->vtotal *= 2;\n\t\t\tmode->vtotal |= 1;\n\t\t}\n\t}\n\n\tmode->flags |= DRM_MODE_FLAG_INTERLACE;\n}\n\n/**\n * drm_mode_detailed - create a new mode from an EDID detailed timing section\n * @dev: DRM device (needed to create new mode)\n * @edid: EDID block\n * @timing: EDID detailed timing info\n * @quirks: quirks to apply\n *\n * An EDID detailed timing block contains enough info for us to create and\n * return a new struct drm_display_mode.\n */\nstatic struct drm_display_mode *drm_mode_detailed(struct drm_device *dev,\n\t\t\t\t\t\t  struct edid *edid,\n\t\t\t\t\t\t  struct detailed_timing *timing,\n\t\t\t\t\t\t  u32 quirks)\n{\n\tstruct drm_display_mode *mode;\n\tstruct detailed_pixel_timing *pt = &timing->data.pixel_data;\n\tunsigned hactive = (pt->hactive_hblank_hi & 0xf0) << 4 | pt->hactive_lo;\n\tunsigned vactive = (pt->vactive_vblank_hi & 0xf0) << 4 | pt->vactive_lo;\n\tunsigned hblank = (pt->hactive_hblank_hi & 0xf) << 8 | pt->hblank_lo;\n\tunsigned vblank = (pt->vactive_vblank_hi & 0xf) << 8 | pt->vblank_lo;\n\tunsigned hsync_offset = (pt->hsync_vsync_offset_pulse_width_hi & 0xc0) << 2 | pt->hsync_offset_lo;\n\tunsigned hsync_pulse_width = (pt->hsync_vsync_offset_pulse_width_hi & 0x30) << 4 | pt->hsync_pulse_width_lo;\n\tunsigned vsync_offset = (pt->hsync_vsync_offset_pulse_width_hi & 0xc) << 2 | pt->vsync_offset_pulse_width_lo >> 4;\n\tunsigned vsync_pulse_width = (pt->hsync_vsync_offset_pulse_width_hi & 0x3) << 4 | (pt->vsync_offset_pulse_width_lo & 0xf);\n\n\t/* ignore tiny modes */\n\tif (hactive < 64 || vactive < 64)\n\t\treturn NULL;\n\n\tif (pt->misc & DRM_EDID_PT_STEREO) {\n\t\tDRM_DEBUG_KMS(\"stereo mode not supported\\n\");\n\t\treturn NULL;\n\t}\n\tif (!(pt->misc & DRM_EDID_PT_SEPARATE_SYNC)) {\n\t\tDRM_DEBUG_KMS(\"composite sync not supported\\n\");\n\t}\n\n\t/* it is incorrect if hsync/vsync width is zero */\n\tif (!hsync_pulse_width || !vsync_pulse_width) {\n\t\tDRM_DEBUG_KMS(\"Incorrect Detailed timing. \"\n\t\t\t\t\"Wrong Hsync/Vsync pulse width\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (quirks & EDID_QUIRK_FORCE_REDUCED_BLANKING) {\n\t\tmode = drm_cvt_mode(dev, hactive, vactive, 60, true, false, false);\n\t\tif (!mode)\n\t\t\treturn NULL;\n\n\t\tgoto set_size;\n\t}\n\n\tmode = drm_mode_create(dev);\n\tif (!mode)\n\t\treturn NULL;\n\n\tif (quirks & EDID_QUIRK_135_CLOCK_TOO_HIGH)\n\t\ttiming->pixel_clock = cpu_to_le16(1088);\n\n\tmode->clock = le16_to_cpu(timing->pixel_clock) * 10;\n\n\tmode->hdisplay = hactive;\n\tmode->hsync_start = mode->hdisplay + hsync_offset;\n\tmode->hsync_end = mode->hsync_start + hsync_pulse_width;\n\tmode->htotal = mode->hdisplay + hblank;\n\n\tmode->vdisplay = vactive;\n\tmode->vsync_start = mode->vdisplay + vsync_offset;\n\tmode->vsync_end = mode->vsync_start + vsync_pulse_width;\n\tmode->vtotal = mode->vdisplay + vblank;\n\n\t/* Some EDIDs have bogus h/vtotal values */\n\tif (mode->hsync_end > mode->htotal)\n\t\tmode->htotal = mode->hsync_end + 1;\n\tif (mode->vsync_end > mode->vtotal)\n\t\tmode->vtotal = mode->vsync_end + 1;\n\n\tdrm_mode_do_interlace_quirk(mode, pt);\n\n\tif (quirks & EDID_QUIRK_DETAILED_SYNC_PP) {\n\t\tpt->misc |= DRM_EDID_PT_HSYNC_POSITIVE | DRM_EDID_PT_VSYNC_POSITIVE;\n\t}\n\n\tmode->flags |= (pt->misc & DRM_EDID_PT_HSYNC_POSITIVE) ?\n\t\tDRM_MODE_FLAG_PHSYNC : DRM_MODE_FLAG_NHSYNC;\n\tmode->flags |= (pt->misc & DRM_EDID_PT_VSYNC_POSITIVE) ?\n\t\tDRM_MODE_FLAG_PVSYNC : DRM_MODE_FLAG_NVSYNC;\n\nset_size:\n\tmode->width_mm = pt->width_mm_lo | (pt->width_height_mm_hi & 0xf0) << 4;\n\tmode->height_mm = pt->height_mm_lo | (pt->width_height_mm_hi & 0xf) << 8;\n\n\tif (quirks & EDID_QUIRK_DETAILED_IN_CM) {\n\t\tmode->width_mm *= 10;\n\t\tmode->height_mm *= 10;\n\t}\n\n\tif (quirks & EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE) {\n\t\tmode->width_mm = edid->width_cm * 10;\n\t\tmode->height_mm = edid->height_cm * 10;\n\t}\n\n\tmode->type = DRM_MODE_TYPE_DRIVER;\n\tdrm_mode_set_name(mode);\n\n\treturn mode;\n}\n\nstatic bool\nmode_in_hsync_range(const struct drm_display_mode *mode,\n\t\t    struct edid *edid, u8 *t)\n{\n\tint hsync, hmin, hmax;\n\n\thmin = t[7];\n\tif (edid->revision >= 4)\n\t    hmin += ((t[4] & 0x04) ? 255 : 0);\n\thmax = t[8];\n\tif (edid->revision >= 4)\n\t    hmax += ((t[4] & 0x08) ? 255 : 0);\n\thsync = drm_mode_hsync(mode);\n\n\treturn (hsync <= hmax && hsync >= hmin);\n}\n\nstatic bool\nmode_in_vsync_range(const struct drm_display_mode *mode,\n\t\t    struct edid *edid, u8 *t)\n{\n\tint vsync, vmin, vmax;\n\n\tvmin = t[5];\n\tif (edid->revision >= 4)\n\t    vmin += ((t[4] & 0x01) ? 255 : 0);\n\tvmax = t[6];\n\tif (edid->revision >= 4)\n\t    vmax += ((t[4] & 0x02) ? 255 : 0);\n\tvsync = drm_mode_vrefresh(mode);\n\n\treturn (vsync <= vmax && vsync >= vmin);\n}\n\nstatic u32\nrange_pixel_clock(struct edid *edid, u8 *t)\n{\n\t/* unspecified */\n\tif (t[9] == 0 || t[9] == 255)\n\t\treturn 0;\n\n\t/* 1.4 with CVT support gives us real precision, yay */\n\tif (edid->revision >= 4 && t[10] == 0x04)\n\t\treturn (t[9] * 10000) - ((t[12] >> 2) * 250);\n\n\t/* 1.3 is pathetic, so fuzz up a bit */\n\treturn t[9] * 10000 + 5001;\n}\n\nstatic bool\nmode_in_range(const struct drm_display_mode *mode, struct edid *edid,\n\t      struct detailed_timing *timing)\n{\n\tu32 max_clock;\n\tu8 *t = (u8 *)timing;\n\n\tif (!mode_in_hsync_range(mode, edid, t))\n\t\treturn false;\n\n\tif (!mode_in_vsync_range(mode, edid, t))\n\t\treturn false;\n\n\tif ((max_clock = range_pixel_clock(edid, t)))\n\t\tif (mode->clock > max_clock)\n\t\t\treturn false;\n\n\t/* 1.4 max horizontal check */\n\tif (edid->revision >= 4 && t[10] == 0x04)\n\t\tif (t[13] && mode->hdisplay > 8 * (t[13] + (256 * (t[12]&0x3))))\n\t\t\treturn false;\n\n\tif (mode_is_rb(mode) && !drm_monitor_supports_rb(edid))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool valid_inferred_mode(const struct drm_connector *connector,\n\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tconst struct drm_display_mode *m;\n\tbool ok = false;\n\n\tlist_for_each_entry(m, &connector->probed_modes, head) {\n\t\tif (mode->hdisplay == m->hdisplay &&\n\t\t    mode->vdisplay == m->vdisplay &&\n\t\t    drm_mode_vrefresh(mode) == drm_mode_vrefresh(m))\n\t\t\treturn false; /* duplicated */\n\t\tif (mode->hdisplay <= m->hdisplay &&\n\t\t    mode->vdisplay <= m->vdisplay)\n\t\t\tok = true;\n\t}\n\treturn ok;\n}\n\nstatic int\ndrm_dmt_modes_for_range(struct drm_connector *connector, struct edid *edid,\n\t\t\tstruct detailed_timing *timing)\n{\n\tint i, modes = 0;\n\tstruct drm_display_mode *newmode;\n\tstruct drm_device *dev = connector->dev;\n\n\tfor (i = 0; i < ARRAY_SIZE(drm_dmt_modes); i++) {\n\t\tif (mode_in_range(drm_dmt_modes + i, edid, timing) &&\n\t\t    valid_inferred_mode(connector, drm_dmt_modes + i)) {\n\t\t\tnewmode = drm_mode_duplicate(dev, &drm_dmt_modes[i]);\n\t\t\tif (newmode) {\n\t\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t\t\tmodes++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn modes;\n}\n\n/* fix up 1366x768 mode from 1368x768;\n * GFT/CVT can't express 1366 width which isn't dividable by 8\n */\nvoid drm_mode_fixup_1366x768(struct drm_display_mode *mode)\n{\n\tif (mode->hdisplay == 1368 && mode->vdisplay == 768) {\n\t\tmode->hdisplay = 1366;\n\t\tmode->hsync_start--;\n\t\tmode->hsync_end--;\n\t\tdrm_mode_set_name(mode);\n\t}\n}\n\nstatic int\ndrm_gtf_modes_for_range(struct drm_connector *connector, struct edid *edid,\n\t\t\tstruct detailed_timing *timing)\n{\n\tint i, modes = 0;\n\tstruct drm_display_mode *newmode;\n\tstruct drm_device *dev = connector->dev;\n\n\tfor (i = 0; i < ARRAY_SIZE(extra_modes); i++) {\n\t\tconst struct minimode *m = &extra_modes[i];\n\n\t\tnewmode = drm_gtf_mode(dev, m->w, m->h, m->r, 0, 0);\n\t\tif (!newmode)\n\t\t\treturn modes;\n\n\t\tdrm_mode_fixup_1366x768(newmode);\n\t\tif (!mode_in_range(newmode, edid, timing) ||\n\t\t    !valid_inferred_mode(connector, newmode)) {\n\t\t\tdrm_mode_destroy(dev, newmode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdrm_mode_probed_add(connector, newmode);\n\t\tmodes++;\n\t}\n\n\treturn modes;\n}\n\nstatic int\ndrm_cvt_modes_for_range(struct drm_connector *connector, struct edid *edid,\n\t\t\tstruct detailed_timing *timing)\n{\n\tint i, modes = 0;\n\tstruct drm_display_mode *newmode;\n\tstruct drm_device *dev = connector->dev;\n\tbool rb = drm_monitor_supports_rb(edid);\n\n\tfor (i = 0; i < ARRAY_SIZE(extra_modes); i++) {\n\t\tconst struct minimode *m = &extra_modes[i];\n\n\t\tnewmode = drm_cvt_mode(dev, m->w, m->h, m->r, rb, 0, 0);\n\t\tif (!newmode)\n\t\t\treturn modes;\n\n\t\tdrm_mode_fixup_1366x768(newmode);\n\t\tif (!mode_in_range(newmode, edid, timing) ||\n\t\t    !valid_inferred_mode(connector, newmode)) {\n\t\t\tdrm_mode_destroy(dev, newmode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdrm_mode_probed_add(connector, newmode);\n\t\tmodes++;\n\t}\n\n\treturn modes;\n}\n\nstatic void\ndo_inferred_modes(struct detailed_timing *timing, void *c)\n{\n\tstruct detailed_mode_closure *closure = c;\n\tstruct detailed_non_pixel *data = &timing->data.other_data;\n\tstruct detailed_data_monitor_range *range = &data->data.range;\n\n\tif (!is_display_descriptor((const u8 *)timing, EDID_DETAIL_MONITOR_RANGE))\n\t\treturn;\n\n\tclosure->modes += drm_dmt_modes_for_range(closure->connector,\n\t\t\t\t\t\t  closure->edid,\n\t\t\t\t\t\t  timing);\n\n\tif (!version_greater(closure->edid, 1, 1))\n\t\treturn; /* GTF not defined yet */\n\n\tswitch (range->flags) {\n\tcase 0x02: /* secondary gtf, XXX could do more */\n\tcase 0x00: /* default gtf */\n\t\tclosure->modes += drm_gtf_modes_for_range(closure->connector,\n\t\t\t\t\t\t\t  closure->edid,\n\t\t\t\t\t\t\t  timing);\n\t\tbreak;\n\tcase 0x04: /* cvt, only in 1.4+ */\n\t\tif (!version_greater(closure->edid, 1, 3))\n\t\t\tbreak;\n\n\t\tclosure->modes += drm_cvt_modes_for_range(closure->connector,\n\t\t\t\t\t\t\t  closure->edid,\n\t\t\t\t\t\t\t  timing);\n\t\tbreak;\n\tcase 0x01: /* just the ranges, no formula */\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int\nadd_inferred_modes(struct drm_connector *connector, struct edid *edid)\n{\n\tstruct detailed_mode_closure closure = {\n\t\t.connector = connector,\n\t\t.edid = edid,\n\t};\n\n\tif (version_greater(edid, 1, 0))\n\t\tdrm_for_each_detailed_block((u8 *)edid, do_inferred_modes,\n\t\t\t\t\t    &closure);\n\n\treturn closure.modes;\n}\n\nstatic int\ndrm_est3_modes(struct drm_connector *connector, struct detailed_timing *timing)\n{\n\tint i, j, m, modes = 0;\n\tstruct drm_display_mode *mode;\n\tu8 *est = ((u8 *)timing) + 6;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tfor (j = 7; j >= 0; j--) {\n\t\t\tm = (i * 8) + (7 - j);\n\t\t\tif (m >= ARRAY_SIZE(est3_modes))\n\t\t\t\tbreak;\n\t\t\tif (est[i] & (1 << j)) {\n\t\t\t\tmode = drm_mode_find_dmt(connector->dev,\n\t\t\t\t\t\t\t est3_modes[m].w,\n\t\t\t\t\t\t\t est3_modes[m].h,\n\t\t\t\t\t\t\t est3_modes[m].r,\n\t\t\t\t\t\t\t est3_modes[m].rb);\n\t\t\t\tif (mode) {\n\t\t\t\t\tdrm_mode_probed_add(connector, mode);\n\t\t\t\t\tmodes++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn modes;\n}\n\nstatic void\ndo_established_modes(struct detailed_timing *timing, void *c)\n{\n\tstruct detailed_mode_closure *closure = c;\n\n\tif (!is_display_descriptor((const u8 *)timing, EDID_DETAIL_EST_TIMINGS))\n\t\treturn;\n\n\tclosure->modes += drm_est3_modes(closure->connector, timing);\n}\n\n/**\n * add_established_modes - get est. modes from EDID and add them\n * @connector: connector to add mode(s) to\n * @edid: EDID block to scan\n *\n * Each EDID block contains a bitmap of the supported \"established modes\" list\n * (defined above).  Tease them out and add them to the global modes list.\n */\nstatic int\nadd_established_modes(struct drm_connector *connector, struct edid *edid)\n{\n\tstruct drm_device *dev = connector->dev;\n\tunsigned long est_bits = edid->established_timings.t1 |\n\t\t(edid->established_timings.t2 << 8) |\n\t\t((edid->established_timings.mfg_rsvd & 0x80) << 9);\n\tint i, modes = 0;\n\tstruct detailed_mode_closure closure = {\n\t\t.connector = connector,\n\t\t.edid = edid,\n\t};\n\n\tfor (i = 0; i <= EDID_EST_TIMINGS; i++) {\n\t\tif (est_bits & (1<<i)) {\n\t\t\tstruct drm_display_mode *newmode;\n\n\t\t\tnewmode = drm_mode_duplicate(dev, &edid_est_modes[i]);\n\t\t\tif (newmode) {\n\t\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t\t\tmodes++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (version_greater(edid, 1, 0))\n\t\t    drm_for_each_detailed_block((u8 *)edid,\n\t\t\t\t\t\tdo_established_modes, &closure);\n\n\treturn modes + closure.modes;\n}\n\nstatic void\ndo_standard_modes(struct detailed_timing *timing, void *c)\n{\n\tstruct detailed_mode_closure *closure = c;\n\tstruct detailed_non_pixel *data = &timing->data.other_data;\n\tstruct drm_connector *connector = closure->connector;\n\tstruct edid *edid = closure->edid;\n\tint i;\n\n\tif (!is_display_descriptor((const u8 *)timing, EDID_DETAIL_STD_MODES))\n\t\treturn;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tstruct std_timing *std = &data->data.timings[i];\n\t\tstruct drm_display_mode *newmode;\n\n\t\tnewmode = drm_mode_std(connector, edid, std);\n\t\tif (newmode) {\n\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t\tclosure->modes++;\n\t\t}\n\t}\n}\n\n/**\n * add_standard_modes - get std. modes from EDID and add them\n * @connector: connector to add mode(s) to\n * @edid: EDID block to scan\n *\n * Standard modes can be calculated using the appropriate standard (DMT,\n * GTF or CVT. Grab them from @edid and add them to the list.\n */\nstatic int\nadd_standard_modes(struct drm_connector *connector, struct edid *edid)\n{\n\tint i, modes = 0;\n\tstruct detailed_mode_closure closure = {\n\t\t.connector = connector,\n\t\t.edid = edid,\n\t};\n\n\tfor (i = 0; i < EDID_STD_TIMINGS; i++) {\n\t\tstruct drm_display_mode *newmode;\n\n\t\tnewmode = drm_mode_std(connector, edid,\n\t\t\t\t       &edid->standard_timings[i]);\n\t\tif (newmode) {\n\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t\tmodes++;\n\t\t}\n\t}\n\n\tif (version_greater(edid, 1, 0))\n\t\tdrm_for_each_detailed_block((u8 *)edid, do_standard_modes,\n\t\t\t\t\t    &closure);\n\n\t/* XXX should also look for standard codes in VTB blocks */\n\n\treturn modes + closure.modes;\n}\n\nstatic int drm_cvt_modes(struct drm_connector *connector,\n\t\t\t struct detailed_timing *timing)\n{\n\tint i, j, modes = 0;\n\tstruct drm_display_mode *newmode;\n\tstruct drm_device *dev = connector->dev;\n\tstruct cvt_timing *cvt;\n\tconst int rates[] = { 60, 85, 75, 60, 50 };\n\tconst u8 empty[3] = { 0, 0, 0 };\n\n\tfor (i = 0; i < 4; i++) {\n\t\tint width, height;\n\n\t\tcvt = &(timing->data.other_data.data.cvt[i]);\n\n\t\tif (!memcmp(cvt->code, empty, 3))\n\t\t\tcontinue;\n\n\t\theight = (cvt->code[0] + ((cvt->code[1] & 0xf0) << 4) + 1) * 2;\n\t\tswitch (cvt->code[1] & 0x0c) {\n\t\tcase 0x00:\n\t\t\twidth = height * 4 / 3;\n\t\t\tbreak;\n\t\tcase 0x04:\n\t\t\twidth = height * 16 / 9;\n\t\t\tbreak;\n\t\tcase 0x08:\n\t\t\twidth = height * 16 / 10;\n\t\t\tbreak;\n\t\tcase 0x0c:\n\t\t\twidth = height * 15 / 9;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (j = 1; j < 5; j++) {\n\t\t\tif (cvt->code[2] & (1 << j)) {\n\t\t\t\tnewmode = drm_cvt_mode(dev, width, height,\n\t\t\t\t\t\t       rates[j], j == 0,\n\t\t\t\t\t\t       false, false);\n\t\t\t\tif (newmode) {\n\t\t\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t\t\t\tmodes++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn modes;\n}\n\nstatic void\ndo_cvt_mode(struct detailed_timing *timing, void *c)\n{\n\tstruct detailed_mode_closure *closure = c;\n\n\tif (!is_display_descriptor((const u8 *)timing, EDID_DETAIL_CVT_3BYTE))\n\t\treturn;\n\n\tclosure->modes += drm_cvt_modes(closure->connector, timing);\n}\n\nstatic int\nadd_cvt_modes(struct drm_connector *connector, struct edid *edid)\n{\n\tstruct detailed_mode_closure closure = {\n\t\t.connector = connector,\n\t\t.edid = edid,\n\t};\n\n\tif (version_greater(edid, 1, 2))\n\t\tdrm_for_each_detailed_block((u8 *)edid, do_cvt_mode, &closure);\n\n\t/* XXX should also look for CVT codes in VTB blocks */\n\n\treturn closure.modes;\n}\n\nstatic void fixup_detailed_cea_mode_clock(struct drm_display_mode *mode);\n\nstatic void\ndo_detailed_mode(struct detailed_timing *timing, void *c)\n{\n\tstruct detailed_mode_closure *closure = c;\n\tstruct drm_display_mode *newmode;\n\n\tif (!is_detailed_timing_descriptor((const u8 *)timing))\n\t\treturn;\n\n\tnewmode = drm_mode_detailed(closure->connector->dev,\n\t\t\t\t    closure->edid, timing,\n\t\t\t\t    closure->quirks);\n\tif (!newmode)\n\t\treturn;\n\n\tif (closure->preferred)\n\t\tnewmode->type |= DRM_MODE_TYPE_PREFERRED;\n\n\t/*\n\t * Detailed modes are limited to 10kHz pixel clock resolution,\n\t * so fix up anything that looks like CEA/HDMI mode, but the clock\n\t * is just slightly off.\n\t */\n\tfixup_detailed_cea_mode_clock(newmode);\n\n\tdrm_mode_probed_add(closure->connector, newmode);\n\tclosure->modes++;\n\tclosure->preferred = false;\n}\n\n/*\n * add_detailed_modes - Add modes from detailed timings\n * @connector: attached connector\n * @edid: EDID block to scan\n * @quirks: quirks to apply\n */\nstatic int\nadd_detailed_modes(struct drm_connector *connector, struct edid *edid,\n\t\t   u32 quirks)\n{\n\tstruct detailed_mode_closure closure = {\n\t\t.connector = connector,\n\t\t.edid = edid,\n\t\t.preferred = true,\n\t\t.quirks = quirks,\n\t};\n\n\tif (closure.preferred && !version_greater(edid, 1, 3))\n\t\tclosure.preferred =\n\t\t    (edid->features & DRM_EDID_FEATURE_PREFERRED_TIMING);\n\n\tdrm_for_each_detailed_block((u8 *)edid, do_detailed_mode, &closure);\n\n\treturn closure.modes;\n}\n\n#define AUDIO_BLOCK\t0x01\n#define VIDEO_BLOCK     0x02\n#define VENDOR_BLOCK    0x03\n#define SPEAKER_BLOCK\t0x04\n#define HDR_STATIC_METADATA_BLOCK\t0x6\n#define USE_EXTENDED_TAG 0x07\n#define EXT_VIDEO_CAPABILITY_BLOCK 0x00\n#define EXT_VIDEO_DATA_BLOCK_420\t0x0E\n#define EXT_VIDEO_CAP_BLOCK_Y420CMDB 0x0F\n#define EDID_BASIC_AUDIO\t(1 << 6)\n#define EDID_CEA_YCRCB444\t(1 << 5)\n#define EDID_CEA_YCRCB422\t(1 << 4)\n#define EDID_CEA_VCDB_QS\t(1 << 6)\n\n/*\n * Search EDID for CEA extension block.\n */\nstatic u8 *drm_find_edid_extension(const struct edid *edid,\n\t\t\t\t   int ext_id, int *ext_index)\n{\n\tu8 *edid_ext = NULL;\n\tint i;\n\n\t/* No EDID or EDID extensions */\n\tif (edid == NULL || edid->extensions == 0)\n\t\treturn NULL;\n\n\t/* Find CEA extension */\n\tfor (i = *ext_index; i < edid->extensions; i++) {\n\t\tedid_ext = (u8 *)edid + EDID_LENGTH * (i + 1);\n\t\tif (edid_ext[0] == ext_id)\n\t\t\tbreak;\n\t}\n\n\tif (i >= edid->extensions)\n\t\treturn NULL;\n\n\t*ext_index = i + 1;\n\n\treturn edid_ext;\n}\n\n\nstatic u8 *drm_find_displayid_extension(const struct edid *edid,\n\t\t\t\t\tint *length, int *idx,\n\t\t\t\t\tint *ext_index)\n{\n\tu8 *displayid = drm_find_edid_extension(edid, DISPLAYID_EXT, ext_index);\n\tstruct displayid_hdr *base;\n\tint ret;\n\n\tif (!displayid)\n\t\treturn NULL;\n\n\t/* EDID extensions block checksum isn't for us */\n\t*length = EDID_LENGTH - 1;\n\t*idx = 1;\n\n\tret = validate_displayid(displayid, *length, *idx);\n\tif (ret)\n\t\treturn NULL;\n\n\tbase = (struct displayid_hdr *)&displayid[*idx];\n\t*length = *idx + sizeof(*base) + base->bytes;\n\n\treturn displayid;\n}\n\nstatic u8 *drm_find_cea_extension(const struct edid *edid)\n{\n\tint length, idx;\n\tstruct displayid_block *block;\n\tu8 *cea;\n\tu8 *displayid;\n\tint ext_index;\n\n\t/* Look for a top level CEA extension block */\n\t/* FIXME: make callers iterate through multiple CEA ext blocks? */\n\text_index = 0;\n\tcea = drm_find_edid_extension(edid, CEA_EXT, &ext_index);\n\tif (cea)\n\t\treturn cea;\n\n\t/* CEA blocks can also be found embedded in a DisplayID block */\n\text_index = 0;\n\tfor (;;) {\n\t\tdisplayid = drm_find_displayid_extension(edid, &length, &idx,\n\t\t\t\t\t\t\t &ext_index);\n\t\tif (!displayid)\n\t\t\treturn NULL;\n\n\t\tidx += sizeof(struct displayid_hdr);\n\t\tfor_each_displayid_db(displayid, block, idx, length) {\n\t\t\tif (block->tag == DATA_BLOCK_CTA)\n\t\t\t\treturn (u8 *)block;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic __always_inline const struct drm_display_mode *cea_mode_for_vic(u8 vic)\n{\n\tBUILD_BUG_ON(1 + ARRAY_SIZE(edid_cea_modes_1) - 1 != 127);\n\tBUILD_BUG_ON(193 + ARRAY_SIZE(edid_cea_modes_193) - 1 != 219);\n\n\tif (vic >= 1 && vic < 1 + ARRAY_SIZE(edid_cea_modes_1))\n\t\treturn &edid_cea_modes_1[vic - 1];\n\tif (vic >= 193 && vic < 193 + ARRAY_SIZE(edid_cea_modes_193))\n\t\treturn &edid_cea_modes_193[vic - 193];\n\treturn NULL;\n}\n\nstatic u8 cea_num_vics(void)\n{\n\treturn 193 + ARRAY_SIZE(edid_cea_modes_193);\n}\n\nstatic u8 cea_next_vic(u8 vic)\n{\n\tif (++vic == 1 + ARRAY_SIZE(edid_cea_modes_1))\n\t\tvic = 193;\n\treturn vic;\n}\n\n/*\n * Calculate the alternate clock for the CEA mode\n * (60Hz vs. 59.94Hz etc.)\n */\nstatic unsigned int\ncea_mode_alternate_clock(const struct drm_display_mode *cea_mode)\n{\n\tunsigned int clock = cea_mode->clock;\n\n\tif (drm_mode_vrefresh(cea_mode) % 6 != 0)\n\t\treturn clock;\n\n\t/*\n\t * edid_cea_modes contains the 59.94Hz\n\t * variant for 240 and 480 line modes,\n\t * and the 60Hz variant otherwise.\n\t */\n\tif (cea_mode->vdisplay == 240 || cea_mode->vdisplay == 480)\n\t\tclock = DIV_ROUND_CLOSEST(clock * 1001, 1000);\n\telse\n\t\tclock = DIV_ROUND_CLOSEST(clock * 1000, 1001);\n\n\treturn clock;\n}\n\nstatic bool\ncea_mode_alternate_timings(u8 vic, struct drm_display_mode *mode)\n{\n\t/*\n\t * For certain VICs the spec allows the vertical\n\t * front porch to vary by one or two lines.\n\t *\n\t * cea_modes[] stores the variant with the shortest\n\t * vertical front porch. We can adjust the mode to\n\t * get the other variants by simply increasing the\n\t * vertical front porch length.\n\t */\n\tBUILD_BUG_ON(cea_mode_for_vic(8)->vtotal != 262 ||\n\t\t     cea_mode_for_vic(9)->vtotal != 262 ||\n\t\t     cea_mode_for_vic(12)->vtotal != 262 ||\n\t\t     cea_mode_for_vic(13)->vtotal != 262 ||\n\t\t     cea_mode_for_vic(23)->vtotal != 312 ||\n\t\t     cea_mode_for_vic(24)->vtotal != 312 ||\n\t\t     cea_mode_for_vic(27)->vtotal != 312 ||\n\t\t     cea_mode_for_vic(28)->vtotal != 312);\n\n\tif (((vic == 8 || vic == 9 ||\n\t      vic == 12 || vic == 13) && mode->vtotal < 263) ||\n\t    ((vic == 23 || vic == 24 ||\n\t      vic == 27 || vic == 28) && mode->vtotal < 314)) {\n\t\tmode->vsync_start++;\n\t\tmode->vsync_end++;\n\t\tmode->vtotal++;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic u8 drm_match_cea_mode_clock_tolerance(const struct drm_display_mode *to_match,\n\t\t\t\t\t     unsigned int clock_tolerance)\n{\n\tunsigned int match_flags = DRM_MODE_MATCH_TIMINGS | DRM_MODE_MATCH_FLAGS;\n\tu8 vic;\n\n\tif (!to_match->clock)\n\t\treturn 0;\n\n\tif (to_match->picture_aspect_ratio)\n\t\tmatch_flags |= DRM_MODE_MATCH_ASPECT_RATIO;\n\n\tfor (vic = 1; vic < cea_num_vics(); vic = cea_next_vic(vic)) {\n\t\tstruct drm_display_mode cea_mode = *cea_mode_for_vic(vic);\n\t\tunsigned int clock1, clock2;\n\n\t\t/* Check both 60Hz and 59.94Hz */\n\t\tclock1 = cea_mode.clock;\n\t\tclock2 = cea_mode_alternate_clock(&cea_mode);\n\n\t\tif (abs(to_match->clock - clock1) > clock_tolerance &&\n\t\t    abs(to_match->clock - clock2) > clock_tolerance)\n\t\t\tcontinue;\n\n\t\tdo {\n\t\t\tif (drm_mode_match(to_match, &cea_mode, match_flags))\n\t\t\t\treturn vic;\n\t\t} while (cea_mode_alternate_timings(vic, &cea_mode));\n\t}\n\n\treturn 0;\n}\n\n/**\n * drm_match_cea_mode - look for a CEA mode matching given mode\n * @to_match: display mode\n *\n * Return: The CEA Video ID (VIC) of the mode or 0 if it isn't a CEA-861\n * mode.\n */\nu8 drm_match_cea_mode(const struct drm_display_mode *to_match)\n{\n\tunsigned int match_flags = DRM_MODE_MATCH_TIMINGS | DRM_MODE_MATCH_FLAGS;\n\tu8 vic;\n\n\tif (!to_match->clock)\n\t\treturn 0;\n\n\tif (to_match->picture_aspect_ratio)\n\t\tmatch_flags |= DRM_MODE_MATCH_ASPECT_RATIO;\n\n\tfor (vic = 1; vic < cea_num_vics(); vic = cea_next_vic(vic)) {\n\t\tstruct drm_display_mode cea_mode = *cea_mode_for_vic(vic);\n\t\tunsigned int clock1, clock2;\n\n\t\t/* Check both 60Hz and 59.94Hz */\n\t\tclock1 = cea_mode.clock;\n\t\tclock2 = cea_mode_alternate_clock(&cea_mode);\n\n\t\tif (KHZ2PICOS(to_match->clock) != KHZ2PICOS(clock1) &&\n\t\t    KHZ2PICOS(to_match->clock) != KHZ2PICOS(clock2))\n\t\t\tcontinue;\n\n\t\tdo {\n\t\t\tif (drm_mode_match(to_match, &cea_mode, match_flags))\n\t\t\t\treturn vic;\n\t\t} while (cea_mode_alternate_timings(vic, &cea_mode));\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_match_cea_mode);\n\nstatic bool drm_valid_cea_vic(u8 vic)\n{\n\treturn cea_mode_for_vic(vic) != NULL;\n}\n\nstatic enum hdmi_picture_aspect drm_get_cea_aspect_ratio(const u8 video_code)\n{\n\tconst struct drm_display_mode *mode = cea_mode_for_vic(video_code);\n\n\tif (mode)\n\t\treturn mode->picture_aspect_ratio;\n\n\treturn HDMI_PICTURE_ASPECT_NONE;\n}\n\nstatic enum hdmi_picture_aspect drm_get_hdmi_aspect_ratio(const u8 video_code)\n{\n\treturn edid_4k_modes[video_code].picture_aspect_ratio;\n}\n\n/*\n * Calculate the alternate clock for HDMI modes (those from the HDMI vendor\n * specific block).\n */\nstatic unsigned int\nhdmi_mode_alternate_clock(const struct drm_display_mode *hdmi_mode)\n{\n\treturn cea_mode_alternate_clock(hdmi_mode);\n}\n\nstatic u8 drm_match_hdmi_mode_clock_tolerance(const struct drm_display_mode *to_match,\n\t\t\t\t\t      unsigned int clock_tolerance)\n{\n\tunsigned int match_flags = DRM_MODE_MATCH_TIMINGS | DRM_MODE_MATCH_FLAGS;\n\tu8 vic;\n\n\tif (!to_match->clock)\n\t\treturn 0;\n\n\tif (to_match->picture_aspect_ratio)\n\t\tmatch_flags |= DRM_MODE_MATCH_ASPECT_RATIO;\n\n\tfor (vic = 1; vic < ARRAY_SIZE(edid_4k_modes); vic++) {\n\t\tconst struct drm_display_mode *hdmi_mode = &edid_4k_modes[vic];\n\t\tunsigned int clock1, clock2;\n\n\t\t/* Make sure to also match alternate clocks */\n\t\tclock1 = hdmi_mode->clock;\n\t\tclock2 = hdmi_mode_alternate_clock(hdmi_mode);\n\n\t\tif (abs(to_match->clock - clock1) > clock_tolerance &&\n\t\t    abs(to_match->clock - clock2) > clock_tolerance)\n\t\t\tcontinue;\n\n\t\tif (drm_mode_match(to_match, hdmi_mode, match_flags))\n\t\t\treturn vic;\n\t}\n\n\treturn 0;\n}\n\n/*\n * drm_match_hdmi_mode - look for a HDMI mode matching given mode\n * @to_match: display mode\n *\n * An HDMI mode is one defined in the HDMI vendor specific block.\n *\n * Returns the HDMI Video ID (VIC) of the mode or 0 if it isn't one.\n */\nstatic u8 drm_match_hdmi_mode(const struct drm_display_mode *to_match)\n{\n\tunsigned int match_flags = DRM_MODE_MATCH_TIMINGS | DRM_MODE_MATCH_FLAGS;\n\tu8 vic;\n\n\tif (!to_match->clock)\n\t\treturn 0;\n\n\tif (to_match->picture_aspect_ratio)\n\t\tmatch_flags |= DRM_MODE_MATCH_ASPECT_RATIO;\n\n\tfor (vic = 1; vic < ARRAY_SIZE(edid_4k_modes); vic++) {\n\t\tconst struct drm_display_mode *hdmi_mode = &edid_4k_modes[vic];\n\t\tunsigned int clock1, clock2;\n\n\t\t/* Make sure to also match alternate clocks */\n\t\tclock1 = hdmi_mode->clock;\n\t\tclock2 = hdmi_mode_alternate_clock(hdmi_mode);\n\n\t\tif ((KHZ2PICOS(to_match->clock) == KHZ2PICOS(clock1) ||\n\t\t     KHZ2PICOS(to_match->clock) == KHZ2PICOS(clock2)) &&\n\t\t    drm_mode_match(to_match, hdmi_mode, match_flags))\n\t\t\treturn vic;\n\t}\n\treturn 0;\n}\n\nstatic bool drm_valid_hdmi_vic(u8 vic)\n{\n\treturn vic > 0 && vic < ARRAY_SIZE(edid_4k_modes);\n}\n\nstatic int\nadd_alternate_cea_modes(struct drm_connector *connector, struct edid *edid)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_display_mode *mode, *tmp;\n\tLIST_HEAD(list);\n\tint modes = 0;\n\n\t/* Don't add CEA modes if the CEA extension block is missing */\n\tif (!drm_find_cea_extension(edid))\n\t\treturn 0;\n\n\t/*\n\t * Go through all probed modes and create a new mode\n\t * with the alternate clock for certain CEA modes.\n\t */\n\tlist_for_each_entry(mode, &connector->probed_modes, head) {\n\t\tconst struct drm_display_mode *cea_mode = NULL;\n\t\tstruct drm_display_mode *newmode;\n\t\tu8 vic = drm_match_cea_mode(mode);\n\t\tunsigned int clock1, clock2;\n\n\t\tif (drm_valid_cea_vic(vic)) {\n\t\t\tcea_mode = cea_mode_for_vic(vic);\n\t\t\tclock2 = cea_mode_alternate_clock(cea_mode);\n\t\t} else {\n\t\t\tvic = drm_match_hdmi_mode(mode);\n\t\t\tif (drm_valid_hdmi_vic(vic)) {\n\t\t\t\tcea_mode = &edid_4k_modes[vic];\n\t\t\t\tclock2 = hdmi_mode_alternate_clock(cea_mode);\n\t\t\t}\n\t\t}\n\n\t\tif (!cea_mode)\n\t\t\tcontinue;\n\n\t\tclock1 = cea_mode->clock;\n\n\t\tif (clock1 == clock2)\n\t\t\tcontinue;\n\n\t\tif (mode->clock != clock1 && mode->clock != clock2)\n\t\t\tcontinue;\n\n\t\tnewmode = drm_mode_duplicate(dev, cea_mode);\n\t\tif (!newmode)\n\t\t\tcontinue;\n\n\t\t/* Carry over the stereo flags */\n\t\tnewmode->flags |= mode->flags & DRM_MODE_FLAG_3D_MASK;\n\n\t\t/*\n\t\t * The current mode could be either variant. Make\n\t\t * sure to pick the \"other\" clock for the new mode.\n\t\t */\n\t\tif (mode->clock != clock1)\n\t\t\tnewmode->clock = clock1;\n\t\telse\n\t\t\tnewmode->clock = clock2;\n\n\t\tlist_add_tail(&newmode->head, &list);\n\t}\n\n\tlist_for_each_entry_safe(mode, tmp, &list, head) {\n\t\tlist_del(&mode->head);\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tmodes++;\n\t}\n\n\treturn modes;\n}\n\nstatic u8 svd_to_vic(u8 svd)\n{\n\t/* 0-6 bit vic, 7th bit native mode indicator */\n\tif ((svd >= 1 &&  svd <= 64) || (svd >= 129 && svd <= 192))\n\t\treturn svd & 127;\n\n\treturn svd;\n}\n\nstatic struct drm_display_mode *\ndrm_display_mode_from_vic_index(struct drm_connector *connector,\n\t\t\t\tconst u8 *video_db, u8 video_len,\n\t\t\t\tu8 video_index)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_display_mode *newmode;\n\tu8 vic;\n\n\tif (video_db == NULL || video_index >= video_len)\n\t\treturn NULL;\n\n\t/* CEA modes are numbered 1..127 */\n\tvic = svd_to_vic(video_db[video_index]);\n\tif (!drm_valid_cea_vic(vic))\n\t\treturn NULL;\n\n\tnewmode = drm_mode_duplicate(dev, cea_mode_for_vic(vic));\n\tif (!newmode)\n\t\treturn NULL;\n\n\treturn newmode;\n}\n\n/*\n * do_y420vdb_modes - Parse YCBCR 420 only modes\n * @connector: connector corresponding to the HDMI sink\n * @svds: start of the data block of CEA YCBCR 420 VDB\n * @len: length of the CEA YCBCR 420 VDB\n *\n * Parse the CEA-861-F YCBCR 420 Video Data Block (Y420VDB)\n * which contains modes which can be supported in YCBCR 420\n * output format only.\n */\nstatic int do_y420vdb_modes(struct drm_connector *connector,\n\t\t\t    const u8 *svds, u8 svds_len)\n{\n\tint modes = 0, i;\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_display_info *info = &connector->display_info;\n\tstruct drm_hdmi_info *hdmi = &info->hdmi;\n\n\tfor (i = 0; i < svds_len; i++) {\n\t\tu8 vic = svd_to_vic(svds[i]);\n\t\tstruct drm_display_mode *newmode;\n\n\t\tif (!drm_valid_cea_vic(vic))\n\t\t\tcontinue;\n\n\t\tnewmode = drm_mode_duplicate(dev, cea_mode_for_vic(vic));\n\t\tif (!newmode)\n\t\t\tbreak;\n\t\tbitmap_set(hdmi->y420_vdb_modes, vic, 1);\n\t\tdrm_mode_probed_add(connector, newmode);\n\t\tmodes++;\n\t}\n\n\tif (modes > 0)\n\t\tinfo->color_formats |= DRM_COLOR_FORMAT_YCRCB420;\n\treturn modes;\n}\n\n/*\n * drm_add_cmdb_modes - Add a YCBCR 420 mode into bitmap\n * @connector: connector corresponding to the HDMI sink\n * @vic: CEA vic for the video mode to be added in the map\n *\n * Makes an entry for a videomode in the YCBCR 420 bitmap\n */\nstatic void\ndrm_add_cmdb_modes(struct drm_connector *connector, u8 svd)\n{\n\tu8 vic = svd_to_vic(svd);\n\tstruct drm_hdmi_info *hdmi = &connector->display_info.hdmi;\n\n\tif (!drm_valid_cea_vic(vic))\n\t\treturn;\n\n\tbitmap_set(hdmi->y420_cmdb_modes, vic, 1);\n}\n\n/**\n * drm_display_mode_from_cea_vic() - return a mode for CEA VIC\n * @dev: DRM device\n * @video_code: CEA VIC of the mode\n *\n * Creates a new mode matching the specified CEA VIC.\n *\n * Returns: A new drm_display_mode on success or NULL on failure\n */\nstruct drm_display_mode *\ndrm_display_mode_from_cea_vic(struct drm_device *dev,\n\t\t\t      u8 video_code)\n{\n\tconst struct drm_display_mode *cea_mode;\n\tstruct drm_display_mode *newmode;\n\n\tcea_mode = cea_mode_for_vic(video_code);\n\tif (!cea_mode)\n\t\treturn NULL;\n\n\tnewmode = drm_mode_duplicate(dev, cea_mode);\n\tif (!newmode)\n\t\treturn NULL;\n\n\treturn newmode;\n}\nEXPORT_SYMBOL(drm_display_mode_from_cea_vic);\n\nstatic int\ndo_cea_modes(struct drm_connector *connector, const u8 *db, u8 len)\n{\n\tint i, modes = 0;\n\tstruct drm_hdmi_info *hdmi = &connector->display_info.hdmi;\n\n\tfor (i = 0; i < len; i++) {\n\t\tstruct drm_display_mode *mode;\n\n\t\tmode = drm_display_mode_from_vic_index(connector, db, len, i);\n\t\tif (mode) {\n\t\t\t/*\n\t\t\t * YCBCR420 capability block contains a bitmap which\n\t\t\t * gives the index of CEA modes from CEA VDB, which\n\t\t\t * can support YCBCR 420 sampling output also (apart\n\t\t\t * from RGB/YCBCR444 etc).\n\t\t\t * For example, if the bit 0 in bitmap is set,\n\t\t\t * first mode in VDB can support YCBCR420 output too.\n\t\t\t * Add YCBCR420 modes only if sink is HDMI 2.0 capable.\n\t\t\t */\n\t\t\tif (i < 64 && hdmi->y420_cmdb_map & (1ULL << i))\n\t\t\t\tdrm_add_cmdb_modes(connector, db[i]);\n\n\t\t\tdrm_mode_probed_add(connector, mode);\n\t\t\tmodes++;\n\t\t}\n\t}\n\n\treturn modes;\n}\n\nstruct stereo_mandatory_mode {\n\tint width, height, vrefresh;\n\tunsigned int flags;\n};\n\nstatic const struct stereo_mandatory_mode stereo_mandatory_modes[] = {\n\t{ 1920, 1080, 24, DRM_MODE_FLAG_3D_TOP_AND_BOTTOM },\n\t{ 1920, 1080, 24, DRM_MODE_FLAG_3D_FRAME_PACKING },\n\t{ 1920, 1080, 50,\n\t  DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF },\n\t{ 1920, 1080, 60,\n\t  DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF },\n\t{ 1280, 720,  50, DRM_MODE_FLAG_3D_TOP_AND_BOTTOM },\n\t{ 1280, 720,  50, DRM_MODE_FLAG_3D_FRAME_PACKING },\n\t{ 1280, 720,  60, DRM_MODE_FLAG_3D_TOP_AND_BOTTOM },\n\t{ 1280, 720,  60, DRM_MODE_FLAG_3D_FRAME_PACKING }\n};\n\nstatic bool\nstereo_match_mandatory(const struct drm_display_mode *mode,\n\t\t       const struct stereo_mandatory_mode *stereo_mode)\n{\n\tunsigned int interlaced = mode->flags & DRM_MODE_FLAG_INTERLACE;\n\n\treturn mode->hdisplay == stereo_mode->width &&\n\t       mode->vdisplay == stereo_mode->height &&\n\t       interlaced == (stereo_mode->flags & DRM_MODE_FLAG_INTERLACE) &&\n\t       drm_mode_vrefresh(mode) == stereo_mode->vrefresh;\n}\n\nstatic int add_hdmi_mandatory_stereo_modes(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tconst struct drm_display_mode *mode;\n\tstruct list_head stereo_modes;\n\tint modes = 0, i;\n\n\tINIT_LIST_HEAD(&stereo_modes);\n\n\tlist_for_each_entry(mode, &connector->probed_modes, head) {\n\t\tfor (i = 0; i < ARRAY_SIZE(stereo_mandatory_modes); i++) {\n\t\t\tconst struct stereo_mandatory_mode *mandatory;\n\t\t\tstruct drm_display_mode *new_mode;\n\n\t\t\tif (!stereo_match_mandatory(mode,\n\t\t\t\t\t\t    &stereo_mandatory_modes[i]))\n\t\t\t\tcontinue;\n\n\t\t\tmandatory = &stereo_mandatory_modes[i];\n\t\t\tnew_mode = drm_mode_duplicate(dev, mode);\n\t\t\tif (!new_mode)\n\t\t\t\tcontinue;\n\n\t\t\tnew_mode->flags |= mandatory->flags;\n\t\t\tlist_add_tail(&new_mode->head, &stereo_modes);\n\t\t\tmodes++;\n\t\t}\n\t}\n\n\tlist_splice_tail(&stereo_modes, &connector->probed_modes);\n\n\treturn modes;\n}\n\nstatic int add_hdmi_mode(struct drm_connector *connector, u8 vic)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_display_mode *newmode;\n\n\tif (!drm_valid_hdmi_vic(vic)) {\n\t\tDRM_ERROR(\"Unknown HDMI VIC: %d\\n\", vic);\n\t\treturn 0;\n\t}\n\n\tnewmode = drm_mode_duplicate(dev, &edid_4k_modes[vic]);\n\tif (!newmode)\n\t\treturn 0;\n\n\tdrm_mode_probed_add(connector, newmode);\n\n\treturn 1;\n}\n\nstatic int add_3d_struct_modes(struct drm_connector *connector, u16 structure,\n\t\t\t       const u8 *video_db, u8 video_len, u8 video_index)\n{\n\tstruct drm_display_mode *newmode;\n\tint modes = 0;\n\n\tif (structure & (1 << 0)) {\n\t\tnewmode = drm_display_mode_from_vic_index(connector, video_db,\n\t\t\t\t\t\t\t  video_len,\n\t\t\t\t\t\t\t  video_index);\n\t\tif (newmode) {\n\t\t\tnewmode->flags |= DRM_MODE_FLAG_3D_FRAME_PACKING;\n\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t\tmodes++;\n\t\t}\n\t}\n\tif (structure & (1 << 6)) {\n\t\tnewmode = drm_display_mode_from_vic_index(connector, video_db,\n\t\t\t\t\t\t\t  video_len,\n\t\t\t\t\t\t\t  video_index);\n\t\tif (newmode) {\n\t\t\tnewmode->flags |= DRM_MODE_FLAG_3D_TOP_AND_BOTTOM;\n\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t\tmodes++;\n\t\t}\n\t}\n\tif (structure & (1 << 8)) {\n\t\tnewmode = drm_display_mode_from_vic_index(connector, video_db,\n\t\t\t\t\t\t\t  video_len,\n\t\t\t\t\t\t\t  video_index);\n\t\tif (newmode) {\n\t\t\tnewmode->flags |= DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF;\n\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t\tmodes++;\n\t\t}\n\t}\n\n\treturn modes;\n}\n\n/*\n * do_hdmi_vsdb_modes - Parse the HDMI Vendor Specific data block\n * @connector: connector corresponding to the HDMI sink\n * @db: start of the CEA vendor specific block\n * @len: length of the CEA block payload, ie. one can access up to db[len]\n *\n * Parses the HDMI VSDB looking for modes to add to @connector. This function\n * also adds the stereo 3d modes when applicable.\n */\nstatic int\ndo_hdmi_vsdb_modes(struct drm_connector *connector, const u8 *db, u8 len,\n\t\t   const u8 *video_db, u8 video_len)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\tint modes = 0, offset = 0, i, multi_present = 0, multi_len;\n\tu8 vic_len, hdmi_3d_len = 0;\n\tu16 mask;\n\tu16 structure_all;\n\n\tif (len < 8)\n\t\tgoto out;\n\n\t/* no HDMI_Video_Present */\n\tif (!(db[8] & (1 << 5)))\n\t\tgoto out;\n\n\t/* Latency_Fields_Present */\n\tif (db[8] & (1 << 7))\n\t\toffset += 2;\n\n\t/* I_Latency_Fields_Present */\n\tif (db[8] & (1 << 6))\n\t\toffset += 2;\n\n\t/* the declared length is not long enough for the 2 first bytes\n\t * of additional video format capabilities */\n\tif (len < (8 + offset + 2))\n\t\tgoto out;\n\n\t/* 3D_Present */\n\toffset++;\n\tif (db[8 + offset] & (1 << 7)) {\n\t\tmodes += add_hdmi_mandatory_stereo_modes(connector);\n\n\t\t/* 3D_Multi_present */\n\t\tmulti_present = (db[8 + offset] & 0x60) >> 5;\n\t}\n\n\toffset++;\n\tvic_len = db[8 + offset] >> 5;\n\thdmi_3d_len = db[8 + offset] & 0x1f;\n\n\tfor (i = 0; i < vic_len && len >= (9 + offset + i); i++) {\n\t\tu8 vic;\n\n\t\tvic = db[9 + offset + i];\n\t\tmodes += add_hdmi_mode(connector, vic);\n\t}\n\toffset += 1 + vic_len;\n\n\tif (multi_present == 1)\n\t\tmulti_len = 2;\n\telse if (multi_present == 2)\n\t\tmulti_len = 4;\n\telse\n\t\tmulti_len = 0;\n\n\tif (len < (8 + offset + hdmi_3d_len - 1))\n\t\tgoto out;\n\n\tif (hdmi_3d_len < multi_len)\n\t\tgoto out;\n\n\tif (multi_present == 1 || multi_present == 2) {\n\t\t/* 3D_Structure_ALL */\n\t\tstructure_all = (db[8 + offset] << 8) | db[9 + offset];\n\n\t\t/* check if 3D_MASK is present */\n\t\tif (multi_present == 2)\n\t\t\tmask = (db[10 + offset] << 8) | db[11 + offset];\n\t\telse\n\t\t\tmask = 0xffff;\n\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tif (mask & (1 << i))\n\t\t\t\tmodes += add_3d_struct_modes(connector,\n\t\t\t\t\t\tstructure_all,\n\t\t\t\t\t\tvideo_db,\n\t\t\t\t\t\tvideo_len, i);\n\t\t}\n\t}\n\n\toffset += multi_len;\n\n\tfor (i = 0; i < (hdmi_3d_len - multi_len); i++) {\n\t\tint vic_index;\n\t\tstruct drm_display_mode *newmode = NULL;\n\t\tunsigned int newflag = 0;\n\t\tbool detail_present;\n\n\t\tdetail_present = ((db[8 + offset + i] & 0x0f) > 7);\n\n\t\tif (detail_present && (i + 1 == hdmi_3d_len - multi_len))\n\t\t\tbreak;\n\n\t\t/* 2D_VIC_order_X */\n\t\tvic_index = db[8 + offset + i] >> 4;\n\n\t\t/* 3D_Structure_X */\n\t\tswitch (db[8 + offset + i] & 0x0f) {\n\t\tcase 0:\n\t\t\tnewflag = DRM_MODE_FLAG_3D_FRAME_PACKING;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tnewflag = DRM_MODE_FLAG_3D_TOP_AND_BOTTOM;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\t/* 3D_Detail_X */\n\t\t\tif ((db[9 + offset + i] >> 4) == 1)\n\t\t\t\tnewflag = DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (newflag != 0) {\n\t\t\tnewmode = drm_display_mode_from_vic_index(connector,\n\t\t\t\t\t\t\t\t  video_db,\n\t\t\t\t\t\t\t\t  video_len,\n\t\t\t\t\t\t\t\t  vic_index);\n\n\t\t\tif (newmode) {\n\t\t\t\tnewmode->flags |= newflag;\n\t\t\t\tdrm_mode_probed_add(connector, newmode);\n\t\t\t\tmodes++;\n\t\t\t}\n\t\t}\n\n\t\tif (detail_present)\n\t\t\ti++;\n\t}\n\nout:\n\tif (modes > 0)\n\t\tinfo->has_hdmi_infoframe = true;\n\treturn modes;\n}\n\nstatic int\ncea_db_payload_len(const u8 *db)\n{\n\treturn db[0] & 0x1f;\n}\n\nstatic int\ncea_db_extended_tag(const u8 *db)\n{\n\treturn db[1];\n}\n\nstatic int\ncea_db_tag(const u8 *db)\n{\n\treturn db[0] >> 5;\n}\n\nstatic int\ncea_revision(const u8 *cea)\n{\n\t/*\n\t * FIXME is this correct for the DispID variant?\n\t * The DispID spec doesn't really specify whether\n\t * this is the revision of the CEA extension or\n\t * the DispID CEA data block. And the only value\n\t * given as an example is 0.\n\t */\n\treturn cea[1];\n}\n\nstatic int\ncea_db_offsets(const u8 *cea, int *start, int *end)\n{\n\t/* DisplayID CTA extension blocks and top-level CEA EDID\n\t * block header definitions differ in the following bytes:\n\t *   1) Byte 2 of the header specifies length differently,\n\t *   2) Byte 3 is only present in the CEA top level block.\n\t *\n\t * The different definitions for byte 2 follow.\n\t *\n\t * DisplayID CTA extension block defines byte 2 as:\n\t *   Number of payload bytes\n\t *\n\t * CEA EDID block defines byte 2 as:\n\t *   Byte number (decimal) within this block where the 18-byte\n\t *   DTDs begin. If no non-DTD data is present in this extension\n\t *   block, the value should be set to 04h (the byte after next).\n\t *   If set to 00h, there are no DTDs present in this block and\n\t *   no non-DTD data.\n\t */\n\tif (cea[0] == DATA_BLOCK_CTA) {\n\t\t/*\n\t\t * for_each_displayid_db() has already verified\n\t\t * that these stay within expected bounds.\n\t\t */\n\t\t*start = 3;\n\t\t*end = *start + cea[2];\n\t} else if (cea[0] == CEA_EXT) {\n\t\t/* Data block offset in CEA extension block */\n\t\t*start = 4;\n\t\t*end = cea[2];\n\t\tif (*end == 0)\n\t\t\t*end = 127;\n\t\tif (*end < 4 || *end > 127)\n\t\t\treturn -ERANGE;\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic bool cea_db_is_hdmi_vsdb(const u8 *db)\n{\n\tint hdmi_id;\n\n\tif (cea_db_tag(db) != VENDOR_BLOCK)\n\t\treturn false;\n\n\tif (cea_db_payload_len(db) < 5)\n\t\treturn false;\n\n\thdmi_id = db[1] | (db[2] << 8) | (db[3] << 16);\n\n\treturn hdmi_id == HDMI_IEEE_OUI;\n}\n\nstatic bool cea_db_is_hdmi_forum_vsdb(const u8 *db)\n{\n\tunsigned int oui;\n\n\tif (cea_db_tag(db) != VENDOR_BLOCK)\n\t\treturn false;\n\n\tif (cea_db_payload_len(db) < 7)\n\t\treturn false;\n\n\toui = db[3] << 16 | db[2] << 8 | db[1];\n\n\treturn oui == HDMI_FORUM_IEEE_OUI;\n}\n\nstatic bool cea_db_is_vcdb(const u8 *db)\n{\n\tif (cea_db_tag(db) != USE_EXTENDED_TAG)\n\t\treturn false;\n\n\tif (cea_db_payload_len(db) != 2)\n\t\treturn false;\n\n\tif (cea_db_extended_tag(db) != EXT_VIDEO_CAPABILITY_BLOCK)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool cea_db_is_y420cmdb(const u8 *db)\n{\n\tif (cea_db_tag(db) != USE_EXTENDED_TAG)\n\t\treturn false;\n\n\tif (!cea_db_payload_len(db))\n\t\treturn false;\n\n\tif (cea_db_extended_tag(db) != EXT_VIDEO_CAP_BLOCK_Y420CMDB)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool cea_db_is_y420vdb(const u8 *db)\n{\n\tif (cea_db_tag(db) != USE_EXTENDED_TAG)\n\t\treturn false;\n\n\tif (!cea_db_payload_len(db))\n\t\treturn false;\n\n\tif (cea_db_extended_tag(db) != EXT_VIDEO_DATA_BLOCK_420)\n\t\treturn false;\n\n\treturn true;\n}\n\n#define for_each_cea_db(cea, i, start, end) \\\n\tfor ((i) = (start); (i) < (end) && (i) + cea_db_payload_len(&(cea)[(i)]) < (end); (i) += cea_db_payload_len(&(cea)[(i)]) + 1)\n\nstatic void drm_parse_y420cmdb_bitmap(struct drm_connector *connector,\n\t\t\t\t      const u8 *db)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\tstruct drm_hdmi_info *hdmi = &info->hdmi;\n\tu8 map_len = cea_db_payload_len(db) - 1;\n\tu8 count;\n\tu64 map = 0;\n\n\tif (map_len == 0) {\n\t\t/* All CEA modes support ycbcr420 sampling also.*/\n\t\thdmi->y420_cmdb_map = U64_MAX;\n\t\tinfo->color_formats |= DRM_COLOR_FORMAT_YCRCB420;\n\t\treturn;\n\t}\n\n\t/*\n\t * This map indicates which of the existing CEA block modes\n\t * from VDB can support YCBCR420 output too. So if bit=0 is\n\t * set, first mode from VDB can support YCBCR420 output too.\n\t * We will parse and keep this map, before parsing VDB itself\n\t * to avoid going through the same block again and again.\n\t *\n\t * Spec is not clear about max possible size of this block.\n\t * Clamping max bitmap block size at 8 bytes. Every byte can\n\t * address 8 CEA modes, in this way this map can address\n\t * 8*8 = first 64 SVDs.\n\t */\n\tif (WARN_ON_ONCE(map_len > 8))\n\t\tmap_len = 8;\n\n\tfor (count = 0; count < map_len; count++)\n\t\tmap |= (u64)db[2 + count] << (8 * count);\n\n\tif (map)\n\t\tinfo->color_formats |= DRM_COLOR_FORMAT_YCRCB420;\n\n\thdmi->y420_cmdb_map = map;\n}\n\nstatic int\nadd_cea_modes(struct drm_connector *connector, struct edid *edid)\n{\n\tconst u8 *cea = drm_find_cea_extension(edid);\n\tconst u8 *db, *hdmi = NULL, *video = NULL;\n\tu8 dbl, hdmi_len, video_len = 0;\n\tint modes = 0;\n\n\tif (cea && cea_revision(cea) >= 3) {\n\t\tint i, start, end;\n\n\t\tif (cea_db_offsets(cea, &start, &end))\n\t\t\treturn 0;\n\n\t\tfor_each_cea_db(cea, i, start, end) {\n\t\t\tdb = &cea[i];\n\t\t\tdbl = cea_db_payload_len(db);\n\n\t\t\tif (cea_db_tag(db) == VIDEO_BLOCK) {\n\t\t\t\tvideo = db + 1;\n\t\t\t\tvideo_len = dbl;\n\t\t\t\tmodes += do_cea_modes(connector, video, dbl);\n\t\t\t} else if (cea_db_is_hdmi_vsdb(db)) {\n\t\t\t\thdmi = db;\n\t\t\t\thdmi_len = dbl;\n\t\t\t} else if (cea_db_is_y420vdb(db)) {\n\t\t\t\tconst u8 *vdb420 = &db[2];\n\n\t\t\t\t/* Add 4:2:0(only) modes present in EDID */\n\t\t\t\tmodes += do_y420vdb_modes(connector,\n\t\t\t\t\t\t\t  vdb420,\n\t\t\t\t\t\t\t  dbl - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We parse the HDMI VSDB after having added the cea modes as we will\n\t * be patching their flags when the sink supports stereo 3D.\n\t */\n\tif (hdmi)\n\t\tmodes += do_hdmi_vsdb_modes(connector, hdmi, hdmi_len, video,\n\t\t\t\t\t    video_len);\n\n\treturn modes;\n}\n\nstatic void fixup_detailed_cea_mode_clock(struct drm_display_mode *mode)\n{\n\tconst struct drm_display_mode *cea_mode;\n\tint clock1, clock2, clock;\n\tu8 vic;\n\tconst char *type;\n\n\t/*\n\t * allow 5kHz clock difference either way to account for\n\t * the 10kHz clock resolution limit of detailed timings.\n\t */\n\tvic = drm_match_cea_mode_clock_tolerance(mode, 5);\n\tif (drm_valid_cea_vic(vic)) {\n\t\ttype = \"CEA\";\n\t\tcea_mode = cea_mode_for_vic(vic);\n\t\tclock1 = cea_mode->clock;\n\t\tclock2 = cea_mode_alternate_clock(cea_mode);\n\t} else {\n\t\tvic = drm_match_hdmi_mode_clock_tolerance(mode, 5);\n\t\tif (drm_valid_hdmi_vic(vic)) {\n\t\t\ttype = \"HDMI\";\n\t\t\tcea_mode = &edid_4k_modes[vic];\n\t\t\tclock1 = cea_mode->clock;\n\t\t\tclock2 = hdmi_mode_alternate_clock(cea_mode);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* pick whichever is closest */\n\tif (abs(mode->clock - clock1) < abs(mode->clock - clock2))\n\t\tclock = clock1;\n\telse\n\t\tclock = clock2;\n\n\tif (mode->clock == clock)\n\t\treturn;\n\n\tDRM_DEBUG(\"detailed mode matches %s VIC %d, adjusting clock %d -> %d\\n\",\n\t\t  type, vic, mode->clock, clock);\n\tmode->clock = clock;\n}\n\nstatic bool cea_db_is_hdmi_hdr_metadata_block(const u8 *db)\n{\n\tif (cea_db_tag(db) != USE_EXTENDED_TAG)\n\t\treturn false;\n\n\tif (db[1] != HDR_STATIC_METADATA_BLOCK)\n\t\treturn false;\n\n\tif (cea_db_payload_len(db) < 3)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic uint8_t eotf_supported(const u8 *edid_ext)\n{\n\treturn edid_ext[2] &\n\t\t(BIT(HDMI_EOTF_TRADITIONAL_GAMMA_SDR) |\n\t\t BIT(HDMI_EOTF_TRADITIONAL_GAMMA_HDR) |\n\t\t BIT(HDMI_EOTF_SMPTE_ST2084) |\n\t\t BIT(HDMI_EOTF_BT_2100_HLG));\n}\n\nstatic uint8_t hdr_metadata_type(const u8 *edid_ext)\n{\n\treturn edid_ext[3] &\n\t\tBIT(HDMI_STATIC_METADATA_TYPE1);\n}\n\nstatic void\ndrm_parse_hdr_metadata_block(struct drm_connector *connector, const u8 *db)\n{\n\tu16 len;\n\n\tlen = cea_db_payload_len(db);\n\n\tconnector->hdr_sink_metadata.hdmi_type1.eotf =\n\t\t\t\t\t\teotf_supported(db);\n\tconnector->hdr_sink_metadata.hdmi_type1.metadata_type =\n\t\t\t\t\t\thdr_metadata_type(db);\n\n\tif (len >= 4)\n\t\tconnector->hdr_sink_metadata.hdmi_type1.max_cll = db[4];\n\tif (len >= 5)\n\t\tconnector->hdr_sink_metadata.hdmi_type1.max_fall = db[5];\n\tif (len >= 6)\n\t\tconnector->hdr_sink_metadata.hdmi_type1.min_cll = db[6];\n}\n\nstatic void\ndrm_parse_hdmi_vsdb_audio(struct drm_connector *connector, const u8 *db)\n{\n\tu8 len = cea_db_payload_len(db);\n\n\tif (len >= 6 && (db[6] & (1 << 7)))\n\t\tconnector->eld[DRM_ELD_SAD_COUNT_CONN_TYPE] |= DRM_ELD_SUPPORTS_AI;\n\tif (len >= 8) {\n\t\tconnector->latency_present[0] = db[8] >> 7;\n\t\tconnector->latency_present[1] = (db[8] >> 6) & 1;\n\t}\n\tif (len >= 9)\n\t\tconnector->video_latency[0] = db[9];\n\tif (len >= 10)\n\t\tconnector->audio_latency[0] = db[10];\n\tif (len >= 11)\n\t\tconnector->video_latency[1] = db[11];\n\tif (len >= 12)\n\t\tconnector->audio_latency[1] = db[12];\n\n\tDRM_DEBUG_KMS(\"HDMI: latency present %d %d, \"\n\t\t      \"video latency %d %d, \"\n\t\t      \"audio latency %d %d\\n\",\n\t\t      connector->latency_present[0],\n\t\t      connector->latency_present[1],\n\t\t      connector->video_latency[0],\n\t\t      connector->video_latency[1],\n\t\t      connector->audio_latency[0],\n\t\t      connector->audio_latency[1]);\n}\n\nstatic void\nmonitor_name(struct detailed_timing *t, void *data)\n{\n\tif (!is_display_descriptor((const u8 *)t, EDID_DETAIL_MONITOR_NAME))\n\t\treturn;\n\n\t*(u8 **)data = t->data.other_data.data.str.str;\n}\n\nstatic int get_monitor_name(struct edid *edid, char name[13])\n{\n\tchar *edid_name = NULL;\n\tint mnl;\n\n\tif (!edid || !name)\n\t\treturn 0;\n\n\tdrm_for_each_detailed_block((u8 *)edid, monitor_name, &edid_name);\n\tfor (mnl = 0; edid_name && mnl < 13; mnl++) {\n\t\tif (edid_name[mnl] == 0x0a)\n\t\t\tbreak;\n\n\t\tname[mnl] = edid_name[mnl];\n\t}\n\n\treturn mnl;\n}\n\n/**\n * drm_edid_get_monitor_name - fetch the monitor name from the edid\n * @edid: monitor EDID information\n * @name: pointer to a character array to hold the name of the monitor\n * @bufsize: The size of the name buffer (should be at least 14 chars.)\n *\n */\nvoid drm_edid_get_monitor_name(struct edid *edid, char *name, int bufsize)\n{\n\tint name_length;\n\tchar buf[13];\n\n\tif (bufsize <= 0)\n\t\treturn;\n\n\tname_length = min(get_monitor_name(edid, buf), bufsize - 1);\n\tmemcpy(name, buf, name_length);\n\tname[name_length] = '\\0';\n}\nEXPORT_SYMBOL(drm_edid_get_monitor_name);\n\nstatic void clear_eld(struct drm_connector *connector)\n{\n\tmemset(connector->eld, 0, sizeof(connector->eld));\n\n\tconnector->latency_present[0] = false;\n\tconnector->latency_present[1] = false;\n\tconnector->video_latency[0] = 0;\n\tconnector->audio_latency[0] = 0;\n\tconnector->video_latency[1] = 0;\n\tconnector->audio_latency[1] = 0;\n}\n\n/*\n * drm_edid_to_eld - build ELD from EDID\n * @connector: connector corresponding to the HDMI/DP sink\n * @edid: EDID to parse\n *\n * Fill the ELD (EDID-Like Data) buffer for passing to the audio driver. The\n * HDCP and Port_ID ELD fields are left for the graphics driver to fill in.\n */\nstatic void drm_edid_to_eld(struct drm_connector *connector, struct edid *edid)\n{\n\tuint8_t *eld = connector->eld;\n\tu8 *cea;\n\tu8 *db;\n\tint total_sad_count = 0;\n\tint mnl;\n\tint dbl;\n\n\tclear_eld(connector);\n\n\tif (!edid)\n\t\treturn;\n\n\tcea = drm_find_cea_extension(edid);\n\tif (!cea) {\n\t\tDRM_DEBUG_KMS(\"ELD: no CEA Extension found\\n\");\n\t\treturn;\n\t}\n\n\tmnl = get_monitor_name(edid, &eld[DRM_ELD_MONITOR_NAME_STRING]);\n\tDRM_DEBUG_KMS(\"ELD monitor %s\\n\", &eld[DRM_ELD_MONITOR_NAME_STRING]);\n\n\teld[DRM_ELD_CEA_EDID_VER_MNL] = cea[1] << DRM_ELD_CEA_EDID_VER_SHIFT;\n\teld[DRM_ELD_CEA_EDID_VER_MNL] |= mnl;\n\n\teld[DRM_ELD_VER] = DRM_ELD_VER_CEA861D;\n\n\teld[DRM_ELD_MANUFACTURER_NAME0] = edid->mfg_id[0];\n\teld[DRM_ELD_MANUFACTURER_NAME1] = edid->mfg_id[1];\n\teld[DRM_ELD_PRODUCT_CODE0] = edid->prod_code[0];\n\teld[DRM_ELD_PRODUCT_CODE1] = edid->prod_code[1];\n\n\tif (cea_revision(cea) >= 3) {\n\t\tint i, start, end;\n\t\tint sad_count;\n\n\t\tif (cea_db_offsets(cea, &start, &end)) {\n\t\t\tstart = 0;\n\t\t\tend = 0;\n\t\t}\n\n\t\tfor_each_cea_db(cea, i, start, end) {\n\t\t\tdb = &cea[i];\n\t\t\tdbl = cea_db_payload_len(db);\n\n\t\t\tswitch (cea_db_tag(db)) {\n\t\t\tcase AUDIO_BLOCK:\n\t\t\t\t/* Audio Data Block, contains SADs */\n\t\t\t\tsad_count = min(dbl / 3, 15 - total_sad_count);\n\t\t\t\tif (sad_count >= 1)\n\t\t\t\t\tmemcpy(&eld[DRM_ELD_CEA_SAD(mnl, total_sad_count)],\n\t\t\t\t\t       &db[1], sad_count * 3);\n\t\t\t\ttotal_sad_count += sad_count;\n\t\t\t\tbreak;\n\t\t\tcase SPEAKER_BLOCK:\n\t\t\t\t/* Speaker Allocation Data Block */\n\t\t\t\tif (dbl >= 1)\n\t\t\t\t\teld[DRM_ELD_SPEAKER] = db[1];\n\t\t\t\tbreak;\n\t\t\tcase VENDOR_BLOCK:\n\t\t\t\t/* HDMI Vendor-Specific Data Block */\n\t\t\t\tif (cea_db_is_hdmi_vsdb(db))\n\t\t\t\t\tdrm_parse_hdmi_vsdb_audio(connector, db);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\teld[DRM_ELD_SAD_COUNT_CONN_TYPE] |= total_sad_count << DRM_ELD_SAD_COUNT_SHIFT;\n\n\tif (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort ||\n\t    connector->connector_type == DRM_MODE_CONNECTOR_eDP)\n\t\teld[DRM_ELD_SAD_COUNT_CONN_TYPE] |= DRM_ELD_CONN_TYPE_DP;\n\telse\n\t\teld[DRM_ELD_SAD_COUNT_CONN_TYPE] |= DRM_ELD_CONN_TYPE_HDMI;\n\n\teld[DRM_ELD_BASELINE_ELD_LEN] =\n\t\tDIV_ROUND_UP(drm_eld_calc_baseline_block_size(eld), 4);\n\n\tDRM_DEBUG_KMS(\"ELD size %d, SAD count %d\\n\",\n\t\t      drm_eld_size(eld), total_sad_count);\n}\n\n/**\n * drm_edid_to_sad - extracts SADs from EDID\n * @edid: EDID to parse\n * @sads: pointer that will be set to the extracted SADs\n *\n * Looks for CEA EDID block and extracts SADs (Short Audio Descriptors) from it.\n *\n * Note: The returned pointer needs to be freed using kfree().\n *\n * Return: The number of found SADs or negative number on error.\n */\nint drm_edid_to_sad(struct edid *edid, struct cea_sad **sads)\n{\n\tint count = 0;\n\tint i, start, end, dbl;\n\tu8 *cea;\n\n\tcea = drm_find_cea_extension(edid);\n\tif (!cea) {\n\t\tDRM_DEBUG_KMS(\"SAD: no CEA Extension found\\n\");\n\t\treturn 0;\n\t}\n\n\tif (cea_revision(cea) < 3) {\n\t\tDRM_DEBUG_KMS(\"SAD: wrong CEA revision\\n\");\n\t\treturn 0;\n\t}\n\n\tif (cea_db_offsets(cea, &start, &end)) {\n\t\tDRM_DEBUG_KMS(\"SAD: invalid data block offsets\\n\");\n\t\treturn -EPROTO;\n\t}\n\n\tfor_each_cea_db(cea, i, start, end) {\n\t\tu8 *db = &cea[i];\n\n\t\tif (cea_db_tag(db) == AUDIO_BLOCK) {\n\t\t\tint j;\n\n\t\t\tdbl = cea_db_payload_len(db);\n\n\t\t\tcount = dbl / 3; /* SAD is 3B */\n\t\t\t*sads = kcalloc(count, sizeof(**sads), GFP_KERNEL);\n\t\t\tif (!*sads)\n\t\t\t\treturn -ENOMEM;\n\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\tu8 *sad = &db[1 + j * 3];\n\n\t\t\t\t(*sads)[j].format = (sad[0] & 0x78) >> 3;\n\t\t\t\t(*sads)[j].channels = sad[0] & 0x7;\n\t\t\t\t(*sads)[j].freq = sad[1] & 0x7F;\n\t\t\t\t(*sads)[j].byte2 = sad[2];\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn count;\n}\nEXPORT_SYMBOL(drm_edid_to_sad);\n\n/**\n * drm_edid_to_speaker_allocation - extracts Speaker Allocation Data Blocks from EDID\n * @edid: EDID to parse\n * @sadb: pointer to the speaker block\n *\n * Looks for CEA EDID block and extracts the Speaker Allocation Data Block from it.\n *\n * Note: The returned pointer needs to be freed using kfree().\n *\n * Return: The number of found Speaker Allocation Blocks or negative number on\n * error.\n */\nint drm_edid_to_speaker_allocation(struct edid *edid, u8 **sadb)\n{\n\tint count = 0;\n\tint i, start, end, dbl;\n\tconst u8 *cea;\n\n\tcea = drm_find_cea_extension(edid);\n\tif (!cea) {\n\t\tDRM_DEBUG_KMS(\"SAD: no CEA Extension found\\n\");\n\t\treturn 0;\n\t}\n\n\tif (cea_revision(cea) < 3) {\n\t\tDRM_DEBUG_KMS(\"SAD: wrong CEA revision\\n\");\n\t\treturn 0;\n\t}\n\n\tif (cea_db_offsets(cea, &start, &end)) {\n\t\tDRM_DEBUG_KMS(\"SAD: invalid data block offsets\\n\");\n\t\treturn -EPROTO;\n\t}\n\n\tfor_each_cea_db(cea, i, start, end) {\n\t\tconst u8 *db = &cea[i];\n\n\t\tif (cea_db_tag(db) == SPEAKER_BLOCK) {\n\t\t\tdbl = cea_db_payload_len(db);\n\n\t\t\t/* Speaker Allocation Data Block */\n\t\t\tif (dbl == 3) {\n\t\t\t\t*sadb = kmemdup(&db[1], dbl, GFP_KERNEL);\n\t\t\t\tif (!*sadb)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tcount = dbl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\nEXPORT_SYMBOL(drm_edid_to_speaker_allocation);\n\n/**\n * drm_av_sync_delay - compute the HDMI/DP sink audio-video sync delay\n * @connector: connector associated with the HDMI/DP sink\n * @mode: the display mode\n *\n * Return: The HDMI/DP sink's audio-video sync delay in milliseconds or 0 if\n * the sink doesn't support audio or video.\n */\nint drm_av_sync_delay(struct drm_connector *connector,\n\t\t      const struct drm_display_mode *mode)\n{\n\tint i = !!(mode->flags & DRM_MODE_FLAG_INTERLACE);\n\tint a, v;\n\n\tif (!connector->latency_present[0])\n\t\treturn 0;\n\tif (!connector->latency_present[1])\n\t\ti = 0;\n\n\ta = connector->audio_latency[i];\n\tv = connector->video_latency[i];\n\n\t/*\n\t * HDMI/DP sink doesn't support audio or video?\n\t */\n\tif (a == 255 || v == 255)\n\t\treturn 0;\n\n\t/*\n\t * Convert raw EDID values to millisecond.\n\t * Treat unknown latency as 0ms.\n\t */\n\tif (a)\n\t\ta = min(2 * (a - 1), 500);\n\tif (v)\n\t\tv = min(2 * (v - 1), 500);\n\n\treturn max(v - a, 0);\n}\nEXPORT_SYMBOL(drm_av_sync_delay);\n\n/**\n * drm_detect_hdmi_monitor - detect whether monitor is HDMI\n * @edid: monitor EDID information\n *\n * Parse the CEA extension according to CEA-861-B.\n *\n * Drivers that have added the modes parsed from EDID to drm_display_info\n * should use &drm_display_info.is_hdmi instead of calling this function.\n *\n * Return: True if the monitor is HDMI, false if not or unknown.\n */\nbool drm_detect_hdmi_monitor(struct edid *edid)\n{\n\tu8 *edid_ext;\n\tint i;\n\tint start_offset, end_offset;\n\n\tedid_ext = drm_find_cea_extension(edid);\n\tif (!edid_ext)\n\t\treturn false;\n\n\tif (cea_db_offsets(edid_ext, &start_offset, &end_offset))\n\t\treturn false;\n\n\t/*\n\t * Because HDMI identifier is in Vendor Specific Block,\n\t * search it from all data blocks of CEA extension.\n\t */\n\tfor_each_cea_db(edid_ext, i, start_offset, end_offset) {\n\t\tif (cea_db_is_hdmi_vsdb(&edid_ext[i]))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL(drm_detect_hdmi_monitor);\n\n/**\n * drm_detect_monitor_audio - check monitor audio capability\n * @edid: EDID block to scan\n *\n * Monitor should have CEA extension block.\n * If monitor has 'basic audio', but no CEA audio blocks, it's 'basic\n * audio' only. If there is any audio extension block and supported\n * audio format, assume at least 'basic audio' support, even if 'basic\n * audio' is not defined in EDID.\n *\n * Return: True if the monitor supports audio, false otherwise.\n */\nbool drm_detect_monitor_audio(struct edid *edid)\n{\n\tu8 *edid_ext;\n\tint i, j;\n\tbool has_audio = false;\n\tint start_offset, end_offset;\n\n\tedid_ext = drm_find_cea_extension(edid);\n\tif (!edid_ext)\n\t\tgoto end;\n\n\thas_audio = ((edid_ext[3] & EDID_BASIC_AUDIO) != 0);\n\n\tif (has_audio) {\n\t\tDRM_DEBUG_KMS(\"Monitor has basic audio support\\n\");\n\t\tgoto end;\n\t}\n\n\tif (cea_db_offsets(edid_ext, &start_offset, &end_offset))\n\t\tgoto end;\n\n\tfor_each_cea_db(edid_ext, i, start_offset, end_offset) {\n\t\tif (cea_db_tag(&edid_ext[i]) == AUDIO_BLOCK) {\n\t\t\thas_audio = true;\n\t\t\tfor (j = 1; j < cea_db_payload_len(&edid_ext[i]) + 1; j += 3)\n\t\t\t\tDRM_DEBUG_KMS(\"CEA audio format %d\\n\",\n\t\t\t\t\t      (edid_ext[i + j] >> 3) & 0xf);\n\t\t\tgoto end;\n\t\t}\n\t}\nend:\n\treturn has_audio;\n}\nEXPORT_SYMBOL(drm_detect_monitor_audio);\n\n\n/**\n * drm_default_rgb_quant_range - default RGB quantization range\n * @mode: display mode\n *\n * Determine the default RGB quantization range for the mode,\n * as specified in CEA-861.\n *\n * Return: The default RGB quantization range for the mode\n */\nenum hdmi_quantization_range\ndrm_default_rgb_quant_range(const struct drm_display_mode *mode)\n{\n\t/* All CEA modes other than VIC 1 use limited quantization range. */\n\treturn drm_match_cea_mode(mode) > 1 ?\n\t\tHDMI_QUANTIZATION_RANGE_LIMITED :\n\t\tHDMI_QUANTIZATION_RANGE_FULL;\n}\nEXPORT_SYMBOL(drm_default_rgb_quant_range);\n\nstatic void drm_parse_vcdb(struct drm_connector *connector, const u8 *db)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\n\tDRM_DEBUG_KMS(\"CEA VCDB 0x%02x\\n\", db[2]);\n\n\tif (db[2] & EDID_CEA_VCDB_QS)\n\t\tinfo->rgb_quant_range_selectable = true;\n}\n\nstatic void drm_parse_ycbcr420_deep_color_info(struct drm_connector *connector,\n\t\t\t\t\t       const u8 *db)\n{\n\tu8 dc_mask;\n\tstruct drm_hdmi_info *hdmi = &connector->display_info.hdmi;\n\n\tdc_mask = db[7] & DRM_EDID_YCBCR420_DC_MASK;\n\thdmi->y420_dc_modes = dc_mask;\n}\n\nstatic void drm_parse_hdmi_forum_vsdb(struct drm_connector *connector,\n\t\t\t\t const u8 *hf_vsdb)\n{\n\tstruct drm_display_info *display = &connector->display_info;\n\tstruct drm_hdmi_info *hdmi = &display->hdmi;\n\n\tdisplay->has_hdmi_infoframe = true;\n\n\tif (hf_vsdb[6] & 0x80) {\n\t\thdmi->scdc.supported = true;\n\t\tif (hf_vsdb[6] & 0x40)\n\t\t\thdmi->scdc.read_request = true;\n\t}\n\n\t/*\n\t * All HDMI 2.0 monitors must support scrambling at rates > 340 MHz.\n\t * And as per the spec, three factors confirm this:\n\t * * Availability of a HF-VSDB block in EDID (check)\n\t * * Non zero Max_TMDS_Char_Rate filed in HF-VSDB (let's check)\n\t * * SCDC support available (let's check)\n\t * Lets check it out.\n\t */\n\n\tif (hf_vsdb[5]) {\n\t\t/* max clock is 5000 KHz times block value */\n\t\tu32 max_tmds_clock = hf_vsdb[5] * 5000;\n\t\tstruct drm_scdc *scdc = &hdmi->scdc;\n\n\t\tif (max_tmds_clock > 340000) {\n\t\t\tdisplay->max_tmds_clock = max_tmds_clock;\n\t\t\tDRM_DEBUG_KMS(\"HF-VSDB: max TMDS clock %d kHz\\n\",\n\t\t\t\tdisplay->max_tmds_clock);\n\t\t}\n\n\t\tif (scdc->supported) {\n\t\t\tscdc->scrambling.supported = true;\n\n\t\t\t/* Few sinks support scrambling for clocks < 340M */\n\t\t\tif ((hf_vsdb[6] & 0x8))\n\t\t\t\tscdc->scrambling.low_rates = true;\n\t\t}\n\t}\n\n\tdrm_parse_ycbcr420_deep_color_info(connector, hf_vsdb);\n}\n\nstatic void drm_parse_hdmi_deep_color_info(struct drm_connector *connector,\n\t\t\t\t\t   const u8 *hdmi)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\tunsigned int dc_bpc = 0;\n\n\t/* HDMI supports at least 8 bpc */\n\tinfo->bpc = 8;\n\n\tif (cea_db_payload_len(hdmi) < 6)\n\t\treturn;\n\n\tif (hdmi[6] & DRM_EDID_HDMI_DC_30) {\n\t\tdc_bpc = 10;\n\t\tinfo->edid_hdmi_dc_modes |= DRM_EDID_HDMI_DC_30;\n\t\tDRM_DEBUG(\"%s: HDMI sink does deep color 30.\\n\",\n\t\t\t  connector->name);\n\t}\n\n\tif (hdmi[6] & DRM_EDID_HDMI_DC_36) {\n\t\tdc_bpc = 12;\n\t\tinfo->edid_hdmi_dc_modes |= DRM_EDID_HDMI_DC_36;\n\t\tDRM_DEBUG(\"%s: HDMI sink does deep color 36.\\n\",\n\t\t\t  connector->name);\n\t}\n\n\tif (hdmi[6] & DRM_EDID_HDMI_DC_48) {\n\t\tdc_bpc = 16;\n\t\tinfo->edid_hdmi_dc_modes |= DRM_EDID_HDMI_DC_48;\n\t\tDRM_DEBUG(\"%s: HDMI sink does deep color 48.\\n\",\n\t\t\t  connector->name);\n\t}\n\n\tif (dc_bpc == 0) {\n\t\tDRM_DEBUG(\"%s: No deep color support on this HDMI sink.\\n\",\n\t\t\t  connector->name);\n\t\treturn;\n\t}\n\n\tDRM_DEBUG(\"%s: Assigning HDMI sink color depth as %d bpc.\\n\",\n\t\t  connector->name, dc_bpc);\n\tinfo->bpc = dc_bpc;\n\n\t/*\n\t * Deep color support mandates RGB444 support for all video\n\t * modes and forbids YCRCB422 support for all video modes per\n\t * HDMI 1.3 spec.\n\t */\n\tinfo->color_formats = DRM_COLOR_FORMAT_RGB444;\n\n\t/* YCRCB444 is optional according to spec. */\n\tif (hdmi[6] & DRM_EDID_HDMI_DC_Y444) {\n\t\tinfo->color_formats |= DRM_COLOR_FORMAT_YCRCB444;\n\t\tDRM_DEBUG(\"%s: HDMI sink does YCRCB444 in deep color.\\n\",\n\t\t\t  connector->name);\n\t}\n\n\t/*\n\t * Spec says that if any deep color mode is supported at all,\n\t * then deep color 36 bit must be supported.\n\t */\n\tif (!(hdmi[6] & DRM_EDID_HDMI_DC_36)) {\n\t\tDRM_DEBUG(\"%s: HDMI sink should do DC_36, but does not!\\n\",\n\t\t\t  connector->name);\n\t}\n}\n\nstatic void\ndrm_parse_hdmi_vsdb_video(struct drm_connector *connector, const u8 *db)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\tu8 len = cea_db_payload_len(db);\n\n\tinfo->is_hdmi = true;\n\n\tif (len >= 6)\n\t\tinfo->dvi_dual = db[6] & 1;\n\tif (len >= 7)\n\t\tinfo->max_tmds_clock = db[7] * 5000;\n\n\tDRM_DEBUG_KMS(\"HDMI: DVI dual %d, \"\n\t\t      \"max TMDS clock %d kHz\\n\",\n\t\t      info->dvi_dual,\n\t\t      info->max_tmds_clock);\n\n\tdrm_parse_hdmi_deep_color_info(connector, db);\n}\n\nstatic void drm_parse_cea_ext(struct drm_connector *connector,\n\t\t\t      const struct edid *edid)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\tconst u8 *edid_ext;\n\tint i, start, end;\n\n\tedid_ext = drm_find_cea_extension(edid);\n\tif (!edid_ext)\n\t\treturn;\n\n\tinfo->cea_rev = edid_ext[1];\n\n\t/* The existence of a CEA block should imply RGB support */\n\tinfo->color_formats = DRM_COLOR_FORMAT_RGB444;\n\tif (edid_ext[3] & EDID_CEA_YCRCB444)\n\t\tinfo->color_formats |= DRM_COLOR_FORMAT_YCRCB444;\n\tif (edid_ext[3] & EDID_CEA_YCRCB422)\n\t\tinfo->color_formats |= DRM_COLOR_FORMAT_YCRCB422;\n\n\tif (cea_db_offsets(edid_ext, &start, &end))\n\t\treturn;\n\n\tfor_each_cea_db(edid_ext, i, start, end) {\n\t\tconst u8 *db = &edid_ext[i];\n\n\t\tif (cea_db_is_hdmi_vsdb(db))\n\t\t\tdrm_parse_hdmi_vsdb_video(connector, db);\n\t\tif (cea_db_is_hdmi_forum_vsdb(db))\n\t\t\tdrm_parse_hdmi_forum_vsdb(connector, db);\n\t\tif (cea_db_is_y420cmdb(db))\n\t\t\tdrm_parse_y420cmdb_bitmap(connector, db);\n\t\tif (cea_db_is_vcdb(db))\n\t\t\tdrm_parse_vcdb(connector, db);\n\t\tif (cea_db_is_hdmi_hdr_metadata_block(db))\n\t\t\tdrm_parse_hdr_metadata_block(connector, db);\n\t}\n}\n\nstatic\nvoid get_monitor_range(struct detailed_timing *timing,\n\t\t       void *info_monitor_range)\n{\n\tstruct drm_monitor_range_info *monitor_range = info_monitor_range;\n\tconst struct detailed_non_pixel *data = &timing->data.other_data;\n\tconst struct detailed_data_monitor_range *range = &data->data.range;\n\n\tif (!is_display_descriptor((const u8 *)timing, EDID_DETAIL_MONITOR_RANGE))\n\t\treturn;\n\n\t/*\n\t * Check for flag range limits only. If flag == 1 then\n\t * no additional timing information provided.\n\t * Default GTF, GTF Secondary curve and CVT are not\n\t * supported\n\t */\n\tif (range->flags != DRM_EDID_RANGE_LIMITS_ONLY_FLAG)\n\t\treturn;\n\n\tmonitor_range->min_vfreq = range->min_vfreq;\n\tmonitor_range->max_vfreq = range->max_vfreq;\n}\n\nstatic\nvoid drm_get_monitor_range(struct drm_connector *connector,\n\t\t\t   const struct edid *edid)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\n\tif (!version_greater(edid, 1, 1))\n\t\treturn;\n\n\tdrm_for_each_detailed_block((u8 *)edid, get_monitor_range,\n\t\t\t\t    &info->monitor_range);\n\n\tDRM_DEBUG_KMS(\"Supported Monitor Refresh rate range is %d Hz - %d Hz\\n\",\n\t\t      info->monitor_range.min_vfreq,\n\t\t      info->monitor_range.max_vfreq);\n}\n\n/* A connector has no EDID information, so we've got no EDID to compute quirks from. Reset\n * all of the values which would have been set from EDID\n */\nvoid\ndrm_reset_display_info(struct drm_connector *connector)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\n\tinfo->width_mm = 0;\n\tinfo->height_mm = 0;\n\n\tinfo->bpc = 0;\n\tinfo->color_formats = 0;\n\tinfo->cea_rev = 0;\n\tinfo->max_tmds_clock = 0;\n\tinfo->dvi_dual = false;\n\tinfo->is_hdmi = false;\n\tinfo->has_hdmi_infoframe = false;\n\tinfo->rgb_quant_range_selectable = false;\n\tmemset(&info->hdmi, 0, sizeof(info->hdmi));\n\n\tinfo->non_desktop = 0;\n\tmemset(&info->monitor_range, 0, sizeof(info->monitor_range));\n}\n\nu32 drm_add_display_info(struct drm_connector *connector, const struct edid *edid)\n{\n\tstruct drm_display_info *info = &connector->display_info;\n\n\tu32 quirks = edid_get_quirks(edid);\n\n\tdrm_reset_display_info(connector);\n\n\tinfo->width_mm = edid->width_cm * 10;\n\tinfo->height_mm = edid->height_cm * 10;\n\n\tinfo->non_desktop = !!(quirks & EDID_QUIRK_NON_DESKTOP);\n\n\tdrm_get_monitor_range(connector, edid);\n\n\tDRM_DEBUG_KMS(\"non_desktop set to %d\\n\", info->non_desktop);\n\n\tif (edid->revision < 3)\n\t\treturn quirks;\n\n\tif (!(edid->input & DRM_EDID_INPUT_DIGITAL))\n\t\treturn quirks;\n\n\tdrm_parse_cea_ext(connector, edid);\n\n\t/*\n\t * Digital sink with \"DFP 1.x compliant TMDS\" according to EDID 1.3?\n\t *\n\t * For such displays, the DFP spec 1.0, section 3.10 \"EDID support\"\n\t * tells us to assume 8 bpc color depth if the EDID doesn't have\n\t * extensions which tell otherwise.\n\t */\n\tif (info->bpc == 0 && edid->revision == 3 &&\n\t    edid->input & DRM_EDID_DIGITAL_DFP_1_X) {\n\t\tinfo->bpc = 8;\n\t\tDRM_DEBUG(\"%s: Assigning DFP sink color depth as %d bpc.\\n\",\n\t\t\t  connector->name, info->bpc);\n\t}\n\n\t/* Only defined for 1.4 with digital displays */\n\tif (edid->revision < 4)\n\t\treturn quirks;\n\n\tswitch (edid->input & DRM_EDID_DIGITAL_DEPTH_MASK) {\n\tcase DRM_EDID_DIGITAL_DEPTH_6:\n\t\tinfo->bpc = 6;\n\t\tbreak;\n\tcase DRM_EDID_DIGITAL_DEPTH_8:\n\t\tinfo->bpc = 8;\n\t\tbreak;\n\tcase DRM_EDID_DIGITAL_DEPTH_10:\n\t\tinfo->bpc = 10;\n\t\tbreak;\n\tcase DRM_EDID_DIGITAL_DEPTH_12:\n\t\tinfo->bpc = 12;\n\t\tbreak;\n\tcase DRM_EDID_DIGITAL_DEPTH_14:\n\t\tinfo->bpc = 14;\n\t\tbreak;\n\tcase DRM_EDID_DIGITAL_DEPTH_16:\n\t\tinfo->bpc = 16;\n\t\tbreak;\n\tcase DRM_EDID_DIGITAL_DEPTH_UNDEF:\n\tdefault:\n\t\tinfo->bpc = 0;\n\t\tbreak;\n\t}\n\n\tDRM_DEBUG(\"%s: Assigning EDID-1.4 digital sink color depth as %d bpc.\\n\",\n\t\t\t  connector->name, info->bpc);\n\n\tinfo->color_formats |= DRM_COLOR_FORMAT_RGB444;\n\tif (edid->features & DRM_EDID_FEATURE_RGB_YCRCB444)\n\t\tinfo->color_formats |= DRM_COLOR_FORMAT_YCRCB444;\n\tif (edid->features & DRM_EDID_FEATURE_RGB_YCRCB422)\n\t\tinfo->color_formats |= DRM_COLOR_FORMAT_YCRCB422;\n\treturn quirks;\n}\n\nstatic int validate_displayid(u8 *displayid, int length, int idx)\n{\n\tint i, dispid_length;\n\tu8 csum = 0;\n\tstruct displayid_hdr *base;\n\n\tbase = (struct displayid_hdr *)&displayid[idx];\n\n\tDRM_DEBUG_KMS(\"base revision 0x%x, length %d, %d %d\\n\",\n\t\t      base->rev, base->bytes, base->prod_id, base->ext_count);\n\n\t/* +1 for DispID checksum */\n\tdispid_length = sizeof(*base) + base->bytes + 1;\n\tif (dispid_length > length - idx)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < dispid_length; i++)\n\t\tcsum += displayid[idx + i];\n\tif (csum) {\n\t\tDRM_NOTE(\"DisplayID checksum invalid, remainder is %d\\n\", csum);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct drm_display_mode *drm_mode_displayid_detailed(struct drm_device *dev,\n\t\t\t\t\t\t\t    struct displayid_detailed_timings_1 *timings)\n{\n\tstruct drm_display_mode *mode;\n\tunsigned pixel_clock = (timings->pixel_clock[0] |\n\t\t\t\t(timings->pixel_clock[1] << 8) |\n\t\t\t\t(timings->pixel_clock[2] << 16)) + 1;\n\tunsigned hactive = (timings->hactive[0] | timings->hactive[1] << 8) + 1;\n\tunsigned hblank = (timings->hblank[0] | timings->hblank[1] << 8) + 1;\n\tunsigned hsync = (timings->hsync[0] | (timings->hsync[1] & 0x7f) << 8) + 1;\n\tunsigned hsync_width = (timings->hsw[0] | timings->hsw[1] << 8) + 1;\n\tunsigned vactive = (timings->vactive[0] | timings->vactive[1] << 8) + 1;\n\tunsigned vblank = (timings->vblank[0] | timings->vblank[1] << 8) + 1;\n\tunsigned vsync = (timings->vsync[0] | (timings->vsync[1] & 0x7f) << 8) + 1;\n\tunsigned vsync_width = (timings->vsw[0] | timings->vsw[1] << 8) + 1;\n\tbool hsync_positive = (timings->hsync[1] >> 7) & 0x1;\n\tbool vsync_positive = (timings->vsync[1] >> 7) & 0x1;\n\n\tmode = drm_mode_create(dev);\n\tif (!mode)\n\t\treturn NULL;\n\n\tmode->clock = pixel_clock * 10;\n\tmode->hdisplay = hactive;\n\tmode->hsync_start = mode->hdisplay + hsync;\n\tmode->hsync_end = mode->hsync_start + hsync_width;\n\tmode->htotal = mode->hdisplay + hblank;\n\n\tmode->vdisplay = vactive;\n\tmode->vsync_start = mode->vdisplay + vsync;\n\tmode->vsync_end = mode->vsync_start + vsync_width;\n\tmode->vtotal = mode->vdisplay + vblank;\n\n\tmode->flags = 0;\n\tmode->flags |= hsync_positive ? DRM_MODE_FLAG_PHSYNC : DRM_MODE_FLAG_NHSYNC;\n\tmode->flags |= vsync_positive ? DRM_MODE_FLAG_PVSYNC : DRM_MODE_FLAG_NVSYNC;\n\tmode->type = DRM_MODE_TYPE_DRIVER;\n\n\tif (timings->flags & 0x80)\n\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\tdrm_mode_set_name(mode);\n\n\treturn mode;\n}\n\nstatic int add_displayid_detailed_1_modes(struct drm_connector *connector,\n\t\t\t\t\t  struct displayid_block *block)\n{\n\tstruct displayid_detailed_timing_block *det = (struct displayid_detailed_timing_block *)block;\n\tint i;\n\tint num_timings;\n\tstruct drm_display_mode *newmode;\n\tint num_modes = 0;\n\t/* blocks must be multiple of 20 bytes length */\n\tif (block->num_bytes % 20)\n\t\treturn 0;\n\n\tnum_timings = block->num_bytes / 20;\n\tfor (i = 0; i < num_timings; i++) {\n\t\tstruct displayid_detailed_timings_1 *timings = &det->timings[i];\n\n\t\tnewmode = drm_mode_displayid_detailed(connector->dev, timings);\n\t\tif (!newmode)\n\t\t\tcontinue;\n\n\t\tdrm_mode_probed_add(connector, newmode);\n\t\tnum_modes++;\n\t}\n\treturn num_modes;\n}\n\nstatic int add_displayid_detailed_modes(struct drm_connector *connector,\n\t\t\t\t\tstruct edid *edid)\n{\n\tu8 *displayid;\n\tint length, idx;\n\tstruct displayid_block *block;\n\tint num_modes = 0;\n\tint ext_index = 0;\n\n\tfor (;;) {\n\t\tdisplayid = drm_find_displayid_extension(edid, &length, &idx,\n\t\t\t\t\t\t\t &ext_index);\n\t\tif (!displayid)\n\t\t\tbreak;\n\n\t\tidx += sizeof(struct displayid_hdr);\n\t\tfor_each_displayid_db(displayid, block, idx, length) {\n\t\t\tswitch (block->tag) {\n\t\t\tcase DATA_BLOCK_TYPE_1_DETAILED_TIMING:\n\t\t\t\tnum_modes += add_displayid_detailed_1_modes(connector, block);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn num_modes;\n}\n\n/**\n * drm_add_edid_modes - add modes from EDID data, if available\n * @connector: connector we're probing\n * @edid: EDID data\n *\n * Add the specified modes to the connector's mode list. Also fills out the\n * &drm_display_info structure and ELD in @connector with any information which\n * can be derived from the edid.\n *\n * Return: The number of modes added or 0 if we couldn't find any.\n */\nint drm_add_edid_modes(struct drm_connector *connector, struct edid *edid)\n{\n\tint num_modes = 0;\n\tu32 quirks;\n\n\tif (edid == NULL) {\n\t\tclear_eld(connector);\n\t\treturn 0;\n\t}\n\tif (!drm_edid_is_valid(edid)) {\n\t\tclear_eld(connector);\n\t\tdrm_warn(connector->dev, \"%s: EDID invalid.\\n\",\n\t\t\t connector->name);\n\t\treturn 0;\n\t}\n\n\tdrm_edid_to_eld(connector, edid);\n\n\t/*\n\t * CEA-861-F adds ycbcr capability map block, for HDMI 2.0 sinks.\n\t * To avoid multiple parsing of same block, lets parse that map\n\t * from sink info, before parsing CEA modes.\n\t */\n\tquirks = drm_add_display_info(connector, edid);\n\n\t/*\n\t * EDID spec says modes should be preferred in this order:\n\t * - preferred detailed mode\n\t * - other detailed modes from base block\n\t * - detailed modes from extension blocks\n\t * - CVT 3-byte code modes\n\t * - standard timing codes\n\t * - established timing codes\n\t * - modes inferred from GTF or CVT range information\n\t *\n\t * We get this pretty much right.\n\t *\n\t * XXX order for additional mode types in extension blocks?\n\t */\n\tnum_modes += add_detailed_modes(connector, edid, quirks);\n\tnum_modes += add_cvt_modes(connector, edid);\n\tnum_modes += add_standard_modes(connector, edid);\n\tnum_modes += add_established_modes(connector, edid);\n\tnum_modes += add_cea_modes(connector, edid);\n\tnum_modes += add_alternate_cea_modes(connector, edid);\n\tnum_modes += add_displayid_detailed_modes(connector, edid);\n\tif (edid->features & DRM_EDID_FEATURE_DEFAULT_GTF)\n\t\tnum_modes += add_inferred_modes(connector, edid);\n\n\tif (quirks & (EDID_QUIRK_PREFER_LARGE_60 | EDID_QUIRK_PREFER_LARGE_75))\n\t\tedid_fixup_preferred(connector, quirks);\n\n\tif (quirks & EDID_QUIRK_FORCE_6BPC)\n\t\tconnector->display_info.bpc = 6;\n\n\tif (quirks & EDID_QUIRK_FORCE_8BPC)\n\t\tconnector->display_info.bpc = 8;\n\n\tif (quirks & EDID_QUIRK_FORCE_10BPC)\n\t\tconnector->display_info.bpc = 10;\n\n\tif (quirks & EDID_QUIRK_FORCE_12BPC)\n\t\tconnector->display_info.bpc = 12;\n\n\treturn num_modes;\n}\nEXPORT_SYMBOL(drm_add_edid_modes);\n\n/**\n * drm_add_modes_noedid - add modes for the connectors without EDID\n * @connector: connector we're probing\n * @hdisplay: the horizontal display limit\n * @vdisplay: the vertical display limit\n *\n * Add the specified modes to the connector's mode list. Only when the\n * hdisplay/vdisplay is not beyond the given limit, it will be added.\n *\n * Return: The number of modes added or 0 if we couldn't find any.\n */\nint drm_add_modes_noedid(struct drm_connector *connector,\n\t\t\tint hdisplay, int vdisplay)\n{\n\tint i, count, num_modes = 0;\n\tstruct drm_display_mode *mode;\n\tstruct drm_device *dev = connector->dev;\n\n\tcount = ARRAY_SIZE(drm_dmt_modes);\n\tif (hdisplay < 0)\n\t\thdisplay = 0;\n\tif (vdisplay < 0)\n\t\tvdisplay = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tconst struct drm_display_mode *ptr = &drm_dmt_modes[i];\n\n\t\tif (hdisplay && vdisplay) {\n\t\t\t/*\n\t\t\t * Only when two are valid, they will be used to check\n\t\t\t * whether the mode should be added to the mode list of\n\t\t\t * the connector.\n\t\t\t */\n\t\t\tif (ptr->hdisplay > hdisplay ||\n\t\t\t\t\tptr->vdisplay > vdisplay)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (drm_mode_vrefresh(ptr) > 61)\n\t\t\tcontinue;\n\t\tmode = drm_mode_duplicate(dev, ptr);\n\t\tif (mode) {\n\t\t\tdrm_mode_probed_add(connector, mode);\n\t\t\tnum_modes++;\n\t\t}\n\t}\n\treturn num_modes;\n}\nEXPORT_SYMBOL(drm_add_modes_noedid);\n\n/**\n * drm_set_preferred_mode - Sets the preferred mode of a connector\n * @connector: connector whose mode list should be processed\n * @hpref: horizontal resolution of preferred mode\n * @vpref: vertical resolution of preferred mode\n *\n * Marks a mode as preferred if it matches the resolution specified by @hpref\n * and @vpref.\n */\nvoid drm_set_preferred_mode(struct drm_connector *connector,\n\t\t\t   int hpref, int vpref)\n{\n\tstruct drm_display_mode *mode;\n\n\tlist_for_each_entry(mode, &connector->probed_modes, head) {\n\t\tif (mode->hdisplay == hpref &&\n\t\t    mode->vdisplay == vpref)\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\t}\n}\nEXPORT_SYMBOL(drm_set_preferred_mode);\n\nstatic bool is_hdmi2_sink(const struct drm_connector *connector)\n{\n\t/*\n\t * FIXME: sil-sii8620 doesn't have a connector around when\n\t * we need one, so we have to be prepared for a NULL connector.\n\t */\n\tif (!connector)\n\t\treturn true;\n\n\treturn connector->display_info.hdmi.scdc.supported ||\n\t\tconnector->display_info.color_formats & DRM_COLOR_FORMAT_YCRCB420;\n}\n\nstatic inline bool is_eotf_supported(u8 output_eotf, u8 sink_eotf)\n{\n\treturn sink_eotf & BIT(output_eotf);\n}\n\n/**\n * drm_hdmi_infoframe_set_hdr_metadata() - fill an HDMI DRM infoframe with\n *                                         HDR metadata from userspace\n * @frame: HDMI DRM infoframe\n * @conn_state: Connector state containing HDR metadata\n *\n * Return: 0 on success or a negative error code on failure.\n */\nint\ndrm_hdmi_infoframe_set_hdr_metadata(struct hdmi_drm_infoframe *frame,\n\t\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tstruct drm_connector *connector;\n\tstruct hdr_output_metadata *hdr_metadata;\n\tint err;\n\n\tif (!frame || !conn_state)\n\t\treturn -EINVAL;\n\n\tconnector = conn_state->connector;\n\n\tif (!conn_state->hdr_output_metadata)\n\t\treturn -EINVAL;\n\n\thdr_metadata = conn_state->hdr_output_metadata->data;\n\n\tif (!hdr_metadata || !connector)\n\t\treturn -EINVAL;\n\n\t/* Sink EOTF is Bit map while infoframe is absolute values */\n\tif (!is_eotf_supported(hdr_metadata->hdmi_metadata_type1.eotf,\n\t    connector->hdr_sink_metadata.hdmi_type1.eotf)) {\n\t\tDRM_DEBUG_KMS(\"EOTF Not Supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = hdmi_drm_infoframe_init(frame);\n\tif (err < 0)\n\t\treturn err;\n\n\tframe->eotf = hdr_metadata->hdmi_metadata_type1.eotf;\n\tframe->metadata_type = hdr_metadata->hdmi_metadata_type1.metadata_type;\n\n\tBUILD_BUG_ON(sizeof(frame->display_primaries) !=\n\t\t     sizeof(hdr_metadata->hdmi_metadata_type1.display_primaries));\n\tBUILD_BUG_ON(sizeof(frame->white_point) !=\n\t\t     sizeof(hdr_metadata->hdmi_metadata_type1.white_point));\n\n\tmemcpy(&frame->display_primaries,\n\t       &hdr_metadata->hdmi_metadata_type1.display_primaries,\n\t       sizeof(frame->display_primaries));\n\n\tmemcpy(&frame->white_point,\n\t       &hdr_metadata->hdmi_metadata_type1.white_point,\n\t       sizeof(frame->white_point));\n\n\tframe->max_display_mastering_luminance =\n\t\thdr_metadata->hdmi_metadata_type1.max_display_mastering_luminance;\n\tframe->min_display_mastering_luminance =\n\t\thdr_metadata->hdmi_metadata_type1.min_display_mastering_luminance;\n\tframe->max_fall = hdr_metadata->hdmi_metadata_type1.max_fall;\n\tframe->max_cll = hdr_metadata->hdmi_metadata_type1.max_cll;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_hdmi_infoframe_set_hdr_metadata);\n\nstatic u8 drm_mode_hdmi_vic(const struct drm_connector *connector,\n\t\t\t    const struct drm_display_mode *mode)\n{\n\tbool has_hdmi_infoframe = connector ?\n\t\tconnector->display_info.has_hdmi_infoframe : false;\n\n\tif (!has_hdmi_infoframe)\n\t\treturn 0;\n\n\t/* No HDMI VIC when signalling 3D video format */\n\tif (mode->flags & DRM_MODE_FLAG_3D_MASK)\n\t\treturn 0;\n\n\treturn drm_match_hdmi_mode(mode);\n}\n\nstatic u8 drm_mode_cea_vic(const struct drm_connector *connector,\n\t\t\t   const struct drm_display_mode *mode)\n{\n\tu8 vic;\n\n\t/*\n\t * HDMI spec says if a mode is found in HDMI 1.4b 4K modes\n\t * we should send its VIC in vendor infoframes, else send the\n\t * VIC in AVI infoframes. Lets check if this mode is present in\n\t * HDMI 1.4b 4K modes\n\t */\n\tif (drm_mode_hdmi_vic(connector, mode))\n\t\treturn 0;\n\n\tvic = drm_match_cea_mode(mode);\n\n\t/*\n\t * HDMI 1.4 VIC range: 1 <= VIC <= 64 (CEA-861-D) but\n\t * HDMI 2.0 VIC range: 1 <= VIC <= 107 (CEA-861-F). So we\n\t * have to make sure we dont break HDMI 1.4 sinks.\n\t */\n\tif (!is_hdmi2_sink(connector) && vic > 64)\n\t\treturn 0;\n\n\treturn vic;\n}\n\n/**\n * drm_hdmi_avi_infoframe_from_display_mode() - fill an HDMI AVI infoframe with\n *                                              data from a DRM display mode\n * @frame: HDMI AVI infoframe\n * @connector: the connector\n * @mode: DRM display mode\n *\n * Return: 0 on success or a negative error code on failure.\n */\nint\ndrm_hdmi_avi_infoframe_from_display_mode(struct hdmi_avi_infoframe *frame,\n\t\t\t\t\t const struct drm_connector *connector,\n\t\t\t\t\t const struct drm_display_mode *mode)\n{\n\tenum hdmi_picture_aspect picture_aspect;\n\tu8 vic, hdmi_vic;\n\n\tif (!frame || !mode)\n\t\treturn -EINVAL;\n\n\thdmi_avi_infoframe_init(frame);\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)\n\t\tframe->pixel_repeat = 1;\n\n\tvic = drm_mode_cea_vic(connector, mode);\n\thdmi_vic = drm_mode_hdmi_vic(connector, mode);\n\n\tframe->picture_aspect = HDMI_PICTURE_ASPECT_NONE;\n\n\t/*\n\t * As some drivers don't support atomic, we can't use connector state.\n\t * So just initialize the frame with default values, just the same way\n\t * as it's done with other properties here.\n\t */\n\tframe->content_type = HDMI_CONTENT_TYPE_GRAPHICS;\n\tframe->itc = 0;\n\n\t/*\n\t * Populate picture aspect ratio from either\n\t * user input (if specified) or from the CEA/HDMI mode lists.\n\t */\n\tpicture_aspect = mode->picture_aspect_ratio;\n\tif (picture_aspect == HDMI_PICTURE_ASPECT_NONE) {\n\t\tif (vic)\n\t\t\tpicture_aspect = drm_get_cea_aspect_ratio(vic);\n\t\telse if (hdmi_vic)\n\t\t\tpicture_aspect = drm_get_hdmi_aspect_ratio(hdmi_vic);\n\t}\n\n\t/*\n\t * The infoframe can't convey anything but none, 4:3\n\t * and 16:9, so if the user has asked for anything else\n\t * we can only satisfy it by specifying the right VIC.\n\t */\n\tif (picture_aspect > HDMI_PICTURE_ASPECT_16_9) {\n\t\tif (vic) {\n\t\t\tif (picture_aspect != drm_get_cea_aspect_ratio(vic))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (hdmi_vic) {\n\t\t\tif (picture_aspect != drm_get_hdmi_aspect_ratio(hdmi_vic))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpicture_aspect = HDMI_PICTURE_ASPECT_NONE;\n\t}\n\n\tframe->video_code = vic;\n\tframe->picture_aspect = picture_aspect;\n\tframe->active_aspect = HDMI_ACTIVE_ASPECT_PICTURE;\n\tframe->scan_mode = HDMI_SCAN_MODE_UNDERSCAN;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_hdmi_avi_infoframe_from_display_mode);\n\n/* HDMI Colorspace Spec Definitions */\n#define FULL_COLORIMETRY_MASK\t\t0x1FF\n#define NORMAL_COLORIMETRY_MASK\t\t0x3\n#define EXTENDED_COLORIMETRY_MASK\t0x7\n#define EXTENDED_ACE_COLORIMETRY_MASK\t0xF\n\n#define C(x) ((x) << 0)\n#define EC(x) ((x) << 2)\n#define ACE(x) ((x) << 5)\n\n#define HDMI_COLORIMETRY_NO_DATA\t\t0x0\n#define HDMI_COLORIMETRY_SMPTE_170M_YCC\t\t(C(1) | EC(0) | ACE(0))\n#define HDMI_COLORIMETRY_BT709_YCC\t\t(C(2) | EC(0) | ACE(0))\n#define HDMI_COLORIMETRY_XVYCC_601\t\t(C(3) | EC(0) | ACE(0))\n#define HDMI_COLORIMETRY_XVYCC_709\t\t(C(3) | EC(1) | ACE(0))\n#define HDMI_COLORIMETRY_SYCC_601\t\t(C(3) | EC(2) | ACE(0))\n#define HDMI_COLORIMETRY_OPYCC_601\t\t(C(3) | EC(3) | ACE(0))\n#define HDMI_COLORIMETRY_OPRGB\t\t\t(C(3) | EC(4) | ACE(0))\n#define HDMI_COLORIMETRY_BT2020_CYCC\t\t(C(3) | EC(5) | ACE(0))\n#define HDMI_COLORIMETRY_BT2020_RGB\t\t(C(3) | EC(6) | ACE(0))\n#define HDMI_COLORIMETRY_BT2020_YCC\t\t(C(3) | EC(6) | ACE(0))\n#define HDMI_COLORIMETRY_DCI_P3_RGB_D65\t\t(C(3) | EC(7) | ACE(0))\n#define HDMI_COLORIMETRY_DCI_P3_RGB_THEATER\t(C(3) | EC(7) | ACE(1))\n\nstatic const u32 hdmi_colorimetry_val[] = {\n\t[DRM_MODE_COLORIMETRY_NO_DATA] = HDMI_COLORIMETRY_NO_DATA,\n\t[DRM_MODE_COLORIMETRY_SMPTE_170M_YCC] = HDMI_COLORIMETRY_SMPTE_170M_YCC,\n\t[DRM_MODE_COLORIMETRY_BT709_YCC] = HDMI_COLORIMETRY_BT709_YCC,\n\t[DRM_MODE_COLORIMETRY_XVYCC_601] = HDMI_COLORIMETRY_XVYCC_601,\n\t[DRM_MODE_COLORIMETRY_XVYCC_709] = HDMI_COLORIMETRY_XVYCC_709,\n\t[DRM_MODE_COLORIMETRY_SYCC_601] = HDMI_COLORIMETRY_SYCC_601,\n\t[DRM_MODE_COLORIMETRY_OPYCC_601] = HDMI_COLORIMETRY_OPYCC_601,\n\t[DRM_MODE_COLORIMETRY_OPRGB] = HDMI_COLORIMETRY_OPRGB,\n\t[DRM_MODE_COLORIMETRY_BT2020_CYCC] = HDMI_COLORIMETRY_BT2020_CYCC,\n\t[DRM_MODE_COLORIMETRY_BT2020_RGB] = HDMI_COLORIMETRY_BT2020_RGB,\n\t[DRM_MODE_COLORIMETRY_BT2020_YCC] = HDMI_COLORIMETRY_BT2020_YCC,\n};\n\n#undef C\n#undef EC\n#undef ACE\n\n/**\n * drm_hdmi_avi_infoframe_colorspace() - fill the HDMI AVI infoframe\n *                                       colorspace information\n * @frame: HDMI AVI infoframe\n * @conn_state: connector state\n */\nvoid\ndrm_hdmi_avi_infoframe_colorspace(struct hdmi_avi_infoframe *frame,\n\t\t\t\t  const struct drm_connector_state *conn_state)\n{\n\tu32 colorimetry_val;\n\tu32 colorimetry_index = conn_state->colorspace & FULL_COLORIMETRY_MASK;\n\n\tif (colorimetry_index >= ARRAY_SIZE(hdmi_colorimetry_val))\n\t\tcolorimetry_val = HDMI_COLORIMETRY_NO_DATA;\n\telse\n\t\tcolorimetry_val = hdmi_colorimetry_val[colorimetry_index];\n\n\tframe->colorimetry = colorimetry_val & NORMAL_COLORIMETRY_MASK;\n\t/*\n\t * ToDo: Extend it for ACE formats as well. Modify the infoframe\n\t * structure and extend it in drivers/video/hdmi\n\t */\n\tframe->extended_colorimetry = (colorimetry_val >> 2) &\n\t\t\t\t\tEXTENDED_COLORIMETRY_MASK;\n}\nEXPORT_SYMBOL(drm_hdmi_avi_infoframe_colorspace);\n\n/**\n * drm_hdmi_avi_infoframe_quant_range() - fill the HDMI AVI infoframe\n *                                        quantization range information\n * @frame: HDMI AVI infoframe\n * @connector: the connector\n * @mode: DRM display mode\n * @rgb_quant_range: RGB quantization range (Q)\n */\nvoid\ndrm_hdmi_avi_infoframe_quant_range(struct hdmi_avi_infoframe *frame,\n\t\t\t\t   const struct drm_connector *connector,\n\t\t\t\t   const struct drm_display_mode *mode,\n\t\t\t\t   enum hdmi_quantization_range rgb_quant_range)\n{\n\tconst struct drm_display_info *info = &connector->display_info;\n\n\t/*\n\t * CEA-861:\n\t * \"A Source shall not send a non-zero Q value that does not correspond\n\t *  to the default RGB Quantization Range for the transmitted Picture\n\t *  unless the Sink indicates support for the Q bit in a Video\n\t *  Capabilities Data Block.\"\n\t *\n\t * HDMI 2.0 recommends sending non-zero Q when it does match the\n\t * default RGB quantization range for the mode, even when QS=0.\n\t */\n\tif (info->rgb_quant_range_selectable ||\n\t    rgb_quant_range == drm_default_rgb_quant_range(mode))\n\t\tframe->quantization_range = rgb_quant_range;\n\telse\n\t\tframe->quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;\n\n\t/*\n\t * CEA-861-F:\n\t * \"When transmitting any RGB colorimetry, the Source should set the\n\t *  YQ-field to match the RGB Quantization Range being transmitted\n\t *  (e.g., when Limited Range RGB, set YQ=0 or when Full Range RGB,\n\t *  set YQ=1) and the Sink shall ignore the YQ-field.\"\n\t *\n\t * Unfortunate certain sinks (eg. VIZ Model 67/E261VA) get confused\n\t * by non-zero YQ when receiving RGB. There doesn't seem to be any\n\t * good way to tell which version of CEA-861 the sink supports, so\n\t * we limit non-zero YQ to HDMI 2.0 sinks only as HDMI 2.0 is based\n\t * on on CEA-861-F.\n\t */\n\tif (!is_hdmi2_sink(connector) ||\n\t    rgb_quant_range == HDMI_QUANTIZATION_RANGE_LIMITED)\n\t\tframe->ycc_quantization_range =\n\t\t\tHDMI_YCC_QUANTIZATION_RANGE_LIMITED;\n\telse\n\t\tframe->ycc_quantization_range =\n\t\t\tHDMI_YCC_QUANTIZATION_RANGE_FULL;\n}\nEXPORT_SYMBOL(drm_hdmi_avi_infoframe_quant_range);\n\n/**\n * drm_hdmi_avi_infoframe_bars() - fill the HDMI AVI infoframe\n *                                 bar information\n * @frame: HDMI AVI infoframe\n * @conn_state: connector state\n */\nvoid\ndrm_hdmi_avi_infoframe_bars(struct hdmi_avi_infoframe *frame,\n\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tframe->right_bar = conn_state->tv.margins.right;\n\tframe->left_bar = conn_state->tv.margins.left;\n\tframe->top_bar = conn_state->tv.margins.top;\n\tframe->bottom_bar = conn_state->tv.margins.bottom;\n}\nEXPORT_SYMBOL(drm_hdmi_avi_infoframe_bars);\n\nstatic enum hdmi_3d_structure\ns3d_structure_from_display_mode(const struct drm_display_mode *mode)\n{\n\tu32 layout = mode->flags & DRM_MODE_FLAG_3D_MASK;\n\n\tswitch (layout) {\n\tcase DRM_MODE_FLAG_3D_FRAME_PACKING:\n\t\treturn HDMI_3D_STRUCTURE_FRAME_PACKING;\n\tcase DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE:\n\t\treturn HDMI_3D_STRUCTURE_FIELD_ALTERNATIVE;\n\tcase DRM_MODE_FLAG_3D_LINE_ALTERNATIVE:\n\t\treturn HDMI_3D_STRUCTURE_LINE_ALTERNATIVE;\n\tcase DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL:\n\t\treturn HDMI_3D_STRUCTURE_SIDE_BY_SIDE_FULL;\n\tcase DRM_MODE_FLAG_3D_L_DEPTH:\n\t\treturn HDMI_3D_STRUCTURE_L_DEPTH;\n\tcase DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH:\n\t\treturn HDMI_3D_STRUCTURE_L_DEPTH_GFX_GFX_DEPTH;\n\tcase DRM_MODE_FLAG_3D_TOP_AND_BOTTOM:\n\t\treturn HDMI_3D_STRUCTURE_TOP_AND_BOTTOM;\n\tcase DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF:\n\t\treturn HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF;\n\tdefault:\n\t\treturn HDMI_3D_STRUCTURE_INVALID;\n\t}\n}\n\n/**\n * drm_hdmi_vendor_infoframe_from_display_mode() - fill an HDMI infoframe with\n * data from a DRM display mode\n * @frame: HDMI vendor infoframe\n * @connector: the connector\n * @mode: DRM display mode\n *\n * Note that there's is a need to send HDMI vendor infoframes only when using a\n * 4k or stereoscopic 3D mode. So when giving any other mode as input this\n * function will return -EINVAL, error that can be safely ignored.\n *\n * Return: 0 on success or a negative error code on failure.\n */\nint\ndrm_hdmi_vendor_infoframe_from_display_mode(struct hdmi_vendor_infoframe *frame,\n\t\t\t\t\t    const struct drm_connector *connector,\n\t\t\t\t\t    const struct drm_display_mode *mode)\n{\n\t/*\n\t * FIXME: sil-sii8620 doesn't have a connector around when\n\t * we need one, so we have to be prepared for a NULL connector.\n\t */\n\tbool has_hdmi_infoframe = connector ?\n\t\tconnector->display_info.has_hdmi_infoframe : false;\n\tint err;\n\n\tif (!frame || !mode)\n\t\treturn -EINVAL;\n\n\tif (!has_hdmi_infoframe)\n\t\treturn -EINVAL;\n\n\terr = hdmi_vendor_infoframe_init(frame);\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * Even if it's not absolutely necessary to send the infoframe\n\t * (ie.vic==0 and s3d_struct==0) we will still send it if we\n\t * know that the sink can handle it. This is based on a\n\t * suggestion in HDMI 2.0 Appendix F. Apparently some sinks\n\t * have trouble realizing that they shuld switch from 3D to 2D\n\t * mode if the source simply stops sending the infoframe when\n\t * it wants to switch from 3D to 2D.\n\t */\n\tframe->vic = drm_mode_hdmi_vic(connector, mode);\n\tframe->s3d_struct = s3d_structure_from_display_mode(mode);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_hdmi_vendor_infoframe_from_display_mode);\n\nstatic void drm_parse_tiled_block(struct drm_connector *connector,\n\t\t\t\t  const struct displayid_block *block)\n{\n\tconst struct displayid_tiled_block *tile = (struct displayid_tiled_block *)block;\n\tu16 w, h;\n\tu8 tile_v_loc, tile_h_loc;\n\tu8 num_v_tile, num_h_tile;\n\tstruct drm_tile_group *tg;\n\n\tw = tile->tile_size[0] | tile->tile_size[1] << 8;\n\th = tile->tile_size[2] | tile->tile_size[3] << 8;\n\n\tnum_v_tile = (tile->topo[0] & 0xf) | (tile->topo[2] & 0x30);\n\tnum_h_tile = (tile->topo[0] >> 4) | ((tile->topo[2] >> 2) & 0x30);\n\ttile_v_loc = (tile->topo[1] & 0xf) | ((tile->topo[2] & 0x3) << 4);\n\ttile_h_loc = (tile->topo[1] >> 4) | (((tile->topo[2] >> 2) & 0x3) << 4);\n\n\tconnector->has_tile = true;\n\tif (tile->tile_cap & 0x80)\n\t\tconnector->tile_is_single_monitor = true;\n\n\tconnector->num_h_tile = num_h_tile + 1;\n\tconnector->num_v_tile = num_v_tile + 1;\n\tconnector->tile_h_loc = tile_h_loc;\n\tconnector->tile_v_loc = tile_v_loc;\n\tconnector->tile_h_size = w + 1;\n\tconnector->tile_v_size = h + 1;\n\n\tDRM_DEBUG_KMS(\"tile cap 0x%x\\n\", tile->tile_cap);\n\tDRM_DEBUG_KMS(\"tile_size %d x %d\\n\", w + 1, h + 1);\n\tDRM_DEBUG_KMS(\"topo num tiles %dx%d, location %dx%d\\n\",\n\t\t      num_h_tile + 1, num_v_tile + 1, tile_h_loc, tile_v_loc);\n\tDRM_DEBUG_KMS(\"vend %c%c%c\\n\", tile->topology_id[0], tile->topology_id[1], tile->topology_id[2]);\n\n\ttg = drm_mode_get_tile_group(connector->dev, tile->topology_id);\n\tif (!tg)\n\t\ttg = drm_mode_create_tile_group(connector->dev, tile->topology_id);\n\tif (!tg)\n\t\treturn;\n\n\tif (connector->tile_group != tg) {\n\t\t/* if we haven't got a pointer,\n\t\t   take the reference, drop ref to old tile group */\n\t\tif (connector->tile_group)\n\t\t\tdrm_mode_put_tile_group(connector->dev, connector->tile_group);\n\t\tconnector->tile_group = tg;\n\t} else {\n\t\t/* if same tile group, then release the ref we just took. */\n\t\tdrm_mode_put_tile_group(connector->dev, tg);\n\t}\n}\n\nstatic void drm_displayid_parse_tiled(struct drm_connector *connector,\n\t\t\t\t      const u8 *displayid, int length, int idx)\n{\n\tconst struct displayid_block *block;\n\n\tidx += sizeof(struct displayid_hdr);\n\tfor_each_displayid_db(displayid, block, idx, length) {\n\t\tDRM_DEBUG_KMS(\"block id 0x%x, rev %d, len %d\\n\",\n\t\t\t      block->tag, block->rev, block->num_bytes);\n\n\t\tswitch (block->tag) {\n\t\tcase DATA_BLOCK_TILED_DISPLAY:\n\t\t\tdrm_parse_tiled_block(connector, block);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_DEBUG_KMS(\"found DisplayID tag 0x%x, unhandled\\n\", block->tag);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid drm_update_tile_info(struct drm_connector *connector,\n\t\t\t  const struct edid *edid)\n{\n\tconst void *displayid = NULL;\n\tint ext_index = 0;\n\tint length, idx;\n\n\tconnector->has_tile = false;\n\tfor (;;) {\n\t\tdisplayid = drm_find_displayid_extension(edid, &length, &idx,\n\t\t\t\t\t\t\t &ext_index);\n\t\tif (!displayid)\n\t\t\tbreak;\n\n\t\tdrm_displayid_parse_tiled(connector, displayid, length, idx);\n\t}\n\n\tif (!connector->has_tile && connector->tile_group) {\n\t\tdrm_mode_put_tile_group(connector->dev, connector->tile_group);\n\t\tconnector->tile_group = NULL;\n\t}\n}\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 1636}, "message": "error: we previously assumed 'edid2' could be null (see line 1629)"}], "macros": [], "notes": [], "path": "/src/drivers/gpu/drm/drm_edid.c", "reportHash": "4505f471677d74a1ed06314060ded34b", "checkerName": "check_check_deref", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3121}, "message": "error: uninitialized symbol 'width'."}], "macros": [], "notes": [], "path": "/src/drivers/gpu/drm/drm_edid.c", "reportHash": "ea4a066d67ee39386d04e1d08b5f04da", "checkerName": "check_uninitialized", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
