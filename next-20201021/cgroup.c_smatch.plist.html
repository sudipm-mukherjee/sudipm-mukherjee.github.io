<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/kernel/cgroup/cgroup.c", "content": "/*\n *  Generic process-grouping system.\n *\n *  Based originally on the cpuset system, extracted by Paul Menage\n *  Copyright (C) 2006 Google, Inc\n *\n *  Notifications support\n *  Copyright (C) 2009 Nokia Corporation\n *  Author: Kirill A. Shutemov\n *\n *  Copyright notices from the original cpuset code:\n *  --------------------------------------------------\n *  Copyright (C) 2003 BULL SA.\n *  Copyright (C) 2004-2006 Silicon Graphics, Inc.\n *\n *  Portions derived from Patrick Mochel's sysfs code.\n *  sysfs is Copyright (c) 2001-3 Patrick Mochel\n *\n *  2003-10-10 Written by Simon Derr.\n *  2003-10-22 Updates by Stephen Hemminger.\n *  2004 May-July Rework by Paul Jackson.\n *  ---------------------------------------------------\n *\n *  This file is subject to the terms and conditions of the GNU General Public\n *  License.  See the file COPYING in the main directory of the Linux\n *  distribution for more details.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"cgroup-internal.h\"\n\n#include <linux/cred.h>\n#include <linux/errno.h>\n#include <linux/init_task.h>\n#include <linux/kernel.h>\n#include <linux/magic.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/proc_fs.h>\n#include <linux/rcupdate.h>\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/string.h>\n#include <linux/hashtable.h>\n#include <linux/idr.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpuset.h>\n#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/file.h>\n#include <linux/fs_parser.h>\n#include <linux/sched/cputime.h>\n#include <linux/psi.h>\n#include <net/sock.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/cgroup.h>\n\n#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)\n/* let's not notify more than 100 times per second */\n#define CGROUP_FILE_NOTIFY_MIN_INTV\tDIV_ROUND_UP(HZ, 100)\n\n/*\n * cgroup_mutex is the master lock.  Any modification to cgroup or its\n * hierarchy must be performed while holding it.\n *\n * css_set_lock protects task->cgroups pointer, the list of css_set\n * objects, and the chain of tasks off each css_set.\n *\n * These locks are exported if CONFIG_PROVE_RCU so that accessors in\n * cgroup.h can use them for lockdep annotations.\n */\nDEFINE_MUTEX(cgroup_mutex);\nDEFINE_SPINLOCK(css_set_lock);\n\n#ifdef CONFIG_PROVE_RCU\nEXPORT_SYMBOL_GPL(cgroup_mutex);\nEXPORT_SYMBOL_GPL(css_set_lock);\n#endif\n\nDEFINE_SPINLOCK(trace_cgroup_path_lock);\nchar trace_cgroup_path[TRACE_CGROUP_PATH_LEN];\nbool cgroup_debug __read_mostly;\n\n/*\n * Protects cgroup_idr and css_idr so that IDs can be released without\n * grabbing cgroup_mutex.\n */\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\n/*\n * Protects cgroup_file->kn for !self csses.  It synchronizes notifications\n * against file removal/re-creation across css hiding.\n */\nstatic DEFINE_SPINLOCK(cgroup_file_kn_lock);\n\nDEFINE_PERCPU_RWSEM(cgroup_threadgroup_rwsem);\n\n#define cgroup_assert_mutex_or_rcu_locked()\t\t\t\t\\\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held() &&\t\t\t\\\n\t\t\t   !lockdep_is_held(&cgroup_mutex),\t\t\\\n\t\t\t   \"cgroup_mutex or RCU read lock required\");\n\n/*\n * cgroup destruction makes heavy use of work items and there can be a lot\n * of concurrent destructions.  Use a separate workqueue so that cgroup\n * destruction work items don't end up filling up max_active of system_wq\n * which may lead to deadlock.\n */\nstatic struct workqueue_struct *cgroup_destroy_wq;\n\n/* generate an array of cgroup subsystem pointers */\n#define SUBSYS(_x) [_x ## _cgrp_id] = &_x ## _cgrp_subsys,\nstruct cgroup_subsys *cgroup_subsys[] = {\n#include <linux/cgroup_subsys.h>\n};\n#undef SUBSYS\n\n/* array of cgroup subsystem names */\n#define SUBSYS(_x) [_x ## _cgrp_id] = #_x,\nstatic const char *cgroup_subsys_name[] = {\n#include <linux/cgroup_subsys.h>\n};\n#undef SUBSYS\n\n/* array of static_keys for cgroup_subsys_enabled() and cgroup_subsys_on_dfl() */\n#define SUBSYS(_x)\t\t\t\t\t\t\t\t\\\n\tDEFINE_STATIC_KEY_TRUE(_x ## _cgrp_subsys_enabled_key);\t\t\t\\\n\tDEFINE_STATIC_KEY_TRUE(_x ## _cgrp_subsys_on_dfl_key);\t\t\t\\\n\tEXPORT_SYMBOL_GPL(_x ## _cgrp_subsys_enabled_key);\t\t\t\\\n\tEXPORT_SYMBOL_GPL(_x ## _cgrp_subsys_on_dfl_key);\n#include <linux/cgroup_subsys.h>\n#undef SUBSYS\n\n#define SUBSYS(_x) [_x ## _cgrp_id] = &_x ## _cgrp_subsys_enabled_key,\nstatic struct static_key_true *cgroup_subsys_enabled_key[] = {\n#include <linux/cgroup_subsys.h>\n};\n#undef SUBSYS\n\n#define SUBSYS(_x) [_x ## _cgrp_id] = &_x ## _cgrp_subsys_on_dfl_key,\nstatic struct static_key_true *cgroup_subsys_on_dfl_key[] = {\n#include <linux/cgroup_subsys.h>\n};\n#undef SUBSYS\n\nstatic DEFINE_PER_CPU(struct cgroup_rstat_cpu, cgrp_dfl_root_rstat_cpu);\n\n/* the default hierarchy */\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nEXPORT_SYMBOL_GPL(cgrp_dfl_root);\n\n/*\n * The default hierarchy always exists but is hidden until mounted for the\n * first time.  This is for backward compatibility.\n */\nstatic bool cgrp_dfl_visible;\n\n/* some controllers are not supported in the default hierarchy */\nstatic u16 cgrp_dfl_inhibit_ss_mask;\n\n/* some controllers are implicitly enabled on the default hierarchy */\nstatic u16 cgrp_dfl_implicit_ss_mask;\n\n/* some controllers can be threaded on the default hierarchy */\nstatic u16 cgrp_dfl_threaded_ss_mask;\n\n/* The list of hierarchy roots */\nLIST_HEAD(cgroup_roots);\nstatic int cgroup_root_count;\n\n/* hierarchy ID allocation and mapping, protected by cgroup_mutex */\nstatic DEFINE_IDR(cgroup_hierarchy_idr);\n\n/*\n * Assign a monotonically increasing serial number to csses.  It guarantees\n * cgroups with bigger numbers are newer than those with smaller numbers.\n * Also, as csses are always appended to the parent's ->children list, it\n * guarantees that sibling csses are always sorted in the ascending serial\n * number order on the list.  Protected by cgroup_mutex.\n */\nstatic u64 css_serial_nr_next = 1;\n\n/*\n * These bitmasks identify subsystems with specific features to avoid\n * having to do iterative checks repeatedly.\n */\nstatic u16 have_fork_callback __read_mostly;\nstatic u16 have_exit_callback __read_mostly;\nstatic u16 have_release_callback __read_mostly;\nstatic u16 have_canfork_callback __read_mostly;\n\n/* cgroup namespace for init task */\nstruct cgroup_namespace init_cgroup_ns = {\n\t.ns.count\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};\n\nstatic struct file_system_type cgroup2_fs_type;\nstatic struct cftype cgroup_base_files[];\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void css_release(struct percpu_ref *ref);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\n\n/**\n * cgroup_ssid_enabled - cgroup subsys enabled test by subsys ID\n * @ssid: subsys ID of interest\n *\n * cgroup_subsys_enabled() can only be used with literal subsys names which\n * is fine for individual subsystems but unsuitable for cgroup core.  This\n * is slower static_key_enabled() based test indexed by @ssid.\n */\nbool cgroup_ssid_enabled(int ssid)\n{\n\tif (CGROUP_SUBSYS_COUNT == 0)\n\t\treturn false;\n\n\treturn static_key_enabled(cgroup_subsys_enabled_key[ssid]);\n}\n\n/**\n * cgroup_on_dfl - test whether a cgroup is on the default hierarchy\n * @cgrp: the cgroup of interest\n *\n * The default hierarchy is the v2 interface of cgroup and this function\n * can be used to test whether a cgroup is on the default hierarchy for\n * cases where a subsystem should behave differnetly depending on the\n * interface version.\n *\n * List of changed behaviors:\n *\n * - Mount options \"noprefix\", \"xattr\", \"clone_children\", \"release_agent\"\n *   and \"name\" are disallowed.\n *\n * - When mounting an existing superblock, mount options should match.\n *\n * - Remount is disallowed.\n *\n * - rename(2) is disallowed.\n *\n * - \"tasks\" is removed.  Everything should be at process granularity.  Use\n *   \"cgroup.procs\" instead.\n *\n * - \"cgroup.procs\" is not sorted.  pids will be unique unless they got\n *   recycled inbetween reads.\n *\n * - \"release_agent\" and \"notify_on_release\" are removed.  Replacement\n *   notification mechanism will be implemented.\n *\n * - \"cgroup.clone_children\" is removed.\n *\n * - \"cgroup.subtree_populated\" is available.  Its value is 0 if the cgroup\n *   and its descendants contain no task; otherwise, 1.  The file also\n *   generates kernfs notification which can be monitored through poll and\n *   [di]notify when the value of the file changes.\n *\n * - cpuset: tasks will be kept in empty cpusets when hotplug happens and\n *   take masks of ancestors with non-empty cpus/mems, instead of being\n *   moved to an ancestor.\n *\n * - cpuset: a task can be moved into an empty cpuset, and again it takes\n *   masks of ancestors.\n *\n * - memcg: use_hierarchy is on by default and the cgroup file for the flag\n *   is not created.\n *\n * - blkcg: blk-throttle becomes properly hierarchical.\n *\n * - debug: disallowed on the default hierarchy.\n */\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}\n\n/* IDR wrappers which synchronize using cgroup_idr_lock */\nstatic int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}\n\nstatic void *cgroup_idr_replace(struct idr *idr, void *ptr, int id)\n{\n\tvoid *ret;\n\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_replace(idr, ptr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\treturn ret;\n}\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}\n\nstatic bool cgroup_has_tasks(struct cgroup *cgrp)\n{\n\treturn cgrp->nr_populated_csets;\n}\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}\n\n/* can @cgrp host both domain and threaded children? */\nstatic bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}\n\n/* can @cgrp become a thread root? should always be true for a thread root */\nstatic bool cgroup_can_be_thread_root(struct cgroup *cgrp)\n{\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn true;\n\n\t/* domain roots can't be nested under threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* can only have either domain or threaded children */\n\tif (cgrp->nr_populated_domain_children)\n\t\treturn false;\n\n\t/* and no domain controllers can be enabled */\n\tif (cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn false;\n\n\treturn true;\n}\n\n/* is @cgrp root of a threaded subtree? */\nbool cgroup_is_thread_root(struct cgroup *cgrp)\n{\n\t/* thread root should be a domain */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* a domain w/ threaded children is a thread root */\n\tif (cgrp->nr_threaded_children)\n\t\treturn true;\n\n\t/*\n\t * A domain which has tasks and explicit threaded controllers\n\t * enabled is a thread root.\n\t */\n\tif (cgroup_has_tasks(cgrp) &&\n\t    (cgrp->subtree_control & cgrp_dfl_threaded_ss_mask))\n\t\treturn true;\n\n\treturn false;\n}\n\n/* a domain which isn't connected to the root w/o brekage can't be used */\nstatic bool cgroup_is_valid_domain(struct cgroup *cgrp)\n{\n\t/* the cgroup itself can be a thread root */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* but the ancestors can't be unless mixable */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (!cgroup_is_mixable(cgrp) && cgroup_is_thread_root(cgrp))\n\t\t\treturn false;\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/* subsystems visibly enabled on a cgroup */\nstatic u16 cgroup_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tu16 root_ss_mask = cgrp->root->subsys_mask;\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_control;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\tif (cgroup_on_dfl(cgrp))\n\t\troot_ss_mask &= ~(cgrp_dfl_inhibit_ss_mask |\n\t\t\t\t  cgrp_dfl_implicit_ss_mask);\n\treturn root_ss_mask;\n}\n\n/* subsystems enabled on a cgroup */\nstatic u16 cgroup_ss_mask(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_ss_mask;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\treturn cgrp->root->subsys_mask;\n}\n\n/**\n * cgroup_css - obtain a cgroup's css for the specified subsystem\n * @cgrp: the cgroup of interest\n * @ss: the subsystem of interest (%NULL returns @cgrp->self)\n *\n * Return @cgrp's css (cgroup_subsys_state) associated with @ss.  This\n * function must be called either under cgroup_mutex or rcu_read_lock() and\n * the caller is responsible for pinning the returned css if it wants to\n * keep accessing it outside the said locks.  This function may return\n * %NULL if @cgrp doesn't have @subsys_id enabled.\n */\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}\n\n/**\n * cgroup_tryget_css - try to get a cgroup's css for the specified subsystem\n * @cgrp: the cgroup of interest\n * @ss: the subsystem of interest\n *\n * Find and get @cgrp's css assocaited with @ss.  If the css doesn't exist\n * or is offline, %NULL is returned.\n */\nstatic struct cgroup_subsys_state *cgroup_tryget_css(struct cgroup *cgrp,\n\t\t\t\t\t\t     struct cgroup_subsys *ss)\n{\n\tstruct cgroup_subsys_state *css;\n\n\trcu_read_lock();\n\tcss = cgroup_css(cgrp, ss);\n\tif (css && !css_tryget_online(css))\n\t\tcss = NULL;\n\trcu_read_unlock();\n\n\treturn css;\n}\n\n/**\n * cgroup_e_css_by_mask - obtain a cgroup's effective css for the specified ss\n * @cgrp: the cgroup of interest\n * @ss: the subsystem of interest (%NULL returns @cgrp->self)\n *\n * Similar to cgroup_css() but returns the effective css, which is defined\n * as the matching css of the nearest ancestor including self which has @ss\n * enabled.  If @ss is associated with the hierarchy @cgrp is on, this\n * function is guaranteed to return non-NULL css.\n */\nstatic struct cgroup_subsys_state *cgroup_e_css_by_mask(struct cgroup *cgrp,\n\t\t\t\t\t\t\tstruct cgroup_subsys *ss)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!ss)\n\t\treturn &cgrp->self;\n\n\t/*\n\t * This function is used while updating css associations and thus\n\t * can't test the csses directly.  Test ss_mask.\n\t */\n\twhile (!(cgroup_ss_mask(cgrp) & (1 << ss->id))) {\n\t\tcgrp = cgroup_parent(cgrp);\n\t\tif (!cgrp)\n\t\t\treturn NULL;\n\t}\n\n\treturn cgroup_css(cgrp, ss);\n}\n\n/**\n * cgroup_e_css - obtain a cgroup's effective css for the specified subsystem\n * @cgrp: the cgroup of interest\n * @ss: the subsystem of interest\n *\n * Find and get the effective css of @cgrp for @ss.  The effective css is\n * defined as the matching css of the nearest ancestor including self which\n * has @ss enabled.  If @ss is not mounted on the hierarchy @cgrp is on,\n * the root css is returned, so this function always returns a valid css.\n *\n * The returned css is not guaranteed to be online, and therefore it is the\n * callers responsiblity to tryget a reference for it.\n */\nstruct cgroup_subsys_state *cgroup_e_css(struct cgroup *cgrp,\n\t\t\t\t\t struct cgroup_subsys *ss)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tdo {\n\t\tcss = cgroup_css(cgrp, ss);\n\n\t\tif (css)\n\t\t\treturn css;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n\n\treturn init_css_set.subsys[ss->id];\n}\n\n/**\n * cgroup_get_e_css - get a cgroup's effective css for the specified subsystem\n * @cgrp: the cgroup of interest\n * @ss: the subsystem of interest\n *\n * Find and get the effective css of @cgrp for @ss.  The effective css is\n * defined as the matching css of the nearest ancestor including self which\n * has @ss enabled.  If @ss is not mounted on the hierarchy @cgrp is on,\n * the root css is returned, so this function always returns a valid css.\n * The returned css must be put using css_put().\n */\nstruct cgroup_subsys_state *cgroup_get_e_css(struct cgroup *cgrp,\n\t\t\t\t\t     struct cgroup_subsys *ss)\n{\n\tstruct cgroup_subsys_state *css;\n\n\trcu_read_lock();\n\n\tdo {\n\t\tcss = cgroup_css(cgrp, ss);\n\n\t\tif (css && css_tryget_online(css))\n\t\t\tgoto out_unlock;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n\n\tcss = init_css_set.subsys[ss->id];\n\tcss_get(css);\nout_unlock:\n\trcu_read_unlock();\n\treturn css;\n}\n\nstatic void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}\n\n/**\n * __cgroup_task_count - count the number of tasks in a cgroup. The caller\n * is responsible for taking the css_set_lock.\n * @cgrp: the cgroup in question\n */\nint __cgroup_task_count(const struct cgroup *cgrp)\n{\n\tint count = 0;\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tcount += link->cset->nr_tasks;\n\n\treturn count;\n}\n\n/**\n * cgroup_task_count - count the number of tasks in a cgroup.\n * @cgrp: the cgroup in question\n */\nint cgroup_task_count(const struct cgroup *cgrp)\n{\n\tint count;\n\n\tspin_lock_irq(&css_set_lock);\n\tcount = __cgroup_task_count(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn count;\n}\n\nstruct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}\nEXPORT_SYMBOL_GPL(of_css);\n\n/**\n * for_each_css - iterate all css's of a cgroup\n * @css: the iteration cursor\n * @ssid: the index of the subsystem, CGROUP_SUBSYS_COUNT after reaching the end\n * @cgrp: the target cgroup to iterate css's of\n *\n * Should be called under cgroup_[tree_]mutex.\n */\n#define for_each_css(css, ssid, cgrp)\t\t\t\t\t\\\n\tfor ((ssid) = 0; (ssid) < CGROUP_SUBSYS_COUNT; (ssid)++)\t\\\n\t\tif (!((css) = rcu_dereference_check(\t\t\t\\\n\t\t\t\t(cgrp)->subsys[(ssid)],\t\t\t\\\n\t\t\t\tlockdep_is_held(&cgroup_mutex)))) { }\t\\\n\t\telse\n\n/**\n * for_each_e_css - iterate all effective css's of a cgroup\n * @css: the iteration cursor\n * @ssid: the index of the subsystem, CGROUP_SUBSYS_COUNT after reaching the end\n * @cgrp: the target cgroup to iterate css's of\n *\n * Should be called under cgroup_[tree_]mutex.\n */\n#define for_each_e_css(css, ssid, cgrp)\t\t\t\t\t    \\\n\tfor ((ssid) = 0; (ssid) < CGROUP_SUBSYS_COUNT; (ssid)++)\t    \\\n\t\tif (!((css) = cgroup_e_css_by_mask(cgrp,\t\t    \\\n\t\t\t\t\t\t   cgroup_subsys[(ssid)]))) \\\n\t\t\t;\t\t\t\t\t\t    \\\n\t\telse\n\n/**\n * do_each_subsys_mask - filter for_each_subsys with a bitmask\n * @ss: the iteration cursor\n * @ssid: the index of @ss, CGROUP_SUBSYS_COUNT after reaching the end\n * @ss_mask: the bitmask\n *\n * The block will only run for cases where the ssid-th bit (1 << ssid) of\n * @ss_mask is set.\n */\n#define do_each_subsys_mask(ss, ssid, ss_mask) do {\t\t\t\\\n\tunsigned long __ss_mask = (ss_mask);\t\t\t\t\\\n\tif (!CGROUP_SUBSYS_COUNT) { /* to avoid spurious gcc warning */\t\\\n\t\t(ssid) = 0;\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tfor_each_set_bit(ssid, &__ss_mask, CGROUP_SUBSYS_COUNT) {\t\\\n\t\t(ss) = cgroup_subsys[ssid];\t\t\t\t\\\n\t\t{\n\n#define while_each_subsys_mask()\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (false)\n\n/* iterate over child cgrps, lock should be held throughout iteration */\n#define cgroup_for_each_live_child(child, cgrp)\t\t\t\t\\\n\tlist_for_each_entry((child), &(cgrp)->self.children, self.sibling) \\\n\t\tif (({ lockdep_assert_held(&cgroup_mutex);\t\t\\\n\t\t       cgroup_is_dead(child); }))\t\t\t\\\n\t\t\t;\t\t\t\t\t\t\\\n\t\telse\n\n/* walk live descendants in preorder */\n#define cgroup_for_each_live_descendant_pre(dsct, d_css, cgrp)\t\t\\\n\tcss_for_each_descendant_pre((d_css), cgroup_css((cgrp), NULL))\t\\\n\t\tif (({ lockdep_assert_held(&cgroup_mutex);\t\t\\\n\t\t       (dsct) = (d_css)->cgroup;\t\t\t\\\n\t\t       cgroup_is_dead(dsct); }))\t\t\t\\\n\t\t\t;\t\t\t\t\t\t\\\n\t\telse\n\n/* walk live descendants in postorder */\n#define cgroup_for_each_live_descendant_post(dsct, d_css, cgrp)\t\t\\\n\tcss_for_each_descendant_post((d_css), cgroup_css((cgrp), NULL))\t\\\n\t\tif (({ lockdep_assert_held(&cgroup_mutex);\t\t\\\n\t\t       (dsct) = (d_css)->cgroup;\t\t\t\\\n\t\t       cgroup_is_dead(dsct); }))\t\t\t\\\n\t\t\t;\t\t\t\t\t\t\\\n\t\telse\n\n/*\n * The default css_set - used by init and its children prior to any\n * hierarchies being mounted. It contains a pointer to the root state\n * for each subsystem. Also used to anchor the list of css_sets. Not\n * reference-counted, to improve performance when child cgroups\n * haven't been created.\n */\nstruct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};\n\nstatic int css_set_count\t= 1;\t/* 1 for init_css_set */\n\nstatic bool css_set_threaded(struct css_set *cset)\n{\n\treturn cset->dom_cset != cset;\n}\n\n/**\n * css_set_populated - does a css_set contain any tasks?\n * @cset: target css_set\n *\n * css_set_populated() should be the same as !!cset->nr_tasks at steady\n * state. However, css_set_populated() can be called while a task is being\n * added to or removed from the linked list before the nr_tasks is\n * properly updated. Hence, we can't just look at ->nr_tasks here.\n */\nstatic bool css_set_populated(struct css_set *cset)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\treturn !list_empty(&cset->tasks) || !list_empty(&cset->mg_tasks);\n}\n\n/**\n * cgroup_update_populated - update the populated count of a cgroup\n * @cgrp: the target cgroup\n * @populated: inc or dec populated count\n *\n * One of the css_sets associated with @cgrp is either getting its first\n * task or losing the last.  Update @cgrp->nr_populated_* accordingly.  The\n * count is propagated towards root so that a given cgroup's\n * nr_populated_children is zero iff none of its descendants contain any\n * tasks.\n *\n * @cgrp's interface file \"cgroup.populated\" is zero if both\n * @cgrp->nr_populated_csets and @cgrp->nr_populated_children are zero and\n * 1 otherwise.  When the sum changes from or to zero, userland is notified\n * that the content of the interface file has changed.  This can be used to\n * detect when @cgrp and its descendants become populated or empty.\n */\nstatic void cgroup_update_populated(struct cgroup *cgrp, bool populated)\n{\n\tstruct cgroup *child = NULL;\n\tint adj = populated ? 1 : -1;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tdo {\n\t\tbool was_populated = cgroup_is_populated(cgrp);\n\n\t\tif (!child) {\n\t\t\tcgrp->nr_populated_csets += adj;\n\t\t} else {\n\t\t\tif (cgroup_is_threaded(child))\n\t\t\t\tcgrp->nr_populated_threaded_children += adj;\n\t\t\telse\n\t\t\t\tcgrp->nr_populated_domain_children += adj;\n\t\t}\n\n\t\tif (was_populated == cgroup_is_populated(cgrp))\n\t\t\tbreak;\n\n\t\tcgroup1_check_for_release(cgrp);\n\t\tTRACE_CGROUP_PATH(notify_populated, cgrp,\n\t\t\t\t  cgroup_is_populated(cgrp));\n\t\tcgroup_file_notify(&cgrp->events_file);\n\n\t\tchild = cgrp;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n}\n\n/**\n * css_set_update_populated - update populated state of a css_set\n * @cset: target css_set\n * @populated: whether @cset is populated or depopulated\n *\n * @cset is either getting the first task or losing the last.  Update the\n * populated counters of all associated cgroups accordingly.\n */\nstatic void css_set_update_populated(struct css_set *cset, bool populated)\n{\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link)\n\t\tcgroup_update_populated(link->cgrp, populated);\n}\n\n/*\n * @task is leaving, advance task iterators which are pointing to it so\n * that they can resume at the next position.  Advancing an iterator might\n * remove it from the list, use safe walk.  See css_task_iter_skip() for\n * details.\n */\nstatic void css_set_skip_task_iters(struct css_set *cset,\n\t\t\t\t    struct task_struct *task)\n{\n\tstruct css_task_iter *it, *pos;\n\n\tlist_for_each_entry_safe(it, pos, &cset->task_iters, iters_node)\n\t\tcss_task_iter_skip(it, task);\n}\n\n/**\n * css_set_move_task - move a task from one css_set to another\n * @task: task being moved\n * @from_cset: css_set @task currently belongs to (may be NULL)\n * @to_cset: new css_set @task is being moved to (may be NULL)\n * @use_mg_tasks: move to @to_cset->mg_tasks instead of ->tasks\n *\n * Move @task from @from_cset to @to_cset.  If @task didn't belong to any\n * css_set, @from_cset can be NULL.  If @task is being disassociated\n * instead of moved, @to_cset can be NULL.\n *\n * This function automatically handles populated counter updates and\n * css_task_iter adjustments but the caller is responsible for managing\n * @from_cset and @to_cset's reference counts.\n */\nstatic void css_set_move_task(struct task_struct *task,\n\t\t\t      struct css_set *from_cset, struct css_set *to_cset,\n\t\t\t      bool use_mg_tasks)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (to_cset && !css_set_populated(to_cset))\n\t\tcss_set_update_populated(to_cset, true);\n\n\tif (from_cset) {\n\t\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\t\tcss_set_skip_task_iters(from_cset, task);\n\t\tlist_del_init(&task->cg_list);\n\t\tif (!css_set_populated(from_cset))\n\t\t\tcss_set_update_populated(from_cset, false);\n\t} else {\n\t\tWARN_ON_ONCE(!list_empty(&task->cg_list));\n\t}\n\n\tif (to_cset) {\n\t\t/*\n\t\t * We are synchronized through cgroup_threadgroup_rwsem\n\t\t * against PF_EXITING setting such that we can't race\n\t\t * against cgroup_exit()/cgroup_free() dropping the css_set.\n\t\t */\n\t\tWARN_ON_ONCE(task->flags & PF_EXITING);\n\n\t\tcgroup_move_task(task, to_cset);\n\t\tlist_add_tail(&task->cg_list, use_mg_tasks ? &to_cset->mg_tasks :\n\t\t\t\t\t\t\t     &to_cset->tasks);\n\t}\n}\n\n/*\n * hash table for cgroup groups. This improves the performance to find\n * an existing css_set. This hash doesn't (currently) take into\n * account cgroups in empty hierarchies.\n */\n#define CSS_SET_HASH_BITS\t7\nstatic DEFINE_HASHTABLE(css_set_table, CSS_SET_HASH_BITS);\n\nstatic unsigned long css_set_hash(struct cgroup_subsys_state *css[])\n{\n\tunsigned long key = 0UL;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tkey += (unsigned long)css[i];\n\tkey = (key >> 16) ^ key;\n\n\treturn key;\n}\n\nvoid put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}\n\n/**\n * compare_css_sets - helper function for find_existing_css_set().\n * @cset: candidate css_set being tested\n * @old_cset: existing css_set for a task\n * @new_cgrp: cgroup that's being entered by the task\n * @template: desired set of css pointers in css_set (pre-calculated)\n *\n * Returns true if \"cset\" matches \"old_cset\" except for the hierarchy\n * which \"new_cgrp\" belongs to, for which it should match \"new_cgrp\".\n */\nstatic bool compare_css_sets(struct css_set *cset,\n\t\t\t     struct css_set *old_cset,\n\t\t\t     struct cgroup *new_cgrp,\n\t\t\t     struct cgroup_subsys_state *template[])\n{\n\tstruct cgroup *new_dfl_cgrp;\n\tstruct list_head *l1, *l2;\n\n\t/*\n\t * On the default hierarchy, there can be csets which are\n\t * associated with the same set of cgroups but different csses.\n\t * Let's first ensure that csses match.\n\t */\n\tif (memcmp(template, cset->subsys, sizeof(cset->subsys)))\n\t\treturn false;\n\n\n\t/* @cset's domain should match the default cgroup's */\n\tif (cgroup_on_dfl(new_cgrp))\n\t\tnew_dfl_cgrp = new_cgrp;\n\telse\n\t\tnew_dfl_cgrp = old_cset->dfl_cgrp;\n\n\tif (new_dfl_cgrp->dom_cgrp != cset->dom_cset->dfl_cgrp)\n\t\treturn false;\n\n\t/*\n\t * Compare cgroup pointers in order to distinguish between\n\t * different cgroups in hierarchies.  As different cgroups may\n\t * share the same effective css, this comparison is always\n\t * necessary.\n\t */\n\tl1 = &cset->cgrp_links;\n\tl2 = &old_cset->cgrp_links;\n\twhile (1) {\n\t\tstruct cgrp_cset_link *link1, *link2;\n\t\tstruct cgroup *cgrp1, *cgrp2;\n\n\t\tl1 = l1->next;\n\t\tl2 = l2->next;\n\t\t/* See if we reached the end - both lists are equal length. */\n\t\tif (l1 == &cset->cgrp_links) {\n\t\t\tBUG_ON(l2 != &old_cset->cgrp_links);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tBUG_ON(l2 == &old_cset->cgrp_links);\n\t\t}\n\t\t/* Locate the cgroups associated with these links. */\n\t\tlink1 = list_entry(l1, struct cgrp_cset_link, cgrp_link);\n\t\tlink2 = list_entry(l2, struct cgrp_cset_link, cgrp_link);\n\t\tcgrp1 = link1->cgrp;\n\t\tcgrp2 = link2->cgrp;\n\t\t/* Hierarchies should be linked in the same order. */\n\t\tBUG_ON(cgrp1->root != cgrp2->root);\n\n\t\t/*\n\t\t * If this hierarchy is the hierarchy of the cgroup\n\t\t * that's changing, then we need to check that this\n\t\t * css_set points to the new cgroup; if it's any other\n\t\t * hierarchy, then this css_set should point to the\n\t\t * same cgroup as the old css_set.\n\t\t */\n\t\tif (cgrp1->root == new_cgrp->root) {\n\t\t\tif (cgrp1 != new_cgrp)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (cgrp1 != cgrp2)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * find_existing_css_set - init css array and find the matching css_set\n * @old_cset: the css_set that we're using before the cgroup transition\n * @cgrp: the cgroup that we're moving into\n * @template: out param for the new set of csses, should be clear on entry\n */\nstatic struct css_set *find_existing_css_set(struct css_set *old_cset,\n\t\t\t\t\tstruct cgroup *cgrp,\n\t\t\t\t\tstruct cgroup_subsys_state *template[])\n{\n\tstruct cgroup_root *root = cgrp->root;\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tunsigned long key;\n\tint i;\n\n\t/*\n\t * Build the set of subsystem state objects that we want to see in the\n\t * new css_set. while subsystems can change globally, the entries here\n\t * won't change, so no need for locking.\n\t */\n\tfor_each_subsys(ss, i) {\n\t\tif (root->subsys_mask & (1UL << i)) {\n\t\t\t/*\n\t\t\t * @ss is in this hierarchy, so we want the\n\t\t\t * effective css from @cgrp.\n\t\t\t */\n\t\t\ttemplate[i] = cgroup_e_css_by_mask(cgrp, ss);\n\t\t} else {\n\t\t\t/*\n\t\t\t * @ss is not in this hierarchy, so we don't want\n\t\t\t * to change the css.\n\t\t\t */\n\t\t\ttemplate[i] = old_cset->subsys[i];\n\t\t}\n\t}\n\n\tkey = css_set_hash(template);\n\thash_for_each_possible(css_set_table, cset, hlist, key) {\n\t\tif (!compare_css_sets(cset, old_cset, cgrp, template))\n\t\t\tcontinue;\n\n\t\t/* This css_set matches what we need */\n\t\treturn cset;\n\t}\n\n\t/* No existing cgroup group matched */\n\treturn NULL;\n}\n\nstatic void free_cgrp_cset_links(struct list_head *links_to_free)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\tlist_for_each_entry_safe(link, tmp_link, links_to_free, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tkfree(link);\n\t}\n}\n\n/**\n * allocate_cgrp_cset_links - allocate cgrp_cset_links\n * @count: the number of links to allocate\n * @tmp_links: list_head the allocated links are put on\n *\n * Allocate @count cgrp_cset_link structures and chain them on @tmp_links\n * through ->cset_link.  Returns 0 on success or -errno.\n */\nstatic int allocate_cgrp_cset_links(int count, struct list_head *tmp_links)\n{\n\tstruct cgrp_cset_link *link;\n\tint i;\n\n\tINIT_LIST_HEAD(tmp_links);\n\n\tfor (i = 0; i < count; i++) {\n\t\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tfree_cgrp_cset_links(tmp_links);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlist_add(&link->cset_link, tmp_links);\n\t}\n\treturn 0;\n}\n\n/**\n * link_css_set - a helper function to link a css_set to a cgroup\n * @tmp_links: cgrp_cset_link objects allocated by allocate_cgrp_cset_links()\n * @cset: the css_set to be linked\n * @cgrp: the destination cgroup\n */\nstatic void link_css_set(struct list_head *tmp_links, struct css_set *cset,\n\t\t\t struct cgroup *cgrp)\n{\n\tstruct cgrp_cset_link *link;\n\n\tBUG_ON(list_empty(tmp_links));\n\n\tif (cgroup_on_dfl(cgrp))\n\t\tcset->dfl_cgrp = cgrp;\n\n\tlink = list_first_entry(tmp_links, struct cgrp_cset_link, cset_link);\n\tlink->cset = cset;\n\tlink->cgrp = cgrp;\n\n\t/*\n\t * Always add links to the tail of the lists so that the lists are\n\t * in choronological order.\n\t */\n\tlist_move_tail(&link->cset_link, &cgrp->cset_links);\n\tlist_add_tail(&link->cgrp_link, &cset->cgrp_links);\n\n\tif (cgroup_parent(cgrp))\n\t\tcgroup_get_live(cgrp);\n}\n\n/**\n * find_css_set - return a new css_set with one cgroup updated\n * @old_cset: the baseline css_set\n * @cgrp: the cgroup to be updated\n *\n * Return a new css_set that's equivalent to @old_cset, but with @cgrp\n * substituted into the appropriate hierarchy.\n */\nstatic struct css_set *find_css_set(struct css_set *old_cset,\n\t\t\t\t    struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys_state *template[CGROUP_SUBSYS_COUNT] = { };\n\tstruct css_set *cset;\n\tstruct list_head tmp_links;\n\tstruct cgrp_cset_link *link;\n\tstruct cgroup_subsys *ss;\n\tunsigned long key;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* First see if we already have a cgroup group that matches\n\t * the desired set */\n\tspin_lock_irq(&css_set_lock);\n\tcset = find_existing_css_set(old_cset, cgrp, template);\n\tif (cset)\n\t\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (cset)\n\t\treturn cset;\n\n\tcset = kzalloc(sizeof(*cset), GFP_KERNEL);\n\tif (!cset)\n\t\treturn NULL;\n\n\t/* Allocate all the cgrp_cset_link objects that we'll need */\n\tif (allocate_cgrp_cset_links(cgroup_root_count, &tmp_links) < 0) {\n\t\tkfree(cset);\n\t\treturn NULL;\n\t}\n\n\trefcount_set(&cset->refcount, 1);\n\tcset->dom_cset = cset;\n\tINIT_LIST_HEAD(&cset->tasks);\n\tINIT_LIST_HEAD(&cset->mg_tasks);\n\tINIT_LIST_HEAD(&cset->dying_tasks);\n\tINIT_LIST_HEAD(&cset->task_iters);\n\tINIT_LIST_HEAD(&cset->threaded_csets);\n\tINIT_HLIST_NODE(&cset->hlist);\n\tINIT_LIST_HEAD(&cset->cgrp_links);\n\tINIT_LIST_HEAD(&cset->mg_preload_node);\n\tINIT_LIST_HEAD(&cset->mg_node);\n\n\t/* Copy the set of subsystem state objects generated in\n\t * find_existing_css_set() */\n\tmemcpy(cset->subsys, template, sizeof(cset->subsys));\n\n\tspin_lock_irq(&css_set_lock);\n\t/* Add reference counts and links from the new css_set. */\n\tlist_for_each_entry(link, &old_cset->cgrp_links, cgrp_link) {\n\t\tstruct cgroup *c = link->cgrp;\n\n\t\tif (c->root == cgrp->root)\n\t\t\tc = cgrp;\n\t\tlink_css_set(&tmp_links, cset, c);\n\t}\n\n\tBUG_ON(!list_empty(&tmp_links));\n\n\tcss_set_count++;\n\n\t/* Add @cset to the hash table */\n\tkey = css_set_hash(cset->subsys);\n\thash_add(css_set_table, &cset->hlist, key);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tstruct cgroup_subsys_state *css = cset->subsys[ssid];\n\n\t\tlist_add_tail(&cset->e_cset_node[ssid],\n\t\t\t      &css->cgroup->e_csets[ssid]);\n\t\tcss_get(css);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * If @cset should be threaded, look up the matching dom_cset and\n\t * link them up.  We first fully initialize @cset then look for the\n\t * dom_cset.  It's simpler this way and safe as @cset is guaranteed\n\t * to stay empty until we return.\n\t */\n\tif (cgroup_is_threaded(cset->dfl_cgrp)) {\n\t\tstruct css_set *dcset;\n\n\t\tdcset = find_css_set(cset, cset->dfl_cgrp->dom_cgrp);\n\t\tif (!dcset) {\n\t\t\tput_css_set(cset);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\tcset->dom_cset = dcset;\n\t\tlist_add_tail(&cset->threaded_csets_node,\n\t\t\t      &dcset->threaded_csets);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\treturn cset;\n}\n\nstruct cgroup_root *cgroup_root_from_kf(struct kernfs_root *kf_root)\n{\n\tstruct cgroup *root_cgrp = kf_root->kn->priv;\n\n\treturn root_cgrp->root;\n}\n\nstatic int cgroup_init_root_id(struct cgroup_root *root)\n{\n\tint id;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tid = idr_alloc_cyclic(&cgroup_hierarchy_idr, root, 0, 0, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn id;\n\n\troot->hierarchy_id = id;\n\treturn 0;\n}\n\nstatic void cgroup_exit_root_id(struct cgroup_root *root)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tidr_remove(&cgroup_hierarchy_idr, root->hierarchy_id);\n}\n\nvoid cgroup_free_root(struct cgroup_root *root)\n{\n\tkfree(root);\n}\n\nstatic void cgroup_destroy_root(struct cgroup_root *root)\n{\n\tstruct cgroup *cgrp = &root->cgrp;\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\ttrace_cgroup_destroy_root(root);\n\n\tcgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);\n\n\tBUG_ON(atomic_read(&root->nr_cgrps));\n\tBUG_ON(!list_empty(&cgrp->self.children));\n\n\t/* Rebind all subsystems back to the default hierarchy */\n\tWARN_ON(rebind_subsystems(&cgrp_dfl_root, root->subsys_mask));\n\n\t/*\n\t * Release all the links from cset_links to this hierarchy's\n\t * root cgroup\n\t */\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_for_each_entry_safe(link, tmp_link, &cgrp->cset_links, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tkfree(link);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (!list_empty(&root->root_list)) {\n\t\tlist_del(&root->root_list);\n\t\tcgroup_root_count--;\n\t}\n\n\tcgroup_exit_root_id(root);\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_destroy_root(root->kf_root);\n\tcgroup_free_root(root);\n}\n\n/*\n * look up cgroup associated with current task's cgroup namespace on the\n * specified hierarchy\n */\nstatic struct cgroup *\ncurrent_cgns_cgroup_from_root(struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\trcu_read_lock();\n\n\tcset = current->nsproxy->cgroup_ns->root_cset;\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tBUG_ON(!res);\n\treturn res;\n}\n\n/* look up cgroup associated with given css_set on the specified hierarchy */\nstatic struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}\n\n/*\n * Return the cgroup for \"task\" from the given hierarchy. Must be\n * called with cgroup_mutex and css_set_lock held.\n */\nstruct cgroup *task_cgroup_from_root(struct task_struct *task,\n\t\t\t\t     struct cgroup_root *root)\n{\n\t/*\n\t * No need to lock the task - since we hold css_set_lock the\n\t * task can't change groups.\n\t */\n\treturn cset_cgroup_from_root(task_css_set(task), root);\n}\n\n/*\n * A task must hold cgroup_mutex to modify cgroups.\n *\n * Any task can increment and decrement the count field without lock.\n * So in general, code holding cgroup_mutex can't rely on the count\n * field not changing.  However, if the count goes to zero, then only\n * cgroup_attach_task() can increment it again.  Because a count of zero\n * means that no tasks are currently attached, therefore there is no\n * way a task attached to that cgroup can fork (the other way to\n * increment the count).  So code holding cgroup_mutex can safely\n * assume that if the count is zero, it will stay zero. Similarly, if\n * a task holds cgroup_mutex on a cgroup with zero count, it\n * knows that the cgroup won't be removed, as cgroup_rmdir()\n * needs that mutex.\n *\n * A cgroup can only be deleted if both its 'count' of using tasks\n * is zero, and its list of 'children' cgroups is empty.  Since all\n * tasks in the system use _some_ cgroup, and since there is always at\n * least one task in the system (init, pid == 1), therefore, root cgroup\n * always has either children cgroups and/or using tasks.  So we don't\n * need a special hack to ensure that root cgroup cannot be deleted.\n *\n * P.S.  One more locking exception.  RCU is used to guard the\n * update of a tasks cgroup pointer by cgroup_attach_task()\n */\n\nstatic struct kernfs_syscall_ops cgroup_kf_syscall_ops;\n\nstatic char *cgroup_file_name(struct cgroup *cgrp, const struct cftype *cft,\n\t\t\t      char *buf)\n{\n\tstruct cgroup_subsys *ss = cft->ss;\n\n\tif (cft->ss && !(cft->flags & CFTYPE_NO_PREFIX) &&\n\t    !(cgrp->root->flags & CGRP_ROOT_NOPREFIX)) {\n\t\tconst char *dbg = (cft->flags & CFTYPE_DEBUG) ? \".__DEBUG__.\" : \"\";\n\n\t\tsnprintf(buf, CGROUP_FILE_NAME_MAX, \"%s%s.%s\",\n\t\t\t dbg, cgroup_on_dfl(cgrp) ? ss->name : ss->legacy_name,\n\t\t\t cft->name);\n\t} else {\n\t\tstrscpy(buf, cft->name, CGROUP_FILE_NAME_MAX);\n\t}\n\treturn buf;\n}\n\n/**\n * cgroup_file_mode - deduce file mode of a control file\n * @cft: the control file in question\n *\n * S_IRUGO for read, S_IWUSR for write.\n */\nstatic umode_t cgroup_file_mode(const struct cftype *cft)\n{\n\tumode_t mode = 0;\n\n\tif (cft->read_u64 || cft->read_s64 || cft->seq_show)\n\t\tmode |= S_IRUGO;\n\n\tif (cft->write_u64 || cft->write_s64 || cft->write) {\n\t\tif (cft->flags & CFTYPE_WORLD_WRITABLE)\n\t\t\tmode |= S_IWUGO;\n\t\telse\n\t\t\tmode |= S_IWUSR;\n\t}\n\n\treturn mode;\n}\n\n/**\n * cgroup_calc_subtree_ss_mask - calculate subtree_ss_mask\n * @subtree_control: the new subtree_control mask to consider\n * @this_ss_mask: available subsystems\n *\n * On the default hierarchy, a subsystem may request other subsystems to be\n * enabled together through its ->depends_on mask.  In such cases, more\n * subsystems than specified in \"cgroup.subtree_control\" may be enabled.\n *\n * This function calculates which subsystems need to be enabled if\n * @subtree_control is to be applied while restricted to @this_ss_mask.\n */\nstatic u16 cgroup_calc_subtree_ss_mask(u16 subtree_control, u16 this_ss_mask)\n{\n\tu16 cur_ss_mask = subtree_control;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcur_ss_mask |= cgrp_dfl_implicit_ss_mask;\n\n\twhile (true) {\n\t\tu16 new_ss_mask = cur_ss_mask;\n\n\t\tdo_each_subsys_mask(ss, ssid, cur_ss_mask) {\n\t\t\tnew_ss_mask |= ss->depends_on;\n\t\t} while_each_subsys_mask();\n\n\t\t/*\n\t\t * Mask out subsystems which aren't available.  This can\n\t\t * happen only if some depended-upon subsystems were bound\n\t\t * to non-default hierarchies.\n\t\t */\n\t\tnew_ss_mask &= this_ss_mask;\n\n\t\tif (new_ss_mask == cur_ss_mask)\n\t\t\tbreak;\n\t\tcur_ss_mask = new_ss_mask;\n\t}\n\n\treturn cur_ss_mask;\n}\n\n/**\n * cgroup_kn_unlock - unlocking helper for cgroup kernfs methods\n * @kn: the kernfs_node being serviced\n *\n * This helper undoes cgroup_kn_lock_live() and should be invoked before\n * the method finishes if locking succeeded.  Note that once this function\n * returns the cgroup returned by cgroup_kn_lock_live() may become\n * inaccessible any time.  If the caller intends to continue to access the\n * cgroup, it should pin it before invoking this function.\n */\nvoid cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}\n\n/**\n * cgroup_kn_lock_live - locking helper for cgroup kernfs methods\n * @kn: the kernfs_node being serviced\n * @drain_offline: perform offline draining on the cgroup\n *\n * This helper is to be used by a cgroup kernfs method currently servicing\n * @kn.  It breaks the active protection, performs cgroup locking and\n * verifies that the associated cgroup is alive.  Returns the cgroup if\n * alive; otherwise, %NULL.  A successful return should be undone by a\n * matching cgroup_kn_unlock() invocation.  If @drain_offline is %true, the\n * cgroup is drained of offlining csses before return.\n *\n * Any cgroup kernfs method implementation which requires locking the\n * associated cgroup should use this helper.  It avoids nesting cgroup\n * locking under kernfs active protection and allows all kernfs operations\n * including self-removal.\n */\nstruct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}\n\nstatic void cgroup_rm_file(struct cgroup *cgrp, const struct cftype *cft)\n{\n\tchar name[CGROUP_FILE_NAME_MAX];\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (cft->file_offset) {\n\t\tstruct cgroup_subsys_state *css = cgroup_css(cgrp, cft->ss);\n\t\tstruct cgroup_file *cfile = (void *)css + cft->file_offset;\n\n\t\tspin_lock_irq(&cgroup_file_kn_lock);\n\t\tcfile->kn = NULL;\n\t\tspin_unlock_irq(&cgroup_file_kn_lock);\n\n\t\tdel_timer_sync(&cfile->notify_timer);\n\t}\n\n\tkernfs_remove_by_name(cgrp->kn, cgroup_file_name(cgrp, cft, name));\n}\n\n/**\n * css_clear_dir - remove subsys files in a cgroup directory\n * @css: taget css\n */\nstatic void css_clear_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts;\n\n\tif (!(css->flags & CSS_VISIBLE))\n\t\treturn;\n\n\tcss->flags &= ~CSS_VISIBLE;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node)\n\t\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n}\n\n/**\n * css_populate_dir - create subsys files in a cgroup directory\n * @css: target css\n *\n * On failure, no file is added.\n */\nstatic int css_populate_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts, *failed_cfts;\n\tint ret;\n\n\tif ((css->flags & CSS_VISIBLE) || !cgrp->kn)\n\t\treturn 0;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tret = cgroup_addrm_files(&cgrp->self, cgrp, cfts, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\t\tret = cgroup_addrm_files(css, cgrp, cfts, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tfailed_cfts = cfts;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcss->flags |= CSS_VISIBLE;\n\n\treturn 0;\nerr:\n\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\tif (cfts == failed_cfts)\n\t\t\tbreak;\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n\treturn ret;\n}\n\nint rebind_subsystems(struct cgroup_root *dst_root, u16 ss_mask)\n{\n\tstruct cgroup *dcgrp = &dst_root->cgrp;\n\tstruct cgroup_subsys *ss;\n\tint ssid, i, ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\t/*\n\t\t * If @ss has non-root csses attached to it, can't move.\n\t\t * If @ss is an implicit controller, it is exempt from this\n\t\t * rule and can be stolen.\n\t\t */\n\t\tif (css_next_child(NULL, cgroup_css(&ss->root->cgrp, ss)) &&\n\t\t    !ss->implicit_on_dfl)\n\t\t\treturn -EBUSY;\n\n\t\t/* can't move between two non-dummy roots either */\n\t\tif (ss->root != &cgrp_dfl_root && dst_root != &cgrp_dfl_root)\n\t\t\treturn -EBUSY;\n\t} while_each_subsys_mask();\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tstruct cgroup_root *src_root = ss->root;\n\t\tstruct cgroup *scgrp = &src_root->cgrp;\n\t\tstruct cgroup_subsys_state *css = cgroup_css(scgrp, ss);\n\t\tstruct css_set *cset;\n\n\t\tWARN_ON(!css || cgroup_css(dcgrp, ss));\n\n\t\t/* disable from the source */\n\t\tsrc_root->subsys_mask &= ~(1 << ssid);\n\t\tWARN_ON(cgroup_apply_control(scgrp));\n\t\tcgroup_finalize_control(scgrp, 0);\n\n\t\t/* rebind */\n\t\tRCU_INIT_POINTER(scgrp->subsys[ssid], NULL);\n\t\trcu_assign_pointer(dcgrp->subsys[ssid], css);\n\t\tss->root = dst_root;\n\t\tcss->cgroup = dcgrp;\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\thash_for_each(css_set_table, i, cset, hlist)\n\t\t\tlist_move_tail(&cset->e_cset_node[ss->id],\n\t\t\t\t       &dcgrp->e_csets[ss->id]);\n\t\tspin_unlock_irq(&css_set_lock);\n\n\t\t/* default hierarchy doesn't enable controllers by default */\n\t\tdst_root->subsys_mask |= 1 << ssid;\n\t\tif (dst_root == &cgrp_dfl_root) {\n\t\t\tstatic_branch_enable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t} else {\n\t\t\tdcgrp->subtree_control |= 1 << ssid;\n\t\t\tstatic_branch_disable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t}\n\n\t\tret = cgroup_apply_control(dcgrp);\n\t\tif (ret)\n\t\t\tpr_warn(\"partial failure to rebind %s controller (err=%d)\\n\",\n\t\t\t\tss->name, ret);\n\n\t\tif (ss->bind)\n\t\t\tss->bind(css);\n\t} while_each_subsys_mask();\n\n\tkernfs_activate(dcgrp->kn);\n\treturn 0;\n}\n\nint cgroup_show_path(struct seq_file *sf, struct kernfs_node *kf_node,\n\t\t     struct kernfs_root *kf_root)\n{\n\tint len = 0;\n\tchar *buf = NULL;\n\tstruct cgroup_root *kf_cgroot = cgroup_root_from_kf(kf_root);\n\tstruct cgroup *ns_cgroup;\n\n\tbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&css_set_lock);\n\tns_cgroup = current_cgns_cgroup_from_root(kf_cgroot);\n\tlen = kernfs_path_from_node(kf_node, ns_cgroup->kn, buf, PATH_MAX);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (len >= PATH_MAX)\n\t\tlen = -ERANGE;\n\telse if (len > 0) {\n\t\tseq_escape(sf, buf, \" \\t\\n\\\\\");\n\t\tlen = 0;\n\t}\n\tkfree(buf);\n\treturn len;\n}\n\nenum cgroup2_param {\n\tOpt_nsdelegate,\n\tOpt_memory_localevents,\n\tOpt_memory_recursiveprot,\n\tnr__cgroup2_params\n};\n\nstatic const struct fs_parameter_spec cgroup2_fs_parameters[] = {\n\tfsparam_flag(\"nsdelegate\",\t\tOpt_nsdelegate),\n\tfsparam_flag(\"memory_localevents\",\tOpt_memory_localevents),\n\tfsparam_flag(\"memory_recursiveprot\",\tOpt_memory_recursiveprot),\n\t{}\n};\n\nstatic int cgroup2_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\tstruct fs_parse_result result;\n\tint opt;\n\n\topt = fs_parse(fc, cgroup2_fs_parameters, param, &result);\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase Opt_nsdelegate:\n\t\tctx->flags |= CGRP_ROOT_NS_DELEGATE;\n\t\treturn 0;\n\tcase Opt_memory_localevents:\n\t\tctx->flags |= CGRP_ROOT_MEMORY_LOCAL_EVENTS;\n\t\treturn 0;\n\tcase Opt_memory_recursiveprot:\n\t\tctx->flags |= CGRP_ROOT_MEMORY_RECURSIVE_PROT;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic void apply_cgroup_root_flags(unsigned int root_flags)\n{\n\tif (current->nsproxy->cgroup_ns == &init_cgroup_ns) {\n\t\tif (root_flags & CGRP_ROOT_NS_DELEGATE)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_NS_DELEGATE;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_NS_DELEGATE;\n\n\t\tif (root_flags & CGRP_ROOT_MEMORY_LOCAL_EVENTS)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_MEMORY_LOCAL_EVENTS;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_MEMORY_LOCAL_EVENTS;\n\n\t\tif (root_flags & CGRP_ROOT_MEMORY_RECURSIVE_PROT)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_MEMORY_RECURSIVE_PROT;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_MEMORY_RECURSIVE_PROT;\n\t}\n}\n\nstatic int cgroup_show_options(struct seq_file *seq, struct kernfs_root *kf_root)\n{\n\tif (cgrp_dfl_root.flags & CGRP_ROOT_NS_DELEGATE)\n\t\tseq_puts(seq, \",nsdelegate\");\n\tif (cgrp_dfl_root.flags & CGRP_ROOT_MEMORY_LOCAL_EVENTS)\n\t\tseq_puts(seq, \",memory_localevents\");\n\tif (cgrp_dfl_root.flags & CGRP_ROOT_MEMORY_RECURSIVE_PROT)\n\t\tseq_puts(seq, \",memory_recursiveprot\");\n\treturn 0;\n}\n\nstatic int cgroup_reconfigure(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\n\tapply_cgroup_root_flags(ctx->flags);\n\treturn 0;\n}\n\nstatic void init_cgroup_housekeeping(struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tINIT_LIST_HEAD(&cgrp->self.sibling);\n\tINIT_LIST_HEAD(&cgrp->self.children);\n\tINIT_LIST_HEAD(&cgrp->cset_links);\n\tINIT_LIST_HEAD(&cgrp->pidlists);\n\tmutex_init(&cgrp->pidlist_mutex);\n\tcgrp->self.cgroup = cgrp;\n\tcgrp->self.flags |= CSS_ONLINE;\n\tcgrp->dom_cgrp = cgrp;\n\tcgrp->max_descendants = INT_MAX;\n\tcgrp->max_depth = INT_MAX;\n\tINIT_LIST_HEAD(&cgrp->rstat_css_list);\n\tprev_cputime_init(&cgrp->prev_cputime);\n\n\tfor_each_subsys(ss, ssid)\n\t\tINIT_LIST_HEAD(&cgrp->e_csets[ssid]);\n\n\tinit_waitqueue_head(&cgrp->offline_waitq);\n\tINIT_WORK(&cgrp->release_agent_work, cgroup1_release_agent);\n}\n\nvoid init_cgroup_root(struct cgroup_fs_context *ctx)\n{\n\tstruct cgroup_root *root = ctx->root;\n\tstruct cgroup *cgrp = &root->cgrp;\n\n\tINIT_LIST_HEAD(&root->root_list);\n\tatomic_set(&root->nr_cgrps, 1);\n\tcgrp->root = root;\n\tinit_cgroup_housekeeping(cgrp);\n\n\troot->flags = ctx->flags;\n\tif (ctx->release_agent)\n\t\tstrscpy(root->release_agent_path, ctx->release_agent, PATH_MAX);\n\tif (ctx->name)\n\t\tstrscpy(root->name, ctx->name, MAX_CGROUP_ROOT_NAMELEN);\n\tif (ctx->cpuset_clone_children)\n\t\tset_bit(CGRP_CPUSET_CLONE_CHILDREN, &root->cgrp.flags);\n}\n\nint cgroup_setup_root(struct cgroup_root *root, u16 ss_mask)\n{\n\tLIST_HEAD(tmp_links);\n\tstruct cgroup *root_cgrp = &root->cgrp;\n\tstruct kernfs_syscall_ops *kf_sops;\n\tstruct css_set *cset;\n\tint i, ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tret = percpu_ref_init(&root_cgrp->self.refcnt, css_release,\n\t\t\t      0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * We're accessing css_set_count without locking css_set_lock here,\n\t * but that's OK - it can only be increased by someone holding\n\t * cgroup_lock, and that's us.  Later rebinding may disable\n\t * controllers on the default hierarchy and thus create new csets,\n\t * which can't be more than the existing ones.  Allocate 2x.\n\t */\n\tret = allocate_cgrp_cset_links(2 * css_set_count, &tmp_links);\n\tif (ret)\n\t\tgoto cancel_ref;\n\n\tret = cgroup_init_root_id(root);\n\tif (ret)\n\t\tgoto cancel_ref;\n\n\tkf_sops = root == &cgrp_dfl_root ?\n\t\t&cgroup_kf_syscall_ops : &cgroup1_kf_syscall_ops;\n\n\troot->kf_root = kernfs_create_root(kf_sops,\n\t\t\t\t\t   KERNFS_ROOT_CREATE_DEACTIVATED |\n\t\t\t\t\t   KERNFS_ROOT_SUPPORT_EXPORTOP |\n\t\t\t\t\t   KERNFS_ROOT_SUPPORT_USER_XATTR,\n\t\t\t\t\t   root_cgrp);\n\tif (IS_ERR(root->kf_root)) {\n\t\tret = PTR_ERR(root->kf_root);\n\t\tgoto exit_root_id;\n\t}\n\troot_cgrp->kn = root->kf_root->kn;\n\tWARN_ON_ONCE(cgroup_ino(root_cgrp) != 1);\n\troot_cgrp->ancestor_ids[0] = cgroup_id(root_cgrp);\n\n\tret = css_populate_dir(&root_cgrp->self);\n\tif (ret)\n\t\tgoto destroy_root;\n\n\tret = rebind_subsystems(root, ss_mask);\n\tif (ret)\n\t\tgoto destroy_root;\n\n\tret = cgroup_bpf_inherit(root_cgrp);\n\tWARN_ON_ONCE(ret);\n\n\ttrace_cgroup_setup_root(root);\n\n\t/*\n\t * There must be no failure case after here, since rebinding takes\n\t * care of subsystems' refcounts, which are explicitly dropped in\n\t * the failure exit path.\n\t */\n\tlist_add(&root->root_list, &cgroup_roots);\n\tcgroup_root_count++;\n\n\t/*\n\t * Link the root cgroup in this hierarchy into all the css_set\n\t * objects.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\thash_for_each(css_set_table, i, cset, hlist) {\n\t\tlink_css_set(&tmp_links, cset, root_cgrp);\n\t\tif (css_set_populated(cset))\n\t\t\tcgroup_update_populated(root_cgrp, true);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tBUG_ON(!list_empty(&root_cgrp->self.children));\n\tBUG_ON(atomic_read(&root->nr_cgrps) != 1);\n\n\tret = 0;\n\tgoto out;\n\ndestroy_root:\n\tkernfs_destroy_root(root->kf_root);\n\troot->kf_root = NULL;\nexit_root_id:\n\tcgroup_exit_root_id(root);\ncancel_ref:\n\tpercpu_ref_exit(&root_cgrp->self.refcnt);\nout:\n\tfree_cgrp_cset_links(&tmp_links);\n\treturn ret;\n}\n\nint cgroup_do_get_tree(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\tint ret;\n\n\tctx->kfc.root = ctx->root->kf_root;\n\tif (fc->fs_type == &cgroup2_fs_type)\n\t\tctx->kfc.magic = CGROUP2_SUPER_MAGIC;\n\telse\n\t\tctx->kfc.magic = CGROUP_SUPER_MAGIC;\n\tret = kernfs_get_tree(fc);\n\n\t/*\n\t * In non-init cgroup namespace, instead of root cgroup's dentry,\n\t * we return the dentry corresponding to the cgroupns->root_cgrp.\n\t */\n\tif (!ret && ctx->ns != &init_cgroup_ns) {\n\t\tstruct dentry *nsdentry;\n\t\tstruct super_block *sb = fc->root->d_sb;\n\t\tstruct cgroup *cgrp;\n\n\t\tmutex_lock(&cgroup_mutex);\n\t\tspin_lock_irq(&css_set_lock);\n\n\t\tcgrp = cset_cgroup_from_root(ctx->ns->root_cset, ctx->root);\n\n\t\tspin_unlock_irq(&css_set_lock);\n\t\tmutex_unlock(&cgroup_mutex);\n\n\t\tnsdentry = kernfs_node_dentry(cgrp->kn, sb);\n\t\tdput(fc->root);\n\t\tif (IS_ERR(nsdentry)) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\tret = PTR_ERR(nsdentry);\n\t\t\tnsdentry = NULL;\n\t\t}\n\t\tfc->root = nsdentry;\n\t}\n\n\tif (!ctx->kfc.new_sb_created)\n\t\tcgroup_put(&ctx->root->cgrp);\n\n\treturn ret;\n}\n\n/*\n * Destroy a cgroup filesystem context.\n */\nstatic void cgroup_fs_context_free(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\n\tkfree(ctx->name);\n\tkfree(ctx->release_agent);\n\tput_cgroup_ns(ctx->ns);\n\tkernfs_free_fs_context(fc);\n\tkfree(ctx);\n}\n\nstatic int cgroup_get_tree(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\tint ret;\n\n\tcgrp_dfl_visible = true;\n\tcgroup_get_live(&cgrp_dfl_root.cgrp);\n\tctx->root = &cgrp_dfl_root;\n\n\tret = cgroup_do_get_tree(fc);\n\tif (!ret)\n\t\tapply_cgroup_root_flags(ctx->flags);\n\treturn ret;\n}\n\nstatic const struct fs_context_operations cgroup_fs_context_ops = {\n\t.free\t\t= cgroup_fs_context_free,\n\t.parse_param\t= cgroup2_parse_param,\n\t.get_tree\t= cgroup_get_tree,\n\t.reconfigure\t= cgroup_reconfigure,\n};\n\nstatic const struct fs_context_operations cgroup1_fs_context_ops = {\n\t.free\t\t= cgroup_fs_context_free,\n\t.parse_param\t= cgroup1_parse_param,\n\t.get_tree\t= cgroup1_get_tree,\n\t.reconfigure\t= cgroup1_reconfigure,\n};\n\n/*\n * Initialise the cgroup filesystem creation/reconfiguration context.  Notably,\n * we select the namespace we're going to use.\n */\nstatic int cgroup_init_fs_context(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx;\n\n\tctx = kzalloc(sizeof(struct cgroup_fs_context), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->ns = current->nsproxy->cgroup_ns;\n\tget_cgroup_ns(ctx->ns);\n\tfc->fs_private = &ctx->kfc;\n\tif (fc->fs_type == &cgroup2_fs_type)\n\t\tfc->ops = &cgroup_fs_context_ops;\n\telse\n\t\tfc->ops = &cgroup1_fs_context_ops;\n\tput_user_ns(fc->user_ns);\n\tfc->user_ns = get_user_ns(ctx->ns->user_ns);\n\tfc->global = true;\n\treturn 0;\n}\n\nstatic void cgroup_kill_sb(struct super_block *sb)\n{\n\tstruct kernfs_root *kf_root = kernfs_root_from_sb(sb);\n\tstruct cgroup_root *root = cgroup_root_from_kf(kf_root);\n\n\t/*\n\t * If @root doesn't have any children, start killing it.\n\t * This prevents new mounts by disabling percpu_ref_tryget_live().\n\t * cgroup_mount() may wait for @root's release.\n\t *\n\t * And don't kill the default root.\n\t */\n\tif (list_empty(&root->cgrp.self.children) && root != &cgrp_dfl_root &&\n\t    !percpu_ref_is_dying(&root->cgrp.self.refcnt))\n\t\tpercpu_ref_kill(&root->cgrp.self.refcnt);\n\tcgroup_put(&root->cgrp);\n\tkernfs_kill_sb(sb);\n}\n\nstruct file_system_type cgroup_fs_type = {\n\t.name\t\t\t= \"cgroup\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup1_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};\n\nstatic struct file_system_type cgroup2_fs_type = {\n\t.name\t\t\t= \"cgroup2\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup2_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};\n\n#ifdef CONFIG_CPUSETS\nstatic const struct fs_context_operations cpuset_fs_context_ops = {\n\t.get_tree\t= cgroup1_get_tree,\n\t.free\t\t= cgroup_fs_context_free,\n};\n\n/*\n * This is ugly, but preserves the userspace API for existing cpuset\n * users. If someone tries to mount the \"cpuset\" filesystem, we\n * silently switch it to mount \"cgroup\" instead\n */\nstatic int cpuset_init_fs_context(struct fs_context *fc)\n{\n\tchar *agent = kstrdup(\"/sbin/cpuset_release_agent\", GFP_USER);\n\tstruct cgroup_fs_context *ctx;\n\tint err;\n\n\terr = cgroup_init_fs_context(fc);\n\tif (err) {\n\t\tkfree(agent);\n\t\treturn err;\n\t}\n\n\tfc->ops = &cpuset_fs_context_ops;\n\n\tctx = cgroup_fc2context(fc);\n\tctx->subsys_mask = 1 << cpuset_cgrp_id;\n\tctx->flags |= CGRP_ROOT_NOPREFIX;\n\tctx->release_agent = agent;\n\n\tget_filesystem(&cgroup_fs_type);\n\tput_filesystem(fc->fs_type);\n\tfc->fs_type = &cgroup_fs_type;\n\n\treturn 0;\n}\n\nstatic struct file_system_type cpuset_fs_type = {\n\t.name\t\t\t= \"cpuset\",\n\t.init_fs_context\t= cpuset_init_fs_context,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};\n#endif\n\nint cgroup_path_ns_locked(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t\t  struct cgroup_namespace *ns)\n{\n\tstruct cgroup *root = cset_cgroup_from_root(ns->root_cset, cgrp->root);\n\n\treturn kernfs_path_from_node(cgrp->kn, root->kn, buf, buflen);\n}\n\nint cgroup_path_ns(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t   struct cgroup_namespace *ns)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tspin_lock_irq(&css_set_lock);\n\n\tret = cgroup_path_ns_locked(cgrp, buf, buflen, ns);\n\n\tspin_unlock_irq(&css_set_lock);\n\tmutex_unlock(&cgroup_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cgroup_path_ns);\n\n/**\n * task_cgroup_path - cgroup path of a task in the first cgroup hierarchy\n * @task: target task\n * @buf: the buffer to write the path into\n * @buflen: the length of the buffer\n *\n * Determine @task's cgroup on the first (the one with the lowest non-zero\n * hierarchy_id) cgroup hierarchy and copy its path into @buf.  This\n * function grabs cgroup_mutex and shouldn't be used inside locks used by\n * cgroup controller callbacks.\n *\n * Return value is the same as kernfs_path().\n */\nint task_cgroup_path(struct task_struct *task, char *buf, size_t buflen)\n{\n\tstruct cgroup_root *root;\n\tstruct cgroup *cgrp;\n\tint hierarchy_id = 1;\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tspin_lock_irq(&css_set_lock);\n\n\troot = idr_get_next(&cgroup_hierarchy_idr, &hierarchy_id);\n\n\tif (root) {\n\t\tcgrp = task_cgroup_from_root(task, root);\n\t\tret = cgroup_path_ns_locked(cgrp, buf, buflen, &init_cgroup_ns);\n\t} else {\n\t\t/* if no hierarchy exists, everyone is in \"/\" */\n\t\tret = strlcpy(buf, \"/\", buflen);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(task_cgroup_path);\n\n/**\n * cgroup_migrate_add_task - add a migration target task to a migration context\n * @task: target task\n * @mgctx: target migration context\n *\n * Add @task, which is a migration target, to @mgctx->tset.  This function\n * becomes noop if @task doesn't need to be migrated.  @task's css_set\n * should have been added as a migration source and @task->cg_list will be\n * moved from the css_set's tasks list to mg_tasks one.\n */\nstatic void cgroup_migrate_add_task(struct task_struct *task,\n\t\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* @task either already exited or can't exit until the end */\n\tif (task->flags & PF_EXITING)\n\t\treturn;\n\n\t/* cgroup_threadgroup_rwsem protects racing against forks */\n\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\tcset = task_css_set(task);\n\tif (!cset->mg_src_cgrp)\n\t\treturn;\n\n\tmgctx->tset.nr_tasks++;\n\n\tlist_move_tail(&task->cg_list, &cset->mg_tasks);\n\tif (list_empty(&cset->mg_node))\n\t\tlist_add_tail(&cset->mg_node,\n\t\t\t      &mgctx->tset.src_csets);\n\tif (list_empty(&cset->mg_dst_cset->mg_node))\n\t\tlist_add_tail(&cset->mg_dst_cset->mg_node,\n\t\t\t      &mgctx->tset.dst_csets);\n}\n\n/**\n * cgroup_taskset_first - reset taskset and return the first task\n * @tset: taskset of interest\n * @dst_cssp: output variable for the destination css\n *\n * @tset iteration is initialized and the first task is returned.\n */\nstruct task_struct *cgroup_taskset_first(struct cgroup_taskset *tset,\n\t\t\t\t\t struct cgroup_subsys_state **dst_cssp)\n{\n\ttset->cur_cset = list_first_entry(tset->csets, struct css_set, mg_node);\n\ttset->cur_task = NULL;\n\n\treturn cgroup_taskset_next(tset, dst_cssp);\n}\n\n/**\n * cgroup_taskset_next - iterate to the next task in taskset\n * @tset: taskset of interest\n * @dst_cssp: output variable for the destination css\n *\n * Return the next task in @tset.  Iteration must have been initialized\n * with cgroup_taskset_first().\n */\nstruct task_struct *cgroup_taskset_next(struct cgroup_taskset *tset,\n\t\t\t\t\tstruct cgroup_subsys_state **dst_cssp)\n{\n\tstruct css_set *cset = tset->cur_cset;\n\tstruct task_struct *task = tset->cur_task;\n\n\twhile (&cset->mg_node != tset->csets) {\n\t\tif (!task)\n\t\t\ttask = list_first_entry(&cset->mg_tasks,\n\t\t\t\t\t\tstruct task_struct, cg_list);\n\t\telse\n\t\t\ttask = list_next_entry(task, cg_list);\n\n\t\tif (&task->cg_list != &cset->mg_tasks) {\n\t\t\ttset->cur_cset = cset;\n\t\t\ttset->cur_task = task;\n\n\t\t\t/*\n\t\t\t * This function may be called both before and\n\t\t\t * after cgroup_taskset_migrate().  The two cases\n\t\t\t * can be distinguished by looking at whether @cset\n\t\t\t * has its ->mg_dst_cset set.\n\t\t\t */\n\t\t\tif (cset->mg_dst_cset)\n\t\t\t\t*dst_cssp = cset->mg_dst_cset->subsys[tset->ssid];\n\t\t\telse\n\t\t\t\t*dst_cssp = cset->subsys[tset->ssid];\n\n\t\t\treturn task;\n\t\t}\n\n\t\tcset = list_next_entry(cset, mg_node);\n\t\ttask = NULL;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * cgroup_taskset_migrate - migrate a taskset\n * @mgctx: migration context\n *\n * Migrate tasks in @mgctx as setup by migration preparation functions.\n * This function fails iff one of the ->can_attach callbacks fails and\n * guarantees that either all or none of the tasks in @mgctx are migrated.\n * @mgctx is consumed regardless of success.\n */\nstatic int cgroup_migrate_execute(struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup_taskset *tset = &mgctx->tset;\n\tstruct cgroup_subsys *ss;\n\tstruct task_struct *task, *tmp_task;\n\tstruct css_set *cset, *tmp_cset;\n\tint ssid, failed_ssid, ret;\n\n\t/* check that we can legitimately attach to the cgroup */\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->can_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tret = ss->can_attach(tset);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfailed_ssid = ssid;\n\t\t\t\t\tgoto out_cancel_attach;\n\t\t\t\t}\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\t/*\n\t * Now that we're guaranteed success, proceed to move all tasks to\n\t * the new cgroup.  There are no failure cases after here, so this\n\t * is the commit point.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(cset, &tset->src_csets, mg_node) {\n\t\tlist_for_each_entry_safe(task, tmp_task, &cset->mg_tasks, cg_list) {\n\t\t\tstruct css_set *from_cset = task_css_set(task);\n\t\t\tstruct css_set *to_cset = cset->mg_dst_cset;\n\n\t\t\tget_css_set(to_cset);\n\t\t\tto_cset->nr_tasks++;\n\t\t\tcss_set_move_task(task, from_cset, to_cset, true);\n\t\t\tfrom_cset->nr_tasks--;\n\t\t\t/*\n\t\t\t * If the source or destination cgroup is frozen,\n\t\t\t * the task might require to change its state.\n\t\t\t */\n\t\t\tcgroup_freezer_migrate_task(task, from_cset->dfl_cgrp,\n\t\t\t\t\t\t    to_cset->dfl_cgrp);\n\t\t\tput_css_set_locked(from_cset);\n\n\t\t}\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Migration is committed, all target tasks are now on dst_csets.\n\t * Nothing is sensitive to fork() after this point.  Notify\n\t * controllers that migration is complete.\n\t */\n\ttset->csets = &tset->dst_csets;\n\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\tret = 0;\n\tgoto out_release_tset;\n\nout_cancel_attach:\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ssid == failed_ssid)\n\t\t\t\tbreak;\n\t\t\tif (ss->cancel_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->cancel_attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\nout_release_tset:\n\tspin_lock_irq(&css_set_lock);\n\tlist_splice_init(&tset->dst_csets, &tset->src_csets);\n\tlist_for_each_entry_safe(cset, tmp_cset, &tset->src_csets, mg_node) {\n\t\tlist_splice_tail_init(&cset->mg_tasks, &cset->tasks);\n\t\tlist_del_init(&cset->mg_node);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Re-initialize the cgroup_taskset structure in case it is reused\n\t * again in another cgroup_migrate_add_task()/cgroup_migrate_execute()\n\t * iteration.\n\t */\n\ttset->nr_tasks = 0;\n\ttset->csets    = &tset->src_csets;\n\treturn ret;\n}\n\n/**\n * cgroup_migrate_vet_dst - verify whether a cgroup can be migration destination\n * @dst_cgrp: destination cgroup to test\n *\n * On the default hierarchy, except for the mixable, (possible) thread root\n * and threaded cgroups, subtree_control must be zero for migration\n * destination cgroups with tasks so that child cgroups don't compete\n * against tasks.\n */\nint cgroup_migrate_vet_dst(struct cgroup *dst_cgrp)\n{\n\t/* v1 doesn't have any restriction */\n\tif (!cgroup_on_dfl(dst_cgrp))\n\t\treturn 0;\n\n\t/* verify @dst_cgrp can host resources */\n\tif (!cgroup_is_valid_domain(dst_cgrp->dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(dst_cgrp))\n\t\treturn 0;\n\n\t/*\n\t * If @dst_cgrp is already or can become a thread root or is\n\t * threaded, it doesn't matter.\n\t */\n\tif (cgroup_can_be_thread_root(dst_cgrp) || cgroup_is_threaded(dst_cgrp))\n\t\treturn 0;\n\n\t/* apply no-internal-process constraint */\n\tif (dst_cgrp->subtree_control)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n/**\n * cgroup_migrate_finish - cleanup after attach\n * @mgctx: migration context\n *\n * Undo cgroup_migrate_add_src() and cgroup_migrate_prepare_dst().  See\n * those functions for details.\n */\nvoid cgroup_migrate_finish(struct cgroup_mgctx *mgctx)\n{\n\tLIST_HEAD(preloaded);\n\tstruct css_set *cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_splice_tail_init(&mgctx->preloaded_src_csets, &preloaded);\n\tlist_splice_tail_init(&mgctx->preloaded_dst_csets, &preloaded);\n\n\tlist_for_each_entry_safe(cset, tmp_cset, &preloaded, mg_preload_node) {\n\t\tcset->mg_src_cgrp = NULL;\n\t\tcset->mg_dst_cgrp = NULL;\n\t\tcset->mg_dst_cset = NULL;\n\t\tlist_del_init(&cset->mg_preload_node);\n\t\tput_css_set_locked(cset);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n}\n\n/**\n * cgroup_migrate_add_src - add a migration source css_set\n * @src_cset: the source css_set to add\n * @dst_cgrp: the destination cgroup\n * @mgctx: migration context\n *\n * Tasks belonging to @src_cset are about to be migrated to @dst_cgrp.  Pin\n * @src_cset and add it to @mgctx->src_csets, which should later be cleaned\n * up by cgroup_migrate_finish().\n *\n * This function may be called without holding cgroup_threadgroup_rwsem\n * even if the target is a process.  Threads may be created and destroyed\n * but as long as cgroup_mutex is not dropped, no new css_set can be put\n * into play and the preloaded css_sets are guaranteed to cover all\n * migrations.\n */\nvoid cgroup_migrate_add_src(struct css_set *src_cset,\n\t\t\t    struct cgroup *dst_cgrp,\n\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup *src_cgrp;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If ->dead, @src_set is associated with one or more dead cgroups\n\t * and doesn't contain any migratable tasks.  Ignore it early so\n\t * that the rest of migration path doesn't get confused by it.\n\t */\n\tif (src_cset->dead)\n\t\treturn;\n\n\tsrc_cgrp = cset_cgroup_from_root(src_cset, dst_cgrp->root);\n\n\tif (!list_empty(&src_cset->mg_preload_node))\n\t\treturn;\n\n\tWARN_ON(src_cset->mg_src_cgrp);\n\tWARN_ON(src_cset->mg_dst_cgrp);\n\tWARN_ON(!list_empty(&src_cset->mg_tasks));\n\tWARN_ON(!list_empty(&src_cset->mg_node));\n\n\tsrc_cset->mg_src_cgrp = src_cgrp;\n\tsrc_cset->mg_dst_cgrp = dst_cgrp;\n\tget_css_set(src_cset);\n\tlist_add_tail(&src_cset->mg_preload_node, &mgctx->preloaded_src_csets);\n}\n\n/**\n * cgroup_migrate_prepare_dst - prepare destination css_sets for migration\n * @mgctx: migration context\n *\n * Tasks are about to be moved and all the source css_sets have been\n * preloaded to @mgctx->preloaded_src_csets.  This function looks up and\n * pins all destination css_sets, links each to its source, and append them\n * to @mgctx->preloaded_dst_csets.\n *\n * This function must be called after cgroup_migrate_add_src() has been\n * called on each migration source css_set.  After migration is performed\n * using cgroup_migrate(), cgroup_migrate_finish() must be called on\n * @mgctx.\n */\nint cgroup_migrate_prepare_dst(struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *src_cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* look up the dst cset for each src cset and link it to src */\n\tlist_for_each_entry_safe(src_cset, tmp_cset, &mgctx->preloaded_src_csets,\n\t\t\t\t mg_preload_node) {\n\t\tstruct css_set *dst_cset;\n\t\tstruct cgroup_subsys *ss;\n\t\tint ssid;\n\n\t\tdst_cset = find_css_set(src_cset, src_cset->mg_dst_cgrp);\n\t\tif (!dst_cset)\n\t\t\treturn -ENOMEM;\n\n\t\tWARN_ON_ONCE(src_cset->mg_dst_cset || dst_cset->mg_dst_cset);\n\n\t\t/*\n\t\t * If src cset equals dst, it's noop.  Drop the src.\n\t\t * cgroup_migrate() will skip the cset too.  Note that we\n\t\t * can't handle src == dst as some nodes are used by both.\n\t\t */\n\t\tif (src_cset == dst_cset) {\n\t\t\tsrc_cset->mg_src_cgrp = NULL;\n\t\t\tsrc_cset->mg_dst_cgrp = NULL;\n\t\t\tlist_del_init(&src_cset->mg_preload_node);\n\t\t\tput_css_set(src_cset);\n\t\t\tput_css_set(dst_cset);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsrc_cset->mg_dst_cset = dst_cset;\n\n\t\tif (list_empty(&dst_cset->mg_preload_node))\n\t\t\tlist_add_tail(&dst_cset->mg_preload_node,\n\t\t\t\t      &mgctx->preloaded_dst_csets);\n\t\telse\n\t\t\tput_css_set(dst_cset);\n\n\t\tfor_each_subsys(ss, ssid)\n\t\t\tif (src_cset->subsys[ssid] != dst_cset->subsys[ssid])\n\t\t\t\tmgctx->ss_mask |= 1 << ssid;\n\t}\n\n\treturn 0;\n}\n\n/**\n * cgroup_migrate - migrate a process or task to a cgroup\n * @leader: the leader of the process or the task to migrate\n * @threadgroup: whether @leader points to the whole process or a single task\n * @mgctx: migration context\n *\n * Migrate a process or task denoted by @leader.  If migrating a process,\n * the caller must be holding cgroup_threadgroup_rwsem.  The caller is also\n * responsible for invoking cgroup_migrate_add_src() and\n * cgroup_migrate_prepare_dst() on the targets before invoking this\n * function and following up with cgroup_migrate_finish().\n *\n * As long as a controller's ->can_attach() doesn't fail, this function is\n * guaranteed to succeed.  This means that, excluding ->can_attach()\n * failure, when migrating multiple targets, the success or failure can be\n * decided for all targets by invoking group_migrate_prepare_dst() before\n * actually starting migrating.\n */\nint cgroup_migrate(struct task_struct *leader, bool threadgroup,\n\t\t   struct cgroup_mgctx *mgctx)\n{\n\tstruct task_struct *task;\n\n\t/*\n\t * Prevent freeing of tasks while we take a snapshot. Tasks that are\n\t * already PF_EXITING could be freed from underneath us unless we\n\t * take an rcu_read_lock.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\ttask = leader;\n\tdo {\n\t\tcgroup_migrate_add_task(task, mgctx);\n\t\tif (!threadgroup)\n\t\t\tbreak;\n\t} while_each_thread(leader, task);\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn cgroup_migrate_execute(mgctx);\n}\n\n/**\n * cgroup_attach_task - attach a task or a whole threadgroup to a cgroup\n * @dst_cgrp: the cgroup to attach to\n * @leader: the task or the leader of the threadgroup to be attached\n * @threadgroup: attach the whole threadgroup?\n *\n * Call holding cgroup_mutex and cgroup_threadgroup_rwsem.\n */\nint cgroup_attach_task(struct cgroup *dst_cgrp, struct task_struct *leader,\n\t\t       bool threadgroup)\n{\n\tDEFINE_CGROUP_MGCTX(mgctx);\n\tstruct task_struct *task;\n\tint ret = 0;\n\n\t/* look up all src csets */\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\ttask = leader;\n\tdo {\n\t\tcgroup_migrate_add_src(task_css_set(task), dst_cgrp, &mgctx);\n\t\tif (!threadgroup)\n\t\t\tbreak;\n\t} while_each_thread(leader, task);\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* prepare dst csets and commit */\n\tret = cgroup_migrate_prepare_dst(&mgctx);\n\tif (!ret)\n\t\tret = cgroup_migrate(leader, threadgroup, &mgctx);\n\n\tcgroup_migrate_finish(&mgctx);\n\n\tif (!ret)\n\t\tTRACE_CGROUP_PATH(attach_task, dst_cgrp, leader, threadgroup);\n\n\treturn ret;\n}\n\nstruct task_struct *cgroup_procs_write_start(char *buf, bool threadgroup,\n\t\t\t\t\t     bool *locked)\n\t__acquires(&cgroup_threadgroup_rwsem)\n{\n\tstruct task_struct *tsk;\n\tpid_t pid;\n\n\tif (kstrtoint(strstrip(buf), 0, &pid) || pid < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * If we migrate a single thread, we don't care about threadgroup\n\t * stability. If the thread is `current`, it won't exit(2) under our\n\t * hands or change PID through exec(2). We exclude\n\t * cgroup_update_dfl_csses and other cgroup_{proc,thread}s_write\n\t * callers by cgroup_mutex.\n\t * Therefore, we can skip the global lock.\n\t */\n\tlockdep_assert_held(&cgroup_mutex);\n\tif (pid || threadgroup) {\n\t\tpercpu_down_write(&cgroup_threadgroup_rwsem);\n\t\t*locked = true;\n\t} else {\n\t\t*locked = false;\n\t}\n\n\trcu_read_lock();\n\tif (pid) {\n\t\ttsk = find_task_by_vpid(pid);\n\t\tif (!tsk) {\n\t\t\ttsk = ERR_PTR(-ESRCH);\n\t\t\tgoto out_unlock_threadgroup;\n\t\t}\n\t} else {\n\t\ttsk = current;\n\t}\n\n\tif (threadgroup)\n\t\ttsk = tsk->group_leader;\n\n\t/*\n\t * kthreads may acquire PF_NO_SETAFFINITY during initialization.\n\t * If userland migrates such a kthread to a non-root cgroup, it can\n\t * become trapped in a cpuset, or RT kthread may be born in a\n\t * cgroup with no rt_runtime allocated.  Just say no.\n\t */\n\tif (tsk->no_cgroup_migration || (tsk->flags & PF_NO_SETAFFINITY)) {\n\t\ttsk = ERR_PTR(-EINVAL);\n\t\tgoto out_unlock_threadgroup;\n\t}\n\n\tget_task_struct(tsk);\n\tgoto out_unlock_rcu;\n\nout_unlock_threadgroup:\n\tif (*locked) {\n\t\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\t\t*locked = false;\n\t}\nout_unlock_rcu:\n\trcu_read_unlock();\n\treturn tsk;\n}\n\nvoid cgroup_procs_write_finish(struct task_struct *task, bool locked)\n\t__releases(&cgroup_threadgroup_rwsem)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\t/* release reference from cgroup_procs_write_start() */\n\tput_task_struct(task);\n\n\tif (locked)\n\t\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\tfor_each_subsys(ss, ssid)\n\t\tif (ss->post_attach)\n\t\t\tss->post_attach();\n}\n\nstatic void cgroup_print_ss_mask(struct seq_file *seq, u16 ss_mask)\n{\n\tstruct cgroup_subsys *ss;\n\tbool printed = false;\n\tint ssid;\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tif (printed)\n\t\t\tseq_putc(seq, ' ');\n\t\tseq_puts(seq, ss->name);\n\t\tprinted = true;\n\t} while_each_subsys_mask();\n\tif (printed)\n\t\tseq_putc(seq, '\\n');\n}\n\n/* show controllers which are enabled from the parent */\nstatic int cgroup_controllers_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tcgroup_print_ss_mask(seq, cgroup_control(cgrp));\n\treturn 0;\n}\n\n/* show controllers which are enabled for a given cgroup's children */\nstatic int cgroup_subtree_control_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tcgroup_print_ss_mask(seq, cgrp->subtree_control);\n\treturn 0;\n}\n\n/**\n * cgroup_update_dfl_csses - update css assoc of a subtree in default hierarchy\n * @cgrp: root of the subtree to update csses for\n *\n * @cgrp's control masks have changed and its subtree's css associations\n * need to be updated accordingly.  This function looks up all css_sets\n * which are attached to the subtree, creates the matching updated css_sets\n * and migrates the tasks to the new ones.\n */\nstatic int cgroup_update_dfl_csses(struct cgroup *cgrp)\n{\n\tDEFINE_CGROUP_MGCTX(mgctx);\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup *dsct;\n\tstruct css_set *src_cset;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tpercpu_down_write(&cgroup_threadgroup_rwsem);\n\n\t/* look up all csses currently attached to @cgrp's subtree */\n\tspin_lock_irq(&css_set_lock);\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &dsct->cset_links, cset_link)\n\t\t\tcgroup_migrate_add_src(link->cset, dsct, &mgctx);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* NULL dst indicates self on default hierarchy */\n\tret = cgroup_migrate_prepare_dst(&mgctx);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(src_cset, &mgctx.preloaded_src_csets, mg_preload_node) {\n\t\tstruct task_struct *task, *ntask;\n\n\t\t/* all tasks in src_csets need to be migrated */\n\t\tlist_for_each_entry_safe(task, ntask, &src_cset->tasks, cg_list)\n\t\t\tcgroup_migrate_add_task(task, &mgctx);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tret = cgroup_migrate_execute(&mgctx);\nout_finish:\n\tcgroup_migrate_finish(&mgctx);\n\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\treturn ret;\n}\n\n/**\n * cgroup_lock_and_drain_offline - lock cgroup_mutex and drain offlined csses\n * @cgrp: root of the target subtree\n *\n * Because css offlining is asynchronous, userland may try to re-enable a\n * controller while the previous css is still around.  This function grabs\n * cgroup_mutex and drains the previous css instances of @cgrp's subtree.\n */\nvoid cgroup_lock_and_drain_offline(struct cgroup *cgrp)\n\t__acquires(&cgroup_mutex)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\nrestart:\n\tmutex_lock(&cgroup_mutex);\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\t\t\tDEFINE_WAIT(wait);\n\n\t\t\tif (!css || !percpu_ref_is_dying(&css->refcnt))\n\t\t\t\tcontinue;\n\n\t\t\tcgroup_get_live(dsct);\n\t\t\tprepare_to_wait(&dsct->offline_waitq, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\t\tmutex_unlock(&cgroup_mutex);\n\t\t\tschedule();\n\t\t\tfinish_wait(&dsct->offline_waitq, &wait);\n\n\t\t\tcgroup_put(dsct);\n\t\t\tgoto restart;\n\t\t}\n\t}\n}\n\n/**\n * cgroup_save_control - save control masks and dom_cgrp of a subtree\n * @cgrp: root of the target subtree\n *\n * Save ->subtree_control, ->subtree_ss_mask and ->dom_cgrp to the\n * respective old_ prefixed fields for @cgrp's subtree including @cgrp\n * itself.\n */\nstatic void cgroup_save_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tdsct->old_subtree_control = dsct->subtree_control;\n\t\tdsct->old_subtree_ss_mask = dsct->subtree_ss_mask;\n\t\tdsct->old_dom_cgrp = dsct->dom_cgrp;\n\t}\n}\n\n/**\n * cgroup_propagate_control - refresh control masks of a subtree\n * @cgrp: root of the target subtree\n *\n * For @cgrp and its subtree, ensure ->subtree_ss_mask matches\n * ->subtree_control and propagate controller availability through the\n * subtree so that descendants don't have unavailable controllers enabled.\n */\nstatic void cgroup_propagate_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tdsct->subtree_control &= cgroup_control(dsct);\n\t\tdsct->subtree_ss_mask =\n\t\t\tcgroup_calc_subtree_ss_mask(dsct->subtree_control,\n\t\t\t\t\t\t    cgroup_ss_mask(dsct));\n\t}\n}\n\n/**\n * cgroup_restore_control - restore control masks and dom_cgrp of a subtree\n * @cgrp: root of the target subtree\n *\n * Restore ->subtree_control, ->subtree_ss_mask and ->dom_cgrp from the\n * respective old_ prefixed fields for @cgrp's subtree including @cgrp\n * itself.\n */\nstatic void cgroup_restore_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tdsct->subtree_control = dsct->old_subtree_control;\n\t\tdsct->subtree_ss_mask = dsct->old_subtree_ss_mask;\n\t\tdsct->dom_cgrp = dsct->old_dom_cgrp;\n\t}\n}\n\nstatic bool css_visible(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tif (cgroup_control(cgrp) & (1 << ss->id))\n\t\treturn true;\n\tif (!(cgroup_ss_mask(cgrp) & (1 << ss->id)))\n\t\treturn false;\n\treturn cgroup_on_dfl(cgrp) && ss->implicit_on_dfl;\n}\n\n/**\n * cgroup_apply_control_enable - enable or show csses according to control\n * @cgrp: root of the target subtree\n *\n * Walk @cgrp's subtree and create new csses or make the existing ones\n * visible.  A css is created invisible if it's being implicitly enabled\n * through dependency.  An invisible css is made visible when the userland\n * explicitly enables it.\n *\n * Returns 0 on success, -errno on failure.  On failure, csses which have\n * been processed already aren't cleaned up.  The caller is responsible for\n * cleaning up with cgroup_apply_control_disable().\n */\nstatic int cgroup_apply_control_enable(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid, ret;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\n\t\t\tif (!(cgroup_ss_mask(dsct) & (1 << ss->id)))\n\t\t\t\tcontinue;\n\n\t\t\tif (!css) {\n\t\t\t\tcss = css_create(dsct, ss);\n\t\t\t\tif (IS_ERR(css))\n\t\t\t\t\treturn PTR_ERR(css);\n\t\t\t}\n\n\t\t\tWARN_ON_ONCE(percpu_ref_is_dying(&css->refcnt));\n\n\t\t\tif (css_visible(css)) {\n\t\t\t\tret = css_populate_dir(css);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * cgroup_apply_control_disable - kill or hide csses according to control\n * @cgrp: root of the target subtree\n *\n * Walk @cgrp's subtree and kill and hide csses so that they match\n * cgroup_ss_mask() and cgroup_visible_mask().\n *\n * A css is hidden when the userland requests it to be disabled while other\n * subsystems are still depending on it.  The css must not actively control\n * resources and be in the vanilla state if it's made visible again later.\n * Controllers which may be depended upon should provide ->css_reset() for\n * this purpose.\n */\nstatic void cgroup_apply_control_disable(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\n\t\t\tif (!css)\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON_ONCE(percpu_ref_is_dying(&css->refcnt));\n\n\t\t\tif (css->parent &&\n\t\t\t    !(cgroup_ss_mask(dsct) & (1 << ss->id))) {\n\t\t\t\tkill_css(css);\n\t\t\t} else if (!css_visible(css)) {\n\t\t\t\tcss_clear_dir(css);\n\t\t\t\tif (ss->css_reset)\n\t\t\t\t\tss->css_reset(css);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * cgroup_apply_control - apply control mask updates to the subtree\n * @cgrp: root of the target subtree\n *\n * subsystems can be enabled and disabled in a subtree using the following\n * steps.\n *\n * 1. Call cgroup_save_control() to stash the current state.\n * 2. Update ->subtree_control masks in the subtree as desired.\n * 3. Call cgroup_apply_control() to apply the changes.\n * 4. Optionally perform other related operations.\n * 5. Call cgroup_finalize_control() to finish up.\n *\n * This function implements step 3 and propagates the mask changes\n * throughout @cgrp's subtree, updates csses accordingly and perform\n * process migrations.\n */\nstatic int cgroup_apply_control(struct cgroup *cgrp)\n{\n\tint ret;\n\n\tcgroup_propagate_control(cgrp);\n\n\tret = cgroup_apply_control_enable(cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * At this point, cgroup_e_css_by_mask() results reflect the new csses\n\t * making the following cgroup_update_dfl_csses() properly update\n\t * css associations of all tasks in the subtree.\n\t */\n\tret = cgroup_update_dfl_csses(cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n/**\n * cgroup_finalize_control - finalize control mask update\n * @cgrp: root of the target subtree\n * @ret: the result of the update\n *\n * Finalize control mask update.  See cgroup_apply_control() for more info.\n */\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret)\n{\n\tif (ret) {\n\t\tcgroup_restore_control(cgrp);\n\t\tcgroup_propagate_control(cgrp);\n\t}\n\n\tcgroup_apply_control_disable(cgrp);\n}\n\nstatic int cgroup_vet_subtree_control_enable(struct cgroup *cgrp, u16 enable)\n{\n\tu16 domain_enable = enable & ~cgrp_dfl_threaded_ss_mask;\n\n\t/* if nothing is getting enabled, nothing to worry about */\n\tif (!enable)\n\t\treturn 0;\n\n\t/* can @cgrp host any resources? */\n\tif (!cgroup_is_valid_domain(cgrp->dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn 0;\n\n\tif (domain_enable) {\n\t\t/* can't enable domain controllers inside a thread subtree */\n\t\tif (cgroup_is_thread_root(cgrp) || cgroup_is_threaded(cgrp))\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\t/*\n\t\t * Threaded controllers can handle internal competitions\n\t\t * and are always allowed inside a (prospective) thread\n\t\t * subtree.\n\t\t */\n\t\tif (cgroup_can_be_thread_root(cgrp) || cgroup_is_threaded(cgrp))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Controllers can't be enabled for a cgroup with tasks to avoid\n\t * child cgroups competing against tasks.\n\t */\n\tif (cgroup_has_tasks(cgrp))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n/* change the enabled child controllers for a cgroup in the default hierarchy */\nstatic ssize_t cgroup_subtree_control_write(struct kernfs_open_file *of,\n\t\t\t\t\t    char *buf, size_t nbytes,\n\t\t\t\t\t    loff_t off)\n{\n\tu16 enable = 0, disable = 0;\n\tstruct cgroup *cgrp, *child;\n\tstruct cgroup_subsys *ss;\n\tchar *tok;\n\tint ssid, ret;\n\n\t/*\n\t * Parse input - space separated list of subsystem names prefixed\n\t * with either + or -.\n\t */\n\tbuf = strstrip(buf);\n\twhile ((tok = strsep(&buf, \" \"))) {\n\t\tif (tok[0] == '\\0')\n\t\t\tcontinue;\n\t\tdo_each_subsys_mask(ss, ssid, ~cgrp_dfl_inhibit_ss_mask) {\n\t\t\tif (!cgroup_ssid_enabled(ssid) ||\n\t\t\t    strcmp(tok + 1, ss->name))\n\t\t\t\tcontinue;\n\n\t\t\tif (*tok == '+') {\n\t\t\t\tenable |= 1 << ssid;\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t} else if (*tok == '-') {\n\t\t\t\tdisable |= 1 << ssid;\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t} else {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t} while_each_subsys_mask();\n\t\tif (ssid == CGROUP_SUBSYS_COUNT)\n\t\t\treturn -EINVAL;\n\t}\n\n\tcgrp = cgroup_kn_lock_live(of->kn, true);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tfor_each_subsys(ss, ssid) {\n\t\tif (enable & (1 << ssid)) {\n\t\t\tif (cgrp->subtree_control & (1 << ssid)) {\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(cgroup_control(cgrp) & (1 << ssid))) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else if (disable & (1 << ssid)) {\n\t\t\tif (!(cgrp->subtree_control & (1 << ssid))) {\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* a child has it enabled? */\n\t\t\tcgroup_for_each_live_child(child, cgrp) {\n\t\t\t\tif (child->subtree_control & (1 << ssid)) {\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!enable && !disable) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tret = cgroup_vet_subtree_control_enable(cgrp, enable);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* save and update control masks and prepare csses */\n\tcgroup_save_control(cgrp);\n\n\tcgrp->subtree_control |= enable;\n\tcgrp->subtree_control &= ~disable;\n\n\tret = cgroup_apply_control(cgrp);\n\tcgroup_finalize_control(cgrp, ret);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tkernfs_activate(cgrp->kn);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\treturn ret ?: nbytes;\n}\n\n/**\n * cgroup_enable_threaded - make @cgrp threaded\n * @cgrp: the target cgroup\n *\n * Called when \"threaded\" is written to the cgroup.type interface file and\n * tries to make @cgrp threaded and join the parent's resource domain.\n * This function is never called on the root cgroup as cgroup.type doesn't\n * exist on it.\n */\nstatic int cgroup_enable_threaded(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup *dom_cgrp = parent->dom_cgrp;\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* noop if already threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn 0;\n\n\t/*\n\t * If @cgroup is populated or has domain controllers enabled, it\n\t * can't be switched.  While the below cgroup_can_be_thread_root()\n\t * test can catch the same conditions, that's only when @parent is\n\t * not mixable, so let's check it explicitly.\n\t */\n\tif (cgroup_is_populated(cgrp) ||\n\t    cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn -EOPNOTSUPP;\n\n\t/* we're joining the parent's domain, ensure its validity */\n\tif (!cgroup_is_valid_domain(dom_cgrp) ||\n\t    !cgroup_can_be_thread_root(dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * The following shouldn't cause actual migrations and should\n\t * always succeed.\n\t */\n\tcgroup_save_control(cgrp);\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp)\n\t\tif (dsct == cgrp || cgroup_is_threaded(dsct))\n\t\t\tdsct->dom_cgrp = dom_cgrp;\n\n\tret = cgroup_apply_control(cgrp);\n\tif (!ret)\n\t\tparent->nr_threaded_children++;\n\n\tcgroup_finalize_control(cgrp, ret);\n\treturn ret;\n}\n\nstatic int cgroup_type_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tif (cgroup_is_threaded(cgrp))\n\t\tseq_puts(seq, \"threaded\\n\");\n\telse if (!cgroup_is_valid_domain(cgrp))\n\t\tseq_puts(seq, \"domain invalid\\n\");\n\telse if (cgroup_is_thread_root(cgrp))\n\t\tseq_puts(seq, \"domain threaded\\n\");\n\telse\n\t\tseq_puts(seq, \"domain\\n\");\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_type_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\t/* only switching to threaded mode is supported */\n\tif (strcmp(strstrip(buf), \"threaded\"))\n\t\treturn -EINVAL;\n\n\t/* drain dying csses before we re-apply (threaded) subtree control */\n\tcgrp = cgroup_kn_lock_live(of->kn, true);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\t/* threaded can only be enabled */\n\tret = cgroup_enable_threaded(cgrp);\n\n\tcgroup_kn_unlock(of->kn);\n\treturn ret ?: nbytes;\n}\n\nstatic int cgroup_max_descendants_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tint descendants = READ_ONCE(cgrp->max_descendants);\n\n\tif (descendants == INT_MAX)\n\t\tseq_puts(seq, \"max\\n\");\n\telse\n\t\tseq_printf(seq, \"%d\\n\", descendants);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_max_descendants_write(struct kernfs_open_file *of,\n\t\t\t\t\t   char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tint descendants;\n\tssize_t ret;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, \"max\")) {\n\t\tdescendants = INT_MAX;\n\t} else {\n\t\tret = kstrtoint(buf, 0, &descendants);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (descendants < 0)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgrp->max_descendants = descendants;\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic int cgroup_max_depth_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tint depth = READ_ONCE(cgrp->max_depth);\n\n\tif (depth == INT_MAX)\n\t\tseq_puts(seq, \"max\\n\");\n\telse\n\t\tseq_printf(seq, \"%d\\n\", depth);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_max_depth_write(struct kernfs_open_file *of,\n\t\t\t\t      char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tssize_t ret;\n\tint depth;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, \"max\")) {\n\t\tdepth = INT_MAX;\n\t} else {\n\t\tret = kstrtoint(buf, 0, &depth);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (depth < 0)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgrp->max_depth = depth;\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic int cgroup_events_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tseq_printf(seq, \"populated %d\\n\", cgroup_is_populated(cgrp));\n\tseq_printf(seq, \"frozen %d\\n\", test_bit(CGRP_FROZEN, &cgrp->flags));\n\n\treturn 0;\n}\n\nstatic int cgroup_stat_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgroup = seq_css(seq)->cgroup;\n\n\tseq_printf(seq, \"nr_descendants %d\\n\",\n\t\t   cgroup->nr_descendants);\n\tseq_printf(seq, \"nr_dying_descendants %d\\n\",\n\t\t   cgroup->nr_dying_descendants);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cgroup_extra_stat_show(struct seq_file *seq,\n\t\t\t\t\t\t struct cgroup *cgrp, int ssid)\n{\n\tstruct cgroup_subsys *ss = cgroup_subsys[ssid];\n\tstruct cgroup_subsys_state *css;\n\tint ret;\n\n\tif (!ss->css_extra_stat_show)\n\t\treturn 0;\n\n\tcss = cgroup_tryget_css(cgrp, ss);\n\tif (!css)\n\t\treturn 0;\n\n\tret = ss->css_extra_stat_show(seq, css);\n\tcss_put(css);\n\treturn ret;\n}\n\nstatic int cpu_stat_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup __maybe_unused *cgrp = seq_css(seq)->cgroup;\n\tint ret = 0;\n\n\tcgroup_base_stat_cputime_show(seq);\n#ifdef CONFIG_CGROUP_SCHED\n\tret = cgroup_extra_stat_show(seq, cgrp, cpu_cgrp_id);\n#endif\n\treturn ret;\n}\n\n#ifdef CONFIG_PSI\nstatic int cgroup_io_pressure_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tstruct psi_group *psi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\n\treturn psi_show(seq, psi, PSI_IO);\n}\nstatic int cgroup_memory_pressure_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tstruct psi_group *psi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\n\treturn psi_show(seq, psi, PSI_MEM);\n}\nstatic int cgroup_cpu_pressure_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tstruct psi_group *psi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\n\treturn psi_show(seq, psi, PSI_CPU);\n}\n\nstatic ssize_t cgroup_pressure_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t\t  size_t nbytes, enum psi_res res)\n{\n\tstruct psi_trigger *new;\n\tstruct cgroup *cgrp;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tcgroup_get(cgrp);\n\tcgroup_kn_unlock(of->kn);\n\n\tnew = psi_trigger_create(&cgrp->psi, buf, nbytes, res);\n\tif (IS_ERR(new)) {\n\t\tcgroup_put(cgrp);\n\t\treturn PTR_ERR(new);\n\t}\n\n\tpsi_trigger_replace(&of->priv, new);\n\n\tcgroup_put(cgrp);\n\n\treturn nbytes;\n}\n\nstatic ssize_t cgroup_io_pressure_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes,\n\t\t\t\t\t  loff_t off)\n{\n\treturn cgroup_pressure_write(of, buf, nbytes, PSI_IO);\n}\n\nstatic ssize_t cgroup_memory_pressure_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes,\n\t\t\t\t\t  loff_t off)\n{\n\treturn cgroup_pressure_write(of, buf, nbytes, PSI_MEM);\n}\n\nstatic ssize_t cgroup_cpu_pressure_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes,\n\t\t\t\t\t  loff_t off)\n{\n\treturn cgroup_pressure_write(of, buf, nbytes, PSI_CPU);\n}\n\nstatic __poll_t cgroup_pressure_poll(struct kernfs_open_file *of,\n\t\t\t\t\t  poll_table *pt)\n{\n\treturn psi_trigger_poll(&of->priv, of->file, pt);\n}\n\nstatic void cgroup_pressure_release(struct kernfs_open_file *of)\n{\n\tpsi_trigger_replace(&of->priv, NULL);\n}\n#endif /* CONFIG_PSI */\n\nstatic int cgroup_freeze_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tseq_printf(seq, \"%d\\n\", cgrp->freezer.freeze);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_freeze_write(struct kernfs_open_file *of,\n\t\t\t\t   char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tssize_t ret;\n\tint freeze;\n\n\tret = kstrtoint(strstrip(buf), 0, &freeze);\n\tif (ret)\n\t\treturn ret;\n\n\tif (freeze < 0 || freeze > 1)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgroup_freeze(cgrp, freeze);\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic int cgroup_file_open(struct kernfs_open_file *of)\n{\n\tstruct cftype *cft = of->kn->priv;\n\n\tif (cft->open)\n\t\treturn cft->open(of);\n\treturn 0;\n}\n\nstatic void cgroup_file_release(struct kernfs_open_file *of)\n{\n\tstruct cftype *cft = of->kn->priv;\n\n\tif (cft->release)\n\t\tcft->release(of);\n}\n\nstatic ssize_t cgroup_file_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tstruct cgroup_namespace *ns = current->nsproxy->cgroup_ns;\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of->kn->priv;\n\tstruct cgroup_subsys_state *css;\n\tint ret;\n\n\tif (!nbytes)\n\t\treturn 0;\n\n\t/*\n\t * If namespaces are delegation boundaries, disallow writes to\n\t * files in an non-init namespace root from inside the namespace\n\t * except for the files explicitly marked delegatable -\n\t * cgroup.procs and cgroup.subtree_control.\n\t */\n\tif ((cgrp->root->flags & CGRP_ROOT_NS_DELEGATE) &&\n\t    !(cft->flags & CFTYPE_NS_DELEGATABLE) &&\n\t    ns != &init_cgroup_ns && ns->root_cset->dfl_cgrp == cgrp)\n\t\treturn -EPERM;\n\n\tif (cft->write)\n\t\treturn cft->write(of, buf, nbytes, off);\n\n\t/*\n\t * kernfs guarantees that a file isn't deleted with operations in\n\t * flight, which means that the matching css is and stays alive and\n\t * doesn't need to be pinned.  The RCU locking is not necessary\n\t * either.  It's just for the convenience of using cgroup_css().\n\t */\n\trcu_read_lock();\n\tcss = cgroup_css(cgrp, cft->ss);\n\trcu_read_unlock();\n\n\tif (cft->write_u64) {\n\t\tunsigned long long v;\n\t\tret = kstrtoull(buf, 0, &v);\n\t\tif (!ret)\n\t\t\tret = cft->write_u64(css, cft, v);\n\t} else if (cft->write_s64) {\n\t\tlong long v;\n\t\tret = kstrtoll(buf, 0, &v);\n\t\tif (!ret)\n\t\t\tret = cft->write_s64(css, cft, v);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret ?: nbytes;\n}\n\nstatic __poll_t cgroup_file_poll(struct kernfs_open_file *of, poll_table *pt)\n{\n\tstruct cftype *cft = of->kn->priv;\n\n\tif (cft->poll)\n\t\treturn cft->poll(of, pt);\n\n\treturn kernfs_generic_poll(of, pt);\n}\n\nstatic void *cgroup_seqfile_start(struct seq_file *seq, loff_t *ppos)\n{\n\treturn seq_cft(seq)->seq_start(seq, ppos);\n}\n\nstatic void *cgroup_seqfile_next(struct seq_file *seq, void *v, loff_t *ppos)\n{\n\treturn seq_cft(seq)->seq_next(seq, v, ppos);\n}\n\nstatic void cgroup_seqfile_stop(struct seq_file *seq, void *v)\n{\n\tif (seq_cft(seq)->seq_stop)\n\t\tseq_cft(seq)->seq_stop(seq, v);\n}\n\nstatic int cgroup_seqfile_show(struct seq_file *m, void *arg)\n{\n\tstruct cftype *cft = seq_cft(m);\n\tstruct cgroup_subsys_state *css = seq_css(m);\n\n\tif (cft->seq_show)\n\t\treturn cft->seq_show(m, arg);\n\n\tif (cft->read_u64)\n\t\tseq_printf(m, \"%llu\\n\", cft->read_u64(css, cft));\n\telse if (cft->read_s64)\n\t\tseq_printf(m, \"%lld\\n\", cft->read_s64(css, cft));\n\telse\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic struct kernfs_ops cgroup_kf_single_ops = {\n\t.atomic_write_len\t= PAGE_SIZE,\n\t.open\t\t\t= cgroup_file_open,\n\t.release\t\t= cgroup_file_release,\n\t.write\t\t\t= cgroup_file_write,\n\t.poll\t\t\t= cgroup_file_poll,\n\t.seq_show\t\t= cgroup_seqfile_show,\n};\n\nstatic struct kernfs_ops cgroup_kf_ops = {\n\t.atomic_write_len\t= PAGE_SIZE,\n\t.open\t\t\t= cgroup_file_open,\n\t.release\t\t= cgroup_file_release,\n\t.write\t\t\t= cgroup_file_write,\n\t.poll\t\t\t= cgroup_file_poll,\n\t.seq_start\t\t= cgroup_seqfile_start,\n\t.seq_next\t\t= cgroup_seqfile_next,\n\t.seq_stop\t\t= cgroup_seqfile_stop,\n\t.seq_show\t\t= cgroup_seqfile_show,\n};\n\n/* set uid and gid of cgroup dirs and files to that of the creator */\nstatic int cgroup_kn_set_ugid(struct kernfs_node *kn)\n{\n\tstruct iattr iattr = { .ia_valid = ATTR_UID | ATTR_GID,\n\t\t\t       .ia_uid = current_fsuid(),\n\t\t\t       .ia_gid = current_fsgid(), };\n\n\tif (uid_eq(iattr.ia_uid, GLOBAL_ROOT_UID) &&\n\t    gid_eq(iattr.ia_gid, GLOBAL_ROOT_GID))\n\t\treturn 0;\n\n\treturn kernfs_setattr(kn, &iattr);\n}\n\nstatic void cgroup_file_notify_timer(struct timer_list *timer)\n{\n\tcgroup_file_notify(container_of(timer, struct cgroup_file,\n\t\t\t\t\tnotify_timer));\n}\n\nstatic int cgroup_add_file(struct cgroup_subsys_state *css, struct cgroup *cgrp,\n\t\t\t   struct cftype *cft)\n{\n\tchar name[CGROUP_FILE_NAME_MAX];\n\tstruct kernfs_node *kn;\n\tstruct lock_class_key *key = NULL;\n\tint ret;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tkey = &cft->lockdep_key;\n#endif\n\tkn = __kernfs_create_file(cgrp->kn, cgroup_file_name(cgrp, cft, name),\n\t\t\t\t  cgroup_file_mode(cft),\n\t\t\t\t  GLOBAL_ROOT_UID, GLOBAL_ROOT_GID,\n\t\t\t\t  0, cft->kf_ops, cft,\n\t\t\t\t  NULL, key);\n\tif (IS_ERR(kn))\n\t\treturn PTR_ERR(kn);\n\n\tret = cgroup_kn_set_ugid(kn);\n\tif (ret) {\n\t\tkernfs_remove(kn);\n\t\treturn ret;\n\t}\n\n\tif (cft->file_offset) {\n\t\tstruct cgroup_file *cfile = (void *)css + cft->file_offset;\n\n\t\ttimer_setup(&cfile->notify_timer, cgroup_file_notify_timer, 0);\n\n\t\tspin_lock_irq(&cgroup_file_kn_lock);\n\t\tcfile->kn = kn;\n\t\tspin_unlock_irq(&cgroup_file_kn_lock);\n\t}\n\n\treturn 0;\n}\n\n/**\n * cgroup_addrm_files - add or remove files to a cgroup directory\n * @css: the target css\n * @cgrp: the target cgroup (usually css->cgroup)\n * @cfts: array of cftypes to be added\n * @is_add: whether to add or remove\n *\n * Depending on @is_add, add or remove files defined by @cfts on @cgrp.\n * For removals, this function never fails.\n */\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add)\n{\n\tstruct cftype *cft, *cft_end = NULL;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\nrestart:\n\tfor (cft = cfts; cft != cft_end && cft->name[0] != '\\0'; cft++) {\n\t\t/* does cft->flags tell us to skip this file on @cgrp? */\n\t\tif ((cft->flags & __CFTYPE_ONLY_ON_DFL) && !cgroup_on_dfl(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & __CFTYPE_NOT_ON_DFL) && cgroup_on_dfl(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_NOT_ON_ROOT) && !cgroup_parent(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_ONLY_ON_ROOT) && cgroup_parent(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_DEBUG) && !cgroup_debug)\n\t\t\tcontinue;\n\t\tif (is_add) {\n\t\t\tret = cgroup_add_file(css, cgrp, cft);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"%s: failed to add %s, err=%d\\n\",\n\t\t\t\t\t__func__, cft->name, ret);\n\t\t\t\tcft_end = cft;\n\t\t\t\tis_add = false;\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t} else {\n\t\t\tcgroup_rm_file(cgrp, cft);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int cgroup_apply_cftypes(struct cftype *cfts, bool is_add)\n{\n\tstruct cgroup_subsys *ss = cfts[0].ss;\n\tstruct cgroup *root = &ss->root->cgrp;\n\tstruct cgroup_subsys_state *css;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* add/rm files for all cgroups created before */\n\tcss_for_each_descendant_pre(css, cgroup_css(root, ss)) {\n\t\tstruct cgroup *cgrp = css->cgroup;\n\n\t\tif (!(css->flags & CSS_VISIBLE))\n\t\t\tcontinue;\n\n\t\tret = cgroup_addrm_files(css, cgrp, cfts, is_add);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (is_add && !ret)\n\t\tkernfs_activate(root->kn);\n\treturn ret;\n}\n\nstatic void cgroup_exit_cftypes(struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft->name[0] != '\\0'; cft++) {\n\t\t/* free copy for custom atomic_write_len, see init_cftypes() */\n\t\tif (cft->max_write_len && cft->max_write_len != PAGE_SIZE)\n\t\t\tkfree(cft->kf_ops);\n\t\tcft->kf_ops = NULL;\n\t\tcft->ss = NULL;\n\n\t\t/* revert flags set by cgroup core while adding @cfts */\n\t\tcft->flags &= ~(__CFTYPE_ONLY_ON_DFL | __CFTYPE_NOT_ON_DFL);\n\t}\n}\n\nstatic int cgroup_init_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft->name[0] != '\\0'; cft++) {\n\t\tstruct kernfs_ops *kf_ops;\n\n\t\tWARN_ON(cft->ss || cft->kf_ops);\n\n\t\tif (cft->seq_start)\n\t\t\tkf_ops = &cgroup_kf_ops;\n\t\telse\n\t\t\tkf_ops = &cgroup_kf_single_ops;\n\n\t\t/*\n\t\t * Ugh... if @cft wants a custom max_write_len, we need to\n\t\t * make a copy of kf_ops to set its atomic_write_len.\n\t\t */\n\t\tif (cft->max_write_len && cft->max_write_len != PAGE_SIZE) {\n\t\t\tkf_ops = kmemdup(kf_ops, sizeof(*kf_ops), GFP_KERNEL);\n\t\t\tif (!kf_ops) {\n\t\t\t\tcgroup_exit_cftypes(cfts);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tkf_ops->atomic_write_len = cft->max_write_len;\n\t\t}\n\n\t\tcft->kf_ops = kf_ops;\n\t\tcft->ss = ss;\n\t}\n\n\treturn 0;\n}\n\nstatic int cgroup_rm_cftypes_locked(struct cftype *cfts)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!cfts || !cfts[0].ss)\n\t\treturn -ENOENT;\n\n\tlist_del(&cfts->node);\n\tcgroup_apply_cftypes(cfts, false);\n\tcgroup_exit_cftypes(cfts);\n\treturn 0;\n}\n\n/**\n * cgroup_rm_cftypes - remove an array of cftypes from a subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Unregister @cfts.  Files described by @cfts are removed from all\n * existing cgroups and all future cgroups won't have them either.  This\n * function can be called anytime whether @cfts' subsys is attached or not.\n *\n * Returns 0 on successful unregistration, -ENOENT if @cfts is not\n * registered.\n */\nint cgroup_rm_cftypes(struct cftype *cfts)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = cgroup_rm_cftypes_locked(cfts);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\n\n/**\n * cgroup_add_cftypes - add an array of cftypes to a subsystem\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Register @cfts to @ss.  Files described by @cfts are created for all\n * existing cgroups to which @ss is attached and all future cgroups will\n * have them too.  This function can be called anytime whether @ss is\n * attached or not.\n *\n * Returns 0 on successful registration, -errno on failure.  Note that this\n * function currently returns 0 as long as @cfts registration is successful\n * even if some file creation attempts on existing cgroups fail.\n */\nstatic int cgroup_add_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tint ret;\n\n\tif (!cgroup_ssid_enabled(ss->id))\n\t\treturn 0;\n\n\tif (!cfts || cfts[0].name[0] == '\\0')\n\t\treturn 0;\n\n\tret = cgroup_init_cftypes(ss, cfts);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tlist_add_tail(&cfts->node, &ss->cfts);\n\tret = cgroup_apply_cftypes(cfts, true);\n\tif (ret)\n\t\tcgroup_rm_cftypes_locked(cfts);\n\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\n\n/**\n * cgroup_add_dfl_cftypes - add an array of cftypes for default hierarchy\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Similar to cgroup_add_cftypes() but the added files are only used for\n * the default hierarchy.\n */\nint cgroup_add_dfl_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft && cft->name[0] != '\\0'; cft++)\n\t\tcft->flags |= __CFTYPE_ONLY_ON_DFL;\n\treturn cgroup_add_cftypes(ss, cfts);\n}\n\n/**\n * cgroup_add_legacy_cftypes - add an array of cftypes for legacy hierarchies\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Similar to cgroup_add_cftypes() but the added files are only used for\n * the legacy hierarchies.\n */\nint cgroup_add_legacy_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft && cft->name[0] != '\\0'; cft++)\n\t\tcft->flags |= __CFTYPE_NOT_ON_DFL;\n\treturn cgroup_add_cftypes(ss, cfts);\n}\n\n/**\n * cgroup_file_notify - generate a file modified event for a cgroup_file\n * @cfile: target cgroup_file\n *\n * @cfile must have been obtained by setting cftype->file_offset.\n */\nvoid cgroup_file_notify(struct cgroup_file *cfile)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cgroup_file_kn_lock, flags);\n\tif (cfile->kn) {\n\t\tunsigned long last = cfile->notified_at;\n\t\tunsigned long next = last + CGROUP_FILE_NOTIFY_MIN_INTV;\n\n\t\tif (time_in_range(jiffies, last, next)) {\n\t\t\ttimer_reduce(&cfile->notify_timer, next);\n\t\t} else {\n\t\t\tkernfs_notify(cfile->kn);\n\t\t\tcfile->notified_at = jiffies;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&cgroup_file_kn_lock, flags);\n}\n\n/**\n * css_next_child - find the next child of a given css\n * @pos: the current position (%NULL to initiate traversal)\n * @parent: css whose children to walk\n *\n * This function returns the next child of @parent and should be called\n * under either cgroup_mutex or RCU read lock.  The only requirement is\n * that @parent and @pos are accessible.  The next sibling is guaranteed to\n * be returned regardless of their states.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *css_next_child(struct cgroup_subsys_state *pos,\n\t\t\t\t\t   struct cgroup_subsys_state *parent)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/*\n\t * @pos could already have been unlinked from the sibling list.\n\t * Once a cgroup is removed, its ->sibling.next is no longer\n\t * updated when its next sibling changes.  CSS_RELEASED is set when\n\t * @pos is taken off list, at which time its next pointer is valid,\n\t * and, as releases are serialized, the one pointed to by the next\n\t * pointer is guaranteed to not have started release yet.  This\n\t * implies that if we observe !CSS_RELEASED on @pos in this RCU\n\t * critical section, the one pointed to by its next pointer is\n\t * guaranteed to not have finished its RCU grace period even if we\n\t * have dropped rcu_read_lock() inbetween iterations.\n\t *\n\t * If @pos has CSS_RELEASED set, its next pointer can't be\n\t * dereferenced; however, as each css is given a monotonically\n\t * increasing unique serial number and always appended to the\n\t * sibling list, the next one can be found by walking the parent's\n\t * children until the first css with higher serial number than\n\t * @pos's.  While this path can be slower, it happens iff iteration\n\t * races against release and the race window is very small.\n\t */\n\tif (!pos) {\n\t\tnext = list_entry_rcu(parent->children.next, struct cgroup_subsys_state, sibling);\n\t} else if (likely(!(pos->flags & CSS_RELEASED))) {\n\t\tnext = list_entry_rcu(pos->sibling.next, struct cgroup_subsys_state, sibling);\n\t} else {\n\t\tlist_for_each_entry_rcu(next, &parent->children, sibling,\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex))\n\t\t\tif (next->serial_nr > pos->serial_nr)\n\t\t\t\tbreak;\n\t}\n\n\t/*\n\t * @next, if not pointing to the head, can be dereferenced and is\n\t * the next sibling.\n\t */\n\tif (&next->sibling != &parent->children)\n\t\treturn next;\n\treturn NULL;\n}\n\n/**\n * css_next_descendant_pre - find the next descendant for pre-order walk\n * @pos: the current position (%NULL to initiate traversal)\n * @root: css whose descendants to walk\n *\n * To be used by css_for_each_descendant_pre().  Find the next descendant\n * to visit for pre-order traversal of @root's descendants.  @root is\n * included in the iteration and the first node to be visited.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct next descendant as long\n * as both @pos and @root are accessible and @pos is a descendant of @root.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *\ncss_next_descendant_pre(struct cgroup_subsys_state *pos,\n\t\t\tstruct cgroup_subsys_state *root)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/* if first iteration, visit @root */\n\tif (!pos)\n\t\treturn root;\n\n\t/* visit the first child if exists */\n\tnext = css_next_child(NULL, pos);\n\tif (next)\n\t\treturn next;\n\n\t/* no child, visit my or the closest ancestor's next sibling */\n\twhile (pos != root) {\n\t\tnext = css_next_child(pos, pos->parent);\n\t\tif (next)\n\t\t\treturn next;\n\t\tpos = pos->parent;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(css_next_descendant_pre);\n\n/**\n * css_rightmost_descendant - return the rightmost descendant of a css\n * @pos: css of interest\n *\n * Return the rightmost descendant of @pos.  If there's no descendant, @pos\n * is returned.  This can be used during pre-order traversal to skip\n * subtree of @pos.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct rightmost descendant as\n * long as @pos is accessible.\n */\nstruct cgroup_subsys_state *\ncss_rightmost_descendant(struct cgroup_subsys_state *pos)\n{\n\tstruct cgroup_subsys_state *last, *tmp;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\tdo {\n\t\tlast = pos;\n\t\t/* ->prev isn't RCU safe, walk ->next till the end */\n\t\tpos = NULL;\n\t\tcss_for_each_child(tmp, last)\n\t\t\tpos = tmp;\n\t} while (pos);\n\n\treturn last;\n}\n\nstatic struct cgroup_subsys_state *\ncss_leftmost_descendant(struct cgroup_subsys_state *pos)\n{\n\tstruct cgroup_subsys_state *last;\n\n\tdo {\n\t\tlast = pos;\n\t\tpos = css_next_child(NULL, pos);\n\t} while (pos);\n\n\treturn last;\n}\n\n/**\n * css_next_descendant_post - find the next descendant for post-order walk\n * @pos: the current position (%NULL to initiate traversal)\n * @root: css whose descendants to walk\n *\n * To be used by css_for_each_descendant_post().  Find the next descendant\n * to visit for post-order traversal of @root's descendants.  @root is\n * included in the iteration and the last node to be visited.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct next descendant as long\n * as both @pos and @cgroup are accessible and @pos is a descendant of\n * @cgroup.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *\ncss_next_descendant_post(struct cgroup_subsys_state *pos,\n\t\t\t struct cgroup_subsys_state *root)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/* if first iteration, visit leftmost descendant which may be @root */\n\tif (!pos)\n\t\treturn css_leftmost_descendant(root);\n\n\t/* if we visited @root, we're done */\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/* if there's an unvisited sibling, visit its leftmost descendant */\n\tnext = css_next_child(pos, pos->parent);\n\tif (next)\n\t\treturn css_leftmost_descendant(next);\n\n\t/* no sibling left, visit parent */\n\treturn pos->parent;\n}\n\n/**\n * css_has_online_children - does a css have online children\n * @css: the target css\n *\n * Returns %true if @css has any online children; otherwise, %false.  This\n * function can be called from any context but the caller is responsible\n * for synchronizing against on/offlining as necessary.\n */\nbool css_has_online_children(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys_state *child;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tcss_for_each_child(child, css) {\n\t\tif (child->flags & CSS_ONLINE) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic struct css_set *css_task_iter_next_css_set(struct css_task_iter *it)\n{\n\tstruct list_head *l;\n\tstruct cgrp_cset_link *link;\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* find the next threaded cset */\n\tif (it->tcset_pos) {\n\t\tl = it->tcset_pos->next;\n\n\t\tif (l != it->tcset_head) {\n\t\t\tit->tcset_pos = l;\n\t\t\treturn container_of(l, struct css_set,\n\t\t\t\t\t    threaded_csets_node);\n\t\t}\n\n\t\tit->tcset_pos = NULL;\n\t}\n\n\t/* find the next cset */\n\tl = it->cset_pos;\n\tl = l->next;\n\tif (l == it->cset_head) {\n\t\tit->cset_pos = NULL;\n\t\treturn NULL;\n\t}\n\n\tif (it->ss) {\n\t\tcset = container_of(l, struct css_set, e_cset_node[it->ss->id]);\n\t} else {\n\t\tlink = list_entry(l, struct cgrp_cset_link, cset_link);\n\t\tcset = link->cset;\n\t}\n\n\tit->cset_pos = l;\n\n\t/* initialize threaded css_set walking */\n\tif (it->flags & CSS_TASK_ITER_THREADED) {\n\t\tif (it->cur_dcset)\n\t\t\tput_css_set_locked(it->cur_dcset);\n\t\tit->cur_dcset = cset;\n\t\tget_css_set(cset);\n\n\t\tit->tcset_head = &cset->threaded_csets;\n\t\tit->tcset_pos = &cset->threaded_csets;\n\t}\n\n\treturn cset;\n}\n\n/**\n * css_task_iter_advance_css_set - advance a task itererator to the next css_set\n * @it: the iterator to advance\n *\n * Advance @it to the next css_set to walk.\n */\nstatic void css_task_iter_advance_css_set(struct css_task_iter *it)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* Advance to the next non-empty css_set and find first non-empty tasks list*/\n\twhile ((cset = css_task_iter_next_css_set(it))) {\n\t\tif (!list_empty(&cset->tasks)) {\n\t\t\tit->cur_tasks_head = &cset->tasks;\n\t\t\tbreak;\n\t\t} else if (!list_empty(&cset->mg_tasks)) {\n\t\t\tit->cur_tasks_head = &cset->mg_tasks;\n\t\t\tbreak;\n\t\t} else if (!list_empty(&cset->dying_tasks)) {\n\t\t\tit->cur_tasks_head = &cset->dying_tasks;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!cset) {\n\t\tit->task_pos = NULL;\n\t\treturn;\n\t}\n\tit->task_pos = it->cur_tasks_head->next;\n\n\t/*\n\t * We don't keep css_sets locked across iteration steps and thus\n\t * need to take steps to ensure that iteration can be resumed after\n\t * the lock is re-acquired.  Iteration is performed at two levels -\n\t * css_sets and tasks in them.\n\t *\n\t * Once created, a css_set never leaves its cgroup lists, so a\n\t * pinned css_set is guaranteed to stay put and we can resume\n\t * iteration afterwards.\n\t *\n\t * Tasks may leave @cset across iteration steps.  This is resolved\n\t * by registering each iterator with the css_set currently being\n\t * walked and making css_set_move_task() advance iterators whose\n\t * next task is leaving.\n\t */\n\tif (it->cur_cset) {\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t}\n\tget_css_set(cset);\n\tit->cur_cset = cset;\n\tlist_add(&it->iters_node, &cset->task_iters);\n}\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (it->task_pos == &task->cg_list) {\n\t\tit->task_pos = it->task_pos->next;\n\t\tit->flags |= CSS_TASK_ITER_SKIPPED;\n\t}\n}\n\nstatic void css_task_iter_advance(struct css_task_iter *it)\n{\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&css_set_lock);\nrepeat:\n\tif (it->task_pos) {\n\t\t/*\n\t\t * Advance iterator to find next entry. We go through cset\n\t\t * tasks, mg_tasks and dying_tasks, when consumed we move onto\n\t\t * the next cset.\n\t\t */\n\t\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\t\tit->flags &= ~CSS_TASK_ITER_SKIPPED;\n\t\telse\n\t\t\tit->task_pos = it->task_pos->next;\n\n\t\tif (it->task_pos == &it->cur_cset->tasks) {\n\t\t\tit->cur_tasks_head = &it->cur_cset->mg_tasks;\n\t\t\tit->task_pos = it->cur_tasks_head->next;\n\t\t}\n\t\tif (it->task_pos == &it->cur_cset->mg_tasks) {\n\t\t\tit->cur_tasks_head = &it->cur_cset->dying_tasks;\n\t\t\tit->task_pos = it->cur_tasks_head->next;\n\t\t}\n\t\tif (it->task_pos == &it->cur_cset->dying_tasks)\n\t\t\tcss_task_iter_advance_css_set(it);\n\t} else {\n\t\t/* called from start, proceed to the first cset */\n\t\tcss_task_iter_advance_css_set(it);\n\t}\n\n\tif (!it->task_pos)\n\t\treturn;\n\n\ttask = list_entry(it->task_pos, struct task_struct, cg_list);\n\n\tif (it->flags & CSS_TASK_ITER_PROCS) {\n\t\t/* if PROCS, skip over tasks which aren't group leaders */\n\t\tif (!thread_group_leader(task))\n\t\t\tgoto repeat;\n\n\t\t/* and dying leaders w/o live member threads */\n\t\tif (it->cur_tasks_head == &it->cur_cset->dying_tasks &&\n\t\t    !atomic_read(&task->signal->live))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* skip all dying ones */\n\t\tif (it->cur_tasks_head == &it->cur_cset->dying_tasks)\n\t\t\tgoto repeat;\n\t}\n}\n\n/**\n * css_task_iter_start - initiate task iteration\n * @css: the css to walk tasks of\n * @flags: CSS_TASK_ITER_* flags\n * @it: the task iterator to use\n *\n * Initiate iteration through the tasks of @css.  The caller can call\n * css_task_iter_next() to walk through the tasks until the function\n * returns NULL.  On completion of iteration, css_task_iter_end() must be\n * called.\n */\nvoid css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}\n\n/**\n * css_task_iter_next - return the next task for the iterator\n * @it: the task iterator being iterated\n *\n * The \"next\" function for task iteration.  @it should have been\n * initialized via css_task_iter_start().  Returns NULL when the iteration\n * reaches the end.\n */\nstruct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}\n\n/**\n * css_task_iter_end - finish task iteration\n * @it: the task iterator to finish\n *\n * Finish task iteration started by css_task_iter_start().\n */\nvoid css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}\n\nstatic void cgroup_procs_release(struct kernfs_open_file *of)\n{\n\tif (of->priv) {\n\t\tcss_task_iter_end(of->priv);\n\t\tkfree(of->priv);\n\t}\n}\n\nstatic void *cgroup_procs_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct css_task_iter *it = of->priv;\n\n\tif (pos)\n\t\t(*pos)++;\n\n\treturn css_task_iter_next(it);\n}\n\nstatic void *__cgroup_procs_start(struct seq_file *s, loff_t *pos,\n\t\t\t\t  unsigned int iter_flags)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct cgroup *cgrp = seq_css(s)->cgroup;\n\tstruct css_task_iter *it = of->priv;\n\n\t/*\n\t * When a seq_file is seeked, it's always traversed sequentially\n\t * from position 0, so we can simply keep iterating on !0 *pos.\n\t */\n\tif (!it) {\n\t\tif (WARN_ON_ONCE((*pos)))\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tit = kzalloc(sizeof(*it), GFP_KERNEL);\n\t\tif (!it)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tof->priv = it;\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t} else if (!(*pos)) {\n\t\tcss_task_iter_end(it);\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t} else\n\t\treturn it->cur_task;\n\n\treturn cgroup_procs_next(s, NULL, NULL);\n}\n\nstatic void *cgroup_procs_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct cgroup *cgrp = seq_css(s)->cgroup;\n\n\t/*\n\t * All processes of a threaded subtree belong to the domain cgroup\n\t * of the subtree.  Only threads can be distributed across the\n\t * subtree.  Reject reads on cgroup.procs in the subtree proper.\n\t * They're always empty anyway.\n\t */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\treturn __cgroup_procs_start(s, pos, CSS_TASK_ITER_PROCS |\n\t\t\t\t\t    CSS_TASK_ITER_THREADED);\n}\n\nstatic int cgroup_procs_show(struct seq_file *s, void *v)\n{\n\tseq_printf(s, \"%d\\n\", task_pid_vnr(v));\n\treturn 0;\n}\n\nstatic int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)\n{\n\tint ret;\n\tstruct inode *inode;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tinode = kernfs_get_inode(sb, cgrp->procs_file.kn);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tret = inode_permission(inode, MAY_WRITE);\n\tiput(inode);\n\treturn ret;\n}\n\nstatic int cgroup_procs_write_permission(struct cgroup *src_cgrp,\n\t\t\t\t\t struct cgroup *dst_cgrp,\n\t\t\t\t\t struct super_block *sb)\n{\n\tstruct cgroup_namespace *ns = current->nsproxy->cgroup_ns;\n\tstruct cgroup *com_cgrp = src_cgrp;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* find the common ancestor */\n\twhile (!cgroup_is_descendant(dst_cgrp, com_cgrp))\n\t\tcom_cgrp = cgroup_parent(com_cgrp);\n\n\t/* %current should be authorized to migrate to the common ancestor */\n\tret = cgroup_may_write(com_cgrp, sb);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If namespaces are delegation boundaries, %current must be able\n\t * to see both source and destination cgroups from its namespace.\n\t */\n\tif ((cgrp_dfl_root.flags & CGRP_ROOT_NS_DELEGATE) &&\n\t    (!cgroup_is_descendant(src_cgrp, ns->root_cset->dfl_cgrp) ||\n\t     !cgroup_is_descendant(dst_cgrp, ns->root_cset->dfl_cgrp)))\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nstatic int cgroup_attach_permissions(struct cgroup *src_cgrp,\n\t\t\t\t     struct cgroup *dst_cgrp,\n\t\t\t\t     struct super_block *sb, bool threadgroup)\n{\n\tint ret = 0;\n\n\tret = cgroup_procs_write_permission(src_cgrp, dst_cgrp, sb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cgroup_migrate_vet_dst(dst_cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!threadgroup && (src_cgrp->dom_cgrp != dst_cgrp->dom_cgrp))\n\t\tret = -EOPNOTSUPP;\n\n\treturn ret;\n}\n\nstatic ssize_t cgroup_procs_write(struct kernfs_open_file *of,\n\t\t\t\t  char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *src_cgrp, *dst_cgrp;\n\tstruct task_struct *task;\n\tssize_t ret;\n\tbool locked;\n\n\tdst_cgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!dst_cgrp)\n\t\treturn -ENODEV;\n\n\ttask = cgroup_procs_write_start(buf, true, &locked);\n\tret = PTR_ERR_OR_ZERO(task);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* find the source cgroup */\n\tspin_lock_irq(&css_set_lock);\n\tsrc_cgrp = task_cgroup_from_root(task, &cgrp_dfl_root);\n\tspin_unlock_irq(&css_set_lock);\n\n\tret = cgroup_attach_permissions(src_cgrp, dst_cgrp,\n\t\t\t\t\tof->file->f_path.dentry->d_sb, true);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tret = cgroup_attach_task(dst_cgrp, task, true);\n\nout_finish:\n\tcgroup_procs_write_finish(task, locked);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\n\treturn ret ?: nbytes;\n}\n\nstatic void *cgroup_threads_start(struct seq_file *s, loff_t *pos)\n{\n\treturn __cgroup_procs_start(s, pos, 0);\n}\n\nstatic ssize_t cgroup_threads_write(struct kernfs_open_file *of,\n\t\t\t\t    char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *src_cgrp, *dst_cgrp;\n\tstruct task_struct *task;\n\tssize_t ret;\n\tbool locked;\n\n\tbuf = strstrip(buf);\n\n\tdst_cgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!dst_cgrp)\n\t\treturn -ENODEV;\n\n\ttask = cgroup_procs_write_start(buf, false, &locked);\n\tret = PTR_ERR_OR_ZERO(task);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* find the source cgroup */\n\tspin_lock_irq(&css_set_lock);\n\tsrc_cgrp = task_cgroup_from_root(task, &cgrp_dfl_root);\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* thread migrations follow the cgroup.procs delegation rule */\n\tret = cgroup_attach_permissions(src_cgrp, dst_cgrp,\n\t\t\t\t\tof->file->f_path.dentry->d_sb, false);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tret = cgroup_attach_task(dst_cgrp, task, false);\n\nout_finish:\n\tcgroup_procs_write_finish(task, locked);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\n\treturn ret ?: nbytes;\n}\n\n/* cgroup core interface files for the default hierarchy */\nstatic struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};\n\n/*\n * css destruction is four-stage process.\n *\n * 1. Destruction starts.  Killing of the percpu_ref is initiated.\n *    Implemented in kill_css().\n *\n * 2. When the percpu_ref is confirmed to be visible as killed on all CPUs\n *    and thus css_tryget_online() is guaranteed to fail, the css can be\n *    offlined by invoking offline_css().  After offlining, the base ref is\n *    put.  Implemented in css_killed_work_fn().\n *\n * 3. When the percpu_ref reaches zero, the only possible remaining\n *    accessors are inside RCU read sections.  css_release() schedules the\n *    RCU callback.\n *\n * 4. After the grace period, the css can be freed.  Implemented in\n *    css_free_work_fn().\n *\n * It is actually hairier because both step 2 and 4 require process context\n * and thus involve punting to css->destroy_work adding two additional\n * steps to the already complex sequence.\n */\nstatic void css_free_rwork_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css = container_of(to_rcu_work(work),\n\t\t\t\tstruct cgroup_subsys_state, destroy_rwork);\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tpercpu_ref_exit(&css->refcnt);\n\n\tif (ss) {\n\t\t/* css free path */\n\t\tstruct cgroup_subsys_state *parent = css->parent;\n\t\tint id = css->id;\n\n\t\tss->css_free(css);\n\t\tcgroup_idr_remove(&ss->css_idr, id);\n\t\tcgroup_put(cgrp);\n\n\t\tif (parent)\n\t\t\tcss_put(parent);\n\t} else {\n\t\t/* cgroup free path */\n\t\tatomic_dec(&cgrp->root->nr_cgrps);\n\t\tcgroup1_pidlist_destroy_all(cgrp);\n\t\tcancel_work_sync(&cgrp->release_agent_work);\n\n\t\tif (cgroup_parent(cgrp)) {\n\t\t\t/*\n\t\t\t * We get a ref to the parent, and put the ref when\n\t\t\t * this cgroup is being freed, so it's guaranteed\n\t\t\t * that the parent won't be destroyed before its\n\t\t\t * children.\n\t\t\t */\n\t\t\tcgroup_put(cgroup_parent(cgrp));\n\t\t\tkernfs_put(cgrp->kn);\n\t\t\tpsi_cgroup_free(cgrp);\n\t\t\tif (cgroup_on_dfl(cgrp))\n\t\t\t\tcgroup_rstat_exit(cgrp);\n\t\t\tkfree(cgrp);\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is root cgroup's refcnt reaching zero,\n\t\t\t * which indicates that the root should be\n\t\t\t * released.\n\t\t\t */\n\t\t\tcgroup_destroy_root(cgrp->root);\n\t\t}\n\t}\n}\n\nstatic void css_release_work_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(work, struct cgroup_subsys_state, destroy_work);\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tcss->flags |= CSS_RELEASED;\n\tlist_del_rcu(&css->sibling);\n\n\tif (ss) {\n\t\t/* css release path */\n\t\tif (!list_empty(&css->rstat_css_node)) {\n\t\t\tcgroup_rstat_flush(cgrp);\n\t\t\tlist_del_rcu(&css->rstat_css_node);\n\t\t}\n\n\t\tcgroup_idr_replace(&ss->css_idr, NULL, css->id);\n\t\tif (ss->css_released)\n\t\t\tss->css_released(css);\n\t} else {\n\t\tstruct cgroup *tcgrp;\n\n\t\t/* cgroup release path */\n\t\tTRACE_CGROUP_PATH(release, cgrp);\n\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcgroup_rstat_flush(cgrp);\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\tfor (tcgrp = cgroup_parent(cgrp); tcgrp;\n\t\t     tcgrp = cgroup_parent(tcgrp))\n\t\t\ttcgrp->nr_dying_descendants--;\n\t\tspin_unlock_irq(&css_set_lock);\n\n\t\t/*\n\t\t * There are two control paths which try to determine\n\t\t * cgroup from dentry without going through kernfs -\n\t\t * cgroupstats_build() and css_tryget_online_from_dir().\n\t\t * Those are supported by RCU protecting clearing of\n\t\t * cgrp->kn->priv backpointer.\n\t\t */\n\t\tif (cgrp->kn)\n\t\t\tRCU_INIT_POINTER(*(void __rcu __force **)&cgrp->kn->priv,\n\t\t\t\t\t NULL);\n\t}\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tINIT_RCU_WORK(&css->destroy_rwork, css_free_rwork_fn);\n\tqueue_rcu_work(cgroup_destroy_wq, &css->destroy_rwork);\n}\n\nstatic void css_release(struct percpu_ref *ref)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(ref, struct cgroup_subsys_state, refcnt);\n\n\tINIT_WORK(&css->destroy_work, css_release_work_fn);\n\tqueue_work(cgroup_destroy_wq, &css->destroy_work);\n}\n\nstatic void init_and_link_css(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup_subsys *ss, struct cgroup *cgrp)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcgroup_get_live(cgrp);\n\n\tmemset(css, 0, sizeof(*css));\n\tcss->cgroup = cgrp;\n\tcss->ss = ss;\n\tcss->id = -1;\n\tINIT_LIST_HEAD(&css->sibling);\n\tINIT_LIST_HEAD(&css->children);\n\tINIT_LIST_HEAD(&css->rstat_css_node);\n\tcss->serial_nr = css_serial_nr_next++;\n\tatomic_set(&css->online_cnt, 0);\n\n\tif (cgroup_parent(cgrp)) {\n\t\tcss->parent = cgroup_css(cgroup_parent(cgrp), ss);\n\t\tcss_get(css->parent);\n\t}\n\n\tif (cgroup_on_dfl(cgrp) && ss->css_rstat_flush)\n\t\tlist_add_rcu(&css->rstat_css_node, &cgrp->rstat_css_list);\n\n\tBUG_ON(cgroup_css(cgrp, ss));\n}\n\n/* invoke ->css_online() on a new CSS and mark it online if successful */\nstatic int online_css(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (ss->css_online)\n\t\tret = ss->css_online(css);\n\tif (!ret) {\n\t\tcss->flags |= CSS_ONLINE;\n\t\trcu_assign_pointer(css->cgroup->subsys[ss->id], css);\n\n\t\tatomic_inc(&css->online_cnt);\n\t\tif (css->parent)\n\t\t\tatomic_inc(&css->parent->online_cnt);\n\t}\n\treturn ret;\n}\n\n/* if the CSS is online, invoke ->css_offline() on it and mark it offline */\nstatic void offline_css(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!(css->flags & CSS_ONLINE))\n\t\treturn;\n\n\tif (ss->css_offline)\n\t\tss->css_offline(css);\n\n\tcss->flags &= ~CSS_ONLINE;\n\tRCU_INIT_POINTER(css->cgroup->subsys[ss->id], NULL);\n\n\twake_up_all(&css->cgroup->offline_waitq);\n}\n\n/**\n * css_create - create a cgroup_subsys_state\n * @cgrp: the cgroup new css will be associated with\n * @ss: the subsys of new css\n *\n * Create a new css associated with @cgrp - @ss pair.  On success, the new\n * css is online and installed in @cgrp.  This function doesn't create the\n * interface files.  Returns 0 on success, -errno on failure.\n */\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *parent_css = cgroup_css(parent, ss);\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcss = ss->css_alloc(parent_css);\n\tif (!css)\n\t\tcss = ERR_PTR(-ENOMEM);\n\tif (IS_ERR(css))\n\t\treturn css;\n\n\tinit_and_link_css(css, ss, cgrp);\n\n\terr = percpu_ref_init(&css->refcnt, css_release, 0, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_free_css;\n\n\terr = cgroup_idr_alloc(&ss->css_idr, NULL, 2, 0, GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto err_free_css;\n\tcss->id = err;\n\n\t/* @css is ready to be brought online now, make it visible */\n\tlist_add_tail_rcu(&css->sibling, &parent_css->children);\n\tcgroup_idr_replace(&ss->css_idr, css, css->id);\n\n\terr = online_css(css);\n\tif (err)\n\t\tgoto err_list_del;\n\n\tif (ss->broken_hierarchy && !ss->warned_broken_hierarchy &&\n\t    cgroup_parent(parent)) {\n\t\tpr_warn(\"%s (%d) created nested cgroup for controller \\\"%s\\\" which has incomplete hierarchy support. Nested cgroups may change behavior in the future.\\n\",\n\t\t\tcurrent->comm, current->pid, ss->name);\n\t\tif (!strcmp(ss->name, \"memory\"))\n\t\t\tpr_warn(\"\\\"memory\\\" requires setting use_hierarchy to 1 on the root\\n\");\n\t\tss->warned_broken_hierarchy = true;\n\t}\n\n\treturn css;\n\nerr_list_del:\n\tlist_del_rcu(&css->sibling);\nerr_free_css:\n\tlist_del_rcu(&css->rstat_css_node);\n\tINIT_RCU_WORK(&css->destroy_rwork, css_free_rwork_fn);\n\tqueue_rcu_work(cgroup_destroy_wq, &css->destroy_rwork);\n\treturn ERR_PTR(err);\n}\n\n/*\n * The returned cgroup is fully initialized including its control mask, but\n * it isn't associated with its kernfs_node and doesn't have the control\n * mask applied.\n */\nstatic struct cgroup *cgroup_create(struct cgroup *parent, const char *name,\n\t\t\t\t    umode_t mode)\n{\n\tstruct cgroup_root *root = parent->root;\n\tstruct cgroup *cgrp, *tcgrp;\n\tstruct kernfs_node *kn;\n\tint level = parent->level + 1;\n\tint ret;\n\n\t/* allocate the cgroup and its ID, 0 is reserved for the root */\n\tcgrp = kzalloc(struct_size(cgrp, ancestor_ids, (level + 1)),\n\t\t       GFP_KERNEL);\n\tif (!cgrp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = percpu_ref_init(&cgrp->self.refcnt, css_release, 0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out_free_cgrp;\n\n\tif (cgroup_on_dfl(parent)) {\n\t\tret = cgroup_rstat_init(cgrp);\n\t\tif (ret)\n\t\t\tgoto out_cancel_ref;\n\t}\n\n\t/* create the directory */\n\tkn = kernfs_create_dir(parent->kn, name, mode, cgrp);\n\tif (IS_ERR(kn)) {\n\t\tret = PTR_ERR(kn);\n\t\tgoto out_stat_exit;\n\t}\n\tcgrp->kn = kn;\n\n\tinit_cgroup_housekeeping(cgrp);\n\n\tcgrp->self.parent = &parent->self;\n\tcgrp->root = root;\n\tcgrp->level = level;\n\n\tret = psi_cgroup_alloc(cgrp);\n\tif (ret)\n\t\tgoto out_kernfs_remove;\n\n\tret = cgroup_bpf_inherit(cgrp);\n\tif (ret)\n\t\tgoto out_psi_free;\n\n\t/*\n\t * New cgroup inherits effective freeze counter, and\n\t * if the parent has to be frozen, the child has too.\n\t */\n\tcgrp->freezer.e_freeze = parent->freezer.e_freeze;\n\tif (cgrp->freezer.e_freeze) {\n\t\t/*\n\t\t * Set the CGRP_FREEZE flag, so when a process will be\n\t\t * attached to the child cgroup, it will become frozen.\n\t\t * At this point the new cgroup is unpopulated, so we can\n\t\t * consider it frozen immediately.\n\t\t */\n\t\tset_bit(CGRP_FREEZE, &cgrp->flags);\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\tfor (tcgrp = cgrp; tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\tcgrp->ancestor_ids[tcgrp->level] = cgroup_id(tcgrp);\n\n\t\tif (tcgrp != cgrp) {\n\t\t\ttcgrp->nr_descendants++;\n\n\t\t\t/*\n\t\t\t * If the new cgroup is frozen, all ancestor cgroups\n\t\t\t * get a new frozen descendant, but their state can't\n\t\t\t * change because of this.\n\t\t\t */\n\t\t\tif (cgrp->freezer.e_freeze)\n\t\t\t\ttcgrp->freezer.nr_frozen_descendants++;\n\t\t}\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (notify_on_release(parent))\n\t\tset_bit(CGRP_NOTIFY_ON_RELEASE, &cgrp->flags);\n\n\tif (test_bit(CGRP_CPUSET_CLONE_CHILDREN, &parent->flags))\n\t\tset_bit(CGRP_CPUSET_CLONE_CHILDREN, &cgrp->flags);\n\n\tcgrp->self.serial_nr = css_serial_nr_next++;\n\n\t/* allocation complete, commit to creation */\n\tlist_add_tail_rcu(&cgrp->self.sibling, &cgroup_parent(cgrp)->self.children);\n\tatomic_inc(&root->nr_cgrps);\n\tcgroup_get_live(parent);\n\n\t/*\n\t * On the default hierarchy, a child doesn't automatically inherit\n\t * subtree_control from the parent.  Each is configured manually.\n\t */\n\tif (!cgroup_on_dfl(cgrp))\n\t\tcgrp->subtree_control = cgroup_control(cgrp);\n\n\tcgroup_propagate_control(cgrp);\n\n\treturn cgrp;\n\nout_psi_free:\n\tpsi_cgroup_free(cgrp);\nout_kernfs_remove:\n\tkernfs_remove(cgrp->kn);\nout_stat_exit:\n\tif (cgroup_on_dfl(parent))\n\t\tcgroup_rstat_exit(cgrp);\nout_cancel_ref:\n\tpercpu_ref_exit(&cgrp->self.refcnt);\nout_free_cgrp:\n\tkfree(cgrp);\n\treturn ERR_PTR(ret);\n}\n\nstatic bool cgroup_check_hierarchy_limits(struct cgroup *parent)\n{\n\tstruct cgroup *cgroup;\n\tint ret = false;\n\tint level = 1;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tfor (cgroup = parent; cgroup; cgroup = cgroup_parent(cgroup)) {\n\t\tif (cgroup->nr_descendants >= cgroup->max_descendants)\n\t\t\tgoto fail;\n\n\t\tif (level > cgroup->max_depth)\n\t\t\tgoto fail;\n\n\t\tlevel++;\n\t}\n\n\tret = true;\nfail:\n\treturn ret;\n}\n\nint cgroup_mkdir(struct kernfs_node *parent_kn, const char *name, umode_t mode)\n{\n\tstruct cgroup *parent, *cgrp;\n\tint ret;\n\n\t/* do not accept '\\n' to prevent making /proc/<pid>/cgroup unparsable */\n\tif (strchr(name, '\\n'))\n\t\treturn -EINVAL;\n\n\tparent = cgroup_kn_lock_live(parent_kn, false);\n\tif (!parent)\n\t\treturn -ENODEV;\n\n\tif (!cgroup_check_hierarchy_limits(parent)) {\n\t\tret = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\tcgrp = cgroup_create(parent, name, mode);\n\tif (IS_ERR(cgrp)) {\n\t\tret = PTR_ERR(cgrp);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * This extra ref will be put in cgroup_free_fn() and guarantees\n\t * that @cgrp->kn is always accessible.\n\t */\n\tkernfs_get(cgrp->kn);\n\n\tret = cgroup_kn_set_ugid(cgrp->kn);\n\tif (ret)\n\t\tgoto out_destroy;\n\n\tret = css_populate_dir(&cgrp->self);\n\tif (ret)\n\t\tgoto out_destroy;\n\n\tret = cgroup_apply_control_enable(cgrp);\n\tif (ret)\n\t\tgoto out_destroy;\n\n\tTRACE_CGROUP_PATH(mkdir, cgrp);\n\n\t/* let's create and online css's */\n\tkernfs_activate(cgrp->kn);\n\n\tret = 0;\n\tgoto out_unlock;\n\nout_destroy:\n\tcgroup_destroy_locked(cgrp);\nout_unlock:\n\tcgroup_kn_unlock(parent_kn);\n\treturn ret;\n}\n\n/*\n * This is called when the refcnt of a css is confirmed to be killed.\n * css_tryget_online() is now guaranteed to fail.  Tell the subsystem to\n * initate destruction and put the css ref from kill_css().\n */\nstatic void css_killed_work_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(work, struct cgroup_subsys_state, destroy_work);\n\n\tmutex_lock(&cgroup_mutex);\n\n\tdo {\n\t\toffline_css(css);\n\t\tcss_put(css);\n\t\t/* @css can't go away while we're holding cgroup_mutex */\n\t\tcss = css->parent;\n\t} while (css && atomic_dec_and_test(&css->online_cnt));\n\n\tmutex_unlock(&cgroup_mutex);\n}\n\n/* css kill confirmation processing requires process context, bounce */\nstatic void css_killed_ref_fn(struct percpu_ref *ref)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(ref, struct cgroup_subsys_state, refcnt);\n\n\tif (atomic_dec_and_test(&css->online_cnt)) {\n\t\tINIT_WORK(&css->destroy_work, css_killed_work_fn);\n\t\tqueue_work(cgroup_destroy_wq, &css->destroy_work);\n\t}\n}\n\n/**\n * kill_css - destroy a css\n * @css: css to destroy\n *\n * This function initiates destruction of @css by removing cgroup interface\n * files and putting its base reference.  ->css_offline() will be invoked\n * asynchronously once css_tryget_online() is guaranteed to fail and when\n * the reference count reaches zero, @css will be released.\n */\nstatic void kill_css(struct cgroup_subsys_state *css)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (css->flags & CSS_DYING)\n\t\treturn;\n\n\tcss->flags |= CSS_DYING;\n\n\t/*\n\t * This must happen before css is disassociated with its cgroup.\n\t * See seq_css() for details.\n\t */\n\tcss_clear_dir(css);\n\n\t/*\n\t * Killing would put the base ref, but we need to keep it alive\n\t * until after ->css_offline().\n\t */\n\tcss_get(css);\n\n\t/*\n\t * cgroup core guarantees that, by the time ->css_offline() is\n\t * invoked, no new css reference will be given out via\n\t * css_tryget_online().  We can't simply call percpu_ref_kill() and\n\t * proceed to offlining css's because percpu_ref_kill() doesn't\n\t * guarantee that the ref is seen as killed on all CPUs on return.\n\t *\n\t * Use percpu_ref_kill_and_confirm() to get notifications as each\n\t * css is confirmed to be seen as killed on all CPUs.\n\t */\n\tpercpu_ref_kill_and_confirm(&css->refcnt, css_killed_ref_fn);\n}\n\n/**\n * cgroup_destroy_locked - the first stage of cgroup destruction\n * @cgrp: cgroup to be destroyed\n *\n * css's make use of percpu refcnts whose killing latency shouldn't be\n * exposed to userland and are RCU protected.  Also, cgroup core needs to\n * guarantee that css_tryget_online() won't succeed by the time\n * ->css_offline() is invoked.  To satisfy all the requirements,\n * destruction is implemented in the following two steps.\n *\n * s1. Verify @cgrp can be destroyed and mark it dying.  Remove all\n *     userland visible parts and start killing the percpu refcnts of\n *     css's.  Set up so that the next stage will be kicked off once all\n *     the percpu refcnts are confirmed to be killed.\n *\n * s2. Invoke ->css_offline(), mark the cgroup dead and proceed with the\n *     rest of destruction.  Once all cgroup references are gone, the\n *     cgroup is RCU-freed.\n *\n * This function implements s1.  After this step, @cgrp is gone as far as\n * the userland is concerned and a new cgroup with the same name may be\n * created.  As cgroup doesn't care about the names internally, this\n * doesn't cause any problem.\n */\nstatic int cgroup_destroy_locked(struct cgroup *cgrp)\n\t__releases(&cgroup_mutex) __acquires(&cgroup_mutex)\n{\n\tstruct cgroup *tcgrp, *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *css;\n\tstruct cgrp_cset_link *link;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/*\n\t * Only migration can raise populated from zero and we're already\n\t * holding cgroup_mutex.\n\t */\n\tif (cgroup_is_populated(cgrp))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Make sure there's no live children.  We can't test emptiness of\n\t * ->self.children as dead children linger on it while being\n\t * drained; otherwise, \"rmdir parent/child parent\" may fail.\n\t */\n\tif (css_has_online_children(&cgrp->self))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Mark @cgrp and the associated csets dead.  The former prevents\n\t * further task migration and child creation by disabling\n\t * cgroup_lock_live_group().  The latter makes the csets ignored by\n\t * the migration path.\n\t */\n\tcgrp->self.flags &= ~CSS_ONLINE;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tlink->cset->dead = true;\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* initiate massacre of all css's */\n\tfor_each_css(css, ssid, cgrp)\n\t\tkill_css(css);\n\n\t/* clear and remove @cgrp dir, @cgrp has an extra ref on its kn */\n\tcss_clear_dir(&cgrp->self);\n\tkernfs_remove(cgrp->kn);\n\n\tif (parent && cgroup_is_threaded(cgrp))\n\t\tparent->nr_threaded_children--;\n\n\tspin_lock_irq(&css_set_lock);\n\tfor (tcgrp = cgroup_parent(cgrp); tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\ttcgrp->nr_descendants--;\n\t\ttcgrp->nr_dying_descendants++;\n\t\t/*\n\t\t * If the dying cgroup is frozen, decrease frozen descendants\n\t\t * counters of ancestor cgroups.\n\t\t */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\ttcgrp->freezer.nr_frozen_descendants--;\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tcgroup1_check_for_release(parent);\n\n\tcgroup_bpf_offline(cgrp);\n\n\t/* put the base reference */\n\tpercpu_ref_kill(&cgrp->self.refcnt);\n\n\treturn 0;\n};\n\nint cgroup_rmdir(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\tint ret = 0;\n\n\tcgrp = cgroup_kn_lock_live(kn, false);\n\tif (!cgrp)\n\t\treturn 0;\n\n\tret = cgroup_destroy_locked(cgrp);\n\tif (!ret)\n\t\tTRACE_CGROUP_PATH(rmdir, cgrp);\n\n\tcgroup_kn_unlock(kn);\n\treturn ret;\n}\n\nstatic struct kernfs_syscall_ops cgroup_kf_syscall_ops = {\n\t.show_options\t\t= cgroup_show_options,\n\t.mkdir\t\t\t= cgroup_mkdir,\n\t.rmdir\t\t\t= cgroup_rmdir,\n\t.show_path\t\t= cgroup_show_path,\n};\n\nstatic void __init cgroup_init_subsys(struct cgroup_subsys *ss, bool early)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tpr_debug(\"Initializing cgroup subsys %s\\n\", ss->name);\n\n\tmutex_lock(&cgroup_mutex);\n\n\tidr_init(&ss->css_idr);\n\tINIT_LIST_HEAD(&ss->cfts);\n\n\t/* Create the root cgroup state for this subsystem */\n\tss->root = &cgrp_dfl_root;\n\tcss = ss->css_alloc(cgroup_css(&cgrp_dfl_root.cgrp, ss));\n\t/* We don't handle early failures gracefully */\n\tBUG_ON(IS_ERR(css));\n\tinit_and_link_css(css, ss, &cgrp_dfl_root.cgrp);\n\n\t/*\n\t * Root csses are never destroyed and we can't initialize\n\t * percpu_ref during early init.  Disable refcnting.\n\t */\n\tcss->flags |= CSS_NO_REF;\n\n\tif (early) {\n\t\t/* allocation can't be done safely during early init */\n\t\tcss->id = 1;\n\t} else {\n\t\tcss->id = cgroup_idr_alloc(&ss->css_idr, css, 1, 2, GFP_KERNEL);\n\t\tBUG_ON(css->id < 0);\n\t}\n\n\t/* Update the init_css_set to contain a subsys\n\t * pointer to this state - since the subsystem is\n\t * newly registered, all tasks and hence the\n\t * init_css_set is in the subsystem's root cgroup. */\n\tinit_css_set.subsys[ss->id] = css;\n\n\thave_fork_callback |= (bool)ss->fork << ss->id;\n\thave_exit_callback |= (bool)ss->exit << ss->id;\n\thave_release_callback |= (bool)ss->release << ss->id;\n\thave_canfork_callback |= (bool)ss->can_fork << ss->id;\n\n\t/* At system boot, before all subsystems have been\n\t * registered, no tasks have been forked, so we don't\n\t * need to invoke fork callbacks here. */\n\tBUG_ON(!list_empty(&init_task.tasks));\n\n\tBUG_ON(online_css(css));\n\n\tmutex_unlock(&cgroup_mutex);\n}\n\n/**\n * cgroup_init_early - cgroup initialization at system boot\n *\n * Initialize cgroups at system boot, and initialize any\n * subsystems that request early init.\n */\nint __init cgroup_init_early(void)\n{\n\tstatic struct cgroup_fs_context __initdata ctx;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tctx.root = &cgrp_dfl_root;\n\tinit_cgroup_root(&ctx);\n\tcgrp_dfl_root.cgrp.self.flags |= CSS_NO_REF;\n\n\tRCU_INIT_POINTER(init_task.cgroups, &init_css_set);\n\n\tfor_each_subsys(ss, i) {\n\t\tWARN(!ss->css_alloc || !ss->css_free || ss->name || ss->id,\n\t\t     \"invalid cgroup_subsys %d:%s css_alloc=%p css_free=%p id:name=%d:%s\\n\",\n\t\t     i, cgroup_subsys_name[i], ss->css_alloc, ss->css_free,\n\t\t     ss->id, ss->name);\n\t\tWARN(strlen(cgroup_subsys_name[i]) > MAX_CGROUP_TYPE_NAMELEN,\n\t\t     \"cgroup_subsys_name %s too long\\n\", cgroup_subsys_name[i]);\n\n\t\tss->id = i;\n\t\tss->name = cgroup_subsys_name[i];\n\t\tif (!ss->legacy_name)\n\t\t\tss->legacy_name = cgroup_subsys_name[i];\n\n\t\tif (ss->early_init)\n\t\t\tcgroup_init_subsys(ss, true);\n\t}\n\treturn 0;\n}\n\nstatic u16 cgroup_disable_mask __initdata;\n\n/**\n * cgroup_init - cgroup initialization\n *\n * Register cgroup filesystem and /proc file, and initialize\n * any subsystems that didn't request early init.\n */\nint __init cgroup_init(void)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tBUILD_BUG_ON(CGROUP_SUBSYS_COUNT > 16);\n\tBUG_ON(cgroup_init_cftypes(NULL, cgroup_base_files));\n\tBUG_ON(cgroup_init_cftypes(NULL, cgroup1_base_files));\n\n\tcgroup_rstat_boot();\n\n\t/*\n\t * The latency of the synchronize_rcu() is too high for cgroups,\n\t * avoid it at the cost of forcing all readers into the slow path.\n\t */\n\trcu_sync_enter_start(&cgroup_threadgroup_rwsem.rss);\n\n\tget_user_ns(init_cgroup_ns.user_ns);\n\n\tmutex_lock(&cgroup_mutex);\n\n\t/*\n\t * Add init_css_set to the hash table so that dfl_root can link to\n\t * it during init.\n\t */\n\thash_add(css_set_table, &init_css_set.hlist,\n\t\t css_set_hash(init_css_set.subsys));\n\n\tBUG_ON(cgroup_setup_root(&cgrp_dfl_root, 0));\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tif (ss->early_init) {\n\t\t\tstruct cgroup_subsys_state *css =\n\t\t\t\tinit_css_set.subsys[ss->id];\n\n\t\t\tcss->id = cgroup_idr_alloc(&ss->css_idr, css, 1, 2,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tBUG_ON(css->id < 0);\n\t\t} else {\n\t\t\tcgroup_init_subsys(ss, false);\n\t\t}\n\n\t\tlist_add_tail(&init_css_set.e_cset_node[ssid],\n\t\t\t      &cgrp_dfl_root.cgrp.e_csets[ssid]);\n\n\t\t/*\n\t\t * Setting dfl_root subsys_mask needs to consider the\n\t\t * disabled flag and cftype registration needs kmalloc,\n\t\t * both of which aren't available during early_init.\n\t\t */\n\t\tif (cgroup_disable_mask & (1 << ssid)) {\n\t\t\tstatic_branch_disable(cgroup_subsys_enabled_key[ssid]);\n\t\t\tprintk(KERN_INFO \"Disabling %s control group subsystem\\n\",\n\t\t\t       ss->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cgroup1_ssid_disabled(ssid))\n\t\t\tprintk(KERN_INFO \"Disabling %s control group subsystem in v1 mounts\\n\",\n\t\t\t       ss->name);\n\n\t\tcgrp_dfl_root.subsys_mask |= 1 << ss->id;\n\n\t\t/* implicit controllers must be threaded too */\n\t\tWARN_ON(ss->implicit_on_dfl && !ss->threaded);\n\n\t\tif (ss->implicit_on_dfl)\n\t\t\tcgrp_dfl_implicit_ss_mask |= 1 << ss->id;\n\t\telse if (!ss->dfl_cftypes)\n\t\t\tcgrp_dfl_inhibit_ss_mask |= 1 << ss->id;\n\n\t\tif (ss->threaded)\n\t\t\tcgrp_dfl_threaded_ss_mask |= 1 << ss->id;\n\n\t\tif (ss->dfl_cftypes == ss->legacy_cftypes) {\n\t\t\tWARN_ON(cgroup_add_cftypes(ss, ss->dfl_cftypes));\n\t\t} else {\n\t\t\tWARN_ON(cgroup_add_dfl_cftypes(ss, ss->dfl_cftypes));\n\t\t\tWARN_ON(cgroup_add_legacy_cftypes(ss, ss->legacy_cftypes));\n\t\t}\n\n\t\tif (ss->bind)\n\t\t\tss->bind(init_css_set.subsys[ssid]);\n\n\t\tmutex_lock(&cgroup_mutex);\n\t\tcss_populate_dir(init_css_set.subsys[ssid]);\n\t\tmutex_unlock(&cgroup_mutex);\n\t}\n\n\t/* init_css_set.subsys[] has been updated, re-hash */\n\thash_del(&init_css_set.hlist);\n\thash_add(css_set_table, &init_css_set.hlist,\n\t\t css_set_hash(init_css_set.subsys));\n\n\tWARN_ON(sysfs_create_mount_point(fs_kobj, \"cgroup\"));\n\tWARN_ON(register_filesystem(&cgroup_fs_type));\n\tWARN_ON(register_filesystem(&cgroup2_fs_type));\n\tWARN_ON(!proc_create_single(\"cgroups\", 0, NULL, proc_cgroupstats_show));\n#ifdef CONFIG_CPUSETS\n\tWARN_ON(register_filesystem(&cpuset_fs_type));\n#endif\n\n\treturn 0;\n}\n\nstatic int __init cgroup_wq_init(void)\n{\n\t/*\n\t * There isn't much point in executing destruction path in\n\t * parallel.  Good chunk is serialized with cgroup_mutex anyway.\n\t * Use 1 for @max_active.\n\t *\n\t * We would prefer to do this in cgroup_init() above, but that\n\t * is called before init_workqueues(): so leave this until after.\n\t */\n\tcgroup_destroy_wq = alloc_workqueue(\"cgroup_destroy\", 0, 1);\n\tBUG_ON(!cgroup_destroy_wq);\n\treturn 0;\n}\ncore_initcall(cgroup_wq_init);\n\nvoid cgroup_path_from_kernfs_id(u64 id, char *buf, size_t buflen)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = kernfs_find_and_get_node_by_id(cgrp_dfl_root.kf_root, id);\n\tif (!kn)\n\t\treturn;\n\tkernfs_path(kn, buf, buflen);\n\tkernfs_put(kn);\n}\n\n/*\n * proc_cgroup_show()\n *  - Print task's cgroup paths into seq_file, one line for each hierarchy\n *  - Used for /proc/<pid>/cgroup.\n */\nint proc_cgroup_show(struct seq_file *m, struct pid_namespace *ns,\n\t\t     struct pid *pid, struct task_struct *tsk)\n{\n\tchar *buf;\n\tint retval;\n\tstruct cgroup_root *root;\n\n\tretval = -ENOMEM;\n\tbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto out;\n\n\tmutex_lock(&cgroup_mutex);\n\tspin_lock_irq(&css_set_lock);\n\n\tfor_each_root(root) {\n\t\tstruct cgroup_subsys *ss;\n\t\tstruct cgroup *cgrp;\n\t\tint ssid, count = 0;\n\n\t\tif (root == &cgrp_dfl_root && !cgrp_dfl_visible)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"%d:\", root->hierarchy_id);\n\t\tif (root != &cgrp_dfl_root)\n\t\t\tfor_each_subsys(ss, ssid)\n\t\t\t\tif (root->subsys_mask & (1 << ssid))\n\t\t\t\t\tseq_printf(m, \"%s%s\", count++ ? \",\" : \"\",\n\t\t\t\t\t\t   ss->legacy_name);\n\t\tif (strlen(root->name))\n\t\t\tseq_printf(m, \"%sname=%s\", count ? \",\" : \"\",\n\t\t\t\t   root->name);\n\t\tseq_putc(m, ':');\n\n\t\tcgrp = task_cgroup_from_root(tsk, root);\n\n\t\t/*\n\t\t * On traditional hierarchies, all zombie tasks show up as\n\t\t * belonging to the root cgroup.  On the default hierarchy,\n\t\t * while a zombie doesn't show up in \"cgroup.procs\" and\n\t\t * thus can't be migrated, its /proc/PID/cgroup keeps\n\t\t * reporting the cgroup it belonged to before exiting.  If\n\t\t * the cgroup is removed before the zombie is reaped,\n\t\t * \" (deleted)\" is appended to the cgroup path.\n\t\t */\n\t\tif (cgroup_on_dfl(cgrp) || !(tsk->flags & PF_EXITING)) {\n\t\t\tretval = cgroup_path_ns_locked(cgrp, buf, PATH_MAX,\n\t\t\t\t\t\tcurrent->nsproxy->cgroup_ns);\n\t\t\tif (retval >= PATH_MAX)\n\t\t\t\tretval = -ENAMETOOLONG;\n\t\t\tif (retval < 0)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tseq_puts(m, buf);\n\t\t} else {\n\t\t\tseq_puts(m, \"/\");\n\t\t}\n\n\t\tif (cgroup_on_dfl(cgrp) && cgroup_is_dead(cgrp))\n\t\t\tseq_puts(m, \" (deleted)\\n\");\n\t\telse\n\t\t\tseq_putc(m, '\\n');\n\t}\n\n\tretval = 0;\nout_unlock:\n\tspin_unlock_irq(&css_set_lock);\n\tmutex_unlock(&cgroup_mutex);\n\tkfree(buf);\nout:\n\treturn retval;\n}\n\n/**\n * cgroup_fork - initialize cgroup related fields during copy_process()\n * @child: pointer to task_struct of forking parent process.\n *\n * A task is associated with the init_css_set until cgroup_post_fork()\n * attaches it to the target css_set.\n */\nvoid cgroup_fork(struct task_struct *child)\n{\n\tRCU_INIT_POINTER(child->cgroups, &init_css_set);\n\tINIT_LIST_HEAD(&child->cg_list);\n}\n\nstatic struct cgroup *cgroup_get_from_file(struct file *f)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *cgrp;\n\n\tcss = css_tryget_online_from_dir(f->f_path.dentry, NULL);\n\tif (IS_ERR(css))\n\t\treturn ERR_CAST(css);\n\n\tcgrp = css->cgroup;\n\tif (!cgroup_on_dfl(cgrp)) {\n\t\tcgroup_put(cgrp);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn cgrp;\n}\n\n/**\n * cgroup_css_set_fork - find or create a css_set for a child process\n * @kargs: the arguments passed to create the child process\n *\n * This functions finds or creates a new css_set which the child\n * process will be attached to in cgroup_post_fork(). By default,\n * the child process will be given the same css_set as its parent.\n *\n * If CLONE_INTO_CGROUP is specified this function will try to find an\n * existing css_set which includes the requested cgroup and if not create\n * a new css_set that the child will be attached to later. If this function\n * succeeds it will hold cgroup_threadgroup_rwsem on return. If\n * CLONE_INTO_CGROUP is requested this function will grab cgroup mutex\n * before grabbing cgroup_threadgroup_rwsem and will hold a reference\n * to the target cgroup.\n */\nstatic int cgroup_css_set_fork(struct kernel_clone_args *kargs)\n\t__acquires(&cgroup_mutex) __acquires(&cgroup_threadgroup_rwsem)\n{\n\tint ret;\n\tstruct cgroup *dst_cgrp = NULL;\n\tstruct css_set *cset;\n\tstruct super_block *sb;\n\tstruct file *f;\n\n\tif (kargs->flags & CLONE_INTO_CGROUP)\n\t\tmutex_lock(&cgroup_mutex);\n\n\tcgroup_threadgroup_change_begin(current);\n\n\tspin_lock_irq(&css_set_lock);\n\tcset = task_css_set(current);\n\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (!(kargs->flags & CLONE_INTO_CGROUP)) {\n\t\tkargs->cset = cset;\n\t\treturn 0;\n\t}\n\n\tf = fget_raw(kargs->cgroup);\n\tif (!f) {\n\t\tret = -EBADF;\n\t\tgoto err;\n\t}\n\tsb = f->f_path.dentry->d_sb;\n\n\tdst_cgrp = cgroup_get_from_file(f);\n\tif (IS_ERR(dst_cgrp)) {\n\t\tret = PTR_ERR(dst_cgrp);\n\t\tdst_cgrp = NULL;\n\t\tgoto err;\n\t}\n\n\tif (cgroup_is_dead(dst_cgrp)) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * Verify that we the target cgroup is writable for us. This is\n\t * usually done by the vfs layer but since we're not going through\n\t * the vfs layer here we need to do it \"manually\".\n\t */\n\tret = cgroup_may_write(dst_cgrp, sb);\n\tif (ret)\n\t\tgoto err;\n\n\tret = cgroup_attach_permissions(cset->dfl_cgrp, dst_cgrp, sb,\n\t\t\t\t\t!(kargs->flags & CLONE_THREAD));\n\tif (ret)\n\t\tgoto err;\n\n\tkargs->cset = find_css_set(cset, dst_cgrp);\n\tif (!kargs->cset) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tput_css_set(cset);\n\tfput(f);\n\tkargs->cgrp = dst_cgrp;\n\treturn ret;\n\nerr:\n\tcgroup_threadgroup_change_end(current);\n\tmutex_unlock(&cgroup_mutex);\n\tif (f)\n\t\tfput(f);\n\tif (dst_cgrp)\n\t\tcgroup_put(dst_cgrp);\n\tput_css_set(cset);\n\tif (kargs->cset)\n\t\tput_css_set(kargs->cset);\n\treturn ret;\n}\n\n/**\n * cgroup_css_set_put_fork - drop references we took during fork\n * @kargs: the arguments passed to create the child process\n *\n * Drop references to the prepared css_set and target cgroup if\n * CLONE_INTO_CGROUP was requested.\n */\nstatic void cgroup_css_set_put_fork(struct kernel_clone_args *kargs)\n\t__releases(&cgroup_threadgroup_rwsem) __releases(&cgroup_mutex)\n{\n\tcgroup_threadgroup_change_end(current);\n\n\tif (kargs->flags & CLONE_INTO_CGROUP) {\n\t\tstruct cgroup *cgrp = kargs->cgrp;\n\t\tstruct css_set *cset = kargs->cset;\n\n\t\tmutex_unlock(&cgroup_mutex);\n\n\t\tif (cset) {\n\t\t\tput_css_set(cset);\n\t\t\tkargs->cset = NULL;\n\t\t}\n\n\t\tif (cgrp) {\n\t\t\tcgroup_put(cgrp);\n\t\t\tkargs->cgrp = NULL;\n\t\t}\n\t}\n}\n\n/**\n * cgroup_can_fork - called on a new task before the process is exposed\n * @child: the child process\n *\n * This prepares a new css_set for the child process which the child will\n * be attached to in cgroup_post_fork().\n * This calls the subsystem can_fork() callbacks. If the cgroup_can_fork()\n * callback returns an error, the fork aborts with that error code. This\n * allows for a cgroup subsystem to conditionally allow or deny new forks.\n */\nint cgroup_can_fork(struct task_struct *child, struct kernel_clone_args *kargs)\n{\n\tstruct cgroup_subsys *ss;\n\tint i, j, ret;\n\n\tret = cgroup_css_set_fork(kargs);\n\tif (ret)\n\t\treturn ret;\n\n\tdo_each_subsys_mask(ss, i, have_canfork_callback) {\n\t\tret = ss->can_fork(child, kargs->cset);\n\t\tif (ret)\n\t\t\tgoto out_revert;\n\t} while_each_subsys_mask();\n\n\treturn 0;\n\nout_revert:\n\tfor_each_subsys(ss, j) {\n\t\tif (j >= i)\n\t\t\tbreak;\n\t\tif (ss->cancel_fork)\n\t\t\tss->cancel_fork(child, kargs->cset);\n\t}\n\n\tcgroup_css_set_put_fork(kargs);\n\n\treturn ret;\n}\n\n/**\n * cgroup_cancel_fork - called if a fork failed after cgroup_can_fork()\n * @child: the child process\n * @kargs: the arguments passed to create the child process\n *\n * This calls the cancel_fork() callbacks if a fork failed *after*\n * cgroup_can_fork() succeded and cleans up references we took to\n * prepare a new css_set for the child process in cgroup_can_fork().\n */\nvoid cgroup_cancel_fork(struct task_struct *child,\n\t\t\tstruct kernel_clone_args *kargs)\n{\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tif (ss->cancel_fork)\n\t\t\tss->cancel_fork(child, kargs->cset);\n\n\tcgroup_css_set_put_fork(kargs);\n}\n\n/**\n * cgroup_post_fork - finalize cgroup setup for the child process\n * @child: the child process\n *\n * Attach the child process to its css_set calling the subsystem fork()\n * callbacks.\n */\nvoid cgroup_post_fork(struct task_struct *child,\n\t\t      struct kernel_clone_args *kargs)\n\t__releases(&cgroup_threadgroup_rwsem) __releases(&cgroup_mutex)\n{\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tint i;\n\n\tcset = kargs->cset;\n\tkargs->cset = NULL;\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* init tasks are special, only link regular threads */\n\tif (likely(child->pid)) {\n\t\tWARN_ON_ONCE(!list_empty(&child->cg_list));\n\t\tcset->nr_tasks++;\n\t\tcss_set_move_task(child, NULL, cset, false);\n\t} else {\n\t\tput_css_set(cset);\n\t\tcset = NULL;\n\t}\n\n\t/*\n\t * If the cgroup has to be frozen, the new task has too.  Let's set\n\t * the JOBCTL_TRAP_FREEZE jobctl bit to get the task into the\n\t * frozen state.\n\t */\n\tif (unlikely(cgroup_task_freeze(child))) {\n\t\tspin_lock(&child->sighand->siglock);\n\t\tWARN_ON_ONCE(child->frozen);\n\t\tchild->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tspin_unlock(&child->sighand->siglock);\n\n\t\t/*\n\t\t * Calling cgroup_update_frozen() isn't required here,\n\t\t * because it will be called anyway a bit later from\n\t\t * do_freezer_trap(). So we avoid cgroup's transient switch\n\t\t * from the frozen state and back.\n\t\t */\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Call ss->fork().  This must happen after @child is linked on\n\t * css_set; otherwise, @child might change state between ->fork()\n\t * and addition to css_set.\n\t */\n\tdo_each_subsys_mask(ss, i, have_fork_callback) {\n\t\tss->fork(child);\n\t} while_each_subsys_mask();\n\n\t/* Make the new cset the root_cset of the new cgroup namespace. */\n\tif (kargs->flags & CLONE_NEWCGROUP) {\n\t\tstruct css_set *rcset = child->nsproxy->cgroup_ns->root_cset;\n\n\t\tget_css_set(cset);\n\t\tchild->nsproxy->cgroup_ns->root_cset = cset;\n\t\tput_css_set(rcset);\n\t}\n\n\tcgroup_css_set_put_fork(kargs);\n}\n\n/**\n * cgroup_exit - detach cgroup from exiting task\n * @tsk: pointer to task_struct of exiting process\n *\n * Description: Detach cgroup from @tsk.\n *\n */\nvoid cgroup_exit(struct task_struct *tsk)\n{\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tint i;\n\n\tspin_lock_irq(&css_set_lock);\n\n\tWARN_ON_ONCE(list_empty(&tsk->cg_list));\n\tcset = task_css_set(tsk);\n\tcss_set_move_task(tsk, cset, NULL, false);\n\tlist_add_tail(&tsk->cg_list, &cset->dying_tasks);\n\tcset->nr_tasks--;\n\n\tWARN_ON_ONCE(cgroup_task_frozen(tsk));\n\tif (unlikely(cgroup_task_freeze(tsk)))\n\t\tcgroup_update_frozen(task_dfl_cgroup(tsk));\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* see cgroup_post_fork() for details */\n\tdo_each_subsys_mask(ss, i, have_exit_callback) {\n\t\tss->exit(tsk);\n\t} while_each_subsys_mask();\n}\n\nvoid cgroup_release(struct task_struct *task)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tdo_each_subsys_mask(ss, ssid, have_release_callback) {\n\t\tss->release(task);\n\t} while_each_subsys_mask();\n\n\tspin_lock_irq(&css_set_lock);\n\tcss_set_skip_task_iters(task_css_set(task), task);\n\tlist_del_init(&task->cg_list);\n\tspin_unlock_irq(&css_set_lock);\n}\n\nvoid cgroup_free(struct task_struct *task)\n{\n\tstruct css_set *cset = task_css_set(task);\n\tput_css_set(cset);\n}\n\nstatic int __init cgroup_disable(char *str)\n{\n\tstruct cgroup_subsys *ss;\n\tchar *token;\n\tint i;\n\n\twhile ((token = strsep(&str, \",\")) != NULL) {\n\t\tif (!*token)\n\t\t\tcontinue;\n\n\t\tfor_each_subsys(ss, i) {\n\t\t\tif (strcmp(token, ss->name) &&\n\t\t\t    strcmp(token, ss->legacy_name))\n\t\t\t\tcontinue;\n\t\t\tcgroup_disable_mask |= 1 << i;\n\t\t}\n\t}\n\treturn 1;\n}\n__setup(\"cgroup_disable=\", cgroup_disable);\n\nvoid __init __weak enable_debug_cgroup(void) { }\n\nstatic int __init enable_cgroup_debug(char *str)\n{\n\tcgroup_debug = true;\n\tenable_debug_cgroup();\n\treturn 1;\n}\n__setup(\"cgroup_debug\", enable_cgroup_debug);\n\n/**\n * css_tryget_online_from_dir - get corresponding css from a cgroup dentry\n * @dentry: directory dentry of interest\n * @ss: subsystem of interest\n *\n * If @dentry is a directory for a cgroup which has @ss enabled on it, try\n * to get the corresponding css and return it.  If such css doesn't exist\n * or can't be pinned, an ERR_PTR value is returned.\n */\nstruct cgroup_subsys_state *css_tryget_online_from_dir(struct dentry *dentry,\n\t\t\t\t\t\t       struct cgroup_subsys *ss)\n{\n\tstruct kernfs_node *kn = kernfs_node_from_dentry(dentry);\n\tstruct file_system_type *s_type = dentry->d_sb->s_type;\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct cgroup *cgrp;\n\n\t/* is @dentry a cgroup dir? */\n\tif ((s_type != &cgroup_fs_type && s_type != &cgroup2_fs_type) ||\n\t    !kn || kernfs_type(kn) != KERNFS_DIR)\n\t\treturn ERR_PTR(-EBADF);\n\n\trcu_read_lock();\n\n\t/*\n\t * This path doesn't originate from kernfs and @kn could already\n\t * have been or be removed at any point.  @kn->priv is RCU\n\t * protected for this access.  See css_release_work_fn() for details.\n\t */\n\tcgrp = rcu_dereference(*(void __rcu __force **)&kn->priv);\n\tif (cgrp)\n\t\tcss = cgroup_css(cgrp, ss);\n\n\tif (!css || !css_tryget_online(css))\n\t\tcss = ERR_PTR(-ENOENT);\n\n\trcu_read_unlock();\n\treturn css;\n}\n\n/**\n * css_from_id - lookup css by id\n * @id: the cgroup id\n * @ss: cgroup subsys to be looked into\n *\n * Returns the css if there's valid one with @id, otherwise returns NULL.\n * Should be called under rcu_read_lock().\n */\nstruct cgroup_subsys_state *css_from_id(int id, struct cgroup_subsys *ss)\n{\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\treturn idr_find(&ss->css_idr, id);\n}\n\n/**\n * cgroup_get_from_path - lookup and get a cgroup from its default hierarchy path\n * @path: path on the default hierarchy\n *\n * Find the cgroup at @path on the default hierarchy, increment its\n * reference count and return it.  Returns pointer to the found cgroup on\n * success, ERR_PTR(-ENOENT) if @path doens't exist and ERR_PTR(-ENOTDIR)\n * if @path points to a non-directory.\n */\nstruct cgroup *cgroup_get_from_path(const char *path)\n{\n\tstruct kernfs_node *kn;\n\tstruct cgroup *cgrp;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tkn = kernfs_walk_and_get(cgrp_dfl_root.cgrp.kn, path);\n\tif (kn) {\n\t\tif (kernfs_type(kn) == KERNFS_DIR) {\n\t\t\tcgrp = kn->priv;\n\t\t\tcgroup_get_live(cgrp);\n\t\t} else {\n\t\t\tcgrp = ERR_PTR(-ENOTDIR);\n\t\t}\n\t\tkernfs_put(kn);\n\t} else {\n\t\tcgrp = ERR_PTR(-ENOENT);\n\t}\n\n\tmutex_unlock(&cgroup_mutex);\n\treturn cgrp;\n}\nEXPORT_SYMBOL_GPL(cgroup_get_from_path);\n\n/**\n * cgroup_get_from_fd - get a cgroup pointer from a fd\n * @fd: fd obtained by open(cgroup2_dir)\n *\n * Find the cgroup from a fd which should be obtained\n * by opening a cgroup directory.  Returns a pointer to the\n * cgroup on success. ERR_PTR is returned if the cgroup\n * cannot be found.\n */\nstruct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}\nEXPORT_SYMBOL_GPL(cgroup_get_from_fd);\n\nstatic u64 power_of_ten(int power)\n{\n\tu64 v = 1;\n\twhile (power--)\n\t\tv *= 10;\n\treturn v;\n}\n\n/**\n * cgroup_parse_float - parse a floating number\n * @input: input string\n * @dec_shift: number of decimal digits to shift\n * @v: output\n *\n * Parse a decimal floating point number in @input and store the result in\n * @v with decimal point right shifted @dec_shift times.  For example, if\n * @input is \"12.3456\" and @dec_shift is 3, *@v will be set to 12345.\n * Returns 0 on success, -errno otherwise.\n *\n * There's nothing cgroup specific about this function except that it's\n * currently the only user.\n */\nint cgroup_parse_float(const char *input, unsigned dec_shift, s64 *v)\n{\n\ts64 whole, frac = 0;\n\tint fstart = 0, fend = 0, flen;\n\n\tif (!sscanf(input, \"%lld.%n%lld%n\", &whole, &fstart, &frac, &fend))\n\t\treturn -EINVAL;\n\tif (frac < 0)\n\t\treturn -EINVAL;\n\n\tflen = fend > fstart ? fend - fstart : 0;\n\tif (flen < dec_shift)\n\t\tfrac *= power_of_ten(dec_shift - flen);\n\telse\n\t\tfrac = DIV_ROUND_CLOSEST_ULL(frac, power_of_ten(flen - dec_shift));\n\n\t*v = whole * power_of_ten(dec_shift) + frac;\n\treturn 0;\n}\n\n/*\n * sock->sk_cgrp_data handling.  For more info, see sock_cgroup_data\n * definition in cgroup-defs.h.\n */\n#ifdef CONFIG_SOCK_CGROUP_DATA\n\n#if defined(CONFIG_CGROUP_NET_PRIO) || defined(CONFIG_CGROUP_NET_CLASSID)\n\nDEFINE_SPINLOCK(cgroup_sk_update_lock);\nstatic bool cgroup_sk_alloc_disabled __read_mostly;\n\nvoid cgroup_sk_alloc_disable(void)\n{\n\tif (cgroup_sk_alloc_disabled)\n\t\treturn;\n\tpr_info(\"cgroup: disabling cgroup2 socket matching due to net_prio or net_cls activation\\n\");\n\tcgroup_sk_alloc_disabled = true;\n}\n\n#else\n\n#define cgroup_sk_alloc_disabled\tfalse\n\n#endif\n\nvoid cgroup_sk_alloc(struct sock_cgroup_data *skcd)\n{\n\tif (cgroup_sk_alloc_disabled) {\n\t\tskcd->no_refcnt = 1;\n\t\treturn;\n\t}\n\n\t/* Don't associate the sock with unrelated interrupted task's cgroup. */\n\tif (in_interrupt())\n\t\treturn;\n\n\trcu_read_lock();\n\n\twhile (true) {\n\t\tstruct css_set *cset;\n\n\t\tcset = task_css_set(current);\n\t\tif (likely(cgroup_tryget(cset->dfl_cgrp))) {\n\t\t\tskcd->val = (unsigned long)cset->dfl_cgrp;\n\t\t\tcgroup_bpf_get(cset->dfl_cgrp);\n\t\t\tbreak;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\trcu_read_unlock();\n}\n\nvoid cgroup_sk_clone(struct sock_cgroup_data *skcd)\n{\n\tif (skcd->val) {\n\t\tif (skcd->no_refcnt)\n\t\t\treturn;\n\t\t/*\n\t\t * We might be cloning a socket which is left in an empty\n\t\t * cgroup and the cgroup might have already been rmdir'd.\n\t\t * Don't use cgroup_get_live().\n\t\t */\n\t\tcgroup_get(sock_cgroup_ptr(skcd));\n\t\tcgroup_bpf_get(sock_cgroup_ptr(skcd));\n\t}\n}\n\nvoid cgroup_sk_free(struct sock_cgroup_data *skcd)\n{\n\tstruct cgroup *cgrp = sock_cgroup_ptr(skcd);\n\n\tif (skcd->no_refcnt)\n\t\treturn;\n\tcgroup_bpf_put(cgrp);\n\tcgroup_put(cgrp);\n}\n\n#endif\t/* CONFIG_SOCK_CGROUP_DATA */\n\n#ifdef CONFIG_CGROUP_BPF\nint cgroup_bpf_attach(struct cgroup *cgrp,\n\t\t      struct bpf_prog *prog, struct bpf_prog *replace_prog,\n\t\t      struct bpf_cgroup_link *link,\n\t\t      enum bpf_attach_type type,\n\t\t      u32 flags)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_attach(cgrp, prog, replace_prog, link, type, flags);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\n\nint cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,\n\t\t      enum bpf_attach_type type)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_detach(cgrp, prog, NULL, type);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\n\nint cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,\n\t\t     union bpf_attr __user *uattr)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = __cgroup_bpf_query(cgrp, attr, uattr);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\n#endif /* CONFIG_CGROUP_BPF */\n\n#ifdef CONFIG_SYSFS\nstatic ssize_t show_delegatable_files(struct cftype *files, char *buf,\n\t\t\t\t      ssize_t size, const char *prefix)\n{\n\tstruct cftype *cft;\n\tssize_t ret = 0;\n\n\tfor (cft = files; cft && cft->name[0] != '\\0'; cft++) {\n\t\tif (!(cft->flags & CFTYPE_NS_DELEGATABLE))\n\t\t\tcontinue;\n\n\t\tif (prefix)\n\t\t\tret += snprintf(buf + ret, size - ret, \"%s.\", prefix);\n\n\t\tret += snprintf(buf + ret, size - ret, \"%s\\n\", cft->name);\n\n\t\tif (WARN_ON(ret >= size))\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t delegate_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\tssize_t ret = 0;\n\n\tret = show_delegatable_files(cgroup_base_files, buf, PAGE_SIZE - ret,\n\t\t\t\t     NULL);\n\n\tfor_each_subsys(ss, ssid)\n\t\tret += show_delegatable_files(ss->dfl_cftypes, buf + ret,\n\t\t\t\t\t      PAGE_SIZE - ret,\n\t\t\t\t\t      cgroup_subsys_name[ssid]);\n\n\treturn ret;\n}\nstatic struct kobj_attribute cgroup_delegate_attr = __ATTR_RO(delegate);\n\nstatic ssize_t features_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE,\n\t\t\t\"nsdelegate\\n\"\n\t\t\t\"memory_localevents\\n\"\n\t\t\t\"memory_recursiveprot\\n\");\n}\nstatic struct kobj_attribute cgroup_features_attr = __ATTR_RO(features);\n\nstatic struct attribute *cgroup_sysfs_attrs[] = {\n\t&cgroup_delegate_attr.attr,\n\t&cgroup_features_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group cgroup_sysfs_attr_group = {\n\t.attrs = cgroup_sysfs_attrs,\n\t.name = \"cgroup\",\n};\n\nstatic int __init cgroup_sysfs_init(void)\n{\n\treturn sysfs_create_group(kernel_kobj, &cgroup_sysfs_attr_group);\n}\nsubsys_initcall(cgroup_sysfs_init);\n\n#endif /* CONFIG_SYSFS */\n"}}, "reports": [{"events": [{"location": {"col": -1, "file": 0, "line": 5542}, "message": "cgroup_destroy_locked() error: we previously assumed 'parent' could be null (see line 5526)"}], "macros": [], "notes": [], "path": "/src/kernel/cgroup/cgroup.c", "reportHash": "442c9ae04d56c55ef2f96be111509f27", "checkerName": "smatch", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
