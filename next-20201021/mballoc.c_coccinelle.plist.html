<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/fs/ext4/mballoc.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (c) 2003-2006, Cluster File Systems, Inc, info@clusterfs.com\n * Written by Alex Tomas <alex@clusterfs.com>\n */\n\n\n/*\n * mballoc.c contains the multiblocks allocation routines\n */\n\n#include \"ext4_jbd2.h\"\n#include \"mballoc.h\"\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/nospec.h>\n#include <linux/backing-dev.h>\n#include <trace/events/ext4.h>\n\n/*\n * MUSTDO:\n *   - test ext4_ext_search_left() and ext4_ext_search_right()\n *   - search for metadata in few groups\n *\n * TODO v4:\n *   - normalization should take into account whether file is still open\n *   - discard preallocations if no free space left (policy?)\n *   - don't normalize tails\n *   - quota\n *   - reservation for superuser\n *\n * TODO v3:\n *   - bitmap read-ahead (proposed by Oleg Drokin aka green)\n *   - track min/max extents in each group for better group selection\n *   - mb_mark_used() may allocate chunk right after splitting buddy\n *   - tree of groups sorted by number of free blocks\n *   - error handling\n */\n\n/*\n * The allocation request involve request for multiple number of blocks\n * near to the goal(block) value specified.\n *\n * During initialization phase of the allocator we decide to use the\n * group preallocation or inode preallocation depending on the size of\n * the file. The size of the file could be the resulting file size we\n * would have after allocation, or the current file size, which ever\n * is larger. If the size is less than sbi->s_mb_stream_request we\n * select to use the group preallocation. The default value of\n * s_mb_stream_request is 16 blocks. This can also be tuned via\n * /sys/fs/ext4/<partition>/mb_stream_req. The value is represented in\n * terms of number of blocks.\n *\n * The main motivation for having small file use group preallocation is to\n * ensure that we have small files closer together on the disk.\n *\n * First stage the allocator looks at the inode prealloc list,\n * ext4_inode_info->i_prealloc_list, which contains list of prealloc\n * spaces for this particular inode. The inode prealloc space is\n * represented as:\n *\n * pa_lstart -> the logical start block for this prealloc space\n * pa_pstart -> the physical start block for this prealloc space\n * pa_len    -> length for this prealloc space (in clusters)\n * pa_free   ->  free space available in this prealloc space (in clusters)\n *\n * The inode preallocation space is used looking at the _logical_ start\n * block. If only the logical file block falls within the range of prealloc\n * space we will consume the particular prealloc space. This makes sure that\n * we have contiguous physical blocks representing the file blocks\n *\n * The important thing to be noted in case of inode prealloc space is that\n * we don't modify the values associated to inode prealloc space except\n * pa_free.\n *\n * If we are not able to find blocks in the inode prealloc space and if we\n * have the group allocation flag set then we look at the locality group\n * prealloc space. These are per CPU prealloc list represented as\n *\n * ext4_sb_info.s_locality_groups[smp_processor_id()]\n *\n * The reason for having a per cpu locality group is to reduce the contention\n * between CPUs. It is possible to get scheduled at this point.\n *\n * The locality group prealloc space is used looking at whether we have\n * enough free space (pa_free) within the prealloc space.\n *\n * If we can't allocate blocks via inode prealloc or/and locality group\n * prealloc then we look at the buddy cache. The buddy cache is represented\n * by ext4_sb_info.s_buddy_cache (struct inode) whose file offset gets\n * mapped to the buddy and bitmap information regarding different\n * groups. The buddy information is attached to buddy cache inode so that\n * we can access them through the page cache. The information regarding\n * each group is loaded via ext4_mb_load_buddy.  The information involve\n * block bitmap and buddy information. The information are stored in the\n * inode as:\n *\n *  {                        page                        }\n *  [ group 0 bitmap][ group 0 buddy] [group 1][ group 1]...\n *\n *\n * one block each for bitmap and buddy information.  So for each group we\n * take up 2 blocks. A page can contain blocks_per_page (PAGE_SIZE /\n * blocksize) blocks.  So it can have information regarding groups_per_page\n * which is blocks_per_page/2\n *\n * The buddy cache inode is not stored on disk. The inode is thrown\n * away when the filesystem is unmounted.\n *\n * We look for count number of blocks in the buddy cache. If we were able\n * to locate that many free blocks we return with additional information\n * regarding rest of the contiguous physical block available\n *\n * Before allocating blocks via buddy cache we normalize the request\n * blocks. This ensure we ask for more blocks that we needed. The extra\n * blocks that we get after allocation is added to the respective prealloc\n * list. In case of inode preallocation we follow a list of heuristics\n * based on file size. This can be found in ext4_mb_normalize_request. If\n * we are doing a group prealloc we try to normalize the request to\n * sbi->s_mb_group_prealloc.  The default value of s_mb_group_prealloc is\n * dependent on the cluster size; for non-bigalloc file systems, it is\n * 512 blocks. This can be tuned via\n * /sys/fs/ext4/<partition>/mb_group_prealloc. The value is represented in\n * terms of number of blocks. If we have mounted the file system with -O\n * stripe=<value> option the group prealloc request is normalized to the\n * smallest multiple of the stripe value (sbi->s_stripe) which is\n * greater than the default mb_group_prealloc.\n *\n * The regular allocator (using the buddy cache) supports a few tunables.\n *\n * /sys/fs/ext4/<partition>/mb_min_to_scan\n * /sys/fs/ext4/<partition>/mb_max_to_scan\n * /sys/fs/ext4/<partition>/mb_order2_req\n *\n * The regular allocator uses buddy scan only if the request len is power of\n * 2 blocks and the order of allocation is >= sbi->s_mb_order2_reqs. The\n * value of s_mb_order2_reqs can be tuned via\n * /sys/fs/ext4/<partition>/mb_order2_req.  If the request len is equal to\n * stripe size (sbi->s_stripe), we try to search for contiguous block in\n * stripe size. This should result in better allocation on RAID setups. If\n * not, we search in the specific group using bitmap for best extents. The\n * tunable min_to_scan and max_to_scan control the behaviour here.\n * min_to_scan indicate how long the mballoc __must__ look for a best\n * extent and max_to_scan indicates how long the mballoc __can__ look for a\n * best extent in the found extents. Searching for the blocks starts with\n * the group specified as the goal value in allocation context via\n * ac_g_ex. Each group is first checked based on the criteria whether it\n * can be used for allocation. ext4_mb_good_group explains how the groups are\n * checked.\n *\n * Both the prealloc space are getting populated as above. So for the first\n * request we will hit the buddy cache which will result in this prealloc\n * space getting filled. The prealloc space is then later used for the\n * subsequent request.\n */\n\n/*\n * mballoc operates on the following data:\n *  - on-disk bitmap\n *  - in-core buddy (actually includes buddy and bitmap)\n *  - preallocation descriptors (PAs)\n *\n * there are two types of preallocations:\n *  - inode\n *    assiged to specific inode and can be used for this inode only.\n *    it describes part of inode's space preallocated to specific\n *    physical blocks. any block from that preallocated can be used\n *    independent. the descriptor just tracks number of blocks left\n *    unused. so, before taking some block from descriptor, one must\n *    make sure corresponded logical block isn't allocated yet. this\n *    also means that freeing any block within descriptor's range\n *    must discard all preallocated blocks.\n *  - locality group\n *    assigned to specific locality group which does not translate to\n *    permanent set of inodes: inode can join and leave group. space\n *    from this type of preallocation can be used for any inode. thus\n *    it's consumed from the beginning to the end.\n *\n * relation between them can be expressed as:\n *    in-core buddy = on-disk bitmap + preallocation descriptors\n *\n * this mean blocks mballoc considers used are:\n *  - allocated blocks (persistent)\n *  - preallocated blocks (non-persistent)\n *\n * consistency in mballoc world means that at any time a block is either\n * free or used in ALL structures. notice: \"any time\" should not be read\n * literally -- time is discrete and delimited by locks.\n *\n *  to keep it simple, we don't use block numbers, instead we count number of\n *  blocks: how many blocks marked used/free in on-disk bitmap, buddy and PA.\n *\n * all operations can be expressed as:\n *  - init buddy:\t\t\tbuddy = on-disk + PAs\n *  - new PA:\t\t\t\tbuddy += N; PA = N\n *  - use inode PA:\t\t\ton-disk += N; PA -= N\n *  - discard inode PA\t\t\tbuddy -= on-disk - PA; PA = 0\n *  - use locality group PA\t\ton-disk += N; PA -= N\n *  - discard locality group PA\t\tbuddy -= PA; PA = 0\n *  note: 'buddy -= on-disk - PA' is used to show that on-disk bitmap\n *        is used in real operation because we can't know actual used\n *        bits from PA, only from on-disk bitmap\n *\n * if we follow this strict logic, then all operations above should be atomic.\n * given some of them can block, we'd have to use something like semaphores\n * killing performance on high-end SMP hardware. let's try to relax it using\n * the following knowledge:\n *  1) if buddy is referenced, it's already initialized\n *  2) while block is used in buddy and the buddy is referenced,\n *     nobody can re-allocate that block\n *  3) we work on bitmaps and '+' actually means 'set bits'. if on-disk has\n *     bit set and PA claims same block, it's OK. IOW, one can set bit in\n *     on-disk bitmap if buddy has same bit set or/and PA covers corresponded\n *     block\n *\n * so, now we're building a concurrency table:\n *  - init buddy vs.\n *    - new PA\n *      blocks for PA are allocated in the buddy, buddy must be referenced\n *      until PA is linked to allocation group to avoid concurrent buddy init\n *    - use inode PA\n *      we need to make sure that either on-disk bitmap or PA has uptodate data\n *      given (3) we care that PA-=N operation doesn't interfere with init\n *    - discard inode PA\n *      the simplest way would be to have buddy initialized by the discard\n *    - use locality group PA\n *      again PA-=N must be serialized with init\n *    - discard locality group PA\n *      the simplest way would be to have buddy initialized by the discard\n *  - new PA vs.\n *    - use inode PA\n *      i_data_sem serializes them\n *    - discard inode PA\n *      discard process must wait until PA isn't used by another process\n *    - use locality group PA\n *      some mutex should serialize them\n *    - discard locality group PA\n *      discard process must wait until PA isn't used by another process\n *  - use inode PA\n *    - use inode PA\n *      i_data_sem or another mutex should serializes them\n *    - discard inode PA\n *      discard process must wait until PA isn't used by another process\n *    - use locality group PA\n *      nothing wrong here -- they're different PAs covering different blocks\n *    - discard locality group PA\n *      discard process must wait until PA isn't used by another process\n *\n * now we're ready to make few consequences:\n *  - PA is referenced and while it is no discard is possible\n *  - PA is referenced until block isn't marked in on-disk bitmap\n *  - PA changes only after on-disk bitmap\n *  - discard must not compete with init. either init is done before\n *    any discard or they're serialized somehow\n *  - buddy init as sum of on-disk bitmap and PAs is done atomically\n *\n * a special case when we've used PA to emptiness. no need to modify buddy\n * in this case, but we should care about concurrent init\n *\n */\n\n /*\n * Logic in few words:\n *\n *  - allocation:\n *    load group\n *    find blocks\n *    mark bits in on-disk bitmap\n *    release group\n *\n *  - use preallocation:\n *    find proper PA (per-inode or group)\n *    load group\n *    mark bits in on-disk bitmap\n *    release group\n *    release PA\n *\n *  - free:\n *    load group\n *    mark bits in on-disk bitmap\n *    release group\n *\n *  - discard preallocations in group:\n *    mark PAs deleted\n *    move them onto local list\n *    load on-disk bitmap\n *    load group\n *    remove PA from object (inode or locality group)\n *    mark free blocks in-core\n *\n *  - discard inode's preallocations:\n */\n\n/*\n * Locking rules\n *\n * Locks:\n *  - bitlock on a group\t(group)\n *  - object (inode/locality)\t(object)\n *  - per-pa lock\t\t(pa)\n *\n * Paths:\n *  - new pa\n *    object\n *    group\n *\n *  - find and use pa:\n *    pa\n *\n *  - release consumed pa:\n *    pa\n *    group\n *    object\n *\n *  - generate in-core bitmap:\n *    group\n *        pa\n *\n *  - discard all for given object (inode, locality group):\n *    object\n *        pa\n *    group\n *\n *  - discard all for given group:\n *    group\n *        pa\n *    group\n *        object\n *\n */\nstatic struct kmem_cache *ext4_pspace_cachep;\nstatic struct kmem_cache *ext4_ac_cachep;\nstatic struct kmem_cache *ext4_free_data_cachep;\n\n/* We create slab caches for groupinfo data structures based on the\n * superblock block size.  There will be one per mounted filesystem for\n * each unique s_blocksize_bits */\n#define NR_GRPINFO_CACHES 8\nstatic struct kmem_cache *ext4_groupinfo_caches[NR_GRPINFO_CACHES];\n\nstatic const char * const ext4_groupinfo_slab_names[NR_GRPINFO_CACHES] = {\n\t\"ext4_groupinfo_1k\", \"ext4_groupinfo_2k\", \"ext4_groupinfo_4k\",\n\t\"ext4_groupinfo_8k\", \"ext4_groupinfo_16k\", \"ext4_groupinfo_32k\",\n\t\"ext4_groupinfo_64k\", \"ext4_groupinfo_128k\"\n};\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_new_preallocation(struct ext4_allocation_context *ac);\n\n/*\n * The algorithm using this percpu seq counter goes below:\n * 1. We sample the percpu discard_pa_seq counter before trying for block\n *    allocation in ext4_mb_new_blocks().\n * 2. We increment this percpu discard_pa_seq counter when we either allocate\n *    or free these blocks i.e. while marking those blocks as used/free in\n *    mb_mark_used()/mb_free_blocks().\n * 3. We also increment this percpu seq counter when we successfully identify\n *    that the bb_prealloc_list is not empty and hence proceed for discarding\n *    of those PAs inside ext4_mb_discard_group_preallocations().\n *\n * Now to make sure that the regular fast path of block allocation is not\n * affected, as a small optimization we only sample the percpu seq counter\n * on that cpu. Only when the block allocation fails and when freed blocks\n * found were 0, that is when we sample percpu seq counter for all cpus using\n * below function ext4_get_discard_pa_seq_sum(). This happens after making\n * sure that all the PAs on grp->bb_prealloc_list got freed or if it's empty.\n */\nstatic DEFINE_PER_CPU(u64, discard_pa_seq);\nstatic inline u64 ext4_get_discard_pa_seq_sum(void)\n{\n\tint __cpu;\n\tu64 __seq = 0;\n\n\tfor_each_possible_cpu(__cpu)\n\t\t__seq += per_cpu(discard_pa_seq, __cpu);\n\treturn __seq;\n}\n\nstatic inline void *mb_correct_addr_and_bit(int *bit, void *addr)\n{\n#if BITS_PER_LONG == 64\n\t*bit += ((unsigned long) addr & 7UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~7UL);\n#elif BITS_PER_LONG == 32\n\t*bit += ((unsigned long) addr & 3UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~3UL);\n#else\n#error \"how many bits you are?!\"\n#endif\n\treturn addr;\n}\n\nstatic inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}\n\nstatic inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}\n\nstatic inline void mb_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_clear_bit(bit, addr);\n}\n\nstatic inline int mb_test_and_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_and_clear_bit(bit, addr);\n}\n\nstatic inline int mb_find_next_zero_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_zero_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}\n\nstatic void *mb_find_buddy(struct ext4_buddy *e4b, int order, int *max)\n{\n\tchar *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(max == NULL);\n\n\tif (order > e4b->bd_blkbits + 1) {\n\t\t*max = 0;\n\t\treturn NULL;\n\t}\n\n\t/* at order 0 we see each particular block */\n\tif (order == 0) {\n\t\t*max = 1 << (e4b->bd_blkbits + 3);\n\t\treturn e4b->bd_bitmap;\n\t}\n\n\tbb = e4b->bd_buddy + EXT4_SB(e4b->bd_sb)->s_mb_offsets[order];\n\t*max = EXT4_SB(e4b->bd_sb)->s_mb_maxs[order];\n\n\treturn bb;\n}\n\n#ifdef DOUBLE_CHECK\nstatic void mb_free_blocks_double(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint i;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (unlikely(e4b->bd_info->bb_bitmap == NULL))\n\t\treturn;\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\tfor (i = 0; i < count; i++) {\n\t\tif (!mb_test_bit(first + i, e4b->bd_info->bb_bitmap)) {\n\t\t\text4_fsblk_t blocknr;\n\n\t\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\t\tblocknr += EXT4_C2B(EXT4_SB(sb), first + i);\n\t\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t\t      blocknr,\n\t\t\t\t\t      \"freeing block already freed \"\n\t\t\t\t\t      \"(bit %u)\",\n\t\t\t\t\t      first + i);\n\t\t\text4_mark_group_bitmap_corrupted(sb, e4b->bd_group,\n\t\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT);\n\t\t}\n\t\tmb_clear_bit(first + i, e4b->bd_info->bb_bitmap);\n\t}\n}\n\nstatic void mb_mark_used_double(struct ext4_buddy *e4b, int first, int count)\n{\n\tint i;\n\n\tif (unlikely(e4b->bd_info->bb_bitmap == NULL))\n\t\treturn;\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tfor (i = 0; i < count; i++) {\n\t\tBUG_ON(mb_test_bit(first + i, e4b->bd_info->bb_bitmap));\n\t\tmb_set_bit(first + i, e4b->bd_info->bb_bitmap);\n\t}\n}\n\nstatic void mb_cmp_bitmaps(struct ext4_buddy *e4b, void *bitmap)\n{\n\tif (unlikely(e4b->bd_info->bb_bitmap == NULL))\n\t\treturn;\n\tif (memcmp(e4b->bd_info->bb_bitmap, bitmap, e4b->bd_sb->s_blocksize)) {\n\t\tunsigned char *b1, *b2;\n\t\tint i;\n\t\tb1 = (unsigned char *) e4b->bd_info->bb_bitmap;\n\t\tb2 = (unsigned char *) bitmap;\n\t\tfor (i = 0; i < e4b->bd_sb->s_blocksize; i++) {\n\t\t\tif (b1[i] != b2[i]) {\n\t\t\t\text4_msg(e4b->bd_sb, KERN_ERR,\n\t\t\t\t\t \"corruption in group %u \"\n\t\t\t\t\t \"at byte %u(%u): %x in copy != %x \"\n\t\t\t\t\t \"on disk/prealloc\",\n\t\t\t\t\t e4b->bd_group, i, i * 8, b1[i], b2[i]);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void mb_group_bb_bitmap_alloc(struct super_block *sb,\n\t\t\tstruct ext4_group_info *grp, ext4_group_t group)\n{\n\tstruct buffer_head *bh;\n\n\tgrp->bb_bitmap = kmalloc(sb->s_blocksize, GFP_NOFS);\n\tif (!grp->bb_bitmap)\n\t\treturn;\n\n\tbh = ext4_read_block_bitmap(sb, group);\n\tif (IS_ERR_OR_NULL(bh)) {\n\t\tkfree(grp->bb_bitmap);\n\t\tgrp->bb_bitmap = NULL;\n\t\treturn;\n\t}\n\n\tmemcpy(grp->bb_bitmap, bh->b_data, sb->s_blocksize);\n\tput_bh(bh);\n}\n\nstatic void mb_group_bb_bitmap_free(struct ext4_group_info *grp)\n{\n\tkfree(grp->bb_bitmap);\n}\n\n#else\nstatic inline void mb_free_blocks_double(struct inode *inode,\n\t\t\t\tstruct ext4_buddy *e4b, int first, int count)\n{\n\treturn;\n}\nstatic inline void mb_mark_used_double(struct ext4_buddy *e4b,\n\t\t\t\t\t\tint first, int count)\n{\n\treturn;\n}\nstatic inline void mb_cmp_bitmaps(struct ext4_buddy *e4b, void *bitmap)\n{\n\treturn;\n}\n\nstatic inline void mb_group_bb_bitmap_alloc(struct super_block *sb,\n\t\t\tstruct ext4_group_info *grp, ext4_group_t group)\n{\n\treturn;\n}\n\nstatic inline void mb_group_bb_bitmap_free(struct ext4_group_info *grp)\n{\n\treturn;\n}\n#endif\n\n#ifdef AGGRESSIVE_CHECK\n\n#define MB_CHECK_ASSERT(assert)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (!(assert)) {\t\t\t\t\t\t\\\n\t\tprintk(KERN_EMERG\t\t\t\t\t\\\n\t\t\t\"Assertion failure in %s() at %s:%d: \\\"%s\\\"\\n\",\t\\\n\t\t\tfunction, file, line, # assert);\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\nstatic int __mb_check_buddy(struct ext4_buddy *e4b, char *file,\n\t\t\t\tconst char *function, int line)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\tint order = e4b->bd_blkbits + 1;\n\tint max;\n\tint max2;\n\tint i;\n\tint j;\n\tint k;\n\tint count;\n\tstruct ext4_group_info *grp;\n\tint fragments = 0;\n\tint fstart;\n\tstruct list_head *cur;\n\tvoid *buddy;\n\tvoid *buddy2;\n\n\tif (e4b->bd_info->bb_check_counter++ % 10)\n\t\treturn 0;\n\n\twhile (order > 1) {\n\t\tbuddy = mb_find_buddy(e4b, order, &max);\n\t\tMB_CHECK_ASSERT(buddy);\n\t\tbuddy2 = mb_find_buddy(e4b, order - 1, &max2);\n\t\tMB_CHECK_ASSERT(buddy2);\n\t\tMB_CHECK_ASSERT(buddy != buddy2);\n\t\tMB_CHECK_ASSERT(max * 2 == max2);\n\n\t\tcount = 0;\n\t\tfor (i = 0; i < max; i++) {\n\n\t\t\tif (mb_test_bit(i, buddy)) {\n\t\t\t\t/* only single bit in buddy2 may be 1 */\n\t\t\t\tif (!mb_test_bit(i << 1, buddy2)) {\n\t\t\t\t\tMB_CHECK_ASSERT(\n\t\t\t\t\t\tmb_test_bit((i<<1)+1, buddy2));\n\t\t\t\t} else if (!mb_test_bit((i << 1) + 1, buddy2)) {\n\t\t\t\t\tMB_CHECK_ASSERT(\n\t\t\t\t\t\tmb_test_bit(i << 1, buddy2));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* both bits in buddy2 must be 1 */\n\t\t\tMB_CHECK_ASSERT(mb_test_bit(i << 1, buddy2));\n\t\t\tMB_CHECK_ASSERT(mb_test_bit((i << 1) + 1, buddy2));\n\n\t\t\tfor (j = 0; j < (1 << order); j++) {\n\t\t\t\tk = (i * (1 << order)) + j;\n\t\t\t\tMB_CHECK_ASSERT(\n\t\t\t\t\t!mb_test_bit(k, e4b->bd_bitmap));\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tMB_CHECK_ASSERT(e4b->bd_info->bb_counters[order] == count);\n\t\torder--;\n\t}\n\n\tfstart = -1;\n\tbuddy = mb_find_buddy(e4b, 0, &max);\n\tfor (i = 0; i < max; i++) {\n\t\tif (!mb_test_bit(i, buddy)) {\n\t\t\tMB_CHECK_ASSERT(i >= e4b->bd_info->bb_first_free);\n\t\t\tif (fstart == -1) {\n\t\t\t\tfragments++;\n\t\t\t\tfstart = i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfstart = -1;\n\t\t/* check used bits only */\n\t\tfor (j = 0; j < e4b->bd_blkbits + 1; j++) {\n\t\t\tbuddy2 = mb_find_buddy(e4b, j, &max2);\n\t\t\tk = i >> j;\n\t\t\tMB_CHECK_ASSERT(k < max2);\n\t\t\tMB_CHECK_ASSERT(mb_test_bit(k, buddy2));\n\t\t}\n\t}\n\tMB_CHECK_ASSERT(!EXT4_MB_GRP_NEED_INIT(e4b->bd_info));\n\tMB_CHECK_ASSERT(e4b->bd_info->bb_fragments == fragments);\n\n\tgrp = ext4_get_group_info(sb, e4b->bd_group);\n\tlist_for_each(cur, &grp->bb_prealloc_list) {\n\t\text4_group_t groupnr;\n\t\tstruct ext4_prealloc_space *pa;\n\t\tpa = list_entry(cur, struct ext4_prealloc_space, pa_group_list);\n\t\text4_get_group_no_and_offset(sb, pa->pa_pstart, &groupnr, &k);\n\t\tMB_CHECK_ASSERT(groupnr == e4b->bd_group);\n\t\tfor (i = 0; i < pa->pa_len; i++)\n\t\t\tMB_CHECK_ASSERT(mb_test_bit(k + i, buddy));\n\t}\n\treturn 0;\n}\n#undef MB_CHECK_ASSERT\n#define mb_check_buddy(e4b) __mb_check_buddy(e4b,\t\\\n\t\t\t\t\t__FILE__, __func__, __LINE__)\n#else\n#define mb_check_buddy(e4b)\n#endif\n\n/*\n * Divide blocks started from @first with length @len into\n * smaller chunks with power of 2 blocks.\n * Clear the bits in bitmap which the blocks of the chunk(s) covered,\n * then increase bb_counters[] for corresponded chunk size.\n */\nstatic void ext4_mb_mark_free_simple(struct super_block *sb,\n\t\t\t\tvoid *buddy, ext4_grpblk_t first, ext4_grpblk_t len,\n\t\t\t\t\tstruct ext4_group_info *grp)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t min;\n\text4_grpblk_t max;\n\text4_grpblk_t chunk;\n\tunsigned int border;\n\n\tBUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));\n\n\tborder = 2 << sb->s_blocksize_bits;\n\n\twhile (len > 0) {\n\t\t/* find how many blocks can be covered since this position */\n\t\tmax = ffs(first | border) - 1;\n\n\t\t/* find how many blocks of power 2 we need to mark */\n\t\tmin = fls(len) - 1;\n\n\t\tif (max < min)\n\t\t\tmin = max;\n\t\tchunk = 1 << min;\n\n\t\t/* mark multiblock chunks only */\n\t\tgrp->bb_counters[min]++;\n\t\tif (min > 0)\n\t\t\tmb_clear_bit(first >> min,\n\t\t\t\t     buddy + sbi->s_mb_offsets[min]);\n\n\t\tlen -= chunk;\n\t\tfirst += chunk;\n\t}\n}\n\n/*\n * Cache the order of the largest free extent we have available in this block\n * group.\n */\nstatic void\nmb_set_largest_free_order(struct super_block *sb, struct ext4_group_info *grp)\n{\n\tint i;\n\tint bits;\n\n\tgrp->bb_largest_free_order = -1; /* uninit */\n\n\tbits = sb->s_blocksize_bits + 1;\n\tfor (i = bits; i >= 0; i--) {\n\t\tif (grp->bb_counters[i] > 0) {\n\t\t\tgrp->bb_largest_free_order = i;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic noinline_for_stack\nvoid ext4_mb_generate_buddy(struct super_block *sb,\n\t\t\t\tvoid *buddy, void *bitmap, ext4_group_t group)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t max = EXT4_CLUSTERS_PER_GROUP(sb);\n\text4_grpblk_t i = 0;\n\text4_grpblk_t first;\n\text4_grpblk_t len;\n\tunsigned free = 0;\n\tunsigned fragments = 0;\n\tunsigned long long period = get_cycles();\n\n\t/* initialize buddy from bitmap which is aggregation\n\t * of on-disk bitmap and preallocations */\n\ti = mb_find_next_zero_bit(bitmap, max, 0);\n\tgrp->bb_first_free = i;\n\twhile (i < max) {\n\t\tfragments++;\n\t\tfirst = i;\n\t\ti = mb_find_next_bit(bitmap, max, i);\n\t\tlen = i - first;\n\t\tfree += len;\n\t\tif (len > 1)\n\t\t\text4_mb_mark_free_simple(sb, buddy, first, len, grp);\n\t\telse\n\t\t\tgrp->bb_counters[0]++;\n\t\tif (i < max)\n\t\t\ti = mb_find_next_zero_bit(bitmap, max, i);\n\t}\n\tgrp->bb_fragments = fragments;\n\n\tif (free != grp->bb_free) {\n\t\text4_grp_locked_error(sb, group, 0, 0,\n\t\t\t\t      \"block bitmap and bg descriptor \"\n\t\t\t\t      \"inconsistent: %u vs %u free clusters\",\n\t\t\t\t      free, grp->bb_free);\n\t\t/*\n\t\t * If we intend to continue, we consider group descriptor\n\t\t * corrupt and update bb_free using bitmap value\n\t\t */\n\t\tgrp->bb_free = free;\n\t\text4_mark_group_bitmap_corrupted(sb, group,\n\t\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT);\n\t}\n\tmb_set_largest_free_order(sb, grp);\n\n\tclear_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &(grp->bb_state));\n\n\tperiod = get_cycles() - period;\n\tspin_lock(&sbi->s_bal_lock);\n\tsbi->s_mb_buddies_generated++;\n\tsbi->s_mb_generation_time += period;\n\tspin_unlock(&sbi->s_bal_lock);\n}\n\nstatic void mb_regenerate_buddy(struct ext4_buddy *e4b)\n{\n\tint count;\n\tint order = 1;\n\tvoid *buddy;\n\n\twhile ((buddy = mb_find_buddy(e4b, order++, &count))) {\n\t\text4_set_bits(buddy, 0, count);\n\t}\n\te4b->bd_info->bb_fragments = 0;\n\tmemset(e4b->bd_info->bb_counters, 0,\n\t\tsizeof(*e4b->bd_info->bb_counters) *\n\t\t(e4b->bd_sb->s_blocksize_bits + 2));\n\n\text4_mb_generate_buddy(e4b->bd_sb, e4b->bd_buddy,\n\t\te4b->bd_bitmap, e4b->bd_group);\n}\n\n/* The buddy information is attached the buddy cache inode\n * for convenience. The information regarding each group\n * is loaded via ext4_mb_load_buddy. The information involve\n * block bitmap and buddy information. The information are\n * stored in the inode as\n *\n * {                        page                        }\n * [ group 0 bitmap][ group 0 buddy] [group 1][ group 1]...\n *\n *\n * one block each for bitmap and buddy information.\n * So for each group we take up 2 blocks. A page can\n * contain blocks_per_page (PAGE_SIZE / blocksize)  blocks.\n * So it can have information regarding groups_per_page which\n * is blocks_per_page/2\n *\n * Locking note:  This routine takes the block group lock of all groups\n * for this page; do not hold this lock when calling this routine!\n */\n\nstatic int ext4_mb_init_cache(struct page *page, char *incore, gfp_t gfp)\n{\n\text4_group_t ngroups;\n\tint blocksize;\n\tint blocks_per_page;\n\tint groups_per_page;\n\tint err = 0;\n\tint i;\n\text4_group_t first_group, group;\n\tint first_block;\n\tstruct super_block *sb;\n\tstruct buffer_head *bhs;\n\tstruct buffer_head **bh = NULL;\n\tstruct inode *inode;\n\tchar *data;\n\tchar *bitmap;\n\tstruct ext4_group_info *grinfo;\n\n\tinode = page->mapping->host;\n\tsb = inode->i_sb;\n\tngroups = ext4_get_groups_count(sb);\n\tblocksize = i_blocksize(inode);\n\tblocks_per_page = PAGE_SIZE / blocksize;\n\n\tmb_debug(sb, \"init page %lu\\n\", page->index);\n\n\tgroups_per_page = blocks_per_page >> 1;\n\tif (groups_per_page == 0)\n\t\tgroups_per_page = 1;\n\n\t/* allocate buffer_heads to read bitmaps */\n\tif (groups_per_page > 1) {\n\t\ti = sizeof(struct buffer_head *) * groups_per_page;\n\t\tbh = kzalloc(i, gfp);\n\t\tif (bh == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tbh = &bhs;\n\n\tfirst_group = page->index * blocks_per_page / 2;\n\n\t/* read all groups the page covers into the cache */\n\tfor (i = 0, group = first_group; i < groups_per_page; i++, group++) {\n\t\tif (group >= ngroups)\n\t\t\tbreak;\n\n\t\tgrinfo = ext4_get_group_info(sb, group);\n\t\t/*\n\t\t * If page is uptodate then we came here after online resize\n\t\t * which added some new uninitialized group info structs, so\n\t\t * we must skip all initialized uptodate buddies on the page,\n\t\t * which may be currently in use by an allocating task.\n\t\t */\n\t\tif (PageUptodate(page) && !EXT4_MB_GRP_NEED_INIT(grinfo)) {\n\t\t\tbh[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tbh[i] = ext4_read_block_bitmap_nowait(sb, group, false);\n\t\tif (IS_ERR(bh[i])) {\n\t\t\terr = PTR_ERR(bh[i]);\n\t\t\tbh[i] = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tmb_debug(sb, \"read bitmap for group %u\\n\", group);\n\t}\n\n\t/* wait for I/O completion */\n\tfor (i = 0, group = first_group; i < groups_per_page; i++, group++) {\n\t\tint err2;\n\n\t\tif (!bh[i])\n\t\t\tcontinue;\n\t\terr2 = ext4_wait_block_bitmap(sb, group, bh[i]);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\n\tfirst_block = page->index * blocks_per_page;\n\tfor (i = 0; i < blocks_per_page; i++) {\n\t\tgroup = (first_block + i) >> 1;\n\t\tif (group >= ngroups)\n\t\t\tbreak;\n\n\t\tif (!bh[group - first_group])\n\t\t\t/* skip initialized uptodate buddy */\n\t\t\tcontinue;\n\n\t\tif (!buffer_verified(bh[group - first_group]))\n\t\t\t/* Skip faulty bitmaps */\n\t\t\tcontinue;\n\t\terr = 0;\n\n\t\t/*\n\t\t * data carry information regarding this\n\t\t * particular group in the format specified\n\t\t * above\n\t\t *\n\t\t */\n\t\tdata = page_address(page) + (i * blocksize);\n\t\tbitmap = bh[group - first_group]->b_data;\n\n\t\t/*\n\t\t * We place the buddy block and bitmap block\n\t\t * close together\n\t\t */\n\t\tif ((first_block + i) & 1) {\n\t\t\t/* this is block of buddy */\n\t\t\tBUG_ON(incore == NULL);\n\t\t\tmb_debug(sb, \"put buddy for group %u in page %lu/%x\\n\",\n\t\t\t\tgroup, page->index, i * blocksize);\n\t\t\ttrace_ext4_mb_buddy_bitmap_load(sb, group);\n\t\t\tgrinfo = ext4_get_group_info(sb, group);\n\t\t\tgrinfo->bb_fragments = 0;\n\t\t\tmemset(grinfo->bb_counters, 0,\n\t\t\t       sizeof(*grinfo->bb_counters) *\n\t\t\t\t(sb->s_blocksize_bits+2));\n\t\t\t/*\n\t\t\t * incore got set to the group block bitmap below\n\t\t\t */\n\t\t\text4_lock_group(sb, group);\n\t\t\t/* init the buddy */\n\t\t\tmemset(data, 0xff, blocksize);\n\t\t\text4_mb_generate_buddy(sb, data, incore, group);\n\t\t\text4_unlock_group(sb, group);\n\t\t\tincore = NULL;\n\t\t} else {\n\t\t\t/* this is block of bitmap */\n\t\t\tBUG_ON(incore != NULL);\n\t\t\tmb_debug(sb, \"put bitmap for group %u in page %lu/%x\\n\",\n\t\t\t\tgroup, page->index, i * blocksize);\n\t\t\ttrace_ext4_mb_bitmap_load(sb, group);\n\n\t\t\t/* see comments in ext4_mb_put_pa() */\n\t\t\text4_lock_group(sb, group);\n\t\t\tmemcpy(data, bitmap, blocksize);\n\n\t\t\t/* mark all preallocated blks used in in-core bitmap */\n\t\t\text4_mb_generate_from_pa(sb, data, group);\n\t\t\text4_mb_generate_from_freelist(sb, data, group);\n\t\t\text4_unlock_group(sb, group);\n\n\t\t\t/* set incore so that the buddy information can be\n\t\t\t * generated using this\n\t\t\t */\n\t\t\tincore = data;\n\t\t}\n\t}\n\tSetPageUptodate(page);\n\nout:\n\tif (bh) {\n\t\tfor (i = 0; i < groups_per_page; i++)\n\t\t\tbrelse(bh[i]);\n\t\tif (bh != &bhs)\n\t\t\tkfree(bh);\n\t}\n\treturn err;\n}\n\n/*\n * Lock the buddy and bitmap pages. This make sure other parallel init_group\n * on the same buddy page doesn't happen whild holding the buddy page lock.\n * Return locked buddy and bitmap pages on e4b struct. If buddy and bitmap\n * are on the same page e4b->bd_buddy_page is NULL and return value is 0.\n */\nstatic int ext4_mb_get_buddy_page_lock(struct super_block *sb,\n\t\text4_group_t group, struct ext4_buddy *e4b, gfp_t gfp)\n{\n\tstruct inode *inode = EXT4_SB(sb)->s_buddy_cache;\n\tint block, pnum, poff;\n\tint blocks_per_page;\n\tstruct page *page;\n\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tblocks_per_page = PAGE_SIZE / sb->s_blocksize;\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\tpage = find_or_create_page(inode->i_mapping, pnum, gfp);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tBUG_ON(page->mapping != inode->i_mapping);\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tif (blocks_per_page >= 2) {\n\t\t/* buddy and bitmap are on the same page */\n\t\treturn 0;\n\t}\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpage = find_or_create_page(inode->i_mapping, pnum, gfp);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tBUG_ON(page->mapping != inode->i_mapping);\n\te4b->bd_buddy_page = page;\n\treturn 0;\n}\n\nstatic void ext4_mb_put_buddy_page_lock(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page) {\n\t\tunlock_page(e4b->bd_bitmap_page);\n\t\tput_page(e4b->bd_bitmap_page);\n\t}\n\tif (e4b->bd_buddy_page) {\n\t\tunlock_page(e4b->bd_buddy_page);\n\t\tput_page(e4b->bd_buddy_page);\n\t}\n}\n\n/*\n * Locking note:  This routine calls ext4_mb_init_cache(), which takes the\n * block group lock of all groups for this page; do not hold the BG lock when\n * calling this routine!\n */\nstatic noinline_for_stack\nint ext4_mb_init_group(struct super_block *sb, ext4_group_t group, gfp_t gfp)\n{\n\n\tstruct ext4_group_info *this_grp;\n\tstruct ext4_buddy e4b;\n\tstruct page *page;\n\tint ret = 0;\n\n\tmight_sleep();\n\tmb_debug(sb, \"init group %u\\n\", group);\n\tthis_grp = ext4_get_group_info(sb, group);\n\t/*\n\t * This ensures that we don't reinit the buddy cache\n\t * page which map to the group from which we are already\n\t * allocating. If we are looking at the buddy cache we would\n\t * have taken a reference using ext4_mb_load_buddy and that\n\t * would have pinned buddy page to page cache.\n\t * The call to ext4_mb_get_buddy_page_lock will mark the\n\t * page accessed.\n\t */\n\tret = ext4_mb_get_buddy_page_lock(sb, group, &e4b, gfp);\n\tif (ret || !EXT4_MB_GRP_NEED_INIT(this_grp)) {\n\t\t/*\n\t\t * somebody initialized the group\n\t\t * return without doing anything\n\t\t */\n\t\tgoto err;\n\t}\n\n\tpage = e4b.bd_bitmap_page;\n\tret = ext4_mb_init_cache(page, NULL, gfp);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (e4b.bd_buddy_page == NULL) {\n\t\t/*\n\t\t * If both the bitmap and buddy are in\n\t\t * the same page we don't need to force\n\t\t * init the buddy\n\t\t */\n\t\tret = 0;\n\t\tgoto err;\n\t}\n\t/* init buddy cache */\n\tpage = e4b.bd_buddy_page;\n\tret = ext4_mb_init_cache(page, e4b.bd_bitmap, gfp);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\nerr:\n\text4_mb_put_buddy_page_lock(&e4b);\n\treturn ret;\n}\n\n/*\n * Locking note:  This routine calls ext4_mb_init_cache(), which takes the\n * block group lock of all groups for this page; do not hold the BG lock when\n * calling this routine!\n */\nstatic noinline_for_stack int\next4_mb_load_buddy_gfp(struct super_block *sb, ext4_group_t group,\n\t\t       struct ext4_buddy *e4b, gfp_t gfp)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(sb, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group, gfp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tput_page(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, gfp);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL, gfp);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tput_page(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, gfp);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap,\n\t\t\t\t\t\t\t gfp);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tput_page(page);\n\tif (e4b->bd_bitmap_page)\n\t\tput_page(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tput_page(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}\n\nstatic int ext4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t      struct ext4_buddy *e4b)\n{\n\treturn ext4_mb_load_buddy_gfp(sb, group, e4b, GFP_NOFS);\n}\n\nstatic void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tput_page(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tput_page(e4b->bd_buddy_page);\n}\n\n\nstatic int mb_find_order_for_block(struct ext4_buddy *e4b, int block)\n{\n\tint order = 1;\n\tint bb_incr = 1 << (e4b->bd_blkbits - 1);\n\tvoid *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(block >= (1 << (e4b->bd_blkbits + 3)));\n\n\tbb = e4b->bd_buddy;\n\twhile (order <= e4b->bd_blkbits + 1) {\n\t\tblock = block >> 1;\n\t\tif (!mb_test_bit(block, bb)) {\n\t\t\t/* this block is part of buddy of order 'order' */\n\t\t\treturn order;\n\t\t}\n\t\tbb += bb_incr;\n\t\tbb_incr >>= 1;\n\t\torder++;\n\t}\n\treturn 0;\n}\n\nstatic void mb_clear_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: clear whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_clear_bit(cur, bm);\n\t\tcur++;\n\t}\n}\n\n/* clear bits in given range\n * will return first found zero bit if any, -1 otherwise\n */\nstatic int mb_test_and_clear_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\tint zero_bit = -1;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: clear whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\tif (*addr != (__u32)(-1) && zero_bit == -1)\n\t\t\t\tzero_bit = cur + mb_find_next_zero_bit(addr, 32, 0);\n\t\t\t*addr = 0;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!mb_test_and_clear_bit(cur, bm) && zero_bit == -1)\n\t\t\tzero_bit = cur;\n\t\tcur++;\n\t}\n\n\treturn zero_bit;\n}\n\nvoid ext4_set_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: set whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0xffffffff;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_set_bit(cur, bm);\n\t\tcur++;\n\t}\n}\n\nstatic inline int mb_buddy_adjust_border(int* bit, void* bitmap, int side)\n{\n\tif (mb_test_bit(*bit + side, bitmap)) {\n\t\tmb_clear_bit(*bit, bitmap);\n\t\t(*bit) -= side;\n\t\treturn 1;\n\t}\n\telse {\n\t\t(*bit) += side;\n\t\tmb_set_bit(*bit, bitmap);\n\t\treturn -1;\n\t}\n}\n\nstatic void mb_buddy_mark_free(struct ext4_buddy *e4b, int first, int last)\n{\n\tint max;\n\tint order = 1;\n\tvoid *buddy = mb_find_buddy(e4b, order, &max);\n\n\twhile (buddy) {\n\t\tvoid *buddy2;\n\n\t\t/* Bits in range [first; last] are known to be set since\n\t\t * corresponding blocks were allocated. Bits in range\n\t\t * (first; last) will stay set because they form buddies on\n\t\t * upper layer. We just deal with borders if they don't\n\t\t * align with upper layer and then go up.\n\t\t * Releasing entire group is all about clearing\n\t\t * single bit of highest order buddy.\n\t\t */\n\n\t\t/* Example:\n\t\t * ---------------------------------\n\t\t * |   1   |   1   |   1   |   1   |\n\t\t * ---------------------------------\n\t\t * | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |\n\t\t * ---------------------------------\n\t\t *   0   1   2   3   4   5   6   7\n\t\t *      \\_____________________/\n\t\t *\n\t\t * Neither [1] nor [6] is aligned to above layer.\n\t\t * Left neighbour [0] is free, so mark it busy,\n\t\t * decrease bb_counters and extend range to\n\t\t * [0; 6]\n\t\t * Right neighbour [7] is busy. It can't be coaleasced with [6], so\n\t\t * mark [6] free, increase bb_counters and shrink range to\n\t\t * [0; 5].\n\t\t * Then shift range to [0; 2], go up and do the same.\n\t\t */\n\n\n\t\tif (first & 1)\n\t\t\te4b->bd_info->bb_counters[order] += mb_buddy_adjust_border(&first, buddy, -1);\n\t\tif (!(last & 1))\n\t\t\te4b->bd_info->bb_counters[order] += mb_buddy_adjust_border(&last, buddy, 1);\n\t\tif (first > last)\n\t\t\tbreak;\n\t\torder++;\n\n\t\tif (first == last || !(buddy2 = mb_find_buddy(e4b, order, &max))) {\n\t\t\tmb_clear_bits(buddy, first, last - first + 1);\n\t\t\te4b->bd_info->bb_counters[order - 1] += last - first + 1;\n\t\t\tbreak;\n\t\t}\n\t\tfirst >>= 1;\n\t\tlast >>= 1;\n\t\tbuddy = buddy2;\n\t}\n}\n\nstatic void mb_free_blocks(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint left_is_free = 0;\n\tint right_is_free = 0;\n\tint block;\n\tint last = first + count - 1;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (WARN_ON(count == 0))\n\t\treturn;\n\tBUG_ON(last >= (sb->s_blocksize << 3));\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\t/* Don't bother if the block group is corrupt. */\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)))\n\t\treturn;\n\n\tmb_check_buddy(e4b);\n\tmb_free_blocks_double(inode, e4b, first, count);\n\n\tthis_cpu_inc(discard_pa_seq);\n\te4b->bd_info->bb_free += count;\n\tif (first < e4b->bd_info->bb_first_free)\n\t\te4b->bd_info->bb_first_free = first;\n\n\t/* access memory sequentially: check left neighbour,\n\t * clear range and then check right neighbour\n\t */\n\tif (first != 0)\n\t\tleft_is_free = !mb_test_bit(first - 1, e4b->bd_bitmap);\n\tblock = mb_test_and_clear_bits(e4b->bd_bitmap, first, count);\n\tif (last + 1 < EXT4_SB(sb)->s_mb_maxs[0])\n\t\tright_is_free = !mb_test_bit(last + 1, e4b->bd_bitmap);\n\n\tif (unlikely(block != -1)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\text4_fsblk_t blocknr;\n\n\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\tblocknr += EXT4_C2B(sbi, block);\n\t\tif (!(sbi->s_mount_state & EXT4_FC_REPLAY)) {\n\t\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t\t      blocknr,\n\t\t\t\t\t      \"freeing already freed block (bit %u); block bitmap corrupt.\",\n\t\t\t\t\t      block);\n\t\t\text4_mark_group_bitmap_corrupted(\n\t\t\t\tsb, e4b->bd_group,\n\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT);\n\t\t}\n\t\tmb_regenerate_buddy(e4b);\n\t\tgoto done;\n\t}\n\n\t/* let's maintain fragments counter */\n\tif (left_is_free && right_is_free)\n\t\te4b->bd_info->bb_fragments--;\n\telse if (!left_is_free && !right_is_free)\n\t\te4b->bd_info->bb_fragments++;\n\n\t/* buddy[0] == bd_bitmap is a special case, so handle\n\t * it right away and let mb_buddy_mark_free stay free of\n\t * zero order checks.\n\t * Check if neighbours are to be coaleasced,\n\t * adjust bitmap bb_counters and borders appropriately.\n\t */\n\tif (first & 1) {\n\t\tfirst += !left_is_free;\n\t\te4b->bd_info->bb_counters[0] += left_is_free ? -1 : 1;\n\t}\n\tif (!(last & 1)) {\n\t\tlast -= !right_is_free;\n\t\te4b->bd_info->bb_counters[0] += right_is_free ? -1 : 1;\n\t}\n\n\tif (first <= last)\n\t\tmb_buddy_mark_free(e4b, first >> 1, last >> 1);\n\ndone:\n\tmb_set_largest_free_order(sb, e4b->bd_info);\n\tmb_check_buddy(e4b);\n}\n\nstatic int mb_find_extent(struct ext4_buddy *e4b, int block,\n\t\t\t\tint needed, struct ext4_free_extent *ex)\n{\n\tint next = block;\n\tint max, order;\n\tvoid *buddy;\n\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tBUG_ON(ex == NULL);\n\n\tbuddy = mb_find_buddy(e4b, 0, &max);\n\tBUG_ON(buddy == NULL);\n\tBUG_ON(block >= max);\n\tif (mb_test_bit(block, buddy)) {\n\t\tex->fe_len = 0;\n\t\tex->fe_start = 0;\n\t\tex->fe_group = 0;\n\t\treturn 0;\n\t}\n\n\t/* find actual order */\n\torder = mb_find_order_for_block(e4b, block);\n\tblock = block >> order;\n\n\tex->fe_len = 1 << order;\n\tex->fe_start = block << order;\n\tex->fe_group = e4b->bd_group;\n\n\t/* calc difference from given start */\n\tnext = next - ex->fe_start;\n\tex->fe_len -= next;\n\tex->fe_start += next;\n\n\twhile (needed > ex->fe_len &&\n\t       mb_find_buddy(e4b, order, &max)) {\n\n\t\tif (block + 1 >= max)\n\t\t\tbreak;\n\n\t\tnext = (block + 1) * (1 << order);\n\t\tif (mb_test_bit(next, e4b->bd_bitmap))\n\t\t\tbreak;\n\n\t\torder = mb_find_order_for_block(e4b, next);\n\n\t\tblock = next >> order;\n\t\tex->fe_len += 1 << order;\n\t}\n\n\tif (ex->fe_start + ex->fe_len > EXT4_CLUSTERS_PER_GROUP(e4b->bd_sb)) {\n\t\t/* Should never happen! (but apparently sometimes does?!?) */\n\t\tWARN_ON(1);\n\t\text4_error(e4b->bd_sb, \"corruption or bug in mb_find_extent \"\n\t\t\t   \"block=%d, order=%d needed=%d ex=%u/%d/%d@%u\",\n\t\t\t   block, order, needed, ex->fe_group, ex->fe_start,\n\t\t\t   ex->fe_len, ex->fe_logical);\n\t\tex->fe_len = 0;\n\t\tex->fe_start = 0;\n\t\tex->fe_group = 0;\n\t}\n\treturn ex->fe_len;\n}\n\nstatic int mb_mark_used(struct ext4_buddy *e4b, struct ext4_free_extent *ex)\n{\n\tint ord;\n\tint mlen = 0;\n\tint max = 0;\n\tint cur;\n\tint start = ex->fe_start;\n\tint len = ex->fe_len;\n\tunsigned ret = 0;\n\tint len0 = len;\n\tvoid *buddy;\n\n\tBUG_ON(start + len > (e4b->bd_sb->s_blocksize << 3));\n\tBUG_ON(e4b->bd_group != ex->fe_group);\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tmb_check_buddy(e4b);\n\tmb_mark_used_double(e4b, start, len);\n\n\tthis_cpu_inc(discard_pa_seq);\n\te4b->bd_info->bb_free -= len;\n\tif (e4b->bd_info->bb_first_free == start)\n\t\te4b->bd_info->bb_first_free += len;\n\n\t/* let's maintain fragments counter */\n\tif (start != 0)\n\t\tmlen = !mb_test_bit(start - 1, e4b->bd_bitmap);\n\tif (start + len < EXT4_SB(e4b->bd_sb)->s_mb_maxs[0])\n\t\tmax = !mb_test_bit(start + len, e4b->bd_bitmap);\n\tif (mlen && max)\n\t\te4b->bd_info->bb_fragments++;\n\telse if (!mlen && !max)\n\t\te4b->bd_info->bb_fragments--;\n\n\t/* let's maintain buddy itself */\n\twhile (len) {\n\t\tord = mb_find_order_for_block(e4b, start);\n\n\t\tif (((start >> ord) << ord) == start && len >= (1 << ord)) {\n\t\t\t/* the whole chunk may be allocated at once! */\n\t\t\tmlen = 1 << ord;\n\t\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\t\tBUG_ON((start >> ord) >= max);\n\t\t\tmb_set_bit(start >> ord, buddy);\n\t\t\te4b->bd_info->bb_counters[ord]--;\n\t\t\tstart += mlen;\n\t\t\tlen -= mlen;\n\t\t\tBUG_ON(len < 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* store for history */\n\t\tif (ret == 0)\n\t\t\tret = len | (ord << 16);\n\n\t\t/* we have to split large buddy */\n\t\tBUG_ON(ord <= 0);\n\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\tmb_set_bit(start >> ord, buddy);\n\t\te4b->bd_info->bb_counters[ord]--;\n\n\t\tord--;\n\t\tcur = (start >> ord) & ~1U;\n\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\tmb_clear_bit(cur, buddy);\n\t\tmb_clear_bit(cur + 1, buddy);\n\t\te4b->bd_info->bb_counters[ord]++;\n\t\te4b->bd_info->bb_counters[ord]++;\n\t}\n\tmb_set_largest_free_order(e4b->bd_sb, e4b->bd_info);\n\n\text4_set_bits(e4b->bd_bitmap, ex->fe_start, len0);\n\tmb_check_buddy(e4b);\n\n\treturn ret;\n}\n\n/*\n * Must be called under group lock!\n */\nstatic void ext4_mb_use_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint ret;\n\n\tBUG_ON(ac->ac_b_ex.fe_group != e4b->bd_group);\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\tac->ac_b_ex.fe_len = min(ac->ac_b_ex.fe_len, ac->ac_g_ex.fe_len);\n\tac->ac_b_ex.fe_logical = ac->ac_g_ex.fe_logical;\n\tret = mb_mark_used(e4b, &ac->ac_b_ex);\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_tail = ret & 0xffff;\n\tac->ac_buddy = ret >> 16;\n\n\t/*\n\t * take the page reference. We want the page to be pinned\n\t * so that we don't get a ext4_mb_init_cache_call for this\n\t * group until we update the bitmap. That would mean we\n\t * double allocate blocks. The reference is dropped\n\t * in ext4_mb_release_context\n\t */\n\tac->ac_bitmap_page = e4b->bd_bitmap_page;\n\tget_page(ac->ac_bitmap_page);\n\tac->ac_buddy_page = e4b->bd_buddy_page;\n\tget_page(ac->ac_buddy_page);\n\t/* store last allocated for subsequent stream allocation */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tsbi->s_mb_last_group = ac->ac_f_ex.fe_group;\n\t\tsbi->s_mb_last_start = ac->ac_f_ex.fe_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n\t/*\n\t * As we've just preallocated more space than\n\t * user requested originally, we store allocated\n\t * space in a special descriptor.\n\t */\n\tif (ac->ac_o_ex.fe_len < ac->ac_b_ex.fe_len)\n\t\text4_mb_new_preallocation(ac);\n\n}\n\nstatic void ext4_mb_check_limits(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b,\n\t\t\t\t\tint finish_group)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_free_extent *bex = &ac->ac_b_ex;\n\tstruct ext4_free_extent *gex = &ac->ac_g_ex;\n\tstruct ext4_free_extent ex;\n\tint max;\n\n\tif (ac->ac_status == AC_STATUS_FOUND)\n\t\treturn;\n\t/*\n\t * We don't want to scan for a whole year\n\t */\n\tif (ac->ac_found > sbi->s_mb_max_to_scan &&\n\t\t\t!(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\tac->ac_status = AC_STATUS_BREAK;\n\t\treturn;\n\t}\n\n\t/*\n\t * Haven't found good chunk so far, let's continue\n\t */\n\tif (bex->fe_len < gex->fe_len)\n\t\treturn;\n\n\tif ((finish_group || ac->ac_found > sbi->s_mb_min_to_scan)\n\t\t\t&& bex->fe_group == e4b->bd_group) {\n\t\t/* recheck chunk's availability - we don't know\n\t\t * when it was found (within this lock-unlock\n\t\t * period or not) */\n\t\tmax = mb_find_extent(e4b, bex->fe_start, gex->fe_len, &ex);\n\t\tif (max >= gex->fe_len) {\n\t\t\text4_mb_use_best_found(ac, e4b);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n/*\n * The routine checks whether found extent is good enough. If it is,\n * then the extent gets marked used and flag is set to the context\n * to stop scanning. Otherwise, the extent is compared with the\n * previous found extent and if new one is better, then it's stored\n * in the context. Later, the best found extent will be used, if\n * mballoc can't find good enough extent.\n *\n * FIXME: real allocation policy is to be designed yet!\n */\nstatic void ext4_mb_measure_extent(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_free_extent *ex,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_free_extent *bex = &ac->ac_b_ex;\n\tstruct ext4_free_extent *gex = &ac->ac_g_ex;\n\n\tBUG_ON(ex->fe_len <= 0);\n\tBUG_ON(ex->fe_len > EXT4_CLUSTERS_PER_GROUP(ac->ac_sb));\n\tBUG_ON(ex->fe_start >= EXT4_CLUSTERS_PER_GROUP(ac->ac_sb));\n\tBUG_ON(ac->ac_status != AC_STATUS_CONTINUE);\n\n\tac->ac_found++;\n\n\t/*\n\t * The special case - take what you catch first\n\t */\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\t*bex = *ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t\treturn;\n\t}\n\n\t/*\n\t * Let's check whether the chuck is good enough\n\t */\n\tif (ex->fe_len == gex->fe_len) {\n\t\t*bex = *ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t\treturn;\n\t}\n\n\t/*\n\t * If this is first found extent, just store it in the context\n\t */\n\tif (bex->fe_len == 0) {\n\t\t*bex = *ex;\n\t\treturn;\n\t}\n\n\t/*\n\t * If new found extent is better, store it in the context\n\t */\n\tif (bex->fe_len < gex->fe_len) {\n\t\t/* if the request isn't satisfied, any found extent\n\t\t * larger than previous best one is better */\n\t\tif (ex->fe_len > bex->fe_len)\n\t\t\t*bex = *ex;\n\t} else if (ex->fe_len > gex->fe_len) {\n\t\t/* if the request is satisfied, then we try to find\n\t\t * an extent that still satisfy the request, but is\n\t\t * smaller than previous one */\n\t\tif (ex->fe_len < bex->fe_len)\n\t\t\t*bex = *ex;\n\t}\n\n\text4_mb_check_limits(ac, e4b, 0);\n}\n\nstatic noinline_for_stack\nint ext4_mb_try_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_free_extent ex = ac->ac_b_ex;\n\text4_group_t group = ex.fe_group;\n\tint max;\n\tint err;\n\n\tBUG_ON(ex.fe_len <= 0);\n\terr = ext4_mb_load_buddy(ac->ac_sb, group, e4b);\n\tif (err)\n\t\treturn err;\n\n\text4_lock_group(ac->ac_sb, group);\n\tmax = mb_find_extent(e4b, ex.fe_start, ex.fe_len, &ex);\n\n\tif (max > 0) {\n\t\tac->ac_b_ex = ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t}\n\n\text4_unlock_group(ac->ac_sb, group);\n\text4_mb_unload_buddy(e4b);\n\n\treturn 0;\n}\n\nstatic noinline_for_stack\nint ext4_mb_find_by_goal(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_buddy *e4b)\n{\n\text4_group_t group = ac->ac_g_ex.fe_group;\n\tint max;\n\tint err;\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_group_info *grp = ext4_get_group_info(ac->ac_sb, group);\n\tstruct ext4_free_extent ex;\n\n\tif (!(ac->ac_flags & EXT4_MB_HINT_TRY_GOAL))\n\t\treturn 0;\n\tif (grp->bb_free == 0)\n\t\treturn 0;\n\n\terr = ext4_mb_load_buddy(ac->ac_sb, group, e4b);\n\tif (err)\n\t\treturn err;\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))) {\n\t\text4_mb_unload_buddy(e4b);\n\t\treturn 0;\n\t}\n\n\text4_lock_group(ac->ac_sb, group);\n\tmax = mb_find_extent(e4b, ac->ac_g_ex.fe_start,\n\t\t\t     ac->ac_g_ex.fe_len, &ex);\n\tex.fe_logical = 0xDEADFA11; /* debug value */\n\n\tif (max >= ac->ac_g_ex.fe_len && ac->ac_g_ex.fe_len == sbi->s_stripe) {\n\t\text4_fsblk_t start;\n\n\t\tstart = ext4_group_first_block_no(ac->ac_sb, e4b->bd_group) +\n\t\t\tex.fe_start;\n\t\t/* use do_div to get remainder (would be 64-bit modulo) */\n\t\tif (do_div(start, sbi->s_stripe) == 0) {\n\t\t\tac->ac_found++;\n\t\t\tac->ac_b_ex = ex;\n\t\t\text4_mb_use_best_found(ac, e4b);\n\t\t}\n\t} else if (max >= ac->ac_g_ex.fe_len) {\n\t\tBUG_ON(ex.fe_len <= 0);\n\t\tBUG_ON(ex.fe_group != ac->ac_g_ex.fe_group);\n\t\tBUG_ON(ex.fe_start != ac->ac_g_ex.fe_start);\n\t\tac->ac_found++;\n\t\tac->ac_b_ex = ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t} else if (max > 0 && (ac->ac_flags & EXT4_MB_HINT_MERGE)) {\n\t\t/* Sometimes, caller may want to merge even small\n\t\t * number of blocks to an existing extent */\n\t\tBUG_ON(ex.fe_len <= 0);\n\t\tBUG_ON(ex.fe_group != ac->ac_g_ex.fe_group);\n\t\tBUG_ON(ex.fe_start != ac->ac_g_ex.fe_start);\n\t\tac->ac_found++;\n\t\tac->ac_b_ex = ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t}\n\text4_unlock_group(ac->ac_sb, group);\n\text4_mb_unload_buddy(e4b);\n\n\treturn 0;\n}\n\n/*\n * The routine scans buddy structures (not bitmap!) from given order\n * to max order and tries to find big enough chunk to satisfy the req\n */\nstatic noinline_for_stack\nvoid ext4_mb_simple_scan_group(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_group_info *grp = e4b->bd_info;\n\tvoid *buddy;\n\tint i;\n\tint k;\n\tint max;\n\n\tBUG_ON(ac->ac_2order <= 0);\n\tfor (i = ac->ac_2order; i <= sb->s_blocksize_bits + 1; i++) {\n\t\tif (grp->bb_counters[i] == 0)\n\t\t\tcontinue;\n\n\t\tbuddy = mb_find_buddy(e4b, i, &max);\n\t\tBUG_ON(buddy == NULL);\n\n\t\tk = mb_find_next_zero_bit(buddy, max, 0);\n\t\tif (k >= max) {\n\t\t\text4_grp_locked_error(ac->ac_sb, e4b->bd_group, 0, 0,\n\t\t\t\t\"%d free clusters of order %d. But found 0\",\n\t\t\t\tgrp->bb_counters[i], i);\n\t\t\text4_mark_group_bitmap_corrupted(ac->ac_sb,\n\t\t\t\t\t e4b->bd_group,\n\t\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT);\n\t\t\tbreak;\n\t\t}\n\t\tac->ac_found++;\n\n\t\tac->ac_b_ex.fe_len = 1 << i;\n\t\tac->ac_b_ex.fe_start = k << i;\n\t\tac->ac_b_ex.fe_group = e4b->bd_group;\n\n\t\text4_mb_use_best_found(ac, e4b);\n\n\t\tBUG_ON(ac->ac_f_ex.fe_len != ac->ac_g_ex.fe_len);\n\n\t\tif (EXT4_SB(sb)->s_mb_stats)\n\t\t\tatomic_inc(&EXT4_SB(sb)->s_bal_2orders);\n\n\t\tbreak;\n\t}\n}\n\n/*\n * The routine scans the group and measures all found extents.\n * In order to optimize scanning, caller must pass number of\n * free blocks in the group, so the routine can know upper limit.\n */\nstatic noinline_for_stack\nvoid ext4_mb_complex_scan_group(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tvoid *bitmap = e4b->bd_bitmap;\n\tstruct ext4_free_extent ex;\n\tint i;\n\tint free;\n\n\tfree = e4b->bd_info->bb_free;\n\tif (WARN_ON(free <= 0))\n\t\treturn;\n\n\ti = e4b->bd_info->bb_first_free;\n\n\twhile (free && ac->ac_status == AC_STATUS_CONTINUE) {\n\t\ti = mb_find_next_zero_bit(bitmap,\n\t\t\t\t\t\tEXT4_CLUSTERS_PER_GROUP(sb), i);\n\t\tif (i >= EXT4_CLUSTERS_PER_GROUP(sb)) {\n\t\t\t/*\n\t\t\t * IF we have corrupt bitmap, we won't find any\n\t\t\t * free blocks even though group info says we\n\t\t\t * have free blocks\n\t\t\t */\n\t\t\text4_grp_locked_error(sb, e4b->bd_group, 0, 0,\n\t\t\t\t\t\"%d free clusters as per \"\n\t\t\t\t\t\"group info. But bitmap says 0\",\n\t\t\t\t\tfree);\n\t\t\text4_mark_group_bitmap_corrupted(sb, e4b->bd_group,\n\t\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT);\n\t\t\tbreak;\n\t\t}\n\n\t\tmb_find_extent(e4b, i, ac->ac_g_ex.fe_len, &ex);\n\t\tif (WARN_ON(ex.fe_len <= 0))\n\t\t\tbreak;\n\t\tif (free < ex.fe_len) {\n\t\t\text4_grp_locked_error(sb, e4b->bd_group, 0, 0,\n\t\t\t\t\t\"%d free clusters as per \"\n\t\t\t\t\t\"group info. But got %d blocks\",\n\t\t\t\t\tfree, ex.fe_len);\n\t\t\text4_mark_group_bitmap_corrupted(sb, e4b->bd_group,\n\t\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT);\n\t\t\t/*\n\t\t\t * The number of free blocks differs. This mostly\n\t\t\t * indicate that the bitmap is corrupt. So exit\n\t\t\t * without claiming the space.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tex.fe_logical = 0xDEADC0DE; /* debug value */\n\t\text4_mb_measure_extent(ac, &ex, e4b);\n\n\t\ti += ex.fe_len;\n\t\tfree -= ex.fe_len;\n\t}\n\n\text4_mb_check_limits(ac, e4b, 1);\n}\n\n/*\n * This is a special case for storages like raid5\n * we try to find stripe-aligned chunks for stripe-size-multiple requests\n */\nstatic noinline_for_stack\nvoid ext4_mb_scan_aligned(struct ext4_allocation_context *ac,\n\t\t\t\t struct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tvoid *bitmap = e4b->bd_bitmap;\n\tstruct ext4_free_extent ex;\n\text4_fsblk_t first_group_block;\n\text4_fsblk_t a;\n\text4_grpblk_t i;\n\tint max;\n\n\tBUG_ON(sbi->s_stripe == 0);\n\n\t/* find first stripe-aligned block in group */\n\tfirst_group_block = ext4_group_first_block_no(sb, e4b->bd_group);\n\n\ta = first_group_block + sbi->s_stripe - 1;\n\tdo_div(a, sbi->s_stripe);\n\ti = (a * sbi->s_stripe) - first_group_block;\n\n\twhile (i < EXT4_CLUSTERS_PER_GROUP(sb)) {\n\t\tif (!mb_test_bit(i, bitmap)) {\n\t\t\tmax = mb_find_extent(e4b, i, sbi->s_stripe, &ex);\n\t\t\tif (max >= sbi->s_stripe) {\n\t\t\t\tac->ac_found++;\n\t\t\t\tex.fe_logical = 0xDEADF00D; /* debug value */\n\t\t\t\tac->ac_b_ex = ex;\n\t\t\t\text4_mb_use_best_found(ac, e4b);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti += sbi->s_stripe;\n\t}\n}\n\n/*\n * This is also called BEFORE we load the buddy bitmap.\n * Returns either 1 or 0 indicating that the group is either suitable\n * for the allocation or not.\n */\nstatic bool ext4_mb_good_group(struct ext4_allocation_context *ac,\n\t\t\t\text4_group_t group, int cr)\n{\n\text4_grpblk_t free, fragments;\n\tint flex_size = ext4_flex_bg_size(EXT4_SB(ac->ac_sb));\n\tstruct ext4_group_info *grp = ext4_get_group_info(ac->ac_sb, group);\n\n\tBUG_ON(cr < 0 || cr >= 4);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(grp)))\n\t\treturn false;\n\n\tfree = grp->bb_free;\n\tif (free == 0)\n\t\treturn false;\n\n\tfragments = grp->bb_fragments;\n\tif (fragments == 0)\n\t\treturn false;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tBUG_ON(ac->ac_2order == 0);\n\n\t\t/* Avoid using the first bg of a flexgroup for data files */\n\t\tif ((ac->ac_flags & EXT4_MB_HINT_DATA) &&\n\t\t    (flex_size >= EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME) &&\n\t\t    ((group % flex_size) == 0))\n\t\t\treturn false;\n\n\t\tif (free < ac->ac_g_ex.fe_len)\n\t\t\treturn false;\n\n\t\tif (ac->ac_2order > ac->ac_sb->s_blocksize_bits+1)\n\t\t\treturn true;\n\n\t\tif (grp->bb_largest_free_order < ac->ac_2order)\n\t\t\treturn false;\n\n\t\treturn true;\n\tcase 1:\n\t\tif ((free / fragments) >= ac->ac_g_ex.fe_len)\n\t\t\treturn true;\n\t\tbreak;\n\tcase 2:\n\t\tif (free >= ac->ac_g_ex.fe_len)\n\t\t\treturn true;\n\t\tbreak;\n\tcase 3:\n\t\treturn true;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn false;\n}\n\n/*\n * This could return negative error code if something goes wrong\n * during ext4_mb_init_group(). This should not be called with\n * ext4_lock_group() held.\n */\nstatic int ext4_mb_good_group_nolock(struct ext4_allocation_context *ac,\n\t\t\t\t     ext4_group_t group, int cr)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(ac->ac_sb, group);\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tbool should_lock = ac->ac_flags & EXT4_MB_STRICT_CHECK;\n\text4_grpblk_t free;\n\tint ret = 0;\n\n\tif (should_lock)\n\t\text4_lock_group(sb, group);\n\tfree = grp->bb_free;\n\tif (free == 0)\n\t\tgoto out;\n\tif (cr <= 2 && free < ac->ac_g_ex.fe_len)\n\t\tgoto out;\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(grp)))\n\t\tgoto out;\n\tif (should_lock)\n\t\text4_unlock_group(sb, group);\n\n\t/* We only do this if the grp has never been initialized */\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\tstruct ext4_group_desc *gdp =\n\t\t\text4_get_group_desc(sb, group, NULL);\n\t\tint ret;\n\n\t\t/* cr=0/1 is a very optimistic search to find large\n\t\t * good chunks almost for free.  If buddy data is not\n\t\t * ready, then this optimization makes no sense.  But\n\t\t * we never skip the first block group in a flex_bg,\n\t\t * since this gets used for metadata block allocation,\n\t\t * and we want to make sure we locate metadata blocks\n\t\t * in the first block group in the flex_bg if possible.\n\t\t */\n\t\tif (cr < 2 &&\n\t\t    (!sbi->s_log_groups_per_flex ||\n\t\t     ((group & ((1 << sbi->s_log_groups_per_flex) - 1)) != 0)) &&\n\t\t    !(ext4_has_group_desc_csum(sb) &&\n\t\t      (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))))\n\t\t\treturn 0;\n\t\tret = ext4_mb_init_group(sb, group, GFP_NOFS);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (should_lock)\n\t\text4_lock_group(sb, group);\n\tret = ext4_mb_good_group(ac, group, cr);\nout:\n\tif (should_lock)\n\t\text4_unlock_group(sb, group);\n\treturn ret;\n}\n\n/*\n * Start prefetching @nr block bitmaps starting at @group.\n * Return the next group which needs to be prefetched.\n */\next4_group_t ext4_mb_prefetch(struct super_block *sb, ext4_group_t group,\n\t\t\t      unsigned int nr, int *cnt)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct buffer_head *bh;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\twhile (nr-- > 0) {\n\t\tstruct ext4_group_desc *gdp = ext4_get_group_desc(sb, group,\n\t\t\t\t\t\t\t\t  NULL);\n\t\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\n\t\t/*\n\t\t * Prefetch block groups with free blocks; but don't\n\t\t * bother if it is marked uninitialized on disk, since\n\t\t * it won't require I/O to read.  Also only try to\n\t\t * prefetch once, so we avoid getblk() call, which can\n\t\t * be expensive.\n\t\t */\n\t\tif (!EXT4_MB_GRP_TEST_AND_SET_READ(grp) &&\n\t\t    EXT4_MB_GRP_NEED_INIT(grp) &&\n\t\t    ext4_free_group_clusters(sb, gdp) > 0 &&\n\t\t    !(ext4_has_group_desc_csum(sb) &&\n\t\t      (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)))) {\n\t\t\tbh = ext4_read_block_bitmap_nowait(sb, group, true);\n\t\t\tif (bh && !IS_ERR(bh)) {\n\t\t\t\tif (!buffer_uptodate(bh) && cnt)\n\t\t\t\t\t(*cnt)++;\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t}\n\t\tif (++group >= ngroups)\n\t\t\tgroup = 0;\n\t}\n\tblk_finish_plug(&plug);\n\treturn group;\n}\n\n/*\n * Prefetching reads the block bitmap into the buffer cache; but we\n * need to make sure that the buddy bitmap in the page cache has been\n * initialized.  Note that ext4_mb_init_group() will block if the I/O\n * is not yet completed, or indeed if it was not initiated by\n * ext4_mb_prefetch did not start the I/O.\n *\n * TODO: We should actually kick off the buddy bitmap setup in a work\n * queue when the buffer I/O is completed, so that we don't block\n * waiting for the block allocation bitmap read to finish when\n * ext4_mb_prefetch_fini is called from ext4_mb_regular_allocator().\n */\nvoid ext4_mb_prefetch_fini(struct super_block *sb, ext4_group_t group,\n\t\t\t   unsigned int nr)\n{\n\twhile (nr-- > 0) {\n\t\tstruct ext4_group_desc *gdp = ext4_get_group_desc(sb, group,\n\t\t\t\t\t\t\t\t  NULL);\n\t\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\n\t\tif (!group)\n\t\t\tgroup = ext4_get_groups_count(sb);\n\t\tgroup--;\n\t\tgrp = ext4_get_group_info(sb, group);\n\n\t\tif (EXT4_MB_GRP_NEED_INIT(grp) &&\n\t\t    ext4_free_group_clusters(sb, gdp) > 0 &&\n\t\t    !(ext4_has_group_desc_csum(sb) &&\n\t\t      (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)))) {\n\t\t\tif (ext4_mb_init_group(sb, group, GFP_NOFS))\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic noinline_for_stack int\next4_mb_regular_allocator(struct ext4_allocation_context *ac)\n{\n\text4_group_t prefetch_grp = 0, ngroups, group, i;\n\tint cr = -1;\n\tint err = 0, first_err = 0;\n\tunsigned int nr = 0, prefetch_ios = 0;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\tstruct ext4_buddy e4b;\n\tint lost;\n\n\tsb = ac->ac_sb;\n\tsbi = EXT4_SB(sb);\n\tngroups = ext4_get_groups_count(sb);\n\t/* non-extent files are limited to low blocks/groups */\n\tif (!(ext4_test_inode_flag(ac->ac_inode, EXT4_INODE_EXTENTS)))\n\t\tngroups = sbi->s_blockfile_groups;\n\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\t/* first, try the goal */\n\terr = ext4_mb_find_by_goal(ac, &e4b);\n\tif (err || ac->ac_status == AC_STATUS_FOUND)\n\t\tgoto out;\n\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY))\n\t\tgoto out;\n\n\t/*\n\t * ac->ac_2order is set only if the fe_len is a power of 2\n\t * if ac->ac_2order is set we also set criteria to 0 so that we\n\t * try exact allocation using buddy.\n\t */\n\ti = fls(ac->ac_g_ex.fe_len);\n\tac->ac_2order = 0;\n\t/*\n\t * We search using buddy data only if the order of the request\n\t * is greater than equal to the sbi_s_mb_order2_reqs\n\t * You can tune it via /sys/fs/ext4/<partition>/mb_order2_req\n\t * We also support searching for power-of-two requests only for\n\t * requests upto maximum buddy size we have constructed.\n\t */\n\tif (i >= sbi->s_mb_order2_reqs && i <= sb->s_blocksize_bits + 2) {\n\t\t/*\n\t\t * This should tell if fe_len is exactly power of 2\n\t\t */\n\t\tif ((ac->ac_g_ex.fe_len & (~(1 << (i - 1)))) == 0)\n\t\t\tac->ac_2order = array_index_nospec(i - 1,\n\t\t\t\t\t\t\t   sb->s_blocksize_bits + 2);\n\t}\n\n\t/* if stream allocation is enabled, use global goal */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\t/* TBD: may be hot point */\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tac->ac_g_ex.fe_group = sbi->s_mb_last_group;\n\t\tac->ac_g_ex.fe_start = sbi->s_mb_last_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n\n\t/* Let's just scan groups to find more-less suitable blocks */\n\tcr = ac->ac_2order ? 0 : 1;\n\t/*\n\t * cr == 0 try to get exact allocation,\n\t * cr == 3  try to get anything\n\t */\nrepeat:\n\tfor (; cr < 4 && ac->ac_status == AC_STATUS_CONTINUE; cr++) {\n\t\tac->ac_criteria = cr;\n\t\t/*\n\t\t * searching for the right group start\n\t\t * from the goal value specified\n\t\t */\n\t\tgroup = ac->ac_g_ex.fe_group;\n\t\tprefetch_grp = group;\n\n\t\tfor (i = 0; i < ngroups; group++, i++) {\n\t\t\tint ret = 0;\n\t\t\tcond_resched();\n\t\t\t/*\n\t\t\t * Artificially restricted ngroups for non-extent\n\t\t\t * files makes group > ngroups possible on first loop.\n\t\t\t */\n\t\t\tif (group >= ngroups)\n\t\t\t\tgroup = 0;\n\n\t\t\t/*\n\t\t\t * Batch reads of the block allocation bitmaps\n\t\t\t * to get multiple READs in flight; limit\n\t\t\t * prefetching at cr=0/1, otherwise mballoc can\n\t\t\t * spend a lot of time loading imperfect groups\n\t\t\t */\n\t\t\tif ((prefetch_grp == group) &&\n\t\t\t    (cr > 1 ||\n\t\t\t     prefetch_ios < sbi->s_mb_prefetch_limit)) {\n\t\t\t\tunsigned int curr_ios = prefetch_ios;\n\n\t\t\t\tnr = sbi->s_mb_prefetch;\n\t\t\t\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t\t\t\tnr = (group / sbi->s_mb_prefetch) *\n\t\t\t\t\t\tsbi->s_mb_prefetch;\n\t\t\t\t\tnr = nr + sbi->s_mb_prefetch - group;\n\t\t\t\t}\n\t\t\t\tprefetch_grp = ext4_mb_prefetch(sb, group,\n\t\t\t\t\t\t\tnr, &prefetch_ios);\n\t\t\t\tif (prefetch_ios == curr_ios)\n\t\t\t\t\tnr = 0;\n\t\t\t}\n\n\t\t\t/* This now checks without needing the buddy page */\n\t\t\tret = ext4_mb_good_group_nolock(ac, group, cr);\n\t\t\tif (ret <= 0) {\n\t\t\t\tif (!first_err)\n\t\t\t\t\tfirst_err = ret;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\text4_lock_group(sb, group);\n\n\t\t\t/*\n\t\t\t * We need to check again after locking the\n\t\t\t * block group\n\t\t\t */\n\t\t\tret = ext4_mb_good_group(ac, group, cr);\n\t\t\tif (ret == 0) {\n\t\t\t\text4_unlock_group(sb, group);\n\t\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tac->ac_groups_scanned++;\n\t\t\tif (cr == 0)\n\t\t\t\text4_mb_simple_scan_group(ac, &e4b);\n\t\t\telse if (cr == 1 && sbi->s_stripe &&\n\t\t\t\t\t!(ac->ac_g_ex.fe_len % sbi->s_stripe))\n\t\t\t\text4_mb_scan_aligned(ac, &e4b);\n\t\t\telse\n\t\t\t\text4_mb_complex_scan_group(ac, &e4b);\n\n\t\t\text4_unlock_group(sb, group);\n\t\t\text4_mb_unload_buddy(&e4b);\n\n\t\t\tif (ac->ac_status != AC_STATUS_CONTINUE)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ac->ac_b_ex.fe_len > 0 && ac->ac_status != AC_STATUS_FOUND &&\n\t    !(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\t/*\n\t\t * We've been searching too long. Let's try to allocate\n\t\t * the best chunk we've found so far\n\t\t */\n\t\text4_mb_try_best_found(ac, &e4b);\n\t\tif (ac->ac_status != AC_STATUS_FOUND) {\n\t\t\t/*\n\t\t\t * Someone more lucky has already allocated it.\n\t\t\t * The only thing we can do is just take first\n\t\t\t * found block(s)\n\t\t\t */\n\t\t\tlost = atomic_inc_return(&sbi->s_mb_lost_chunks);\n\t\t\tmb_debug(sb, \"lost chunk, group: %u, start: %d, len: %d, lost: %d\\n\",\n\t\t\t\t ac->ac_b_ex.fe_group, ac->ac_b_ex.fe_start,\n\t\t\t\t ac->ac_b_ex.fe_len, lost);\n\n\t\t\tac->ac_b_ex.fe_group = 0;\n\t\t\tac->ac_b_ex.fe_start = 0;\n\t\t\tac->ac_b_ex.fe_len = 0;\n\t\t\tac->ac_status = AC_STATUS_CONTINUE;\n\t\t\tac->ac_flags |= EXT4_MB_HINT_FIRST;\n\t\t\tcr = 3;\n\t\t\tgoto repeat;\n\t\t}\n\t}\nout:\n\tif (!err && ac->ac_status != AC_STATUS_FOUND && first_err)\n\t\terr = first_err;\n\n\tmb_debug(sb, \"Best len %d, origin len %d, ac_status %u, ac_flags 0x%x, cr %d ret %d\\n\",\n\t\t ac->ac_b_ex.fe_len, ac->ac_o_ex.fe_len, ac->ac_status,\n\t\t ac->ac_flags, cr, err);\n\n\tif (nr)\n\t\text4_mb_prefetch_fini(sb, prefetch_grp, nr);\n\n\treturn err;\n}\n\nstatic void *ext4_mb_seq_groups_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct super_block *sb = PDE_DATA(file_inode(seq->file));\n\text4_group_t group;\n\n\tif (*pos < 0 || *pos >= ext4_get_groups_count(sb))\n\t\treturn NULL;\n\tgroup = *pos + 1;\n\treturn (void *) ((unsigned long) group);\n}\n\nstatic void *ext4_mb_seq_groups_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct super_block *sb = PDE_DATA(file_inode(seq->file));\n\text4_group_t group;\n\n\t++*pos;\n\tif (*pos < 0 || *pos >= ext4_get_groups_count(sb))\n\t\treturn NULL;\n\tgroup = *pos + 1;\n\treturn (void *) ((unsigned long) group);\n}\n\nstatic int ext4_mb_seq_groups_show(struct seq_file *seq, void *v)\n{\n\tstruct super_block *sb = PDE_DATA(file_inode(seq->file));\n\text4_group_t group = (ext4_group_t) ((unsigned long) v);\n\tint i;\n\tint err, buddy_loaded = 0;\n\tstruct ext4_buddy e4b;\n\tstruct ext4_group_info *grinfo;\n\tunsigned char blocksize_bits = min_t(unsigned char,\n\t\t\t\t\t     sb->s_blocksize_bits,\n\t\t\t\t\t     EXT4_MAX_BLOCK_LOG_SIZE);\n\tstruct sg {\n\t\tstruct ext4_group_info info;\n\t\text4_grpblk_t counters[EXT4_MAX_BLOCK_LOG_SIZE + 2];\n\t} sg;\n\n\tgroup--;\n\tif (group == 0)\n\t\tseq_puts(seq, \"#group: free  frags first [\"\n\t\t\t      \" 2^0   2^1   2^2   2^3   2^4   2^5   2^6  \"\n\t\t\t      \" 2^7   2^8   2^9   2^10  2^11  2^12  2^13  ]\\n\");\n\n\ti = (blocksize_bits + 2) * sizeof(sg.info.bb_counters[0]) +\n\t\tsizeof(struct ext4_group_info);\n\n\tgrinfo = ext4_get_group_info(sb, group);\n\t/* Load the group info in memory only if not already loaded. */\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grinfo))) {\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\tseq_printf(seq, \"#%-5u: I/O error\\n\", group);\n\t\t\treturn 0;\n\t\t}\n\t\tbuddy_loaded = 1;\n\t}\n\n\tmemcpy(&sg, ext4_get_group_info(sb, group), i);\n\n\tif (buddy_loaded)\n\t\text4_mb_unload_buddy(&e4b);\n\n\tseq_printf(seq, \"#%-5u: %-5u %-5u %-5u [\", group, sg.info.bb_free,\n\t\t\tsg.info.bb_fragments, sg.info.bb_first_free);\n\tfor (i = 0; i <= 13; i++)\n\t\tseq_printf(seq, \" %-5u\", i <= blocksize_bits + 1 ?\n\t\t\t\tsg.info.bb_counters[i] : 0);\n\tseq_puts(seq, \" ]\\n\");\n\n\treturn 0;\n}\n\nstatic void ext4_mb_seq_groups_stop(struct seq_file *seq, void *v)\n{\n}\n\nconst struct seq_operations ext4_mb_seq_groups_ops = {\n\t.start  = ext4_mb_seq_groups_start,\n\t.next   = ext4_mb_seq_groups_next,\n\t.stop   = ext4_mb_seq_groups_stop,\n\t.show   = ext4_mb_seq_groups_show,\n};\n\nstatic struct kmem_cache *get_groupinfo_cache(int blocksize_bits)\n{\n\tint cache_index = blocksize_bits - EXT4_MIN_BLOCK_LOG_SIZE;\n\tstruct kmem_cache *cachep = ext4_groupinfo_caches[cache_index];\n\n\tBUG_ON(!cachep);\n\treturn cachep;\n}\n\n/*\n * Allocate the top-level s_group_info array for the specified number\n * of groups\n */\nint ext4_mb_alloc_groupinfo(struct super_block *sb, ext4_group_t ngroups)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned size;\n\tstruct ext4_group_info ***old_groupinfo, ***new_groupinfo;\n\n\tsize = (ngroups + EXT4_DESC_PER_BLOCK(sb) - 1) >>\n\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\tif (size <= sbi->s_group_info_size)\n\t\treturn 0;\n\n\tsize = roundup_pow_of_two(sizeof(*sbi->s_group_info) * size);\n\tnew_groupinfo = kvzalloc(size, GFP_KERNEL);\n\tif (!new_groupinfo) {\n\t\text4_msg(sb, KERN_ERR, \"can't allocate buddy meta group\");\n\t\treturn -ENOMEM;\n\t}\n\trcu_read_lock();\n\told_groupinfo = rcu_dereference(sbi->s_group_info);\n\tif (old_groupinfo)\n\t\tmemcpy(new_groupinfo, old_groupinfo,\n\t\t       sbi->s_group_info_size * sizeof(*sbi->s_group_info));\n\trcu_read_unlock();\n\trcu_assign_pointer(sbi->s_group_info, new_groupinfo);\n\tsbi->s_group_info_size = size / sizeof(*sbi->s_group_info);\n\tif (old_groupinfo)\n\t\text4_kvfree_array_rcu(old_groupinfo);\n\text4_debug(\"allocated s_groupinfo array for %d meta_bg's\\n\", \n\t\t   sbi->s_group_info_size);\n\treturn 0;\n}\n\n/* Create and initialize ext4_group_info data for the given group. */\nint ext4_mb_add_groupinfo(struct super_block *sb, ext4_group_t group,\n\t\t\t  struct ext4_group_desc *desc)\n{\n\tint i;\n\tint metalen = 0;\n\tint idx = group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_info **meta_group_info;\n\tstruct kmem_cache *cachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\n\t/*\n\t * First check if this group is the first of a reserved block.\n\t * If it's true, we have to allocate a new table of pointers\n\t * to ext4_group_info structures\n\t */\n\tif (group % EXT4_DESC_PER_BLOCK(sb) == 0) {\n\t\tmetalen = sizeof(*meta_group_info) <<\n\t\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\t\tmeta_group_info = kmalloc(metalen, GFP_NOFS);\n\t\tif (meta_group_info == NULL) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't allocate mem \"\n\t\t\t\t \"for a buddy group\");\n\t\t\tgoto exit_meta_group_info;\n\t\t}\n\t\trcu_read_lock();\n\t\trcu_dereference(sbi->s_group_info)[idx] = meta_group_info;\n\t\trcu_read_unlock();\n\t}\n\n\tmeta_group_info = sbi_array_rcu_deref(sbi, s_group_info, idx);\n\ti = group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\n\tmeta_group_info[i] = kmem_cache_zalloc(cachep, GFP_NOFS);\n\tif (meta_group_info[i] == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"can't allocate buddy mem\");\n\t\tgoto exit_group_info;\n\t}\n\tset_bit(EXT4_GROUP_INFO_NEED_INIT_BIT,\n\t\t&(meta_group_info[i]->bb_state));\n\n\t/*\n\t * initialize bb_free to be able to skip\n\t * empty groups without initialization\n\t */\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {\n\t\tmeta_group_info[i]->bb_free =\n\t\t\text4_free_clusters_after_init(sb, group, desc);\n\t} else {\n\t\tmeta_group_info[i]->bb_free =\n\t\t\text4_free_group_clusters(sb, desc);\n\t}\n\n\tINIT_LIST_HEAD(&meta_group_info[i]->bb_prealloc_list);\n\tinit_rwsem(&meta_group_info[i]->alloc_sem);\n\tmeta_group_info[i]->bb_free_root = RB_ROOT;\n\tmeta_group_info[i]->bb_largest_free_order = -1;  /* uninit */\n\n\tmb_group_bb_bitmap_alloc(sb, meta_group_info[i], group);\n\treturn 0;\n\nexit_group_info:\n\t/* If a meta_group_info table has been allocated, release it now */\n\tif (group % EXT4_DESC_PER_BLOCK(sb) == 0) {\n\t\tstruct ext4_group_info ***group_info;\n\n\t\trcu_read_lock();\n\t\tgroup_info = rcu_dereference(sbi->s_group_info);\n\t\tkfree(group_info[idx]);\n\t\tgroup_info[idx] = NULL;\n\t\trcu_read_unlock();\n\t}\nexit_meta_group_info:\n\treturn -ENOMEM;\n} /* ext4_mb_add_groupinfo */\n\nstatic int ext4_mb_init_backend(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\text4_group_t i;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint err;\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_group_info ***group_info;\n\tstruct kmem_cache *cachep;\n\n\terr = ext4_mb_alloc_groupinfo(sb, ngroups);\n\tif (err)\n\t\treturn err;\n\n\tsbi->s_buddy_cache = new_inode(sb);\n\tif (sbi->s_buddy_cache == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"can't get new inode\");\n\t\tgoto err_freesgi;\n\t}\n\t/* To avoid potentially colliding with an valid on-disk inode number,\n\t * use EXT4_BAD_INO for the buddy cache inode number.  This inode is\n\t * not in the inode hash, so it should never be found by iget(), but\n\t * this will avoid confusion if it ever shows up during debugging. */\n\tsbi->s_buddy_cache->i_ino = EXT4_BAD_INO;\n\tEXT4_I(sbi->s_buddy_cache)->i_disksize = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tcond_resched();\n\t\tdesc = ext4_get_group_desc(sb, i, NULL);\n\t\tif (desc == NULL) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't read descriptor %u\", i);\n\t\t\tgoto err_freebuddy;\n\t\t}\n\t\tif (ext4_mb_add_groupinfo(sb, i, desc) != 0)\n\t\t\tgoto err_freebuddy;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* a single flex group is supposed to be read by a single IO */\n\t\tsbi->s_mb_prefetch = 1 << sbi->s_es->s_log_groups_per_flex;\n\t\tsbi->s_mb_prefetch *= 8; /* 8 prefetch IOs in flight at most */\n\t} else {\n\t\tsbi->s_mb_prefetch = 32;\n\t}\n\tif (sbi->s_mb_prefetch > ext4_get_groups_count(sb))\n\t\tsbi->s_mb_prefetch = ext4_get_groups_count(sb);\n\t/* now many real IOs to prefetch within a single allocation at cr=0\n\t * given cr=0 is an CPU-related optimization we shouldn't try to\n\t * load too many groups, at some point we should start to use what\n\t * we've got in memory.\n\t * with an average random access time 5ms, it'd take a second to get\n\t * 200 groups (* N with flex_bg), so let's make this limit 4\n\t */\n\tsbi->s_mb_prefetch_limit = sbi->s_mb_prefetch * 4;\n\tif (sbi->s_mb_prefetch_limit > ext4_get_groups_count(sb))\n\t\tsbi->s_mb_prefetch_limit = ext4_get_groups_count(sb);\n\n\treturn 0;\n\nerr_freebuddy:\n\tcachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\twhile (i-- > 0)\n\t\tkmem_cache_free(cachep, ext4_get_group_info(sb, i));\n\ti = sbi->s_group_info_size;\n\trcu_read_lock();\n\tgroup_info = rcu_dereference(sbi->s_group_info);\n\twhile (i-- > 0)\n\t\tkfree(group_info[i]);\n\trcu_read_unlock();\n\tiput(sbi->s_buddy_cache);\nerr_freesgi:\n\trcu_read_lock();\n\tkvfree(rcu_dereference(sbi->s_group_info));\n\trcu_read_unlock();\n\treturn -ENOMEM;\n}\n\nstatic void ext4_groupinfo_destroy_slabs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_GRPINFO_CACHES; i++) {\n\t\tkmem_cache_destroy(ext4_groupinfo_caches[i]);\n\t\text4_groupinfo_caches[i] = NULL;\n\t}\n}\n\nstatic int ext4_groupinfo_create_slab(size_t size)\n{\n\tstatic DEFINE_MUTEX(ext4_grpinfo_slab_create_mutex);\n\tint slab_size;\n\tint blocksize_bits = order_base_2(size);\n\tint cache_index = blocksize_bits - EXT4_MIN_BLOCK_LOG_SIZE;\n\tstruct kmem_cache *cachep;\n\n\tif (cache_index >= NR_GRPINFO_CACHES)\n\t\treturn -EINVAL;\n\n\tif (unlikely(cache_index < 0))\n\t\tcache_index = 0;\n\n\tmutex_lock(&ext4_grpinfo_slab_create_mutex);\n\tif (ext4_groupinfo_caches[cache_index]) {\n\t\tmutex_unlock(&ext4_grpinfo_slab_create_mutex);\n\t\treturn 0;\t/* Already created */\n\t}\n\n\tslab_size = offsetof(struct ext4_group_info,\n\t\t\t\tbb_counters[blocksize_bits + 2]);\n\n\tcachep = kmem_cache_create(ext4_groupinfo_slab_names[cache_index],\n\t\t\t\t\tslab_size, 0, SLAB_RECLAIM_ACCOUNT,\n\t\t\t\t\tNULL);\n\n\text4_groupinfo_caches[cache_index] = cachep;\n\n\tmutex_unlock(&ext4_grpinfo_slab_create_mutex);\n\tif (!cachep) {\n\t\tprintk(KERN_EMERG\n\t\t       \"EXT4-fs: no memory for groupinfo slab cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nint ext4_mb_init(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned i, j;\n\tunsigned offset, offset_incr;\n\tunsigned max;\n\tint ret;\n\n\ti = (sb->s_blocksize_bits + 2) * sizeof(*sbi->s_mb_offsets);\n\n\tsbi->s_mb_offsets = kmalloc(i, GFP_KERNEL);\n\tif (sbi->s_mb_offsets == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ti = (sb->s_blocksize_bits + 2) * sizeof(*sbi->s_mb_maxs);\n\tsbi->s_mb_maxs = kmalloc(i, GFP_KERNEL);\n\tif (sbi->s_mb_maxs == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ext4_groupinfo_create_slab(sb->s_blocksize);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* order 0 is regular bitmap */\n\tsbi->s_mb_maxs[0] = sb->s_blocksize << 3;\n\tsbi->s_mb_offsets[0] = 0;\n\n\ti = 1;\n\toffset = 0;\n\toffset_incr = 1 << (sb->s_blocksize_bits - 1);\n\tmax = sb->s_blocksize << 2;\n\tdo {\n\t\tsbi->s_mb_offsets[i] = offset;\n\t\tsbi->s_mb_maxs[i] = max;\n\t\toffset += offset_incr;\n\t\toffset_incr = offset_incr >> 1;\n\t\tmax = max >> 1;\n\t\ti++;\n\t} while (i <= sb->s_blocksize_bits + 1);\n\n\tspin_lock_init(&sbi->s_md_lock);\n\tspin_lock_init(&sbi->s_bal_lock);\n\tsbi->s_mb_free_pending = 0;\n\tINIT_LIST_HEAD(&sbi->s_freed_data_list);\n\n\tsbi->s_mb_max_to_scan = MB_DEFAULT_MAX_TO_SCAN;\n\tsbi->s_mb_min_to_scan = MB_DEFAULT_MIN_TO_SCAN;\n\tsbi->s_mb_stats = MB_DEFAULT_STATS;\n\tsbi->s_mb_stream_request = MB_DEFAULT_STREAM_THRESHOLD;\n\tsbi->s_mb_order2_reqs = MB_DEFAULT_ORDER2_REQS;\n\tsbi->s_mb_max_inode_prealloc = MB_DEFAULT_MAX_INODE_PREALLOC;\n\t/*\n\t * The default group preallocation is 512, which for 4k block\n\t * sizes translates to 2 megabytes.  However for bigalloc file\n\t * systems, this is probably too big (i.e, if the cluster size\n\t * is 1 megabyte, then group preallocation size becomes half a\n\t * gigabyte!).  As a default, we will keep a two megabyte\n\t * group pralloc size for cluster sizes up to 64k, and after\n\t * that, we will force a minimum group preallocation size of\n\t * 32 clusters.  This translates to 8 megs when the cluster\n\t * size is 256k, and 32 megs when the cluster size is 1 meg,\n\t * which seems reasonable as a default.\n\t */\n\tsbi->s_mb_group_prealloc = max(MB_DEFAULT_GROUP_PREALLOC >>\n\t\t\t\t       sbi->s_cluster_bits, 32);\n\t/*\n\t * If there is a s_stripe > 1, then we set the s_mb_group_prealloc\n\t * to the lowest multiple of s_stripe which is bigger than\n\t * the s_mb_group_prealloc as determined above. We want\n\t * the preallocation size to be an exact multiple of the\n\t * RAID stripe size so that preallocations don't fragment\n\t * the stripes.\n\t */\n\tif (sbi->s_stripe > 1) {\n\t\tsbi->s_mb_group_prealloc = roundup(\n\t\t\tsbi->s_mb_group_prealloc, sbi->s_stripe);\n\t}\n\n\tsbi->s_locality_groups = alloc_percpu(struct ext4_locality_group);\n\tif (sbi->s_locality_groups == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfor_each_possible_cpu(i) {\n\t\tstruct ext4_locality_group *lg;\n\t\tlg = per_cpu_ptr(sbi->s_locality_groups, i);\n\t\tmutex_init(&lg->lg_mutex);\n\t\tfor (j = 0; j < PREALLOC_TB_SIZE; j++)\n\t\t\tINIT_LIST_HEAD(&lg->lg_prealloc_list[j]);\n\t\tspin_lock_init(&lg->lg_prealloc_lock);\n\t}\n\n\t/* init file for buddy data */\n\tret = ext4_mb_init_backend(sb);\n\tif (ret != 0)\n\t\tgoto out_free_locality_groups;\n\n\treturn 0;\n\nout_free_locality_groups:\n\tfree_percpu(sbi->s_locality_groups);\n\tsbi->s_locality_groups = NULL;\nout:\n\tkfree(sbi->s_mb_offsets);\n\tsbi->s_mb_offsets = NULL;\n\tkfree(sbi->s_mb_maxs);\n\tsbi->s_mb_maxs = NULL;\n\treturn ret;\n}\n\n/* need to called with the ext4 group lock held */\nstatic int ext4_mb_cleanup_pa(struct ext4_group_info *grp)\n{\n\tstruct ext4_prealloc_space *pa;\n\tstruct list_head *cur, *tmp;\n\tint count = 0;\n\n\tlist_for_each_safe(cur, tmp, &grp->bb_prealloc_list) {\n\t\tpa = list_entry(cur, struct ext4_prealloc_space, pa_group_list);\n\t\tlist_del(&pa->pa_group_list);\n\t\tcount++;\n\t\tkmem_cache_free(ext4_pspace_cachep, pa);\n\t}\n\treturn count;\n}\n\nint ext4_mb_release(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\text4_group_t i;\n\tint num_meta_group_infos;\n\tstruct ext4_group_info *grinfo, ***group_info;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct kmem_cache *cachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\tint count;\n\n\tif (sbi->s_group_info) {\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tcond_resched();\n\t\t\tgrinfo = ext4_get_group_info(sb, i);\n\t\t\tmb_group_bb_bitmap_free(grinfo);\n\t\t\text4_lock_group(sb, i);\n\t\t\tcount = ext4_mb_cleanup_pa(grinfo);\n\t\t\tif (count)\n\t\t\t\tmb_debug(sb, \"mballoc: %d PAs left\\n\",\n\t\t\t\t\t count);\n\t\t\text4_unlock_group(sb, i);\n\t\t\tkmem_cache_free(cachep, grinfo);\n\t\t}\n\t\tnum_meta_group_infos = (ngroups +\n\t\t\t\tEXT4_DESC_PER_BLOCK(sb) - 1) >>\n\t\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\t\trcu_read_lock();\n\t\tgroup_info = rcu_dereference(sbi->s_group_info);\n\t\tfor (i = 0; i < num_meta_group_infos; i++)\n\t\t\tkfree(group_info[i]);\n\t\tkvfree(group_info);\n\t\trcu_read_unlock();\n\t}\n\tkfree(sbi->s_mb_offsets);\n\tkfree(sbi->s_mb_maxs);\n\tiput(sbi->s_buddy_cache);\n\tif (sbi->s_mb_stats) {\n\t\text4_msg(sb, KERN_INFO,\n\t\t       \"mballoc: %u blocks %u reqs (%u success)\",\n\t\t\t\tatomic_read(&sbi->s_bal_allocated),\n\t\t\t\tatomic_read(&sbi->s_bal_reqs),\n\t\t\t\tatomic_read(&sbi->s_bal_success));\n\t\text4_msg(sb, KERN_INFO,\n\t\t      \"mballoc: %u extents scanned, %u goal hits, \"\n\t\t\t\t\"%u 2^N hits, %u breaks, %u lost\",\n\t\t\t\tatomic_read(&sbi->s_bal_ex_scanned),\n\t\t\t\tatomic_read(&sbi->s_bal_goals),\n\t\t\t\tatomic_read(&sbi->s_bal_2orders),\n\t\t\t\tatomic_read(&sbi->s_bal_breaks),\n\t\t\t\tatomic_read(&sbi->s_mb_lost_chunks));\n\t\text4_msg(sb, KERN_INFO,\n\t\t       \"mballoc: %lu generated and it took %Lu\",\n\t\t\t\tsbi->s_mb_buddies_generated,\n\t\t\t\tsbi->s_mb_generation_time);\n\t\text4_msg(sb, KERN_INFO,\n\t\t       \"mballoc: %u preallocated, %u discarded\",\n\t\t\t\tatomic_read(&sbi->s_mb_preallocated),\n\t\t\t\tatomic_read(&sbi->s_mb_discarded));\n\t}\n\n\tfree_percpu(sbi->s_locality_groups);\n\n\treturn 0;\n}\n\nstatic inline int ext4_issue_discard(struct super_block *sb,\n\t\text4_group_t block_group, ext4_grpblk_t cluster, int count,\n\t\tstruct bio **biop)\n{\n\text4_fsblk_t discard_block;\n\n\tdiscard_block = (EXT4_C2B(EXT4_SB(sb), cluster) +\n\t\t\t ext4_group_first_block_no(sb, block_group));\n\tcount = EXT4_C2B(EXT4_SB(sb), count);\n\ttrace_ext4_discard_blocks(sb,\n\t\t\t(unsigned long long) discard_block, count);\n\tif (biop) {\n\t\treturn __blkdev_issue_discard(sb->s_bdev,\n\t\t\t(sector_t)discard_block << (sb->s_blocksize_bits - 9),\n\t\t\t(sector_t)count << (sb->s_blocksize_bits - 9),\n\t\t\tGFP_NOFS, 0, biop);\n\t} else\n\t\treturn sb_issue_discard(sb, discard_block, count, GFP_NOFS, 0);\n}\n\nstatic void ext4_free_data_in_buddy(struct super_block *sb,\n\t\t\t\t    struct ext4_free_data *entry)\n{\n\tstruct ext4_buddy e4b;\n\tstruct ext4_group_info *db;\n\tint err, count = 0, count2 = 0;\n\n\tmb_debug(sb, \"gonna free %u blocks in group %u (0x%p):\",\n\t\t entry->efd_count, entry->efd_group, entry);\n\n\terr = ext4_mb_load_buddy(sb, entry->efd_group, &e4b);\n\t/* we expect to find existing buddy because it's pinned */\n\tBUG_ON(err != 0);\n\n\tspin_lock(&EXT4_SB(sb)->s_md_lock);\n\tEXT4_SB(sb)->s_mb_free_pending -= entry->efd_count;\n\tspin_unlock(&EXT4_SB(sb)->s_md_lock);\n\n\tdb = e4b.bd_info;\n\t/* there are blocks to put in buddy to make them really free */\n\tcount += entry->efd_count;\n\tcount2++;\n\text4_lock_group(sb, entry->efd_group);\n\t/* Take it out of per group rb tree */\n\trb_erase(&entry->efd_node, &(db->bb_free_root));\n\tmb_free_blocks(NULL, &e4b, entry->efd_start_cluster, entry->efd_count);\n\n\t/*\n\t * Clear the trimmed flag for the group so that the next\n\t * ext4_trim_fs can trim it.\n\t * If the volume is mounted with -o discard, online discard\n\t * is supported and the free blocks will be trimmed online.\n\t */\n\tif (!test_opt(sb, DISCARD))\n\t\tEXT4_MB_GRP_CLEAR_TRIMMED(db);\n\n\tif (!db->bb_free_root.rb_node) {\n\t\t/* No more items in the per group rb tree\n\t\t * balance refcounts from ext4_mb_free_metadata()\n\t\t */\n\t\tput_page(e4b.bd_buddy_page);\n\t\tput_page(e4b.bd_bitmap_page);\n\t}\n\text4_unlock_group(sb, entry->efd_group);\n\tkmem_cache_free(ext4_free_data_cachep, entry);\n\text4_mb_unload_buddy(&e4b);\n\n\tmb_debug(sb, \"freed %d blocks in %d structures\\n\", count,\n\t\t count2);\n}\n\n/*\n * This function is called by the jbd2 layer once the commit has finished,\n * so we know we can free the blocks that were released with that commit.\n */\nvoid ext4_process_freed_data(struct super_block *sb, tid_t commit_tid)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_free_data *entry, *tmp;\n\tstruct bio *discard_bio = NULL;\n\tstruct list_head freed_data_list;\n\tstruct list_head *cut_pos = NULL;\n\tint err;\n\n\tINIT_LIST_HEAD(&freed_data_list);\n\n\tspin_lock(&sbi->s_md_lock);\n\tlist_for_each_entry(entry, &sbi->s_freed_data_list, efd_list) {\n\t\tif (entry->efd_tid != commit_tid)\n\t\t\tbreak;\n\t\tcut_pos = &entry->efd_list;\n\t}\n\tif (cut_pos)\n\t\tlist_cut_position(&freed_data_list, &sbi->s_freed_data_list,\n\t\t\t\t  cut_pos);\n\tspin_unlock(&sbi->s_md_lock);\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tlist_for_each_entry(entry, &freed_data_list, efd_list) {\n\t\t\terr = ext4_issue_discard(sb, entry->efd_group,\n\t\t\t\t\t\t entry->efd_start_cluster,\n\t\t\t\t\t\t entry->efd_count,\n\t\t\t\t\t\t &discard_bio);\n\t\t\tif (err && err != -EOPNOTSUPP) {\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%d failed\"\n\t\t\t\t\t \" with %d\", entry->efd_group,\n\t\t\t\t\t entry->efd_start_cluster,\n\t\t\t\t\t entry->efd_count, err);\n\t\t\t} else if (err == -EOPNOTSUPP)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (discard_bio) {\n\t\t\tsubmit_bio_wait(discard_bio);\n\t\t\tbio_put(discard_bio);\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(entry, tmp, &freed_data_list, efd_list)\n\t\text4_free_data_in_buddy(sb, entry);\n}\n\nint __init ext4_init_mballoc(void)\n{\n\text4_pspace_cachep = KMEM_CACHE(ext4_prealloc_space,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT);\n\tif (ext4_pspace_cachep == NULL)\n\t\tgoto out;\n\n\text4_ac_cachep = KMEM_CACHE(ext4_allocation_context,\n\t\t\t\t    SLAB_RECLAIM_ACCOUNT);\n\tif (ext4_ac_cachep == NULL)\n\t\tgoto out_pa_free;\n\n\text4_free_data_cachep = KMEM_CACHE(ext4_free_data,\n\t\t\t\t\t   SLAB_RECLAIM_ACCOUNT);\n\tif (ext4_free_data_cachep == NULL)\n\t\tgoto out_ac_free;\n\n\treturn 0;\n\nout_ac_free:\n\tkmem_cache_destroy(ext4_ac_cachep);\nout_pa_free:\n\tkmem_cache_destroy(ext4_pspace_cachep);\nout:\n\treturn -ENOMEM;\n}\n\nvoid ext4_exit_mballoc(void)\n{\n\t/*\n\t * Wait for completion of call_rcu()'s on ext4_pspace_cachep\n\t * before destroying the slab cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext4_pspace_cachep);\n\tkmem_cache_destroy(ext4_ac_cachep);\n\tkmem_cache_destroy(ext4_free_data_cachep);\n\text4_groupinfo_destroy_slabs();\n}\n\n\n/*\n * Check quota and mark chosen space (ac->ac_b_ex) non-free in bitmaps\n * Returns 0 if success or error code\n */\nstatic noinline_for_stack int\next4_mb_mark_diskspace_used(struct ext4_allocation_context *ac,\n\t\t\t\thandle_t *handle, unsigned int reserv_clstrs)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_group_desc *gdp;\n\tstruct buffer_head *gdp_bh;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\text4_fsblk_t block;\n\tint err, len;\n\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(ac->ac_b_ex.fe_len <= 0);\n\n\tsb = ac->ac_sb;\n\tsbi = EXT4_SB(sb);\n\n\tbitmap_bh = ext4_read_block_bitmap(sb, ac->ac_b_ex.fe_group);\n\tif (IS_ERR(bitmap_bh)) {\n\t\terr = PTR_ERR(bitmap_bh);\n\t\tbitmap_bh = NULL;\n\t\tgoto out_err;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto out_err;\n\n\terr = -EIO;\n\tgdp = ext4_get_group_desc(sb, ac->ac_b_ex.fe_group, &gdp_bh);\n\tif (!gdp)\n\t\tgoto out_err;\n\n\text4_debug(\"using block group %u(%d)\\n\", ac->ac_b_ex.fe_group,\n\t\t\text4_free_group_clusters(sb, gdp));\n\n\tBUFFER_TRACE(gdp_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gdp_bh);\n\tif (err)\n\t\tgoto out_err;\n\n\tblock = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\n\tlen = EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\tif (!ext4_inode_block_valid(ac->ac_inode, block, len)) {\n\t\text4_error(sb, \"Allocating blocks %llu-%llu which overlap \"\n\t\t\t   \"fs metadata\", block, block+len);\n\t\t/* File system mounted not to panic on error\n\t\t * Fix the bitmap and return EFSCORRUPTED\n\t\t * We leak some of the blocks here.\n\t\t */\n\t\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n\t\text4_set_bits(bitmap_bh->b_data, ac->ac_b_ex.fe_start,\n\t\t\t      ac->ac_b_ex.fe_len);\n\t\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\t\tif (!err)\n\t\t\terr = -EFSCORRUPTED;\n\t\tgoto out_err;\n\t}\n\n\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < ac->ac_b_ex.fe_len; i++) {\n\t\t\tBUG_ON(mb_test_bit(ac->ac_b_ex.fe_start + i,\n\t\t\t\t\t\tbitmap_bh->b_data));\n\t\t}\n\t}\n#endif\n\text4_set_bits(bitmap_bh->b_data, ac->ac_b_ex.fe_start,\n\t\t      ac->ac_b_ex.fe_len);\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {\n\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);\n\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\t\t\t     ext4_free_clusters_after_init(sb,\n\t\t\t\t\t\tac->ac_b_ex.fe_group, gdp));\n\t}\n\tlen = ext4_free_group_clusters(sb, gdp) - ac->ac_b_ex.fe_len;\n\text4_free_group_clusters_set(sb, gdp, len);\n\text4_block_bitmap_csum_set(sb, ac->ac_b_ex.fe_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, ac->ac_b_ex.fe_group, gdp);\n\n\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\tpercpu_counter_sub(&sbi->s_freeclusters_counter, ac->ac_b_ex.fe_len);\n\t/*\n\t * Now reduce the dirty block count also. Should not go negative\n\t */\n\tif (!(ac->ac_flags & EXT4_MB_DELALLOC_RESERVED))\n\t\t/* release all the reserved blocks if non delalloc */\n\t\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter,\n\t\t\t\t   reserv_clstrs);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi,\n\t\t\t\t\t\t\t  ac->ac_b_ex.fe_group);\n\t\tatomic64_sub(ac->ac_b_ex.fe_len,\n\t\t\t     &sbi_array_rcu_deref(sbi, s_flex_groups,\n\t\t\t\t\t\t  flex_group)->free_clusters);\n\t}\n\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\tif (err)\n\t\tgoto out_err;\n\terr = ext4_handle_dirty_metadata(handle, NULL, gdp_bh);\n\nout_err:\n\tbrelse(bitmap_bh);\n\treturn err;\n}\n\n/*\n * Idempotent helper for Ext4 fast commit replay path to set the state of\n * blocks in bitmaps and update counters.\n */\nvoid ext4_mb_mark_bb(struct super_block *sb, ext4_fsblk_t block,\n\t\t\tint len, int state)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_group_desc *gdp;\n\tstruct buffer_head *gdp_bh;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t group;\n\text4_grpblk_t blkoff;\n\tint i, clen, err;\n\tint already;\n\n\tclen = EXT4_B2C(sbi, len);\n\n\text4_get_group_no_and_offset(sb, block, &group, &blkoff);\n\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\tif (IS_ERR(bitmap_bh)) {\n\t\terr = PTR_ERR(bitmap_bh);\n\t\tbitmap_bh = NULL;\n\t\tgoto out_err;\n\t}\n\n\terr = -EIO;\n\tgdp = ext4_get_group_desc(sb, group, &gdp_bh);\n\tif (!gdp)\n\t\tgoto out_err;\n\n\text4_lock_group(sb, group);\n\talready = 0;\n\tfor (i = 0; i < clen; i++)\n\t\tif (!mb_test_bit(blkoff + i, bitmap_bh->b_data) == !state)\n\t\t\talready++;\n\n\tif (state)\n\t\text4_set_bits(bitmap_bh->b_data, blkoff, clen);\n\telse\n\t\tmb_test_and_clear_bits(bitmap_bh->b_data, blkoff, clen);\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {\n\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);\n\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\t\t\t     ext4_free_clusters_after_init(sb,\n\t\t\t\t\t\tgroup, gdp));\n\t}\n\tif (state)\n\t\tclen = ext4_free_group_clusters(sb, gdp) - clen + already;\n\telse\n\t\tclen = ext4_free_group_clusters(sb, gdp) + clen - already;\n\n\text4_free_group_clusters_set(sb, gdp, clen);\n\text4_block_bitmap_csum_set(sb, group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, group, gdp);\n\n\text4_unlock_group(sb, group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, group);\n\n\t\tatomic64_sub(len,\n\t\t\t     &sbi_array_rcu_deref(sbi, s_flex_groups,\n\t\t\t\t\t\t  flex_group)->free_clusters);\n\t}\n\n\terr = ext4_handle_dirty_metadata(NULL, NULL, bitmap_bh);\n\tif (err)\n\t\tgoto out_err;\n\tsync_dirty_buffer(bitmap_bh);\n\terr = ext4_handle_dirty_metadata(NULL, NULL, gdp_bh);\n\tsync_dirty_buffer(gdp_bh);\n\nout_err:\n\tbrelse(bitmap_bh);\n}\n\n/*\n * here we normalize request for locality group\n * Group request are normalized to s_mb_group_prealloc, which goes to\n * s_strip if we set the same via mount option.\n * s_mb_group_prealloc can be configured via\n * /sys/fs/ext4/<partition>/mb_group_prealloc\n *\n * XXX: should we try to preallocate more than the group has now?\n */\nstatic void ext4_mb_normalize_group_request(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_locality_group *lg = ac->ac_lg;\n\n\tBUG_ON(lg == NULL);\n\tac->ac_g_ex.fe_len = EXT4_SB(sb)->s_mb_group_prealloc;\n\tmb_debug(sb, \"goal %u blocks for locality group\\n\", ac->ac_g_ex.fe_len);\n}\n\n/*\n * Normalization means making request better in terms of\n * size and alignment\n */\nstatic noinline_for_stack void\next4_mb_normalize_request(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_allocation_request *ar)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint bsbits, max;\n\text4_lblk_t end;\n\tloff_t size, start_off;\n\tloff_t orig_size __maybe_unused;\n\text4_lblk_t start;\n\tstruct ext4_inode_info *ei = EXT4_I(ac->ac_inode);\n\tstruct ext4_prealloc_space *pa;\n\n\t/* do normalize only data requests, metadata requests\n\t   do not need preallocation */\n\tif (!(ac->ac_flags & EXT4_MB_HINT_DATA))\n\t\treturn;\n\n\t/* sometime caller may want exact blocks */\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY))\n\t\treturn;\n\n\t/* caller may indicate that preallocation isn't\n\t * required (it's a tail, for example) */\n\tif (ac->ac_flags & EXT4_MB_HINT_NOPREALLOC)\n\t\treturn;\n\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC) {\n\t\text4_mb_normalize_group_request(ac);\n\t\treturn ;\n\t}\n\n\tbsbits = ac->ac_sb->s_blocksize_bits;\n\n\t/* first, let's learn actual file size\n\t * given current request is allocated */\n\tsize = ac->ac_o_ex.fe_logical + EXT4_C2B(sbi, ac->ac_o_ex.fe_len);\n\tsize = size << bsbits;\n\tif (size < i_size_read(ac->ac_inode))\n\t\tsize = i_size_read(ac->ac_inode);\n\torig_size = size;\n\n\t/* max size of free chunks */\n\tmax = 2 << bsbits;\n\n#define NRL_CHECK_SIZE(req, size, max, chunk_size)\t\\\n\t\t(req <= (size) || max <= (chunk_size))\n\n\t/* first, try to predict filesize */\n\t/* XXX: should this table be tunable? */\n\tstart_off = 0;\n\tif (size <= 16 * 1024) {\n\t\tsize = 16 * 1024;\n\t} else if (size <= 32 * 1024) {\n\t\tsize = 32 * 1024;\n\t} else if (size <= 64 * 1024) {\n\t\tsize = 64 * 1024;\n\t} else if (size <= 128 * 1024) {\n\t\tsize = 128 * 1024;\n\t} else if (size <= 256 * 1024) {\n\t\tsize = 256 * 1024;\n\t} else if (size <= 512 * 1024) {\n\t\tsize = 512 * 1024;\n\t} else if (size <= 1024 * 1024) {\n\t\tsize = 1024 * 1024;\n\t} else if (NRL_CHECK_SIZE(size, 4 * 1024 * 1024, max, 2 * 1024)) {\n\t\tstart_off = ((loff_t)ac->ac_o_ex.fe_logical >>\n\t\t\t\t\t\t(21 - bsbits)) << 21;\n\t\tsize = 2 * 1024 * 1024;\n\t} else if (NRL_CHECK_SIZE(size, 8 * 1024 * 1024, max, 4 * 1024)) {\n\t\tstart_off = ((loff_t)ac->ac_o_ex.fe_logical >>\n\t\t\t\t\t\t\t(22 - bsbits)) << 22;\n\t\tsize = 4 * 1024 * 1024;\n\t} else if (NRL_CHECK_SIZE(ac->ac_o_ex.fe_len,\n\t\t\t\t\t(8<<20)>>bsbits, max, 8 * 1024)) {\n\t\tstart_off = ((loff_t)ac->ac_o_ex.fe_logical >>\n\t\t\t\t\t\t\t(23 - bsbits)) << 23;\n\t\tsize = 8 * 1024 * 1024;\n\t} else {\n\t\tstart_off = (loff_t) ac->ac_o_ex.fe_logical << bsbits;\n\t\tsize\t  = (loff_t) EXT4_C2B(EXT4_SB(ac->ac_sb),\n\t\t\t\t\t      ac->ac_o_ex.fe_len) << bsbits;\n\t}\n\tsize = size >> bsbits;\n\tstart = start_off >> bsbits;\n\n\t/* don't cover already allocated blocks in selected range */\n\tif (ar->pleft && start <= ar->lleft) {\n\t\tsize -= ar->lleft + 1 - start;\n\t\tstart = ar->lleft + 1;\n\t}\n\tif (ar->pright && start + size - 1 >= ar->lright)\n\t\tsize -= start + size - ar->lright;\n\n\t/*\n\t * Trim allocation request for filesystems with artificially small\n\t * groups.\n\t */\n\tif (size > EXT4_BLOCKS_PER_GROUP(ac->ac_sb))\n\t\tsize = EXT4_BLOCKS_PER_GROUP(ac->ac_sb);\n\n\tend = start + size;\n\n\t/* check we don't cross already preallocated blocks */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pa, &ei->i_prealloc_list, pa_inode_list) {\n\t\text4_lblk_t pa_end;\n\n\t\tif (pa->pa_deleted)\n\t\t\tcontinue;\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (pa->pa_deleted) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpa_end = pa->pa_lstart + EXT4_C2B(EXT4_SB(ac->ac_sb),\n\t\t\t\t\t\t  pa->pa_len);\n\n\t\t/* PA must not overlap original request */\n\t\tBUG_ON(!(ac->ac_o_ex.fe_logical >= pa_end ||\n\t\t\tac->ac_o_ex.fe_logical < pa->pa_lstart));\n\n\t\t/* skip PAs this normalized request doesn't overlap with */\n\t\tif (pa->pa_lstart >= end || pa_end <= start) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tBUG_ON(pa->pa_lstart <= start && pa_end >= end);\n\n\t\t/* adjust start or end to be adjacent to this pa */\n\t\tif (pa_end <= ac->ac_o_ex.fe_logical) {\n\t\t\tBUG_ON(pa_end < start);\n\t\t\tstart = pa_end;\n\t\t} else if (pa->pa_lstart > ac->ac_o_ex.fe_logical) {\n\t\t\tBUG_ON(pa->pa_lstart > end);\n\t\t\tend = pa->pa_lstart;\n\t\t}\n\t\tspin_unlock(&pa->pa_lock);\n\t}\n\trcu_read_unlock();\n\tsize = end - start;\n\n\t/* XXX: extra loop to check we really don't overlap preallocations */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pa, &ei->i_prealloc_list, pa_inode_list) {\n\t\text4_lblk_t pa_end;\n\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa_end = pa->pa_lstart + EXT4_C2B(EXT4_SB(ac->ac_sb),\n\t\t\t\t\t\t\t  pa->pa_len);\n\t\t\tBUG_ON(!(start >= pa_end || end <= pa->pa_lstart));\n\t\t}\n\t\tspin_unlock(&pa->pa_lock);\n\t}\n\trcu_read_unlock();\n\n\tif (start + size <= ac->ac_o_ex.fe_logical &&\n\t\t\tstart > ac->ac_o_ex.fe_logical) {\n\t\text4_msg(ac->ac_sb, KERN_ERR,\n\t\t\t \"start %lu, size %lu, fe_logical %lu\",\n\t\t\t (unsigned long) start, (unsigned long) size,\n\t\t\t (unsigned long) ac->ac_o_ex.fe_logical);\n\t\tBUG();\n\t}\n\tBUG_ON(size <= 0 || size > EXT4_BLOCKS_PER_GROUP(ac->ac_sb));\n\n\t/* now prepare goal request */\n\n\t/* XXX: is it better to align blocks WRT to logical\n\t * placement or satisfy big request as is */\n\tac->ac_g_ex.fe_logical = start;\n\tac->ac_g_ex.fe_len = EXT4_NUM_B2C(sbi, size);\n\n\t/* define goal start in order to merge */\n\tif (ar->pright && (ar->lright == (start + size))) {\n\t\t/* merge to the right */\n\t\text4_get_group_no_and_offset(ac->ac_sb, ar->pright - size,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_group,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_start);\n\t\tac->ac_flags |= EXT4_MB_HINT_TRY_GOAL;\n\t}\n\tif (ar->pleft && (ar->lleft + 1 == start)) {\n\t\t/* merge to the left */\n\t\text4_get_group_no_and_offset(ac->ac_sb, ar->pleft + 1,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_group,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_start);\n\t\tac->ac_flags |= EXT4_MB_HINT_TRY_GOAL;\n\t}\n\n\tmb_debug(ac->ac_sb, \"goal: %lld(was %lld) blocks at %u\\n\", size,\n\t\t orig_size, start);\n}\n\nstatic void ext4_mb_collect_stats(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\n\tif (sbi->s_mb_stats && ac->ac_g_ex.fe_len > 1) {\n\t\tatomic_inc(&sbi->s_bal_reqs);\n\t\tatomic_add(ac->ac_b_ex.fe_len, &sbi->s_bal_allocated);\n\t\tif (ac->ac_b_ex.fe_len >= ac->ac_o_ex.fe_len)\n\t\t\tatomic_inc(&sbi->s_bal_success);\n\t\tatomic_add(ac->ac_found, &sbi->s_bal_ex_scanned);\n\t\tif (ac->ac_g_ex.fe_start == ac->ac_b_ex.fe_start &&\n\t\t\t\tac->ac_g_ex.fe_group == ac->ac_b_ex.fe_group)\n\t\t\tatomic_inc(&sbi->s_bal_goals);\n\t\tif (ac->ac_found > sbi->s_mb_max_to_scan)\n\t\t\tatomic_inc(&sbi->s_bal_breaks);\n\t}\n\n\tif (ac->ac_op == EXT4_MB_HISTORY_ALLOC)\n\t\ttrace_ext4_mballoc_alloc(ac);\n\telse\n\t\ttrace_ext4_mballoc_prealloc(ac);\n}\n\n/*\n * Called on failure; free up any blocks from the inode PA for this\n * context.  We don't need this for MB_GROUP_PA because we only change\n * pa_free in ext4_mb_release_context(), but on failure, we've already\n * zeroed out ac->ac_b_ex.fe_len, so group_pa->pa_free is not changed.\n */\nstatic void ext4_discard_allocated_blocks(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_prealloc_space *pa = ac->ac_pa;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (pa == NULL) {\n\t\tif (ac->ac_f_ex.fe_len == 0)\n\t\t\treturn;\n\t\terr = ext4_mb_load_buddy(ac->ac_sb, ac->ac_f_ex.fe_group, &e4b);\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * This should never happen since we pin the\n\t\t\t * pages in the ext4_allocation_context so\n\t\t\t * ext4_mb_load_buddy() should never fail.\n\t\t\t */\n\t\t\tWARN(1, \"mb_load_buddy failed (%d)\", err);\n\t\t\treturn;\n\t\t}\n\t\text4_lock_group(ac->ac_sb, ac->ac_f_ex.fe_group);\n\t\tmb_free_blocks(ac->ac_inode, &e4b, ac->ac_f_ex.fe_start,\n\t\t\t       ac->ac_f_ex.fe_len);\n\t\text4_unlock_group(ac->ac_sb, ac->ac_f_ex.fe_group);\n\t\text4_mb_unload_buddy(&e4b);\n\t\treturn;\n\t}\n\tif (pa->pa_type == MB_INODE_PA)\n\t\tpa->pa_free += ac->ac_b_ex.fe_len;\n}\n\n/*\n * use blocks preallocated to inode\n */\nstatic void ext4_mb_use_inode_pa(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\text4_fsblk_t start;\n\text4_fsblk_t end;\n\tint len;\n\n\t/* found preallocated blocks, use them */\n\tstart = pa->pa_pstart + (ac->ac_o_ex.fe_logical - pa->pa_lstart);\n\tend = min(pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len),\n\t\t  start + EXT4_C2B(sbi, ac->ac_o_ex.fe_len));\n\tlen = EXT4_NUM_B2C(sbi, end - start);\n\text4_get_group_no_and_offset(ac->ac_sb, start, &ac->ac_b_ex.fe_group,\n\t\t\t\t\t&ac->ac_b_ex.fe_start);\n\tac->ac_b_ex.fe_len = len;\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_pa = pa;\n\n\tBUG_ON(start < pa->pa_pstart);\n\tBUG_ON(end > pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len));\n\tBUG_ON(pa->pa_free < len);\n\tpa->pa_free -= len;\n\n\tmb_debug(ac->ac_sb, \"use %llu/%d from inode pa %p\\n\", start, len, pa);\n}\n\n/*\n * use blocks preallocated to locality group\n */\nstatic void ext4_mb_use_group_pa(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tunsigned int len = ac->ac_o_ex.fe_len;\n\n\text4_get_group_no_and_offset(ac->ac_sb, pa->pa_pstart,\n\t\t\t\t\t&ac->ac_b_ex.fe_group,\n\t\t\t\t\t&ac->ac_b_ex.fe_start);\n\tac->ac_b_ex.fe_len = len;\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_pa = pa;\n\n\t/* we don't correct pa_pstart or pa_plen here to avoid\n\t * possible race when the group is being loaded concurrently\n\t * instead we correct pa later, after blocks are marked\n\t * in on-disk bitmap -- see ext4_mb_release_context()\n\t * Other CPUs are prevented from allocating from this pa by lg_mutex\n\t */\n\tmb_debug(ac->ac_sb, \"use %u/%u from group pa %p\\n\",\n\t\t pa->pa_lstart-len, len, pa);\n}\n\n/*\n * Return the prealloc space that have minimal distance\n * from the goal block. @cpa is the prealloc\n * space that is having currently known minimal distance\n * from the goal block.\n */\nstatic struct ext4_prealloc_space *\next4_mb_check_group_pa(ext4_fsblk_t goal_block,\n\t\t\tstruct ext4_prealloc_space *pa,\n\t\t\tstruct ext4_prealloc_space *cpa)\n{\n\text4_fsblk_t cur_distance, new_distance;\n\n\tif (cpa == NULL) {\n\t\tatomic_inc(&pa->pa_count);\n\t\treturn pa;\n\t}\n\tcur_distance = abs(goal_block - cpa->pa_pstart);\n\tnew_distance = abs(goal_block - pa->pa_pstart);\n\n\tif (cur_distance <= new_distance)\n\t\treturn cpa;\n\n\t/* drop the previous reference */\n\tatomic_dec(&cpa->pa_count);\n\tatomic_inc(&pa->pa_count);\n\treturn pa;\n}\n\n/*\n * search goal blocks in preallocated space\n */\nstatic noinline_for_stack bool\next4_mb_use_preallocated(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint order, i;\n\tstruct ext4_inode_info *ei = EXT4_I(ac->ac_inode);\n\tstruct ext4_locality_group *lg;\n\tstruct ext4_prealloc_space *pa, *cpa = NULL;\n\text4_fsblk_t goal_block;\n\n\t/* only data can be preallocated */\n\tif (!(ac->ac_flags & EXT4_MB_HINT_DATA))\n\t\treturn false;\n\n\t/* first, try per-file preallocation */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pa, &ei->i_prealloc_list, pa_inode_list) {\n\n\t\t/* all fields in this condition don't change,\n\t\t * so we can skip locking for them */\n\t\tif (ac->ac_o_ex.fe_logical < pa->pa_lstart ||\n\t\t    ac->ac_o_ex.fe_logical >= (pa->pa_lstart +\n\t\t\t\t\t       EXT4_C2B(sbi, pa->pa_len)))\n\t\t\tcontinue;\n\n\t\t/* non-extent files can't have physical blocks past 2^32 */\n\t\tif (!(ext4_test_inode_flag(ac->ac_inode, EXT4_INODE_EXTENTS)) &&\n\t\t    (pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len) >\n\t\t     EXT4_MAX_BLOCK_FILE_PHYS))\n\t\t\tcontinue;\n\n\t\t/* found preallocated blocks, use them */\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (pa->pa_deleted == 0 && pa->pa_free) {\n\t\t\tatomic_inc(&pa->pa_count);\n\t\t\text4_mb_use_inode_pa(ac, pa);\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tac->ac_criteria = 10;\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t\tspin_unlock(&pa->pa_lock);\n\t}\n\trcu_read_unlock();\n\n\t/* can we use group allocation? */\n\tif (!(ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC))\n\t\treturn false;\n\n\t/* inode may have no locality group for some reason */\n\tlg = ac->ac_lg;\n\tif (lg == NULL)\n\t\treturn false;\n\torder  = fls(ac->ac_o_ex.fe_len) - 1;\n\tif (order > PREALLOC_TB_SIZE - 1)\n\t\t/* The max size of hash table is PREALLOC_TB_SIZE */\n\t\torder = PREALLOC_TB_SIZE - 1;\n\n\tgoal_block = ext4_grp_offs_to_block(ac->ac_sb, &ac->ac_g_ex);\n\t/*\n\t * search for the prealloc space that is having\n\t * minimal distance from the goal block.\n\t */\n\tfor (i = order; i < PREALLOC_TB_SIZE; i++) {\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(pa, &lg->lg_prealloc_list[i],\n\t\t\t\t\tpa_inode_list) {\n\t\t\tspin_lock(&pa->pa_lock);\n\t\t\tif (pa->pa_deleted == 0 &&\n\t\t\t\t\tpa->pa_free >= ac->ac_o_ex.fe_len) {\n\n\t\t\t\tcpa = ext4_mb_check_group_pa(goal_block,\n\t\t\t\t\t\t\t\tpa, cpa);\n\t\t\t}\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tif (cpa) {\n\t\text4_mb_use_group_pa(ac, cpa);\n\t\tac->ac_criteria = 20;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * the function goes through all block freed in the group\n * but not yet committed and marks them used in in-core bitmap.\n * buddy must be generated from this bitmap\n * Need to be called with the ext4 group lock held\n */\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group)\n{\n\tstruct rb_node *n;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_free_data *entry;\n\n\tgrp = ext4_get_group_info(sb, group);\n\tn = rb_first(&(grp->bb_free_root));\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_free_data, efd_node);\n\t\text4_set_bits(bitmap, entry->efd_start_cluster, entry->efd_count);\n\t\tn = rb_next(n);\n\t}\n\treturn;\n}\n\n/*\n * the function goes through all preallocation in this group and marks them\n * used in in-core bitmap. buddy must be generated from this bitmap\n * Need to be called with ext4 group lock held\n */\nstatic noinline_for_stack\nvoid ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct ext4_prealloc_space *pa;\n\tstruct list_head *cur;\n\text4_group_t groupnr;\n\text4_grpblk_t start;\n\tint preallocated = 0;\n\tint len;\n\n\t/* all form of preallocation discards first load group,\n\t * so the only competing code is preallocation use.\n\t * we don't need any locking here\n\t * notice we do NOT ignore preallocations with pa_deleted\n\t * otherwise we could leave used blocks available for\n\t * allocation in buddy when concurrent ext4_mb_put_pa()\n\t * is dropping preallocation\n\t */\n\tlist_for_each(cur, &grp->bb_prealloc_list) {\n\t\tpa = list_entry(cur, struct ext4_prealloc_space, pa_group_list);\n\t\tspin_lock(&pa->pa_lock);\n\t\text4_get_group_no_and_offset(sb, pa->pa_pstart,\n\t\t\t\t\t     &groupnr, &start);\n\t\tlen = pa->pa_len;\n\t\tspin_unlock(&pa->pa_lock);\n\t\tif (unlikely(len == 0))\n\t\t\tcontinue;\n\t\tBUG_ON(groupnr != group);\n\t\text4_set_bits(bitmap, start, len);\n\t\tpreallocated += len;\n\t}\n\tmb_debug(sb, \"preallocated %d for group %u\\n\", preallocated, group);\n}\n\nstatic void ext4_mb_mark_pa_deleted(struct super_block *sb,\n\t\t\t\t    struct ext4_prealloc_space *pa)\n{\n\tstruct ext4_inode_info *ei;\n\n\tif (pa->pa_deleted) {\n\t\text4_warning(sb, \"deleted pa, type:%d, pblk:%llu, lblk:%u, len:%d\\n\",\n\t\t\t     pa->pa_type, pa->pa_pstart, pa->pa_lstart,\n\t\t\t     pa->pa_len);\n\t\treturn;\n\t}\n\n\tpa->pa_deleted = 1;\n\n\tif (pa->pa_type == MB_INODE_PA) {\n\t\tei = EXT4_I(pa->pa_inode);\n\t\tatomic_dec(&ei->i_prealloc_active);\n\t}\n}\n\nstatic void ext4_mb_pa_callback(struct rcu_head *head)\n{\n\tstruct ext4_prealloc_space *pa;\n\tpa = container_of(head, struct ext4_prealloc_space, u.pa_rcu);\n\n\tBUG_ON(atomic_read(&pa->pa_count));\n\tBUG_ON(pa->pa_deleted == 0);\n\tkmem_cache_free(ext4_pspace_cachep, pa);\n}\n\n/*\n * drops a reference to preallocated space descriptor\n * if this was the last reference and the space is consumed\n */\nstatic void ext4_mb_put_pa(struct ext4_allocation_context *ac,\n\t\t\tstruct super_block *sb, struct ext4_prealloc_space *pa)\n{\n\text4_group_t grp;\n\text4_fsblk_t grp_blk;\n\n\t/* in this short window concurrent discard can set pa_deleted */\n\tspin_lock(&pa->pa_lock);\n\tif (!atomic_dec_and_test(&pa->pa_count) || pa->pa_free != 0) {\n\t\tspin_unlock(&pa->pa_lock);\n\t\treturn;\n\t}\n\n\tif (pa->pa_deleted == 1) {\n\t\tspin_unlock(&pa->pa_lock);\n\t\treturn;\n\t}\n\n\text4_mb_mark_pa_deleted(sb, pa);\n\tspin_unlock(&pa->pa_lock);\n\n\tgrp_blk = pa->pa_pstart;\n\t/*\n\t * If doing group-based preallocation, pa_pstart may be in the\n\t * next group when pa is used up\n\t */\n\tif (pa->pa_type == MB_GROUP_PA)\n\t\tgrp_blk--;\n\n\tgrp = ext4_get_group_number(sb, grp_blk);\n\n\t/*\n\t * possible race:\n\t *\n\t *  P1 (buddy init)\t\t\tP2 (regular allocation)\n\t *\t\t\t\t\tfind block B in PA\n\t *  copy on-disk bitmap to buddy\n\t *  \t\t\t\t\tmark B in on-disk bitmap\n\t *\t\t\t\t\tdrop PA from group\n\t *  mark all PAs in buddy\n\t *\n\t * thus, P1 initializes buddy with B available. to prevent this\n\t * we make \"copy\" and \"mark all PAs\" atomic and serialize \"drop PA\"\n\t * against that pair\n\t */\n\text4_lock_group(sb, grp);\n\tlist_del(&pa->pa_group_list);\n\text4_unlock_group(sb, grp);\n\n\tspin_lock(pa->pa_obj_lock);\n\tlist_del_rcu(&pa->pa_inode_list);\n\tspin_unlock(pa->pa_obj_lock);\n\n\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n}\n\n/*\n * creates new preallocated space for given inode\n */\nstatic noinline_for_stack void\next4_mb_new_inode_pa(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_prealloc_space *pa;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_inode_info *ei;\n\n\t/* preallocate only when found space is larger then requested */\n\tBUG_ON(ac->ac_o_ex.fe_len >= ac->ac_b_ex.fe_len);\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(!S_ISREG(ac->ac_inode->i_mode));\n\tBUG_ON(ac->ac_pa == NULL);\n\n\tpa = ac->ac_pa;\n\n\tif (ac->ac_b_ex.fe_len < ac->ac_g_ex.fe_len) {\n\t\tint winl;\n\t\tint wins;\n\t\tint win;\n\t\tint offs;\n\n\t\t/* we can't allocate as much as normalizer wants.\n\t\t * so, found space must get proper lstart\n\t\t * to cover original request */\n\t\tBUG_ON(ac->ac_g_ex.fe_logical > ac->ac_o_ex.fe_logical);\n\t\tBUG_ON(ac->ac_g_ex.fe_len < ac->ac_o_ex.fe_len);\n\n\t\t/* we're limited by original request in that\n\t\t * logical block must be covered any way\n\t\t * winl is window we can move our chunk within */\n\t\twinl = ac->ac_o_ex.fe_logical - ac->ac_g_ex.fe_logical;\n\n\t\t/* also, we should cover whole original request */\n\t\twins = EXT4_C2B(sbi, ac->ac_b_ex.fe_len - ac->ac_o_ex.fe_len);\n\n\t\t/* the smallest one defines real window */\n\t\twin = min(winl, wins);\n\n\t\toffs = ac->ac_o_ex.fe_logical %\n\t\t\tEXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\tif (offs && offs < win)\n\t\t\twin = offs;\n\n\t\tac->ac_b_ex.fe_logical = ac->ac_o_ex.fe_logical -\n\t\t\tEXT4_NUM_B2C(sbi, win);\n\t\tBUG_ON(ac->ac_o_ex.fe_logical < ac->ac_b_ex.fe_logical);\n\t\tBUG_ON(ac->ac_o_ex.fe_len > ac->ac_b_ex.fe_len);\n\t}\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tpa->pa_lstart = ac->ac_b_ex.fe_logical;\n\tpa->pa_pstart = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\tpa->pa_len = ac->ac_b_ex.fe_len;\n\tpa->pa_free = pa->pa_len;\n\tspin_lock_init(&pa->pa_lock);\n\tINIT_LIST_HEAD(&pa->pa_inode_list);\n\tINIT_LIST_HEAD(&pa->pa_group_list);\n\tpa->pa_deleted = 0;\n\tpa->pa_type = MB_INODE_PA;\n\n\tmb_debug(sb, \"new inode pa %p: %llu/%d for %u\\n\", pa, pa->pa_pstart,\n\t\t pa->pa_len, pa->pa_lstart);\n\ttrace_ext4_mb_new_inode_pa(ac, pa);\n\n\text4_mb_use_inode_pa(ac, pa);\n\tatomic_add(pa->pa_free, &sbi->s_mb_preallocated);\n\n\tei = EXT4_I(ac->ac_inode);\n\tgrp = ext4_get_group_info(sb, ac->ac_b_ex.fe_group);\n\n\tpa->pa_obj_lock = &ei->i_prealloc_lock;\n\tpa->pa_inode = ac->ac_inode;\n\n\tlist_add(&pa->pa_group_list, &grp->bb_prealloc_list);\n\n\tspin_lock(pa->pa_obj_lock);\n\tlist_add_rcu(&pa->pa_inode_list, &ei->i_prealloc_list);\n\tspin_unlock(pa->pa_obj_lock);\n\tatomic_inc(&ei->i_prealloc_active);\n}\n\n/*\n * creates new preallocated space for locality group inodes belongs to\n */\nstatic noinline_for_stack void\next4_mb_new_group_pa(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_locality_group *lg;\n\tstruct ext4_prealloc_space *pa;\n\tstruct ext4_group_info *grp;\n\n\t/* preallocate only when found space is larger then requested */\n\tBUG_ON(ac->ac_o_ex.fe_len >= ac->ac_b_ex.fe_len);\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(!S_ISREG(ac->ac_inode->i_mode));\n\tBUG_ON(ac->ac_pa == NULL);\n\n\tpa = ac->ac_pa;\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tpa->pa_pstart = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\tpa->pa_lstart = pa->pa_pstart;\n\tpa->pa_len = ac->ac_b_ex.fe_len;\n\tpa->pa_free = pa->pa_len;\n\tspin_lock_init(&pa->pa_lock);\n\tINIT_LIST_HEAD(&pa->pa_inode_list);\n\tINIT_LIST_HEAD(&pa->pa_group_list);\n\tpa->pa_deleted = 0;\n\tpa->pa_type = MB_GROUP_PA;\n\n\tmb_debug(sb, \"new group pa %p: %llu/%d for %u\\n\", pa, pa->pa_pstart,\n\t\t pa->pa_len, pa->pa_lstart);\n\ttrace_ext4_mb_new_group_pa(ac, pa);\n\n\text4_mb_use_group_pa(ac, pa);\n\tatomic_add(pa->pa_free, &EXT4_SB(sb)->s_mb_preallocated);\n\n\tgrp = ext4_get_group_info(sb, ac->ac_b_ex.fe_group);\n\tlg = ac->ac_lg;\n\tBUG_ON(lg == NULL);\n\n\tpa->pa_obj_lock = &lg->lg_prealloc_lock;\n\tpa->pa_inode = NULL;\n\n\tlist_add(&pa->pa_group_list, &grp->bb_prealloc_list);\n\n\t/*\n\t * We will later add the new pa to the right bucket\n\t * after updating the pa_free in ext4_mb_release_context\n\t */\n}\n\nstatic void ext4_mb_new_preallocation(struct ext4_allocation_context *ac)\n{\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC)\n\t\text4_mb_new_group_pa(ac);\n\telse\n\t\text4_mb_new_inode_pa(ac);\n}\n\n/*\n * finds all unused blocks in on-disk bitmap, frees them in\n * in-core bitmap and buddy.\n * @pa must be unlinked from inode and group lists, so that\n * nobody else can find/use it.\n * the caller MUST hold group/inode locks.\n * TODO: optimize the case when there are no in-core structures yet\n */\nstatic noinline_for_stack int\next4_mb_release_inode_pa(struct ext4_buddy *e4b, struct buffer_head *bitmap_bh,\n\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned int end;\n\tunsigned int next;\n\text4_group_t group;\n\text4_grpblk_t bit;\n\tunsigned long long grp_blk_start;\n\tint free = 0;\n\n\tBUG_ON(pa->pa_deleted == 0);\n\text4_get_group_no_and_offset(sb, pa->pa_pstart, &group, &bit);\n\tgrp_blk_start = pa->pa_pstart - EXT4_C2B(sbi, bit);\n\tBUG_ON(group != e4b->bd_group && pa->pa_len != 0);\n\tend = bit + pa->pa_len;\n\n\twhile (bit < end) {\n\t\tbit = mb_find_next_zero_bit(bitmap_bh->b_data, end, bit);\n\t\tif (bit >= end)\n\t\t\tbreak;\n\t\tnext = mb_find_next_bit(bitmap_bh->b_data, end, bit);\n\t\tmb_debug(sb, \"free preallocated %u/%u in group %u\\n\",\n\t\t\t (unsigned) ext4_group_first_block_no(sb, group) + bit,\n\t\t\t (unsigned) next - bit, (unsigned) group);\n\t\tfree += next - bit;\n\n\t\ttrace_ext4_mballoc_discard(sb, NULL, group, bit, next - bit);\n\t\ttrace_ext4_mb_release_inode_pa(pa, (grp_blk_start +\n\t\t\t\t\t\t    EXT4_C2B(sbi, bit)),\n\t\t\t\t\t       next - bit);\n\t\tmb_free_blocks(pa->pa_inode, e4b, bit, next - bit);\n\t\tbit = next + 1;\n\t}\n\tif (free != pa->pa_free) {\n\t\text4_msg(e4b->bd_sb, KERN_CRIT,\n\t\t\t \"pa %p: logic %lu, phys. %lu, len %d\",\n\t\t\t pa, (unsigned long) pa->pa_lstart,\n\t\t\t (unsigned long) pa->pa_pstart,\n\t\t\t pa->pa_len);\n\t\text4_grp_locked_error(sb, group, 0, 0, \"free %u, pa_free %u\",\n\t\t\t\t\tfree, pa->pa_free);\n\t\t/*\n\t\t * pa is already deleted so we use the value obtained\n\t\t * from the bitmap and continue.\n\t\t */\n\t}\n\tatomic_add(free, &sbi->s_mb_discarded);\n\n\treturn 0;\n}\n\nstatic noinline_for_stack int\next4_mb_release_group_pa(struct ext4_buddy *e4b,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\text4_group_t group;\n\text4_grpblk_t bit;\n\n\ttrace_ext4_mb_release_group_pa(sb, pa);\n\tBUG_ON(pa->pa_deleted == 0);\n\text4_get_group_no_and_offset(sb, pa->pa_pstart, &group, &bit);\n\tBUG_ON(group != e4b->bd_group && pa->pa_len != 0);\n\tmb_free_blocks(pa->pa_inode, e4b, bit, pa->pa_len);\n\tatomic_add(pa->pa_len, &EXT4_SB(sb)->s_mb_discarded);\n\ttrace_ext4_mballoc_discard(sb, NULL, group, bit, pa->pa_len);\n\n\treturn 0;\n}\n\n/*\n * releases all preallocations in given group\n *\n * first, we need to decide discard policy:\n * - when do we discard\n *   1) ENOSPC\n * - how many do we discard\n *   1) how many requested\n */\nstatic noinline_for_stack int\next4_mb_discard_group_preallocations(struct super_block *sb,\n\t\t\t\t\text4_group_t group, int needed)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\tint busy = 0;\n\tint free, free_total = 0;\n\n\tmb_debug(sb, \"discard preallocation for group %u\\n\", group);\n\tif (list_empty(&grp->bb_prealloc_list))\n\t\tgoto out_dbg;\n\n\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\tif (IS_ERR(bitmap_bh)) {\n\t\terr = PTR_ERR(bitmap_bh);\n\t\text4_error_err(sb, -err,\n\t\t\t       \"Error %d reading block bitmap for %u\",\n\t\t\t       err, group);\n\t\tgoto out_dbg;\n\t}\n\n\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\tif (err) {\n\t\text4_warning(sb, \"Error %d loading buddy information for %u\",\n\t\t\t     err, group);\n\t\tput_bh(bitmap_bh);\n\t\tgoto out_dbg;\n\t}\n\n\tif (needed == 0)\n\t\tneeded = EXT4_CLUSTERS_PER_GROUP(sb) + 1;\n\n\tINIT_LIST_HEAD(&list);\nrepeat:\n\tfree = 0;\n\text4_lock_group(sb, group);\n\tlist_for_each_entry_safe(pa, tmp,\n\t\t\t\t&grp->bb_prealloc_list, pa_group_list) {\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pa->pa_deleted) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* seems this one can be freed ... */\n\t\text4_mb_mark_pa_deleted(sb, pa);\n\n\t\tif (!free)\n\t\t\tthis_cpu_inc(discard_pa_seq);\n\n\t\t/* we can trust pa_free ... */\n\t\tfree += pa->pa_free;\n\n\t\tspin_unlock(&pa->pa_lock);\n\n\t\tlist_del(&pa->pa_group_list);\n\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t}\n\n\t/* now free all selected PAs */\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\n\t\t/* remove from object (inode or locality group) */\n\t\tspin_lock(pa->pa_obj_lock);\n\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\tspin_unlock(pa->pa_obj_lock);\n\n\t\tif (pa->pa_type == MB_GROUP_PA)\n\t\t\text4_mb_release_group_pa(&e4b, pa);\n\t\telse\n\t\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n\n\tfree_total += free;\n\n\t/* if we still need more blocks and some PAs were used, try again */\n\tif (free_total < needed && busy) {\n\t\text4_unlock_group(sb, group);\n\t\tcond_resched();\n\t\tbusy = 0;\n\t\tgoto repeat;\n\t}\n\text4_unlock_group(sb, group);\n\text4_mb_unload_buddy(&e4b);\n\tput_bh(bitmap_bh);\nout_dbg:\n\tmb_debug(sb, \"discarded (%d) blocks preallocated for group %u bb_free (%d)\\n\",\n\t\t free_total, group, grp->bb_free);\n\treturn free_total;\n}\n\n/*\n * releases all non-used preallocated blocks for given inode\n *\n * It's important to discard preallocations under i_data_sem\n * We don't want another block to be served from the prealloc\n * space when we are discarding the inode prealloc space.\n *\n * FIXME!! Make sure it is valid at all the call sites\n */\nvoid ext4_discard_preallocations(struct inode *inode, unsigned int needed)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\t/*BUG_ON(!list_empty(&ei->i_prealloc_list));*/\n\t\treturn;\n\t}\n\n\tif (EXT4_SB(sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn;\n\n\tmb_debug(sb, \"discard preallocation for inode %lu\\n\",\n\t\t inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode,\n\t\t\tatomic_read(&ei->i_prealloc_active), needed);\n\n\tINIT_LIST_HEAD(&list);\n\n\tif (needed == 0)\n\t\tneeded = UINT_MAX;\n\nrepeat:\n\t/* first, collect all pa's in the inode */\n\tspin_lock(&ei->i_prealloc_lock);\n\twhile (!list_empty(&ei->i_prealloc_list) && needed) {\n\t\tpa = list_entry(ei->i_prealloc_list.prev,\n\t\t\t\tstruct ext4_prealloc_space, pa_inode_list);\n\t\tBUG_ON(pa->pa_obj_lock != &ei->i_prealloc_lock);\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/* this shouldn't happen often - nobody should\n\t\t\t * use preallocation while we're discarding it */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tspin_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\text4_mb_mark_pa_deleted(sb, pa);\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tneeded--;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* someone is deleting pa right now */\n\t\tspin_unlock(&pa->pa_lock);\n\t\tspin_unlock(&ei->i_prealloc_lock);\n\n\t\t/* we have to wait here because pa_deleted\n\t\t * doesn't mean pa is already unlinked from\n\t\t * the list. as we might be called from\n\t\t * ->clear_inode() the inode will get freed\n\t\t * and concurrent thread which is unlinking\n\t\t * pa from inode's list may access already\n\t\t * freed memory, bad-bad-bad */\n\n\t\t/* XXX: if this happens too often, we can\n\t\t * add a flag to force wait only in case\n\t\t * of ->clear_inode(), but not in case of\n\t\t * regular truncate */\n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\tspin_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy_gfp(sb, group, &e4b,\n\t\t\t\t\t     GFP_NOFS|__GFP_NOFAIL);\n\t\tif (err) {\n\t\t\text4_error_err(sb, -err, \"Error %d loading buddy information for %u\",\n\t\t\t\t       err, group);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (IS_ERR(bitmap_bh)) {\n\t\t\terr = PTR_ERR(bitmap_bh);\n\t\t\text4_error_err(sb, -err, \"Error %d reading block bitmap for %u\",\n\t\t\t\t       err, group);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}\n\nstatic int ext4_mb_pa_alloc(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_prealloc_space *pa;\n\n\tBUG_ON(ext4_pspace_cachep == NULL);\n\tpa = kmem_cache_zalloc(ext4_pspace_cachep, GFP_NOFS);\n\tif (!pa)\n\t\treturn -ENOMEM;\n\tatomic_set(&pa->pa_count, 1);\n\tac->ac_pa = pa;\n\treturn 0;\n}\n\nstatic void ext4_mb_pa_free(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_prealloc_space *pa = ac->ac_pa;\n\n\tBUG_ON(!pa);\n\tac->ac_pa = NULL;\n\tWARN_ON(!atomic_dec_and_test(&pa->pa_count));\n\tkmem_cache_free(ext4_pspace_cachep, pa);\n}\n\n#ifdef CONFIG_EXT4_DEBUG\nstatic inline void ext4_mb_show_pa(struct super_block *sb)\n{\n\text4_group_t i, ngroups;\n\n\tif (EXT4_SB(sb)->s_mount_flags & EXT4_MF_FS_ABORTED)\n\t\treturn;\n\n\tngroups = ext4_get_groups_count(sb);\n\tmb_debug(sb, \"groups: \");\n\tfor (i = 0; i < ngroups; i++) {\n\t\tstruct ext4_group_info *grp = ext4_get_group_info(sb, i);\n\t\tstruct ext4_prealloc_space *pa;\n\t\text4_grpblk_t start;\n\t\tstruct list_head *cur;\n\t\text4_lock_group(sb, i);\n\t\tlist_for_each(cur, &grp->bb_prealloc_list) {\n\t\t\tpa = list_entry(cur, struct ext4_prealloc_space,\n\t\t\t\t\tpa_group_list);\n\t\t\tspin_lock(&pa->pa_lock);\n\t\t\text4_get_group_no_and_offset(sb, pa->pa_pstart,\n\t\t\t\t\t\t     NULL, &start);\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tmb_debug(sb, \"PA:%u:%d:%d\\n\", i, start,\n\t\t\t\t pa->pa_len);\n\t\t}\n\t\text4_unlock_group(sb, i);\n\t\tmb_debug(sb, \"%u: %d/%d\\n\", i, grp->bb_free,\n\t\t\t grp->bb_fragments);\n\t}\n}\n\nstatic void ext4_mb_show_ac(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\n\tif (EXT4_SB(sb)->s_mount_flags & EXT4_MF_FS_ABORTED)\n\t\treturn;\n\n\tmb_debug(sb, \"Can't allocate:\"\n\t\t\t\" Allocation context details:\");\n\tmb_debug(sb, \"status %u flags 0x%x\",\n\t\t\tac->ac_status, ac->ac_flags);\n\tmb_debug(sb, \"orig %lu/%lu/%lu@%lu, \"\n\t\t\t\"goal %lu/%lu/%lu@%lu, \"\n\t\t\t\"best %lu/%lu/%lu@%lu cr %d\",\n\t\t\t(unsigned long)ac->ac_o_ex.fe_group,\n\t\t\t(unsigned long)ac->ac_o_ex.fe_start,\n\t\t\t(unsigned long)ac->ac_o_ex.fe_len,\n\t\t\t(unsigned long)ac->ac_o_ex.fe_logical,\n\t\t\t(unsigned long)ac->ac_g_ex.fe_group,\n\t\t\t(unsigned long)ac->ac_g_ex.fe_start,\n\t\t\t(unsigned long)ac->ac_g_ex.fe_len,\n\t\t\t(unsigned long)ac->ac_g_ex.fe_logical,\n\t\t\t(unsigned long)ac->ac_b_ex.fe_group,\n\t\t\t(unsigned long)ac->ac_b_ex.fe_start,\n\t\t\t(unsigned long)ac->ac_b_ex.fe_len,\n\t\t\t(unsigned long)ac->ac_b_ex.fe_logical,\n\t\t\t(int)ac->ac_criteria);\n\tmb_debug(sb, \"%u found\", ac->ac_found);\n\text4_mb_show_pa(sb);\n}\n#else\nstatic inline void ext4_mb_show_pa(struct super_block *sb)\n{\n\treturn;\n}\nstatic inline void ext4_mb_show_ac(struct ext4_allocation_context *ac)\n{\n\text4_mb_show_pa(ac->ac_sb);\n\treturn;\n}\n#endif\n\n/*\n * We use locality group preallocation for small size file. The size of the\n * file is determined by the current size or the resulting size after\n * allocation which ever is larger\n *\n * One can tune this size via /sys/fs/ext4/<partition>/mb_stream_req\n */\nstatic void ext4_mb_group_or_file(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint bsbits = ac->ac_sb->s_blocksize_bits;\n\tloff_t size, isize;\n\n\tif (!(ac->ac_flags & EXT4_MB_HINT_DATA))\n\t\treturn;\n\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY))\n\t\treturn;\n\n\tsize = ac->ac_o_ex.fe_logical + EXT4_C2B(sbi, ac->ac_o_ex.fe_len);\n\tisize = (i_size_read(ac->ac_inode) + ac->ac_sb->s_blocksize - 1)\n\t\t>> bsbits;\n\n\tif ((size == isize) && !ext4_fs_is_busy(sbi) &&\n\t    !inode_is_open_for_write(ac->ac_inode)) {\n\t\tac->ac_flags |= EXT4_MB_HINT_NOPREALLOC;\n\t\treturn;\n\t}\n\n\tif (sbi->s_mb_group_prealloc <= 0) {\n\t\tac->ac_flags |= EXT4_MB_STREAM_ALLOC;\n\t\treturn;\n\t}\n\n\t/* don't use group allocation for large files */\n\tsize = max(size, isize);\n\tif (size > sbi->s_mb_stream_request) {\n\t\tac->ac_flags |= EXT4_MB_STREAM_ALLOC;\n\t\treturn;\n\t}\n\n\tBUG_ON(ac->ac_lg != NULL);\n\t/*\n\t * locality group prealloc space are per cpu. The reason for having\n\t * per cpu locality group is to reduce the contention between block\n\t * request from multiple CPUs.\n\t */\n\tac->ac_lg = raw_cpu_ptr(sbi->s_locality_groups);\n\n\t/* we're going to use group allocation */\n\tac->ac_flags |= EXT4_MB_HINT_GROUP_ALLOC;\n\n\t/* serialize all allocations in the group */\n\tmutex_lock(&ac->ac_lg->lg_mutex);\n}\n\nstatic noinline_for_stack int\next4_mb_initialize_context(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_allocation_request *ar)\n{\n\tstruct super_block *sb = ar->inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_group_t group;\n\tunsigned int len;\n\text4_fsblk_t goal;\n\text4_grpblk_t block;\n\n\t/* we can't allocate > group size */\n\tlen = ar->len;\n\n\t/* just a dirty hack to filter too big requests  */\n\tif (len >= EXT4_CLUSTERS_PER_GROUP(sb))\n\t\tlen = EXT4_CLUSTERS_PER_GROUP(sb);\n\n\t/* start searching from the goal */\n\tgoal = ar->goal;\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t\t\tgoal >= ext4_blocks_count(es))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\text4_get_group_no_and_offset(sb, goal, &group, &block);\n\n\t/* set up allocation goals */\n\tac->ac_b_ex.fe_logical = EXT4_LBLK_CMASK(sbi, ar->logical);\n\tac->ac_status = AC_STATUS_CONTINUE;\n\tac->ac_sb = sb;\n\tac->ac_inode = ar->inode;\n\tac->ac_o_ex.fe_logical = ac->ac_b_ex.fe_logical;\n\tac->ac_o_ex.fe_group = group;\n\tac->ac_o_ex.fe_start = block;\n\tac->ac_o_ex.fe_len = len;\n\tac->ac_g_ex = ac->ac_o_ex;\n\tac->ac_flags = ar->flags;\n\n\t/* we have to define context: we'll work with a file or\n\t * locality group. this is a policy, actually */\n\text4_mb_group_or_file(ac);\n\n\tmb_debug(sb, \"init ac: %u blocks @ %u, goal %u, flags 0x%x, 2^%d, \"\n\t\t\t\"left: %u/%u, right %u/%u to %swritable\\n\",\n\t\t\t(unsigned) ar->len, (unsigned) ar->logical,\n\t\t\t(unsigned) ar->goal, ac->ac_flags, ac->ac_2order,\n\t\t\t(unsigned) ar->lleft, (unsigned) ar->pleft,\n\t\t\t(unsigned) ar->lright, (unsigned) ar->pright,\n\t\t\tinode_is_open_for_write(ar->inode) ? \"\" : \"non-\");\n\treturn 0;\n\n}\n\nstatic noinline_for_stack void\next4_mb_discard_lg_preallocations(struct super_block *sb,\n\t\t\t\t\tstruct ext4_locality_group *lg,\n\t\t\t\t\tint order, int total_entries)\n{\n\text4_group_t group = 0;\n\tstruct ext4_buddy e4b;\n\tstruct list_head discard_list;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\n\tmb_debug(sb, \"discard locality group preallocation\\n\");\n\n\tINIT_LIST_HEAD(&discard_list);\n\n\tspin_lock(&lg->lg_prealloc_lock);\n\tlist_for_each_entry_rcu(pa, &lg->lg_prealloc_list[order],\n\t\t\t\tpa_inode_list,\n\t\t\t\tlockdep_is_held(&lg->lg_prealloc_lock)) {\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/*\n\t\t\t * This is the pa that we just used\n\t\t\t * for block allocation. So don't\n\t\t\t * free that\n\t\t\t */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pa->pa_deleted) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* only lg prealloc space */\n\t\tBUG_ON(pa->pa_type != MB_GROUP_PA);\n\n\t\t/* seems this one can be freed ... */\n\t\text4_mb_mark_pa_deleted(sb, pa);\n\t\tspin_unlock(&pa->pa_lock);\n\n\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\tlist_add(&pa->u.pa_tmp_list, &discard_list);\n\n\t\ttotal_entries--;\n\t\tif (total_entries <= 5) {\n\t\t\t/*\n\t\t\t * we want to keep only 5 entries\n\t\t\t * allowing it to grow to 8. This\n\t\t\t * mak sure we don't call discard\n\t\t\t * soon for this list.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&lg->lg_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &discard_list, u.pa_tmp_list) {\n\t\tint err;\n\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\t\terr = ext4_mb_load_buddy_gfp(sb, group, &e4b,\n\t\t\t\t\t     GFP_NOFS|__GFP_NOFAIL);\n\t\tif (err) {\n\t\t\text4_error_err(sb, -err, \"Error %d loading buddy information for %u\",\n\t\t\t\t       err, group);\n\t\t\tcontinue;\n\t\t}\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_group_pa(&e4b, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}\n\n/*\n * We have incremented pa_count. So it cannot be freed at this\n * point. Also we hold lg_mutex. So no parallel allocation is\n * possible from this lg. That means pa_free cannot be updated.\n *\n * A parallel ext4_mb_discard_group_preallocations is possible.\n * which can cause the lg_prealloc_list to be updated.\n */\n\nstatic void ext4_mb_add_n_trim(struct ext4_allocation_context *ac)\n{\n\tint order, added = 0, lg_prealloc_count = 1;\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_locality_group *lg = ac->ac_lg;\n\tstruct ext4_prealloc_space *tmp_pa, *pa = ac->ac_pa;\n\n\torder = fls(pa->pa_free) - 1;\n\tif (order > PREALLOC_TB_SIZE - 1)\n\t\t/* The max size of hash table is PREALLOC_TB_SIZE */\n\t\torder = PREALLOC_TB_SIZE - 1;\n\t/* Add the prealloc space to lg */\n\tspin_lock(&lg->lg_prealloc_lock);\n\tlist_for_each_entry_rcu(tmp_pa, &lg->lg_prealloc_list[order],\n\t\t\t\tpa_inode_list,\n\t\t\t\tlockdep_is_held(&lg->lg_prealloc_lock)) {\n\t\tspin_lock(&tmp_pa->pa_lock);\n\t\tif (tmp_pa->pa_deleted) {\n\t\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!added && pa->pa_free < tmp_pa->pa_free) {\n\t\t\t/* Add to the tail of the previous entry */\n\t\t\tlist_add_tail_rcu(&pa->pa_inode_list,\n\t\t\t\t\t\t&tmp_pa->pa_inode_list);\n\t\t\tadded = 1;\n\t\t\t/*\n\t\t\t * we want to count the total\n\t\t\t * number of entries in the list\n\t\t\t */\n\t\t}\n\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\tlg_prealloc_count++;\n\t}\n\tif (!added)\n\t\tlist_add_tail_rcu(&pa->pa_inode_list,\n\t\t\t\t\t&lg->lg_prealloc_list[order]);\n\tspin_unlock(&lg->lg_prealloc_lock);\n\n\t/* Now trim the list to be not more than 8 elements */\n\tif (lg_prealloc_count > 8) {\n\t\text4_mb_discard_lg_preallocations(sb, lg,\n\t\t\t\t\t\t  order, lg_prealloc_count);\n\t\treturn;\n\t}\n\treturn ;\n}\n\n/*\n * if per-inode prealloc list is too long, trim some PA\n */\nstatic void ext4_mb_trim_inode_pa(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tint count, delta;\n\n\tcount = atomic_read(&ei->i_prealloc_active);\n\tdelta = (sbi->s_mb_max_inode_prealloc >> 2) + 1;\n\tif (count > sbi->s_mb_max_inode_prealloc + delta) {\n\t\tcount -= sbi->s_mb_max_inode_prealloc;\n\t\text4_discard_preallocations(inode, count);\n\t}\n}\n\n/*\n * release all resource we used in allocation\n */\nstatic int ext4_mb_release_context(struct ext4_allocation_context *ac)\n{\n\tstruct inode *inode = ac->ac_inode;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_prealloc_space *pa = ac->ac_pa;\n\tif (pa) {\n\t\tif (pa->pa_type == MB_GROUP_PA) {\n\t\t\t/* see comment in ext4_mb_use_group_pa() */\n\t\t\tspin_lock(&pa->pa_lock);\n\t\t\tpa->pa_pstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_lstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_free -= ac->ac_b_ex.fe_len;\n\t\t\tpa->pa_len -= ac->ac_b_ex.fe_len;\n\t\t\tspin_unlock(&pa->pa_lock);\n\n\t\t\t/*\n\t\t\t * We want to add the pa to the right bucket.\n\t\t\t * Remove it from the list and while adding\n\t\t\t * make sure the list to which we are adding\n\t\t\t * doesn't grow big.\n\t\t\t */\n\t\t\tif (likely(pa->pa_free)) {\n\t\t\t\tspin_lock(pa->pa_obj_lock);\n\t\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\t\tspin_unlock(pa->pa_obj_lock);\n\t\t\t\text4_mb_add_n_trim(ac);\n\t\t\t}\n\t\t}\n\n\t\tif (pa->pa_type == MB_INODE_PA) {\n\t\t\t/*\n\t\t\t * treat per-inode prealloc list as a lru list, then try\n\t\t\t * to trim the least recently used PA.\n\t\t\t */\n\t\t\tspin_lock(pa->pa_obj_lock);\n\t\t\tlist_move(&pa->pa_inode_list, &ei->i_prealloc_list);\n\t\t\tspin_unlock(pa->pa_obj_lock);\n\t\t}\n\n\t\text4_mb_put_pa(ac, ac->ac_sb, pa);\n\t}\n\tif (ac->ac_bitmap_page)\n\t\tput_page(ac->ac_bitmap_page);\n\tif (ac->ac_buddy_page)\n\t\tput_page(ac->ac_buddy_page);\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC)\n\t\tmutex_unlock(&ac->ac_lg->lg_mutex);\n\text4_mb_collect_stats(ac);\n\text4_mb_trim_inode_pa(inode);\n\treturn 0;\n}\n\nstatic int ext4_mb_discard_preallocations(struct super_block *sb, int needed)\n{\n\text4_group_t i, ngroups = ext4_get_groups_count(sb);\n\tint ret;\n\tint freed = 0;\n\n\ttrace_ext4_mb_discard_preallocations(sb, needed);\n\tfor (i = 0; i < ngroups && needed > 0; i++) {\n\t\tret = ext4_mb_discard_group_preallocations(sb, i, needed);\n\t\tfreed += ret;\n\t\tneeded -= ret;\n\t}\n\n\treturn freed;\n}\n\nstatic bool ext4_mb_discard_preallocations_should_retry(struct super_block *sb,\n\t\t\tstruct ext4_allocation_context *ac, u64 *seq)\n{\n\tint freed;\n\tu64 seq_retry = 0;\n\tbool ret = false;\n\n\tfreed = ext4_mb_discard_preallocations(sb, ac->ac_o_ex.fe_len);\n\tif (freed) {\n\t\tret = true;\n\t\tgoto out_dbg;\n\t}\n\tseq_retry = ext4_get_discard_pa_seq_sum();\n\tif (!(ac->ac_flags & EXT4_MB_STRICT_CHECK) || seq_retry != *seq) {\n\t\tac->ac_flags |= EXT4_MB_STRICT_CHECK;\n\t\t*seq = seq_retry;\n\t\tret = true;\n\t}\n\nout_dbg:\n\tmb_debug(sb, \"freed %d, retry ? %s\\n\", freed, ret ? \"yes\" : \"no\");\n\treturn ret;\n}\n\nstatic ext4_fsblk_t ext4_mb_new_blocks_simple(handle_t *handle,\n\t\t\t\tstruct ext4_allocation_request *ar, int *errp);\n\n/*\n * Main entry point into mballoc to allocate blocks\n * it tries to use preallocation first, then falls back\n * to usual allocation\n */\next4_fsblk_t ext4_mb_new_blocks(handle_t *handle,\n\t\t\t\tstruct ext4_allocation_request *ar, int *errp)\n{\n\tstruct ext4_allocation_context *ac = NULL;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\text4_fsblk_t block = 0;\n\tunsigned int inquota = 0;\n\tunsigned int reserv_clstrs = 0;\n\tu64 seq;\n\n\tmight_sleep();\n\tsb = ar->inode->i_sb;\n\tsbi = EXT4_SB(sb);\n\n\ttrace_ext4_request_blocks(ar);\n\tif (sbi->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn ext4_mb_new_blocks_simple(handle, ar, errp);\n\n\t/* Allow to use superuser reservation for quota file */\n\tif (ext4_is_quota_file(ar->inode))\n\t\tar->flags |= EXT4_MB_USE_ROOT_BLOCKS;\n\n\tif ((ar->flags & EXT4_MB_DELALLOC_RESERVED) == 0) {\n\t\t/* Without delayed allocation we need to verify\n\t\t * there is enough free blocks to do block allocation\n\t\t * and verify allocation doesn't exceed the quota limits.\n\t\t */\n\t\twhile (ar->len &&\n\t\t\text4_claim_free_clusters(sbi, ar->len, ar->flags)) {\n\n\t\t\t/* let others to free the space */\n\t\t\tcond_resched();\n\t\t\tar->len = ar->len >> 1;\n\t\t}\n\t\tif (!ar->len) {\n\t\t\text4_mb_show_pa(sb);\n\t\t\t*errp = -ENOSPC;\n\t\t\treturn 0;\n\t\t}\n\t\treserv_clstrs = ar->len;\n\t\tif (ar->flags & EXT4_MB_USE_ROOT_BLOCKS) {\n\t\t\tdquot_alloc_block_nofail(ar->inode,\n\t\t\t\t\t\t EXT4_C2B(sbi, ar->len));\n\t\t} else {\n\t\t\twhile (ar->len &&\n\t\t\t\tdquot_alloc_block(ar->inode,\n\t\t\t\t\t\t  EXT4_C2B(sbi, ar->len))) {\n\n\t\t\t\tar->flags |= EXT4_MB_HINT_NOPREALLOC;\n\t\t\t\tar->len--;\n\t\t\t}\n\t\t}\n\t\tinquota = ar->len;\n\t\tif (ar->len == 0) {\n\t\t\t*errp = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tac = kmem_cache_zalloc(ext4_ac_cachep, GFP_NOFS);\n\tif (!ac) {\n\t\tar->len = 0;\n\t\t*errp = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t*errp = ext4_mb_initialize_context(ac, ar);\n\tif (*errp) {\n\t\tar->len = 0;\n\t\tgoto out;\n\t}\n\n\tac->ac_op = EXT4_MB_HISTORY_PREALLOC;\n\tseq = this_cpu_read(discard_pa_seq);\n\tif (!ext4_mb_use_preallocated(ac)) {\n\t\tac->ac_op = EXT4_MB_HISTORY_ALLOC;\n\t\text4_mb_normalize_request(ac, ar);\n\n\t\t*errp = ext4_mb_pa_alloc(ac);\n\t\tif (*errp)\n\t\t\tgoto errout;\nrepeat:\n\t\t/* allocate space in core */\n\t\t*errp = ext4_mb_regular_allocator(ac);\n\t\t/*\n\t\t * pa allocated above is added to grp->bb_prealloc_list only\n\t\t * when we were able to allocate some block i.e. when\n\t\t * ac->ac_status == AC_STATUS_FOUND.\n\t\t * And error from above mean ac->ac_status != AC_STATUS_FOUND\n\t\t * So we have to free this pa here itself.\n\t\t */\n\t\tif (*errp) {\n\t\t\text4_mb_pa_free(ac);\n\t\t\text4_discard_allocated_blocks(ac);\n\t\t\tgoto errout;\n\t\t}\n\t\tif (ac->ac_status == AC_STATUS_FOUND &&\n\t\t\tac->ac_o_ex.fe_len >= ac->ac_f_ex.fe_len)\n\t\t\text4_mb_pa_free(ac);\n\t}\n\tif (likely(ac->ac_status == AC_STATUS_FOUND)) {\n\t\t*errp = ext4_mb_mark_diskspace_used(ac, handle, reserv_clstrs);\n\t\tif (*errp) {\n\t\t\text4_discard_allocated_blocks(ac);\n\t\t\tgoto errout;\n\t\t} else {\n\t\t\tblock = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\t\t\tar->len = ac->ac_b_ex.fe_len;\n\t\t}\n\t} else {\n\t\tif (ext4_mb_discard_preallocations_should_retry(sb, ac, &seq))\n\t\t\tgoto repeat;\n\t\t/*\n\t\t * If block allocation fails then the pa allocated above\n\t\t * needs to be freed here itself.\n\t\t */\n\t\text4_mb_pa_free(ac);\n\t\t*errp = -ENOSPC;\n\t}\n\nerrout:\n\tif (*errp) {\n\t\tac->ac_b_ex.fe_len = 0;\n\t\tar->len = 0;\n\t\text4_mb_show_ac(ac);\n\t}\n\text4_mb_release_context(ac);\nout:\n\tif (ac)\n\t\tkmem_cache_free(ext4_ac_cachep, ac);\n\tif (inquota && ar->len < inquota)\n\t\tdquot_free_block(ar->inode, EXT4_C2B(sbi, inquota - ar->len));\n\tif (!ar->len) {\n\t\tif ((ar->flags & EXT4_MB_DELALLOC_RESERVED) == 0)\n\t\t\t/* release all the reserved blocks if non delalloc */\n\t\t\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter,\n\t\t\t\t\t\treserv_clstrs);\n\t}\n\n\ttrace_ext4_allocate_blocks(ar, (unsigned long long)block);\n\n\treturn block;\n}\n\n/*\n * We can merge two free data extents only if the physical blocks\n * are contiguous, AND the extents were freed by the same transaction,\n * AND the blocks are associated with the same group.\n */\nstatic void ext4_try_merge_freed_extent(struct ext4_sb_info *sbi,\n\t\t\t\t\tstruct ext4_free_data *entry,\n\t\t\t\t\tstruct ext4_free_data *new_entry,\n\t\t\t\t\tstruct rb_root *entry_rb_root)\n{\n\tif ((entry->efd_tid != new_entry->efd_tid) ||\n\t    (entry->efd_group != new_entry->efd_group))\n\t\treturn;\n\tif (entry->efd_start_cluster + entry->efd_count ==\n\t    new_entry->efd_start_cluster) {\n\t\tnew_entry->efd_start_cluster = entry->efd_start_cluster;\n\t\tnew_entry->efd_count += entry->efd_count;\n\t} else if (new_entry->efd_start_cluster + new_entry->efd_count ==\n\t\t   entry->efd_start_cluster) {\n\t\tnew_entry->efd_count += entry->efd_count;\n\t} else\n\t\treturn;\n\tspin_lock(&sbi->s_md_lock);\n\tlist_del(&entry->efd_list);\n\tspin_unlock(&sbi->s_md_lock);\n\trb_erase(&entry->efd_node, entry_rb_root);\n\tkmem_cache_free(ext4_free_data_cachep, entry);\n}\n\nstatic noinline_for_stack int\next4_mb_free_metadata(handle_t *handle, struct ext4_buddy *e4b,\n\t\t      struct ext4_free_data *new_entry)\n{\n\text4_group_t group = e4b->bd_group;\n\text4_grpblk_t cluster;\n\text4_grpblk_t clusters = new_entry->efd_count;\n\tstruct ext4_free_data *entry;\n\tstruct ext4_group_info *db = e4b->bd_info;\n\tstruct super_block *sb = e4b->bd_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct rb_node **n = &db->bb_free_root.rb_node, *node;\n\tstruct rb_node *parent = NULL, *new_node;\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\tnew_node = &new_entry->efd_node;\n\tcluster = new_entry->efd_start_cluster;\n\n\tif (!*n) {\n\t\t/* first free block exent. We need to\n\t\t   protect buddy cache from being freed,\n\t\t * otherwise we'll refresh it from\n\t\t * on-disk bitmap and lose not-yet-available\n\t\t * blocks */\n\t\tget_page(e4b->bd_buddy_page);\n\t\tget_page(e4b->bd_bitmap_page);\n\t}\n\twhile (*n) {\n\t\tparent = *n;\n\t\tentry = rb_entry(parent, struct ext4_free_data, efd_node);\n\t\tif (cluster < entry->efd_start_cluster)\n\t\t\tn = &(*n)->rb_left;\n\t\telse if (cluster >= (entry->efd_start_cluster + entry->efd_count))\n\t\t\tn = &(*n)->rb_right;\n\t\telse {\n\t\t\text4_grp_locked_error(sb, group, 0,\n\t\t\t\text4_group_first_block_no(sb, group) +\n\t\t\t\tEXT4_C2B(sbi, cluster),\n\t\t\t\t\"Block already on to-be-freed list\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\trb_link_node(new_node, parent, n);\n\trb_insert_color(new_node, &db->bb_free_root);\n\n\t/* Now try to see the extent can be merged to left and right */\n\tnode = rb_prev(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_free_data, efd_node);\n\t\text4_try_merge_freed_extent(sbi, entry, new_entry,\n\t\t\t\t\t    &(db->bb_free_root));\n\t}\n\n\tnode = rb_next(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_free_data, efd_node);\n\t\text4_try_merge_freed_extent(sbi, entry, new_entry,\n\t\t\t\t\t    &(db->bb_free_root));\n\t}\n\n\tspin_lock(&sbi->s_md_lock);\n\tlist_add_tail(&new_entry->efd_list, &sbi->s_freed_data_list);\n\tsbi->s_mb_free_pending += clusters;\n\tspin_unlock(&sbi->s_md_lock);\n\treturn 0;\n}\n\n/*\n * Simple allocator for Ext4 fast commit replay path. It searches for blocks\n * linearly starting at the goal block and also excludes the blocks which\n * are going to be in use after fast commit replay.\n */\nstatic ext4_fsblk_t ext4_mb_new_blocks_simple(handle_t *handle,\n\t\t\t\tstruct ext4_allocation_request *ar, int *errp)\n{\n\tstruct buffer_head *bitmap_bh;\n\tstruct super_block *sb = ar->inode->i_sb;\n\text4_group_t group;\n\text4_grpblk_t blkoff;\n\tint  i;\n\text4_fsblk_t goal, block;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tgoal = ar->goal;\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t\t\tgoal >= ext4_blocks_count(es))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\n\tar->len = 0;\n\text4_get_group_no_and_offset(sb, goal, &group, &blkoff);\n\tfor (; group < ext4_get_groups_count(sb); group++) {\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (IS_ERR(bitmap_bh)) {\n\t\t\t*errp = PTR_ERR(bitmap_bh);\n\t\t\tpr_warn(\"Failed to read block bitmap\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\text4_get_group_no_and_offset(sb,\n\t\t\tmax(ext4_group_first_block_no(sb, group), goal),\n\t\t\tNULL, &blkoff);\n\t\ti = mb_find_next_zero_bit(bitmap_bh->b_data, sb->s_blocksize,\n\t\t\t\t\t\tblkoff);\n\t\tbrelse(bitmap_bh);\n\t\tif (i >= sb->s_blocksize)\n\t\t\tcontinue;\n\t\tif (ext4_fc_replay_check_excluded(sb,\n\t\t\text4_group_first_block_no(sb, group) + i))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\tif (group >= ext4_get_groups_count(sb) && i >= sb->s_blocksize)\n\t\treturn 0;\n\n\tblock = ext4_group_first_block_no(sb, group) + i;\n\text4_mb_mark_bb(sb, block, 1, 1);\n\tar->len = 1;\n\n\treturn block;\n}\n\nstatic void ext4_free_blocks_simple(struct inode *inode, ext4_fsblk_t block,\n\t\t\t\t\tunsigned long count)\n{\n\tstruct buffer_head *bitmap_bh;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tstruct buffer_head *gdp_bh;\n\text4_group_t group;\n\text4_grpblk_t blkoff;\n\tint already_freed = 0, err, i;\n\n\text4_get_group_no_and_offset(sb, block, &group, &blkoff);\n\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\tif (IS_ERR(bitmap_bh)) {\n\t\terr = PTR_ERR(bitmap_bh);\n\t\tpr_warn(\"Failed to read block bitmap\\n\");\n\t\treturn;\n\t}\n\tgdp = ext4_get_group_desc(sb, group, &gdp_bh);\n\tif (!gdp)\n\t\treturn;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (!mb_test_bit(blkoff + i, bitmap_bh->b_data))\n\t\t\talready_freed++;\n\t}\n\tmb_clear_bits(bitmap_bh->b_data, blkoff, count);\n\terr = ext4_handle_dirty_metadata(NULL, NULL, bitmap_bh);\n\tif (err)\n\t\treturn;\n\text4_free_group_clusters_set(\n\t\tsb, gdp, ext4_free_group_clusters(sb, gdp) +\n\t\tcount - already_freed);\n\text4_block_bitmap_csum_set(sb, group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, group, gdp);\n\text4_handle_dirty_metadata(NULL, NULL, gdp_bh);\n\tsync_dirty_buffer(bitmap_bh);\n\tsync_dirty_buffer(gdp_bh);\n\tbrelse(bitmap_bh);\n}\n\n/**\n * ext4_free_blocks() -- Free given blocks and update quota\n * @handle:\t\thandle for this transaction\n * @inode:\t\tinode\n * @bh:\t\t\toptional buffer of the block to be freed\n * @block:\t\tstarting physical block to be freed\n * @count:\t\tnumber of blocks to be freed\n * @flags:\t\tflags used by ext4_free_blocks\n */\nvoid ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tsbi = EXT4_SB(sb);\n\n\tif (sbi->s_mount_state & EXT4_FC_REPLAY) {\n\t\text4_free_blocks_simple(inode, block, count);\n\t\treturn;\n\t}\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_inode_block_valid(inode, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (bh && (flags & EXT4_FREE_BLOCKS_FORGET)) {\n\t\tBUG_ON(count > 1);\n\n\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t    inode, bh, block);\n\t}\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\n\tif (!bh && (flags & EXT4_FREE_BLOCKS_FORGET)) {\n\t\tint i;\n\t\tint is_metadata = flags & EXT4_FREE_BLOCKS_METADATA;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (is_metadata)\n\t\t\t\tbh = sb_find_get_block(inode->i_sb, block + i);\n\t\t\text4_forget(handle, is_metadata, inode, bh, block + i);\n\t\t}\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (IS_ERR(bitmap_bh)) {\n\t\terr = PTR_ERR(bitmap_bh);\n\t\tbitmap_bh = NULL;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     sbi->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     sbi->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\t/* __GFP_NOFAIL: retry infinitely, ignore TIF_MEMDIE and memcg limit. */\n\terr = ext4_mb_load_buddy_gfp(sb, block_group, &e4b,\n\t\t\t\t     GFP_NOFS|__GFP_NOFAIL);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until after the\n\t * transaction is committed. We make an exception if the inode is to be\n\t * written in writeback mode since writeback mode has weak data\n\t * consistency guarantees.\n\t */\n\tif (ext4_handle_valid(handle) &&\n\t    ((flags & EXT4_FREE_BLOCKS_METADATA) ||\n\t     !ext4_should_writeback_data(inode))) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * We use __GFP_NOFAIL because ext4_free_blocks() is not allowed\n\t\t * to fail.\n\t\t */\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep,\n\t\t\t\tGFP_NOFS|__GFP_NOFAIL);\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count,\n\t\t\t\t\t\t NULL);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi_array_rcu_deref(sbi, s_flex_groups,\n\t\t\t\t\t\t  flex_group)->free_clusters);\n\t}\n\n\t/*\n\t * on a bigalloc file system, defer the s_freeclusters_counter\n\t * update to the caller (ext4_remove_space and friends) so they\n\t * can determine if a cluster freed here should be rereserved\n\t */\n\tif (!(flags & EXT4_FREE_BLOCKS_RERESERVE_CLUSTER)) {\n\t\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\t\tpercpu_counter_add(&sbi->s_freeclusters_counter,\n\t\t\t\t   count_clusters);\n\t}\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}\n\n/**\n * ext4_group_add_blocks() -- Add given blocks to an existing group\n * @handle:\t\t\thandle to this transaction\n * @sb:\t\t\t\tsuper block\n * @block:\t\t\tstart physical block to add to the block group\n * @count:\t\t\tnumber of blocks to free\n *\n * This marks the blocks as free in the bitmap and buddy.\n */\nint ext4_group_add_blocks(handle_t *handle, struct super_block *sb,\n\t\t\t ext4_fsblk_t block, unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\text4_grpblk_t bit;\n\tunsigned int i;\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_buddy e4b;\n\tint err = 0, ret, free_clusters_count;\n\text4_grpblk_t clusters_freed;\n\text4_fsblk_t first_cluster = EXT4_B2C(sbi, block);\n\text4_fsblk_t last_cluster = EXT4_B2C(sbi, block + count - 1);\n\tunsigned long cluster_count = last_cluster - first_cluster + 1;\n\n\text4_debug(\"Adding block(s) %llu-%llu\\n\", block, block + count - 1);\n\n\tif (count == 0)\n\t\treturn 0;\n\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + cluster_count > EXT4_CLUSTERS_PER_GROUP(sb)) {\n\t\text4_warning(sb, \"too many blocks added to group %u\",\n\t\t\t     block_group);\n\t\terr = -EINVAL;\n\t\tgoto error_return;\n\t}\n\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (IS_ERR(bitmap_bh)) {\n\t\terr = PTR_ERR(bitmap_bh);\n\t\tbitmap_bh = NULL;\n\t\tgoto error_return;\n\t}\n\n\tdesc = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!desc) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, desc), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, desc), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, desc), sbi->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, desc),\n\t\t     sbi->s_itb_per_group)) {\n\t\text4_error(sb, \"Adding blocks in system zones - \"\n\t\t\t   \"Block = %llu, count = %lu\",\n\t\t\t   block, count);\n\t\terr = -EINVAL;\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\tfor (i = 0, clusters_freed = 0; i < cluster_count; i++) {\n\t\tBUFFER_TRACE(bitmap_bh, \"clear bit\");\n\t\tif (!mb_test_bit(bit + i, bitmap_bh->b_data)) {\n\t\t\text4_error(sb, \"bit already cleared for block %llu\",\n\t\t\t\t   (ext4_fsblk_t)(block + i));\n\t\t\tBUFFER_TRACE(bitmap_bh, \"bit already cleared\");\n\t\t} else {\n\t\t\tclusters_freed++;\n\t\t}\n\t}\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * need to update group_info->bb_free and bitmap\n\t * with group lock held. generate_buddy look at\n\t * them with group lock_held\n\t */\n\text4_lock_group(sb, block_group);\n\tmb_clear_bits(bitmap_bh->b_data, bit, cluster_count);\n\tmb_free_blocks(NULL, &e4b, bit, cluster_count);\n\tfree_clusters_count = clusters_freed +\n\t\text4_free_group_clusters(sb, desc);\n\text4_free_group_clusters_set(sb, desc, free_clusters_count);\n\text4_block_bitmap_csum_set(sb, block_group, desc, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, desc);\n\text4_unlock_group(sb, block_group);\n\tpercpu_counter_add(&sbi->s_freeclusters_counter,\n\t\t\t   clusters_freed);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(clusters_freed,\n\t\t\t     &sbi_array_rcu_deref(sbi, s_flex_groups,\n\t\t\t\t\t\t  flex_group)->free_clusters);\n\t}\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn err;\n}\n\n/**\n * ext4_trim_extent -- function to TRIM one single free extent in the group\n * @sb:\t\tsuper block for the file system\n * @start:\tstarting block of the free extent in the alloc. group\n * @count:\tnumber of blocks to TRIM\n * @group:\talloc. group we are working with\n * @e4b:\text4 buddy for the group\n *\n * Trim \"count\" blocks starting at \"start\" in the \"group\". To assure that no\n * one will allocate those blocks, mark it as used in buddy bitmap. This must\n * be called with under the group lock.\n */\nstatic int ext4_trim_extent(struct super_block *sb, int start, int count,\n\t\t\t     ext4_group_t group, struct ext4_buddy *e4b)\n__releases(bitlock)\n__acquires(bitlock)\n{\n\tstruct ext4_free_extent ex;\n\tint ret = 0;\n\n\ttrace_ext4_trim_extent(sb, group, start, count);\n\n\tassert_spin_locked(ext4_group_lock_ptr(sb, group));\n\n\tex.fe_start = start;\n\tex.fe_group = group;\n\tex.fe_len = count;\n\n\t/*\n\t * Mark blocks used, so no one can reuse them while\n\t * being trimmed.\n\t */\n\tmb_mark_used(e4b, &ex);\n\text4_unlock_group(sb, group);\n\tret = ext4_issue_discard(sb, group, start, count, NULL);\n\text4_lock_group(sb, group);\n\tmb_free_blocks(NULL, e4b, start, ex.fe_len);\n\treturn ret;\n}\n\n/**\n * ext4_trim_all_free -- function to trim all free space in alloc. group\n * @sb:\t\t\tsuper block for file system\n * @group:\t\tgroup to be trimmed\n * @start:\t\tfirst group block to examine\n * @max:\t\tlast group block to examine\n * @minblocks:\t\tminimum extent block count\n *\n * ext4_trim_all_free walks through group's buddy bitmap searching for free\n * extents. When the free block is found, ext4_trim_extent is called to TRIM\n * the extent.\n *\n *\n * ext4_trim_all_free walks through group's block bitmap searching for free\n * extents. When the free extent is found, mark it as used in group buddy\n * bitmap. Then issue a TRIM command on this extent and free the extent in\n * the group buddy bitmap. This is done until whole group is scanned.\n */\nstatic ext4_grpblk_t\next4_trim_all_free(struct super_block *sb, ext4_group_t group,\n\t\t   ext4_grpblk_t start, ext4_grpblk_t max,\n\t\t   ext4_grpblk_t minblocks)\n{\n\tvoid *bitmap;\n\text4_grpblk_t next, count = 0, free_count = 0;\n\tstruct ext4_buddy e4b;\n\tint ret = 0;\n\n\ttrace_ext4_trim_all_free(sb, group, start, max);\n\n\tret = ext4_mb_load_buddy(sb, group, &e4b);\n\tif (ret) {\n\t\text4_warning(sb, \"Error %d loading buddy information for %u\",\n\t\t\t     ret, group);\n\t\treturn ret;\n\t}\n\tbitmap = e4b.bd_bitmap;\n\n\text4_lock_group(sb, group);\n\tif (EXT4_MB_GRP_WAS_TRIMMED(e4b.bd_info) &&\n\t    minblocks >= atomic_read(&EXT4_SB(sb)->s_last_trim_minblks))\n\t\tgoto out;\n\n\tstart = (e4b.bd_info->bb_first_free > start) ?\n\t\te4b.bd_info->bb_first_free : start;\n\n\twhile (start <= max) {\n\t\tstart = mb_find_next_zero_bit(bitmap, max + 1, start);\n\t\tif (start > max)\n\t\t\tbreak;\n\t\tnext = mb_find_next_bit(bitmap, max + 1, start);\n\n\t\tif ((next - start) >= minblocks) {\n\t\t\tret = ext4_trim_extent(sb, start,\n\t\t\t\t\t       next - start, group, &e4b);\n\t\t\tif (ret && ret != -EOPNOTSUPP)\n\t\t\t\tbreak;\n\t\t\tret = 0;\n\t\t\tcount += next - start;\n\t\t}\n\t\tfree_count += next - start;\n\t\tstart = next + 1;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tcount = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (need_resched()) {\n\t\t\text4_unlock_group(sb, group);\n\t\t\tcond_resched();\n\t\t\text4_lock_group(sb, group);\n\t\t}\n\n\t\tif ((e4b.bd_info->bb_free - free_count) < minblocks)\n\t\t\tbreak;\n\t}\n\n\tif (!ret) {\n\t\tret = count;\n\t\tEXT4_MB_GRP_SET_TRIMMED(e4b.bd_info);\n\t}\nout:\n\text4_unlock_group(sb, group);\n\text4_mb_unload_buddy(&e4b);\n\n\text4_debug(\"trimmed %d blocks in the group %d\\n\",\n\t\tcount, group);\n\n\treturn ret;\n}\n\n/**\n * ext4_trim_fs() -- trim ioctl handle function\n * @sb:\t\t\tsuperblock for filesystem\n * @range:\t\tfstrim_range structure\n *\n * start:\tFirst Byte to trim\n * len:\t\tnumber of Bytes to trim from start\n * minlen:\tminimum extent length in Bytes\n * ext4_trim_fs goes through all allocation groups containing Bytes from\n * start to start+len. For each such a group ext4_trim_all_free function\n * is invoked to trim all free space.\n */\nint ext4_trim_fs(struct super_block *sb, struct fstrim_range *range)\n{\n\tstruct ext4_group_info *grp;\n\text4_group_t group, first_group, last_group;\n\text4_grpblk_t cnt = 0, first_cluster, last_cluster;\n\tuint64_t start, end, minlen, trimmed = 0;\n\text4_fsblk_t first_data_blk =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n\text4_fsblk_t max_blks = ext4_blocks_count(EXT4_SB(sb)->s_es);\n\tint ret = 0;\n\n\tstart = range->start >> sb->s_blocksize_bits;\n\tend = start + (range->len >> sb->s_blocksize_bits) - 1;\n\tminlen = EXT4_NUM_B2C(EXT4_SB(sb),\n\t\t\t      range->minlen >> sb->s_blocksize_bits);\n\n\tif (minlen > EXT4_CLUSTERS_PER_GROUP(sb) ||\n\t    start >= max_blks ||\n\t    range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\tif (end >= max_blks)\n\t\tend = max_blks - 1;\n\tif (end <= first_data_blk)\n\t\tgoto out;\n\tif (start < first_data_blk)\n\t\tstart = first_data_blk;\n\n\t/* Determine first and last group to examine based on start and end */\n\text4_get_group_no_and_offset(sb, (ext4_fsblk_t) start,\n\t\t\t\t     &first_group, &first_cluster);\n\text4_get_group_no_and_offset(sb, (ext4_fsblk_t) end,\n\t\t\t\t     &last_group, &last_cluster);\n\n\t/* end now represents the last cluster to discard in this group */\n\tend = EXT4_CLUSTERS_PER_GROUP(sb) - 1;\n\n\tfor (group = first_group; group <= last_group; group++) {\n\t\tgrp = ext4_get_group_info(sb, group);\n\t\t/* We only do this if the grp has never been initialized */\n\t\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t\tret = ext4_mb_init_group(sb, group, GFP_NOFS);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * For all the groups except the last one, last cluster will\n\t\t * always be EXT4_CLUSTERS_PER_GROUP(sb)-1, so we only need to\n\t\t * change it for the last group, note that last_cluster is\n\t\t * already computed earlier by ext4_get_group_no_and_offset()\n\t\t */\n\t\tif (group == last_group)\n\t\t\tend = last_cluster;\n\n\t\tif (grp->bb_free >= minlen) {\n\t\t\tcnt = ext4_trim_all_free(sb, group, first_cluster,\n\t\t\t\t\t\tend, minlen);\n\t\t\tif (cnt < 0) {\n\t\t\t\tret = cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttrimmed += cnt;\n\t\t}\n\n\t\t/*\n\t\t * For every group except the first one, we are sure\n\t\t * that the first cluster to discard will be cluster #0.\n\t\t */\n\t\tfirst_cluster = 0;\n\t}\n\n\tif (!ret)\n\t\tatomic_set(&EXT4_SB(sb)->s_last_trim_minblks, minlen);\n\nout:\n\trange->len = EXT4_C2B(EXT4_SB(sb), trimmed) << sb->s_blocksize_bits;\n\treturn ret;\n}\n\n/* Iterate all the free extents in the group. */\nint\next4_mballoc_query_range(\n\tstruct super_block\t\t*sb,\n\text4_group_t\t\t\tgroup,\n\text4_grpblk_t\t\t\tstart,\n\text4_grpblk_t\t\t\tend,\n\text4_mballoc_query_range_fn\tformatter,\n\tvoid\t\t\t\t*priv)\n{\n\tvoid\t\t\t\t*bitmap;\n\text4_grpblk_t\t\t\tnext;\n\tstruct ext4_buddy\t\te4b;\n\tint\t\t\t\terror;\n\n\terror = ext4_mb_load_buddy(sb, group, &e4b);\n\tif (error)\n\t\treturn error;\n\tbitmap = e4b.bd_bitmap;\n\n\text4_lock_group(sb, group);\n\n\tstart = (e4b.bd_info->bb_first_free > start) ?\n\t\te4b.bd_info->bb_first_free : start;\n\tif (end >= EXT4_CLUSTERS_PER_GROUP(sb))\n\t\tend = EXT4_CLUSTERS_PER_GROUP(sb) - 1;\n\n\twhile (start <= end) {\n\t\tstart = mb_find_next_zero_bit(bitmap, end + 1, start);\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnext = mb_find_next_bit(bitmap, end + 1, start);\n\n\t\text4_unlock_group(sb, group);\n\t\terror = formatter(sb, group, start, next - start, priv);\n\t\tif (error)\n\t\t\tgoto out_unload;\n\t\text4_lock_group(sb, group);\n\n\t\tstart = next + 1;\n\t}\n\n\text4_unlock_group(sb, group);\nout_unload:\n\text4_mb_unload_buddy(&e4b);\n\n\treturn error;\n}\n"}}, "reports": [{"events": [{"location": {"col": 6, "file": 0, "line": 3936}, "message": "atomic_dec_and_test variation before object free at line 3946."}], "macros": [], "notes": [], "path": "/src/fs/ext4/mballoc.c", "reportHash": "dcf338a83e354f9ae755762a4f67e219", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
