<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/clk/clk.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (C) 2010-2011 Canonical Ltd <jeremy.kerr@canonical.com>\n * Copyright (C) 2011-2012 Linaro Ltd <mturquette@linaro.org>\n *\n * Standard functionality for the common clock API.  See Documentation/driver-api/clk.rst\n */\n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clk/clk-conf.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/pm_runtime.h>\n#include <linux/sched.h>\n#include <linux/clkdev.h>\n\n#include \"clk.h\"\n\nstatic DEFINE_SPINLOCK(enable_lock);\nstatic DEFINE_MUTEX(prepare_lock);\n\nstatic struct task_struct *prepare_owner;\nstatic struct task_struct *enable_owner;\n\nstatic int prepare_refcnt;\nstatic int enable_refcnt;\n\nstatic HLIST_HEAD(clk_root_list);\nstatic HLIST_HEAD(clk_orphan_list);\nstatic LIST_HEAD(clk_notifier_list);\n\nstatic struct hlist_head *all_lists[] = {\n\t&clk_root_list,\n\t&clk_orphan_list,\n\tNULL,\n};\n\n/***    private data structures    ***/\n\nstruct clk_parent_map {\n\tconst struct clk_hw\t*hw;\n\tstruct clk_core\t\t*core;\n\tconst char\t\t*fw_name;\n\tconst char\t\t*name;\n\tint\t\t\tindex;\n};\n\nstruct clk_core {\n\tconst char\t\t*name;\n\tconst struct clk_ops\t*ops;\n\tstruct clk_hw\t\t*hw;\n\tstruct module\t\t*owner;\n\tstruct device\t\t*dev;\n\tstruct device_node\t*of_node;\n\tstruct clk_core\t\t*parent;\n\tstruct clk_parent_map\t*parents;\n\tu8\t\t\tnum_parents;\n\tu8\t\t\tnew_parent_index;\n\tunsigned long\t\trate;\n\tunsigned long\t\treq_rate;\n\tunsigned long\t\tnew_rate;\n\tstruct clk_core\t\t*new_parent;\n\tstruct clk_core\t\t*new_child;\n\tunsigned long\t\tflags;\n\tbool\t\t\torphan;\n\tbool\t\t\trpm_enabled;\n\tunsigned int\t\tenable_count;\n\tunsigned int\t\tprepare_count;\n\tunsigned int\t\tprotect_count;\n\tunsigned long\t\tmin_rate;\n\tunsigned long\t\tmax_rate;\n\tunsigned long\t\taccuracy;\n\tint\t\t\tphase;\n\tstruct clk_duty\t\tduty;\n\tstruct hlist_head\tchildren;\n\tstruct hlist_node\tchild_node;\n\tstruct hlist_head\tclks;\n\tunsigned int\t\tnotifier_count;\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry\t\t*dentry;\n\tstruct hlist_node\tdebug_node;\n#endif\n\tstruct kref\t\tref;\n};\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/clk.h>\n\nstruct clk {\n\tstruct clk_core\t*core;\n\tstruct device *dev;\n\tconst char *dev_id;\n\tconst char *con_id;\n\tunsigned long min_rate;\n\tunsigned long max_rate;\n\tunsigned int exclusive_count;\n\tstruct hlist_node clks_node;\n};\n\n/***           runtime pm          ***/\nstatic int clk_pm_runtime_get(struct clk_core *core)\n{\n\tint ret;\n\n\tif (!core->rpm_enabled)\n\t\treturn 0;\n\n\tret = pm_runtime_get_sync(core->dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(core->dev);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void clk_pm_runtime_put(struct clk_core *core)\n{\n\tif (!core->rpm_enabled)\n\t\treturn;\n\n\tpm_runtime_put_sync(core->dev);\n}\n\n/***           locking             ***/\nstatic void clk_prepare_lock(void)\n{\n\tif (!mutex_trylock(&prepare_lock)) {\n\t\tif (prepare_owner == current) {\n\t\t\tprepare_refcnt++;\n\t\t\treturn;\n\t\t}\n\t\tmutex_lock(&prepare_lock);\n\t}\n\tWARN_ON_ONCE(prepare_owner != NULL);\n\tWARN_ON_ONCE(prepare_refcnt != 0);\n\tprepare_owner = current;\n\tprepare_refcnt = 1;\n}\n\nstatic void clk_prepare_unlock(void)\n{\n\tWARN_ON_ONCE(prepare_owner != current);\n\tWARN_ON_ONCE(prepare_refcnt == 0);\n\n\tif (--prepare_refcnt)\n\t\treturn;\n\tprepare_owner = NULL;\n\tmutex_unlock(&prepare_lock);\n}\n\nstatic unsigned long clk_enable_lock(void)\n\t__acquires(enable_lock)\n{\n\tunsigned long flags;\n\n\t/*\n\t * On UP systems, spin_trylock_irqsave() always returns true, even if\n\t * we already hold the lock. So, in that case, we rely only on\n\t * reference counting.\n\t */\n\tif (!IS_ENABLED(CONFIG_SMP) ||\n\t    !spin_trylock_irqsave(&enable_lock, flags)) {\n\t\tif (enable_owner == current) {\n\t\t\tenable_refcnt++;\n\t\t\t__acquire(enable_lock);\n\t\t\tif (!IS_ENABLED(CONFIG_SMP))\n\t\t\t\tlocal_save_flags(flags);\n\t\t\treturn flags;\n\t\t}\n\t\tspin_lock_irqsave(&enable_lock, flags);\n\t}\n\tWARN_ON_ONCE(enable_owner != NULL);\n\tWARN_ON_ONCE(enable_refcnt != 0);\n\tenable_owner = current;\n\tenable_refcnt = 1;\n\treturn flags;\n}\n\nstatic void clk_enable_unlock(unsigned long flags)\n\t__releases(enable_lock)\n{\n\tWARN_ON_ONCE(enable_owner != current);\n\tWARN_ON_ONCE(enable_refcnt == 0);\n\n\tif (--enable_refcnt) {\n\t\t__release(enable_lock);\n\t\treturn;\n\t}\n\tenable_owner = NULL;\n\tspin_unlock_irqrestore(&enable_lock, flags);\n}\n\nstatic bool clk_core_rate_is_protected(struct clk_core *core)\n{\n\treturn core->protect_count;\n}\n\nstatic bool clk_core_is_prepared(struct clk_core *core)\n{\n\tbool ret = false;\n\n\t/*\n\t * .is_prepared is optional for clocks that can prepare\n\t * fall back to software usage counter if it is missing\n\t */\n\tif (!core->ops->is_prepared)\n\t\treturn core->prepare_count;\n\n\tif (!clk_pm_runtime_get(core)) {\n\t\tret = core->ops->is_prepared(core->hw);\n\t\tclk_pm_runtime_put(core);\n\t}\n\n\treturn ret;\n}\n\nstatic bool clk_core_is_enabled(struct clk_core *core)\n{\n\tbool ret = false;\n\n\t/*\n\t * .is_enabled is only mandatory for clocks that gate\n\t * fall back to software usage counter if .is_enabled is missing\n\t */\n\tif (!core->ops->is_enabled)\n\t\treturn core->enable_count;\n\n\t/*\n\t * Check if clock controller's device is runtime active before\n\t * calling .is_enabled callback. If not, assume that clock is\n\t * disabled, because we might be called from atomic context, from\n\t * which pm_runtime_get() is not allowed.\n\t * This function is called mainly from clk_disable_unused_subtree,\n\t * which ensures proper runtime pm activation of controller before\n\t * taking enable spinlock, but the below check is needed if one tries\n\t * to call it from other places.\n\t */\n\tif (core->rpm_enabled) {\n\t\tpm_runtime_get_noresume(core->dev);\n\t\tif (!pm_runtime_active(core->dev)) {\n\t\t\tret = false;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tret = core->ops->is_enabled(core->hw);\ndone:\n\tif (core->rpm_enabled)\n\t\tpm_runtime_put(core->dev);\n\n\treturn ret;\n}\n\n/***    helper functions   ***/\n\nconst char *__clk_get_name(const struct clk *clk)\n{\n\treturn !clk ? NULL : clk->core->name;\n}\nEXPORT_SYMBOL_GPL(__clk_get_name);\n\nconst char *clk_hw_get_name(const struct clk_hw *hw)\n{\n\treturn hw->core->name;\n}\nEXPORT_SYMBOL_GPL(clk_hw_get_name);\n\nstruct clk_hw *__clk_get_hw(struct clk *clk)\n{\n\treturn !clk ? NULL : clk->core->hw;\n}\nEXPORT_SYMBOL_GPL(__clk_get_hw);\n\nunsigned int clk_hw_get_num_parents(const struct clk_hw *hw)\n{\n\treturn hw->core->num_parents;\n}\nEXPORT_SYMBOL_GPL(clk_hw_get_num_parents);\n\nstruct clk_hw *clk_hw_get_parent(const struct clk_hw *hw)\n{\n\treturn hw->core->parent ? hw->core->parent->hw : NULL;\n}\nEXPORT_SYMBOL_GPL(clk_hw_get_parent);\n\nstatic struct clk_core *__clk_lookup_subtree(const char *name,\n\t\t\t\t\t     struct clk_core *core)\n{\n\tstruct clk_core *child;\n\tstruct clk_core *ret;\n\n\tif (!strcmp(core->name, name))\n\t\treturn core;\n\n\thlist_for_each_entry(child, &core->children, child_node) {\n\t\tret = __clk_lookup_subtree(name, child);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct clk_core *clk_core_lookup(const char *name)\n{\n\tstruct clk_core *root_clk;\n\tstruct clk_core *ret;\n\n\tif (!name)\n\t\treturn NULL;\n\n\t/* search the 'proper' clk tree first */\n\thlist_for_each_entry(root_clk, &clk_root_list, child_node) {\n\t\tret = __clk_lookup_subtree(name, root_clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* if not found, then search the orphan tree */\n\thlist_for_each_entry(root_clk, &clk_orphan_list, child_node) {\n\t\tret = __clk_lookup_subtree(name, root_clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn NULL;\n}\n\n#ifdef CONFIG_OF\nstatic int of_parse_clkspec(const struct device_node *np, int index,\n\t\t\t    const char *name, struct of_phandle_args *out_args);\nstatic struct clk_hw *\nof_clk_get_hw_from_clkspec(struct of_phandle_args *clkspec);\n#else\nstatic inline int of_parse_clkspec(const struct device_node *np, int index,\n\t\t\t\t   const char *name,\n\t\t\t\t   struct of_phandle_args *out_args)\n{\n\treturn -ENOENT;\n}\nstatic inline struct clk_hw *\nof_clk_get_hw_from_clkspec(struct of_phandle_args *clkspec)\n{\n\treturn ERR_PTR(-ENOENT);\n}\n#endif\n\n/**\n * clk_core_get - Find the clk_core parent of a clk\n * @core: clk to find parent of\n * @p_index: parent index to search for\n *\n * This is the preferred method for clk providers to find the parent of a\n * clk when that parent is external to the clk controller. The parent_names\n * array is indexed and treated as a local name matching a string in the device\n * node's 'clock-names' property or as the 'con_id' matching the device's\n * dev_name() in a clk_lookup. This allows clk providers to use their own\n * namespace instead of looking for a globally unique parent string.\n *\n * For example the following DT snippet would allow a clock registered by the\n * clock-controller@c001 that has a clk_init_data::parent_data array\n * with 'xtal' in the 'name' member to find the clock provided by the\n * clock-controller@f00abcd without needing to get the globally unique name of\n * the xtal clk.\n *\n *      parent: clock-controller@f00abcd {\n *              reg = <0xf00abcd 0xabcd>;\n *              #clock-cells = <0>;\n *      };\n *\n *      clock-controller@c001 {\n *              reg = <0xc001 0xf00d>;\n *              clocks = <&parent>;\n *              clock-names = \"xtal\";\n *              #clock-cells = <1>;\n *      };\n *\n * Returns: -ENOENT when the provider can't be found or the clk doesn't\n * exist in the provider or the name can't be found in the DT node or\n * in a clkdev lookup. NULL when the provider knows about the clk but it\n * isn't provided on this system.\n * A valid clk_core pointer when the clk can be found in the provider.\n */\nstatic struct clk_core *clk_core_get(struct clk_core *core, u8 p_index)\n{\n\tconst char *name = core->parents[p_index].fw_name;\n\tint index = core->parents[p_index].index;\n\tstruct clk_hw *hw = ERR_PTR(-ENOENT);\n\tstruct device *dev = core->dev;\n\tconst char *dev_id = dev ? dev_name(dev) : NULL;\n\tstruct device_node *np = core->of_node;\n\tstruct of_phandle_args clkspec;\n\n\tif (np && (name || index >= 0) &&\n\t    !of_parse_clkspec(np, index, name, &clkspec)) {\n\t\thw = of_clk_get_hw_from_clkspec(&clkspec);\n\t\tof_node_put(clkspec.np);\n\t} else if (name) {\n\t\t/*\n\t\t * If the DT search above couldn't find the provider fallback to\n\t\t * looking up via clkdev based clk_lookups.\n\t\t */\n\t\thw = clk_find_hw(dev_id, name);\n\t}\n\n\tif (IS_ERR(hw))\n\t\treturn ERR_CAST(hw);\n\n\treturn hw->core;\n}\n\nstatic void clk_core_fill_parent_index(struct clk_core *core, u8 index)\n{\n\tstruct clk_parent_map *entry = &core->parents[index];\n\tstruct clk_core *parent;\n\n\tif (entry->hw) {\n\t\tparent = entry->hw->core;\n\t\t/*\n\t\t * We have a direct reference but it isn't registered yet?\n\t\t * Orphan it and let clk_reparent() update the orphan status\n\t\t * when the parent is registered.\n\t\t */\n\t\tif (!parent)\n\t\t\tparent = ERR_PTR(-EPROBE_DEFER);\n\t} else {\n\t\tparent = clk_core_get(core, index);\n\t\tif (PTR_ERR(parent) == -ENOENT && entry->name)\n\t\t\tparent = clk_core_lookup(entry->name);\n\t}\n\n\t/* Only cache it if it's not an error */\n\tif (!IS_ERR(parent))\n\t\tentry->core = parent;\n}\n\nstatic struct clk_core *clk_core_get_parent_by_index(struct clk_core *core,\n\t\t\t\t\t\t\t u8 index)\n{\n\tif (!core || index >= core->num_parents || !core->parents)\n\t\treturn NULL;\n\n\tif (!core->parents[index].core)\n\t\tclk_core_fill_parent_index(core, index);\n\n\treturn core->parents[index].core;\n}\n\nstruct clk_hw *\nclk_hw_get_parent_by_index(const struct clk_hw *hw, unsigned int index)\n{\n\tstruct clk_core *parent;\n\n\tparent = clk_core_get_parent_by_index(hw->core, index);\n\n\treturn !parent ? NULL : parent->hw;\n}\nEXPORT_SYMBOL_GPL(clk_hw_get_parent_by_index);\n\nunsigned int __clk_get_enable_count(struct clk *clk)\n{\n\treturn !clk ? 0 : clk->core->enable_count;\n}\n\nstatic unsigned long clk_core_get_rate_nolock(struct clk_core *core)\n{\n\tif (!core)\n\t\treturn 0;\n\n\tif (!core->num_parents || core->parent)\n\t\treturn core->rate;\n\n\t/*\n\t * Clk must have a parent because num_parents > 0 but the parent isn't\n\t * known yet. Best to return 0 as the rate of this clk until we can\n\t * properly recalc the rate based on the parent's rate.\n\t */\n\treturn 0;\n}\n\nunsigned long clk_hw_get_rate(const struct clk_hw *hw)\n{\n\treturn clk_core_get_rate_nolock(hw->core);\n}\nEXPORT_SYMBOL_GPL(clk_hw_get_rate);\n\nstatic unsigned long clk_core_get_accuracy_no_lock(struct clk_core *core)\n{\n\tif (!core)\n\t\treturn 0;\n\n\treturn core->accuracy;\n}\n\nunsigned long clk_hw_get_flags(const struct clk_hw *hw)\n{\n\treturn hw->core->flags;\n}\nEXPORT_SYMBOL_GPL(clk_hw_get_flags);\n\nbool clk_hw_is_prepared(const struct clk_hw *hw)\n{\n\treturn clk_core_is_prepared(hw->core);\n}\nEXPORT_SYMBOL_GPL(clk_hw_is_prepared);\n\nbool clk_hw_rate_is_protected(const struct clk_hw *hw)\n{\n\treturn clk_core_rate_is_protected(hw->core);\n}\nEXPORT_SYMBOL_GPL(clk_hw_rate_is_protected);\n\nbool clk_hw_is_enabled(const struct clk_hw *hw)\n{\n\treturn clk_core_is_enabled(hw->core);\n}\nEXPORT_SYMBOL_GPL(clk_hw_is_enabled);\n\nbool __clk_is_enabled(struct clk *clk)\n{\n\tif (!clk)\n\t\treturn false;\n\n\treturn clk_core_is_enabled(clk->core);\n}\nEXPORT_SYMBOL_GPL(__clk_is_enabled);\n\nstatic bool mux_is_better_rate(unsigned long rate, unsigned long now,\n\t\t\t   unsigned long best, unsigned long flags)\n{\n\tif (flags & CLK_MUX_ROUND_CLOSEST)\n\t\treturn abs(now - rate) < abs(best - rate);\n\n\treturn now <= rate && now > best;\n}\n\nint clk_mux_determine_rate_flags(struct clk_hw *hw,\n\t\t\t\t struct clk_rate_request *req,\n\t\t\t\t unsigned long flags)\n{\n\tstruct clk_core *core = hw->core, *parent, *best_parent = NULL;\n\tint i, num_parents, ret;\n\tunsigned long best = 0;\n\tstruct clk_rate_request parent_req = *req;\n\n\t/* if NO_REPARENT flag set, pass through to current parent */\n\tif (core->flags & CLK_SET_RATE_NO_REPARENT) {\n\t\tparent = core->parent;\n\t\tif (core->flags & CLK_SET_RATE_PARENT) {\n\t\t\tret = __clk_determine_rate(parent ? parent->hw : NULL,\n\t\t\t\t\t\t   &parent_req);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tbest = parent_req.rate;\n\t\t} else if (parent) {\n\t\t\tbest = clk_core_get_rate_nolock(parent);\n\t\t} else {\n\t\t\tbest = clk_core_get_rate_nolock(core);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\t/* find the parent that can provide the fastest rate <= rate */\n\tnum_parents = core->num_parents;\n\tfor (i = 0; i < num_parents; i++) {\n\t\tparent = clk_core_get_parent_by_index(core, i);\n\t\tif (!parent)\n\t\t\tcontinue;\n\n\t\tif (core->flags & CLK_SET_RATE_PARENT) {\n\t\t\tparent_req = *req;\n\t\t\tret = __clk_determine_rate(parent->hw, &parent_req);\n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tparent_req.rate = clk_core_get_rate_nolock(parent);\n\t\t}\n\n\t\tif (mux_is_better_rate(req->rate, parent_req.rate,\n\t\t\t\t       best, flags)) {\n\t\t\tbest_parent = parent;\n\t\t\tbest = parent_req.rate;\n\t\t}\n\t}\n\n\tif (!best_parent)\n\t\treturn -EINVAL;\n\nout:\n\tif (best_parent)\n\t\treq->best_parent_hw = best_parent->hw;\n\treq->best_parent_rate = best;\n\treq->rate = best;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(clk_mux_determine_rate_flags);\n\nstruct clk *__clk_lookup(const char *name)\n{\n\tstruct clk_core *core = clk_core_lookup(name);\n\n\treturn !core ? NULL : core->hw->clk;\n}\n\nstatic void clk_core_get_boundaries(struct clk_core *core,\n\t\t\t\t    unsigned long *min_rate,\n\t\t\t\t    unsigned long *max_rate)\n{\n\tstruct clk *clk_user;\n\n\tlockdep_assert_held(&prepare_lock);\n\n\t*min_rate = core->min_rate;\n\t*max_rate = core->max_rate;\n\n\thlist_for_each_entry(clk_user, &core->clks, clks_node)\n\t\t*min_rate = max(*min_rate, clk_user->min_rate);\n\n\thlist_for_each_entry(clk_user, &core->clks, clks_node)\n\t\t*max_rate = min(*max_rate, clk_user->max_rate);\n}\n\nvoid clk_hw_set_rate_range(struct clk_hw *hw, unsigned long min_rate,\n\t\t\t   unsigned long max_rate)\n{\n\thw->core->min_rate = min_rate;\n\thw->core->max_rate = max_rate;\n}\nEXPORT_SYMBOL_GPL(clk_hw_set_rate_range);\n\n/*\n * __clk_mux_determine_rate - clk_ops::determine_rate implementation for a mux type clk\n * @hw: mux type clk to determine rate on\n * @req: rate request, also used to return preferred parent and frequencies\n *\n * Helper for finding best parent to provide a given frequency. This can be used\n * directly as a determine_rate callback (e.g. for a mux), or from a more\n * complex clock that may combine a mux with other operations.\n *\n * Returns: 0 on success, -EERROR value on error\n */\nint __clk_mux_determine_rate(struct clk_hw *hw,\n\t\t\t     struct clk_rate_request *req)\n{\n\treturn clk_mux_determine_rate_flags(hw, req, 0);\n}\nEXPORT_SYMBOL_GPL(__clk_mux_determine_rate);\n\nint __clk_mux_determine_rate_closest(struct clk_hw *hw,\n\t\t\t\t     struct clk_rate_request *req)\n{\n\treturn clk_mux_determine_rate_flags(hw, req, CLK_MUX_ROUND_CLOSEST);\n}\nEXPORT_SYMBOL_GPL(__clk_mux_determine_rate_closest);\n\n/***        clk api        ***/\n\nstatic void clk_core_rate_unprotect(struct clk_core *core)\n{\n\tlockdep_assert_held(&prepare_lock);\n\n\tif (!core)\n\t\treturn;\n\n\tif (WARN(core->protect_count == 0,\n\t    \"%s already unprotected\\n\", core->name))\n\t\treturn;\n\n\tif (--core->protect_count > 0)\n\t\treturn;\n\n\tclk_core_rate_unprotect(core->parent);\n}\n\nstatic int clk_core_rate_nuke_protect(struct clk_core *core)\n{\n\tint ret;\n\n\tlockdep_assert_held(&prepare_lock);\n\n\tif (!core)\n\t\treturn -EINVAL;\n\n\tif (core->protect_count == 0)\n\t\treturn 0;\n\n\tret = core->protect_count;\n\tcore->protect_count = 1;\n\tclk_core_rate_unprotect(core);\n\n\treturn ret;\n}\n\n/**\n * clk_rate_exclusive_put - release exclusivity over clock rate control\n * @clk: the clk over which the exclusivity is released\n *\n * clk_rate_exclusive_put() completes a critical section during which a clock\n * consumer cannot tolerate any other consumer making any operation on the\n * clock which could result in a rate change or rate glitch. Exclusive clocks\n * cannot have their rate changed, either directly or indirectly due to changes\n * further up the parent chain of clocks. As a result, clocks up parent chain\n * also get under exclusive control of the calling consumer.\n *\n * If exlusivity is claimed more than once on clock, even by the same consumer,\n * the rate effectively gets locked as exclusivity can't be preempted.\n *\n * Calls to clk_rate_exclusive_put() must be balanced with calls to\n * clk_rate_exclusive_get(). Calls to this function may sleep, and do not return\n * error status.\n */\nvoid clk_rate_exclusive_put(struct clk *clk)\n{\n\tif (!clk)\n\t\treturn;\n\n\tclk_prepare_lock();\n\n\t/*\n\t * if there is something wrong with this consumer protect count, stop\n\t * here before messing with the provider\n\t */\n\tif (WARN_ON(clk->exclusive_count <= 0))\n\t\tgoto out;\n\n\tclk_core_rate_unprotect(clk->core);\n\tclk->exclusive_count--;\nout:\n\tclk_prepare_unlock();\n}\nEXPORT_SYMBOL_GPL(clk_rate_exclusive_put);\n\nstatic void clk_core_rate_protect(struct clk_core *core)\n{\n\tlockdep_assert_held(&prepare_lock);\n\n\tif (!core)\n\t\treturn;\n\n\tif (core->protect_count == 0)\n\t\tclk_core_rate_protect(core->parent);\n\n\tcore->protect_count++;\n}\n\nstatic void clk_core_rate_restore_protect(struct clk_core *core, int count)\n{\n\tlockdep_assert_held(&prepare_lock);\n\n\tif (!core)\n\t\treturn;\n\n\tif (count == 0)\n\t\treturn;\n\n\tclk_core_rate_protect(core);\n\tcore->protect_count = count;\n}\n\n/**\n * clk_rate_exclusive_get - get exclusivity over the clk rate control\n * @clk: the clk over which the exclusity of rate control is requested\n *\n * clk_rate_exclusive_get() begins a critical section during which a clock\n * consumer cannot tolerate any other consumer making any operation on the\n * clock which could result in a rate change or rate glitch. Exclusive clocks\n * cannot have their rate changed, either directly or indirectly due to changes\n * further up the parent chain of clocks. As a result, clocks up parent chain\n * also get under exclusive control of the calling consumer.\n *\n * If exlusivity is claimed more than once on clock, even by the same consumer,\n * the rate effectively gets locked as exclusivity can't be preempted.\n *\n * Calls to clk_rate_exclusive_get() should be balanced with calls to\n * clk_rate_exclusive_put(). Calls to this function may sleep.\n * Returns 0 on success, -EERROR otherwise\n */\nint clk_rate_exclusive_get(struct clk *clk)\n{\n\tif (!clk)\n\t\treturn 0;\n\n\tclk_prepare_lock();\n\tclk_core_rate_protect(clk->core);\n\tclk->exclusive_count++;\n\tclk_prepare_unlock();\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(clk_rate_exclusive_get);\n\nstatic void clk_core_unprepare(struct clk_core *core)\n{\n\tlockdep_assert_held(&prepare_lock);\n\n\tif (!core)\n\t\treturn;\n\n\tif (WARN(core->prepare_count == 0,\n\t    \"%s already unprepared\\n\", core->name))\n\t\treturn;\n\n\tif (WARN(core->prepare_count == 1 && core->flags & CLK_IS_CRITICAL,\n\t    \"Unpreparing critical %s\\n\", core->name))\n\t\treturn;\n\n\tif (core->flags & CLK_SET_RATE_GATE)\n\t\tclk_core_rate_unprotect(core);\n\n\tif (--core->prepare_count > 0)\n\t\treturn;\n\n\tWARN(core->enable_count > 0, \"Unpreparing enabled %s\\n\", core->name);\n\n\ttrace_clk_unprepare(core);\n\n\tif (core->ops->unprepare)\n\t\tcore->ops->unprepare(core->hw);\n\n\tclk_pm_runtime_put(core);\n\n\ttrace_clk_unprepare_complete(core);\n\tclk_core_unprepare(core->parent);\n}\n\nstatic void clk_core_unprepare_lock(struct clk_core *core)\n{\n\tclk_prepare_lock();\n\tclk_core_unprepare(core);\n\tclk_prepare_unlock();\n}\n\n/**\n * clk_unprepare - undo preparation of a clock source\n * @clk: the clk being unprepared\n *\n * clk_unprepare may sleep, which differentiates it from clk_disable.  In a\n * simple case, clk_unprepare can be used instead of clk_disable to gate a clk\n * if the operation may sleep.  One example is a clk which is accessed over\n * I2c.  In the complex case a clk gate operation may require a fast and a slow\n * part.  It is this reason that clk_unprepare and clk_disable are not mutually\n * exclusive.  In fact clk_disable must be called before clk_unprepare.\n */\nvoid clk_unprepare(struct clk *clk)\n{\n\tif (IS_ERR_OR_NULL(clk))\n\t\treturn;\n\n\tclk_core_unprepare_lock(clk->core);\n}\nEXPORT_SYMBOL_GPL(clk_unprepare);\n\nstatic int clk_core_prepare(struct clk_core *core)\n{\n\tint ret = 0;\n\n\tlockdep_assert_held(&prepare_lock);\n\n\tif (!core)\n\t\treturn 0;\n\n\tif (core->prepare_count == 0) {\n\t\tret = clk_pm_runtime_get(core);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = clk_core_prepare(core->parent);\n\t\tif (ret)\n\t\t\tgoto runtime_put;\n\n\t\ttrace_clk_prepare(core);\n\n\t\tif (core->ops->prepare)\n\t\t\tret = core->ops->prepare(core->hw);\n\n\t\ttrace_clk_prepare_complete(core);\n\n\t\tif (ret)\n\t\t\tgoto unprepare;\n\t}\n\n\tcore->prepare_count++;\n\n\t/*\n\t * CLK_SET_RATE_GATE is a special case of clock protection\n\t * Instead of a consumer claiming exclusive rate control, it is\n\t * actually the provider which prevents any consumer from making any\n\t * operation which could result in a rate change or rate glitch while\n\t * the clock is prepared.\n\t */\n\tif (core->flags & CLK_SET_RATE_GATE)\n\t\tclk_core_rate_protect(core);\n\n\treturn 0;\nunprepare:\n\tclk_core_unprepare(core->parent);\nruntime_put:\n\tclk_pm_runtime_put(core);\n\treturn ret;\n}\n\nstatic int clk_core_prepare_lock(struct clk_core *core)\n{\n\tint ret;\n\n\tclk_prepare_lock();\n\tret = clk_core_prepare(core);\n\tclk_prepare_unlock();\n\n\treturn ret;\n}\n\n/**\n * clk_prepare - prepare a clock source\n * @clk: the clk being prepared\n *\n * clk_prepare may sleep, which differentiates it from clk_enable.  In a simple\n * case, clk_prepare can be used instead of clk_enable to ungate a clk if the\n * operation may sleep.  One example is a clk which is accessed over I2c.  In\n * the complex case a clk ungate operation may require a fast and a slow part.\n * It is this reason that clk_prepare and clk_enable are not mutually\n * exclusive.  In fact clk_prepare must be called before clk_enable.\n * Returns 0 on success, -EERROR otherwise.\n */\nint clk_prepare(struct clk *clk)\n{\n\tif (!clk)\n\t\treturn 0;\n\n\treturn clk_core_prepare_lock(clk->core);\n}\nEXPORT_SYMBOL_GPL(clk_prepare);\n\nstatic void clk_core_disable(struct clk_core *core)\n{\n\tlockdep_assert_held(&enable_lock);\n\n\tif (!core)\n\t\treturn;\n\n\tif (WARN(core->enable_count == 0, \"%s already disabled\\n\", core->name))\n\t\treturn;\n\n\tif (WARN(core->enable_count == 1 && core->flags & CLK_IS_CRITICAL,\n\t    \"Disabling critical %s\\n\", core->name))\n\t\treturn;\n\n\tif (--core->enable_count > 0)\n\t\treturn;\n\n\ttrace_clk_disable_rcuidle(core);\n\n\tif (core->ops->disable)\n\t\tcore->ops->disable(core->hw);\n\n\ttrace_clk_disable_complete_rcuidle(core);\n\n\tclk_core_disable(core->parent);\n}\n\nstatic void clk_core_disable_lock(struct clk_core *core)\n{\n\tunsigned long flags;\n\n\tflags = clk_enable_lock();\n\tclk_core_disable(core);\n\tclk_enable_unlock(flags);\n}\n\n/**\n * clk_disable - gate a clock\n * @clk: the clk being gated\n *\n * clk_disable must not sleep, which differentiates it from clk_unprepare.  In\n * a simple case, clk_disable can be used instead of clk_unprepare to gate a\n * clk if the operation is fast and will never sleep.  One example is a\n * SoC-internal clk which is controlled via simple register writes.  In the\n * complex case a clk gate operation may require a fast and a slow part.  It is\n * this reason that clk_unprepare and clk_disable are not mutually exclusive.\n * In fact clk_disable must be called before clk_unprepare.\n */\nvoid clk_disable(struct clk *clk)\n{\n\tif (IS_ERR_OR_NULL(clk))\n\t\treturn;\n\n\tclk_core_disable_lock(clk->core);\n}\nEXPORT_SYMBOL_GPL(clk_disable);\n\nstatic int clk_core_enable(struct clk_core *core)\n{\n\tint ret = 0;\n\n\tlockdep_assert_held(&enable_lock);\n\n\tif (!core)\n\t\treturn 0;\n\n\tif (WARN(core->prepare_count == 0,\n\t    \"Enabling unprepared %s\\n\", core->name))\n\t\treturn -ESHUTDOWN;\n\n\tif (core->enable_count == 0) {\n\t\tret = clk_core_enable(core->parent);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttrace_clk_enable_rcuidle(core);\n\n\t\tif (core->ops->enable)\n\t\t\tret = core->ops->enable(core->hw);\n\n\t\ttrace_clk_enable_complete_rcuidle(core);\n\n\t\tif (ret) {\n\t\t\tclk_core_disable(core->parent);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tcore->enable_count++;\n\treturn 0;\n}\n\nstatic int clk_core_enable_lock(struct clk_core *core)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tflags = clk_enable_lock();\n\tret = clk_core_enable(core);\n\tclk_enable_unlock(flags);\n\n\treturn ret;\n}\n\n/**\n * clk_gate_restore_context - restore context for poweroff\n * @hw: the clk_hw pointer of clock whose state is to be restored\n *\n * The clock gate restore context function enables or disables\n * the gate clocks based on the enable_count. This is done in cases\n * where the clock context is lost and based on the enable_count\n * the clock either needs to be enabled/disabled. This\n * helps restore the state of gate clocks.\n */\nvoid clk_gate_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_core *core = hw->core;\n\n\tif (core->enable_count)\n\t\tcore->ops->enable(hw);\n\telse\n\t\tcore->ops->disable(hw);\n}\nEXPORT_SYMBOL_GPL(clk_gate_restore_context);\n\nstatic int clk_core_save_context(struct clk_core *core)\n{\n\tstruct clk_core *child;\n\tint ret = 0;\n\n\thlist_for_each_entry(child, &core->children, child_node) {\n\t\tret = clk_core_save_context(child);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (core->ops && core->ops->save_context)\n\t\tret = core->ops->save_context(core->hw);\n\n\treturn ret;\n}\n\nstatic void clk_core_restore_context(struct clk_core *core)\n{\n\tstruct clk_core *child;\n\n\tif (core->ops && core->ops->restore_context)\n\t\tcore->ops->restore_context(core->hw);\n\n\thlist_for_each_entry(child, &core->children, child_node)\n\t\tclk_core_restore_context(child);\n}\n\n/**\n * clk_save_context - save clock context for poweroff\n *\n * Saves the context of the clock register for powerstates in which the\n * contents of the registers will be lost. Occurs deep within the suspend\n * code.  Returns 0 on success.\n */\nint clk_save_context(void)\n{\n\tstruct clk_core *clk;\n\tint ret;\n\n\thlist_for_each_entry(clk, &clk_root_list, child_node) {\n\t\tret = clk_core_save_context(clk);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\thlist_for_each_entry(clk, &clk_orphan_list, child_node) {\n\t\tret = clk_core_save_context(clk);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(clk_save_context);\n\n/**\n * clk_restore_context - restore clock context after poweroff\n *\n * Restore the saved clock context upon resume.\n *\n */\nvoid clk_restore_context(void)\n{\n\tstruct clk_core *core;\n\n\thlist_for_each_entry(core, &clk_root_list, child_node)\n\t\tclk_core_restore_context(core);\n\n\thlist_for_each_entry(core, &clk_orphan_list, child_node)\n\t\tclk_core_restore_context(core);\n}\nEXPORT_SYMBOL_GPL(clk_restore_context);\n\n/**\n * clk_enable - ungate a clock\n * @clk: the clk being ungated\n *\n * clk_enable must not sleep, which differentiates it from clk_prepare.  In a\n * simple case, clk_enable can be used instead of clk_prepare to ungate a clk\n * if the operation will never sleep.  One example is a SoC-internal clk which\n * is controlled via simple register writes.  In the complex case a clk ungate\n * operation may require a fast and a slow part.  It is this reason that\n * clk_enable and clk_prepare are not mutually exclusive.  In fact clk_prepare\n * must be called before clk_enable.  Returns 0 on success, -EERROR\n * otherwise.\n */\nint clk_enable(struct clk *clk)\n{\n\tif (!clk)\n\t\treturn 0;\n\n\treturn clk_core_enable_lock(clk->core);\n}\nEXPORT_SYMBOL_GPL(clk_enable);\n\n/**\n * clk_is_enabled_when_prepared - indicate if preparing a clock also enables it.\n * @clk: clock source\n *\n * Returns true if clk_prepare() implicitly enables the clock, effectively\n * making clk_enable()/clk_disable() no-ops, false otherwise.\n *\n * This is of interest mainly to power management code where actually\n * disabling the clock also requires unpreparing it to have any material\n * effect.\n *\n * Regardless of the value returned here, the caller must always invoke\n * clk_enable() or clk_prepare_enable()  and counterparts for usage counts\n * to be right.\n */\nbool clk_is_enabled_when_prepared(struct clk *clk)\n{\n\treturn clk && !(clk->core->ops->enable && clk->core->ops->disable);\n}\nEXPORT_SYMBOL_GPL(clk_is_enabled_when_prepared);\n\nstatic int clk_core_prepare_enable(struct clk_core *core)\n{\n\tint ret;\n\n\tret = clk_core_prepare_lock(core);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_core_enable_lock(core);\n\tif (ret)\n\t\tclk_core_unprepare_lock(core);\n\n\treturn ret;\n}\n\nstatic void clk_core_disable_unprepare(struct clk_core *core)\n{\n\tclk_core_disable_lock(core);\n\tclk_core_unprepare_lock(core);\n}\n\nstatic void __init clk_unprepare_unused_subtree(struct clk_core *core)\n{\n\tstruct clk_core *child;\n\n\tlockdep_assert_held(&prepare_lock);\n\n\thlist_for_each_entry(child, &core->children, child_node)\n\t\tclk_unprepare_unused_subtree(child);\n\n\tif (core->prepare_count)\n\t\treturn;\n\n\tif (core->flags & CLK_IGNORE_UNUSED)\n\t\treturn;\n\n\tif (clk_pm_runtime_get(core))\n\t\treturn;\n\n\tif (clk_core_is_prepared(core)) {\n\t\ttrace_clk_unprepare(core);\n\t\tif (core->ops->unprepare_unused)\n\t\t\tcore->ops->unprepare_unused(core->hw);\n\t\telse if (core->ops->unprepare)\n\t\t\tcore->ops->unprepare(core->hw);\n\t\ttrace_clk_unprepare_complete(core);\n\t}\n\n\tclk_pm_runtime_put(core);\n}\n\nstatic void __init clk_disable_unused_subtree(struct clk_core *core)\n{\n\tstruct clk_core *child;\n\tunsigned long flags;\n\n\tlockdep_assert_held(&prepare_lock);\n\n\thlist_for_each_entry(child, &core->children, child_node)\n\t\tclk_disable_unused_subtree(child);\n\n\tif (core->flags & CLK_OPS_PARENT_ENABLE)\n\t\tclk_core_prepare_enable(core->parent);\n\n\tif (clk_pm_runtime_get(core))\n\t\tgoto unprepare_out;\n\n\tflags = clk_enable_lock();\n\n\tif (core->enable_count)\n\t\tgoto unlock_out;\n\n\tif (core->flags & CLK_IGNORE_UNUSED)\n\t\tgoto unlock_out;\n\n\t/*\n\t * some gate clocks have special needs during the disable-unused\n\t * sequence.  call .disable_unused if available, otherwise fall\n\t * back to .disable\n\t */\n\tif (clk_core_is_enabled(core)) {\n\t\ttrace_clk_disable(core);\n\t\tif (core->ops->disable_unused)\n\t\t\tcore->ops->disable_unused(core->hw);\n\t\telse if (core->ops->disable)\n\t\t\tcore->ops->disable(core->hw);\n\t\ttrace_clk_disable_complete(core);\n\t}\n\nunlock_out:\n\tclk_enable_unlock(flags);\n\tclk_pm_runtime_put(core);\nunprepare_out:\n\tif (core->flags & CLK_OPS_PARENT_ENABLE)\n\t\tclk_core_disable_unprepare(core->parent);\n}\n\nstatic bool clk_ignore_unused __initdata;\nstatic int __init clk_ignore_unused_setup(char *__unused)\n{\n\tclk_ignore_unused = true;\n\treturn 1;\n}\n__setup(\"clk_ignore_unused\", clk_ignore_unused_setup);\n\nstatic int __init clk_disable_unused(void)\n{\n\tstruct clk_core *core;\n\n\tif (clk_ignore_unused) {\n\t\tpr_warn(\"clk: Not disabling unused clocks\\n\");\n\t\treturn 0;\n\t}\n\n\tclk_prepare_lock();\n\n\thlist_for_each_entry(core, &clk_root_list, child_node)\n\t\tclk_disable_unused_subtree(core);\n\n\thlist_for_each_entry(core, &clk_orphan_list, child_node)\n\t\tclk_disable_unused_subtree(core);\n\n\thlist_for_each_entry(core, &clk_root_list, child_node)\n\t\tclk_unprepare_unused_subtree(core);\n\n\thlist_for_each_entry(core, &clk_orphan_list, child_node)\n\t\tclk_unprepare_unused_subtree(core);\n\n\tclk_prepare_unlock();\n\n\treturn 0;\n}\nlate_initcall_sync(clk_disable_unused);\n\nstatic int clk_core_determine_round_nolock(struct clk_core *core,\n\t\t\t\t\t   struct clk_rate_request *req)\n{\n\tlong rate;\n\n\tlockdep_assert_held(&prepare_lock);\n\n\tif (!core)\n\t\treturn 0;\n\n\t/*\n\t * At this point, core protection will be disabled if\n\t * - if the provider is not protected at all\n\t * - if the calling consumer is the only one which has exclusivity\n\t *   over the provider\n\t */\n\tif (clk_core_rate_is_protected(core)) {\n\t\treq->rate = core->rate;\n\t} else if (core->ops->determine_rate) {\n\t\treturn core->ops->determine_rate(core->hw, req);\n\t} else if (core->ops->round_rate) {\n\t\trate = core->ops->round_rate(core->hw, req->rate,\n\t\t\t\t\t     &req->best_parent_rate);\n\t\tif (rate < 0)\n\t\t\treturn rate;\n\n\t\treq->rate = rate;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void clk_core_init_rate_req(struct clk_core * const core,\n\t\t\t\t   struct clk_rate_request *req)\n{\n\tstruct clk_core *parent;\n\n\tif (WARN_ON(!core || !req))\n\t\treturn;\n\n\tparent = core->parent;\n\tif (parent) {\n\t\treq->best_parent_hw = parent->hw;\n\t\treq->best_parent_rate = parent->rate;\n\t} else {\n\t\treq->best_parent_hw = NULL;\n\t\treq->best_parent_rate = 0;\n\t}\n}\n\nstatic bool clk_core_can_round(struct clk_core * const core)\n{\n\treturn core->ops->determine_rate || core->ops->round_rate;\n}\n\nstatic int clk_core_round_rate_nolock(struct clk_core *core,\n\t\t\t\t      struct clk_rate_request *req)\n{\n\tlockdep_assert_held(&prepare_lock);\n\n\tif (!core) {\n\t\treq->rate = 0;\n\t\treturn 0;\n\t}\n\n\tclk_core_init_rate_req(core, req);\n\n\tif (clk_core_can_round(core))\n\t\treturn clk_core_determine_round_nolock(core, req);\n\telse if (core->flags & CLK_SET_RATE_PARENT)\n\t\treturn clk_core_round_rate_nolock(core->parent, req);\n\n\treq->rate = core->rate;\n\treturn 0;\n}\n\n/**\n * __clk_determine_rate - get the closest rate actually supported by a clock\n * @hw: determine the rate of this clock\n * @req: target rate request\n *\n * Useful for clk_ops such as .set_rate and .determine_rate.\n */\nint __clk_determine_rate(struct clk_hw *hw, struct clk_rate_request *req)\n{\n\tif (!hw) {\n\t\treq->rate = 0;\n\t\treturn 0;\n\t}\n\n\treturn clk_core_round_rate_nolock(hw->core, req);\n}\nEXPORT_SYMBOL_GPL(__clk_determine_rate);\n\n/**\n * clk_hw_round_rate() - round the given rate for a hw clk\n * @hw: the hw clk for which we are rounding a rate\n * @rate: the rate which is to be rounded\n *\n * Takes in a rate as input and rounds it to a rate that the clk can actually\n * use.\n *\n * Context: prepare_lock must be held.\n *          For clk providers to call from within clk_ops such as .round_rate,\n *          .determine_rate.\n *\n * Return: returns rounded rate of hw clk if clk supports round_rate operation\n *         else returns the parent rate.\n */\nunsigned long clk_hw_round_rate(struct clk_hw *hw, unsigned long rate)\n{\n\tint ret;\n\tstruct clk_rate_request req;\n\n\tclk_core_get_boundaries(hw->core, &req.min_rate, &req.max_rate);\n\treq.rate = rate;\n\n\tret = clk_core_round_rate_nolock(hw->core, &req);\n\tif (ret)\n\t\treturn 0;\n\n\treturn req.rate;\n}\nEXPORT_SYMBOL_GPL(clk_hw_round_rate);\n\n/**\n * clk_round_rate - round the given rate for a clk\n * @clk: the clk for which we are rounding a rate\n * @rate: the rate which is to be rounded\n *\n * Takes in a rate as input and rounds it to a rate that the clk can actually\n * use which is then returned.  If clk doesn't support round_rate operation\n * then the parent rate is returned.\n */\nlong clk_round_rate(struct clk *clk, unsigned long rate)\n{\n\tstruct clk_rate_request req;\n\tint ret;\n\n\tif (!clk)\n\t\treturn 0;\n\n\tclk_prepare_lock();\n\n\tif (clk->exclusive_count)\n\t\tclk_core_rate_unprotect(clk->core);\n\n\tclk_core_get_boundaries(clk->core, &req.min_rate, &req.max_rate);\n\treq.rate = rate;\n\n\tret = clk_core_round_rate_nolock(clk->core, &req);\n\n\tif (clk->exclusive_count)\n\t\tclk_core_rate_protect(clk->core);\n\n\tclk_prepare_unlock();\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn req.rate;\n}\nEXPORT_SYMBOL_GPL(clk_round_rate);\n\n/**\n * __clk_notify - call clk notifier chain\n * @core: clk that is changing rate\n * @msg: clk notifier type (see include/linux/clk.h)\n * @old_rate: old clk rate\n * @new_rate: new clk rate\n *\n * Triggers a notifier call chain on the clk rate-change notification\n * for 'clk'.  Passes a pointer to the struct clk and the previous\n * and current rates to the notifier callback.  Intended to be called by\n * internal clock code only.  Returns NOTIFY_DONE from the last driver\n * called if all went well, or NOTIFY_STOP or NOTIFY_BAD immediately if\n * a driver returns that.\n */\nstatic int __clk_notify(struct clk_core *core, unsigned long msg,\n\t\tunsigned long old_rate, unsigned long new_rate)\n{\n\tstruct clk_notifier *cn;\n\tstruct clk_notifier_data cnd;\n\tint ret = NOTIFY_DONE;\n\n\tcnd.old_rate = old_rate;\n\tcnd.new_rate = new_rate;\n\n\tlist_for_each_entry(cn, &clk_notifier_list, node) {\n\t\tif (cn->clk->core == core) {\n\t\t\tcnd.clk = cn->clk;\n\t\t\tret = srcu_notifier_call_chain(&cn->notifier_head, msg,\n\t\t\t\t\t&cnd);\n\t\t\tif (ret & NOTIFY_STOP_MASK)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/**\n * __clk_recalc_accuracies\n * @core: first clk in the subtree\n *\n * Walks the subtree of clks starting with clk and recalculates accuracies as\n * it goes.  Note that if a clk does not implement the .recalc_accuracy\n * callback then it is assumed that the clock will take on the accuracy of its\n * parent.\n */\nstatic void __clk_recalc_accuracies(struct clk_core *core)\n{\n\tunsigned long parent_accuracy = 0;\n\tstruct clk_core *child;\n\n\tlockdep_assert_held(&prepare_lock);\n\n\tif (core->parent)\n\t\tparent_accuracy = core->parent->accuracy;\n\n\tif (core->ops->recalc_accuracy)\n\t\tcore->accuracy = core->ops->recalc_accuracy(core->hw,\n\t\t\t\t\t\t\t  parent_accuracy);\n\telse\n\t\tcore->accuracy = parent_accuracy;\n\n\thlist_for_each_entry(child, &core->children, child_node)\n\t\t__clk_recalc_accuracies(child);\n}\n\nstatic long clk_core_get_accuracy_recalc(struct clk_core *core)\n{\n\tif (core && (core->flags & CLK_GET_ACCURACY_NOCACHE))\n\t\t__clk_recalc_accuracies(core);\n\n\treturn clk_core_get_accuracy_no_lock(core);\n}\n\n/**\n * clk_get_accuracy - return the accuracy of clk\n * @clk: the clk whose accuracy is being returned\n *\n * Simply returns the cached accuracy of the clk, unless\n * CLK_GET_ACCURACY_NOCACHE flag is set, which means a recalc_rate will be\n * issued.\n * If clk is NULL then returns 0.\n */\nlong clk_get_accuracy(struct clk *clk)\n{\n\tlong accuracy;\n\n\tif (!clk)\n\t\treturn 0;\n\n\tclk_prepare_lock();\n\taccuracy = clk_core_get_accuracy_recalc(clk->core);\n\tclk_prepare_unlock();\n\n\treturn accuracy;\n}\nEXPORT_SYMBOL_GPL(clk_get_accuracy);\n\nstatic unsigned long clk_recalc(struct clk_core *core,\n\t\t\t\tunsigned long parent_rate)\n{\n\tunsigned long rate = parent_rate;\n\n\tif (core->ops->recalc_rate && !clk_pm_runtime_get(core)) {\n\t\trate = core->ops->recalc_rate(core->hw, parent_rate);\n\t\tclk_pm_runtime_put(core);\n\t}\n\treturn rate;\n}\n\n/**\n * __clk_recalc_rates\n * @core: first clk in the subtree\n * @msg: notification type (see include/linux/clk.h)\n *\n * Walks the subtree of clks starting with clk and recalculates rates as it\n * goes.  Note that if a clk does not implement the .recalc_rate callback then\n * it is assumed that the clock will take on the rate of its parent.\n *\n * clk_recalc_rates also propagates the POST_RATE_CHANGE notification,\n * if necessary.\n */\nstatic void __clk_recalc_rates(struct clk_core *core, unsigned long msg)\n{\n\tunsigned long old_rate;\n\tunsigned long parent_rate = 0;\n\tstruct clk_core *child;\n\n\tlockdep_assert_held(&prepare_lock);\n\n\told_rate = core->rate;\n\n\tif (core->parent)\n\t\tparent_rate = core->parent->rate;\n\n\tcore->rate = clk_recalc(core, parent_rate);\n\n\t/*\n\t * ignore NOTIFY_STOP and NOTIFY_BAD return values for POST_RATE_CHANGE\n\t * & ABORT_RATE_CHANGE notifiers\n\t */\n\tif (core->notifier_count && msg)\n\t\t__clk_notify(core, msg, old_rate, core->rate);\n\n\thlist_for_each_entry(child, &core->children, child_node)\n\t\t__clk_recalc_rates(child, msg);\n}\n\nstatic unsigned long clk_core_get_rate_recalc(struct clk_core *core)\n{\n\tif (core && (core->flags & CLK_GET_RATE_NOCACHE))\n\t\t__clk_recalc_rates(core, 0);\n\n\treturn clk_core_get_rate_nolock(core);\n}\n\n/**\n * clk_get_rate - return the rate of clk\n * @clk: the clk whose rate is being returned\n *\n * Simply returns the cached rate of the clk, unless CLK_GET_RATE_NOCACHE flag\n * is set, which means a recalc_rate will be issued.\n * If clk is NULL then returns 0.\n */\nunsigned long clk_get_rate(struct clk *clk)\n{\n\tunsigned long rate;\n\n\tif (!clk)\n\t\treturn 0;\n\n\tclk_prepare_lock();\n\trate = clk_core_get_rate_recalc(clk->core);\n\tclk_prepare_unlock();\n\n\treturn rate;\n}\nEXPORT_SYMBOL_GPL(clk_get_rate);\n\nstatic int clk_fetch_parent_index(struct clk_core *core,\n\t\t\t\t  struct clk_core *parent)\n{\n\tint i;\n\n\tif (!parent)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < core->num_parents; i++) {\n\t\t/* Found it first try! */\n\t\tif (core->parents[i].core == parent)\n\t\t\treturn i;\n\n\t\t/* Something else is here, so keep looking */\n\t\tif (core->parents[i].core)\n\t\t\tcontinue;\n\n\t\t/* Maybe core hasn't been cached but the hw is all we know? */\n\t\tif (core->parents[i].hw) {\n\t\t\tif (core->parents[i].hw == parent->hw)\n\t\t\t\tbreak;\n\n\t\t\t/* Didn't match, but we're expecting a clk_hw */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Maybe it hasn't been cached (clk_set_parent() path) */\n\t\tif (parent == clk_core_get(core, i))\n\t\t\tbreak;\n\n\t\t/* Fallback to comparing globally unique names */\n\t\tif (core->parents[i].name &&\n\t\t    !strcmp(parent->name, core->parents[i].name))\n\t\t\tbreak;\n\t}\n\n\tif (i == core->num_parents)\n\t\treturn -EINVAL;\n\n\tcore->parents[i].core = parent;\n\treturn i;\n}\n\n/**\n * clk_hw_get_parent_index - return the index of the parent clock\n * @hw: clk_hw associated with the clk being consumed\n *\n * Fetches and returns the index of parent clock. Returns -EINVAL if the given\n * clock does not have a current parent.\n */\nint clk_hw_get_parent_index(struct clk_hw *hw)\n{\n\tstruct clk_hw *parent = clk_hw_get_parent(hw);\n\n\tif (WARN_ON(parent == NULL))\n\t\treturn -EINVAL;\n\n\treturn clk_fetch_parent_index(hw->core, parent->core);\n}\nEXPORT_SYMBOL_GPL(clk_hw_get_parent_index);\n\n/*\n * Update the orphan status of @core and all its children.\n */\nstatic void clk_core_update_orphan_status(struct clk_core *core, bool is_orphan)\n{\n\tstruct clk_core *child;\n\n\tcore->orphan = is_orphan;\n\n\thlist_for_each_entry(child, &core->children, child_node)\n\t\tclk_core_update_orphan_status(child, is_orphan);\n}\n\nstatic void clk_reparent(struct clk_core *core, struct clk_core *new_parent)\n{\n\tbool was_orphan = core->orphan;\n\n\thlist_del(&core->child_node);\n\n\tif (new_parent) {\n\t\tbool becomes_orphan = new_parent->orphan;\n\n\t\t/* avoid duplicate POST_RATE_CHANGE notifications */\n\t\tif (new_parent->new_child == core)\n\t\t\tnew_parent->new_child = NULL;\n\n\t\thlist_add_head(&core->child_node, &new_parent->children);\n\n\t\tif (was_orphan != becomes_orphan)\n\t\t\tclk_core_update_orphan_status(core, becomes_orphan);\n\t} else {\n\t\thlist_add_head(&core->child_node, &clk_orphan_list);\n\t\tif (!was_orphan)\n\t\t\tclk_core_update_orphan_status(core, true);\n\t}\n\n\tcore->parent = new_parent;\n}\n\nstatic struct clk_core *__clk_set_parent_before(struct clk_core *core,\n\t\t\t\t\t   struct clk_core *parent)\n{\n\tunsigned long flags;\n\tstruct clk_core *old_parent = core->parent;\n\n\t/*\n\t * 1. enable parents for CLK_OPS_PARENT_ENABLE clock\n\t *\n\t * 2. Migrate prepare state between parents and prevent race with\n\t * clk_enable().\n\t *\n\t * If the clock is not prepared, then a race with\n\t * clk_enable/disable() is impossible since we already have the\n\t * prepare lock (future calls to clk_enable() need to be preceded by\n\t * a clk_prepare()).\n\t *\n\t * If the clock is prepared, migrate the prepared state to the new\n\t * parent and also protect against a race with clk_enable() by\n\t * forcing the clock and the new parent on.  This ensures that all\n\t * future calls to clk_enable() are practically NOPs with respect to\n\t * hardware and software states.\n\t *\n\t * See also: Comment for clk_set_parent() below.\n\t */\n\n\t/* enable old_parent & parent if CLK_OPS_PARENT_ENABLE is set */\n\tif (core->flags & CLK_OPS_PARENT_ENABLE) {\n\t\tclk_core_prepare_enable(old_parent);\n\t\tclk_core_prepare_enable(parent);\n\t}\n\n\t/* migrate prepare count if > 0 */\n\tif (core->prepare_count) {\n\t\tclk_core_prepare_enable(parent);\n\t\tclk_core_enable_lock(core);\n\t}\n\n\t/* update the clk tree topology */\n\tflags = clk_enable_lock();\n\tclk_reparent(core, parent);\n\tclk_enable_unlock(flags);\n\n\treturn old_parent;\n}\n\nstatic void __clk_set_parent_after(struct clk_core *core,\n\t\t\t\t   struct clk_core *parent,\n\t\t\t\t   struct clk_core *old_parent)\n{\n\t/*\n\t * Finish the migration of prepare state and undo the changes done\n\t * for preventing a race with clk_enable().\n\t */\n\tif (core->prepare_count) {\n\t\tclk_core_disable_lock(core);\n\t\tclk_core_disable_unprepare(old_parent);\n\t}\n\n\t/* re-balance ref counting if CLK_OPS_PARENT_ENABLE is set */\n\tif (core->flags & CLK_OPS_PARENT_ENABLE) {\n\t\tclk_core_disable_unprepare(parent);\n\t\tclk_core_disable_unprepare(old_parent);\n\t}\n}\n\nstatic int __clk_set_parent(struct clk_core *core, struct clk_core *parent,\n\t\t\t    u8 p_index)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\tstruct clk_core *old_parent;\n\n\told_parent = __clk_set_parent_before(core, parent);\n\n\ttrace_clk_set_parent(core, parent);\n\n\t/* change clock input source */\n\tif (parent && core->ops->set_parent)\n\t\tret = core->ops->set_parent(core->hw, p_index);\n\n\ttrace_clk_set_parent_complete(core, parent);\n\n\tif (ret) {\n\t\tflags = clk_enable_lock();\n\t\tclk_reparent(core, old_parent);\n\t\tclk_enable_unlock(flags);\n\t\t__clk_set_parent_after(core, old_parent, parent);\n\n\t\treturn ret;\n\t}\n\n\t__clk_set_parent_after(core, parent, old_parent);\n\n\treturn 0;\n}\n\n/**\n * __clk_speculate_rates\n * @core: first clk in the subtree\n * @parent_rate: the \"future\" rate of clk's parent\n *\n * Walks the subtree of clks starting with clk, speculating rates as it\n * goes and firing off PRE_RATE_CHANGE notifications as necessary.\n *\n * Unlike clk_recalc_rates, clk_speculate_rates exists only for sending\n * pre-rate change notifications and returns early if no clks in the\n * subtree have subscribed to the notifications.  Note that if a clk does not\n * implement the .recalc_rate callback then it is assumed that the clock will\n * take on the rate of its parent.\n */\nstatic int __clk_speculate_rates(struct clk_core *core,\n\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_core *child;\n\tunsigned long new_rate;\n\tint ret = NOTIFY_DONE;\n\n\tlockdep_assert_held(&prepare_lock);\n\n\tnew_rate = clk_recalc(core, parent_rate);\n\n\t/* abort rate change if a driver returns NOTIFY_BAD or NOTIFY_STOP */\n\tif (core->notifier_count)\n\t\tret = __clk_notify(core, PRE_RATE_CHANGE, core->rate, new_rate);\n\n\tif (ret & NOTIFY_STOP_MASK) {\n\t\tpr_debug(\"%s: clk notifier callback for clock %s aborted with error %d\\n\",\n\t\t\t\t__func__, core->name, ret);\n\t\tgoto out;\n\t}\n\n\thlist_for_each_entry(child, &core->children, child_node) {\n\t\tret = __clk_speculate_rates(child, new_rate);\n\t\tif (ret & NOTIFY_STOP_MASK)\n\t\t\tbreak;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic void clk_calc_subtree(struct clk_core *core, unsigned long new_rate,\n\t\t\t     struct clk_core *new_parent, u8 p_index)\n{\n\tstruct clk_core *child;\n\n\tcore->new_rate = new_rate;\n\tcore->new_parent = new_parent;\n\tcore->new_parent_index = p_index;\n\t/* include clk in new parent's PRE_RATE_CHANGE notifications */\n\tcore->new_child = NULL;\n\tif (new_parent && new_parent != core->parent)\n\t\tnew_parent->new_child = core;\n\n\thlist_for_each_entry(child, &core->children, child_node) {\n\t\tchild->new_rate = clk_recalc(child, new_rate);\n\t\tclk_calc_subtree(child, child->new_rate, NULL, 0);\n\t}\n}\n\n/*\n * calculate the new rates returning the topmost clock that has to be\n * changed.\n */\nstatic struct clk_core *clk_calc_new_rates(struct clk_core *core,\n\t\t\t\t\t   unsigned long rate)\n{\n\tstruct clk_core *top = core;\n\tstruct clk_core *old_parent, *parent;\n\tunsigned long best_parent_rate = 0;\n\tunsigned long new_rate;\n\tunsigned long min_rate;\n\tunsigned long max_rate;\n\tint p_index = 0;\n\tlong ret;\n\n\t/* sanity */\n\tif (IS_ERR_OR_NULL(core))\n\t\treturn NULL;\n\n\t/* save parent rate, if it exists */\n\tparent = old_parent = core->parent;\n\tif (parent)\n\t\tbest_parent_rate = parent->rate;\n\n\tclk_core_get_boundaries(core, &min_rate, &max_rate);\n\n\t/* find the closest rate and parent clk/rate */\n\tif (clk_core_can_round(core)) {\n\t\tstruct clk_rate_request req;\n\n\t\treq.rate = rate;\n\t\treq.min_rate = min_rate;\n\t\treq.max_rate = max_rate;\n\n\t\tclk_core_init_rate_req(core, &req);\n\n\t\tret = clk_core_determine_round_nolock(core, &req);\n\t\tif (ret < 0)\n\t\t\treturn NULL;\n\n\t\tbest_parent_rate = req.best_parent_rate;\n\t\tnew_rate = req.rate;\n\t\tparent = req.best_parent_hw ? req.best_parent_hw->core : NULL;\n\n\t\tif (new_rate < min_rate || new_rate > max_rate)\n\t\t\treturn NULL;\n\t} else if (!parent || !(core->flags & CLK_SET_RATE_PARENT)) {\n\t\t/* pass-through clock without adjustable parent */\n\t\tcore->new_rate = core->rate;\n\t\treturn NULL;\n\t} else {\n\t\t/* pass-through clock with adjustable parent */\n\t\ttop = clk_calc_new_rates(parent, rate);\n\t\tnew_rate = parent->new_rate;\n\t\tgoto out;\n\t}\n\n\t/* some clocks must be gated to change parent */\n\tif (parent != old_parent &&\n\t    (core->flags & CLK_SET_PARENT_GATE) && core->prepare_count) {\n\t\tpr_debug(\"%s: %s not gated but wants to reparent\\n\",\n\t\t\t __func__, core->name);\n\t\treturn NULL;\n\t}\n\n\t/* try finding the new parent index */\n\tif (parent && core->num_parents > 1) {\n\t\tp_index = clk_fetch_parent_index(core, parent);\n\t\tif (p_index < 0) {\n\t\t\tpr_debug(\"%s: clk %s can not be parent of clk %s\\n\",\n\t\t\t\t __func__, parent->name, core->name);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif ((core->flags & CLK_SET_RATE_PARENT) && parent &&\n\t    best_parent_rate != parent->rate)\n\t\ttop = clk_calc_new_rates(parent, best_parent_rate);\n\nout:\n\tclk_calc_subtree(core, new_rate, parent, p_index);\n\n\treturn top;\n}\n\n/*\n * Notify about rate changes in a subtree. Always walk down the whole tree\n * so that in case of an error we can walk down the whole tree again and\n * abort the change.\n */\nstatic struct clk_core *clk_propagate_rate_change(struct clk_core *core,\n\t\t\t\t\t\t  unsigned long event)\n{\n\tstruct clk_core *child, *tmp_clk, *fail_clk = NULL;\n\tint ret = NOTIFY_DONE;\n\n\tif (core->rate == core->new_rate)\n\t\treturn NULL;\n\n\tif (core->notifier_count) {\n\t\tret = __clk_notify(core, event, core->rate, core->new_rate);\n\t\tif (ret & NOTIFY_STOP_MASK)\n\t\t\tfail_clk = core;\n\t}\n\n\thlist_for_each_entry(child, &core->children, child_node) {\n\t\t/* Skip children who will be reparented to another clock */\n\t\tif (child->new_parent && child->new_parent != core)\n\t\t\tcontinue;\n\t\ttmp_clk = clk_propagate_rate_change(child, event);\n\t\tif (tmp_clk)\n\t\t\tfail_clk = tmp_clk;\n\t}\n\n\t/* handle the new child who might not be in core->children yet */\n\tif (core->new_child) {\n\t\ttmp_clk = clk_propagate_rate_change(core->new_child, event);\n\t\tif (tmp_clk)\n\t\t\tfail_clk = tmp_clk;\n\t}\n\n\treturn fail_clk;\n}\n\n/*\n * walk down a subtree and set the new rates notifying the rate\n * change on the way\n */\nstatic void clk_change_rate(struct clk_core *core)\n{\n\tstruct clk_core *child;\n\tstruct hlist_node *tmp;\n\tunsigned long old_rate;\n\tunsigned long best_parent_rate = 0;\n\tbool skip_set_rate = false;\n\tstruct clk_core *old_parent;\n\tstruct clk_core *parent = NULL;\n\n\told_rate = core->rate;\n\n\tif (core->new_parent) {\n\t\tparent = core->new_parent;\n\t\tbest_parent_rate = core->new_parent->rate;\n\t} else if (core->parent) {\n\t\tparent = core->parent;\n\t\tbest_parent_rate = core->parent->rate;\n\t}\n\n\tif (clk_pm_runtime_get(core))\n\t\treturn;\n\n\tif (core->flags & CLK_SET_RATE_UNGATE) {\n\t\tunsigned long flags;\n\n\t\tclk_core_prepare(core);\n\t\tflags = clk_enable_lock();\n\t\tclk_core_enable(core);\n\t\tclk_enable_unlock(flags);\n\t}\n\n\tif (core->new_parent && core->new_parent != core->parent) {\n\t\told_parent = __clk_set_parent_before(core, core->new_parent);\n\t\ttrace_clk_set_parent(core, core->new_parent);\n\n\t\tif (core->ops->set_rate_and_parent) {\n\t\t\tskip_set_rate = true;\n\t\t\tcore->ops->set_rate_and_parent(core->hw, core->new_rate,\n\t\t\t\t\tbest_parent_rate,\n\t\t\t\t\tcore->new_parent_index);\n\t\t} else if (core->ops->set_parent) {\n\t\t\tcore->ops->set_parent(core->hw, core->new_parent_index);\n\t\t}\n\n\t\ttrace_clk_set_parent_complete(core, core->new_parent);\n\t\t__clk_set_parent_after(core, core->new_parent, old_parent);\n\t}\n\n\tif (core->flags & CLK_OPS_PARENT_ENABLE)\n\t\tclk_core_prepare_enable(parent);\n\n\ttrace_clk_set_rate(core, core->new_rate);\n\n\tif (!skip_set_rate && core->ops->set_rate)\n\t\tcore->ops->set_rate(core->hw, core->new_rate, best_parent_rate);\n\n\ttrace_clk_set_rate_complete(core, core->new_rate);\n\n\tcore->rate = clk_recalc(core, best_parent_rate);\n\n\tif (core->flags & CLK_SET_RATE_UNGATE) {\n\t\tunsigned long flags;\n\n\t\tflags = clk_enable_lock();\n\t\tclk_core_disable(core);\n\t\tclk_enable_unlock(flags);\n\t\tclk_core_unprepare(core);\n\t}\n\n\tif (core->flags & CLK_OPS_PARENT_ENABLE)\n\t\tclk_core_disable_unprepare(parent);\n\n\tif (core->notifier_count && old_rate != core->rate)\n\t\t__clk_notify(core, POST_RATE_CHANGE, old_rate, core->rate);\n\n\tif (core->flags & CLK_RECALC_NEW_RATES)\n\t\t(void)clk_calc_new_rates(core, core->new_rate);\n\n\t/*\n\t * Use safe iteration, as change_rate can actually swap parents\n\t * for certain clock types.\n\t */\n\thlist_for_each_entry_safe(child, tmp, &core->children, child_node) {\n\t\t/* Skip children who will be reparented to another clock */\n\t\tif (child->new_parent && child->new_parent != core)\n\t\t\tcontinue;\n\t\tclk_change_rate(child);\n\t}\n\n\t/* handle the new child who might not be in core->children yet */\n\tif (core->new_child)\n\t\tclk_change_rate(core->new_child);\n\n\tclk_pm_runtime_put(core);\n}\n\nstatic unsigned long clk_core_req_round_rate_nolock(struct clk_core *core,\n\t\t\t\t\t\t     unsigned long req_rate)\n{\n\tint ret, cnt;\n\tstruct clk_rate_request req;\n\n\tlockdep_assert_held(&prepare_lock);\n\n\tif (!core)\n\t\treturn 0;\n\n\t/* simulate what the rate would be if it could be freely set */\n\tcnt = clk_core_rate_nuke_protect(core);\n\tif (cnt < 0)\n\t\treturn cnt;\n\n\tclk_core_get_boundaries(core, &req.min_rate, &req.max_rate);\n\treq.rate = req_rate;\n\n\tret = clk_core_round_rate_nolock(core, &req);\n\n\t/* restore the protection */\n\tclk_core_rate_restore_protect(core, cnt);\n\n\treturn ret ? 0 : req.rate;\n}\n\nstatic int clk_core_set_rate_nolock(struct clk_core *core,\n\t\t\t\t    unsigned long req_rate)\n{\n\tstruct clk_core *top, *fail_clk;\n\tunsigned long rate;\n\tint ret = 0;\n\n\tif (!core)\n\t\treturn 0;\n\n\trate = clk_core_req_round_rate_nolock(core, req_rate);\n\n\t/* bail early if nothing to do */\n\tif (rate == clk_core_get_rate_nolock(core))\n\t\treturn 0;\n\n\t/* fail on a direct rate set of a protected provider */\n\tif (clk_core_rate_is_protected(core))\n\t\treturn -EBUSY;\n\n\t/* calculate new rates and get the topmost changed clock */\n\ttop = clk_calc_new_rates(core, req_rate);\n\tif (!top)\n\t\treturn -EINVAL;\n\n\tret = clk_pm_runtime_get(core);\n\tif (ret)\n\t\treturn ret;\n\n\t/* notify that we are about to change rates */\n\tfail_clk = clk_propagate_rate_change(top, PRE_RATE_CHANGE);\n\tif (fail_clk) {\n\t\tpr_debug(\"%s: failed to set %s rate\\n\", __func__,\n\t\t\t\tfail_clk->name);\n\t\tclk_propagate_rate_change(top, ABORT_RATE_CHANGE);\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\t/* change the rates */\n\tclk_change_rate(top);\n\n\tcore->req_rate = req_rate;\nerr:\n\tclk_pm_runtime_put(core);\n\n\treturn ret;\n}\n\n/**\n * clk_set_rate - specify a new rate for clk\n * @clk: the clk whose rate is being changed\n * @rate: the new rate for clk\n *\n * In the simplest case clk_set_rate will only adjust the rate of clk.\n *\n * Setting the CLK_SET_RATE_PARENT flag allows the rate change operation to\n * propagate up to clk's parent; whether or not this happens depends on the\n * outcome of clk's .round_rate implementation.  If *parent_rate is unchanged\n * after calling .round_rate then upstream parent propagation is ignored.  If\n * *parent_rate comes back with a new rate for clk's parent then we propagate\n * up to clk's parent and set its rate.  Upward propagation will continue\n * until either a clk does not support the CLK_SET_RATE_PARENT flag or\n * .round_rate stops requesting changes to clk's parent_rate.\n *\n * Rate changes are accomplished via tree traversal that also recalculates the\n * rates for the clocks and fires off POST_RATE_CHANGE notifiers.\n *\n * Returns 0 on success, -EERROR otherwise.\n */\nint clk_set_rate(struct clk *clk, unsigned long rate)\n{\n\tint ret;\n\n\tif (!clk)\n\t\treturn 0;\n\n\t/* prevent racing with updates to the clock topology */\n\tclk_prepare_lock();\n\n\tif (clk->exclusive_count)\n\t\tclk_core_rate_unprotect(clk->core);\n\n\tret = clk_core_set_rate_nolock(clk->core, rate);\n\n\tif (clk->exclusive_count)\n\t\tclk_core_rate_protect(clk->core);\n\n\tclk_prepare_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(clk_set_rate);\n\n/**\n * clk_set_rate_exclusive - specify a new rate and get exclusive control\n * @clk: the clk whose rate is being changed\n * @rate: the new rate for clk\n *\n * This is a combination of clk_set_rate() and clk_rate_exclusive_get()\n * within a critical section\n *\n * This can be used initially to ensure that at least 1 consumer is\n * satisfied when several consumers are competing for exclusivity over the\n * same clock provider.\n *\n * The exclusivity is not applied if setting the rate failed.\n *\n * Calls to clk_rate_exclusive_get() should be balanced with calls to\n * clk_rate_exclusive_put().\n *\n * Returns 0 on success, -EERROR otherwise.\n */\nint clk_set_rate_exclusive(struct clk *clk, unsigned long rate)\n{\n\tint ret;\n\n\tif (!clk)\n\t\treturn 0;\n\n\t/* prevent racing with updates to the clock topology */\n\tclk_prepare_lock();\n\n\t/*\n\t * The temporary protection removal is not here, on purpose\n\t * This function is meant to be used instead of clk_rate_protect,\n\t * so before the consumer code path protect the clock provider\n\t */\n\n\tret = clk_core_set_rate_nolock(clk->core, rate);\n\tif (!ret) {\n\t\tclk_core_rate_protect(clk->core);\n\t\tclk->exclusive_count++;\n\t}\n\n\tclk_prepare_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(clk_set_rate_exclusive);\n\n/**\n * clk_set_rate_range - set a rate range for a clock source\n * @clk: clock source\n * @min: desired minimum clock rate in Hz, inclusive\n * @max: desired maximum clock rate in Hz, inclusive\n *\n * Returns success (0) or negative errno.\n */\nint clk_set_rate_range(struct clk *clk, unsigned long min, unsigned long max)\n{\n\tint ret = 0;\n\tunsigned long old_min, old_max, rate;\n\n\tif (!clk)\n\t\treturn 0;\n\n\ttrace_clk_set_rate_range(clk->core, min, max);\n\n\tif (min > max) {\n\t\tpr_err(\"%s: clk %s dev %s con %s: invalid range [%lu, %lu]\\n\",\n\t\t       __func__, clk->core->name, clk->dev_id, clk->con_id,\n\t\t       min, max);\n\t\treturn -EINVAL;\n\t}\n\n\tclk_prepare_lock();\n\n\tif (clk->exclusive_count)\n\t\tclk_core_rate_unprotect(clk->core);\n\n\t/* Save the current values in case we need to rollback the change */\n\told_min = clk->min_rate;\n\told_max = clk->max_rate;\n\tclk->min_rate = min;\n\tclk->max_rate = max;\n\n\trate = clk_core_get_rate_nolock(clk->core);\n\tif (rate < min || rate > max) {\n\t\t/*\n\t\t * FIXME:\n\t\t * We are in bit of trouble here, current rate is outside the\n\t\t * the requested range. We are going try to request appropriate\n\t\t * range boundary but there is a catch. It may fail for the\n\t\t * usual reason (clock broken, clock protected, etc) but also\n\t\t * because:\n\t\t * - round_rate() was not favorable and fell on the wrong\n\t\t *   side of the boundary\n\t\t * - the determine_rate() callback does not really check for\n\t\t *   this corner case when determining the rate\n\t\t */\n\n\t\tif (rate < min)\n\t\t\trate = min;\n\t\telse\n\t\t\trate = max;\n\n\t\tret = clk_core_set_rate_nolock(clk->core, rate);\n\t\tif (ret) {\n\t\t\t/* rollback the changes */\n\t\t\tclk->min_rate = old_min;\n\t\t\tclk->max_rate = old_max;\n\t\t}\n\t}\n\n\tif (clk->exclusive_count)\n\t\tclk_core_rate_protect(clk->core);\n\n\tclk_prepare_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(clk_set_rate_range);\n\n/**\n * clk_set_min_rate - set a minimum clock rate for a clock source\n * @clk: clock source\n * @rate: desired minimum clock rate in Hz, inclusive\n *\n * Returns success (0) or negative errno.\n */\nint clk_set_min_rate(struct clk *clk, unsigned long rate)\n{\n\tif (!clk)\n\t\treturn 0;\n\n\ttrace_clk_set_min_rate(clk->core, rate);\n\n\treturn clk_set_rate_range(clk, rate, clk->max_rate);\n}\nEXPORT_SYMBOL_GPL(clk_set_min_rate);\n\n/**\n * clk_set_max_rate - set a maximum clock rate for a clock source\n * @clk: clock source\n * @rate: desired maximum clock rate in Hz, inclusive\n *\n * Returns success (0) or negative errno.\n */\nint clk_set_max_rate(struct clk *clk, unsigned long rate)\n{\n\tif (!clk)\n\t\treturn 0;\n\n\ttrace_clk_set_max_rate(clk->core, rate);\n\n\treturn clk_set_rate_range(clk, clk->min_rate, rate);\n}\nEXPORT_SYMBOL_GPL(clk_set_max_rate);\n\n/**\n * clk_get_parent - return the parent of a clk\n * @clk: the clk whose parent gets returned\n *\n * Simply returns clk->parent.  Returns NULL if clk is NULL.\n */\nstruct clk *clk_get_parent(struct clk *clk)\n{\n\tstruct clk *parent;\n\n\tif (!clk)\n\t\treturn NULL;\n\n\tclk_prepare_lock();\n\t/* TODO: Create a per-user clk and change callers to call clk_put */\n\tparent = !clk->core->parent ? NULL : clk->core->parent->hw->clk;\n\tclk_prepare_unlock();\n\n\treturn parent;\n}\nEXPORT_SYMBOL_GPL(clk_get_parent);\n\nstatic struct clk_core *__clk_init_parent(struct clk_core *core)\n{\n\tu8 index = 0;\n\n\tif (core->num_parents > 1 && core->ops->get_parent)\n\t\tindex = core->ops->get_parent(core->hw);\n\n\treturn clk_core_get_parent_by_index(core, index);\n}\n\nstatic void clk_core_reparent(struct clk_core *core,\n\t\t\t\t  struct clk_core *new_parent)\n{\n\tclk_reparent(core, new_parent);\n\t__clk_recalc_accuracies(core);\n\t__clk_recalc_rates(core, POST_RATE_CHANGE);\n}\n\nvoid clk_hw_reparent(struct clk_hw *hw, struct clk_hw *new_parent)\n{\n\tif (!hw)\n\t\treturn;\n\n\tclk_core_reparent(hw->core, !new_parent ? NULL : new_parent->core);\n}\n\n/**\n * clk_has_parent - check if a clock is a possible parent for another\n * @clk: clock source\n * @parent: parent clock source\n *\n * This function can be used in drivers that need to check that a clock can be\n * the parent of another without actually changing the parent.\n *\n * Returns true if @parent is a possible parent for @clk, false otherwise.\n */\nbool clk_has_parent(struct clk *clk, struct clk *parent)\n{\n\tstruct clk_core *core, *parent_core;\n\tint i;\n\n\t/* NULL clocks should be nops, so return success if either is NULL. */\n\tif (!clk || !parent)\n\t\treturn true;\n\n\tcore = clk->core;\n\tparent_core = parent->core;\n\n\t/* Optimize for the case where the parent is already the parent. */\n\tif (core->parent == parent_core)\n\t\treturn true;\n\n\tfor (i = 0; i < core->num_parents; i++)\n\t\tif (!strcmp(core->parents[i].name, parent_core->name))\n\t\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(clk_has_parent);\n\nstatic int clk_core_set_parent_nolock(struct clk_core *core,\n\t\t\t\t      struct clk_core *parent)\n{\n\tint ret = 0;\n\tint p_index = 0;\n\tunsigned long p_rate = 0;\n\n\tlockdep_assert_held(&prepare_lock);\n\n\tif (!core)\n\t\treturn 0;\n\n\tif (core->parent == parent)\n\t\treturn 0;\n\n\t/* verify ops for multi-parent clks */\n\tif (core->num_parents > 1 && !core->ops->set_parent)\n\t\treturn -EPERM;\n\n\t/* check that we are allowed to re-parent if the clock is in use */\n\tif ((core->flags & CLK_SET_PARENT_GATE) && core->prepare_count)\n\t\treturn -EBUSY;\n\n\tif (clk_core_rate_is_protected(core))\n\t\treturn -EBUSY;\n\n\t/* try finding the new parent index */\n\tif (parent) {\n\t\tp_index = clk_fetch_parent_index(core, parent);\n\t\tif (p_index < 0) {\n\t\t\tpr_debug(\"%s: clk %s can not be parent of clk %s\\n\",\n\t\t\t\t\t__func__, parent->name, core->name);\n\t\t\treturn p_index;\n\t\t}\n\t\tp_rate = parent->rate;\n\t}\n\n\tret = clk_pm_runtime_get(core);\n\tif (ret)\n\t\treturn ret;\n\n\t/* propagate PRE_RATE_CHANGE notifications */\n\tret = __clk_speculate_rates(core, p_rate);\n\n\t/* abort if a driver objects */\n\tif (ret & NOTIFY_STOP_MASK)\n\t\tgoto runtime_put;\n\n\t/* do the re-parent */\n\tret = __clk_set_parent(core, parent, p_index);\n\n\t/* propagate rate an accuracy recalculation accordingly */\n\tif (ret) {\n\t\t__clk_recalc_rates(core, ABORT_RATE_CHANGE);\n\t} else {\n\t\t__clk_recalc_rates(core, POST_RATE_CHANGE);\n\t\t__clk_recalc_accuracies(core);\n\t}\n\nruntime_put:\n\tclk_pm_runtime_put(core);\n\n\treturn ret;\n}\n\nint clk_hw_set_parent(struct clk_hw *hw, struct clk_hw *parent)\n{\n\treturn clk_core_set_parent_nolock(hw->core, parent->core);\n}\nEXPORT_SYMBOL_GPL(clk_hw_set_parent);\n\n/**\n * clk_set_parent - switch the parent of a mux clk\n * @clk: the mux clk whose input we are switching\n * @parent: the new input to clk\n *\n * Re-parent clk to use parent as its new input source.  If clk is in\n * prepared state, the clk will get enabled for the duration of this call. If\n * that's not acceptable for a specific clk (Eg: the consumer can't handle\n * that, the reparenting is glitchy in hardware, etc), use the\n * CLK_SET_PARENT_GATE flag to allow reparenting only when clk is unprepared.\n *\n * After successfully changing clk's parent clk_set_parent will update the\n * clk topology, sysfs topology and propagate rate recalculation via\n * __clk_recalc_rates.\n *\n * Returns 0 on success, -EERROR otherwise.\n */\nint clk_set_parent(struct clk *clk, struct clk *parent)\n{\n\tint ret;\n\n\tif (!clk)\n\t\treturn 0;\n\n\tclk_prepare_lock();\n\n\tif (clk->exclusive_count)\n\t\tclk_core_rate_unprotect(clk->core);\n\n\tret = clk_core_set_parent_nolock(clk->core,\n\t\t\t\t\t parent ? parent->core : NULL);\n\n\tif (clk->exclusive_count)\n\t\tclk_core_rate_protect(clk->core);\n\n\tclk_prepare_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(clk_set_parent);\n\nstatic int clk_core_set_phase_nolock(struct clk_core *core, int degrees)\n{\n\tint ret = -EINVAL;\n\n\tlockdep_assert_held(&prepare_lock);\n\n\tif (!core)\n\t\treturn 0;\n\n\tif (clk_core_rate_is_protected(core))\n\t\treturn -EBUSY;\n\n\ttrace_clk_set_phase(core, degrees);\n\n\tif (core->ops->set_phase) {\n\t\tret = core->ops->set_phase(core->hw, degrees);\n\t\tif (!ret)\n\t\t\tcore->phase = degrees;\n\t}\n\n\ttrace_clk_set_phase_complete(core, degrees);\n\n\treturn ret;\n}\n\n/**\n * clk_set_phase - adjust the phase shift of a clock signal\n * @clk: clock signal source\n * @degrees: number of degrees the signal is shifted\n *\n * Shifts the phase of a clock signal by the specified\n * degrees. Returns 0 on success, -EERROR otherwise.\n *\n * This function makes no distinction about the input or reference\n * signal that we adjust the clock signal phase against. For example\n * phase locked-loop clock signal generators we may shift phase with\n * respect to feedback clock signal input, but for other cases the\n * clock phase may be shifted with respect to some other, unspecified\n * signal.\n *\n * Additionally the concept of phase shift does not propagate through\n * the clock tree hierarchy, which sets it apart from clock rates and\n * clock accuracy. A parent clock phase attribute does not have an\n * impact on the phase attribute of a child clock.\n */\nint clk_set_phase(struct clk *clk, int degrees)\n{\n\tint ret;\n\n\tif (!clk)\n\t\treturn 0;\n\n\t/* sanity check degrees */\n\tdegrees %= 360;\n\tif (degrees < 0)\n\t\tdegrees += 360;\n\n\tclk_prepare_lock();\n\n\tif (clk->exclusive_count)\n\t\tclk_core_rate_unprotect(clk->core);\n\n\tret = clk_core_set_phase_nolock(clk->core, degrees);\n\n\tif (clk->exclusive_count)\n\t\tclk_core_rate_protect(clk->core);\n\n\tclk_prepare_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(clk_set_phase);\n\nstatic int clk_core_get_phase(struct clk_core *core)\n{\n\tint ret;\n\n\tlockdep_assert_held(&prepare_lock);\n\tif (!core->ops->get_phase)\n\t\treturn 0;\n\n\t/* Always try to update cached phase if possible */\n\tret = core->ops->get_phase(core->hw);\n\tif (ret >= 0)\n\t\tcore->phase = ret;\n\n\treturn ret;\n}\n\n/**\n * clk_get_phase - return the phase shift of a clock signal\n * @clk: clock signal source\n *\n * Returns the phase shift of a clock node in degrees, otherwise returns\n * -EERROR.\n */\nint clk_get_phase(struct clk *clk)\n{\n\tint ret;\n\n\tif (!clk)\n\t\treturn 0;\n\n\tclk_prepare_lock();\n\tret = clk_core_get_phase(clk->core);\n\tclk_prepare_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(clk_get_phase);\n\nstatic void clk_core_reset_duty_cycle_nolock(struct clk_core *core)\n{\n\t/* Assume a default value of 50% */\n\tcore->duty.num = 1;\n\tcore->duty.den = 2;\n}\n\nstatic int clk_core_update_duty_cycle_parent_nolock(struct clk_core *core);\n\nstatic int clk_core_update_duty_cycle_nolock(struct clk_core *core)\n{\n\tstruct clk_duty *duty = &core->duty;\n\tint ret = 0;\n\n\tif (!core->ops->get_duty_cycle)\n\t\treturn clk_core_update_duty_cycle_parent_nolock(core);\n\n\tret = core->ops->get_duty_cycle(core->hw, duty);\n\tif (ret)\n\t\tgoto reset;\n\n\t/* Don't trust the clock provider too much */\n\tif (duty->den == 0 || duty->num > duty->den) {\n\t\tret = -EINVAL;\n\t\tgoto reset;\n\t}\n\n\treturn 0;\n\nreset:\n\tclk_core_reset_duty_cycle_nolock(core);\n\treturn ret;\n}\n\nstatic int clk_core_update_duty_cycle_parent_nolock(struct clk_core *core)\n{\n\tint ret = 0;\n\n\tif (core->parent &&\n\t    core->flags & CLK_DUTY_CYCLE_PARENT) {\n\t\tret = clk_core_update_duty_cycle_nolock(core->parent);\n\t\tmemcpy(&core->duty, &core->parent->duty, sizeof(core->duty));\n\t} else {\n\t\tclk_core_reset_duty_cycle_nolock(core);\n\t}\n\n\treturn ret;\n}\n\nstatic int clk_core_set_duty_cycle_parent_nolock(struct clk_core *core,\n\t\t\t\t\t\t struct clk_duty *duty);\n\nstatic int clk_core_set_duty_cycle_nolock(struct clk_core *core,\n\t\t\t\t\t  struct clk_duty *duty)\n{\n\tint ret;\n\n\tlockdep_assert_held(&prepare_lock);\n\n\tif (clk_core_rate_is_protected(core))\n\t\treturn -EBUSY;\n\n\ttrace_clk_set_duty_cycle(core, duty);\n\n\tif (!core->ops->set_duty_cycle)\n\t\treturn clk_core_set_duty_cycle_parent_nolock(core, duty);\n\n\tret = core->ops->set_duty_cycle(core->hw, duty);\n\tif (!ret)\n\t\tmemcpy(&core->duty, duty, sizeof(*duty));\n\n\ttrace_clk_set_duty_cycle_complete(core, duty);\n\n\treturn ret;\n}\n\nstatic int clk_core_set_duty_cycle_parent_nolock(struct clk_core *core,\n\t\t\t\t\t\t struct clk_duty *duty)\n{\n\tint ret = 0;\n\n\tif (core->parent &&\n\t    core->flags & (CLK_DUTY_CYCLE_PARENT | CLK_SET_RATE_PARENT)) {\n\t\tret = clk_core_set_duty_cycle_nolock(core->parent, duty);\n\t\tmemcpy(&core->duty, &core->parent->duty, sizeof(core->duty));\n\t}\n\n\treturn ret;\n}\n\n/**\n * clk_set_duty_cycle - adjust the duty cycle ratio of a clock signal\n * @clk: clock signal source\n * @num: numerator of the duty cycle ratio to be applied\n * @den: denominator of the duty cycle ratio to be applied\n *\n * Apply the duty cycle ratio if the ratio is valid and the clock can\n * perform this operation\n *\n * Returns (0) on success, a negative errno otherwise.\n */\nint clk_set_duty_cycle(struct clk *clk, unsigned int num, unsigned int den)\n{\n\tint ret;\n\tstruct clk_duty duty;\n\n\tif (!clk)\n\t\treturn 0;\n\n\t/* sanity check the ratio */\n\tif (den == 0 || num > den)\n\t\treturn -EINVAL;\n\n\tduty.num = num;\n\tduty.den = den;\n\n\tclk_prepare_lock();\n\n\tif (clk->exclusive_count)\n\t\tclk_core_rate_unprotect(clk->core);\n\n\tret = clk_core_set_duty_cycle_nolock(clk->core, &duty);\n\n\tif (clk->exclusive_count)\n\t\tclk_core_rate_protect(clk->core);\n\n\tclk_prepare_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(clk_set_duty_cycle);\n\nstatic int clk_core_get_scaled_duty_cycle(struct clk_core *core,\n\t\t\t\t\t  unsigned int scale)\n{\n\tstruct clk_duty *duty = &core->duty;\n\tint ret;\n\n\tclk_prepare_lock();\n\n\tret = clk_core_update_duty_cycle_nolock(core);\n\tif (!ret)\n\t\tret = mult_frac(scale, duty->num, duty->den);\n\n\tclk_prepare_unlock();\n\n\treturn ret;\n}\n\n/**\n * clk_get_scaled_duty_cycle - return the duty cycle ratio of a clock signal\n * @clk: clock signal source\n * @scale: scaling factor to be applied to represent the ratio as an integer\n *\n * Returns the duty cycle ratio of a clock node multiplied by the provided\n * scaling factor, or negative errno on error.\n */\nint clk_get_scaled_duty_cycle(struct clk *clk, unsigned int scale)\n{\n\tif (!clk)\n\t\treturn 0;\n\n\treturn clk_core_get_scaled_duty_cycle(clk->core, scale);\n}\nEXPORT_SYMBOL_GPL(clk_get_scaled_duty_cycle);\n\n/**\n * clk_is_match - check if two clk's point to the same hardware clock\n * @p: clk compared against q\n * @q: clk compared against p\n *\n * Returns true if the two struct clk pointers both point to the same hardware\n * clock node. Put differently, returns true if struct clk *p and struct clk *q\n * share the same struct clk_core object.\n *\n * Returns false otherwise. Note that two NULL clks are treated as matching.\n */\nbool clk_is_match(const struct clk *p, const struct clk *q)\n{\n\t/* trivial case: identical struct clk's or both NULL */\n\tif (p == q)\n\t\treturn true;\n\n\t/* true if clk->core pointers match. Avoid dereferencing garbage */\n\tif (!IS_ERR_OR_NULL(p) && !IS_ERR_OR_NULL(q))\n\t\tif (p->core == q->core)\n\t\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(clk_is_match);\n\n/***        debugfs support        ***/\n\n#ifdef CONFIG_DEBUG_FS\n#include <linux/debugfs.h>\n\nstatic struct dentry *rootdir;\nstatic int inited = 0;\nstatic DEFINE_MUTEX(clk_debug_lock);\nstatic HLIST_HEAD(clk_debug_list);\n\nstatic struct hlist_head *orphan_list[] = {\n\t&clk_orphan_list,\n\tNULL,\n};\n\nstatic void clk_summary_show_one(struct seq_file *s, struct clk_core *c,\n\t\t\t\t int level)\n{\n\tint phase;\n\n\tseq_printf(s, \"%*s%-*s %7d %8d %8d %11lu %10lu \",\n\t\t   level * 3 + 1, \"\",\n\t\t   30 - level * 3, c->name,\n\t\t   c->enable_count, c->prepare_count, c->protect_count,\n\t\t   clk_core_get_rate_recalc(c),\n\t\t   clk_core_get_accuracy_recalc(c));\n\n\tphase = clk_core_get_phase(c);\n\tif (phase >= 0)\n\t\tseq_printf(s, \"%5d\", phase);\n\telse\n\t\tseq_puts(s, \"-----\");\n\n\tseq_printf(s, \" %6d\", clk_core_get_scaled_duty_cycle(c, 100000));\n\n\tif (c->ops->is_enabled)\n\t\tseq_printf(s, \" %9c\\n\", clk_core_is_enabled(c) ? 'Y' : 'N');\n\telse if (!c->ops->enable)\n\t\tseq_printf(s, \" %9c\\n\", 'Y');\n\telse\n\t\tseq_printf(s, \" %9c\\n\", '?');\n}\n\nstatic void clk_summary_show_subtree(struct seq_file *s, struct clk_core *c,\n\t\t\t\t     int level)\n{\n\tstruct clk_core *child;\n\n\tclk_summary_show_one(s, c, level);\n\n\thlist_for_each_entry(child, &c->children, child_node)\n\t\tclk_summary_show_subtree(s, child, level + 1);\n}\n\nstatic int clk_summary_show(struct seq_file *s, void *data)\n{\n\tstruct clk_core *c;\n\tstruct hlist_head **lists = (struct hlist_head **)s->private;\n\n\tseq_puts(s, \"                                 enable  prepare  protect                                duty  hardware\\n\");\n\tseq_puts(s, \"   clock                          count    count    count        rate   accuracy phase  cycle    enable\\n\");\n\tseq_puts(s, \"-------------------------------------------------------------------------------------------------------\\n\");\n\n\tclk_prepare_lock();\n\n\tfor (; *lists; lists++)\n\t\thlist_for_each_entry(c, *lists, child_node)\n\t\t\tclk_summary_show_subtree(s, c, 0);\n\n\tclk_prepare_unlock();\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(clk_summary);\n\nstatic void clk_dump_one(struct seq_file *s, struct clk_core *c, int level)\n{\n\tint phase;\n\tunsigned long min_rate, max_rate;\n\n\tclk_core_get_boundaries(c, &min_rate, &max_rate);\n\n\t/* This should be JSON format, i.e. elements separated with a comma */\n\tseq_printf(s, \"\\\"%s\\\": { \", c->name);\n\tseq_printf(s, \"\\\"enable_count\\\": %d,\", c->enable_count);\n\tseq_printf(s, \"\\\"prepare_count\\\": %d,\", c->prepare_count);\n\tseq_printf(s, \"\\\"protect_count\\\": %d,\", c->protect_count);\n\tseq_printf(s, \"\\\"rate\\\": %lu,\", clk_core_get_rate_recalc(c));\n\tseq_printf(s, \"\\\"min_rate\\\": %lu,\", min_rate);\n\tseq_printf(s, \"\\\"max_rate\\\": %lu,\", max_rate);\n\tseq_printf(s, \"\\\"accuracy\\\": %lu,\", clk_core_get_accuracy_recalc(c));\n\tphase = clk_core_get_phase(c);\n\tif (phase >= 0)\n\t\tseq_printf(s, \"\\\"phase\\\": %d,\", phase);\n\tseq_printf(s, \"\\\"duty_cycle\\\": %u\",\n\t\t   clk_core_get_scaled_duty_cycle(c, 100000));\n}\n\nstatic void clk_dump_subtree(struct seq_file *s, struct clk_core *c, int level)\n{\n\tstruct clk_core *child;\n\n\tclk_dump_one(s, c, level);\n\n\thlist_for_each_entry(child, &c->children, child_node) {\n\t\tseq_putc(s, ',');\n\t\tclk_dump_subtree(s, child, level + 1);\n\t}\n\n\tseq_putc(s, '}');\n}\n\nstatic int clk_dump_show(struct seq_file *s, void *data)\n{\n\tstruct clk_core *c;\n\tbool first_node = true;\n\tstruct hlist_head **lists = (struct hlist_head **)s->private;\n\n\tseq_putc(s, '{');\n\tclk_prepare_lock();\n\n\tfor (; *lists; lists++) {\n\t\thlist_for_each_entry(c, *lists, child_node) {\n\t\t\tif (!first_node)\n\t\t\t\tseq_putc(s, ',');\n\t\t\tfirst_node = false;\n\t\t\tclk_dump_subtree(s, c, 0);\n\t\t}\n\t}\n\n\tclk_prepare_unlock();\n\n\tseq_puts(s, \"}\\n\");\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(clk_dump);\n\n#undef CLOCK_ALLOW_WRITE_DEBUGFS\n#ifdef CLOCK_ALLOW_WRITE_DEBUGFS\n/*\n * This can be dangerous, therefore don't provide any real compile time\n * configuration option for this feature.\n * People who want to use this will need to modify the source code directly.\n */\nstatic int clk_rate_set(void *data, u64 val)\n{\n\tstruct clk_core *core = data;\n\tint ret;\n\n\tclk_prepare_lock();\n\tret = clk_core_set_rate_nolock(core, val);\n\tclk_prepare_unlock();\n\n\treturn ret;\n}\n\n#define clk_rate_mode\t0644\n\nstatic int clk_prepare_enable_set(void *data, u64 val)\n{\n\tstruct clk_core *core = data;\n\tint ret = 0;\n\n\tif (val)\n\t\tret = clk_prepare_enable(core->hw->clk);\n\telse\n\t\tclk_disable_unprepare(core->hw->clk);\n\n\treturn ret;\n}\n\nstatic int clk_prepare_enable_get(void *data, u64 *val)\n{\n\tstruct clk_core *core = data;\n\n\t*val = core->enable_count && core->prepare_count;\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(clk_prepare_enable_fops, clk_prepare_enable_get,\n\t\t\t clk_prepare_enable_set, \"%llu\\n\");\n\n#else\n#define clk_rate_set\tNULL\n#define clk_rate_mode\t0444\n#endif\n\nstatic int clk_rate_get(void *data, u64 *val)\n{\n\tstruct clk_core *core = data;\n\n\t*val = core->rate;\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(clk_rate_fops, clk_rate_get, clk_rate_set, \"%llu\\n\");\n\nstatic const struct {\n\tunsigned long flag;\n\tconst char *name;\n} clk_flags[] = {\n#define ENTRY(f) { f, #f }\n\tENTRY(CLK_SET_RATE_GATE),\n\tENTRY(CLK_SET_PARENT_GATE),\n\tENTRY(CLK_SET_RATE_PARENT),\n\tENTRY(CLK_IGNORE_UNUSED),\n\tENTRY(CLK_GET_RATE_NOCACHE),\n\tENTRY(CLK_SET_RATE_NO_REPARENT),\n\tENTRY(CLK_GET_ACCURACY_NOCACHE),\n\tENTRY(CLK_RECALC_NEW_RATES),\n\tENTRY(CLK_SET_RATE_UNGATE),\n\tENTRY(CLK_IS_CRITICAL),\n\tENTRY(CLK_OPS_PARENT_ENABLE),\n\tENTRY(CLK_DUTY_CYCLE_PARENT),\n#undef ENTRY\n};\n\nstatic int clk_flags_show(struct seq_file *s, void *data)\n{\n\tstruct clk_core *core = s->private;\n\tunsigned long flags = core->flags;\n\tunsigned int i;\n\n\tfor (i = 0; flags && i < ARRAY_SIZE(clk_flags); i++) {\n\t\tif (flags & clk_flags[i].flag) {\n\t\t\tseq_printf(s, \"%s\\n\", clk_flags[i].name);\n\t\t\tflags &= ~clk_flags[i].flag;\n\t\t}\n\t}\n\tif (flags) {\n\t\t/* Unknown flags */\n\t\tseq_printf(s, \"0x%lx\\n\", flags);\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(clk_flags);\n\nstatic void possible_parent_show(struct seq_file *s, struct clk_core *core,\n\t\t\t\t unsigned int i, char terminator)\n{\n\tstruct clk_core *parent;\n\n\t/*\n\t * Go through the following options to fetch a parent's name.\n\t *\n\t * 1. Fetch the registered parent clock and use its name\n\t * 2. Use the global (fallback) name if specified\n\t * 3. Use the local fw_name if provided\n\t * 4. Fetch parent clock's clock-output-name if DT index was set\n\t *\n\t * This may still fail in some cases, such as when the parent is\n\t * specified directly via a struct clk_hw pointer, but it isn't\n\t * registered (yet).\n\t */\n\tparent = clk_core_get_parent_by_index(core, i);\n\tif (parent)\n\t\tseq_puts(s, parent->name);\n\telse if (core->parents[i].name)\n\t\tseq_puts(s, core->parents[i].name);\n\telse if (core->parents[i].fw_name)\n\t\tseq_printf(s, \"<%s>(fw)\", core->parents[i].fw_name);\n\telse if (core->parents[i].index >= 0)\n\t\tseq_puts(s,\n\t\t\t of_clk_get_parent_name(core->of_node,\n\t\t\t\t\t\tcore->parents[i].index));\n\telse\n\t\tseq_puts(s, \"(missing)\");\n\n\tseq_putc(s, terminator);\n}\n\nstatic int possible_parents_show(struct seq_file *s, void *data)\n{\n\tstruct clk_core *core = s->private;\n\tint i;\n\n\tfor (i = 0; i < core->num_parents - 1; i++)\n\t\tpossible_parent_show(s, core, i, ' ');\n\n\tpossible_parent_show(s, core, i, '\\n');\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(possible_parents);\n\nstatic int current_parent_show(struct seq_file *s, void *data)\n{\n\tstruct clk_core *core = s->private;\n\n\tif (core->parent)\n\t\tseq_printf(s, \"%s\\n\", core->parent->name);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(current_parent);\n\nstatic int clk_duty_cycle_show(struct seq_file *s, void *data)\n{\n\tstruct clk_core *core = s->private;\n\tstruct clk_duty *duty = &core->duty;\n\n\tseq_printf(s, \"%u/%u\\n\", duty->num, duty->den);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(clk_duty_cycle);\n\nstatic int clk_min_rate_show(struct seq_file *s, void *data)\n{\n\tstruct clk_core *core = s->private;\n\tunsigned long min_rate, max_rate;\n\n\tclk_prepare_lock();\n\tclk_core_get_boundaries(core, &min_rate, &max_rate);\n\tclk_prepare_unlock();\n\tseq_printf(s, \"%lu\\n\", min_rate);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(clk_min_rate);\n\nstatic int clk_max_rate_show(struct seq_file *s, void *data)\n{\n\tstruct clk_core *core = s->private;\n\tunsigned long min_rate, max_rate;\n\n\tclk_prepare_lock();\n\tclk_core_get_boundaries(core, &min_rate, &max_rate);\n\tclk_prepare_unlock();\n\tseq_printf(s, \"%lu\\n\", max_rate);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(clk_max_rate);\n\nstatic void clk_debug_create_one(struct clk_core *core, struct dentry *pdentry)\n{\n\tstruct dentry *root;\n\n\tif (!core || !pdentry)\n\t\treturn;\n\n\troot = debugfs_create_dir(core->name, pdentry);\n\tcore->dentry = root;\n\n\tdebugfs_create_file(\"clk_rate\", clk_rate_mode, root, core,\n\t\t\t    &clk_rate_fops);\n\tdebugfs_create_file(\"clk_min_rate\", 0444, root, core, &clk_min_rate_fops);\n\tdebugfs_create_file(\"clk_max_rate\", 0444, root, core, &clk_max_rate_fops);\n\tdebugfs_create_ulong(\"clk_accuracy\", 0444, root, &core->accuracy);\n\tdebugfs_create_u32(\"clk_phase\", 0444, root, &core->phase);\n\tdebugfs_create_file(\"clk_flags\", 0444, root, core, &clk_flags_fops);\n\tdebugfs_create_u32(\"clk_prepare_count\", 0444, root, &core->prepare_count);\n\tdebugfs_create_u32(\"clk_enable_count\", 0444, root, &core->enable_count);\n\tdebugfs_create_u32(\"clk_protect_count\", 0444, root, &core->protect_count);\n\tdebugfs_create_u32(\"clk_notifier_count\", 0444, root, &core->notifier_count);\n\tdebugfs_create_file(\"clk_duty_cycle\", 0444, root, core,\n\t\t\t    &clk_duty_cycle_fops);\n#ifdef CLOCK_ALLOW_WRITE_DEBUGFS\n\tdebugfs_create_file(\"clk_prepare_enable\", 0644, root, core,\n\t\t\t    &clk_prepare_enable_fops);\n#endif\n\n\tif (core->num_parents > 0)\n\t\tdebugfs_create_file(\"clk_parent\", 0444, root, core,\n\t\t\t\t    &current_parent_fops);\n\n\tif (core->num_parents > 1)\n\t\tdebugfs_create_file(\"clk_possible_parents\", 0444, root, core,\n\t\t\t\t    &possible_parents_fops);\n\n\tif (core->ops->debug_init)\n\t\tcore->ops->debug_init(core->hw, core->dentry);\n}\n\n/**\n * clk_debug_register - add a clk node to the debugfs clk directory\n * @core: the clk being added to the debugfs clk directory\n *\n * Dynamically adds a clk to the debugfs clk directory if debugfs has been\n * initialized.  Otherwise it bails out early since the debugfs clk directory\n * will be created lazily by clk_debug_init as part of a late_initcall.\n */\nstatic void clk_debug_register(struct clk_core *core)\n{\n\tmutex_lock(&clk_debug_lock);\n\thlist_add_head(&core->debug_node, &clk_debug_list);\n\tif (inited)\n\t\tclk_debug_create_one(core, rootdir);\n\tmutex_unlock(&clk_debug_lock);\n}\n\n /**\n * clk_debug_unregister - remove a clk node from the debugfs clk directory\n * @core: the clk being removed from the debugfs clk directory\n *\n * Dynamically removes a clk and all its child nodes from the\n * debugfs clk directory if clk->dentry points to debugfs created by\n * clk_debug_register in __clk_core_init.\n */\nstatic void clk_debug_unregister(struct clk_core *core)\n{\n\tmutex_lock(&clk_debug_lock);\n\thlist_del_init(&core->debug_node);\n\tdebugfs_remove_recursive(core->dentry);\n\tcore->dentry = NULL;\n\tmutex_unlock(&clk_debug_lock);\n}\n\n/**\n * clk_debug_init - lazily populate the debugfs clk directory\n *\n * clks are often initialized very early during boot before memory can be\n * dynamically allocated and well before debugfs is setup. This function\n * populates the debugfs clk directory once at boot-time when we know that\n * debugfs is setup. It should only be called once at boot-time, all other clks\n * added dynamically will be done so with clk_debug_register.\n */\nstatic int __init clk_debug_init(void)\n{\n\tstruct clk_core *core;\n\n\trootdir = debugfs_create_dir(\"clk\", NULL);\n\n\tdebugfs_create_file(\"clk_summary\", 0444, rootdir, &all_lists,\n\t\t\t    &clk_summary_fops);\n\tdebugfs_create_file(\"clk_dump\", 0444, rootdir, &all_lists,\n\t\t\t    &clk_dump_fops);\n\tdebugfs_create_file(\"clk_orphan_summary\", 0444, rootdir, &orphan_list,\n\t\t\t    &clk_summary_fops);\n\tdebugfs_create_file(\"clk_orphan_dump\", 0444, rootdir, &orphan_list,\n\t\t\t    &clk_dump_fops);\n\n\tmutex_lock(&clk_debug_lock);\n\thlist_for_each_entry(core, &clk_debug_list, debug_node)\n\t\tclk_debug_create_one(core, rootdir);\n\n\tinited = 1;\n\tmutex_unlock(&clk_debug_lock);\n\n\treturn 0;\n}\nlate_initcall(clk_debug_init);\n#else\nstatic inline void clk_debug_register(struct clk_core *core) { }\nstatic inline void clk_debug_unregister(struct clk_core *core)\n{\n}\n#endif\n\nstatic void clk_core_reparent_orphans_nolock(void)\n{\n\tstruct clk_core *orphan;\n\tstruct hlist_node *tmp2;\n\n\t/*\n\t * walk the list of orphan clocks and reparent any that newly finds a\n\t * parent.\n\t */\n\thlist_for_each_entry_safe(orphan, tmp2, &clk_orphan_list, child_node) {\n\t\tstruct clk_core *parent = __clk_init_parent(orphan);\n\n\t\t/*\n\t\t * We need to use __clk_set_parent_before() and _after() to\n\t\t * to properly migrate any prepare/enable count of the orphan\n\t\t * clock. This is important for CLK_IS_CRITICAL clocks, which\n\t\t * are enabled during init but might not have a parent yet.\n\t\t */\n\t\tif (parent) {\n\t\t\t/* update the clk tree topology */\n\t\t\t__clk_set_parent_before(orphan, parent);\n\t\t\t__clk_set_parent_after(orphan, parent, NULL);\n\t\t\t__clk_recalc_accuracies(orphan);\n\t\t\t__clk_recalc_rates(orphan, 0);\n\t\t}\n\t}\n}\n\n/**\n * __clk_core_init - initialize the data structures in a struct clk_core\n * @core:\tclk_core being initialized\n *\n * Initializes the lists in struct clk_core, queries the hardware for the\n * parent and rate and sets them both.\n */\nstatic int __clk_core_init(struct clk_core *core)\n{\n\tint ret;\n\tstruct clk_core *parent;\n\tunsigned long rate;\n\tint phase;\n\n\tif (!core)\n\t\treturn -EINVAL;\n\n\tclk_prepare_lock();\n\n\tret = clk_pm_runtime_get(core);\n\tif (ret)\n\t\tgoto unlock;\n\n\t/* check to see if a clock with this name is already registered */\n\tif (clk_core_lookup(core->name)) {\n\t\tpr_debug(\"%s: clk %s already initialized\\n\",\n\t\t\t\t__func__, core->name);\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/* check that clk_ops are sane.  See Documentation/driver-api/clk.rst */\n\tif (core->ops->set_rate &&\n\t    !((core->ops->round_rate || core->ops->determine_rate) &&\n\t      core->ops->recalc_rate)) {\n\t\tpr_err(\"%s: %s must implement .round_rate or .determine_rate in addition to .recalc_rate\\n\",\n\t\t       __func__, core->name);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (core->ops->set_parent && !core->ops->get_parent) {\n\t\tpr_err(\"%s: %s must implement .get_parent & .set_parent\\n\",\n\t\t       __func__, core->name);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (core->num_parents > 1 && !core->ops->get_parent) {\n\t\tpr_err(\"%s: %s must implement .get_parent as it has multi parents\\n\",\n\t\t       __func__, core->name);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (core->ops->set_rate_and_parent &&\n\t\t\t!(core->ops->set_parent && core->ops->set_rate)) {\n\t\tpr_err(\"%s: %s must implement .set_parent & .set_rate\\n\",\n\t\t\t\t__func__, core->name);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * optional platform-specific magic\n\t *\n\t * The .init callback is not used by any of the basic clock types, but\n\t * exists for weird hardware that must perform initialization magic for\n\t * CCF to get an accurate view of clock for any other callbacks. It may\n\t * also be used needs to perform dynamic allocations. Such allocation\n\t * must be freed in the terminate() callback.\n\t * This callback shall not be used to initialize the parameters state,\n\t * such as rate, parent, etc ...\n\t *\n\t * If it exist, this callback should called before any other callback of\n\t * the clock\n\t */\n\tif (core->ops->init) {\n\t\tret = core->ops->init(core->hw);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tparent = core->parent = __clk_init_parent(core);\n\n\t/*\n\t * Populate core->parent if parent has already been clk_core_init'd. If\n\t * parent has not yet been clk_core_init'd then place clk in the orphan\n\t * list.  If clk doesn't have any parents then place it in the root\n\t * clk list.\n\t *\n\t * Every time a new clk is clk_init'd then we walk the list of orphan\n\t * clocks and re-parent any that are children of the clock currently\n\t * being clk_init'd.\n\t */\n\tif (parent) {\n\t\thlist_add_head(&core->child_node, &parent->children);\n\t\tcore->orphan = parent->orphan;\n\t} else if (!core->num_parents) {\n\t\thlist_add_head(&core->child_node, &clk_root_list);\n\t\tcore->orphan = false;\n\t} else {\n\t\thlist_add_head(&core->child_node, &clk_orphan_list);\n\t\tcore->orphan = true;\n\t}\n\n\t/*\n\t * Set clk's accuracy.  The preferred method is to use\n\t * .recalc_accuracy. For simple clocks and lazy developers the default\n\t * fallback is to use the parent's accuracy.  If a clock doesn't have a\n\t * parent (or is orphaned) then accuracy is set to zero (perfect\n\t * clock).\n\t */\n\tif (core->ops->recalc_accuracy)\n\t\tcore->accuracy = core->ops->recalc_accuracy(core->hw,\n\t\t\t\t\tclk_core_get_accuracy_no_lock(parent));\n\telse if (parent)\n\t\tcore->accuracy = parent->accuracy;\n\telse\n\t\tcore->accuracy = 0;\n\n\t/*\n\t * Set clk's phase by clk_core_get_phase() caching the phase.\n\t * Since a phase is by definition relative to its parent, just\n\t * query the current clock phase, or just assume it's in phase.\n\t */\n\tphase = clk_core_get_phase(core);\n\tif (phase < 0) {\n\t\tret = phase;\n\t\tpr_warn(\"%s: Failed to get phase for clk '%s'\\n\", __func__,\n\t\t\tcore->name);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Set clk's duty cycle.\n\t */\n\tclk_core_update_duty_cycle_nolock(core);\n\n\t/*\n\t * Set clk's rate.  The preferred method is to use .recalc_rate.  For\n\t * simple clocks and lazy developers the default fallback is to use the\n\t * parent's rate.  If a clock doesn't have a parent (or is orphaned)\n\t * then rate is set to zero.\n\t */\n\tif (core->ops->recalc_rate)\n\t\trate = core->ops->recalc_rate(core->hw,\n\t\t\t\tclk_core_get_rate_nolock(parent));\n\telse if (parent)\n\t\trate = parent->rate;\n\telse\n\t\trate = 0;\n\tcore->rate = core->req_rate = rate;\n\n\t/*\n\t * Enable CLK_IS_CRITICAL clocks so newly added critical clocks\n\t * don't get accidentally disabled when walking the orphan tree and\n\t * reparenting clocks\n\t */\n\tif (core->flags & CLK_IS_CRITICAL) {\n\t\tunsigned long flags;\n\n\t\tret = clk_core_prepare(core);\n\t\tif (ret) {\n\t\t\tpr_warn(\"%s: critical clk '%s' failed to prepare\\n\",\n\t\t\t       __func__, core->name);\n\t\t\tgoto out;\n\t\t}\n\n\t\tflags = clk_enable_lock();\n\t\tret = clk_core_enable(core);\n\t\tclk_enable_unlock(flags);\n\t\tif (ret) {\n\t\t\tpr_warn(\"%s: critical clk '%s' failed to enable\\n\",\n\t\t\t       __func__, core->name);\n\t\t\tclk_core_unprepare(core);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tclk_core_reparent_orphans_nolock();\n\n\n\tkref_init(&core->ref);\nout:\n\tclk_pm_runtime_put(core);\nunlock:\n\tif (ret)\n\t\thlist_del_init(&core->child_node);\n\n\tclk_prepare_unlock();\n\n\tif (!ret)\n\t\tclk_debug_register(core);\n\n\treturn ret;\n}\n\n/**\n * clk_core_link_consumer - Add a clk consumer to the list of consumers in a clk_core\n * @core: clk to add consumer to\n * @clk: consumer to link to a clk\n */\nstatic void clk_core_link_consumer(struct clk_core *core, struct clk *clk)\n{\n\tclk_prepare_lock();\n\thlist_add_head(&clk->clks_node, &core->clks);\n\tclk_prepare_unlock();\n}\n\n/**\n * clk_core_unlink_consumer - Remove a clk consumer from the list of consumers in a clk_core\n * @clk: consumer to unlink\n */\nstatic void clk_core_unlink_consumer(struct clk *clk)\n{\n\tlockdep_assert_held(&prepare_lock);\n\thlist_del(&clk->clks_node);\n}\n\n/**\n * alloc_clk - Allocate a clk consumer, but leave it unlinked to the clk_core\n * @core: clk to allocate a consumer for\n * @dev_id: string describing device name\n * @con_id: connection ID string on device\n *\n * Returns: clk consumer left unlinked from the consumer list\n */\nstatic struct clk *alloc_clk(struct clk_core *core, const char *dev_id,\n\t\t\t     const char *con_id)\n{\n\tstruct clk *clk;\n\n\tclk = kzalloc(sizeof(*clk), GFP_KERNEL);\n\tif (!clk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclk->core = core;\n\tclk->dev_id = dev_id;\n\tclk->con_id = kstrdup_const(con_id, GFP_KERNEL);\n\tclk->max_rate = ULONG_MAX;\n\n\treturn clk;\n}\n\n/**\n * free_clk - Free a clk consumer\n * @clk: clk consumer to free\n *\n * Note, this assumes the clk has been unlinked from the clk_core consumer\n * list.\n */\nstatic void free_clk(struct clk *clk)\n{\n\tkfree_const(clk->con_id);\n\tkfree(clk);\n}\n\n/**\n * clk_hw_create_clk: Allocate and link a clk consumer to a clk_core given\n * a clk_hw\n * @dev: clk consumer device\n * @hw: clk_hw associated with the clk being consumed\n * @dev_id: string describing device name\n * @con_id: connection ID string on device\n *\n * This is the main function used to create a clk pointer for use by clk\n * consumers. It connects a consumer to the clk_core and clk_hw structures\n * used by the framework and clk provider respectively.\n */\nstruct clk *clk_hw_create_clk(struct device *dev, struct clk_hw *hw,\n\t\t\t      const char *dev_id, const char *con_id)\n{\n\tstruct clk *clk;\n\tstruct clk_core *core;\n\n\t/* This is to allow this function to be chained to others */\n\tif (IS_ERR_OR_NULL(hw))\n\t\treturn ERR_CAST(hw);\n\n\tcore = hw->core;\n\tclk = alloc_clk(core, dev_id, con_id);\n\tif (IS_ERR(clk))\n\t\treturn clk;\n\tclk->dev = dev;\n\n\tif (!try_module_get(core->owner)) {\n\t\tfree_clk(clk);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tkref_get(&core->ref);\n\tclk_core_link_consumer(core, clk);\n\n\treturn clk;\n}\n\n/**\n * clk_hw_get_clk - get clk consumer given an clk_hw\n * @hw: clk_hw associated with the clk being consumed\n * @con_id: connection ID string on device\n *\n * Returns: new clk consumer\n * This is the function to be used by providers which need\n * to get a consumer clk and act on the clock element\n * Calls to this function must be balanced with calls clk_put()\n */\nstruct clk *clk_hw_get_clk(struct clk_hw *hw, const char *con_id)\n{\n\tstruct device *dev = hw->core->dev;\n\n\treturn clk_hw_create_clk(dev, hw, dev_name(dev), con_id);\n}\nEXPORT_SYMBOL(clk_hw_get_clk);\n\nstatic int clk_cpy_name(const char **dst_p, const char *src, bool must_exist)\n{\n\tconst char *dst;\n\n\tif (!src) {\n\t\tif (must_exist)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t*dst_p = dst = kstrdup_const(src, GFP_KERNEL);\n\tif (!dst)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int clk_core_populate_parent_map(struct clk_core *core,\n\t\t\t\t\tconst struct clk_init_data *init)\n{\n\tu8 num_parents = init->num_parents;\n\tconst char * const *parent_names = init->parent_names;\n\tconst struct clk_hw **parent_hws = init->parent_hws;\n\tconst struct clk_parent_data *parent_data = init->parent_data;\n\tint i, ret = 0;\n\tstruct clk_parent_map *parents, *parent;\n\n\tif (!num_parents)\n\t\treturn 0;\n\n\t/*\n\t * Avoid unnecessary string look-ups of clk_core's possible parents by\n\t * having a cache of names/clk_hw pointers to clk_core pointers.\n\t */\n\tparents = kcalloc(num_parents, sizeof(*parents), GFP_KERNEL);\n\tcore->parents = parents;\n\tif (!parents)\n\t\treturn -ENOMEM;\n\n\t/* Copy everything over because it might be __initdata */\n\tfor (i = 0, parent = parents; i < num_parents; i++, parent++) {\n\t\tparent->index = -1;\n\t\tif (parent_names) {\n\t\t\t/* throw a WARN if any entries are NULL */\n\t\t\tWARN(!parent_names[i],\n\t\t\t\t\"%s: invalid NULL in %s's .parent_names\\n\",\n\t\t\t\t__func__, core->name);\n\t\t\tret = clk_cpy_name(&parent->name, parent_names[i],\n\t\t\t\t\t   true);\n\t\t} else if (parent_data) {\n\t\t\tparent->hw = parent_data[i].hw;\n\t\t\tparent->index = parent_data[i].index;\n\t\t\tret = clk_cpy_name(&parent->fw_name,\n\t\t\t\t\t   parent_data[i].fw_name, false);\n\t\t\tif (!ret)\n\t\t\t\tret = clk_cpy_name(&parent->name,\n\t\t\t\t\t\t   parent_data[i].name,\n\t\t\t\t\t\t   false);\n\t\t} else if (parent_hws) {\n\t\t\tparent->hw = parent_hws[i];\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tWARN(1, \"Must specify parents if num_parents > 0\\n\");\n\t\t}\n\n\t\tif (ret) {\n\t\t\tdo {\n\t\t\t\tkfree_const(parents[i].name);\n\t\t\t\tkfree_const(parents[i].fw_name);\n\t\t\t} while (--i >= 0);\n\t\t\tkfree(parents);\n\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void clk_core_free_parent_map(struct clk_core *core)\n{\n\tint i = core->num_parents;\n\n\tif (!core->num_parents)\n\t\treturn;\n\n\twhile (--i >= 0) {\n\t\tkfree_const(core->parents[i].name);\n\t\tkfree_const(core->parents[i].fw_name);\n\t}\n\n\tkfree(core->parents);\n}\n\nstatic struct clk *\n__clk_register(struct device *dev, struct device_node *np, struct clk_hw *hw)\n{\n\tint ret;\n\tstruct clk_core *core;\n\tconst struct clk_init_data *init = hw->init;\n\n\t/*\n\t * The init data is not supposed to be used outside of registration path.\n\t * Set it to NULL so that provider drivers can't use it either and so that\n\t * we catch use of hw->init early on in the core.\n\t */\n\thw->init = NULL;\n\n\tcore = kzalloc(sizeof(*core), GFP_KERNEL);\n\tif (!core) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_out;\n\t}\n\n\tcore->name = kstrdup_const(init->name, GFP_KERNEL);\n\tif (!core->name) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_name;\n\t}\n\n\tif (WARN_ON(!init->ops)) {\n\t\tret = -EINVAL;\n\t\tgoto fail_ops;\n\t}\n\tcore->ops = init->ops;\n\n\tif (dev && pm_runtime_enabled(dev))\n\t\tcore->rpm_enabled = true;\n\tcore->dev = dev;\n\tcore->of_node = np;\n\tif (dev && dev->driver)\n\t\tcore->owner = dev->driver->owner;\n\tcore->hw = hw;\n\tcore->flags = init->flags;\n\tcore->num_parents = init->num_parents;\n\tcore->min_rate = 0;\n\tcore->max_rate = ULONG_MAX;\n\thw->core = core;\n\n\tret = clk_core_populate_parent_map(core, init);\n\tif (ret)\n\t\tgoto fail_parents;\n\n\tINIT_HLIST_HEAD(&core->clks);\n\n\t/*\n\t * Don't call clk_hw_create_clk() here because that would pin the\n\t * provider module to itself and prevent it from ever being removed.\n\t */\n\thw->clk = alloc_clk(core, NULL, NULL);\n\tif (IS_ERR(hw->clk)) {\n\t\tret = PTR_ERR(hw->clk);\n\t\tgoto fail_create_clk;\n\t}\n\n\tclk_core_link_consumer(hw->core, hw->clk);\n\n\tret = __clk_core_init(core);\n\tif (!ret)\n\t\treturn hw->clk;\n\n\tclk_prepare_lock();\n\tclk_core_unlink_consumer(hw->clk);\n\tclk_prepare_unlock();\n\n\tfree_clk(hw->clk);\n\thw->clk = NULL;\n\nfail_create_clk:\n\tclk_core_free_parent_map(core);\nfail_parents:\nfail_ops:\n\tkfree_const(core->name);\nfail_name:\n\tkfree(core);\nfail_out:\n\treturn ERR_PTR(ret);\n}\n\n/**\n * dev_or_parent_of_node() - Get device node of @dev or @dev's parent\n * @dev: Device to get device node of\n *\n * Return: device node pointer of @dev, or the device node pointer of\n * @dev->parent if dev doesn't have a device node, or NULL if neither\n * @dev or @dev->parent have a device node.\n */\nstatic struct device_node *dev_or_parent_of_node(struct device *dev)\n{\n\tstruct device_node *np;\n\n\tif (!dev)\n\t\treturn NULL;\n\n\tnp = dev_of_node(dev);\n\tif (!np)\n\t\tnp = dev_of_node(dev->parent);\n\n\treturn np;\n}\n\n/**\n * clk_register - allocate a new clock, register it and return an opaque cookie\n * @dev: device that is registering this clock\n * @hw: link to hardware-specific clock data\n *\n * clk_register is the *deprecated* interface for populating the clock tree with\n * new clock nodes. Use clk_hw_register() instead.\n *\n * Returns: a pointer to the newly allocated struct clk which\n * cannot be dereferenced by driver code but may be used in conjunction with the\n * rest of the clock API.  In the event of an error clk_register will return an\n * error code; drivers must test for an error code after calling clk_register.\n */\nstruct clk *clk_register(struct device *dev, struct clk_hw *hw)\n{\n\treturn __clk_register(dev, dev_or_parent_of_node(dev), hw);\n}\nEXPORT_SYMBOL_GPL(clk_register);\n\n/**\n * clk_hw_register - register a clk_hw and return an error code\n * @dev: device that is registering this clock\n * @hw: link to hardware-specific clock data\n *\n * clk_hw_register is the primary interface for populating the clock tree with\n * new clock nodes. It returns an integer equal to zero indicating success or\n * less than zero indicating failure. Drivers must test for an error code after\n * calling clk_hw_register().\n */\nint clk_hw_register(struct device *dev, struct clk_hw *hw)\n{\n\treturn PTR_ERR_OR_ZERO(__clk_register(dev, dev_or_parent_of_node(dev),\n\t\t\t       hw));\n}\nEXPORT_SYMBOL_GPL(clk_hw_register);\n\n/*\n * of_clk_hw_register - register a clk_hw and return an error code\n * @node: device_node of device that is registering this clock\n * @hw: link to hardware-specific clock data\n *\n * of_clk_hw_register() is the primary interface for populating the clock tree\n * with new clock nodes when a struct device is not available, but a struct\n * device_node is. It returns an integer equal to zero indicating success or\n * less than zero indicating failure. Drivers must test for an error code after\n * calling of_clk_hw_register().\n */\nint of_clk_hw_register(struct device_node *node, struct clk_hw *hw)\n{\n\treturn PTR_ERR_OR_ZERO(__clk_register(NULL, node, hw));\n}\nEXPORT_SYMBOL_GPL(of_clk_hw_register);\n\n/* Free memory allocated for a clock. */\nstatic void __clk_release(struct kref *ref)\n{\n\tstruct clk_core *core = container_of(ref, struct clk_core, ref);\n\n\tlockdep_assert_held(&prepare_lock);\n\n\tclk_core_free_parent_map(core);\n\tkfree_const(core->name);\n\tkfree(core);\n}\n\n/*\n * Empty clk_ops for unregistered clocks. These are used temporarily\n * after clk_unregister() was called on a clock and until last clock\n * consumer calls clk_put() and the struct clk object is freed.\n */\nstatic int clk_nodrv_prepare_enable(struct clk_hw *hw)\n{\n\treturn -ENXIO;\n}\n\nstatic void clk_nodrv_disable_unprepare(struct clk_hw *hw)\n{\n\tWARN_ON_ONCE(1);\n}\n\nstatic int clk_nodrv_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\treturn -ENXIO;\n}\n\nstatic int clk_nodrv_set_parent(struct clk_hw *hw, u8 index)\n{\n\treturn -ENXIO;\n}\n\nstatic const struct clk_ops clk_nodrv_ops = {\n\t.enable\t\t= clk_nodrv_prepare_enable,\n\t.disable\t= clk_nodrv_disable_unprepare,\n\t.prepare\t= clk_nodrv_prepare_enable,\n\t.unprepare\t= clk_nodrv_disable_unprepare,\n\t.set_rate\t= clk_nodrv_set_rate,\n\t.set_parent\t= clk_nodrv_set_parent,\n};\n\nstatic void clk_core_evict_parent_cache_subtree(struct clk_core *root,\n\t\t\t\t\t\tstruct clk_core *target)\n{\n\tint i;\n\tstruct clk_core *child;\n\n\tfor (i = 0; i < root->num_parents; i++)\n\t\tif (root->parents[i].core == target)\n\t\t\troot->parents[i].core = NULL;\n\n\thlist_for_each_entry(child, &root->children, child_node)\n\t\tclk_core_evict_parent_cache_subtree(child, target);\n}\n\n/* Remove this clk from all parent caches */\nstatic void clk_core_evict_parent_cache(struct clk_core *core)\n{\n\tstruct hlist_head **lists;\n\tstruct clk_core *root;\n\n\tlockdep_assert_held(&prepare_lock);\n\n\tfor (lists = all_lists; *lists; lists++)\n\t\thlist_for_each_entry(root, *lists, child_node)\n\t\t\tclk_core_evict_parent_cache_subtree(root, core);\n\n}\n\n/**\n * clk_unregister - unregister a currently registered clock\n * @clk: clock to unregister\n */\nvoid clk_unregister(struct clk *clk)\n{\n\tunsigned long flags;\n\tconst struct clk_ops *ops;\n\n\tif (!clk || WARN_ON_ONCE(IS_ERR(clk)))\n\t\treturn;\n\n\tclk_debug_unregister(clk->core);\n\n\tclk_prepare_lock();\n\n\tops = clk->core->ops;\n\tif (ops == &clk_nodrv_ops) {\n\t\tpr_err(\"%s: unregistered clock: %s\\n\", __func__,\n\t\t       clk->core->name);\n\t\tgoto unlock;\n\t}\n\t/*\n\t * Assign empty clock ops for consumers that might still hold\n\t * a reference to this clock.\n\t */\n\tflags = clk_enable_lock();\n\tclk->core->ops = &clk_nodrv_ops;\n\tclk_enable_unlock(flags);\n\n\tif (ops->terminate)\n\t\tops->terminate(clk->core->hw);\n\n\tif (!hlist_empty(&clk->core->children)) {\n\t\tstruct clk_core *child;\n\t\tstruct hlist_node *t;\n\n\t\t/* Reparent all children to the orphan list. */\n\t\thlist_for_each_entry_safe(child, t, &clk->core->children,\n\t\t\t\t\t  child_node)\n\t\t\tclk_core_set_parent_nolock(child, NULL);\n\t}\n\n\tclk_core_evict_parent_cache(clk->core);\n\n\thlist_del_init(&clk->core->child_node);\n\n\tif (clk->core->prepare_count)\n\t\tpr_warn(\"%s: unregistering prepared clock: %s\\n\",\n\t\t\t\t\t__func__, clk->core->name);\n\n\tif (clk->core->protect_count)\n\t\tpr_warn(\"%s: unregistering protected clock: %s\\n\",\n\t\t\t\t\t__func__, clk->core->name);\n\n\tkref_put(&clk->core->ref, __clk_release);\n\tfree_clk(clk);\nunlock:\n\tclk_prepare_unlock();\n}\nEXPORT_SYMBOL_GPL(clk_unregister);\n\n/**\n * clk_hw_unregister - unregister a currently registered clk_hw\n * @hw: hardware-specific clock data to unregister\n */\nvoid clk_hw_unregister(struct clk_hw *hw)\n{\n\tclk_unregister(hw->clk);\n}\nEXPORT_SYMBOL_GPL(clk_hw_unregister);\n\nstatic void devm_clk_unregister_cb(struct device *dev, void *res)\n{\n\tclk_unregister(*(struct clk **)res);\n}\n\nstatic void devm_clk_hw_unregister_cb(struct device *dev, void *res)\n{\n\tclk_hw_unregister(*(struct clk_hw **)res);\n}\n\n/**\n * devm_clk_register - resource managed clk_register()\n * @dev: device that is registering this clock\n * @hw: link to hardware-specific clock data\n *\n * Managed clk_register(). This function is *deprecated*, use devm_clk_hw_register() instead.\n *\n * Clocks returned from this function are automatically clk_unregister()ed on\n * driver detach. See clk_register() for more information.\n */\nstruct clk *devm_clk_register(struct device *dev, struct clk_hw *hw)\n{\n\tstruct clk *clk;\n\tstruct clk **clkp;\n\n\tclkp = devres_alloc(devm_clk_unregister_cb, sizeof(*clkp), GFP_KERNEL);\n\tif (!clkp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclk = clk_register(dev, hw);\n\tif (!IS_ERR(clk)) {\n\t\t*clkp = clk;\n\t\tdevres_add(dev, clkp);\n\t} else {\n\t\tdevres_free(clkp);\n\t}\n\n\treturn clk;\n}\nEXPORT_SYMBOL_GPL(devm_clk_register);\n\n/**\n * devm_clk_hw_register - resource managed clk_hw_register()\n * @dev: device that is registering this clock\n * @hw: link to hardware-specific clock data\n *\n * Managed clk_hw_register(). Clocks registered by this function are\n * automatically clk_hw_unregister()ed on driver detach. See clk_hw_register()\n * for more information.\n */\nint devm_clk_hw_register(struct device *dev, struct clk_hw *hw)\n{\n\tstruct clk_hw **hwp;\n\tint ret;\n\n\thwp = devres_alloc(devm_clk_hw_unregister_cb, sizeof(*hwp), GFP_KERNEL);\n\tif (!hwp)\n\t\treturn -ENOMEM;\n\n\tret = clk_hw_register(dev, hw);\n\tif (!ret) {\n\t\t*hwp = hw;\n\t\tdevres_add(dev, hwp);\n\t} else {\n\t\tdevres_free(hwp);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devm_clk_hw_register);\n\nstatic int devm_clk_match(struct device *dev, void *res, void *data)\n{\n\tstruct clk *c = res;\n\tif (WARN_ON(!c))\n\t\treturn 0;\n\treturn c == data;\n}\n\nstatic int devm_clk_hw_match(struct device *dev, void *res, void *data)\n{\n\tstruct clk_hw *hw = res;\n\n\tif (WARN_ON(!hw))\n\t\treturn 0;\n\treturn hw == data;\n}\n\n/**\n * devm_clk_unregister - resource managed clk_unregister()\n * @dev: device that is unregistering the clock data\n * @clk: clock to unregister\n *\n * Deallocate a clock allocated with devm_clk_register(). Normally\n * this function will not need to be called and the resource management\n * code will ensure that the resource is freed.\n */\nvoid devm_clk_unregister(struct device *dev, struct clk *clk)\n{\n\tWARN_ON(devres_release(dev, devm_clk_unregister_cb, devm_clk_match, clk));\n}\nEXPORT_SYMBOL_GPL(devm_clk_unregister);\n\n/**\n * devm_clk_hw_unregister - resource managed clk_hw_unregister()\n * @dev: device that is unregistering the hardware-specific clock data\n * @hw: link to hardware-specific clock data\n *\n * Unregister a clk_hw registered with devm_clk_hw_register(). Normally\n * this function will not need to be called and the resource management\n * code will ensure that the resource is freed.\n */\nvoid devm_clk_hw_unregister(struct device *dev, struct clk_hw *hw)\n{\n\tWARN_ON(devres_release(dev, devm_clk_hw_unregister_cb, devm_clk_hw_match,\n\t\t\t\thw));\n}\nEXPORT_SYMBOL_GPL(devm_clk_hw_unregister);\n\nstatic void devm_clk_release(struct device *dev, void *res)\n{\n\tclk_put(*(struct clk **)res);\n}\n\n/**\n * devm_clk_hw_get_clk - resource managed clk_hw_get_clk()\n * @dev: device that is registering this clock\n * @hw: clk_hw associated with the clk being consumed\n * @con_id: connection ID string on device\n *\n * Managed clk_hw_get_clk(). Clocks got with this function are\n * automatically clk_put() on driver detach. See clk_put()\n * for more information.\n */\nstruct clk *devm_clk_hw_get_clk(struct device *dev, struct clk_hw *hw,\n\t\t\t\tconst char *con_id)\n{\n\tstruct clk *clk;\n\tstruct clk **clkp;\n\n\t/* This should not happen because it would mean we have drivers\n\t * passing around clk_hw pointers instead of having the caller use\n\t * proper clk_get() style APIs\n\t */\n\tWARN_ON_ONCE(dev != hw->core->dev);\n\n\tclkp = devres_alloc(devm_clk_release, sizeof(*clkp), GFP_KERNEL);\n\tif (!clkp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclk = clk_hw_get_clk(hw, con_id);\n\tif (!IS_ERR(clk)) {\n\t\t*clkp = clk;\n\t\tdevres_add(dev, clkp);\n\t} else {\n\t\tdevres_free(clkp);\n\t}\n\n\treturn clk;\n}\nEXPORT_SYMBOL_GPL(devm_clk_hw_get_clk);\n\n/*\n * clkdev helpers\n */\n\nvoid __clk_put(struct clk *clk)\n{\n\tstruct module *owner;\n\n\tif (!clk || WARN_ON_ONCE(IS_ERR(clk)))\n\t\treturn;\n\n\tclk_prepare_lock();\n\n\t/*\n\t * Before calling clk_put, all calls to clk_rate_exclusive_get() from a\n\t * given user should be balanced with calls to clk_rate_exclusive_put()\n\t * and by that same consumer\n\t */\n\tif (WARN_ON(clk->exclusive_count)) {\n\t\t/* We voiced our concern, let's sanitize the situation */\n\t\tclk->core->protect_count -= (clk->exclusive_count - 1);\n\t\tclk_core_rate_unprotect(clk->core);\n\t\tclk->exclusive_count = 0;\n\t}\n\n\thlist_del(&clk->clks_node);\n\tif (clk->min_rate > clk->core->req_rate ||\n\t    clk->max_rate < clk->core->req_rate)\n\t\tclk_core_set_rate_nolock(clk->core, clk->core->req_rate);\n\n\towner = clk->core->owner;\n\tkref_put(&clk->core->ref, __clk_release);\n\n\tclk_prepare_unlock();\n\n\tmodule_put(owner);\n\n\tfree_clk(clk);\n}\n\n/***        clk rate change notifiers        ***/\n\n/**\n * clk_notifier_register - add a clk rate change notifier\n * @clk: struct clk * to watch\n * @nb: struct notifier_block * with callback info\n *\n * Request notification when clk's rate changes.  This uses an SRCU\n * notifier because we want it to block and notifier unregistrations are\n * uncommon.  The callbacks associated with the notifier must not\n * re-enter into the clk framework by calling any top-level clk APIs;\n * this will cause a nested prepare_lock mutex.\n *\n * In all notification cases (pre, post and abort rate change) the original\n * clock rate is passed to the callback via struct clk_notifier_data.old_rate\n * and the new frequency is passed via struct clk_notifier_data.new_rate.\n *\n * clk_notifier_register() must be called from non-atomic context.\n * Returns -EINVAL if called with null arguments, -ENOMEM upon\n * allocation failure; otherwise, passes along the return value of\n * srcu_notifier_chain_register().\n */\nint clk_notifier_register(struct clk *clk, struct notifier_block *nb)\n{\n\tstruct clk_notifier *cn;\n\tint ret = -ENOMEM;\n\n\tif (!clk || !nb)\n\t\treturn -EINVAL;\n\n\tclk_prepare_lock();\n\n\t/* search the list of notifiers for this clk */\n\tlist_for_each_entry(cn, &clk_notifier_list, node)\n\t\tif (cn->clk == clk)\n\t\t\tbreak;\n\n\t/* if clk wasn't in the notifier list, allocate new clk_notifier */\n\tif (cn->clk != clk) {\n\t\tcn = kzalloc(sizeof(*cn), GFP_KERNEL);\n\t\tif (!cn)\n\t\t\tgoto out;\n\n\t\tcn->clk = clk;\n\t\tsrcu_init_notifier_head(&cn->notifier_head);\n\n\t\tlist_add(&cn->node, &clk_notifier_list);\n\t}\n\n\tret = srcu_notifier_chain_register(&cn->notifier_head, nb);\n\n\tclk->core->notifier_count++;\n\nout:\n\tclk_prepare_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(clk_notifier_register);\n\n/**\n * clk_notifier_unregister - remove a clk rate change notifier\n * @clk: struct clk *\n * @nb: struct notifier_block * with callback info\n *\n * Request no further notification for changes to 'clk' and frees memory\n * allocated in clk_notifier_register.\n *\n * Returns -EINVAL if called with null arguments; otherwise, passes\n * along the return value of srcu_notifier_chain_unregister().\n */\nint clk_notifier_unregister(struct clk *clk, struct notifier_block *nb)\n{\n\tstruct clk_notifier *cn = NULL;\n\tint ret = -EINVAL;\n\n\tif (!clk || !nb)\n\t\treturn -EINVAL;\n\n\tclk_prepare_lock();\n\n\tlist_for_each_entry(cn, &clk_notifier_list, node)\n\t\tif (cn->clk == clk)\n\t\t\tbreak;\n\n\tif (cn->clk == clk) {\n\t\tret = srcu_notifier_chain_unregister(&cn->notifier_head, nb);\n\n\t\tclk->core->notifier_count--;\n\n\t\t/* XXX the notifier code should handle this better */\n\t\tif (!cn->notifier_head.head) {\n\t\t\tsrcu_cleanup_notifier_head(&cn->notifier_head);\n\t\t\tlist_del(&cn->node);\n\t\t\tkfree(cn);\n\t\t}\n\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\n\tclk_prepare_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(clk_notifier_unregister);\n\nstruct clk_notifier_devres {\n\tstruct clk *clk;\n\tstruct notifier_block *nb;\n};\n\nstatic void devm_clk_notifier_release(struct device *dev, void *res)\n{\n\tstruct clk_notifier_devres *devres = res;\n\n\tclk_notifier_unregister(devres->clk, devres->nb);\n}\n\nint devm_clk_notifier_register(struct device *dev, struct clk *clk,\n\t\t\t       struct notifier_block *nb)\n{\n\tstruct clk_notifier_devres *devres;\n\tint ret;\n\n\tdevres = devres_alloc(devm_clk_notifier_release,\n\t\t\t      sizeof(*devres), GFP_KERNEL);\n\n\tif (!devres)\n\t\treturn -ENOMEM;\n\n\tret = clk_notifier_register(clk, nb);\n\tif (!ret) {\n\t\tdevres->clk = clk;\n\t\tdevres->nb = nb;\n\t} else {\n\t\tdevres_free(devres);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devm_clk_notifier_register);\n\n#ifdef CONFIG_OF\nstatic void clk_core_reparent_orphans(void)\n{\n\tclk_prepare_lock();\n\tclk_core_reparent_orphans_nolock();\n\tclk_prepare_unlock();\n}\n\n/**\n * struct of_clk_provider - Clock provider registration structure\n * @link: Entry in global list of clock providers\n * @node: Pointer to device tree node of clock provider\n * @get: Get clock callback.  Returns NULL or a struct clk for the\n *       given clock specifier\n * @get_hw: Get clk_hw callback.  Returns NULL, ERR_PTR or a\n *       struct clk_hw for the given clock specifier\n * @data: context pointer to be passed into @get callback\n */\nstruct of_clk_provider {\n\tstruct list_head link;\n\n\tstruct device_node *node;\n\tstruct clk *(*get)(struct of_phandle_args *clkspec, void *data);\n\tstruct clk_hw *(*get_hw)(struct of_phandle_args *clkspec, void *data);\n\tvoid *data;\n};\n\nextern struct of_device_id __clk_of_table;\nstatic const struct of_device_id __clk_of_table_sentinel\n\t__used __section(\"__clk_of_table_end\");\n\nstatic LIST_HEAD(of_clk_providers);\nstatic DEFINE_MUTEX(of_clk_mutex);\n\nstruct clk *of_clk_src_simple_get(struct of_phandle_args *clkspec,\n\t\t\t\t     void *data)\n{\n\treturn data;\n}\nEXPORT_SYMBOL_GPL(of_clk_src_simple_get);\n\nstruct clk_hw *of_clk_hw_simple_get(struct of_phandle_args *clkspec, void *data)\n{\n\treturn data;\n}\nEXPORT_SYMBOL_GPL(of_clk_hw_simple_get);\n\nstruct clk *of_clk_src_onecell_get(struct of_phandle_args *clkspec, void *data)\n{\n\tstruct clk_onecell_data *clk_data = data;\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx >= clk_data->clk_num) {\n\t\tpr_err(\"%s: invalid clock index %u\\n\", __func__, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn clk_data->clks[idx];\n}\nEXPORT_SYMBOL_GPL(of_clk_src_onecell_get);\n\nstruct clk_hw *\nof_clk_hw_onecell_get(struct of_phandle_args *clkspec, void *data)\n{\n\tstruct clk_hw_onecell_data *hw_data = data;\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx >= hw_data->num) {\n\t\tpr_err(\"%s: invalid index %u\\n\", __func__, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn hw_data->hws[idx];\n}\nEXPORT_SYMBOL_GPL(of_clk_hw_onecell_get);\n\n/**\n * of_clk_add_provider() - Register a clock provider for a node\n * @np: Device node pointer associated with clock provider\n * @clk_src_get: callback for decoding clock\n * @data: context pointer for @clk_src_get callback.\n *\n * This function is *deprecated*. Use of_clk_add_hw_provider() instead.\n */\nint of_clk_add_provider(struct device_node *np,\n\t\t\tstruct clk *(*clk_src_get)(struct of_phandle_args *clkspec,\n\t\t\t\t\t\t   void *data),\n\t\t\tvoid *data)\n{\n\tstruct of_clk_provider *cp;\n\tint ret;\n\n\tcp = kzalloc(sizeof(*cp), GFP_KERNEL);\n\tif (!cp)\n\t\treturn -ENOMEM;\n\n\tcp->node = of_node_get(np);\n\tcp->data = data;\n\tcp->get = clk_src_get;\n\n\tmutex_lock(&of_clk_mutex);\n\tlist_add(&cp->link, &of_clk_providers);\n\tmutex_unlock(&of_clk_mutex);\n\tpr_debug(\"Added clock from %pOF\\n\", np);\n\n\tclk_core_reparent_orphans();\n\n\tret = of_clk_set_defaults(np, true);\n\tif (ret < 0)\n\t\tof_clk_del_provider(np);\n\n\tfwnode_dev_initialized(&np->fwnode, true);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(of_clk_add_provider);\n\n/**\n * of_clk_add_hw_provider() - Register a clock provider for a node\n * @np: Device node pointer associated with clock provider\n * @get: callback for decoding clk_hw\n * @data: context pointer for @get callback.\n */\nint of_clk_add_hw_provider(struct device_node *np,\n\t\t\t   struct clk_hw *(*get)(struct of_phandle_args *clkspec,\n\t\t\t\t\t\t void *data),\n\t\t\t   void *data)\n{\n\tstruct of_clk_provider *cp;\n\tint ret;\n\n\tcp = kzalloc(sizeof(*cp), GFP_KERNEL);\n\tif (!cp)\n\t\treturn -ENOMEM;\n\n\tcp->node = of_node_get(np);\n\tcp->data = data;\n\tcp->get_hw = get;\n\n\tmutex_lock(&of_clk_mutex);\n\tlist_add(&cp->link, &of_clk_providers);\n\tmutex_unlock(&of_clk_mutex);\n\tpr_debug(\"Added clk_hw provider from %pOF\\n\", np);\n\n\tclk_core_reparent_orphans();\n\n\tret = of_clk_set_defaults(np, true);\n\tif (ret < 0)\n\t\tof_clk_del_provider(np);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(of_clk_add_hw_provider);\n\nstatic void devm_of_clk_release_provider(struct device *dev, void *res)\n{\n\tof_clk_del_provider(*(struct device_node **)res);\n}\n\n/*\n * We allow a child device to use its parent device as the clock provider node\n * for cases like MFD sub-devices where the child device driver wants to use\n * devm_*() APIs but not list the device in DT as a sub-node.\n */\nstatic struct device_node *get_clk_provider_node(struct device *dev)\n{\n\tstruct device_node *np, *parent_np;\n\n\tnp = dev->of_node;\n\tparent_np = dev->parent ? dev->parent->of_node : NULL;\n\n\tif (!of_find_property(np, \"#clock-cells\", NULL))\n\t\tif (of_find_property(parent_np, \"#clock-cells\", NULL))\n\t\t\tnp = parent_np;\n\n\treturn np;\n}\n\n/**\n * devm_of_clk_add_hw_provider() - Managed clk provider node registration\n * @dev: Device acting as the clock provider (used for DT node and lifetime)\n * @get: callback for decoding clk_hw\n * @data: context pointer for @get callback\n *\n * Registers clock provider for given device's node. If the device has no DT\n * node or if the device node lacks of clock provider information (#clock-cells)\n * then the parent device's node is scanned for this information. If parent node\n * has the #clock-cells then it is used in registration. Provider is\n * automatically released at device exit.\n *\n * Return: 0 on success or an errno on failure.\n */\nint devm_of_clk_add_hw_provider(struct device *dev,\n\t\t\tstruct clk_hw *(*get)(struct of_phandle_args *clkspec,\n\t\t\t\t\t      void *data),\n\t\t\tvoid *data)\n{\n\tstruct device_node **ptr, *np;\n\tint ret;\n\n\tptr = devres_alloc(devm_of_clk_release_provider, sizeof(*ptr),\n\t\t\t   GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tnp = get_clk_provider_node(dev);\n\tret = of_clk_add_hw_provider(np, get, data);\n\tif (!ret) {\n\t\t*ptr = np;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devm_of_clk_add_hw_provider);\n\n/**\n * of_clk_del_provider() - Remove a previously registered clock provider\n * @np: Device node pointer associated with clock provider\n */\nvoid of_clk_del_provider(struct device_node *np)\n{\n\tstruct of_clk_provider *cp;\n\n\tmutex_lock(&of_clk_mutex);\n\tlist_for_each_entry(cp, &of_clk_providers, link) {\n\t\tif (cp->node == np) {\n\t\t\tlist_del(&cp->link);\n\t\t\tfwnode_dev_initialized(&np->fwnode, false);\n\t\t\tof_node_put(cp->node);\n\t\t\tkfree(cp);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&of_clk_mutex);\n}\nEXPORT_SYMBOL_GPL(of_clk_del_provider);\n\nstatic int devm_clk_provider_match(struct device *dev, void *res, void *data)\n{\n\tstruct device_node **np = res;\n\n\tif (WARN_ON(!np || !*np))\n\t\treturn 0;\n\n\treturn *np == data;\n}\n\n/**\n * devm_of_clk_del_provider() - Remove clock provider registered using devm\n * @dev: Device to whose lifetime the clock provider was bound\n */\nvoid devm_of_clk_del_provider(struct device *dev)\n{\n\tint ret;\n\tstruct device_node *np = get_clk_provider_node(dev);\n\n\tret = devres_release(dev, devm_of_clk_release_provider,\n\t\t\t     devm_clk_provider_match, np);\n\n\tWARN_ON(ret);\n}\nEXPORT_SYMBOL(devm_of_clk_del_provider);\n\n/**\n * of_parse_clkspec() - Parse a DT clock specifier for a given device node\n * @np: device node to parse clock specifier from\n * @index: index of phandle to parse clock out of. If index < 0, @name is used\n * @name: clock name to find and parse. If name is NULL, the index is used\n * @out_args: Result of parsing the clock specifier\n *\n * Parses a device node's \"clocks\" and \"clock-names\" properties to find the\n * phandle and cells for the index or name that is desired. The resulting clock\n * specifier is placed into @out_args, or an errno is returned when there's a\n * parsing error. The @index argument is ignored if @name is non-NULL.\n *\n * Example:\n *\n * phandle1: clock-controller@1 {\n *\t#clock-cells = <2>;\n * }\n *\n * phandle2: clock-controller@2 {\n *\t#clock-cells = <1>;\n * }\n *\n * clock-consumer@3 {\n *\tclocks = <&phandle1 1 2 &phandle2 3>;\n *\tclock-names = \"name1\", \"name2\";\n * }\n *\n * To get a device_node for `clock-controller@2' node you may call this\n * function a few different ways:\n *\n *   of_parse_clkspec(clock-consumer@3, -1, \"name2\", &args);\n *   of_parse_clkspec(clock-consumer@3, 1, NULL, &args);\n *   of_parse_clkspec(clock-consumer@3, 1, \"name2\", &args);\n *\n * Return: 0 upon successfully parsing the clock specifier. Otherwise, -ENOENT\n * if @name is NULL or -EINVAL if @name is non-NULL and it can't be found in\n * the \"clock-names\" property of @np.\n */\nstatic int of_parse_clkspec(const struct device_node *np, int index,\n\t\t\t    const char *name, struct of_phandle_args *out_args)\n{\n\tint ret = -ENOENT;\n\n\t/* Walk up the tree of devices looking for a clock property that matches */\n\twhile (np) {\n\t\t/*\n\t\t * For named clocks, first look up the name in the\n\t\t * \"clock-names\" property.  If it cannot be found, then index\n\t\t * will be an error code and of_parse_phandle_with_args() will\n\t\t * return -EINVAL.\n\t\t */\n\t\tif (name)\n\t\t\tindex = of_property_match_string(np, \"clock-names\", name);\n\t\tret = of_parse_phandle_with_args(np, \"clocks\", \"#clock-cells\",\n\t\t\t\t\t\t index, out_args);\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tif (name && index >= 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * No matching clock found on this node.  If the parent node\n\t\t * has a \"clock-ranges\" property, then we can try one of its\n\t\t * clocks.\n\t\t */\n\t\tnp = np->parent;\n\t\tif (np && !of_get_property(np, \"clock-ranges\", NULL))\n\t\t\tbreak;\n\t\tindex = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic struct clk_hw *\n__of_clk_get_hw_from_provider(struct of_clk_provider *provider,\n\t\t\t      struct of_phandle_args *clkspec)\n{\n\tstruct clk *clk;\n\n\tif (provider->get_hw)\n\t\treturn provider->get_hw(clkspec, provider->data);\n\n\tclk = provider->get(clkspec, provider->data);\n\tif (IS_ERR(clk))\n\t\treturn ERR_CAST(clk);\n\treturn __clk_get_hw(clk);\n}\n\nstatic struct clk_hw *\nof_clk_get_hw_from_clkspec(struct of_phandle_args *clkspec)\n{\n\tstruct of_clk_provider *provider;\n\tstruct clk_hw *hw = ERR_PTR(-EPROBE_DEFER);\n\n\tif (!clkspec)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmutex_lock(&of_clk_mutex);\n\tlist_for_each_entry(provider, &of_clk_providers, link) {\n\t\tif (provider->node == clkspec->np) {\n\t\t\thw = __of_clk_get_hw_from_provider(provider, clkspec);\n\t\t\tif (!IS_ERR(hw))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&of_clk_mutex);\n\n\treturn hw;\n}\n\n/**\n * of_clk_get_from_provider() - Lookup a clock from a clock provider\n * @clkspec: pointer to a clock specifier data structure\n *\n * This function looks up a struct clk from the registered list of clock\n * providers, an input is a clock specifier data structure as returned\n * from the of_parse_phandle_with_args() function call.\n */\nstruct clk *of_clk_get_from_provider(struct of_phandle_args *clkspec)\n{\n\tstruct clk_hw *hw = of_clk_get_hw_from_clkspec(clkspec);\n\n\treturn clk_hw_create_clk(NULL, hw, NULL, __func__);\n}\nEXPORT_SYMBOL_GPL(of_clk_get_from_provider);\n\nstruct clk_hw *of_clk_get_hw(struct device_node *np, int index,\n\t\t\t     const char *con_id)\n{\n\tint ret;\n\tstruct clk_hw *hw;\n\tstruct of_phandle_args clkspec;\n\n\tret = of_parse_clkspec(np, index, con_id, &clkspec);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\thw = of_clk_get_hw_from_clkspec(&clkspec);\n\tof_node_put(clkspec.np);\n\n\treturn hw;\n}\n\nstatic struct clk *__of_clk_get(struct device_node *np,\n\t\t\t\tint index, const char *dev_id,\n\t\t\t\tconst char *con_id)\n{\n\tstruct clk_hw *hw = of_clk_get_hw(np, index, con_id);\n\n\treturn clk_hw_create_clk(NULL, hw, dev_id, con_id);\n}\n\nstruct clk *of_clk_get(struct device_node *np, int index)\n{\n\treturn __of_clk_get(np, index, np->full_name, NULL);\n}\nEXPORT_SYMBOL(of_clk_get);\n\n/**\n * of_clk_get_by_name() - Parse and lookup a clock referenced by a device node\n * @np: pointer to clock consumer node\n * @name: name of consumer's clock input, or NULL for the first clock reference\n *\n * This function parses the clocks and clock-names properties,\n * and uses them to look up the struct clk from the registered list of clock\n * providers.\n */\nstruct clk *of_clk_get_by_name(struct device_node *np, const char *name)\n{\n\tif (!np)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn __of_clk_get(np, 0, np->full_name, name);\n}\nEXPORT_SYMBOL(of_clk_get_by_name);\n\n/**\n * of_clk_get_parent_count() - Count the number of clocks a device node has\n * @np: device node to count\n *\n * Returns: The number of clocks that are possible parents of this node\n */\nunsigned int of_clk_get_parent_count(const struct device_node *np)\n{\n\tint count;\n\n\tcount = of_count_phandle_with_args(np, \"clocks\", \"#clock-cells\");\n\tif (count < 0)\n\t\treturn 0;\n\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(of_clk_get_parent_count);\n\nconst char *of_clk_get_parent_name(const struct device_node *np, int index)\n{\n\tstruct of_phandle_args clkspec;\n\tstruct property *prop;\n\tconst char *clk_name;\n\tconst __be32 *vp;\n\tu32 pv;\n\tint rc;\n\tint count;\n\tstruct clk *clk;\n\n\trc = of_parse_phandle_with_args(np, \"clocks\", \"#clock-cells\", index,\n\t\t\t\t\t&clkspec);\n\tif (rc)\n\t\treturn NULL;\n\n\tindex = clkspec.args_count ? clkspec.args[0] : 0;\n\tcount = 0;\n\n\t/* if there is an indices property, use it to transfer the index\n\t * specified into an array offset for the clock-output-names property.\n\t */\n\tof_property_for_each_u32(clkspec.np, \"clock-indices\", prop, vp, pv) {\n\t\tif (index == pv) {\n\t\t\tindex = count;\n\t\t\tbreak;\n\t\t}\n\t\tcount++;\n\t}\n\t/* We went off the end of 'clock-indices' without finding it */\n\tif (prop && !vp)\n\t\treturn NULL;\n\n\tif (of_property_read_string_index(clkspec.np, \"clock-output-names\",\n\t\t\t\t\t  index,\n\t\t\t\t\t  &clk_name) < 0) {\n\t\t/*\n\t\t * Best effort to get the name if the clock has been\n\t\t * registered with the framework. If the clock isn't\n\t\t * registered, we return the node name as the name of\n\t\t * the clock as long as #clock-cells = 0.\n\t\t */\n\t\tclk = of_clk_get_from_provider(&clkspec);\n\t\tif (IS_ERR(clk)) {\n\t\t\tif (clkspec.args_count == 0)\n\t\t\t\tclk_name = clkspec.np->name;\n\t\t\telse\n\t\t\t\tclk_name = NULL;\n\t\t} else {\n\t\t\tclk_name = __clk_get_name(clk);\n\t\t\tclk_put(clk);\n\t\t}\n\t}\n\n\n\tof_node_put(clkspec.np);\n\treturn clk_name;\n}\nEXPORT_SYMBOL_GPL(of_clk_get_parent_name);\n\n/**\n * of_clk_parent_fill() - Fill @parents with names of @np's parents and return\n * number of parents\n * @np: Device node pointer associated with clock provider\n * @parents: pointer to char array that hold the parents' names\n * @size: size of the @parents array\n *\n * Return: number of parents for the clock node.\n */\nint of_clk_parent_fill(struct device_node *np, const char **parents,\n\t\t       unsigned int size)\n{\n\tunsigned int i = 0;\n\n\twhile (i < size && (parents[i] = of_clk_get_parent_name(np, i)) != NULL)\n\t\ti++;\n\n\treturn i;\n}\nEXPORT_SYMBOL_GPL(of_clk_parent_fill);\n\nstruct clock_provider {\n\tvoid (*clk_init_cb)(struct device_node *);\n\tstruct device_node *np;\n\tstruct list_head node;\n};\n\n/*\n * This function looks for a parent clock. If there is one, then it\n * checks that the provider for this parent clock was initialized, in\n * this case the parent clock will be ready.\n */\nstatic int parent_ready(struct device_node *np)\n{\n\tint i = 0;\n\n\twhile (true) {\n\t\tstruct clk *clk = of_clk_get(np, i);\n\n\t\t/* this parent is ready we can check the next one */\n\t\tif (!IS_ERR(clk)) {\n\t\t\tclk_put(clk);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* at least one parent is not ready, we exit now */\n\t\tif (PTR_ERR(clk) == -EPROBE_DEFER)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Here we make assumption that the device tree is\n\t\t * written correctly. So an error means that there is\n\t\t * no more parent. As we didn't exit yet, then the\n\t\t * previous parent are ready. If there is no clock\n\t\t * parent, no need to wait for them, then we can\n\t\t * consider their absence as being ready\n\t\t */\n\t\treturn 1;\n\t}\n}\n\n/**\n * of_clk_detect_critical() - set CLK_IS_CRITICAL flag from Device Tree\n * @np: Device node pointer associated with clock provider\n * @index: clock index\n * @flags: pointer to top-level framework flags\n *\n * Detects if the clock-critical property exists and, if so, sets the\n * corresponding CLK_IS_CRITICAL flag.\n *\n * Do not use this function. It exists only for legacy Device Tree\n * bindings, such as the one-clock-per-node style that are outdated.\n * Those bindings typically put all clock data into .dts and the Linux\n * driver has no clock data, thus making it impossible to set this flag\n * correctly from the driver. Only those drivers may call\n * of_clk_detect_critical from their setup functions.\n *\n * Return: error code or zero on success\n */\nint of_clk_detect_critical(struct device_node *np, int index,\n\t\t\t   unsigned long *flags)\n{\n\tstruct property *prop;\n\tconst __be32 *cur;\n\tuint32_t idx;\n\n\tif (!np || !flags)\n\t\treturn -EINVAL;\n\n\tof_property_for_each_u32(np, \"clock-critical\", prop, cur, idx)\n\t\tif (index == idx)\n\t\t\t*flags |= CLK_IS_CRITICAL;\n\n\treturn 0;\n}\n\n/**\n * of_clk_init() - Scan and init clock providers from the DT\n * @matches: array of compatible values and init functions for providers.\n *\n * This function scans the device tree for matching clock providers\n * and calls their initialization functions. It also does it by trying\n * to follow the dependencies.\n */\nvoid __init of_clk_init(const struct of_device_id *matches)\n{\n\tconst struct of_device_id *match;\n\tstruct device_node *np;\n\tstruct clock_provider *clk_provider, *next;\n\tbool is_init_done;\n\tbool force = false;\n\tLIST_HEAD(clk_provider_list);\n\n\tif (!matches)\n\t\tmatches = &__clk_of_table;\n\n\t/* First prepare the list of the clocks providers */\n\tfor_each_matching_node_and_match(np, matches, &match) {\n\t\tstruct clock_provider *parent;\n\n\t\tif (!of_device_is_available(np))\n\t\t\tcontinue;\n\n\t\tparent = kzalloc(sizeof(*parent), GFP_KERNEL);\n\t\tif (!parent) {\n\t\t\tlist_for_each_entry_safe(clk_provider, next,\n\t\t\t\t\t\t &clk_provider_list, node) {\n\t\t\t\tlist_del(&clk_provider->node);\n\t\t\t\tof_node_put(clk_provider->np);\n\t\t\t\tkfree(clk_provider);\n\t\t\t}\n\t\t\tof_node_put(np);\n\t\t\treturn;\n\t\t}\n\n\t\tparent->clk_init_cb = match->data;\n\t\tparent->np = of_node_get(np);\n\t\tlist_add_tail(&parent->node, &clk_provider_list);\n\t}\n\n\twhile (!list_empty(&clk_provider_list)) {\n\t\tis_init_done = false;\n\t\tlist_for_each_entry_safe(clk_provider, next,\n\t\t\t\t\t&clk_provider_list, node) {\n\t\t\tif (force || parent_ready(clk_provider->np)) {\n\n\t\t\t\t/* Don't populate platform devices */\n\t\t\t\tof_node_set_flag(clk_provider->np,\n\t\t\t\t\t\t OF_POPULATED);\n\n\t\t\t\tclk_provider->clk_init_cb(clk_provider->np);\n\t\t\t\tof_clk_set_defaults(clk_provider->np, true);\n\n\t\t\t\tlist_del(&clk_provider->node);\n\t\t\t\tof_node_put(clk_provider->np);\n\t\t\t\tkfree(clk_provider);\n\t\t\t\tis_init_done = true;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We didn't manage to initialize any of the\n\t\t * remaining providers during the last loop, so now we\n\t\t * initialize all the remaining ones unconditionally\n\t\t * in case the clock parent was not mandatory\n\t\t */\n\t\tif (!is_init_done)\n\t\t\tforce = true;\n\t}\n}\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 3685}, "message": "warn: passing zero to 'ERR_CAST'"}], "macros": [], "notes": [], "path": "/src/drivers/clk/clk.c", "reportHash": "2f912500b08ad7181caef0d603c4b2a6", "checkerName": "smatch.check_zero_to_err_ptr", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
