<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/mtd/nand/raw/nand_base.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/*\n *  Overview:\n *   This is the generic MTD driver for NAND flash devices. It should be\n *   capable of working with almost all NAND chips currently available.\n *\n *\tAdditional technical information is available on\n *\thttp://www.linux-mtd.infradead.org/doc/nand.html\n *\n *  Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)\n *\t\t  2002-2006 Thomas Gleixner (tglx@linutronix.de)\n *\n *  Credits:\n *\tDavid Woodhouse for adding multichip support\n *\n *\tAleph One Ltd. and Toby Churchill Ltd. for supporting the\n *\trework for 2K page size chips\n *\n *  TODO:\n *\tEnable cached programming for 2k page size chips\n *\tCheck, if mtd->ecctype should be set to MTD_ECC_HW\n *\tif we have HW ECC support.\n *\tBBT table is not serialized, has to be fixed\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/types.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/nand.h>\n#include <linux/mtd/nand-ecc-sw-hamming.h>\n#include <linux/mtd/nand-ecc-sw-bch.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n#include <linux/mtd/partitions.h>\n#include <linux/of.h>\n#include <linux/gpio/consumer.h>\n\n#include \"internals.h\"\n\nstatic int nand_pairing_dist3_get_info(struct mtd_info *mtd, int page,\n\t\t\t\t       struct mtd_pairing_info *info)\n{\n\tint lastpage = (mtd->erasesize / mtd->writesize) - 1;\n\tint dist = 3;\n\n\tif (page == lastpage)\n\t\tdist = 2;\n\n\tif (!page || (page & 1)) {\n\t\tinfo->group = 0;\n\t\tinfo->pair = (page + 1) / 2;\n\t} else {\n\t\tinfo->group = 1;\n\t\tinfo->pair = (page + 1 - dist) / 2;\n\t}\n\n\treturn 0;\n}\n\nstatic int nand_pairing_dist3_get_wunit(struct mtd_info *mtd,\n\t\t\t\t\tconst struct mtd_pairing_info *info)\n{\n\tint lastpair = ((mtd->erasesize / mtd->writesize) - 1) / 2;\n\tint page = info->pair * 2;\n\tint dist = 3;\n\n\tif (!info->group && !info->pair)\n\t\treturn 0;\n\n\tif (info->pair == lastpair && info->group)\n\t\tdist = 2;\n\n\tif (!info->group)\n\t\tpage--;\n\telse if (info->pair)\n\t\tpage += dist - 1;\n\n\tif (page >= mtd->erasesize / mtd->writesize)\n\t\treturn -EINVAL;\n\n\treturn page;\n}\n\nconst struct mtd_pairing_scheme dist3_pairing_scheme = {\n\t.ngroups = 2,\n\t.get_info = nand_pairing_dist3_get_info,\n\t.get_wunit = nand_pairing_dist3_get_wunit,\n};\n\nstatic int check_offs_len(struct nand_chip *chip, loff_t ofs, uint64_t len)\n{\n\tint ret = 0;\n\n\t/* Start address must align on block boundary */\n\tif (ofs & ((1ULL << chip->phys_erase_shift) - 1)) {\n\t\tpr_debug(\"%s: unaligned address\\n\", __func__);\n\t\tret = -EINVAL;\n\t}\n\n\t/* Length must align on block boundary */\n\tif (len & ((1ULL << chip->phys_erase_shift) - 1)) {\n\t\tpr_debug(\"%s: length not block aligned\\n\", __func__);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n/**\n * nand_extract_bits - Copy unaligned bits from one buffer to another one\n * @dst: destination buffer\n * @dst_off: bit offset at which the writing starts\n * @src: source buffer\n * @src_off: bit offset at which the reading starts\n * @nbits: number of bits to copy from @src to @dst\n *\n * Copy bits from one memory region to another (overlap authorized).\n */\nvoid nand_extract_bits(u8 *dst, unsigned int dst_off, const u8 *src,\n\t\t       unsigned int src_off, unsigned int nbits)\n{\n\tunsigned int tmp, n;\n\n\tdst += dst_off / 8;\n\tdst_off %= 8;\n\tsrc += src_off / 8;\n\tsrc_off %= 8;\n\n\twhile (nbits) {\n\t\tn = min3(8 - dst_off, 8 - src_off, nbits);\n\n\t\ttmp = (*src >> src_off) & GENMASK(n - 1, 0);\n\t\t*dst &= ~GENMASK(n - 1 + dst_off, dst_off);\n\t\t*dst |= tmp << dst_off;\n\n\t\tdst_off += n;\n\t\tif (dst_off >= 8) {\n\t\t\tdst++;\n\t\t\tdst_off -= 8;\n\t\t}\n\n\t\tsrc_off += n;\n\t\tif (src_off >= 8) {\n\t\t\tsrc++;\n\t\t\tsrc_off -= 8;\n\t\t}\n\n\t\tnbits -= n;\n\t}\n}\nEXPORT_SYMBOL_GPL(nand_extract_bits);\n\n/**\n * nand_select_target() - Select a NAND target (A.K.A. die)\n * @chip: NAND chip object\n * @cs: the CS line to select. Note that this CS id is always from the chip\n *\tPoV, not the controller one\n *\n * Select a NAND target so that further operations executed on @chip go to the\n * selected NAND target.\n */\nvoid nand_select_target(struct nand_chip *chip, unsigned int cs)\n{\n\t/*\n\t * cs should always lie between 0 and nanddev_ntargets(), when that's\n\t * not the case it's a bug and the caller should be fixed.\n\t */\n\tif (WARN_ON(cs > nanddev_ntargets(&chip->base)))\n\t\treturn;\n\n\tchip->cur_cs = cs;\n\n\tif (chip->legacy.select_chip)\n\t\tchip->legacy.select_chip(chip, cs);\n}\nEXPORT_SYMBOL_GPL(nand_select_target);\n\n/**\n * nand_deselect_target() - Deselect the currently selected target\n * @chip: NAND chip object\n *\n * Deselect the currently selected NAND target. The result of operations\n * executed on @chip after the target has been deselected is undefined.\n */\nvoid nand_deselect_target(struct nand_chip *chip)\n{\n\tif (chip->legacy.select_chip)\n\t\tchip->legacy.select_chip(chip, -1);\n\n\tchip->cur_cs = -1;\n}\nEXPORT_SYMBOL_GPL(nand_deselect_target);\n\n/**\n * nand_release_device - [GENERIC] release chip\n * @chip: NAND chip object\n *\n * Release chip lock and wake up anyone waiting on the device.\n */\nstatic void nand_release_device(struct nand_chip *chip)\n{\n\t/* Release the controller and the chip */\n\tmutex_unlock(&chip->controller->lock);\n\tmutex_unlock(&chip->lock);\n}\n\n/**\n * nand_bbm_get_next_page - Get the next page for bad block markers\n * @chip: NAND chip object\n * @page: First page to start checking for bad block marker usage\n *\n * Returns an integer that corresponds to the page offset within a block, for\n * a page that is used to store bad block markers. If no more pages are\n * available, -EINVAL is returned.\n */\nint nand_bbm_get_next_page(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint last_page = ((mtd->erasesize - mtd->writesize) >>\n\t\t\t chip->page_shift) & chip->pagemask;\n\tunsigned int bbm_flags = NAND_BBM_FIRSTPAGE | NAND_BBM_SECONDPAGE\n\t\t| NAND_BBM_LASTPAGE;\n\n\tif (page == 0 && !(chip->options & bbm_flags))\n\t\treturn 0;\n\tif (page == 0 && chip->options & NAND_BBM_FIRSTPAGE)\n\t\treturn 0;\n\tif (page <= 1 && chip->options & NAND_BBM_SECONDPAGE)\n\t\treturn 1;\n\tif (page <= last_page && chip->options & NAND_BBM_LASTPAGE)\n\t\treturn last_page;\n\n\treturn -EINVAL;\n}\n\n/**\n * nand_block_bad - [DEFAULT] Read bad block marker from the chip\n * @chip: NAND chip object\n * @ofs: offset from device start\n *\n * Check, if the block is bad.\n */\nstatic int nand_block_bad(struct nand_chip *chip, loff_t ofs)\n{\n\tint first_page, page_offset;\n\tint res;\n\tu8 bad;\n\n\tfirst_page = (int)(ofs >> chip->page_shift) & chip->pagemask;\n\tpage_offset = nand_bbm_get_next_page(chip, 0);\n\n\twhile (page_offset >= 0) {\n\t\tres = chip->ecc.read_oob(chip, first_page + page_offset);\n\t\tif (res < 0)\n\t\t\treturn res;\n\n\t\tbad = chip->oob_poi[chip->badblockpos];\n\n\t\tif (likely(chip->badblockbits == 8))\n\t\t\tres = bad != 0xFF;\n\t\telse\n\t\t\tres = hweight8(bad) < chip->badblockbits;\n\t\tif (res)\n\t\t\treturn res;\n\n\t\tpage_offset = nand_bbm_get_next_page(chip, page_offset + 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int nand_isbad_bbm(struct nand_chip *chip, loff_t ofs)\n{\n\tif (chip->options & NAND_NO_BBM_QUIRK)\n\t\treturn 0;\n\n\tif (chip->legacy.block_bad)\n\t\treturn chip->legacy.block_bad(chip, ofs);\n\n\treturn nand_block_bad(chip, ofs);\n}\n\n/**\n * nand_get_device - [GENERIC] Get chip for selected access\n * @chip: NAND chip structure\n *\n * Lock the device and its controller for exclusive access\n *\n * Return: -EBUSY if the chip has been suspended, 0 otherwise\n */\nstatic int nand_get_device(struct nand_chip *chip)\n{\n\tmutex_lock(&chip->lock);\n\tif (chip->suspended) {\n\t\tmutex_unlock(&chip->lock);\n\t\treturn -EBUSY;\n\t}\n\tmutex_lock(&chip->controller->lock);\n\n\treturn 0;\n}\n\n/**\n * nand_check_wp - [GENERIC] check if the chip is write protected\n * @chip: NAND chip object\n *\n * Check, if the device is write protected. The function expects, that the\n * device is already selected.\n */\nstatic int nand_check_wp(struct nand_chip *chip)\n{\n\tu8 status;\n\tint ret;\n\n\t/* Broken xD cards report WP despite being writable */\n\tif (chip->options & NAND_BROKEN_XD)\n\t\treturn 0;\n\n\t/* Check the WP bit */\n\tret = nand_status_op(chip, &status);\n\tif (ret)\n\t\treturn ret;\n\n\treturn status & NAND_STATUS_WP ? 0 : 1;\n}\n\n/**\n * nand_fill_oob - [INTERN] Transfer client buffer to oob\n * @chip: NAND chip object\n * @oob: oob data buffer\n * @len: oob data write length\n * @ops: oob ops structure\n */\nstatic uint8_t *nand_fill_oob(struct nand_chip *chip, uint8_t *oob, size_t len,\n\t\t\t      struct mtd_oob_ops *ops)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\t/*\n\t * Initialise to all 0xFF, to avoid the possibility of left over OOB\n\t * data from a previous OOB read.\n\t */\n\tmemset(chip->oob_poi, 0xff, mtd->oobsize);\n\n\tswitch (ops->mode) {\n\n\tcase MTD_OPS_PLACE_OOB:\n\tcase MTD_OPS_RAW:\n\t\tmemcpy(chip->oob_poi + ops->ooboffs, oob, len);\n\t\treturn oob + len;\n\n\tcase MTD_OPS_AUTO_OOB:\n\t\tret = mtd_ooblayout_set_databytes(mtd, oob, chip->oob_poi,\n\t\t\t\t\t\t  ops->ooboffs, len);\n\t\tBUG_ON(ret);\n\t\treturn oob + len;\n\n\tdefault:\n\t\tBUG();\n\t}\n\treturn NULL;\n}\n\n/**\n * nand_do_write_oob - [MTD Interface] NAND write out-of-band\n * @chip: NAND chip object\n * @to: offset to write to\n * @ops: oob operation description structure\n *\n * NAND write out-of-band.\n */\nstatic int nand_do_write_oob(struct nand_chip *chip, loff_t to,\n\t\t\t     struct mtd_oob_ops *ops)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint chipnr, page, status, len, ret;\n\n\tpr_debug(\"%s: to = 0x%08x, len = %i\\n\",\n\t\t\t __func__, (unsigned int)to, (int)ops->ooblen);\n\n\tlen = mtd_oobavail(mtd, ops);\n\n\t/* Do not allow write past end of page */\n\tif ((ops->ooboffs + ops->ooblen) > len) {\n\t\tpr_debug(\"%s: attempt to write past end of page\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tchipnr = (int)(to >> chip->chip_shift);\n\n\t/*\n\t * Reset the chip. Some chips (like the Toshiba TC5832DC found in one\n\t * of my DiskOnChip 2000 test units) will clear the whole data page too\n\t * if we don't do this. I have no clue why, but I seem to have 'fixed'\n\t * it in the doc2000 driver in August 1999.  dwmw2.\n\t */\n\tret = nand_reset(chip, chipnr);\n\tif (ret)\n\t\treturn ret;\n\n\tnand_select_target(chip, chipnr);\n\n\t/* Shift to get page */\n\tpage = (int)(to >> chip->page_shift);\n\n\t/* Check, if it is write protected */\n\tif (nand_check_wp(chip)) {\n\t\tnand_deselect_target(chip);\n\t\treturn -EROFS;\n\t}\n\n\t/* Invalidate the page cache, if we write to the cached page */\n\tif (page == chip->pagecache.page)\n\t\tchip->pagecache.page = -1;\n\n\tnand_fill_oob(chip, ops->oobbuf, ops->ooblen, ops);\n\n\tif (ops->mode == MTD_OPS_RAW)\n\t\tstatus = chip->ecc.write_oob_raw(chip, page & chip->pagemask);\n\telse\n\t\tstatus = chip->ecc.write_oob(chip, page & chip->pagemask);\n\n\tnand_deselect_target(chip);\n\n\tif (status)\n\t\treturn status;\n\n\tops->oobretlen = ops->ooblen;\n\n\treturn 0;\n}\n\n/**\n * nand_default_block_markbad - [DEFAULT] mark a block bad via bad block marker\n * @chip: NAND chip object\n * @ofs: offset from device start\n *\n * This is the default implementation, which can be overridden by a hardware\n * specific driver. It provides the details for writing a bad block marker to a\n * block.\n */\nstatic int nand_default_block_markbad(struct nand_chip *chip, loff_t ofs)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct mtd_oob_ops ops;\n\tuint8_t buf[2] = { 0, 0 };\n\tint ret = 0, res, page_offset;\n\n\tmemset(&ops, 0, sizeof(ops));\n\tops.oobbuf = buf;\n\tops.ooboffs = chip->badblockpos;\n\tif (chip->options & NAND_BUSWIDTH_16) {\n\t\tops.ooboffs &= ~0x01;\n\t\tops.len = ops.ooblen = 2;\n\t} else {\n\t\tops.len = ops.ooblen = 1;\n\t}\n\tops.mode = MTD_OPS_PLACE_OOB;\n\n\tpage_offset = nand_bbm_get_next_page(chip, 0);\n\n\twhile (page_offset >= 0) {\n\t\tres = nand_do_write_oob(chip,\n\t\t\t\t\tofs + (page_offset * mtd->writesize),\n\t\t\t\t\t&ops);\n\n\t\tif (!ret)\n\t\t\tret = res;\n\n\t\tpage_offset = nand_bbm_get_next_page(chip, page_offset + 1);\n\t}\n\n\treturn ret;\n}\n\n/**\n * nand_markbad_bbm - mark a block by updating the BBM\n * @chip: NAND chip object\n * @ofs: offset of the block to mark bad\n */\nint nand_markbad_bbm(struct nand_chip *chip, loff_t ofs)\n{\n\tif (chip->legacy.block_markbad)\n\t\treturn chip->legacy.block_markbad(chip, ofs);\n\n\treturn nand_default_block_markbad(chip, ofs);\n}\n\n/**\n * nand_block_markbad_lowlevel - mark a block bad\n * @chip: NAND chip object\n * @ofs: offset from device start\n *\n * This function performs the generic NAND bad block marking steps (i.e., bad\n * block table(s) and/or marker(s)). We only allow the hardware driver to\n * specify how to write bad block markers to OOB (chip->legacy.block_markbad).\n *\n * We try operations in the following order:\n *\n *  (1) erase the affected block, to allow OOB marker to be written cleanly\n *  (2) write bad block marker to OOB area of affected block (unless flag\n *      NAND_BBT_NO_OOB_BBM is present)\n *  (3) update the BBT\n *\n * Note that we retain the first error encountered in (2) or (3), finish the\n * procedures, and dump the error in the end.\n*/\nstatic int nand_block_markbad_lowlevel(struct nand_chip *chip, loff_t ofs)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint res, ret = 0;\n\n\tif (!(chip->bbt_options & NAND_BBT_NO_OOB_BBM)) {\n\t\tstruct erase_info einfo;\n\n\t\t/* Attempt erase before marking OOB */\n\t\tmemset(&einfo, 0, sizeof(einfo));\n\t\teinfo.addr = ofs;\n\t\teinfo.len = 1ULL << chip->phys_erase_shift;\n\t\tnand_erase_nand(chip, &einfo, 0);\n\n\t\t/* Write bad block marker to OOB */\n\t\tret = nand_get_device(chip);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = nand_markbad_bbm(chip, ofs);\n\t\tnand_release_device(chip);\n\t}\n\n\t/* Mark block bad in BBT */\n\tif (chip->bbt) {\n\t\tres = nand_markbad_bbt(chip, ofs);\n\t\tif (!ret)\n\t\t\tret = res;\n\t}\n\n\tif (!ret)\n\t\tmtd->ecc_stats.badblocks++;\n\n\treturn ret;\n}\n\n/**\n * nand_block_isreserved - [GENERIC] Check if a block is marked reserved.\n * @mtd: MTD device structure\n * @ofs: offset from device start\n *\n * Check if the block is marked as reserved.\n */\nstatic int nand_block_isreserved(struct mtd_info *mtd, loff_t ofs)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (!chip->bbt)\n\t\treturn 0;\n\t/* Return info from the table */\n\treturn nand_isreserved_bbt(chip, ofs);\n}\n\n/**\n * nand_block_checkbad - [GENERIC] Check if a block is marked bad\n * @chip: NAND chip object\n * @ofs: offset from device start\n * @allowbbt: 1, if its allowed to access the bbt area\n *\n * Check, if the block is bad. Either by reading the bad block table or\n * calling of the scan function.\n */\nstatic int nand_block_checkbad(struct nand_chip *chip, loff_t ofs, int allowbbt)\n{\n\t/* Return info from the table */\n\tif (chip->bbt)\n\t\treturn nand_isbad_bbt(chip, ofs, allowbbt);\n\n\treturn nand_isbad_bbm(chip, ofs);\n}\n\n/**\n * nand_soft_waitrdy - Poll STATUS reg until RDY bit is set to 1\n * @chip: NAND chip structure\n * @timeout_ms: Timeout in ms\n *\n * Poll the STATUS register using ->exec_op() until the RDY bit becomes 1.\n * If that does not happen whitin the specified timeout, -ETIMEDOUT is\n * returned.\n *\n * This helper is intended to be used when the controller does not have access\n * to the NAND R/B pin.\n *\n * Be aware that calling this helper from an ->exec_op() implementation means\n * ->exec_op() must be re-entrant.\n *\n * Return 0 if the NAND chip is ready, a negative error otherwise.\n */\nint nand_soft_waitrdy(struct nand_chip *chip, unsigned long timeout_ms)\n{\n\tconst struct nand_sdr_timings *timings;\n\tu8 status = 0;\n\tint ret;\n\n\tif (!nand_has_exec_op(chip))\n\t\treturn -ENOTSUPP;\n\n\t/* Wait tWB before polling the STATUS reg. */\n\ttimings = nand_get_sdr_timings(nand_get_interface_config(chip));\n\tndelay(PSEC_TO_NSEC(timings->tWB_max));\n\n\tret = nand_status_op(chip, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * +1 below is necessary because if we are now in the last fraction\n\t * of jiffy and msecs_to_jiffies is 1 then we will wait only that\n\t * small jiffy fraction - possibly leading to false timeout\n\t */\n\ttimeout_ms = jiffies + msecs_to_jiffies(timeout_ms) + 1;\n\tdo {\n\t\tret = nand_read_data_op(chip, &status, sizeof(status), true,\n\t\t\t\t\tfalse);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (status & NAND_STATUS_READY)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Typical lowest execution time for a tR on most NANDs is 10us,\n\t\t * use this as polling delay before doing something smarter (ie.\n\t\t * deriving a delay from the timeout value, timeout_ms/ratio).\n\t\t */\n\t\tudelay(10);\n\t} while\t(time_before(jiffies, timeout_ms));\n\n\t/*\n\t * We have to exit READ_STATUS mode in order to read real data on the\n\t * bus in case the WAITRDY instruction is preceding a DATA_IN\n\t * instruction.\n\t */\n\tnand_exit_status_op(chip);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn status & NAND_STATUS_READY ? 0 : -ETIMEDOUT;\n};\nEXPORT_SYMBOL_GPL(nand_soft_waitrdy);\n\n/**\n * nand_gpio_waitrdy - Poll R/B GPIO pin until ready\n * @chip: NAND chip structure\n * @gpiod: GPIO descriptor of R/B pin\n * @timeout_ms: Timeout in ms\n *\n * Poll the R/B GPIO pin until it becomes ready. If that does not happen\n * whitin the specified timeout, -ETIMEDOUT is returned.\n *\n * This helper is intended to be used when the controller has access to the\n * NAND R/B pin over GPIO.\n *\n * Return 0 if the R/B pin indicates chip is ready, a negative error otherwise.\n */\nint nand_gpio_waitrdy(struct nand_chip *chip, struct gpio_desc *gpiod,\n\t\t      unsigned long timeout_ms)\n{\n\n\t/*\n\t * Wait until R/B pin indicates chip is ready or timeout occurs.\n\t * +1 below is necessary because if we are now in the last fraction\n\t * of jiffy and msecs_to_jiffies is 1 then we will wait only that\n\t * small jiffy fraction - possibly leading to false timeout.\n\t */\n\ttimeout_ms = jiffies + msecs_to_jiffies(timeout_ms) + 1;\n\tdo {\n\t\tif (gpiod_get_value_cansleep(gpiod))\n\t\t\treturn 0;\n\n\t\tcond_resched();\n\t} while\t(time_before(jiffies, timeout_ms));\n\n\treturn gpiod_get_value_cansleep(gpiod) ? 0 : -ETIMEDOUT;\n};\nEXPORT_SYMBOL_GPL(nand_gpio_waitrdy);\n\n/**\n * panic_nand_wait - [GENERIC] wait until the command is done\n * @chip: NAND chip structure\n * @timeo: timeout\n *\n * Wait for command done. This is a helper function for nand_wait used when\n * we are in interrupt context. May happen when in panic and trying to write\n * an oops through mtdoops.\n */\nvoid panic_nand_wait(struct nand_chip *chip, unsigned long timeo)\n{\n\tint i;\n\tfor (i = 0; i < timeo; i++) {\n\t\tif (chip->legacy.dev_ready) {\n\t\t\tif (chip->legacy.dev_ready(chip))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tint ret;\n\t\t\tu8 status;\n\n\t\t\tret = nand_read_data_op(chip, &status, sizeof(status),\n\t\t\t\t\t\ttrue, false);\n\t\t\tif (ret)\n\t\t\t\treturn;\n\n\t\t\tif (status & NAND_STATUS_READY)\n\t\t\t\tbreak;\n\t\t}\n\t\tmdelay(1);\n\t}\n}\n\nstatic bool nand_supports_get_features(struct nand_chip *chip, int addr)\n{\n\treturn (chip->parameters.supports_set_get_features &&\n\t\ttest_bit(addr, chip->parameters.get_feature_list));\n}\n\nstatic bool nand_supports_set_features(struct nand_chip *chip, int addr)\n{\n\treturn (chip->parameters.supports_set_get_features &&\n\t\ttest_bit(addr, chip->parameters.set_feature_list));\n}\n\n/**\n * nand_reset_interface - Reset data interface and timings\n * @chip: The NAND chip\n * @chipnr: Internal die id\n *\n * Reset the Data interface and timings to ONFI mode 0.\n *\n * Returns 0 for success or negative error code otherwise.\n */\nstatic int nand_reset_interface(struct nand_chip *chip, int chipnr)\n{\n\tconst struct nand_controller_ops *ops = chip->controller->ops;\n\tint ret;\n\n\tif (!nand_controller_can_setup_interface(chip))\n\t\treturn 0;\n\n\t/*\n\t * The ONFI specification says:\n\t * \"\n\t * To transition from NV-DDR or NV-DDR2 to the SDR data\n\t * interface, the host shall use the Reset (FFh) command\n\t * using SDR timing mode 0. A device in any timing mode is\n\t * required to recognize Reset (FFh) command issued in SDR\n\t * timing mode 0.\n\t * \"\n\t *\n\t * Configure the data interface in SDR mode and set the\n\t * timings to timing mode 0.\n\t */\n\n\tchip->current_interface_config = nand_get_reset_interface_config();\n\tret = ops->setup_interface(chip, chipnr,\n\t\t\t\t   chip->current_interface_config);\n\tif (ret)\n\t\tpr_err(\"Failed to configure data interface to SDR timing mode 0\\n\");\n\n\treturn ret;\n}\n\n/**\n * nand_setup_interface - Setup the best data interface and timings\n * @chip: The NAND chip\n * @chipnr: Internal die id\n *\n * Configure what has been reported to be the best data interface and NAND\n * timings supported by the chip and the driver.\n *\n * Returns 0 for success or negative error code otherwise.\n */\nstatic int nand_setup_interface(struct nand_chip *chip, int chipnr)\n{\n\tconst struct nand_controller_ops *ops = chip->controller->ops;\n\tu8 tmode_param[ONFI_SUBFEATURE_PARAM_LEN] = { };\n\tint ret;\n\n\tif (!nand_controller_can_setup_interface(chip))\n\t\treturn 0;\n\n\t/*\n\t * A nand_reset_interface() put both the NAND chip and the NAND\n\t * controller in timings mode 0. If the default mode for this chip is\n\t * also 0, no need to proceed to the change again. Plus, at probe time,\n\t * nand_setup_interface() uses ->set/get_features() which would\n\t * fail anyway as the parameter page is not available yet.\n\t */\n\tif (!chip->best_interface_config)\n\t\treturn 0;\n\n\ttmode_param[0] = chip->best_interface_config->timings.mode;\n\n\t/* Change the mode on the chip side (if supported by the NAND chip) */\n\tif (nand_supports_set_features(chip, ONFI_FEATURE_ADDR_TIMING_MODE)) {\n\t\tnand_select_target(chip, chipnr);\n\t\tret = nand_set_features(chip, ONFI_FEATURE_ADDR_TIMING_MODE,\n\t\t\t\t\ttmode_param);\n\t\tnand_deselect_target(chip);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Change the mode on the controller side */\n\tret = ops->setup_interface(chip, chipnr, chip->best_interface_config);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Check the mode has been accepted by the chip, if supported */\n\tif (!nand_supports_get_features(chip, ONFI_FEATURE_ADDR_TIMING_MODE))\n\t\tgoto update_interface_config;\n\n\tmemset(tmode_param, 0, ONFI_SUBFEATURE_PARAM_LEN);\n\tnand_select_target(chip, chipnr);\n\tret = nand_get_features(chip, ONFI_FEATURE_ADDR_TIMING_MODE,\n\t\t\t\ttmode_param);\n\tnand_deselect_target(chip);\n\tif (ret)\n\t\tgoto err_reset_chip;\n\n\tif (tmode_param[0] != chip->best_interface_config->timings.mode) {\n\t\tpr_warn(\"timing mode %d not acknowledged by the NAND chip\\n\",\n\t\t\tchip->best_interface_config->timings.mode);\n\t\tgoto err_reset_chip;\n\t}\n\nupdate_interface_config:\n\tchip->current_interface_config = chip->best_interface_config;\n\n\treturn 0;\n\nerr_reset_chip:\n\t/*\n\t * Fallback to mode 0 if the chip explicitly did not ack the chosen\n\t * timing mode.\n\t */\n\tnand_reset_interface(chip, chipnr);\n\tnand_select_target(chip, chipnr);\n\tnand_reset_op(chip);\n\tnand_deselect_target(chip);\n\n\treturn ret;\n}\n\n/**\n * nand_choose_best_sdr_timings - Pick up the best SDR timings that both the\n *                                NAND controller and the NAND chip support\n * @chip: the NAND chip\n * @iface: the interface configuration (can eventually be updated)\n * @spec_timings: specific timings, when not fitting the ONFI specification\n *\n * If specific timings are provided, use them. Otherwise, retrieve supported\n * timing modes from ONFI information.\n */\nint nand_choose_best_sdr_timings(struct nand_chip *chip,\n\t\t\t\t struct nand_interface_config *iface,\n\t\t\t\t struct nand_sdr_timings *spec_timings)\n{\n\tconst struct nand_controller_ops *ops = chip->controller->ops;\n\tint best_mode = 0, mode, ret;\n\n\tiface->type = NAND_SDR_IFACE;\n\n\tif (spec_timings) {\n\t\tiface->timings.sdr = *spec_timings;\n\t\tiface->timings.mode = onfi_find_closest_sdr_mode(spec_timings);\n\n\t\t/* Verify the controller supports the requested interface */\n\t\tret = ops->setup_interface(chip, NAND_DATA_IFACE_CHECK_ONLY,\n\t\t\t\t\t   iface);\n\t\tif (!ret) {\n\t\t\tchip->best_interface_config = iface;\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* Fallback to slower modes */\n\t\tbest_mode = iface->timings.mode;\n\t} else if (chip->parameters.onfi) {\n\t\tbest_mode = fls(chip->parameters.onfi->async_timing_mode) - 1;\n\t}\n\n\tfor (mode = best_mode; mode >= 0; mode--) {\n\t\tonfi_fill_interface_config(chip, iface, NAND_SDR_IFACE, mode);\n\n\t\tret = ops->setup_interface(chip, NAND_DATA_IFACE_CHECK_ONLY,\n\t\t\t\t\t   iface);\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\n\tchip->best_interface_config = iface;\n\n\treturn 0;\n}\n\n/**\n * nand_choose_interface_config - find the best data interface and timings\n * @chip: The NAND chip\n *\n * Find the best data interface and NAND timings supported by the chip\n * and the driver. Eventually let the NAND manufacturer driver propose his own\n * set of timings.\n *\n * After this function nand_chip->interface_config is initialized with the best\n * timing mode available.\n *\n * Returns 0 for success or negative error code otherwise.\n */\nstatic int nand_choose_interface_config(struct nand_chip *chip)\n{\n\tstruct nand_interface_config *iface;\n\tint ret;\n\n\tif (!nand_controller_can_setup_interface(chip))\n\t\treturn 0;\n\n\tiface = kzalloc(sizeof(*iface), GFP_KERNEL);\n\tif (!iface)\n\t\treturn -ENOMEM;\n\n\tif (chip->ops.choose_interface_config)\n\t\tret = chip->ops.choose_interface_config(chip, iface);\n\telse\n\t\tret = nand_choose_best_sdr_timings(chip, iface, NULL);\n\n\tif (ret)\n\t\tkfree(iface);\n\n\treturn ret;\n}\n\n/**\n * nand_fill_column_cycles - fill the column cycles of an address\n * @chip: The NAND chip\n * @addrs: Array of address cycles to fill\n * @offset_in_page: The offset in the page\n *\n * Fills the first or the first two bytes of the @addrs field depending\n * on the NAND bus width and the page size.\n *\n * Returns the number of cycles needed to encode the column, or a negative\n * error code in case one of the arguments is invalid.\n */\nstatic int nand_fill_column_cycles(struct nand_chip *chip, u8 *addrs,\n\t\t\t\t   unsigned int offset_in_page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\t/* Make sure the offset is less than the actual page size. */\n\tif (offset_in_page > mtd->writesize + mtd->oobsize)\n\t\treturn -EINVAL;\n\n\t/*\n\t * On small page NANDs, there's a dedicated command to access the OOB\n\t * area, and the column address is relative to the start of the OOB\n\t * area, not the start of the page. Asjust the address accordingly.\n\t */\n\tif (mtd->writesize <= 512 && offset_in_page >= mtd->writesize)\n\t\toffset_in_page -= mtd->writesize;\n\n\t/*\n\t * The offset in page is expressed in bytes, if the NAND bus is 16-bit\n\t * wide, then it must be divided by 2.\n\t */\n\tif (chip->options & NAND_BUSWIDTH_16) {\n\t\tif (WARN_ON(offset_in_page % 2))\n\t\t\treturn -EINVAL;\n\n\t\toffset_in_page /= 2;\n\t}\n\n\taddrs[0] = offset_in_page;\n\n\t/*\n\t * Small page NANDs use 1 cycle for the columns, while large page NANDs\n\t * need 2\n\t */\n\tif (mtd->writesize <= 512)\n\t\treturn 1;\n\n\taddrs[1] = offset_in_page >> 8;\n\n\treturn 2;\n}\n\nstatic int nand_sp_exec_read_page_op(struct nand_chip *chip, unsigned int page,\n\t\t\t\t     unsigned int offset_in_page, void *buf,\n\t\t\t\t     unsigned int len)\n{\n\tconst struct nand_sdr_timings *sdr =\n\t\tnand_get_sdr_timings(nand_get_interface_config(chip));\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tu8 addrs[4];\n\tstruct nand_op_instr instrs[] = {\n\t\tNAND_OP_CMD(NAND_CMD_READ0, 0),\n\t\tNAND_OP_ADDR(3, addrs, PSEC_TO_NSEC(sdr->tWB_max)),\n\t\tNAND_OP_WAIT_RDY(PSEC_TO_MSEC(sdr->tR_max),\n\t\t\t\t PSEC_TO_NSEC(sdr->tRR_min)),\n\t\tNAND_OP_DATA_IN(len, buf, 0),\n\t};\n\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\tint ret;\n\n\t/* Drop the DATA_IN instruction if len is set to 0. */\n\tif (!len)\n\t\top.ninstrs--;\n\n\tif (offset_in_page >= mtd->writesize)\n\t\tinstrs[0].ctx.cmd.opcode = NAND_CMD_READOOB;\n\telse if (offset_in_page >= 256 &&\n\t\t !(chip->options & NAND_BUSWIDTH_16))\n\t\tinstrs[0].ctx.cmd.opcode = NAND_CMD_READ1;\n\n\tret = nand_fill_column_cycles(chip, addrs, offset_in_page);\n\tif (ret < 0)\n\t\treturn ret;\n\n\taddrs[1] = page;\n\taddrs[2] = page >> 8;\n\n\tif (chip->options & NAND_ROW_ADDR_3) {\n\t\taddrs[3] = page >> 16;\n\t\tinstrs[1].ctx.addr.naddrs++;\n\t}\n\n\treturn nand_exec_op(chip, &op);\n}\n\nstatic int nand_lp_exec_read_page_op(struct nand_chip *chip, unsigned int page,\n\t\t\t\t     unsigned int offset_in_page, void *buf,\n\t\t\t\t     unsigned int len)\n{\n\tconst struct nand_sdr_timings *sdr =\n\t\tnand_get_sdr_timings(nand_get_interface_config(chip));\n\tu8 addrs[5];\n\tstruct nand_op_instr instrs[] = {\n\t\tNAND_OP_CMD(NAND_CMD_READ0, 0),\n\t\tNAND_OP_ADDR(4, addrs, 0),\n\t\tNAND_OP_CMD(NAND_CMD_READSTART, PSEC_TO_NSEC(sdr->tWB_max)),\n\t\tNAND_OP_WAIT_RDY(PSEC_TO_MSEC(sdr->tR_max),\n\t\t\t\t PSEC_TO_NSEC(sdr->tRR_min)),\n\t\tNAND_OP_DATA_IN(len, buf, 0),\n\t};\n\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\tint ret;\n\n\t/* Drop the DATA_IN instruction if len is set to 0. */\n\tif (!len)\n\t\top.ninstrs--;\n\n\tret = nand_fill_column_cycles(chip, addrs, offset_in_page);\n\tif (ret < 0)\n\t\treturn ret;\n\n\taddrs[2] = page;\n\taddrs[3] = page >> 8;\n\n\tif (chip->options & NAND_ROW_ADDR_3) {\n\t\taddrs[4] = page >> 16;\n\t\tinstrs[1].ctx.addr.naddrs++;\n\t}\n\n\treturn nand_exec_op(chip, &op);\n}\n\n/**\n * nand_read_page_op - Do a READ PAGE operation\n * @chip: The NAND chip\n * @page: page to read\n * @offset_in_page: offset within the page\n * @buf: buffer used to store the data\n * @len: length of the buffer\n *\n * This function issues a READ PAGE operation.\n * This function does not select/unselect the CS line.\n *\n * Returns 0 on success, a negative error code otherwise.\n */\nint nand_read_page_op(struct nand_chip *chip, unsigned int page,\n\t\t      unsigned int offset_in_page, void *buf, unsigned int len)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tif (len && !buf)\n\t\treturn -EINVAL;\n\n\tif (offset_in_page + len > mtd->writesize + mtd->oobsize)\n\t\treturn -EINVAL;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tif (mtd->writesize > 512)\n\t\t\treturn nand_lp_exec_read_page_op(chip, page,\n\t\t\t\t\t\t\t offset_in_page, buf,\n\t\t\t\t\t\t\t len);\n\n\t\treturn nand_sp_exec_read_page_op(chip, page, offset_in_page,\n\t\t\t\t\t\t buf, len);\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_READ0, offset_in_page, page);\n\tif (len)\n\t\tchip->legacy.read_buf(chip, buf, len);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_read_page_op);\n\n/**\n * nand_read_param_page_op - Do a READ PARAMETER PAGE operation\n * @chip: The NAND chip\n * @page: parameter page to read\n * @buf: buffer used to store the data\n * @len: length of the buffer\n *\n * This function issues a READ PARAMETER PAGE operation.\n * This function does not select/unselect the CS line.\n *\n * Returns 0 on success, a negative error code otherwise.\n */\nint nand_read_param_page_op(struct nand_chip *chip, u8 page, void *buf,\n\t\t\t    unsigned int len)\n{\n\tunsigned int i;\n\tu8 *p = buf;\n\n\tif (len && !buf)\n\t\treturn -EINVAL;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_sdr_timings *sdr =\n\t\t\tnand_get_sdr_timings(nand_get_interface_config(chip));\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_PARAM, 0),\n\t\t\tNAND_OP_ADDR(1, &page, PSEC_TO_NSEC(sdr->tWB_max)),\n\t\t\tNAND_OP_WAIT_RDY(PSEC_TO_MSEC(sdr->tR_max),\n\t\t\t\t\t PSEC_TO_NSEC(sdr->tRR_min)),\n\t\t\tNAND_OP_8BIT_DATA_IN(len, buf, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\t/* Drop the DATA_IN instruction if len is set to 0. */\n\t\tif (!len)\n\t\t\top.ninstrs--;\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_PARAM, page, -1);\n\tfor (i = 0; i < len; i++)\n\t\tp[i] = chip->legacy.read_byte(chip);\n\n\treturn 0;\n}\n\n/**\n * nand_change_read_column_op - Do a CHANGE READ COLUMN operation\n * @chip: The NAND chip\n * @offset_in_page: offset within the page\n * @buf: buffer used to store the data\n * @len: length of the buffer\n * @force_8bit: force 8-bit bus access\n *\n * This function issues a CHANGE READ COLUMN operation.\n * This function does not select/unselect the CS line.\n *\n * Returns 0 on success, a negative error code otherwise.\n */\nint nand_change_read_column_op(struct nand_chip *chip,\n\t\t\t       unsigned int offset_in_page, void *buf,\n\t\t\t       unsigned int len, bool force_8bit)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tif (len && !buf)\n\t\treturn -EINVAL;\n\n\tif (offset_in_page + len > mtd->writesize + mtd->oobsize)\n\t\treturn -EINVAL;\n\n\t/* Small page NANDs do not support column change. */\n\tif (mtd->writesize <= 512)\n\t\treturn -ENOTSUPP;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_sdr_timings *sdr =\n\t\t\tnand_get_sdr_timings(nand_get_interface_config(chip));\n\t\tu8 addrs[2] = {};\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_RNDOUT, 0),\n\t\t\tNAND_OP_ADDR(2, addrs, 0),\n\t\t\tNAND_OP_CMD(NAND_CMD_RNDOUTSTART,\n\t\t\t\t    PSEC_TO_NSEC(sdr->tCCS_min)),\n\t\t\tNAND_OP_DATA_IN(len, buf, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\t\tint ret;\n\n\t\tret = nand_fill_column_cycles(chip, addrs, offset_in_page);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t/* Drop the DATA_IN instruction if len is set to 0. */\n\t\tif (!len)\n\t\t\top.ninstrs--;\n\n\t\tinstrs[3].ctx.data.force_8bit = force_8bit;\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_RNDOUT, offset_in_page, -1);\n\tif (len)\n\t\tchip->legacy.read_buf(chip, buf, len);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_change_read_column_op);\n\n/**\n * nand_read_oob_op - Do a READ OOB operation\n * @chip: The NAND chip\n * @page: page to read\n * @offset_in_oob: offset within the OOB area\n * @buf: buffer used to store the data\n * @len: length of the buffer\n *\n * This function issues a READ OOB operation.\n * This function does not select/unselect the CS line.\n *\n * Returns 0 on success, a negative error code otherwise.\n */\nint nand_read_oob_op(struct nand_chip *chip, unsigned int page,\n\t\t     unsigned int offset_in_oob, void *buf, unsigned int len)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tif (len && !buf)\n\t\treturn -EINVAL;\n\n\tif (offset_in_oob + len > mtd->oobsize)\n\t\treturn -EINVAL;\n\n\tif (nand_has_exec_op(chip))\n\t\treturn nand_read_page_op(chip, page,\n\t\t\t\t\t mtd->writesize + offset_in_oob,\n\t\t\t\t\t buf, len);\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_READOOB, offset_in_oob, page);\n\tif (len)\n\t\tchip->legacy.read_buf(chip, buf, len);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_read_oob_op);\n\nstatic int nand_exec_prog_page_op(struct nand_chip *chip, unsigned int page,\n\t\t\t\t  unsigned int offset_in_page, const void *buf,\n\t\t\t\t  unsigned int len, bool prog)\n{\n\tconst struct nand_sdr_timings *sdr =\n\t\tnand_get_sdr_timings(nand_get_interface_config(chip));\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tu8 addrs[5] = {};\n\tstruct nand_op_instr instrs[] = {\n\t\t/*\n\t\t * The first instruction will be dropped if we're dealing\n\t\t * with a large page NAND and adjusted if we're dealing\n\t\t * with a small page NAND and the page offset is > 255.\n\t\t */\n\t\tNAND_OP_CMD(NAND_CMD_READ0, 0),\n\t\tNAND_OP_CMD(NAND_CMD_SEQIN, 0),\n\t\tNAND_OP_ADDR(0, addrs, PSEC_TO_NSEC(sdr->tADL_min)),\n\t\tNAND_OP_DATA_OUT(len, buf, 0),\n\t\tNAND_OP_CMD(NAND_CMD_PAGEPROG, PSEC_TO_NSEC(sdr->tWB_max)),\n\t\tNAND_OP_WAIT_RDY(PSEC_TO_MSEC(sdr->tPROG_max), 0),\n\t};\n\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\tint naddrs = nand_fill_column_cycles(chip, addrs, offset_in_page);\n\n\tif (naddrs < 0)\n\t\treturn naddrs;\n\n\taddrs[naddrs++] = page;\n\taddrs[naddrs++] = page >> 8;\n\tif (chip->options & NAND_ROW_ADDR_3)\n\t\taddrs[naddrs++] = page >> 16;\n\n\tinstrs[2].ctx.addr.naddrs = naddrs;\n\n\t/* Drop the last two instructions if we're not programming the page. */\n\tif (!prog) {\n\t\top.ninstrs -= 2;\n\t\t/* Also drop the DATA_OUT instruction if empty. */\n\t\tif (!len)\n\t\t\top.ninstrs--;\n\t}\n\n\tif (mtd->writesize <= 512) {\n\t\t/*\n\t\t * Small pages need some more tweaking: we have to adjust the\n\t\t * first instruction depending on the page offset we're trying\n\t\t * to access.\n\t\t */\n\t\tif (offset_in_page >= mtd->writesize)\n\t\t\tinstrs[0].ctx.cmd.opcode = NAND_CMD_READOOB;\n\t\telse if (offset_in_page >= 256 &&\n\t\t\t !(chip->options & NAND_BUSWIDTH_16))\n\t\t\tinstrs[0].ctx.cmd.opcode = NAND_CMD_READ1;\n\t} else {\n\t\t/*\n\t\t * Drop the first command if we're dealing with a large page\n\t\t * NAND.\n\t\t */\n\t\top.instrs++;\n\t\top.ninstrs--;\n\t}\n\n\treturn nand_exec_op(chip, &op);\n}\n\n/**\n * nand_prog_page_begin_op - starts a PROG PAGE operation\n * @chip: The NAND chip\n * @page: page to write\n * @offset_in_page: offset within the page\n * @buf: buffer containing the data to write to the page\n * @len: length of the buffer\n *\n * This function issues the first half of a PROG PAGE operation.\n * This function does not select/unselect the CS line.\n *\n * Returns 0 on success, a negative error code otherwise.\n */\nint nand_prog_page_begin_op(struct nand_chip *chip, unsigned int page,\n\t\t\t    unsigned int offset_in_page, const void *buf,\n\t\t\t    unsigned int len)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tif (len && !buf)\n\t\treturn -EINVAL;\n\n\tif (offset_in_page + len > mtd->writesize + mtd->oobsize)\n\t\treturn -EINVAL;\n\n\tif (nand_has_exec_op(chip))\n\t\treturn nand_exec_prog_page_op(chip, page, offset_in_page, buf,\n\t\t\t\t\t      len, false);\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_SEQIN, offset_in_page, page);\n\n\tif (buf)\n\t\tchip->legacy.write_buf(chip, buf, len);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_prog_page_begin_op);\n\n/**\n * nand_prog_page_end_op - ends a PROG PAGE operation\n * @chip: The NAND chip\n *\n * This function issues the second half of a PROG PAGE operation.\n * This function does not select/unselect the CS line.\n *\n * Returns 0 on success, a negative error code otherwise.\n */\nint nand_prog_page_end_op(struct nand_chip *chip)\n{\n\tint ret;\n\tu8 status;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_sdr_timings *sdr =\n\t\t\tnand_get_sdr_timings(nand_get_interface_config(chip));\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_PAGEPROG,\n\t\t\t\t    PSEC_TO_NSEC(sdr->tWB_max)),\n\t\t\tNAND_OP_WAIT_RDY(PSEC_TO_MSEC(sdr->tPROG_max), 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\tret = nand_exec_op(chip, &op);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = nand_status_op(chip, &status);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tchip->legacy.cmdfunc(chip, NAND_CMD_PAGEPROG, -1, -1);\n\t\tret = chip->legacy.waitfunc(chip);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tstatus = ret;\n\t}\n\n\tif (status & NAND_STATUS_FAIL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_prog_page_end_op);\n\n/**\n * nand_prog_page_op - Do a full PROG PAGE operation\n * @chip: The NAND chip\n * @page: page to write\n * @offset_in_page: offset within the page\n * @buf: buffer containing the data to write to the page\n * @len: length of the buffer\n *\n * This function issues a full PROG PAGE operation.\n * This function does not select/unselect the CS line.\n *\n * Returns 0 on success, a negative error code otherwise.\n */\nint nand_prog_page_op(struct nand_chip *chip, unsigned int page,\n\t\t      unsigned int offset_in_page, const void *buf,\n\t\t      unsigned int len)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tu8 status;\n\tint ret;\n\n\tif (!len || !buf)\n\t\treturn -EINVAL;\n\n\tif (offset_in_page + len > mtd->writesize + mtd->oobsize)\n\t\treturn -EINVAL;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tret = nand_exec_prog_page_op(chip, page, offset_in_page, buf,\n\t\t\t\t\t\tlen, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = nand_status_op(chip, &status);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tchip->legacy.cmdfunc(chip, NAND_CMD_SEQIN, offset_in_page,\n\t\t\t\t     page);\n\t\tchip->legacy.write_buf(chip, buf, len);\n\t\tchip->legacy.cmdfunc(chip, NAND_CMD_PAGEPROG, -1, -1);\n\t\tstatus = chip->legacy.waitfunc(chip);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\tif (status & NAND_STATUS_FAIL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_prog_page_op);\n\n/**\n * nand_change_write_column_op - Do a CHANGE WRITE COLUMN operation\n * @chip: The NAND chip\n * @offset_in_page: offset within the page\n * @buf: buffer containing the data to send to the NAND\n * @len: length of the buffer\n * @force_8bit: force 8-bit bus access\n *\n * This function issues a CHANGE WRITE COLUMN operation.\n * This function does not select/unselect the CS line.\n *\n * Returns 0 on success, a negative error code otherwise.\n */\nint nand_change_write_column_op(struct nand_chip *chip,\n\t\t\t\tunsigned int offset_in_page,\n\t\t\t\tconst void *buf, unsigned int len,\n\t\t\t\tbool force_8bit)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tif (len && !buf)\n\t\treturn -EINVAL;\n\n\tif (offset_in_page + len > mtd->writesize + mtd->oobsize)\n\t\treturn -EINVAL;\n\n\t/* Small page NANDs do not support column change. */\n\tif (mtd->writesize <= 512)\n\t\treturn -ENOTSUPP;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_sdr_timings *sdr =\n\t\t\tnand_get_sdr_timings(nand_get_interface_config(chip));\n\t\tu8 addrs[2];\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_RNDIN, 0),\n\t\t\tNAND_OP_ADDR(2, addrs, PSEC_TO_NSEC(sdr->tCCS_min)),\n\t\t\tNAND_OP_DATA_OUT(len, buf, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\t\tint ret;\n\n\t\tret = nand_fill_column_cycles(chip, addrs, offset_in_page);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tinstrs[2].ctx.data.force_8bit = force_8bit;\n\n\t\t/* Drop the DATA_OUT instruction if len is set to 0. */\n\t\tif (!len)\n\t\t\top.ninstrs--;\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_RNDIN, offset_in_page, -1);\n\tif (len)\n\t\tchip->legacy.write_buf(chip, buf, len);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_change_write_column_op);\n\n/**\n * nand_readid_op - Do a READID operation\n * @chip: The NAND chip\n * @addr: address cycle to pass after the READID command\n * @buf: buffer used to store the ID\n * @len: length of the buffer\n *\n * This function sends a READID command and reads back the ID returned by the\n * NAND.\n * This function does not select/unselect the CS line.\n *\n * Returns 0 on success, a negative error code otherwise.\n */\nint nand_readid_op(struct nand_chip *chip, u8 addr, void *buf,\n\t\t   unsigned int len)\n{\n\tunsigned int i;\n\tu8 *id = buf;\n\n\tif (len && !buf)\n\t\treturn -EINVAL;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_sdr_timings *sdr =\n\t\t\tnand_get_sdr_timings(nand_get_interface_config(chip));\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_READID, 0),\n\t\t\tNAND_OP_ADDR(1, &addr, PSEC_TO_NSEC(sdr->tADL_min)),\n\t\t\tNAND_OP_8BIT_DATA_IN(len, buf, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\t/* Drop the DATA_IN instruction if len is set to 0. */\n\t\tif (!len)\n\t\t\top.ninstrs--;\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_READID, addr, -1);\n\n\tfor (i = 0; i < len; i++)\n\t\tid[i] = chip->legacy.read_byte(chip);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_readid_op);\n\n/**\n * nand_status_op - Do a STATUS operation\n * @chip: The NAND chip\n * @status: out variable to store the NAND status\n *\n * This function sends a STATUS command and reads back the status returned by\n * the NAND.\n * This function does not select/unselect the CS line.\n *\n * Returns 0 on success, a negative error code otherwise.\n */\nint nand_status_op(struct nand_chip *chip, u8 *status)\n{\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_sdr_timings *sdr =\n\t\t\tnand_get_sdr_timings(nand_get_interface_config(chip));\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_STATUS,\n\t\t\t\t    PSEC_TO_NSEC(sdr->tADL_min)),\n\t\t\tNAND_OP_8BIT_DATA_IN(1, status, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\tif (!status)\n\t\t\top.ninstrs--;\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_STATUS, -1, -1);\n\tif (status)\n\t\t*status = chip->legacy.read_byte(chip);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_status_op);\n\n/**\n * nand_exit_status_op - Exit a STATUS operation\n * @chip: The NAND chip\n *\n * This function sends a READ0 command to cancel the effect of the STATUS\n * command to avoid reading only the status until a new read command is sent.\n *\n * This function does not select/unselect the CS line.\n *\n * Returns 0 on success, a negative error code otherwise.\n */\nint nand_exit_status_op(struct nand_chip *chip)\n{\n\tif (nand_has_exec_op(chip)) {\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_READ0, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_READ0, -1, -1);\n\n\treturn 0;\n}\n\n/**\n * nand_erase_op - Do an erase operation\n * @chip: The NAND chip\n * @eraseblock: block to erase\n *\n * This function sends an ERASE command and waits for the NAND to be ready\n * before returning.\n * This function does not select/unselect the CS line.\n *\n * Returns 0 on success, a negative error code otherwise.\n */\nint nand_erase_op(struct nand_chip *chip, unsigned int eraseblock)\n{\n\tunsigned int page = eraseblock <<\n\t\t\t    (chip->phys_erase_shift - chip->page_shift);\n\tint ret;\n\tu8 status;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_sdr_timings *sdr =\n\t\t\tnand_get_sdr_timings(nand_get_interface_config(chip));\n\t\tu8 addrs[3] = {\tpage, page >> 8, page >> 16 };\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_ERASE1, 0),\n\t\t\tNAND_OP_ADDR(2, addrs, 0),\n\t\t\tNAND_OP_CMD(NAND_CMD_ERASE2,\n\t\t\t\t    PSEC_TO_MSEC(sdr->tWB_max)),\n\t\t\tNAND_OP_WAIT_RDY(PSEC_TO_MSEC(sdr->tBERS_max), 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\tif (chip->options & NAND_ROW_ADDR_3)\n\t\t\tinstrs[1].ctx.addr.naddrs++;\n\n\t\tret = nand_exec_op(chip, &op);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = nand_status_op(chip, &status);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tchip->legacy.cmdfunc(chip, NAND_CMD_ERASE1, -1, page);\n\t\tchip->legacy.cmdfunc(chip, NAND_CMD_ERASE2, -1, -1);\n\n\t\tret = chip->legacy.waitfunc(chip);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tstatus = ret;\n\t}\n\n\tif (status & NAND_STATUS_FAIL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_erase_op);\n\n/**\n * nand_set_features_op - Do a SET FEATURES operation\n * @chip: The NAND chip\n * @feature: feature id\n * @data: 4 bytes of data\n *\n * This function sends a SET FEATURES command and waits for the NAND to be\n * ready before returning.\n * This function does not select/unselect the CS line.\n *\n * Returns 0 on success, a negative error code otherwise.\n */\nstatic int nand_set_features_op(struct nand_chip *chip, u8 feature,\n\t\t\t\tconst void *data)\n{\n\tconst u8 *params = data;\n\tint i, ret;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_sdr_timings *sdr =\n\t\t\tnand_get_sdr_timings(nand_get_interface_config(chip));\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_SET_FEATURES, 0),\n\t\t\tNAND_OP_ADDR(1, &feature, PSEC_TO_NSEC(sdr->tADL_min)),\n\t\t\tNAND_OP_8BIT_DATA_OUT(ONFI_SUBFEATURE_PARAM_LEN, data,\n\t\t\t\t\t      PSEC_TO_NSEC(sdr->tWB_max)),\n\t\t\tNAND_OP_WAIT_RDY(PSEC_TO_MSEC(sdr->tFEAT_max), 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_SET_FEATURES, feature, -1);\n\tfor (i = 0; i < ONFI_SUBFEATURE_PARAM_LEN; ++i)\n\t\tchip->legacy.write_byte(chip, params[i]);\n\n\tret = chip->legacy.waitfunc(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & NAND_STATUS_FAIL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n/**\n * nand_get_features_op - Do a GET FEATURES operation\n * @chip: The NAND chip\n * @feature: feature id\n * @data: 4 bytes of data\n *\n * This function sends a GET FEATURES command and waits for the NAND to be\n * ready before returning.\n * This function does not select/unselect the CS line.\n *\n * Returns 0 on success, a negative error code otherwise.\n */\nstatic int nand_get_features_op(struct nand_chip *chip, u8 feature,\n\t\t\t\tvoid *data)\n{\n\tu8 *params = data;\n\tint i;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_sdr_timings *sdr =\n\t\t\tnand_get_sdr_timings(nand_get_interface_config(chip));\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_GET_FEATURES, 0),\n\t\t\tNAND_OP_ADDR(1, &feature, PSEC_TO_NSEC(sdr->tWB_max)),\n\t\t\tNAND_OP_WAIT_RDY(PSEC_TO_MSEC(sdr->tFEAT_max),\n\t\t\t\t\t PSEC_TO_NSEC(sdr->tRR_min)),\n\t\t\tNAND_OP_8BIT_DATA_IN(ONFI_SUBFEATURE_PARAM_LEN,\n\t\t\t\t\t     data, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_GET_FEATURES, feature, -1);\n\tfor (i = 0; i < ONFI_SUBFEATURE_PARAM_LEN; ++i)\n\t\tparams[i] = chip->legacy.read_byte(chip);\n\n\treturn 0;\n}\n\nstatic int nand_wait_rdy_op(struct nand_chip *chip, unsigned int timeout_ms,\n\t\t\t    unsigned int delay_ns)\n{\n\tif (nand_has_exec_op(chip)) {\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_WAIT_RDY(PSEC_TO_MSEC(timeout_ms),\n\t\t\t\t\t PSEC_TO_NSEC(delay_ns)),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\t/* Apply delay or wait for ready/busy pin */\n\tif (!chip->legacy.dev_ready)\n\t\tudelay(chip->legacy.chip_delay);\n\telse\n\t\tnand_wait_ready(chip);\n\n\treturn 0;\n}\n\n/**\n * nand_reset_op - Do a reset operation\n * @chip: The NAND chip\n *\n * This function sends a RESET command and waits for the NAND to be ready\n * before returning.\n * This function does not select/unselect the CS line.\n *\n * Returns 0 on success, a negative error code otherwise.\n */\nint nand_reset_op(struct nand_chip *chip)\n{\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_sdr_timings *sdr =\n\t\t\tnand_get_sdr_timings(nand_get_interface_config(chip));\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_RESET, PSEC_TO_NSEC(sdr->tWB_max)),\n\t\t\tNAND_OP_WAIT_RDY(PSEC_TO_MSEC(sdr->tRST_max), 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_RESET, -1, -1);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_reset_op);\n\n/**\n * nand_read_data_op - Read data from the NAND\n * @chip: The NAND chip\n * @buf: buffer used to store the data\n * @len: length of the buffer\n * @force_8bit: force 8-bit bus access\n * @check_only: do not actually run the command, only checks if the\n *              controller driver supports it\n *\n * This function does a raw data read on the bus. Usually used after launching\n * another NAND operation like nand_read_page_op().\n * This function does not select/unselect the CS line.\n *\n * Returns 0 on success, a negative error code otherwise.\n */\nint nand_read_data_op(struct nand_chip *chip, void *buf, unsigned int len,\n\t\t      bool force_8bit, bool check_only)\n{\n\tif (!len || !buf)\n\t\treturn -EINVAL;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_DATA_IN(len, buf, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\tinstrs[0].ctx.data.force_8bit = force_8bit;\n\n\t\tif (check_only)\n\t\t\treturn nand_check_op(chip, &op);\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tif (check_only)\n\t\treturn 0;\n\n\tif (force_8bit) {\n\t\tu8 *p = buf;\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < len; i++)\n\t\t\tp[i] = chip->legacy.read_byte(chip);\n\t} else {\n\t\tchip->legacy.read_buf(chip, buf, len);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_read_data_op);\n\n/**\n * nand_write_data_op - Write data from the NAND\n * @chip: The NAND chip\n * @buf: buffer containing the data to send on the bus\n * @len: length of the buffer\n * @force_8bit: force 8-bit bus access\n *\n * This function does a raw data write on the bus. Usually used after launching\n * another NAND operation like nand_write_page_begin_op().\n * This function does not select/unselect the CS line.\n *\n * Returns 0 on success, a negative error code otherwise.\n */\nint nand_write_data_op(struct nand_chip *chip, const void *buf,\n\t\t       unsigned int len, bool force_8bit)\n{\n\tif (!len || !buf)\n\t\treturn -EINVAL;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_DATA_OUT(len, buf, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\tinstrs[0].ctx.data.force_8bit = force_8bit;\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tif (force_8bit) {\n\t\tconst u8 *p = buf;\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < len; i++)\n\t\t\tchip->legacy.write_byte(chip, p[i]);\n\t} else {\n\t\tchip->legacy.write_buf(chip, buf, len);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_write_data_op);\n\n/**\n * struct nand_op_parser_ctx - Context used by the parser\n * @instrs: array of all the instructions that must be addressed\n * @ninstrs: length of the @instrs array\n * @subop: Sub-operation to be passed to the NAND controller\n *\n * This structure is used by the core to split NAND operations into\n * sub-operations that can be handled by the NAND controller.\n */\nstruct nand_op_parser_ctx {\n\tconst struct nand_op_instr *instrs;\n\tunsigned int ninstrs;\n\tstruct nand_subop subop;\n};\n\n/**\n * nand_op_parser_must_split_instr - Checks if an instruction must be split\n * @pat: the parser pattern element that matches @instr\n * @instr: pointer to the instruction to check\n * @start_offset: this is an in/out parameter. If @instr has already been\n *\t\t  split, then @start_offset is the offset from which to start\n *\t\t  (either an address cycle or an offset in the data buffer).\n *\t\t  Conversely, if the function returns true (ie. instr must be\n *\t\t  split), this parameter is updated to point to the first\n *\t\t  data/address cycle that has not been taken care of.\n *\n * Some NAND controllers are limited and cannot send X address cycles with a\n * unique operation, or cannot read/write more than Y bytes at the same time.\n * In this case, split the instruction that does not fit in a single\n * controller-operation into two or more chunks.\n *\n * Returns true if the instruction must be split, false otherwise.\n * The @start_offset parameter is also updated to the offset at which the next\n * bundle of instruction must start (if an address or a data instruction).\n */\nstatic bool\nnand_op_parser_must_split_instr(const struct nand_op_parser_pattern_elem *pat,\n\t\t\t\tconst struct nand_op_instr *instr,\n\t\t\t\tunsigned int *start_offset)\n{\n\tswitch (pat->type) {\n\tcase NAND_OP_ADDR_INSTR:\n\t\tif (!pat->ctx.addr.maxcycles)\n\t\t\tbreak;\n\n\t\tif (instr->ctx.addr.naddrs - *start_offset >\n\t\t    pat->ctx.addr.maxcycles) {\n\t\t\t*start_offset += pat->ctx.addr.maxcycles;\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\n\tcase NAND_OP_DATA_IN_INSTR:\n\tcase NAND_OP_DATA_OUT_INSTR:\n\t\tif (!pat->ctx.data.maxlen)\n\t\t\tbreak;\n\n\t\tif (instr->ctx.data.len - *start_offset >\n\t\t    pat->ctx.data.maxlen) {\n\t\t\t*start_offset += pat->ctx.data.maxlen;\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\n/**\n * nand_op_parser_match_pat - Checks if a pattern matches the instructions\n *\t\t\t      remaining in the parser context\n * @pat: the pattern to test\n * @ctx: the parser context structure to match with the pattern @pat\n *\n * Check if @pat matches the set or a sub-set of instructions remaining in @ctx.\n * Returns true if this is the case, false ortherwise. When true is returned,\n * @ctx->subop is updated with the set of instructions to be passed to the\n * controller driver.\n */\nstatic bool\nnand_op_parser_match_pat(const struct nand_op_parser_pattern *pat,\n\t\t\t struct nand_op_parser_ctx *ctx)\n{\n\tunsigned int instr_offset = ctx->subop.first_instr_start_off;\n\tconst struct nand_op_instr *end = ctx->instrs + ctx->ninstrs;\n\tconst struct nand_op_instr *instr = ctx->subop.instrs;\n\tunsigned int i, ninstrs;\n\n\tfor (i = 0, ninstrs = 0; i < pat->nelems && instr < end; i++) {\n\t\t/*\n\t\t * The pattern instruction does not match the operation\n\t\t * instruction. If the instruction is marked optional in the\n\t\t * pattern definition, we skip the pattern element and continue\n\t\t * to the next one. If the element is mandatory, there's no\n\t\t * match and we can return false directly.\n\t\t */\n\t\tif (instr->type != pat->elems[i].type) {\n\t\t\tif (!pat->elems[i].optional)\n\t\t\t\treturn false;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Now check the pattern element constraints. If the pattern is\n\t\t * not able to handle the whole instruction in a single step,\n\t\t * we have to split it.\n\t\t * The last_instr_end_off value comes back updated to point to\n\t\t * the position where we have to split the instruction (the\n\t\t * start of the next subop chunk).\n\t\t */\n\t\tif (nand_op_parser_must_split_instr(&pat->elems[i], instr,\n\t\t\t\t\t\t    &instr_offset)) {\n\t\t\tninstrs++;\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\n\t\tinstr++;\n\t\tninstrs++;\n\t\tinstr_offset = 0;\n\t}\n\n\t/*\n\t * This can happen if all instructions of a pattern are optional.\n\t * Still, if there's not at least one instruction handled by this\n\t * pattern, this is not a match, and we should try the next one (if\n\t * any).\n\t */\n\tif (!ninstrs)\n\t\treturn false;\n\n\t/*\n\t * We had a match on the pattern head, but the pattern may be longer\n\t * than the instructions we're asked to execute. We need to make sure\n\t * there's no mandatory elements in the pattern tail.\n\t */\n\tfor (; i < pat->nelems; i++) {\n\t\tif (!pat->elems[i].optional)\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * We have a match: update the subop structure accordingly and return\n\t * true.\n\t */\n\tctx->subop.ninstrs = ninstrs;\n\tctx->subop.last_instr_end_off = instr_offset;\n\n\treturn true;\n}\n\n#if IS_ENABLED(CONFIG_DYNAMIC_DEBUG) || defined(DEBUG)\nstatic void nand_op_parser_trace(const struct nand_op_parser_ctx *ctx)\n{\n\tconst struct nand_op_instr *instr;\n\tchar *prefix = \"      \";\n\tunsigned int i;\n\n\tpr_debug(\"executing subop (CS%d):\\n\", ctx->subop.cs);\n\n\tfor (i = 0; i < ctx->ninstrs; i++) {\n\t\tinstr = &ctx->instrs[i];\n\n\t\tif (instr == &ctx->subop.instrs[0])\n\t\t\tprefix = \"    ->\";\n\n\t\tnand_op_trace(prefix, instr);\n\n\t\tif (instr == &ctx->subop.instrs[ctx->subop.ninstrs - 1])\n\t\t\tprefix = \"      \";\n\t}\n}\n#else\nstatic void nand_op_parser_trace(const struct nand_op_parser_ctx *ctx)\n{\n\t/* NOP */\n}\n#endif\n\nstatic int nand_op_parser_cmp_ctx(const struct nand_op_parser_ctx *a,\n\t\t\t\t  const struct nand_op_parser_ctx *b)\n{\n\tif (a->subop.ninstrs < b->subop.ninstrs)\n\t\treturn -1;\n\telse if (a->subop.ninstrs > b->subop.ninstrs)\n\t\treturn 1;\n\n\tif (a->subop.last_instr_end_off < b->subop.last_instr_end_off)\n\t\treturn -1;\n\telse if (a->subop.last_instr_end_off > b->subop.last_instr_end_off)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/**\n * nand_op_parser_exec_op - exec_op parser\n * @chip: the NAND chip\n * @parser: patterns description provided by the controller driver\n * @op: the NAND operation to address\n * @check_only: when true, the function only checks if @op can be handled but\n *\t\tdoes not execute the operation\n *\n * Helper function designed to ease integration of NAND controller drivers that\n * only support a limited set of instruction sequences. The supported sequences\n * are described in @parser, and the framework takes care of splitting @op into\n * multiple sub-operations (if required) and pass them back to the ->exec()\n * callback of the matching pattern if @check_only is set to false.\n *\n * NAND controller drivers should call this function from their own ->exec_op()\n * implementation.\n *\n * Returns 0 on success, a negative error code otherwise. A failure can be\n * caused by an unsupported operation (none of the supported patterns is able\n * to handle the requested operation), or an error returned by one of the\n * matching pattern->exec() hook.\n */\nint nand_op_parser_exec_op(struct nand_chip *chip,\n\t\t\t   const struct nand_op_parser *parser,\n\t\t\t   const struct nand_operation *op, bool check_only)\n{\n\tstruct nand_op_parser_ctx ctx = {\n\t\t.subop.cs = op->cs,\n\t\t.subop.instrs = op->instrs,\n\t\t.instrs = op->instrs,\n\t\t.ninstrs = op->ninstrs,\n\t};\n\tunsigned int i;\n\n\twhile (ctx.subop.instrs < op->instrs + op->ninstrs) {\n\t\tconst struct nand_op_parser_pattern *pattern;\n\t\tstruct nand_op_parser_ctx best_ctx;\n\t\tint ret, best_pattern = -1;\n\n\t\tfor (i = 0; i < parser->npatterns; i++) {\n\t\t\tstruct nand_op_parser_ctx test_ctx = ctx;\n\n\t\t\tpattern = &parser->patterns[i];\n\t\t\tif (!nand_op_parser_match_pat(pattern, &test_ctx))\n\t\t\t\tcontinue;\n\n\t\t\tif (best_pattern >= 0 &&\n\t\t\t    nand_op_parser_cmp_ctx(&test_ctx, &best_ctx) <= 0)\n\t\t\t\tcontinue;\n\n\t\t\tbest_pattern = i;\n\t\t\tbest_ctx = test_ctx;\n\t\t}\n\n\t\tif (best_pattern < 0) {\n\t\t\tpr_debug(\"->exec_op() parser: pattern not found!\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tctx = best_ctx;\n\t\tnand_op_parser_trace(&ctx);\n\n\t\tif (!check_only) {\n\t\t\tpattern = &parser->patterns[best_pattern];\n\t\t\tret = pattern->exec(chip, &ctx.subop);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t/*\n\t\t * Update the context structure by pointing to the start of the\n\t\t * next subop.\n\t\t */\n\t\tctx.subop.instrs = ctx.subop.instrs + ctx.subop.ninstrs;\n\t\tif (ctx.subop.last_instr_end_off)\n\t\t\tctx.subop.instrs -= 1;\n\n\t\tctx.subop.first_instr_start_off = ctx.subop.last_instr_end_off;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_op_parser_exec_op);\n\nstatic bool nand_instr_is_data(const struct nand_op_instr *instr)\n{\n\treturn instr && (instr->type == NAND_OP_DATA_IN_INSTR ||\n\t\t\t instr->type == NAND_OP_DATA_OUT_INSTR);\n}\n\nstatic bool nand_subop_instr_is_valid(const struct nand_subop *subop,\n\t\t\t\t      unsigned int instr_idx)\n{\n\treturn subop && instr_idx < subop->ninstrs;\n}\n\nstatic unsigned int nand_subop_get_start_off(const struct nand_subop *subop,\n\t\t\t\t\t     unsigned int instr_idx)\n{\n\tif (instr_idx)\n\t\treturn 0;\n\n\treturn subop->first_instr_start_off;\n}\n\n/**\n * nand_subop_get_addr_start_off - Get the start offset in an address array\n * @subop: The entire sub-operation\n * @instr_idx: Index of the instruction inside the sub-operation\n *\n * During driver development, one could be tempted to directly use the\n * ->addr.addrs field of address instructions. This is wrong as address\n * instructions might be split.\n *\n * Given an address instruction, returns the offset of the first cycle to issue.\n */\nunsigned int nand_subop_get_addr_start_off(const struct nand_subop *subop,\n\t\t\t\t\t   unsigned int instr_idx)\n{\n\tif (WARN_ON(!nand_subop_instr_is_valid(subop, instr_idx) ||\n\t\t    subop->instrs[instr_idx].type != NAND_OP_ADDR_INSTR))\n\t\treturn 0;\n\n\treturn nand_subop_get_start_off(subop, instr_idx);\n}\nEXPORT_SYMBOL_GPL(nand_subop_get_addr_start_off);\n\n/**\n * nand_subop_get_num_addr_cyc - Get the remaining address cycles to assert\n * @subop: The entire sub-operation\n * @instr_idx: Index of the instruction inside the sub-operation\n *\n * During driver development, one could be tempted to directly use the\n * ->addr->naddrs field of a data instruction. This is wrong as instructions\n * might be split.\n *\n * Given an address instruction, returns the number of address cycle to issue.\n */\nunsigned int nand_subop_get_num_addr_cyc(const struct nand_subop *subop,\n\t\t\t\t\t unsigned int instr_idx)\n{\n\tint start_off, end_off;\n\n\tif (WARN_ON(!nand_subop_instr_is_valid(subop, instr_idx) ||\n\t\t    subop->instrs[instr_idx].type != NAND_OP_ADDR_INSTR))\n\t\treturn 0;\n\n\tstart_off = nand_subop_get_addr_start_off(subop, instr_idx);\n\n\tif (instr_idx == subop->ninstrs - 1 &&\n\t    subop->last_instr_end_off)\n\t\tend_off = subop->last_instr_end_off;\n\telse\n\t\tend_off = subop->instrs[instr_idx].ctx.addr.naddrs;\n\n\treturn end_off - start_off;\n}\nEXPORT_SYMBOL_GPL(nand_subop_get_num_addr_cyc);\n\n/**\n * nand_subop_get_data_start_off - Get the start offset in a data array\n * @subop: The entire sub-operation\n * @instr_idx: Index of the instruction inside the sub-operation\n *\n * During driver development, one could be tempted to directly use the\n * ->data->buf.{in,out} field of data instructions. This is wrong as data\n * instructions might be split.\n *\n * Given a data instruction, returns the offset to start from.\n */\nunsigned int nand_subop_get_data_start_off(const struct nand_subop *subop,\n\t\t\t\t\t   unsigned int instr_idx)\n{\n\tif (WARN_ON(!nand_subop_instr_is_valid(subop, instr_idx) ||\n\t\t    !nand_instr_is_data(&subop->instrs[instr_idx])))\n\t\treturn 0;\n\n\treturn nand_subop_get_start_off(subop, instr_idx);\n}\nEXPORT_SYMBOL_GPL(nand_subop_get_data_start_off);\n\n/**\n * nand_subop_get_data_len - Get the number of bytes to retrieve\n * @subop: The entire sub-operation\n * @instr_idx: Index of the instruction inside the sub-operation\n *\n * During driver development, one could be tempted to directly use the\n * ->data->len field of a data instruction. This is wrong as data instructions\n * might be split.\n *\n * Returns the length of the chunk of data to send/receive.\n */\nunsigned int nand_subop_get_data_len(const struct nand_subop *subop,\n\t\t\t\t     unsigned int instr_idx)\n{\n\tint start_off = 0, end_off;\n\n\tif (WARN_ON(!nand_subop_instr_is_valid(subop, instr_idx) ||\n\t\t    !nand_instr_is_data(&subop->instrs[instr_idx])))\n\t\treturn 0;\n\n\tstart_off = nand_subop_get_data_start_off(subop, instr_idx);\n\n\tif (instr_idx == subop->ninstrs - 1 &&\n\t    subop->last_instr_end_off)\n\t\tend_off = subop->last_instr_end_off;\n\telse\n\t\tend_off = subop->instrs[instr_idx].ctx.data.len;\n\n\treturn end_off - start_off;\n}\nEXPORT_SYMBOL_GPL(nand_subop_get_data_len);\n\n/**\n * nand_reset - Reset and initialize a NAND device\n * @chip: The NAND chip\n * @chipnr: Internal die id\n *\n * Save the timings data structure, then apply SDR timings mode 0 (see\n * nand_reset_interface for details), do the reset operation, and apply\n * back the previous timings.\n *\n * Returns 0 on success, a negative error code otherwise.\n */\nint nand_reset(struct nand_chip *chip, int chipnr)\n{\n\tint ret;\n\n\tret = nand_reset_interface(chip, chipnr);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * The CS line has to be released before we can apply the new NAND\n\t * interface settings, hence this weird nand_select_target()\n\t * nand_deselect_target() dance.\n\t */\n\tnand_select_target(chip, chipnr);\n\tret = nand_reset_op(chip);\n\tnand_deselect_target(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nand_setup_interface(chip, chipnr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_reset);\n\n/**\n * nand_get_features - wrapper to perform a GET_FEATURE\n * @chip: NAND chip info structure\n * @addr: feature address\n * @subfeature_param: the subfeature parameters, a four bytes array\n *\n * Returns 0 for success, a negative error otherwise. Returns -ENOTSUPP if the\n * operation cannot be handled.\n */\nint nand_get_features(struct nand_chip *chip, int addr,\n\t\t      u8 *subfeature_param)\n{\n\tif (!nand_supports_get_features(chip, addr))\n\t\treturn -ENOTSUPP;\n\n\tif (chip->legacy.get_features)\n\t\treturn chip->legacy.get_features(chip, addr, subfeature_param);\n\n\treturn nand_get_features_op(chip, addr, subfeature_param);\n}\n\n/**\n * nand_set_features - wrapper to perform a SET_FEATURE\n * @chip: NAND chip info structure\n * @addr: feature address\n * @subfeature_param: the subfeature parameters, a four bytes array\n *\n * Returns 0 for success, a negative error otherwise. Returns -ENOTSUPP if the\n * operation cannot be handled.\n */\nint nand_set_features(struct nand_chip *chip, int addr,\n\t\t      u8 *subfeature_param)\n{\n\tif (!nand_supports_set_features(chip, addr))\n\t\treturn -ENOTSUPP;\n\n\tif (chip->legacy.set_features)\n\t\treturn chip->legacy.set_features(chip, addr, subfeature_param);\n\n\treturn nand_set_features_op(chip, addr, subfeature_param);\n}\n\n/**\n * nand_check_erased_buf - check if a buffer contains (almost) only 0xff data\n * @buf: buffer to test\n * @len: buffer length\n * @bitflips_threshold: maximum number of bitflips\n *\n * Check if a buffer contains only 0xff, which means the underlying region\n * has been erased and is ready to be programmed.\n * The bitflips_threshold specify the maximum number of bitflips before\n * considering the region is not erased.\n * Note: The logic of this function has been extracted from the memweight\n * implementation, except that nand_check_erased_buf function exit before\n * testing the whole buffer if the number of bitflips exceed the\n * bitflips_threshold value.\n *\n * Returns a positive number of bitflips less than or equal to\n * bitflips_threshold, or -ERROR_CODE for bitflips in excess of the\n * threshold.\n */\nstatic int nand_check_erased_buf(void *buf, int len, int bitflips_threshold)\n{\n\tconst unsigned char *bitmap = buf;\n\tint bitflips = 0;\n\tint weight;\n\n\tfor (; len && ((uintptr_t)bitmap) % sizeof(long);\n\t     len--, bitmap++) {\n\t\tweight = hweight8(*bitmap);\n\t\tbitflips += BITS_PER_BYTE - weight;\n\t\tif (unlikely(bitflips > bitflips_threshold))\n\t\t\treturn -EBADMSG;\n\t}\n\n\tfor (; len >= sizeof(long);\n\t     len -= sizeof(long), bitmap += sizeof(long)) {\n\t\tunsigned long d = *((unsigned long *)bitmap);\n\t\tif (d == ~0UL)\n\t\t\tcontinue;\n\t\tweight = hweight_long(d);\n\t\tbitflips += BITS_PER_LONG - weight;\n\t\tif (unlikely(bitflips > bitflips_threshold))\n\t\t\treturn -EBADMSG;\n\t}\n\n\tfor (; len > 0; len--, bitmap++) {\n\t\tweight = hweight8(*bitmap);\n\t\tbitflips += BITS_PER_BYTE - weight;\n\t\tif (unlikely(bitflips > bitflips_threshold))\n\t\t\treturn -EBADMSG;\n\t}\n\n\treturn bitflips;\n}\n\n/**\n * nand_check_erased_ecc_chunk - check if an ECC chunk contains (almost) only\n *\t\t\t\t 0xff data\n * @data: data buffer to test\n * @datalen: data length\n * @ecc: ECC buffer\n * @ecclen: ECC length\n * @extraoob: extra OOB buffer\n * @extraooblen: extra OOB length\n * @bitflips_threshold: maximum number of bitflips\n *\n * Check if a data buffer and its associated ECC and OOB data contains only\n * 0xff pattern, which means the underlying region has been erased and is\n * ready to be programmed.\n * The bitflips_threshold specify the maximum number of bitflips before\n * considering the region as not erased.\n *\n * Note:\n * 1/ ECC algorithms are working on pre-defined block sizes which are usually\n *    different from the NAND page size. When fixing bitflips, ECC engines will\n *    report the number of errors per chunk, and the NAND core infrastructure\n *    expect you to return the maximum number of bitflips for the whole page.\n *    This is why you should always use this function on a single chunk and\n *    not on the whole page. After checking each chunk you should update your\n *    max_bitflips value accordingly.\n * 2/ When checking for bitflips in erased pages you should not only check\n *    the payload data but also their associated ECC data, because a user might\n *    have programmed almost all bits to 1 but a few. In this case, we\n *    shouldn't consider the chunk as erased, and checking ECC bytes prevent\n *    this case.\n * 3/ The extraoob argument is optional, and should be used if some of your OOB\n *    data are protected by the ECC engine.\n *    It could also be used if you support subpages and want to attach some\n *    extra OOB data to an ECC chunk.\n *\n * Returns a positive number of bitflips less than or equal to\n * bitflips_threshold, or -ERROR_CODE for bitflips in excess of the\n * threshold. In case of success, the passed buffers are filled with 0xff.\n */\nint nand_check_erased_ecc_chunk(void *data, int datalen,\n\t\t\t\tvoid *ecc, int ecclen,\n\t\t\t\tvoid *extraoob, int extraooblen,\n\t\t\t\tint bitflips_threshold)\n{\n\tint data_bitflips = 0, ecc_bitflips = 0, extraoob_bitflips = 0;\n\n\tdata_bitflips = nand_check_erased_buf(data, datalen,\n\t\t\t\t\t      bitflips_threshold);\n\tif (data_bitflips < 0)\n\t\treturn data_bitflips;\n\n\tbitflips_threshold -= data_bitflips;\n\n\tecc_bitflips = nand_check_erased_buf(ecc, ecclen, bitflips_threshold);\n\tif (ecc_bitflips < 0)\n\t\treturn ecc_bitflips;\n\n\tbitflips_threshold -= ecc_bitflips;\n\n\textraoob_bitflips = nand_check_erased_buf(extraoob, extraooblen,\n\t\t\t\t\t\t  bitflips_threshold);\n\tif (extraoob_bitflips < 0)\n\t\treturn extraoob_bitflips;\n\n\tif (data_bitflips)\n\t\tmemset(data, 0xff, datalen);\n\n\tif (ecc_bitflips)\n\t\tmemset(ecc, 0xff, ecclen);\n\n\tif (extraoob_bitflips)\n\t\tmemset(extraoob, 0xff, extraooblen);\n\n\treturn data_bitflips + ecc_bitflips + extraoob_bitflips;\n}\nEXPORT_SYMBOL(nand_check_erased_ecc_chunk);\n\n/**\n * nand_read_page_raw_notsupp - dummy read raw page function\n * @chip: nand chip info structure\n * @buf: buffer to store read data\n * @oob_required: caller requires OOB data read to chip->oob_poi\n * @page: page number to read\n *\n * Returns -ENOTSUPP unconditionally.\n */\nint nand_read_page_raw_notsupp(struct nand_chip *chip, u8 *buf,\n\t\t\t       int oob_required, int page)\n{\n\treturn -ENOTSUPP;\n}\n\n/**\n * nand_read_page_raw - [INTERN] read raw page data without ecc\n * @chip: nand chip info structure\n * @buf: buffer to store read data\n * @oob_required: caller requires OOB data read to chip->oob_poi\n * @page: page number to read\n *\n * Not for syndrome calculating ECC controllers, which use a special oob layout.\n */\nint nand_read_page_raw(struct nand_chip *chip, uint8_t *buf, int oob_required,\n\t\t       int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\tret = nand_read_page_op(chip, page, 0, buf, mtd->writesize);\n\tif (ret)\n\t\treturn ret;\n\n\tif (oob_required) {\n\t\tret = nand_read_data_op(chip, chip->oob_poi, mtd->oobsize,\n\t\t\t\t\tfalse, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nand_read_page_raw);\n\n/**\n * nand_monolithic_read_page_raw - Monolithic page read in raw mode\n * @chip: NAND chip info structure\n * @buf: buffer to store read data\n * @oob_required: caller requires OOB data read to chip->oob_poi\n * @page: page number to read\n *\n * This is a raw page read, ie. without any error detection/correction.\n * Monolithic means we are requesting all the relevant data (main plus\n * eventually OOB) to be loaded in the NAND cache and sent over the\n * bus (from the NAND chip to the NAND controller) in a single\n * operation. This is an alternative to nand_read_page_raw(), which\n * first reads the main data, and if the OOB data is requested too,\n * then reads more data on the bus.\n */\nint nand_monolithic_read_page_raw(struct nand_chip *chip, u8 *buf,\n\t\t\t\t  int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tunsigned int size = mtd->writesize;\n\tu8 *read_buf = buf;\n\tint ret;\n\n\tif (oob_required) {\n\t\tsize += mtd->oobsize;\n\n\t\tif (buf != chip->data_buf)\n\t\t\tread_buf = nand_get_data_buf(chip);\n\t}\n\n\tret = nand_read_page_op(chip, page, 0, read_buf, size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (buf != chip->data_buf)\n\t\tmemcpy(buf, read_buf, mtd->writesize);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nand_monolithic_read_page_raw);\n\n/**\n * nand_read_page_raw_syndrome - [INTERN] read raw page data without ecc\n * @chip: nand chip info structure\n * @buf: buffer to store read data\n * @oob_required: caller requires OOB data read to chip->oob_poi\n * @page: page number to read\n *\n * We need a special oob layout and handling even when OOB isn't used.\n */\nstatic int nand_read_page_raw_syndrome(struct nand_chip *chip, uint8_t *buf,\n\t\t\t\t       int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint eccsize = chip->ecc.size;\n\tint eccbytes = chip->ecc.bytes;\n\tuint8_t *oob = chip->oob_poi;\n\tint steps, size, ret;\n\n\tret = nand_read_page_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (steps = chip->ecc.steps; steps > 0; steps--) {\n\t\tret = nand_read_data_op(chip, buf, eccsize, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbuf += eccsize;\n\n\t\tif (chip->ecc.prepad) {\n\t\t\tret = nand_read_data_op(chip, oob, chip->ecc.prepad,\n\t\t\t\t\t\tfalse, false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\toob += chip->ecc.prepad;\n\t\t}\n\n\t\tret = nand_read_data_op(chip, oob, eccbytes, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\toob += eccbytes;\n\n\t\tif (chip->ecc.postpad) {\n\t\t\tret = nand_read_data_op(chip, oob, chip->ecc.postpad,\n\t\t\t\t\t\tfalse, false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\toob += chip->ecc.postpad;\n\t\t}\n\t}\n\n\tsize = mtd->oobsize - (oob - chip->oob_poi);\n\tif (size) {\n\t\tret = nand_read_data_op(chip, oob, size, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n/**\n * nand_read_page_swecc - [REPLACEABLE] software ECC based page read function\n * @chip: nand chip info structure\n * @buf: buffer to store read data\n * @oob_required: caller requires OOB data read to chip->oob_poi\n * @page: page number to read\n */\nstatic int nand_read_page_swecc(struct nand_chip *chip, uint8_t *buf,\n\t\t\t\tint oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint i, eccsize = chip->ecc.size, ret;\n\tint eccbytes = chip->ecc.bytes;\n\tint eccsteps = chip->ecc.steps;\n\tuint8_t *p = buf;\n\tuint8_t *ecc_calc = chip->ecc.calc_buf;\n\tuint8_t *ecc_code = chip->ecc.code_buf;\n\tunsigned int max_bitflips = 0;\n\n\tchip->ecc.read_page_raw(chip, buf, 1, page);\n\n\tfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)\n\t\tchip->ecc.calculate(chip, p, &ecc_calc[i]);\n\n\tret = mtd_ooblayout_get_eccbytes(mtd, ecc_code, chip->oob_poi, 0,\n\t\t\t\t\t chip->ecc.total);\n\tif (ret)\n\t\treturn ret;\n\n\teccsteps = chip->ecc.steps;\n\tp = buf;\n\n\tfor (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\n\t\tint stat;\n\n\t\tstat = chip->ecc.correct(chip, p, &ecc_code[i], &ecc_calc[i]);\n\t\tif (stat < 0) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t} else {\n\t\t\tmtd->ecc_stats.corrected += stat;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, stat);\n\t\t}\n\t}\n\treturn max_bitflips;\n}\n\n/**\n * nand_read_subpage - [REPLACEABLE] ECC based sub-page read function\n * @chip: nand chip info structure\n * @data_offs: offset of requested data within the page\n * @readlen: data length\n * @bufpoi: buffer to store read data\n * @page: page number to read\n */\nstatic int nand_read_subpage(struct nand_chip *chip, uint32_t data_offs,\n\t\t\t     uint32_t readlen, uint8_t *bufpoi, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint start_step, end_step, num_steps, ret;\n\tuint8_t *p;\n\tint data_col_addr, i, gaps = 0;\n\tint datafrag_len, eccfrag_len, aligned_len, aligned_pos;\n\tint busw = (chip->options & NAND_BUSWIDTH_16) ? 2 : 1;\n\tint index, section = 0;\n\tunsigned int max_bitflips = 0;\n\tstruct mtd_oob_region oobregion = { };\n\n\t/* Column address within the page aligned to ECC size (256bytes) */\n\tstart_step = data_offs / chip->ecc.size;\n\tend_step = (data_offs + readlen - 1) / chip->ecc.size;\n\tnum_steps = end_step - start_step + 1;\n\tindex = start_step * chip->ecc.bytes;\n\n\t/* Data size aligned to ECC ecc.size */\n\tdatafrag_len = num_steps * chip->ecc.size;\n\teccfrag_len = num_steps * chip->ecc.bytes;\n\n\tdata_col_addr = start_step * chip->ecc.size;\n\t/* If we read not a page aligned data */\n\tp = bufpoi + data_col_addr;\n\tret = nand_read_page_op(chip, page, data_col_addr, p, datafrag_len);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Calculate ECC */\n\tfor (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size)\n\t\tchip->ecc.calculate(chip, p, &chip->ecc.calc_buf[i]);\n\n\t/*\n\t * The performance is faster if we position offsets according to\n\t * ecc.pos. Let's make sure that there are no gaps in ECC positions.\n\t */\n\tret = mtd_ooblayout_find_eccregion(mtd, index, &section, &oobregion);\n\tif (ret)\n\t\treturn ret;\n\n\tif (oobregion.length < eccfrag_len)\n\t\tgaps = 1;\n\n\tif (gaps) {\n\t\tret = nand_change_read_column_op(chip, mtd->writesize,\n\t\t\t\t\t\t chip->oob_poi, mtd->oobsize,\n\t\t\t\t\t\t false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\t/*\n\t\t * Send the command to read the particular ECC bytes take care\n\t\t * about buswidth alignment in read_buf.\n\t\t */\n\t\taligned_pos = oobregion.offset & ~(busw - 1);\n\t\taligned_len = eccfrag_len;\n\t\tif (oobregion.offset & (busw - 1))\n\t\t\taligned_len++;\n\t\tif ((oobregion.offset + (num_steps * chip->ecc.bytes)) &\n\t\t    (busw - 1))\n\t\t\taligned_len++;\n\n\t\tret = nand_change_read_column_op(chip,\n\t\t\t\t\t\t mtd->writesize + aligned_pos,\n\t\t\t\t\t\t &chip->oob_poi[aligned_pos],\n\t\t\t\t\t\t aligned_len, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = mtd_ooblayout_get_eccbytes(mtd, chip->ecc.code_buf,\n\t\t\t\t\t chip->oob_poi, index, eccfrag_len);\n\tif (ret)\n\t\treturn ret;\n\n\tp = bufpoi + data_col_addr;\n\tfor (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size) {\n\t\tint stat;\n\n\t\tstat = chip->ecc.correct(chip, p, &chip->ecc.code_buf[i],\n\t\t\t\t\t &chip->ecc.calc_buf[i]);\n\t\tif (stat == -EBADMSG &&\n\t\t    (chip->ecc.options & NAND_ECC_GENERIC_ERASED_CHECK)) {\n\t\t\t/* check for empty pages with bitflips */\n\t\t\tstat = nand_check_erased_ecc_chunk(p, chip->ecc.size,\n\t\t\t\t\t\t&chip->ecc.code_buf[i],\n\t\t\t\t\t\tchip->ecc.bytes,\n\t\t\t\t\t\tNULL, 0,\n\t\t\t\t\t\tchip->ecc.strength);\n\t\t}\n\n\t\tif (stat < 0) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t} else {\n\t\t\tmtd->ecc_stats.corrected += stat;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, stat);\n\t\t}\n\t}\n\treturn max_bitflips;\n}\n\n/**\n * nand_read_page_hwecc - [REPLACEABLE] hardware ECC based page read function\n * @chip: nand chip info structure\n * @buf: buffer to store read data\n * @oob_required: caller requires OOB data read to chip->oob_poi\n * @page: page number to read\n *\n * Not for syndrome calculating ECC controllers which need a special oob layout.\n */\nstatic int nand_read_page_hwecc(struct nand_chip *chip, uint8_t *buf,\n\t\t\t\tint oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint i, eccsize = chip->ecc.size, ret;\n\tint eccbytes = chip->ecc.bytes;\n\tint eccsteps = chip->ecc.steps;\n\tuint8_t *p = buf;\n\tuint8_t *ecc_calc = chip->ecc.calc_buf;\n\tuint8_t *ecc_code = chip->ecc.code_buf;\n\tunsigned int max_bitflips = 0;\n\n\tret = nand_read_page_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\n\t\tchip->ecc.hwctl(chip, NAND_ECC_READ);\n\n\t\tret = nand_read_data_op(chip, p, eccsize, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tchip->ecc.calculate(chip, p, &ecc_calc[i]);\n\t}\n\n\tret = nand_read_data_op(chip, chip->oob_poi, mtd->oobsize, false,\n\t\t\t\tfalse);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mtd_ooblayout_get_eccbytes(mtd, ecc_code, chip->oob_poi, 0,\n\t\t\t\t\t chip->ecc.total);\n\tif (ret)\n\t\treturn ret;\n\n\teccsteps = chip->ecc.steps;\n\tp = buf;\n\n\tfor (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\n\t\tint stat;\n\n\t\tstat = chip->ecc.correct(chip, p, &ecc_code[i], &ecc_calc[i]);\n\t\tif (stat == -EBADMSG &&\n\t\t    (chip->ecc.options & NAND_ECC_GENERIC_ERASED_CHECK)) {\n\t\t\t/* check for empty pages with bitflips */\n\t\t\tstat = nand_check_erased_ecc_chunk(p, eccsize,\n\t\t\t\t\t\t&ecc_code[i], eccbytes,\n\t\t\t\t\t\tNULL, 0,\n\t\t\t\t\t\tchip->ecc.strength);\n\t\t}\n\n\t\tif (stat < 0) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t} else {\n\t\t\tmtd->ecc_stats.corrected += stat;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, stat);\n\t\t}\n\t}\n\treturn max_bitflips;\n}\n\n/**\n * nand_read_page_syndrome - [REPLACEABLE] hardware ECC syndrome based page read\n * @chip: nand chip info structure\n * @buf: buffer to store read data\n * @oob_required: caller requires OOB data read to chip->oob_poi\n * @page: page number to read\n *\n * The hw generator calculates the error syndrome automatically. Therefore we\n * need a special oob layout and handling.\n */\nstatic int nand_read_page_syndrome(struct nand_chip *chip, uint8_t *buf,\n\t\t\t\t   int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret, i, eccsize = chip->ecc.size;\n\tint eccbytes = chip->ecc.bytes;\n\tint eccsteps = chip->ecc.steps;\n\tint eccpadbytes = eccbytes + chip->ecc.prepad + chip->ecc.postpad;\n\tuint8_t *p = buf;\n\tuint8_t *oob = chip->oob_poi;\n\tunsigned int max_bitflips = 0;\n\n\tret = nand_read_page_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\n\t\tint stat;\n\n\t\tchip->ecc.hwctl(chip, NAND_ECC_READ);\n\n\t\tret = nand_read_data_op(chip, p, eccsize, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (chip->ecc.prepad) {\n\t\t\tret = nand_read_data_op(chip, oob, chip->ecc.prepad,\n\t\t\t\t\t\tfalse, false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\toob += chip->ecc.prepad;\n\t\t}\n\n\t\tchip->ecc.hwctl(chip, NAND_ECC_READSYN);\n\n\t\tret = nand_read_data_op(chip, oob, eccbytes, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tstat = chip->ecc.correct(chip, p, oob, NULL);\n\n\t\toob += eccbytes;\n\n\t\tif (chip->ecc.postpad) {\n\t\t\tret = nand_read_data_op(chip, oob, chip->ecc.postpad,\n\t\t\t\t\t\tfalse, false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\toob += chip->ecc.postpad;\n\t\t}\n\n\t\tif (stat == -EBADMSG &&\n\t\t    (chip->ecc.options & NAND_ECC_GENERIC_ERASED_CHECK)) {\n\t\t\t/* check for empty pages with bitflips */\n\t\t\tstat = nand_check_erased_ecc_chunk(p, chip->ecc.size,\n\t\t\t\t\t\t\t   oob - eccpadbytes,\n\t\t\t\t\t\t\t   eccpadbytes,\n\t\t\t\t\t\t\t   NULL, 0,\n\t\t\t\t\t\t\t   chip->ecc.strength);\n\t\t}\n\n\t\tif (stat < 0) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t} else {\n\t\t\tmtd->ecc_stats.corrected += stat;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, stat);\n\t\t}\n\t}\n\n\t/* Calculate remaining oob bytes */\n\ti = mtd->oobsize - (oob - chip->oob_poi);\n\tif (i) {\n\t\tret = nand_read_data_op(chip, oob, i, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn max_bitflips;\n}\n\n/**\n * nand_transfer_oob - [INTERN] Transfer oob to client buffer\n * @chip: NAND chip object\n * @oob: oob destination address\n * @ops: oob ops structure\n * @len: size of oob to transfer\n */\nstatic uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,\n\t\t\t\t  struct mtd_oob_ops *ops, size_t len)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\tswitch (ops->mode) {\n\n\tcase MTD_OPS_PLACE_OOB:\n\tcase MTD_OPS_RAW:\n\t\tmemcpy(oob, chip->oob_poi + ops->ooboffs, len);\n\t\treturn oob + len;\n\n\tcase MTD_OPS_AUTO_OOB:\n\t\tret = mtd_ooblayout_get_databytes(mtd, oob, chip->oob_poi,\n\t\t\t\t\t\t  ops->ooboffs, len);\n\t\tBUG_ON(ret);\n\t\treturn oob + len;\n\n\tdefault:\n\t\tBUG();\n\t}\n\treturn NULL;\n}\n\n/**\n * nand_setup_read_retry - [INTERN] Set the READ RETRY mode\n * @chip: NAND chip object\n * @retry_mode: the retry mode to use\n *\n * Some vendors supply a special command to shift the Vt threshold, to be used\n * when there are too many bitflips in a page (i.e., ECC error). After setting\n * a new threshold, the host should retry reading the page.\n */\nstatic int nand_setup_read_retry(struct nand_chip *chip, int retry_mode)\n{\n\tpr_debug(\"setting READ RETRY mode %d\\n\", retry_mode);\n\n\tif (retry_mode >= chip->read_retries)\n\t\treturn -EINVAL;\n\n\tif (!chip->ops.setup_read_retry)\n\t\treturn -EOPNOTSUPP;\n\n\treturn chip->ops.setup_read_retry(chip, retry_mode);\n}\n\nstatic void nand_wait_readrdy(struct nand_chip *chip)\n{\n\tconst struct nand_sdr_timings *sdr;\n\n\tif (!(chip->options & NAND_NEED_READRDY))\n\t\treturn;\n\n\tsdr = nand_get_sdr_timings(nand_get_interface_config(chip));\n\tWARN_ON(nand_wait_rdy_op(chip, PSEC_TO_MSEC(sdr->tR_max), 0));\n}\n\n/**\n * nand_do_read_ops - [INTERN] Read data with ECC\n * @chip: NAND chip object\n * @from: offset to read from\n * @ops: oob ops structure\n *\n * Internal function. Called with chip held.\n */\nstatic int nand_do_read_ops(struct nand_chip *chip, loff_t from,\n\t\t\t    struct mtd_oob_ops *ops)\n{\n\tint chipnr, page, realpage, col, bytes, aligned, oob_required;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret = 0;\n\tuint32_t readlen = ops->len;\n\tuint32_t oobreadlen = ops->ooblen;\n\tuint32_t max_oobsize = mtd_oobavail(mtd, ops);\n\n\tuint8_t *bufpoi, *oob, *buf;\n\tint use_bounce_buf;\n\tunsigned int max_bitflips = 0;\n\tint retry_mode = 0;\n\tbool ecc_fail = false;\n\n\tchipnr = (int)(from >> chip->chip_shift);\n\tnand_select_target(chip, chipnr);\n\n\trealpage = (int)(from >> chip->page_shift);\n\tpage = realpage & chip->pagemask;\n\n\tcol = (int)(from & (mtd->writesize - 1));\n\n\tbuf = ops->datbuf;\n\toob = ops->oobbuf;\n\toob_required = oob ? 1 : 0;\n\n\twhile (1) {\n\t\tstruct mtd_ecc_stats ecc_stats = mtd->ecc_stats;\n\n\t\tbytes = min(mtd->writesize - col, readlen);\n\t\taligned = (bytes == mtd->writesize);\n\n\t\tif (!aligned)\n\t\t\tuse_bounce_buf = 1;\n\t\telse if (chip->options & NAND_USES_DMA)\n\t\t\tuse_bounce_buf = !virt_addr_valid(buf) ||\n\t\t\t\t\t !IS_ALIGNED((unsigned long)buf,\n\t\t\t\t\t\t     chip->buf_align);\n\t\telse\n\t\t\tuse_bounce_buf = 0;\n\n\t\t/* Is the current page in the buffer? */\n\t\tif (realpage != chip->pagecache.page || oob) {\n\t\t\tbufpoi = use_bounce_buf ? chip->data_buf : buf;\n\n\t\t\tif (use_bounce_buf && aligned)\n\t\t\t\tpr_debug(\"%s: using read bounce buffer for buf@%p\\n\",\n\t\t\t\t\t\t __func__, buf);\n\nread_retry:\n\t\t\t/*\n\t\t\t * Now read the page into the buffer.  Absent an error,\n\t\t\t * the read methods return max bitflips per ecc step.\n\t\t\t */\n\t\t\tif (unlikely(ops->mode == MTD_OPS_RAW))\n\t\t\t\tret = chip->ecc.read_page_raw(chip, bufpoi,\n\t\t\t\t\t\t\t      oob_required,\n\t\t\t\t\t\t\t      page);\n\t\t\telse if (!aligned && NAND_HAS_SUBPAGE_READ(chip) &&\n\t\t\t\t !oob)\n\t\t\t\tret = chip->ecc.read_subpage(chip, col, bytes,\n\t\t\t\t\t\t\t     bufpoi, page);\n\t\t\telse\n\t\t\t\tret = chip->ecc.read_page(chip, bufpoi,\n\t\t\t\t\t\t\t  oob_required, page);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (use_bounce_buf)\n\t\t\t\t\t/* Invalidate page cache */\n\t\t\t\t\tchip->pagecache.page = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Copy back the data in the initial buffer when reading\n\t\t\t * partial pages or when a bounce buffer is required.\n\t\t\t */\n\t\t\tif (use_bounce_buf) {\n\t\t\t\tif (!NAND_HAS_SUBPAGE_READ(chip) && !oob &&\n\t\t\t\t    !(mtd->ecc_stats.failed - ecc_stats.failed) &&\n\t\t\t\t    (ops->mode != MTD_OPS_RAW)) {\n\t\t\t\t\tchip->pagecache.page = realpage;\n\t\t\t\t\tchip->pagecache.bitflips = ret;\n\t\t\t\t} else {\n\t\t\t\t\t/* Invalidate page cache */\n\t\t\t\t\tchip->pagecache.page = -1;\n\t\t\t\t}\n\t\t\t\tmemcpy(buf, bufpoi + col, bytes);\n\t\t\t}\n\n\t\t\tif (unlikely(oob)) {\n\t\t\t\tint toread = min(oobreadlen, max_oobsize);\n\n\t\t\t\tif (toread) {\n\t\t\t\t\toob = nand_transfer_oob(chip, oob, ops,\n\t\t\t\t\t\t\t\ttoread);\n\t\t\t\t\toobreadlen -= toread;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnand_wait_readrdy(chip);\n\n\t\t\tif (mtd->ecc_stats.failed - ecc_stats.failed) {\n\t\t\t\tif (retry_mode + 1 < chip->read_retries) {\n\t\t\t\t\tretry_mode++;\n\t\t\t\t\tret = nand_setup_read_retry(chip,\n\t\t\t\t\t\t\tretry_mode);\n\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t/* Reset ecc_stats; retry */\n\t\t\t\t\tmtd->ecc_stats = ecc_stats;\n\t\t\t\t\tgoto read_retry;\n\t\t\t\t} else {\n\t\t\t\t\t/* No more retry modes; real failure */\n\t\t\t\t\tecc_fail = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbuf += bytes;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, ret);\n\t\t} else {\n\t\t\tmemcpy(buf, chip->data_buf + col, bytes);\n\t\t\tbuf += bytes;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips,\n\t\t\t\t\t     chip->pagecache.bitflips);\n\t\t}\n\n\t\treadlen -= bytes;\n\n\t\t/* Reset to retry mode 0 */\n\t\tif (retry_mode) {\n\t\t\tret = nand_setup_read_retry(chip, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tretry_mode = 0;\n\t\t}\n\n\t\tif (!readlen)\n\t\t\tbreak;\n\n\t\t/* For subsequent reads align to page boundary */\n\t\tcol = 0;\n\t\t/* Increment page address */\n\t\trealpage++;\n\n\t\tpage = realpage & chip->pagemask;\n\t\t/* Check, if we cross a chip boundary */\n\t\tif (!page) {\n\t\t\tchipnr++;\n\t\t\tnand_deselect_target(chip);\n\t\t\tnand_select_target(chip, chipnr);\n\t\t}\n\t}\n\tnand_deselect_target(chip);\n\n\tops->retlen = ops->len - (size_t) readlen;\n\tif (oob)\n\t\tops->oobretlen = ops->ooblen - oobreadlen;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ecc_fail)\n\t\treturn -EBADMSG;\n\n\treturn max_bitflips;\n}\n\n/**\n * nand_read_oob_std - [REPLACEABLE] the most common OOB data read function\n * @chip: nand chip info structure\n * @page: page number to read\n */\nint nand_read_oob_std(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\treturn nand_read_oob_op(chip, page, 0, chip->oob_poi, mtd->oobsize);\n}\nEXPORT_SYMBOL(nand_read_oob_std);\n\n/**\n * nand_read_oob_syndrome - [REPLACEABLE] OOB data read function for HW ECC\n *\t\t\t    with syndromes\n * @chip: nand chip info structure\n * @page: page number to read\n */\nstatic int nand_read_oob_syndrome(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint length = mtd->oobsize;\n\tint chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;\n\tint eccsize = chip->ecc.size;\n\tuint8_t *bufpoi = chip->oob_poi;\n\tint i, toread, sndrnd = 0, pos, ret;\n\n\tret = nand_read_page_op(chip, page, chip->ecc.size, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < chip->ecc.steps; i++) {\n\t\tif (sndrnd) {\n\t\t\tint ret;\n\n\t\t\tpos = eccsize + i * (eccsize + chunk);\n\t\t\tif (mtd->writesize > 512)\n\t\t\t\tret = nand_change_read_column_op(chip, pos,\n\t\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t\t false);\n\t\t\telse\n\t\t\t\tret = nand_read_page_op(chip, page, pos, NULL,\n\t\t\t\t\t\t\t0);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else\n\t\t\tsndrnd = 1;\n\t\ttoread = min_t(int, length, chunk);\n\n\t\tret = nand_read_data_op(chip, bufpoi, toread, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbufpoi += toread;\n\t\tlength -= toread;\n\t}\n\tif (length > 0) {\n\t\tret = nand_read_data_op(chip, bufpoi, length, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n/**\n * nand_write_oob_std - [REPLACEABLE] the most common OOB data write function\n * @chip: nand chip info structure\n * @page: page number to write\n */\nint nand_write_oob_std(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\treturn nand_prog_page_op(chip, page, mtd->writesize, chip->oob_poi,\n\t\t\t\t mtd->oobsize);\n}\nEXPORT_SYMBOL(nand_write_oob_std);\n\n/**\n * nand_write_oob_syndrome - [REPLACEABLE] OOB data write function for HW ECC\n *\t\t\t     with syndrome - only for large page flash\n * @chip: nand chip info structure\n * @page: page number to write\n */\nstatic int nand_write_oob_syndrome(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;\n\tint eccsize = chip->ecc.size, length = mtd->oobsize;\n\tint ret, i, len, pos, sndcmd = 0, steps = chip->ecc.steps;\n\tconst uint8_t *bufpoi = chip->oob_poi;\n\n\t/*\n\t * data-ecc-data-ecc ... ecc-oob\n\t * or\n\t * data-pad-ecc-pad-data-pad .... ecc-pad-oob\n\t */\n\tif (!chip->ecc.prepad && !chip->ecc.postpad) {\n\t\tpos = steps * (eccsize + chunk);\n\t\tsteps = 0;\n\t} else\n\t\tpos = eccsize;\n\n\tret = nand_prog_page_begin_op(chip, page, pos, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < steps; i++) {\n\t\tif (sndcmd) {\n\t\t\tif (mtd->writesize <= 512) {\n\t\t\t\tuint32_t fill = 0xFFFFFFFF;\n\n\t\t\t\tlen = eccsize;\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tint num = min_t(int, len, 4);\n\n\t\t\t\t\tret = nand_write_data_op(chip, &fill,\n\t\t\t\t\t\t\t\t num, false);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\n\t\t\t\t\tlen -= num;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpos = eccsize + i * (eccsize + chunk);\n\t\t\t\tret = nand_change_write_column_op(chip, pos,\n\t\t\t\t\t\t\t\t  NULL, 0,\n\t\t\t\t\t\t\t\t  false);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else\n\t\t\tsndcmd = 1;\n\t\tlen = min_t(int, length, chunk);\n\n\t\tret = nand_write_data_op(chip, bufpoi, len, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbufpoi += len;\n\t\tlength -= len;\n\t}\n\tif (length > 0) {\n\t\tret = nand_write_data_op(chip, bufpoi, length, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn nand_prog_page_end_op(chip);\n}\n\n/**\n * nand_do_read_oob - [INTERN] NAND read out-of-band\n * @chip: NAND chip object\n * @from: offset to read from\n * @ops: oob operations description structure\n *\n * NAND read out-of-band data from the spare area.\n */\nstatic int nand_do_read_oob(struct nand_chip *chip, loff_t from,\n\t\t\t    struct mtd_oob_ops *ops)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tunsigned int max_bitflips = 0;\n\tint page, realpage, chipnr;\n\tstruct mtd_ecc_stats stats;\n\tint readlen = ops->ooblen;\n\tint len;\n\tuint8_t *buf = ops->oobbuf;\n\tint ret = 0;\n\n\tpr_debug(\"%s: from = 0x%08Lx, len = %i\\n\",\n\t\t\t__func__, (unsigned long long)from, readlen);\n\n\tstats = mtd->ecc_stats;\n\n\tlen = mtd_oobavail(mtd, ops);\n\n\tchipnr = (int)(from >> chip->chip_shift);\n\tnand_select_target(chip, chipnr);\n\n\t/* Shift to get page */\n\trealpage = (int)(from >> chip->page_shift);\n\tpage = realpage & chip->pagemask;\n\n\twhile (1) {\n\t\tif (ops->mode == MTD_OPS_RAW)\n\t\t\tret = chip->ecc.read_oob_raw(chip, page);\n\t\telse\n\t\t\tret = chip->ecc.read_oob(chip, page);\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tlen = min(len, readlen);\n\t\tbuf = nand_transfer_oob(chip, buf, ops, len);\n\n\t\tnand_wait_readrdy(chip);\n\n\t\tmax_bitflips = max_t(unsigned int, max_bitflips, ret);\n\n\t\treadlen -= len;\n\t\tif (!readlen)\n\t\t\tbreak;\n\n\t\t/* Increment page address */\n\t\trealpage++;\n\n\t\tpage = realpage & chip->pagemask;\n\t\t/* Check, if we cross a chip boundary */\n\t\tif (!page) {\n\t\t\tchipnr++;\n\t\t\tnand_deselect_target(chip);\n\t\t\tnand_select_target(chip, chipnr);\n\t\t}\n\t}\n\tnand_deselect_target(chip);\n\n\tops->oobretlen = ops->ooblen - readlen;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (mtd->ecc_stats.failed - stats.failed)\n\t\treturn -EBADMSG;\n\n\treturn max_bitflips;\n}\n\n/**\n * nand_read_oob - [MTD Interface] NAND read data and/or out-of-band\n * @mtd: MTD device structure\n * @from: offset to read from\n * @ops: oob operation description structure\n *\n * NAND read data and/or out-of-band data.\n */\nstatic int nand_read_oob(struct mtd_info *mtd, loff_t from,\n\t\t\t struct mtd_oob_ops *ops)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tint ret;\n\n\tops->retlen = 0;\n\n\tif (ops->mode != MTD_OPS_PLACE_OOB &&\n\t    ops->mode != MTD_OPS_AUTO_OOB &&\n\t    ops->mode != MTD_OPS_RAW)\n\t\treturn -ENOTSUPP;\n\n\tret = nand_get_device(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!ops->datbuf)\n\t\tret = nand_do_read_oob(chip, from, ops);\n\telse\n\t\tret = nand_do_read_ops(chip, from, ops);\n\n\tnand_release_device(chip);\n\treturn ret;\n}\n\n/**\n * nand_write_page_raw_notsupp - dummy raw page write function\n * @chip: nand chip info structure\n * @buf: data buffer\n * @oob_required: must write chip->oob_poi to OOB\n * @page: page number to write\n *\n * Returns -ENOTSUPP unconditionally.\n */\nint nand_write_page_raw_notsupp(struct nand_chip *chip, const u8 *buf,\n\t\t\t\tint oob_required, int page)\n{\n\treturn -ENOTSUPP;\n}\n\n/**\n * nand_write_page_raw - [INTERN] raw page write function\n * @chip: nand chip info structure\n * @buf: data buffer\n * @oob_required: must write chip->oob_poi to OOB\n * @page: page number to write\n *\n * Not for syndrome calculating ECC controllers, which use a special oob layout.\n */\nint nand_write_page_raw(struct nand_chip *chip, const uint8_t *buf,\n\t\t\tint oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\tret = nand_prog_page_begin_op(chip, page, 0, buf, mtd->writesize);\n\tif (ret)\n\t\treturn ret;\n\n\tif (oob_required) {\n\t\tret = nand_write_data_op(chip, chip->oob_poi, mtd->oobsize,\n\t\t\t\t\t false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn nand_prog_page_end_op(chip);\n}\nEXPORT_SYMBOL(nand_write_page_raw);\n\n/**\n * nand_monolithic_write_page_raw - Monolithic page write in raw mode\n * @chip: NAND chip info structure\n * @buf: data buffer to write\n * @oob_required: must write chip->oob_poi to OOB\n * @page: page number to write\n *\n * This is a raw page write, ie. without any error detection/correction.\n * Monolithic means we are requesting all the relevant data (main plus\n * eventually OOB) to be sent over the bus and effectively programmed\n * into the NAND chip arrays in a single operation. This is an\n * alternative to nand_write_page_raw(), which first sends the main\n * data, then eventually send the OOB data by latching more data\n * cycles on the NAND bus, and finally sends the program command to\n * synchronyze the NAND chip cache.\n */\nint nand_monolithic_write_page_raw(struct nand_chip *chip, const u8 *buf,\n\t\t\t\t   int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tunsigned int size = mtd->writesize;\n\tu8 *write_buf = (u8 *)buf;\n\n\tif (oob_required) {\n\t\tsize += mtd->oobsize;\n\n\t\tif (buf != chip->data_buf) {\n\t\t\twrite_buf = nand_get_data_buf(chip);\n\t\t\tmemcpy(write_buf, buf, mtd->writesize);\n\t\t}\n\t}\n\n\treturn nand_prog_page_op(chip, page, 0, write_buf, size);\n}\nEXPORT_SYMBOL(nand_monolithic_write_page_raw);\n\n/**\n * nand_write_page_raw_syndrome - [INTERN] raw page write function\n * @chip: nand chip info structure\n * @buf: data buffer\n * @oob_required: must write chip->oob_poi to OOB\n * @page: page number to write\n *\n * We need a special oob layout and handling even when ECC isn't checked.\n */\nstatic int nand_write_page_raw_syndrome(struct nand_chip *chip,\n\t\t\t\t\tconst uint8_t *buf, int oob_required,\n\t\t\t\t\tint page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint eccsize = chip->ecc.size;\n\tint eccbytes = chip->ecc.bytes;\n\tuint8_t *oob = chip->oob_poi;\n\tint steps, size, ret;\n\n\tret = nand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (steps = chip->ecc.steps; steps > 0; steps--) {\n\t\tret = nand_write_data_op(chip, buf, eccsize, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbuf += eccsize;\n\n\t\tif (chip->ecc.prepad) {\n\t\t\tret = nand_write_data_op(chip, oob, chip->ecc.prepad,\n\t\t\t\t\t\t false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\toob += chip->ecc.prepad;\n\t\t}\n\n\t\tret = nand_write_data_op(chip, oob, eccbytes, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\toob += eccbytes;\n\n\t\tif (chip->ecc.postpad) {\n\t\t\tret = nand_write_data_op(chip, oob, chip->ecc.postpad,\n\t\t\t\t\t\t false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\toob += chip->ecc.postpad;\n\t\t}\n\t}\n\n\tsize = mtd->oobsize - (oob - chip->oob_poi);\n\tif (size) {\n\t\tret = nand_write_data_op(chip, oob, size, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn nand_prog_page_end_op(chip);\n}\n/**\n * nand_write_page_swecc - [REPLACEABLE] software ECC based page write function\n * @chip: nand chip info structure\n * @buf: data buffer\n * @oob_required: must write chip->oob_poi to OOB\n * @page: page number to write\n */\nstatic int nand_write_page_swecc(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t\t int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint i, eccsize = chip->ecc.size, ret;\n\tint eccbytes = chip->ecc.bytes;\n\tint eccsteps = chip->ecc.steps;\n\tuint8_t *ecc_calc = chip->ecc.calc_buf;\n\tconst uint8_t *p = buf;\n\n\t/* Software ECC calculation */\n\tfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)\n\t\tchip->ecc.calculate(chip, p, &ecc_calc[i]);\n\n\tret = mtd_ooblayout_set_eccbytes(mtd, ecc_calc, chip->oob_poi, 0,\n\t\t\t\t\t chip->ecc.total);\n\tif (ret)\n\t\treturn ret;\n\n\treturn chip->ecc.write_page_raw(chip, buf, 1, page);\n}\n\n/**\n * nand_write_page_hwecc - [REPLACEABLE] hardware ECC based page write function\n * @chip: nand chip info structure\n * @buf: data buffer\n * @oob_required: must write chip->oob_poi to OOB\n * @page: page number to write\n */\nstatic int nand_write_page_hwecc(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t\t int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint i, eccsize = chip->ecc.size, ret;\n\tint eccbytes = chip->ecc.bytes;\n\tint eccsteps = chip->ecc.steps;\n\tuint8_t *ecc_calc = chip->ecc.calc_buf;\n\tconst uint8_t *p = buf;\n\n\tret = nand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\n\t\tchip->ecc.hwctl(chip, NAND_ECC_WRITE);\n\n\t\tret = nand_write_data_op(chip, p, eccsize, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tchip->ecc.calculate(chip, p, &ecc_calc[i]);\n\t}\n\n\tret = mtd_ooblayout_set_eccbytes(mtd, ecc_calc, chip->oob_poi, 0,\n\t\t\t\t\t chip->ecc.total);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nand_write_data_op(chip, chip->oob_poi, mtd->oobsize, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn nand_prog_page_end_op(chip);\n}\n\n\n/**\n * nand_write_subpage_hwecc - [REPLACEABLE] hardware ECC based subpage write\n * @chip:\tnand chip info structure\n * @offset:\tcolumn address of subpage within the page\n * @data_len:\tdata length\n * @buf:\tdata buffer\n * @oob_required: must write chip->oob_poi to OOB\n * @page: page number to write\n */\nstatic int nand_write_subpage_hwecc(struct nand_chip *chip, uint32_t offset,\n\t\t\t\t    uint32_t data_len, const uint8_t *buf,\n\t\t\t\t    int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tuint8_t *oob_buf  = chip->oob_poi;\n\tuint8_t *ecc_calc = chip->ecc.calc_buf;\n\tint ecc_size      = chip->ecc.size;\n\tint ecc_bytes     = chip->ecc.bytes;\n\tint ecc_steps     = chip->ecc.steps;\n\tuint32_t start_step = offset / ecc_size;\n\tuint32_t end_step   = (offset + data_len - 1) / ecc_size;\n\tint oob_bytes       = mtd->oobsize / ecc_steps;\n\tint step, ret;\n\n\tret = nand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (step = 0; step < ecc_steps; step++) {\n\t\t/* configure controller for WRITE access */\n\t\tchip->ecc.hwctl(chip, NAND_ECC_WRITE);\n\n\t\t/* write data (untouched subpages already masked by 0xFF) */\n\t\tret = nand_write_data_op(chip, buf, ecc_size, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* mask ECC of un-touched subpages by padding 0xFF */\n\t\tif ((step < start_step) || (step > end_step))\n\t\t\tmemset(ecc_calc, 0xff, ecc_bytes);\n\t\telse\n\t\t\tchip->ecc.calculate(chip, buf, ecc_calc);\n\n\t\t/* mask OOB of un-touched subpages by padding 0xFF */\n\t\t/* if oob_required, preserve OOB metadata of written subpage */\n\t\tif (!oob_required || (step < start_step) || (step > end_step))\n\t\t\tmemset(oob_buf, 0xff, oob_bytes);\n\n\t\tbuf += ecc_size;\n\t\tecc_calc += ecc_bytes;\n\t\toob_buf  += oob_bytes;\n\t}\n\n\t/* copy calculated ECC for whole page to chip->buffer->oob */\n\t/* this include masked-value(0xFF) for unwritten subpages */\n\tecc_calc = chip->ecc.calc_buf;\n\tret = mtd_ooblayout_set_eccbytes(mtd, ecc_calc, chip->oob_poi, 0,\n\t\t\t\t\t chip->ecc.total);\n\tif (ret)\n\t\treturn ret;\n\n\t/* write OOB buffer to NAND device */\n\tret = nand_write_data_op(chip, chip->oob_poi, mtd->oobsize, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn nand_prog_page_end_op(chip);\n}\n\n\n/**\n * nand_write_page_syndrome - [REPLACEABLE] hardware ECC syndrome based page write\n * @chip: nand chip info structure\n * @buf: data buffer\n * @oob_required: must write chip->oob_poi to OOB\n * @page: page number to write\n *\n * The hw generator calculates the error syndrome automatically. Therefore we\n * need a special oob layout and handling.\n */\nstatic int nand_write_page_syndrome(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t\t    int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint i, eccsize = chip->ecc.size;\n\tint eccbytes = chip->ecc.bytes;\n\tint eccsteps = chip->ecc.steps;\n\tconst uint8_t *p = buf;\n\tuint8_t *oob = chip->oob_poi;\n\tint ret;\n\n\tret = nand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\n\t\tchip->ecc.hwctl(chip, NAND_ECC_WRITE);\n\n\t\tret = nand_write_data_op(chip, p, eccsize, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (chip->ecc.prepad) {\n\t\t\tret = nand_write_data_op(chip, oob, chip->ecc.prepad,\n\t\t\t\t\t\t false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\toob += chip->ecc.prepad;\n\t\t}\n\n\t\tchip->ecc.calculate(chip, p, oob);\n\n\t\tret = nand_write_data_op(chip, oob, eccbytes, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\toob += eccbytes;\n\n\t\tif (chip->ecc.postpad) {\n\t\t\tret = nand_write_data_op(chip, oob, chip->ecc.postpad,\n\t\t\t\t\t\t false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\toob += chip->ecc.postpad;\n\t\t}\n\t}\n\n\t/* Calculate remaining oob bytes */\n\ti = mtd->oobsize - (oob - chip->oob_poi);\n\tif (i) {\n\t\tret = nand_write_data_op(chip, oob, i, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn nand_prog_page_end_op(chip);\n}\n\n/**\n * nand_write_page - write one page\n * @chip: NAND chip descriptor\n * @offset: address offset within the page\n * @data_len: length of actual data to be written\n * @buf: the data to write\n * @oob_required: must write chip->oob_poi to OOB\n * @page: page number to write\n * @raw: use _raw version of write_page\n */\nstatic int nand_write_page(struct nand_chip *chip, uint32_t offset,\n\t\t\t   int data_len, const uint8_t *buf, int oob_required,\n\t\t\t   int page, int raw)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint status, subpage;\n\n\tif (!(chip->options & NAND_NO_SUBPAGE_WRITE) &&\n\t\tchip->ecc.write_subpage)\n\t\tsubpage = offset || (data_len < mtd->writesize);\n\telse\n\t\tsubpage = 0;\n\n\tif (unlikely(raw))\n\t\tstatus = chip->ecc.write_page_raw(chip, buf, oob_required,\n\t\t\t\t\t\t  page);\n\telse if (subpage)\n\t\tstatus = chip->ecc.write_subpage(chip, offset, data_len, buf,\n\t\t\t\t\t\t oob_required, page);\n\telse\n\t\tstatus = chip->ecc.write_page(chip, buf, oob_required, page);\n\n\tif (status < 0)\n\t\treturn status;\n\n\treturn 0;\n}\n\n#define NOTALIGNED(x)\t((x & (chip->subpagesize - 1)) != 0)\n\n/**\n * nand_do_write_ops - [INTERN] NAND write with ECC\n * @chip: NAND chip object\n * @to: offset to write to\n * @ops: oob operations description structure\n *\n * NAND write with ECC.\n */\nstatic int nand_do_write_ops(struct nand_chip *chip, loff_t to,\n\t\t\t     struct mtd_oob_ops *ops)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint chipnr, realpage, page, column;\n\tuint32_t writelen = ops->len;\n\n\tuint32_t oobwritelen = ops->ooblen;\n\tuint32_t oobmaxlen = mtd_oobavail(mtd, ops);\n\n\tuint8_t *oob = ops->oobbuf;\n\tuint8_t *buf = ops->datbuf;\n\tint ret;\n\tint oob_required = oob ? 1 : 0;\n\n\tops->retlen = 0;\n\tif (!writelen)\n\t\treturn 0;\n\n\t/* Reject writes, which are not page aligned */\n\tif (NOTALIGNED(to) || NOTALIGNED(ops->len)) {\n\t\tpr_notice(\"%s: attempt to write non page aligned data\\n\",\n\t\t\t   __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tcolumn = to & (mtd->writesize - 1);\n\n\tchipnr = (int)(to >> chip->chip_shift);\n\tnand_select_target(chip, chipnr);\n\n\t/* Check, if it is write protected */\n\tif (nand_check_wp(chip)) {\n\t\tret = -EIO;\n\t\tgoto err_out;\n\t}\n\n\trealpage = (int)(to >> chip->page_shift);\n\tpage = realpage & chip->pagemask;\n\n\t/* Invalidate the page cache, when we write to the cached page */\n\tif (to <= ((loff_t)chip->pagecache.page << chip->page_shift) &&\n\t    ((loff_t)chip->pagecache.page << chip->page_shift) < (to + ops->len))\n\t\tchip->pagecache.page = -1;\n\n\t/* Don't allow multipage oob writes with offset */\n\tif (oob && ops->ooboffs && (ops->ooboffs + ops->ooblen > oobmaxlen)) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\twhile (1) {\n\t\tint bytes = mtd->writesize;\n\t\tuint8_t *wbuf = buf;\n\t\tint use_bounce_buf;\n\t\tint part_pagewr = (column || writelen < mtd->writesize);\n\n\t\tif (part_pagewr)\n\t\t\tuse_bounce_buf = 1;\n\t\telse if (chip->options & NAND_USES_DMA)\n\t\t\tuse_bounce_buf = !virt_addr_valid(buf) ||\n\t\t\t\t\t !IS_ALIGNED((unsigned long)buf,\n\t\t\t\t\t\t     chip->buf_align);\n\t\telse\n\t\t\tuse_bounce_buf = 0;\n\n\t\t/*\n\t\t * Copy the data from the initial buffer when doing partial page\n\t\t * writes or when a bounce buffer is required.\n\t\t */\n\t\tif (use_bounce_buf) {\n\t\t\tpr_debug(\"%s: using write bounce buffer for buf@%p\\n\",\n\t\t\t\t\t __func__, buf);\n\t\t\tif (part_pagewr)\n\t\t\t\tbytes = min_t(int, bytes - column, writelen);\n\t\t\twbuf = nand_get_data_buf(chip);\n\t\t\tmemset(wbuf, 0xff, mtd->writesize);\n\t\t\tmemcpy(&wbuf[column], buf, bytes);\n\t\t}\n\n\t\tif (unlikely(oob)) {\n\t\t\tsize_t len = min(oobwritelen, oobmaxlen);\n\t\t\toob = nand_fill_oob(chip, oob, len, ops);\n\t\t\toobwritelen -= len;\n\t\t} else {\n\t\t\t/* We still need to erase leftover OOB data */\n\t\t\tmemset(chip->oob_poi, 0xff, mtd->oobsize);\n\t\t}\n\n\t\tret = nand_write_page(chip, column, bytes, wbuf,\n\t\t\t\t      oob_required, page,\n\t\t\t\t      (ops->mode == MTD_OPS_RAW));\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\twritelen -= bytes;\n\t\tif (!writelen)\n\t\t\tbreak;\n\n\t\tcolumn = 0;\n\t\tbuf += bytes;\n\t\trealpage++;\n\n\t\tpage = realpage & chip->pagemask;\n\t\t/* Check, if we cross a chip boundary */\n\t\tif (!page) {\n\t\t\tchipnr++;\n\t\t\tnand_deselect_target(chip);\n\t\t\tnand_select_target(chip, chipnr);\n\t\t}\n\t}\n\n\tops->retlen = ops->len - writelen;\n\tif (unlikely(oob))\n\t\tops->oobretlen = ops->ooblen;\n\nerr_out:\n\tnand_deselect_target(chip);\n\treturn ret;\n}\n\n/**\n * panic_nand_write - [MTD Interface] NAND write with ECC\n * @mtd: MTD device structure\n * @to: offset to write to\n * @len: number of bytes to write\n * @retlen: pointer to variable to store the number of written bytes\n * @buf: the data to write\n *\n * NAND write with ECC. Used when performing writes in interrupt context, this\n * may for example be called by mtdoops when writing an oops while in panic.\n */\nstatic int panic_nand_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\t    size_t *retlen, const uint8_t *buf)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tint chipnr = (int)(to >> chip->chip_shift);\n\tstruct mtd_oob_ops ops;\n\tint ret;\n\n\tnand_select_target(chip, chipnr);\n\n\t/* Wait for the device to get ready */\n\tpanic_nand_wait(chip, 400);\n\n\tmemset(&ops, 0, sizeof(ops));\n\tops.len = len;\n\tops.datbuf = (uint8_t *)buf;\n\tops.mode = MTD_OPS_PLACE_OOB;\n\n\tret = nand_do_write_ops(chip, to, &ops);\n\n\t*retlen = ops.retlen;\n\treturn ret;\n}\n\n/**\n * nand_write_oob - [MTD Interface] NAND write data and/or out-of-band\n * @mtd: MTD device structure\n * @to: offset to write to\n * @ops: oob operation description structure\n */\nstatic int nand_write_oob(struct mtd_info *mtd, loff_t to,\n\t\t\t  struct mtd_oob_ops *ops)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tint ret;\n\n\tops->retlen = 0;\n\n\tret = nand_get_device(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (ops->mode) {\n\tcase MTD_OPS_PLACE_OOB:\n\tcase MTD_OPS_AUTO_OOB:\n\tcase MTD_OPS_RAW:\n\t\tbreak;\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tif (!ops->datbuf)\n\t\tret = nand_do_write_oob(chip, to, ops);\n\telse\n\t\tret = nand_do_write_ops(chip, to, ops);\n\nout:\n\tnand_release_device(chip);\n\treturn ret;\n}\n\n/**\n * nand_erase - [MTD Interface] erase block(s)\n * @mtd: MTD device structure\n * @instr: erase instruction\n *\n * Erase one ore more blocks.\n */\nstatic int nand_erase(struct mtd_info *mtd, struct erase_info *instr)\n{\n\treturn nand_erase_nand(mtd_to_nand(mtd), instr, 0);\n}\n\n/**\n * nand_erase_nand - [INTERN] erase block(s)\n * @chip: NAND chip object\n * @instr: erase instruction\n * @allowbbt: allow erasing the bbt area\n *\n * Erase one ore more blocks.\n */\nint nand_erase_nand(struct nand_chip *chip, struct erase_info *instr,\n\t\t    int allowbbt)\n{\n\tint page, pages_per_block, ret, chipnr;\n\tloff_t len;\n\n\tpr_debug(\"%s: start = 0x%012llx, len = %llu\\n\",\n\t\t\t__func__, (unsigned long long)instr->addr,\n\t\t\t(unsigned long long)instr->len);\n\n\tif (check_offs_len(chip, instr->addr, instr->len))\n\t\treturn -EINVAL;\n\n\t/* Grab the lock and see if the device is available */\n\tret = nand_get_device(chip);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Shift to get first page */\n\tpage = (int)(instr->addr >> chip->page_shift);\n\tchipnr = (int)(instr->addr >> chip->chip_shift);\n\n\t/* Calculate pages in each block */\n\tpages_per_block = 1 << (chip->phys_erase_shift - chip->page_shift);\n\n\t/* Select the NAND device */\n\tnand_select_target(chip, chipnr);\n\n\t/* Check, if it is write protected */\n\tif (nand_check_wp(chip)) {\n\t\tpr_debug(\"%s: device is write protected!\\n\",\n\t\t\t\t__func__);\n\t\tret = -EIO;\n\t\tgoto erase_exit;\n\t}\n\n\t/* Loop through the pages */\n\tlen = instr->len;\n\n\twhile (len) {\n\t\t/* Check if we have a bad block, we do not erase bad blocks! */\n\t\tif (nand_block_checkbad(chip, ((loff_t) page) <<\n\t\t\t\t\tchip->page_shift, allowbbt)) {\n\t\t\tpr_warn(\"%s: attempt to erase a bad block at page 0x%08x\\n\",\n\t\t\t\t    __func__, page);\n\t\t\tret = -EIO;\n\t\t\tgoto erase_exit;\n\t\t}\n\n\t\t/*\n\t\t * Invalidate the page cache, if we erase the block which\n\t\t * contains the current cached page.\n\t\t */\n\t\tif (page <= chip->pagecache.page && chip->pagecache.page <\n\t\t    (page + pages_per_block))\n\t\t\tchip->pagecache.page = -1;\n\n\t\tret = nand_erase_op(chip, (page & chip->pagemask) >>\n\t\t\t\t    (chip->phys_erase_shift - chip->page_shift));\n\t\tif (ret) {\n\t\t\tpr_debug(\"%s: failed erase, page 0x%08x\\n\",\n\t\t\t\t\t__func__, page);\n\t\t\tinstr->fail_addr =\n\t\t\t\t((loff_t)page << chip->page_shift);\n\t\t\tgoto erase_exit;\n\t\t}\n\n\t\t/* Increment page address and decrement length */\n\t\tlen -= (1ULL << chip->phys_erase_shift);\n\t\tpage += pages_per_block;\n\n\t\t/* Check, if we cross a chip boundary */\n\t\tif (len && !(page & chip->pagemask)) {\n\t\t\tchipnr++;\n\t\t\tnand_deselect_target(chip);\n\t\t\tnand_select_target(chip, chipnr);\n\t\t}\n\t}\n\n\tret = 0;\nerase_exit:\n\n\t/* Deselect and wake up anyone waiting on the device */\n\tnand_deselect_target(chip);\n\tnand_release_device(chip);\n\n\t/* Return more or less happy */\n\treturn ret;\n}\n\n/**\n * nand_sync - [MTD Interface] sync\n * @mtd: MTD device structure\n *\n * Sync is actually a wait for chip ready function.\n */\nstatic void nand_sync(struct mtd_info *mtd)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tpr_debug(\"%s: called\\n\", __func__);\n\n\t/* Grab the lock and see if the device is available */\n\tWARN_ON(nand_get_device(chip));\n\t/* Release it and go back */\n\tnand_release_device(chip);\n}\n\n/**\n * nand_block_isbad - [MTD Interface] Check if block at offset is bad\n * @mtd: MTD device structure\n * @offs: offset relative to mtd start\n */\nstatic int nand_block_isbad(struct mtd_info *mtd, loff_t offs)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tint chipnr = (int)(offs >> chip->chip_shift);\n\tint ret;\n\n\t/* Select the NAND device */\n\tret = nand_get_device(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tnand_select_target(chip, chipnr);\n\n\tret = nand_block_checkbad(chip, offs, 0);\n\n\tnand_deselect_target(chip);\n\tnand_release_device(chip);\n\n\treturn ret;\n}\n\n/**\n * nand_block_markbad - [MTD Interface] Mark block at the given offset as bad\n * @mtd: MTD device structure\n * @ofs: offset relative to mtd start\n */\nstatic int nand_block_markbad(struct mtd_info *mtd, loff_t ofs)\n{\n\tint ret;\n\n\tret = nand_block_isbad(mtd, ofs);\n\tif (ret) {\n\t\t/* If it was bad already, return success and do nothing */\n\t\tif (ret > 0)\n\t\t\treturn 0;\n\t\treturn ret;\n\t}\n\n\treturn nand_block_markbad_lowlevel(mtd_to_nand(mtd), ofs);\n}\n\n/**\n * nand_suspend - [MTD Interface] Suspend the NAND flash\n * @mtd: MTD device structure\n *\n * Returns 0 for success or negative error code otherwise.\n */\nstatic int nand_suspend(struct mtd_info *mtd)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tint ret = 0;\n\n\tmutex_lock(&chip->lock);\n\tif (chip->ops.suspend)\n\t\tret = chip->ops.suspend(chip);\n\tif (!ret)\n\t\tchip->suspended = 1;\n\tmutex_unlock(&chip->lock);\n\n\treturn ret;\n}\n\n/**\n * nand_resume - [MTD Interface] Resume the NAND flash\n * @mtd: MTD device structure\n */\nstatic void nand_resume(struct mtd_info *mtd)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tmutex_lock(&chip->lock);\n\tif (chip->suspended) {\n\t\tif (chip->ops.resume)\n\t\t\tchip->ops.resume(chip);\n\t\tchip->suspended = 0;\n\t} else {\n\t\tpr_err(\"%s called for a chip which is not in suspended state\\n\",\n\t\t\t__func__);\n\t}\n\tmutex_unlock(&chip->lock);\n}\n\n/**\n * nand_shutdown - [MTD Interface] Finish the current NAND operation and\n *                 prevent further operations\n * @mtd: MTD device structure\n */\nstatic void nand_shutdown(struct mtd_info *mtd)\n{\n\tnand_suspend(mtd);\n}\n\n/**\n * nand_lock - [MTD Interface] Lock the NAND flash\n * @mtd: MTD device structure\n * @ofs: offset byte address\n * @len: number of bytes to lock (must be a multiple of block/page size)\n */\nstatic int nand_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (!chip->ops.lock_area)\n\t\treturn -ENOTSUPP;\n\n\treturn chip->ops.lock_area(chip, ofs, len);\n}\n\n/**\n * nand_unlock - [MTD Interface] Unlock the NAND flash\n * @mtd: MTD device structure\n * @ofs: offset byte address\n * @len: number of bytes to unlock (must be a multiple of block/page size)\n */\nstatic int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (!chip->ops.unlock_area)\n\t\treturn -ENOTSUPP;\n\n\treturn chip->ops.unlock_area(chip, ofs, len);\n}\n\n/* Set default functions */\nstatic void nand_set_defaults(struct nand_chip *chip)\n{\n\t/* If no controller is provided, use the dummy, legacy one. */\n\tif (!chip->controller) {\n\t\tchip->controller = &chip->legacy.dummy_controller;\n\t\tnand_controller_init(chip->controller);\n\t}\n\n\tnand_legacy_set_defaults(chip);\n\n\tif (!chip->buf_align)\n\t\tchip->buf_align = 1;\n}\n\n/* Sanitize ONFI strings so we can safely print them */\nvoid sanitize_string(uint8_t *s, size_t len)\n{\n\tssize_t i;\n\n\t/* Null terminate */\n\ts[len - 1] = 0;\n\n\t/* Remove non printable chars */\n\tfor (i = 0; i < len - 1; i++) {\n\t\tif (s[i] < ' ' || s[i] > 127)\n\t\t\ts[i] = '?';\n\t}\n\n\t/* Remove trailing spaces */\n\tstrim(s);\n}\n\n/*\n * nand_id_has_period - Check if an ID string has a given wraparound period\n * @id_data: the ID string\n * @arrlen: the length of the @id_data array\n * @period: the period of repitition\n *\n * Check if an ID string is repeated within a given sequence of bytes at\n * specific repetition interval period (e.g., {0x20,0x01,0x7F,0x20} has a\n * period of 3). This is a helper function for nand_id_len(). Returns non-zero\n * if the repetition has a period of @period; otherwise, returns zero.\n */\nstatic int nand_id_has_period(u8 *id_data, int arrlen, int period)\n{\n\tint i, j;\n\tfor (i = 0; i < period; i++)\n\t\tfor (j = i + period; j < arrlen; j += period)\n\t\t\tif (id_data[i] != id_data[j])\n\t\t\t\treturn 0;\n\treturn 1;\n}\n\n/*\n * nand_id_len - Get the length of an ID string returned by CMD_READID\n * @id_data: the ID string\n * @arrlen: the length of the @id_data array\n\n * Returns the length of the ID string, according to known wraparound/trailing\n * zero patterns. If no pattern exists, returns the length of the array.\n */\nstatic int nand_id_len(u8 *id_data, int arrlen)\n{\n\tint last_nonzero, period;\n\n\t/* Find last non-zero byte */\n\tfor (last_nonzero = arrlen - 1; last_nonzero >= 0; last_nonzero--)\n\t\tif (id_data[last_nonzero])\n\t\t\tbreak;\n\n\t/* All zeros */\n\tif (last_nonzero < 0)\n\t\treturn 0;\n\n\t/* Calculate wraparound period */\n\tfor (period = 1; period < arrlen; period++)\n\t\tif (nand_id_has_period(id_data, arrlen, period))\n\t\t\tbreak;\n\n\t/* There's a repeated pattern */\n\tif (period < arrlen)\n\t\treturn period;\n\n\t/* There are trailing zeros */\n\tif (last_nonzero < arrlen - 1)\n\t\treturn last_nonzero + 1;\n\n\t/* No pattern detected */\n\treturn arrlen;\n}\n\n/* Extract the bits of per cell from the 3rd byte of the extended ID */\nstatic int nand_get_bits_per_cell(u8 cellinfo)\n{\n\tint bits;\n\n\tbits = cellinfo & NAND_CI_CELLTYPE_MSK;\n\tbits >>= NAND_CI_CELLTYPE_SHIFT;\n\treturn bits + 1;\n}\n\n/*\n * Many new NAND share similar device ID codes, which represent the size of the\n * chip. The rest of the parameters must be decoded according to generic or\n * manufacturer-specific \"extended ID\" decoding patterns.\n */\nvoid nand_decode_ext_id(struct nand_chip *chip)\n{\n\tstruct nand_memory_organization *memorg;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint extid;\n\tu8 *id_data = chip->id.data;\n\n\tmemorg = nanddev_get_memorg(&chip->base);\n\n\t/* The 3rd id byte holds MLC / multichip data */\n\tmemorg->bits_per_cell = nand_get_bits_per_cell(id_data[2]);\n\t/* The 4th id byte is the important one */\n\textid = id_data[3];\n\n\t/* Calc pagesize */\n\tmemorg->pagesize = 1024 << (extid & 0x03);\n\tmtd->writesize = memorg->pagesize;\n\textid >>= 2;\n\t/* Calc oobsize */\n\tmemorg->oobsize = (8 << (extid & 0x01)) * (mtd->writesize >> 9);\n\tmtd->oobsize = memorg->oobsize;\n\textid >>= 2;\n\t/* Calc blocksize. Blocksize is multiples of 64KiB */\n\tmemorg->pages_per_eraseblock = ((64 * 1024) << (extid & 0x03)) /\n\t\t\t\t       memorg->pagesize;\n\tmtd->erasesize = (64 * 1024) << (extid & 0x03);\n\textid >>= 2;\n\t/* Get buswidth information */\n\tif (extid & 0x1)\n\t\tchip->options |= NAND_BUSWIDTH_16;\n}\nEXPORT_SYMBOL_GPL(nand_decode_ext_id);\n\n/*\n * Old devices have chip data hardcoded in the device ID table. nand_decode_id\n * decodes a matching ID table entry and assigns the MTD size parameters for\n * the chip.\n */\nstatic void nand_decode_id(struct nand_chip *chip, struct nand_flash_dev *type)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_memory_organization *memorg;\n\n\tmemorg = nanddev_get_memorg(&chip->base);\n\n\tmemorg->pages_per_eraseblock = type->erasesize / type->pagesize;\n\tmtd->erasesize = type->erasesize;\n\tmemorg->pagesize = type->pagesize;\n\tmtd->writesize = memorg->pagesize;\n\tmemorg->oobsize = memorg->pagesize / 32;\n\tmtd->oobsize = memorg->oobsize;\n\n\t/* All legacy ID NAND are small-page, SLC */\n\tmemorg->bits_per_cell = 1;\n}\n\n/*\n * Set the bad block marker/indicator (BBM/BBI) patterns according to some\n * heuristic patterns using various detected parameters (e.g., manufacturer,\n * page size, cell-type information).\n */\nstatic void nand_decode_bbm_options(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\t/* Set the bad block position */\n\tif (mtd->writesize > 512 || (chip->options & NAND_BUSWIDTH_16))\n\t\tchip->badblockpos = NAND_BBM_POS_LARGE;\n\telse\n\t\tchip->badblockpos = NAND_BBM_POS_SMALL;\n}\n\nstatic inline bool is_full_id_nand(struct nand_flash_dev *type)\n{\n\treturn type->id_len;\n}\n\nstatic bool find_full_id_nand(struct nand_chip *chip,\n\t\t\t      struct nand_flash_dev *type)\n{\n\tstruct nand_device *base = &chip->base;\n\tstruct nand_ecc_props requirements;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_memory_organization *memorg;\n\tu8 *id_data = chip->id.data;\n\n\tmemorg = nanddev_get_memorg(&chip->base);\n\n\tif (!strncmp(type->id, id_data, type->id_len)) {\n\t\tmemorg->pagesize = type->pagesize;\n\t\tmtd->writesize = memorg->pagesize;\n\t\tmemorg->pages_per_eraseblock = type->erasesize /\n\t\t\t\t\t       type->pagesize;\n\t\tmtd->erasesize = type->erasesize;\n\t\tmemorg->oobsize = type->oobsize;\n\t\tmtd->oobsize = memorg->oobsize;\n\n\t\tmemorg->bits_per_cell = nand_get_bits_per_cell(id_data[2]);\n\t\tmemorg->eraseblocks_per_lun =\n\t\t\tDIV_ROUND_DOWN_ULL((u64)type->chipsize << 20,\n\t\t\t\t\t   memorg->pagesize *\n\t\t\t\t\t   memorg->pages_per_eraseblock);\n\t\tchip->options |= type->options;\n\t\trequirements.strength = NAND_ECC_STRENGTH(type);\n\t\trequirements.step_size = NAND_ECC_STEP(type);\n\t\tnanddev_set_ecc_requirements(base, &requirements);\n\n\t\tchip->parameters.model = kstrdup(type->name, GFP_KERNEL);\n\t\tif (!chip->parameters.model)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * Manufacturer detection. Only used when the NAND is not ONFI or JEDEC\n * compliant and does not have a full-id or legacy-id entry in the nand_ids\n * table.\n */\nstatic void nand_manufacturer_detect(struct nand_chip *chip)\n{\n\t/*\n\t * Try manufacturer detection if available and use\n\t * nand_decode_ext_id() otherwise.\n\t */\n\tif (chip->manufacturer.desc && chip->manufacturer.desc->ops &&\n\t    chip->manufacturer.desc->ops->detect) {\n\t\tstruct nand_memory_organization *memorg;\n\n\t\tmemorg = nanddev_get_memorg(&chip->base);\n\n\t\t/* The 3rd id byte holds MLC / multichip data */\n\t\tmemorg->bits_per_cell = nand_get_bits_per_cell(chip->id.data[2]);\n\t\tchip->manufacturer.desc->ops->detect(chip);\n\t} else {\n\t\tnand_decode_ext_id(chip);\n\t}\n}\n\n/*\n * Manufacturer initialization. This function is called for all NANDs including\n * ONFI and JEDEC compliant ones.\n * Manufacturer drivers should put all their specific initialization code in\n * their ->init() hook.\n */\nstatic int nand_manufacturer_init(struct nand_chip *chip)\n{\n\tif (!chip->manufacturer.desc || !chip->manufacturer.desc->ops ||\n\t    !chip->manufacturer.desc->ops->init)\n\t\treturn 0;\n\n\treturn chip->manufacturer.desc->ops->init(chip);\n}\n\n/*\n * Manufacturer cleanup. This function is called for all NANDs including\n * ONFI and JEDEC compliant ones.\n * Manufacturer drivers should put all their specific cleanup code in their\n * ->cleanup() hook.\n */\nstatic void nand_manufacturer_cleanup(struct nand_chip *chip)\n{\n\t/* Release manufacturer private data */\n\tif (chip->manufacturer.desc && chip->manufacturer.desc->ops &&\n\t    chip->manufacturer.desc->ops->cleanup)\n\t\tchip->manufacturer.desc->ops->cleanup(chip);\n}\n\nstatic const char *\nnand_manufacturer_name(const struct nand_manufacturer_desc *manufacturer_desc)\n{\n\treturn manufacturer_desc ? manufacturer_desc->name : \"Unknown\";\n}\n\n/*\n * Get the flash and manufacturer id and lookup if the type is supported.\n */\nstatic int nand_detect(struct nand_chip *chip, struct nand_flash_dev *type)\n{\n\tconst struct nand_manufacturer_desc *manufacturer_desc;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_memory_organization *memorg;\n\tint busw, ret;\n\tu8 *id_data = chip->id.data;\n\tu8 maf_id, dev_id;\n\tu64 targetsize;\n\n\t/*\n\t * Let's start by initializing memorg fields that might be left\n\t * unassigned by the ID-based detection logic.\n\t */\n\tmemorg = nanddev_get_memorg(&chip->base);\n\tmemorg->planes_per_lun = 1;\n\tmemorg->luns_per_target = 1;\n\n\t/*\n\t * Reset the chip, required by some chips (e.g. Micron MT29FxGxxxxx)\n\t * after power-up.\n\t */\n\tret = nand_reset(chip, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Select the device */\n\tnand_select_target(chip, 0);\n\n\t/* Send the command for reading device ID */\n\tret = nand_readid_op(chip, 0, id_data, 2);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Read manufacturer and device IDs */\n\tmaf_id = id_data[0];\n\tdev_id = id_data[1];\n\n\t/*\n\t * Try again to make sure, as some systems the bus-hold or other\n\t * interface concerns can cause random data which looks like a\n\t * possibly credible NAND flash to appear. If the two results do\n\t * not match, ignore the device completely.\n\t */\n\n\t/* Read entire ID string */\n\tret = nand_readid_op(chip, 0, id_data, sizeof(chip->id.data));\n\tif (ret)\n\t\treturn ret;\n\n\tif (id_data[0] != maf_id || id_data[1] != dev_id) {\n\t\tpr_info(\"second ID read did not match %02x,%02x against %02x,%02x\\n\",\n\t\t\tmaf_id, dev_id, id_data[0], id_data[1]);\n\t\treturn -ENODEV;\n\t}\n\n\tchip->id.len = nand_id_len(id_data, ARRAY_SIZE(chip->id.data));\n\n\t/* Try to identify manufacturer */\n\tmanufacturer_desc = nand_get_manufacturer_desc(maf_id);\n\tchip->manufacturer.desc = manufacturer_desc;\n\n\tif (!type)\n\t\ttype = nand_flash_ids;\n\n\t/*\n\t * Save the NAND_BUSWIDTH_16 flag before letting auto-detection logic\n\t * override it.\n\t * This is required to make sure initial NAND bus width set by the\n\t * NAND controller driver is coherent with the real NAND bus width\n\t * (extracted by auto-detection code).\n\t */\n\tbusw = chip->options & NAND_BUSWIDTH_16;\n\n\t/*\n\t * The flag is only set (never cleared), reset it to its default value\n\t * before starting auto-detection.\n\t */\n\tchip->options &= ~NAND_BUSWIDTH_16;\n\n\tfor (; type->name != NULL; type++) {\n\t\tif (is_full_id_nand(type)) {\n\t\t\tif (find_full_id_nand(chip, type))\n\t\t\t\tgoto ident_done;\n\t\t} else if (dev_id == type->dev_id) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!type->name || !type->pagesize) {\n\t\t/* Check if the chip is ONFI compliant */\n\t\tret = nand_onfi_detect(chip);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret)\n\t\t\tgoto ident_done;\n\n\t\t/* Check if the chip is JEDEC compliant */\n\t\tret = nand_jedec_detect(chip);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret)\n\t\t\tgoto ident_done;\n\t}\n\n\tif (!type->name)\n\t\treturn -ENODEV;\n\n\tchip->parameters.model = kstrdup(type->name, GFP_KERNEL);\n\tif (!chip->parameters.model)\n\t\treturn -ENOMEM;\n\n\tif (!type->pagesize)\n\t\tnand_manufacturer_detect(chip);\n\telse\n\t\tnand_decode_id(chip, type);\n\n\t/* Get chip options */\n\tchip->options |= type->options;\n\n\tmemorg->eraseblocks_per_lun =\n\t\t\tDIV_ROUND_DOWN_ULL((u64)type->chipsize << 20,\n\t\t\t\t\t   memorg->pagesize *\n\t\t\t\t\t   memorg->pages_per_eraseblock);\n\nident_done:\n\tif (!mtd->name)\n\t\tmtd->name = chip->parameters.model;\n\n\tif (chip->options & NAND_BUSWIDTH_AUTO) {\n\t\tWARN_ON(busw & NAND_BUSWIDTH_16);\n\t\tnand_set_defaults(chip);\n\t} else if (busw != (chip->options & NAND_BUSWIDTH_16)) {\n\t\t/*\n\t\t * Check, if buswidth is correct. Hardware drivers should set\n\t\t * chip correct!\n\t\t */\n\t\tpr_info(\"device found, Manufacturer ID: 0x%02x, Chip ID: 0x%02x\\n\",\n\t\t\tmaf_id, dev_id);\n\t\tpr_info(\"%s %s\\n\", nand_manufacturer_name(manufacturer_desc),\n\t\t\tmtd->name);\n\t\tpr_warn(\"bus width %d instead of %d bits\\n\", busw ? 16 : 8,\n\t\t\t(chip->options & NAND_BUSWIDTH_16) ? 16 : 8);\n\t\tret = -EINVAL;\n\n\t\tgoto free_detect_allocation;\n\t}\n\n\tnand_decode_bbm_options(chip);\n\n\t/* Calculate the address shift from the page size */\n\tchip->page_shift = ffs(mtd->writesize) - 1;\n\t/* Convert chipsize to number of pages per chip -1 */\n\ttargetsize = nanddev_target_size(&chip->base);\n\tchip->pagemask = (targetsize >> chip->page_shift) - 1;\n\n\tchip->bbt_erase_shift = chip->phys_erase_shift =\n\t\tffs(mtd->erasesize) - 1;\n\tif (targetsize & 0xffffffff)\n\t\tchip->chip_shift = ffs((unsigned)targetsize) - 1;\n\telse {\n\t\tchip->chip_shift = ffs((unsigned)(targetsize >> 32));\n\t\tchip->chip_shift += 32 - 1;\n\t}\n\n\tif (chip->chip_shift - chip->page_shift > 16)\n\t\tchip->options |= NAND_ROW_ADDR_3;\n\n\tchip->badblockbits = 8;\n\n\tnand_legacy_adjust_cmdfunc(chip);\n\n\tpr_info(\"device found, Manufacturer ID: 0x%02x, Chip ID: 0x%02x\\n\",\n\t\tmaf_id, dev_id);\n\tpr_info(\"%s %s\\n\", nand_manufacturer_name(manufacturer_desc),\n\t\tchip->parameters.model);\n\tpr_info(\"%d MiB, %s, erase size: %d KiB, page size: %d, OOB size: %d\\n\",\n\t\t(int)(targetsize >> 20), nand_is_slc(chip) ? \"SLC\" : \"MLC\",\n\t\tmtd->erasesize >> 10, mtd->writesize, mtd->oobsize);\n\treturn 0;\n\nfree_detect_allocation:\n\tkfree(chip->parameters.model);\n\n\treturn ret;\n}\n\nstatic enum nand_ecc_engine_type\nof_get_rawnand_ecc_engine_type_legacy(struct device_node *np)\n{\n\tenum nand_ecc_legacy_mode {\n\t\tNAND_ECC_INVALID,\n\t\tNAND_ECC_NONE,\n\t\tNAND_ECC_SOFT,\n\t\tNAND_ECC_SOFT_BCH,\n\t\tNAND_ECC_HW,\n\t\tNAND_ECC_HW_SYNDROME,\n\t\tNAND_ECC_ON_DIE,\n\t};\n\tconst char * const nand_ecc_legacy_modes[] = {\n\t\t[NAND_ECC_NONE]\t\t= \"none\",\n\t\t[NAND_ECC_SOFT]\t\t= \"soft\",\n\t\t[NAND_ECC_SOFT_BCH]\t= \"soft_bch\",\n\t\t[NAND_ECC_HW]\t\t= \"hw\",\n\t\t[NAND_ECC_HW_SYNDROME]\t= \"hw_syndrome\",\n\t\t[NAND_ECC_ON_DIE]\t= \"on-die\",\n\t};\n\tenum nand_ecc_legacy_mode eng_type;\n\tconst char *pm;\n\tint err;\n\n\terr = of_property_read_string(np, \"nand-ecc-mode\", &pm);\n\tif (err)\n\t\treturn NAND_ECC_ENGINE_TYPE_INVALID;\n\n\tfor (eng_type = NAND_ECC_NONE;\n\t     eng_type < ARRAY_SIZE(nand_ecc_legacy_modes); eng_type++) {\n\t\tif (!strcasecmp(pm, nand_ecc_legacy_modes[eng_type])) {\n\t\t\tswitch (eng_type) {\n\t\t\tcase NAND_ECC_NONE:\n\t\t\t\treturn NAND_ECC_ENGINE_TYPE_NONE;\n\t\t\tcase NAND_ECC_SOFT:\n\t\t\tcase NAND_ECC_SOFT_BCH:\n\t\t\t\treturn NAND_ECC_ENGINE_TYPE_SOFT;\n\t\t\tcase NAND_ECC_HW:\n\t\t\tcase NAND_ECC_HW_SYNDROME:\n\t\t\t\treturn NAND_ECC_ENGINE_TYPE_ON_HOST;\n\t\t\tcase NAND_ECC_ON_DIE:\n\t\t\t\treturn NAND_ECC_ENGINE_TYPE_ON_DIE;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NAND_ECC_ENGINE_TYPE_INVALID;\n}\n\nstatic enum nand_ecc_placement\nof_get_rawnand_ecc_placement_legacy(struct device_node *np)\n{\n\tconst char *pm;\n\tint err;\n\n\terr = of_property_read_string(np, \"nand-ecc-mode\", &pm);\n\tif (!err) {\n\t\tif (!strcasecmp(pm, \"hw_syndrome\"))\n\t\t\treturn NAND_ECC_PLACEMENT_INTERLEAVED;\n\t}\n\n\treturn NAND_ECC_PLACEMENT_UNKNOWN;\n}\n\nstatic enum nand_ecc_algo of_get_rawnand_ecc_algo_legacy(struct device_node *np)\n{\n\tconst char *pm;\n\tint err;\n\n\terr = of_property_read_string(np, \"nand-ecc-mode\", &pm);\n\tif (!err) {\n\t\tif (!strcasecmp(pm, \"soft\"))\n\t\t\treturn NAND_ECC_ALGO_HAMMING;\n\t\telse if (!strcasecmp(pm, \"soft_bch\"))\n\t\t\treturn NAND_ECC_ALGO_BCH;\n\t}\n\n\treturn NAND_ECC_ALGO_UNKNOWN;\n}\n\nstatic void of_get_nand_ecc_legacy_user_config(struct nand_chip *chip)\n{\n\tstruct device_node *dn = nand_get_flash_node(chip);\n\tstruct nand_ecc_props *user_conf = &chip->base.ecc.user_conf;\n\n\tif (user_conf->engine_type == NAND_ECC_ENGINE_TYPE_INVALID)\n\t\tuser_conf->engine_type = of_get_rawnand_ecc_engine_type_legacy(dn);\n\n\tif (user_conf->algo == NAND_ECC_ALGO_UNKNOWN)\n\t\tuser_conf->algo = of_get_rawnand_ecc_algo_legacy(dn);\n\n\tif (user_conf->placement == NAND_ECC_PLACEMENT_UNKNOWN)\n\t\tuser_conf->placement = of_get_rawnand_ecc_placement_legacy(dn);\n}\n\nstatic int of_get_nand_bus_width(struct device_node *np)\n{\n\tu32 val;\n\n\tif (of_property_read_u32(np, \"nand-bus-width\", &val))\n\t\treturn 8;\n\n\tswitch (val) {\n\tcase 8:\n\tcase 16:\n\t\treturn val;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic bool of_get_nand_on_flash_bbt(struct device_node *np)\n{\n\treturn of_property_read_bool(np, \"nand-on-flash-bbt\");\n}\n\nstatic int rawnand_dt_init(struct nand_chip *chip)\n{\n\tstruct nand_device *nand = mtd_to_nanddev(nand_to_mtd(chip));\n\tstruct device_node *dn = nand_get_flash_node(chip);\n\n\tif (!dn)\n\t\treturn 0;\n\n\tif (of_get_nand_bus_width(dn) == 16)\n\t\tchip->options |= NAND_BUSWIDTH_16;\n\n\tif (of_property_read_bool(dn, \"nand-is-boot-medium\"))\n\t\tchip->options |= NAND_IS_BOOT_MEDIUM;\n\n\tif (of_get_nand_on_flash_bbt(dn))\n\t\tchip->bbt_options |= NAND_BBT_USE_FLASH;\n\n\tof_get_nand_ecc_user_config(nand);\n\tof_get_nand_ecc_legacy_user_config(chip);\n\n\t/*\n\t * If neither the user nor the NAND controller have requested a specific\n\t * ECC engine type, we will default to NAND_ECC_ENGINE_TYPE_ON_HOST.\n\t */\n\tnand->ecc.defaults.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\n\t/*\n\t * Use the user requested engine type, unless there is none, in this\n\t * case default to the NAND controller choice, otherwise fallback to\n\t * the raw NAND default one.\n\t */\n\tif (nand->ecc.user_conf.engine_type != NAND_ECC_ENGINE_TYPE_INVALID)\n\t\tchip->ecc.engine_type = nand->ecc.user_conf.engine_type;\n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_INVALID)\n\t\tchip->ecc.engine_type = nand->ecc.defaults.engine_type;\n\n\tchip->ecc.placement = nand->ecc.user_conf.placement;\n\tchip->ecc.algo = nand->ecc.user_conf.algo;\n\tchip->ecc.strength = nand->ecc.user_conf.strength;\n\tchip->ecc.size = nand->ecc.user_conf.step_size;\n\n\treturn 0;\n}\n\n/**\n * nand_scan_ident - Scan for the NAND device\n * @chip: NAND chip object\n * @maxchips: number of chips to scan for\n * @table: alternative NAND ID table\n *\n * This is the first phase of the normal nand_scan() function. It reads the\n * flash ID and sets up MTD fields accordingly.\n *\n * This helper used to be called directly from controller drivers that needed\n * to tweak some ECC-related parameters before nand_scan_tail(). This separation\n * prevented dynamic allocations during this phase which was unconvenient and\n * as been banned for the benefit of the ->init_ecc()/cleanup_ecc() hooks.\n */\nstatic int nand_scan_ident(struct nand_chip *chip, unsigned int maxchips,\n\t\t\t   struct nand_flash_dev *table)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_memory_organization *memorg;\n\tint nand_maf_id, nand_dev_id;\n\tunsigned int i;\n\tint ret;\n\n\tmemorg = nanddev_get_memorg(&chip->base);\n\n\t/* Assume all dies are deselected when we enter nand_scan_ident(). */\n\tchip->cur_cs = -1;\n\n\tmutex_init(&chip->lock);\n\n\t/* Enforce the right timings for reset/detection */\n\tchip->current_interface_config = nand_get_reset_interface_config();\n\n\tret = rawnand_dt_init(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!mtd->name && mtd->dev.parent)\n\t\tmtd->name = dev_name(mtd->dev.parent);\n\n\t/* Set the default functions */\n\tnand_set_defaults(chip);\n\n\tret = nand_legacy_check_hooks(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tmemorg->ntargets = maxchips;\n\n\t/* Read the flash type */\n\tret = nand_detect(chip, table);\n\tif (ret) {\n\t\tif (!(chip->options & NAND_SCAN_SILENT_NODEV))\n\t\t\tpr_warn(\"No NAND device found\\n\");\n\t\tnand_deselect_target(chip);\n\t\treturn ret;\n\t}\n\n\tnand_maf_id = chip->id.data[0];\n\tnand_dev_id = chip->id.data[1];\n\n\tnand_deselect_target(chip);\n\n\t/* Check for a chip array */\n\tfor (i = 1; i < maxchips; i++) {\n\t\tu8 id[2];\n\n\t\t/* See comment in nand_get_flash_type for reset */\n\t\tret = nand_reset(chip, i);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tnand_select_target(chip, i);\n\t\t/* Send the command for reading device ID */\n\t\tret = nand_readid_op(chip, 0, id, sizeof(id));\n\t\tif (ret)\n\t\t\tbreak;\n\t\t/* Read manufacturer and device IDs */\n\t\tif (nand_maf_id != id[0] || nand_dev_id != id[1]) {\n\t\t\tnand_deselect_target(chip);\n\t\t\tbreak;\n\t\t}\n\t\tnand_deselect_target(chip);\n\t}\n\tif (i > 1)\n\t\tpr_info(\"%d chips detected\\n\", i);\n\n\t/* Store the number of chips and calc total size for mtd */\n\tmemorg->ntargets = i;\n\tmtd->size = i * nanddev_target_size(&chip->base);\n\n\treturn 0;\n}\n\nstatic void nand_scan_ident_cleanup(struct nand_chip *chip)\n{\n\tkfree(chip->parameters.model);\n\tkfree(chip->parameters.onfi);\n}\n\nint rawnand_sw_hamming_init(struct nand_chip *chip)\n{\n\tstruct nand_ecc_sw_hamming_conf *engine_conf;\n\tstruct nand_device *base = &chip->base;\n\tint ret;\n\n\tbase->ecc.user_conf.engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\tbase->ecc.user_conf.algo = NAND_ECC_ALGO_HAMMING;\n\tbase->ecc.user_conf.strength = chip->ecc.strength;\n\tbase->ecc.user_conf.step_size = chip->ecc.size;\n\n\tret = nand_ecc_sw_hamming_init_ctx(base);\n\tif (ret)\n\t\treturn ret;\n\n\tengine_conf = base->ecc.ctx.priv;\n\n\tif (chip->ecc.options & NAND_ECC_SOFT_HAMMING_SM_ORDER)\n\t\tengine_conf->sm_order = true;\n\n\tchip->ecc.size = base->ecc.ctx.conf.step_size;\n\tchip->ecc.strength = base->ecc.ctx.conf.strength;\n\tchip->ecc.total = base->ecc.ctx.total;\n\tchip->ecc.steps = nanddev_get_ecc_nsteps(base);\n\tchip->ecc.bytes = base->ecc.ctx.total / nanddev_get_ecc_nsteps(base);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rawnand_sw_hamming_init);\n\nint rawnand_sw_hamming_calculate(struct nand_chip *chip,\n\t\t\t\t const unsigned char *buf,\n\t\t\t\t unsigned char *code)\n{\n\tstruct nand_device *base = &chip->base;\n\n\treturn nand_ecc_sw_hamming_calculate(base, buf, code);\n}\nEXPORT_SYMBOL(rawnand_sw_hamming_calculate);\n\nint rawnand_sw_hamming_correct(struct nand_chip *chip,\n\t\t\t       unsigned char *buf,\n\t\t\t       unsigned char *read_ecc,\n\t\t\t       unsigned char *calc_ecc)\n{\n\tstruct nand_device *base = &chip->base;\n\n\treturn nand_ecc_sw_hamming_correct(base, buf, read_ecc, calc_ecc);\n}\nEXPORT_SYMBOL(rawnand_sw_hamming_correct);\n\nvoid rawnand_sw_hamming_cleanup(struct nand_chip *chip)\n{\n\tstruct nand_device *base = &chip->base;\n\n\tnand_ecc_sw_hamming_cleanup_ctx(base);\n}\nEXPORT_SYMBOL(rawnand_sw_hamming_cleanup);\n\nint rawnand_sw_bch_init(struct nand_chip *chip)\n{\n\tstruct nand_device *base = &chip->base;\n\tconst struct nand_ecc_props *ecc_conf = nanddev_get_ecc_conf(base);\n\tint ret;\n\n\tbase->ecc.user_conf.engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\tbase->ecc.user_conf.algo = NAND_ECC_ALGO_BCH;\n\tbase->ecc.user_conf.step_size = chip->ecc.size;\n\tbase->ecc.user_conf.strength = chip->ecc.strength;\n\n\tret = nand_ecc_sw_bch_init_ctx(base);\n\tif (ret)\n\t\treturn ret;\n\n\tchip->ecc.size = ecc_conf->step_size;\n\tchip->ecc.strength = ecc_conf->strength;\n\tchip->ecc.total = base->ecc.ctx.total;\n\tchip->ecc.steps = nanddev_get_ecc_nsteps(base);\n\tchip->ecc.bytes = base->ecc.ctx.total / nanddev_get_ecc_nsteps(base);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rawnand_sw_bch_init);\n\nstatic int rawnand_sw_bch_calculate(struct nand_chip *chip,\n\t\t\t\t    const unsigned char *buf,\n\t\t\t\t    unsigned char *code)\n{\n\tstruct nand_device *base = &chip->base;\n\n\treturn nand_ecc_sw_bch_calculate(base, buf, code);\n}\n\nint rawnand_sw_bch_correct(struct nand_chip *chip, unsigned char *buf,\n\t\t\t   unsigned char *read_ecc, unsigned char *calc_ecc)\n{\n\tstruct nand_device *base = &chip->base;\n\n\treturn nand_ecc_sw_bch_correct(base, buf, read_ecc, calc_ecc);\n}\nEXPORT_SYMBOL(rawnand_sw_bch_correct);\n\nvoid rawnand_sw_bch_cleanup(struct nand_chip *chip)\n{\n\tstruct nand_device *base = &chip->base;\n\n\tnand_ecc_sw_bch_cleanup_ctx(base);\n}\nEXPORT_SYMBOL(rawnand_sw_bch_cleanup);\n\nstatic int nand_set_ecc_on_host_ops(struct nand_chip *chip)\n{\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\n\tswitch (ecc->placement) {\n\tcase NAND_ECC_PLACEMENT_UNKNOWN:\n\tcase NAND_ECC_PLACEMENT_OOB:\n\t\t/* Use standard hwecc read page function? */\n\t\tif (!ecc->read_page)\n\t\t\tecc->read_page = nand_read_page_hwecc;\n\t\tif (!ecc->write_page)\n\t\t\tecc->write_page = nand_write_page_hwecc;\n\t\tif (!ecc->read_page_raw)\n\t\t\tecc->read_page_raw = nand_read_page_raw;\n\t\tif (!ecc->write_page_raw)\n\t\t\tecc->write_page_raw = nand_write_page_raw;\n\t\tif (!ecc->read_oob)\n\t\t\tecc->read_oob = nand_read_oob_std;\n\t\tif (!ecc->write_oob)\n\t\t\tecc->write_oob = nand_write_oob_std;\n\t\tif (!ecc->read_subpage)\n\t\t\tecc->read_subpage = nand_read_subpage;\n\t\tif (!ecc->write_subpage && ecc->hwctl && ecc->calculate)\n\t\t\tecc->write_subpage = nand_write_subpage_hwecc;\n\t\tfallthrough;\n\n\tcase NAND_ECC_PLACEMENT_INTERLEAVED:\n\t\tif ((!ecc->calculate || !ecc->correct || !ecc->hwctl) &&\n\t\t    (!ecc->read_page ||\n\t\t     ecc->read_page == nand_read_page_hwecc ||\n\t\t     !ecc->write_page ||\n\t\t     ecc->write_page == nand_write_page_hwecc)) {\n\t\t\tWARN(1, \"No ECC functions supplied; hardware ECC not possible\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* Use standard syndrome read/write page function? */\n\t\tif (!ecc->read_page)\n\t\t\tecc->read_page = nand_read_page_syndrome;\n\t\tif (!ecc->write_page)\n\t\t\tecc->write_page = nand_write_page_syndrome;\n\t\tif (!ecc->read_page_raw)\n\t\t\tecc->read_page_raw = nand_read_page_raw_syndrome;\n\t\tif (!ecc->write_page_raw)\n\t\t\tecc->write_page_raw = nand_write_page_raw_syndrome;\n\t\tif (!ecc->read_oob)\n\t\t\tecc->read_oob = nand_read_oob_syndrome;\n\t\tif (!ecc->write_oob)\n\t\t\tecc->write_oob = nand_write_oob_syndrome;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_warn(\"Invalid NAND_ECC_PLACEMENT %d\\n\",\n\t\t\tecc->placement);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nand_set_ecc_soft_ops(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_device *nanddev = mtd_to_nanddev(mtd);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\tint ret;\n\n\tif (WARN_ON(ecc->engine_type != NAND_ECC_ENGINE_TYPE_SOFT))\n\t\treturn -EINVAL;\n\n\tswitch (ecc->algo) {\n\tcase NAND_ECC_ALGO_HAMMING:\n\t\tecc->calculate = rawnand_sw_hamming_calculate;\n\t\tecc->correct = rawnand_sw_hamming_correct;\n\t\tecc->read_page = nand_read_page_swecc;\n\t\tecc->read_subpage = nand_read_subpage;\n\t\tecc->write_page = nand_write_page_swecc;\n\t\tif (!ecc->read_page_raw)\n\t\t\tecc->read_page_raw = nand_read_page_raw;\n\t\tif (!ecc->write_page_raw)\n\t\t\tecc->write_page_raw = nand_write_page_raw;\n\t\tecc->read_oob = nand_read_oob_std;\n\t\tecc->write_oob = nand_write_oob_std;\n\t\tif (!ecc->size)\n\t\t\tecc->size = 256;\n\t\tecc->bytes = 3;\n\t\tecc->strength = 1;\n\n\t\tif (IS_ENABLED(CONFIG_MTD_NAND_ECC_SW_HAMMING_SMC))\n\t\t\tecc->options |= NAND_ECC_SOFT_HAMMING_SM_ORDER;\n\n\t\tret = rawnand_sw_hamming_init(chip);\n\t\tif (ret) {\n\t\t\tWARN(1, \"Hamming ECC initialization failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn 0;\n\tcase NAND_ECC_ALGO_BCH:\n\t\tif (!IS_ENABLED(CONFIG_MTD_NAND_ECC_SW_BCH)) {\n\t\t\tWARN(1, \"CONFIG_MTD_NAND_ECC_SW_BCH not enabled\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tecc->calculate = rawnand_sw_bch_calculate;\n\t\tecc->correct = rawnand_sw_bch_correct;\n\t\tecc->read_page = nand_read_page_swecc;\n\t\tecc->read_subpage = nand_read_subpage;\n\t\tecc->write_page = nand_write_page_swecc;\n\t\tif (!ecc->read_page_raw)\n\t\t\tecc->read_page_raw = nand_read_page_raw;\n\t\tif (!ecc->write_page_raw)\n\t\t\tecc->write_page_raw = nand_write_page_raw;\n\t\tecc->read_oob = nand_read_oob_std;\n\t\tecc->write_oob = nand_write_oob_std;\n\n\t\t/*\n\t\t * We can only maximize ECC config when the default layout is\n\t\t * used, otherwise we don't know how many bytes can really be\n\t\t * used.\n\t\t */\n\t\tif (nanddev->ecc.user_conf.flags & NAND_ECC_MAXIMIZE_STRENGTH &&\n\t\t    mtd->ooblayout != nand_get_large_page_ooblayout())\n\t\t\tnanddev->ecc.user_conf.flags &= ~NAND_ECC_MAXIMIZE_STRENGTH;\n\n\t\tret = rawnand_sw_bch_init(chip);\n\t\tif (ret) {\n\t\t\tWARN(1, \"BCH ECC initialization failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn 0;\n\tdefault:\n\t\tWARN(1, \"Unsupported ECC algorithm!\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\n/**\n * nand_check_ecc_caps - check the sanity of preset ECC settings\n * @chip: nand chip info structure\n * @caps: ECC caps info structure\n * @oobavail: OOB size that the ECC engine can use\n *\n * When ECC step size and strength are already set, check if they are supported\n * by the controller and the calculated ECC bytes fit within the chip's OOB.\n * On success, the calculated ECC bytes is set.\n */\nstatic int\nnand_check_ecc_caps(struct nand_chip *chip,\n\t\t    const struct nand_ecc_caps *caps, int oobavail)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tconst struct nand_ecc_step_info *stepinfo;\n\tint preset_step = chip->ecc.size;\n\tint preset_strength = chip->ecc.strength;\n\tint ecc_bytes, nsteps = mtd->writesize / preset_step;\n\tint i, j;\n\n\tfor (i = 0; i < caps->nstepinfos; i++) {\n\t\tstepinfo = &caps->stepinfos[i];\n\n\t\tif (stepinfo->stepsize != preset_step)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < stepinfo->nstrengths; j++) {\n\t\t\tif (stepinfo->strengths[j] != preset_strength)\n\t\t\t\tcontinue;\n\n\t\t\tecc_bytes = caps->calc_ecc_bytes(preset_step,\n\t\t\t\t\t\t\t preset_strength);\n\t\t\tif (WARN_ON_ONCE(ecc_bytes < 0))\n\t\t\t\treturn ecc_bytes;\n\n\t\t\tif (ecc_bytes * nsteps > oobavail) {\n\t\t\t\tpr_err(\"ECC (step, strength) = (%d, %d) does not fit in OOB\",\n\t\t\t\t       preset_step, preset_strength);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tchip->ecc.bytes = ecc_bytes;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpr_err(\"ECC (step, strength) = (%d, %d) not supported on this controller\",\n\t       preset_step, preset_strength);\n\n\treturn -ENOTSUPP;\n}\n\n/**\n * nand_match_ecc_req - meet the chip's requirement with least ECC bytes\n * @chip: nand chip info structure\n * @caps: ECC engine caps info structure\n * @oobavail: OOB size that the ECC engine can use\n *\n * If a chip's ECC requirement is provided, try to meet it with the least\n * number of ECC bytes (i.e. with the largest number of OOB-free bytes).\n * On success, the chosen ECC settings are set.\n */\nstatic int\nnand_match_ecc_req(struct nand_chip *chip,\n\t\t   const struct nand_ecc_caps *caps, int oobavail)\n{\n\tconst struct nand_ecc_props *requirements =\n\t\tnanddev_get_ecc_requirements(&chip->base);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tconst struct nand_ecc_step_info *stepinfo;\n\tint req_step = requirements->step_size;\n\tint req_strength = requirements->strength;\n\tint req_corr, step_size, strength, nsteps, ecc_bytes, ecc_bytes_total;\n\tint best_step, best_strength, best_ecc_bytes;\n\tint best_ecc_bytes_total = INT_MAX;\n\tint i, j;\n\n\t/* No information provided by the NAND chip */\n\tif (!req_step || !req_strength)\n\t\treturn -ENOTSUPP;\n\n\t/* number of correctable bits the chip requires in a page */\n\treq_corr = mtd->writesize / req_step * req_strength;\n\n\tfor (i = 0; i < caps->nstepinfos; i++) {\n\t\tstepinfo = &caps->stepinfos[i];\n\t\tstep_size = stepinfo->stepsize;\n\n\t\tfor (j = 0; j < stepinfo->nstrengths; j++) {\n\t\t\tstrength = stepinfo->strengths[j];\n\n\t\t\t/*\n\t\t\t * If both step size and strength are smaller than the\n\t\t\t * chip's requirement, it is not easy to compare the\n\t\t\t * resulted reliability.\n\t\t\t */\n\t\t\tif (step_size < req_step && strength < req_strength)\n\t\t\t\tcontinue;\n\n\t\t\tif (mtd->writesize % step_size)\n\t\t\t\tcontinue;\n\n\t\t\tnsteps = mtd->writesize / step_size;\n\n\t\t\tecc_bytes = caps->calc_ecc_bytes(step_size, strength);\n\t\t\tif (WARN_ON_ONCE(ecc_bytes < 0))\n\t\t\t\tcontinue;\n\t\t\tecc_bytes_total = ecc_bytes * nsteps;\n\n\t\t\tif (ecc_bytes_total > oobavail ||\n\t\t\t    strength * nsteps < req_corr)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * We assume the best is to meet the chip's requrement\n\t\t\t * with the least number of ECC bytes.\n\t\t\t */\n\t\t\tif (ecc_bytes_total < best_ecc_bytes_total) {\n\t\t\t\tbest_ecc_bytes_total = ecc_bytes_total;\n\t\t\t\tbest_step = step_size;\n\t\t\t\tbest_strength = strength;\n\t\t\t\tbest_ecc_bytes = ecc_bytes;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (best_ecc_bytes_total == INT_MAX)\n\t\treturn -ENOTSUPP;\n\n\tchip->ecc.size = best_step;\n\tchip->ecc.strength = best_strength;\n\tchip->ecc.bytes = best_ecc_bytes;\n\n\treturn 0;\n}\n\n/**\n * nand_maximize_ecc - choose the max ECC strength available\n * @chip: nand chip info structure\n * @caps: ECC engine caps info structure\n * @oobavail: OOB size that the ECC engine can use\n *\n * Choose the max ECC strength that is supported on the controller, and can fit\n * within the chip's OOB.  On success, the chosen ECC settings are set.\n */\nstatic int\nnand_maximize_ecc(struct nand_chip *chip,\n\t\t  const struct nand_ecc_caps *caps, int oobavail)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tconst struct nand_ecc_step_info *stepinfo;\n\tint step_size, strength, nsteps, ecc_bytes, corr;\n\tint best_corr = 0;\n\tint best_step = 0;\n\tint best_strength, best_ecc_bytes;\n\tint i, j;\n\n\tfor (i = 0; i < caps->nstepinfos; i++) {\n\t\tstepinfo = &caps->stepinfos[i];\n\t\tstep_size = stepinfo->stepsize;\n\n\t\t/* If chip->ecc.size is already set, respect it */\n\t\tif (chip->ecc.size && step_size != chip->ecc.size)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < stepinfo->nstrengths; j++) {\n\t\t\tstrength = stepinfo->strengths[j];\n\n\t\t\tif (mtd->writesize % step_size)\n\t\t\t\tcontinue;\n\n\t\t\tnsteps = mtd->writesize / step_size;\n\n\t\t\tecc_bytes = caps->calc_ecc_bytes(step_size, strength);\n\t\t\tif (WARN_ON_ONCE(ecc_bytes < 0))\n\t\t\t\tcontinue;\n\n\t\t\tif (ecc_bytes * nsteps > oobavail)\n\t\t\t\tcontinue;\n\n\t\t\tcorr = strength * nsteps;\n\n\t\t\t/*\n\t\t\t * If the number of correctable bits is the same,\n\t\t\t * bigger step_size has more reliability.\n\t\t\t */\n\t\t\tif (corr > best_corr ||\n\t\t\t    (corr == best_corr && step_size > best_step)) {\n\t\t\t\tbest_corr = corr;\n\t\t\t\tbest_step = step_size;\n\t\t\t\tbest_strength = strength;\n\t\t\t\tbest_ecc_bytes = ecc_bytes;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!best_corr)\n\t\treturn -ENOTSUPP;\n\n\tchip->ecc.size = best_step;\n\tchip->ecc.strength = best_strength;\n\tchip->ecc.bytes = best_ecc_bytes;\n\n\treturn 0;\n}\n\n/**\n * nand_ecc_choose_conf - Set the ECC strength and ECC step size\n * @chip: nand chip info structure\n * @caps: ECC engine caps info structure\n * @oobavail: OOB size that the ECC engine can use\n *\n * Choose the ECC configuration according to following logic.\n *\n * 1. If both ECC step size and ECC strength are already set (usually by DT)\n *    then check if it is supported by this controller.\n * 2. If the user provided the nand-ecc-maximize property, then select maximum\n *    ECC strength.\n * 3. Otherwise, try to match the ECC step size and ECC strength closest\n *    to the chip's requirement. If available OOB size can't fit the chip\n *    requirement then fallback to the maximum ECC step size and ECC strength.\n *\n * On success, the chosen ECC settings are set.\n */\nint nand_ecc_choose_conf(struct nand_chip *chip,\n\t\t\t const struct nand_ecc_caps *caps, int oobavail)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_device *nanddev = mtd_to_nanddev(mtd);\n\n\tif (WARN_ON(oobavail < 0 || oobavail > mtd->oobsize))\n\t\treturn -EINVAL;\n\n\tif (chip->ecc.size && chip->ecc.strength)\n\t\treturn nand_check_ecc_caps(chip, caps, oobavail);\n\n\tif (nanddev->ecc.user_conf.flags & NAND_ECC_MAXIMIZE_STRENGTH)\n\t\treturn nand_maximize_ecc(chip, caps, oobavail);\n\n\tif (!nand_match_ecc_req(chip, caps, oobavail))\n\t\treturn 0;\n\n\treturn nand_maximize_ecc(chip, caps, oobavail);\n}\nEXPORT_SYMBOL_GPL(nand_ecc_choose_conf);\n\nstatic int rawnand_erase(struct nand_device *nand, const struct nand_pos *pos)\n{\n\tstruct nand_chip *chip = container_of(nand, struct nand_chip,\n\t\t\t\t\t      base);\n\tunsigned int eb = nanddev_pos_to_row(nand, pos);\n\tint ret;\n\n\teb >>= nand->rowconv.eraseblock_addr_shift;\n\n\tnand_select_target(chip, pos->target);\n\tret = nand_erase_op(chip, eb);\n\tnand_deselect_target(chip);\n\n\treturn ret;\n}\n\nstatic int rawnand_markbad(struct nand_device *nand,\n\t\t\t   const struct nand_pos *pos)\n{\n\tstruct nand_chip *chip = container_of(nand, struct nand_chip,\n\t\t\t\t\t      base);\n\n\treturn nand_markbad_bbm(chip, nanddev_pos_to_offs(nand, pos));\n}\n\nstatic bool rawnand_isbad(struct nand_device *nand, const struct nand_pos *pos)\n{\n\tstruct nand_chip *chip = container_of(nand, struct nand_chip,\n\t\t\t\t\t      base);\n\tint ret;\n\n\tnand_select_target(chip, pos->target);\n\tret = nand_isbad_bbm(chip, nanddev_pos_to_offs(nand, pos));\n\tnand_deselect_target(chip);\n\n\treturn ret;\n}\n\nstatic const struct nand_ops rawnand_ops = {\n\t.erase = rawnand_erase,\n\t.markbad = rawnand_markbad,\n\t.isbad = rawnand_isbad,\n};\n\n/**\n * nand_scan_tail - Scan for the NAND device\n * @chip: NAND chip object\n *\n * This is the second phase of the normal nand_scan() function. It fills out\n * all the uninitialized function pointers with the defaults and scans for a\n * bad block table if appropriate.\n */\nstatic int nand_scan_tail(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\tint ret, i;\n\n\t/* New bad blocks should be marked in OOB, flash-based BBT, or both */\n\tif (WARN_ON((chip->bbt_options & NAND_BBT_NO_OOB_BBM) &&\n\t\t   !(chip->bbt_options & NAND_BBT_USE_FLASH))) {\n\t\treturn -EINVAL;\n\t}\n\n\tchip->data_buf = kmalloc(mtd->writesize + mtd->oobsize, GFP_KERNEL);\n\tif (!chip->data_buf)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * FIXME: some NAND manufacturer drivers expect the first die to be\n\t * selected when manufacturer->init() is called. They should be fixed\n\t * to explictly select the relevant die when interacting with the NAND\n\t * chip.\n\t */\n\tnand_select_target(chip, 0);\n\tret = nand_manufacturer_init(chip);\n\tnand_deselect_target(chip);\n\tif (ret)\n\t\tgoto err_free_buf;\n\n\t/* Set the internal oob buffer location, just after the page data */\n\tchip->oob_poi = chip->data_buf + mtd->writesize;\n\n\t/*\n\t * If no default placement scheme is given, select an appropriate one.\n\t */\n\tif (!mtd->ooblayout &&\n\t    !(ecc->engine_type == NAND_ECC_ENGINE_TYPE_SOFT &&\n\t      ecc->algo == NAND_ECC_ALGO_BCH) &&\n\t    !(ecc->engine_type == NAND_ECC_ENGINE_TYPE_SOFT &&\n\t      ecc->algo == NAND_ECC_ALGO_HAMMING)) {\n\t\tswitch (mtd->oobsize) {\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tmtd_set_ooblayout(mtd, nand_get_small_page_ooblayout());\n\t\t\tbreak;\n\t\tcase 64:\n\t\tcase 128:\n\t\t\tmtd_set_ooblayout(mtd,\n\t\t\t\t\t  nand_get_large_page_hamming_ooblayout());\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Expose the whole OOB area to users if ECC_NONE\n\t\t\t * is passed. We could do that for all kind of\n\t\t\t * ->oobsize, but we must keep the old large/small\n\t\t\t * page with ECC layout when ->oobsize <= 128 for\n\t\t\t * compatibility reasons.\n\t\t\t */\n\t\t\tif (ecc->engine_type == NAND_ECC_ENGINE_TYPE_NONE) {\n\t\t\t\tmtd_set_ooblayout(mtd,\n\t\t\t\t\t\t  nand_get_large_page_ooblayout());\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tWARN(1, \"No oob scheme defined for oobsize %d\\n\",\n\t\t\t\tmtd->oobsize);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_nand_manuf_cleanup;\n\t\t}\n\t}\n\n\t/*\n\t * Check ECC mode, default to software if 3byte/512byte hardware ECC is\n\t * selected and we have 256 byte pagesize fallback to software ECC\n\t */\n\n\tswitch (ecc->engine_type) {\n\tcase NAND_ECC_ENGINE_TYPE_ON_HOST:\n\t\tret = nand_set_ecc_on_host_ops(chip);\n\t\tif (ret)\n\t\t\tgoto err_nand_manuf_cleanup;\n\n\t\tif (mtd->writesize >= ecc->size) {\n\t\t\tif (!ecc->strength) {\n\t\t\t\tWARN(1, \"Driver must set ecc.strength when using hardware ECC\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_nand_manuf_cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tpr_warn(\"%d byte HW ECC not possible on %d byte page size, fallback to SW ECC\\n\",\n\t\t\tecc->size, mtd->writesize);\n\t\tecc->engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\t\tecc->algo = NAND_ECC_ALGO_HAMMING;\n\t\tfallthrough;\n\n\tcase NAND_ECC_ENGINE_TYPE_SOFT:\n\t\tret = nand_set_ecc_soft_ops(chip);\n\t\tif (ret)\n\t\t\tgoto err_nand_manuf_cleanup;\n\t\tbreak;\n\n\tcase NAND_ECC_ENGINE_TYPE_ON_DIE:\n\t\tif (!ecc->read_page || !ecc->write_page) {\n\t\t\tWARN(1, \"No ECC functions supplied; on-die ECC not possible\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_nand_manuf_cleanup;\n\t\t}\n\t\tif (!ecc->read_oob)\n\t\t\tecc->read_oob = nand_read_oob_std;\n\t\tif (!ecc->write_oob)\n\t\t\tecc->write_oob = nand_write_oob_std;\n\t\tbreak;\n\n\tcase NAND_ECC_ENGINE_TYPE_NONE:\n\t\tpr_warn(\"NAND_ECC_ENGINE_TYPE_NONE selected by board driver. This is not recommended!\\n\");\n\t\tecc->read_page = nand_read_page_raw;\n\t\tecc->write_page = nand_write_page_raw;\n\t\tecc->read_oob = nand_read_oob_std;\n\t\tecc->read_page_raw = nand_read_page_raw;\n\t\tecc->write_page_raw = nand_write_page_raw;\n\t\tecc->write_oob = nand_write_oob_std;\n\t\tecc->size = mtd->writesize;\n\t\tecc->bytes = 0;\n\t\tecc->strength = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"Invalid NAND_ECC_MODE %d\\n\", ecc->engine_type);\n\t\tret = -EINVAL;\n\t\tgoto err_nand_manuf_cleanup;\n\t}\n\n\tif (ecc->correct || ecc->calculate) {\n\t\tecc->calc_buf = kmalloc(mtd->oobsize, GFP_KERNEL);\n\t\tecc->code_buf = kmalloc(mtd->oobsize, GFP_KERNEL);\n\t\tif (!ecc->calc_buf || !ecc->code_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_nand_manuf_cleanup;\n\t\t}\n\t}\n\n\t/* For many systems, the standard OOB write also works for raw */\n\tif (!ecc->read_oob_raw)\n\t\tecc->read_oob_raw = ecc->read_oob;\n\tif (!ecc->write_oob_raw)\n\t\tecc->write_oob_raw = ecc->write_oob;\n\n\t/* propagate ecc info to mtd_info */\n\tmtd->ecc_strength = ecc->strength;\n\tmtd->ecc_step_size = ecc->size;\n\n\t/*\n\t * Set the number of read / write steps for one page depending on ECC\n\t * mode.\n\t */\n\tif (!ecc->steps)\n\t\tecc->steps = mtd->writesize / ecc->size;\n\tif (ecc->steps * ecc->size != mtd->writesize) {\n\t\tWARN(1, \"Invalid ECC parameters\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_nand_manuf_cleanup;\n\t}\n\n\tif (!ecc->total) {\n\t\tecc->total = ecc->steps * ecc->bytes;\n\t\tchip->base.ecc.ctx.total = ecc->total;\n\t}\n\n\tif (ecc->total > mtd->oobsize) {\n\t\tWARN(1, \"Total number of ECC bytes exceeded oobsize\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_nand_manuf_cleanup;\n\t}\n\n\t/*\n\t * The number of bytes available for a client to place data into\n\t * the out of band area.\n\t */\n\tret = mtd_ooblayout_count_freebytes(mtd);\n\tif (ret < 0)\n\t\tret = 0;\n\n\tmtd->oobavail = ret;\n\n\t/* ECC sanity check: warn if it's too weak */\n\tif (!nand_ecc_is_strong_enough(&chip->base))\n\t\tpr_warn(\"WARNING: %s: the ECC used on your system (%db/%dB) is too weak compared to the one required by the NAND chip (%db/%dB)\\n\",\n\t\t\tmtd->name, chip->ecc.strength, chip->ecc.size,\n\t\t\tnanddev_get_ecc_requirements(&chip->base)->strength,\n\t\t\tnanddev_get_ecc_requirements(&chip->base)->step_size);\n\n\t/* Allow subpage writes up to ecc.steps. Not possible for MLC flash */\n\tif (!(chip->options & NAND_NO_SUBPAGE_WRITE) && nand_is_slc(chip)) {\n\t\tswitch (ecc->steps) {\n\t\tcase 2:\n\t\t\tmtd->subpage_sft = 1;\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tmtd->subpage_sft = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\tchip->subpagesize = mtd->writesize >> mtd->subpage_sft;\n\n\t/* Invalidate the pagebuffer reference */\n\tchip->pagecache.page = -1;\n\n\t/* Large page NAND with SOFT_ECC should support subpage reads */\n\tswitch (ecc->engine_type) {\n\tcase NAND_ECC_ENGINE_TYPE_SOFT:\n\t\tif (chip->page_shift > 9)\n\t\t\tchip->options |= NAND_SUBPAGE_READ;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret = nanddev_init(&chip->base, &rawnand_ops, mtd->owner);\n\tif (ret)\n\t\tgoto err_nand_manuf_cleanup;\n\n\t/* Adjust the MTD_CAP_ flags when NAND_ROM is set. */\n\tif (chip->options & NAND_ROM)\n\t\tmtd->flags = MTD_CAP_ROM;\n\n\t/* Fill in remaining MTD driver data */\n\tmtd->_erase = nand_erase;\n\tmtd->_point = NULL;\n\tmtd->_unpoint = NULL;\n\tmtd->_panic_write = panic_nand_write;\n\tmtd->_read_oob = nand_read_oob;\n\tmtd->_write_oob = nand_write_oob;\n\tmtd->_sync = nand_sync;\n\tmtd->_lock = nand_lock;\n\tmtd->_unlock = nand_unlock;\n\tmtd->_suspend = nand_suspend;\n\tmtd->_resume = nand_resume;\n\tmtd->_reboot = nand_shutdown;\n\tmtd->_block_isreserved = nand_block_isreserved;\n\tmtd->_block_isbad = nand_block_isbad;\n\tmtd->_block_markbad = nand_block_markbad;\n\tmtd->_max_bad_blocks = nanddev_mtd_max_bad_blocks;\n\n\t/*\n\t * Initialize bitflip_threshold to its default prior scan_bbt() call.\n\t * scan_bbt() might invoke mtd_read(), thus bitflip_threshold must be\n\t * properly set.\n\t */\n\tif (!mtd->bitflip_threshold)\n\t\tmtd->bitflip_threshold = DIV_ROUND_UP(mtd->ecc_strength * 3, 4);\n\n\t/* Find the fastest data interface for this chip */\n\tret = nand_choose_interface_config(chip);\n\tif (ret)\n\t\tgoto err_nanddev_cleanup;\n\n\t/* Enter fastest possible mode on all dies. */\n\tfor (i = 0; i < nanddev_ntargets(&chip->base); i++) {\n\t\tret = nand_setup_interface(chip, i);\n\t\tif (ret)\n\t\t\tgoto err_free_interface_config;\n\t}\n\n\t/* Check, if we should skip the bad block table scan */\n\tif (chip->options & NAND_SKIP_BBTSCAN)\n\t\treturn 0;\n\n\t/* Build bad block table */\n\tret = nand_create_bbt(chip);\n\tif (ret)\n\t\tgoto err_free_interface_config;\n\n\treturn 0;\n\nerr_free_interface_config:\n\tkfree(chip->best_interface_config);\n\nerr_nanddev_cleanup:\n\tnanddev_cleanup(&chip->base);\n\nerr_nand_manuf_cleanup:\n\tnand_manufacturer_cleanup(chip);\n\nerr_free_buf:\n\tkfree(chip->data_buf);\n\tkfree(ecc->code_buf);\n\tkfree(ecc->calc_buf);\n\n\treturn ret;\n}\n\nstatic int nand_attach(struct nand_chip *chip)\n{\n\tif (chip->controller->ops && chip->controller->ops->attach_chip)\n\t\treturn chip->controller->ops->attach_chip(chip);\n\n\treturn 0;\n}\n\nstatic void nand_detach(struct nand_chip *chip)\n{\n\tif (chip->controller->ops && chip->controller->ops->detach_chip)\n\t\tchip->controller->ops->detach_chip(chip);\n}\n\n/**\n * nand_scan_with_ids - [NAND Interface] Scan for the NAND device\n * @chip: NAND chip object\n * @maxchips: number of chips to scan for.\n * @ids: optional flash IDs table\n *\n * This fills out all the uninitialized function pointers with the defaults.\n * The flash ID is read and the mtd/chip structures are filled with the\n * appropriate values.\n */\nint nand_scan_with_ids(struct nand_chip *chip, unsigned int maxchips,\n\t\t       struct nand_flash_dev *ids)\n{\n\tint ret;\n\n\tif (!maxchips)\n\t\treturn -EINVAL;\n\n\tret = nand_scan_ident(chip, maxchips, ids);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nand_attach(chip);\n\tif (ret)\n\t\tgoto cleanup_ident;\n\n\tret = nand_scan_tail(chip);\n\tif (ret)\n\t\tgoto detach_chip;\n\n\treturn 0;\n\ndetach_chip:\n\tnand_detach(chip);\ncleanup_ident:\n\tnand_scan_ident_cleanup(chip);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(nand_scan_with_ids);\n\n/**\n * nand_cleanup - [NAND Interface] Free resources held by the NAND device\n * @chip: NAND chip object\n */\nvoid nand_cleanup(struct nand_chip *chip)\n{\n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_SOFT) {\n\t\tif (chip->ecc.algo == NAND_ECC_ALGO_HAMMING)\n\t\t\trawnand_sw_hamming_cleanup(chip);\n\t\telse if (chip->ecc.algo == NAND_ECC_ALGO_BCH)\n\t\t\trawnand_sw_bch_cleanup(chip);\n\t}\n\n\tnanddev_cleanup(&chip->base);\n\n\t/* Free bad block table memory */\n\tkfree(chip->bbt);\n\tkfree(chip->data_buf);\n\tkfree(chip->ecc.code_buf);\n\tkfree(chip->ecc.calc_buf);\n\n\t/* Free bad block descriptor memory */\n\tif (chip->badblock_pattern && chip->badblock_pattern->options\n\t\t\t& NAND_BBT_DYNAMICSTRUCT)\n\t\tkfree(chip->badblock_pattern);\n\n\t/* Free the data interface */\n\tkfree(chip->best_interface_config);\n\n\t/* Free manufacturer priv data. */\n\tnand_manufacturer_cleanup(chip);\n\n\t/* Free controller specific allocations after chip identification */\n\tnand_detach(chip);\n\n\t/* Free identification phase allocations */\n\tnand_scan_ident_cleanup(chip);\n}\n\nEXPORT_SYMBOL_GPL(nand_cleanup);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Steven J. Hill <sjhill@realitydiluted.com>\");\nMODULE_AUTHOR(\"Thomas Gleixner <tglx@linutronix.de>\");\nMODULE_DESCRIPTION(\"Generic NAND flash driver code\");\n"}}, "reports": [{"events": [{"location": {"col": 6, "file": 0, "line": 1466}, "message": "WARNING: Unsigned expression compared with zero: status < 0"}], "macros": [], "notes": [], "path": "/src/drivers/mtd/nand/raw/nand_base.c", "reportHash": "6cddd10a7cfa9ad3970ab2a87032d47e", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
