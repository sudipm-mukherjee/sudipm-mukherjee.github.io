<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/include/net/mac80211.h", "content": "/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * mac80211 <-> driver interface\n *\n * Copyright 2002-2005, Devicescape Software, Inc.\n * Copyright 2006-2007\tJiri Benc <jbenc@suse.cz>\n * Copyright 2007-2010\tJohannes Berg <johannes@sipsolutions.net>\n * Copyright 2013-2014  Intel Mobile Communications GmbH\n * Copyright (C) 2015 - 2017 Intel Deutschland GmbH\n * Copyright (C) 2018 - 2020 Intel Corporation\n */\n\n#ifndef MAC80211_H\n#define MAC80211_H\n\n#include <linux/bug.h>\n#include <linux/kernel.h>\n#include <linux/if_ether.h>\n#include <linux/skbuff.h>\n#include <linux/ieee80211.h>\n#include <net/cfg80211.h>\n#include <net/codel.h>\n#include <net/ieee80211_radiotap.h>\n#include <asm/unaligned.h>\n\n/**\n * DOC: Introduction\n *\n * mac80211 is the Linux stack for 802.11 hardware that implements\n * only partial functionality in hard- or firmware. This document\n * defines the interface between mac80211 and low-level hardware\n * drivers.\n */\n\n/**\n * DOC: Calling mac80211 from interrupts\n *\n * Only ieee80211_tx_status_irqsafe() and ieee80211_rx_irqsafe() can be\n * called in hardware interrupt context. The low-level driver must not call any\n * other functions in hardware interrupt context. If there is a need for such\n * call, the low-level driver should first ACK the interrupt and perform the\n * IEEE 802.11 code call after this, e.g. from a scheduled workqueue or even\n * tasklet function.\n *\n * NOTE: If the driver opts to use the _irqsafe() functions, it may not also\n *\t use the non-IRQ-safe functions!\n */\n\n/**\n * DOC: Warning\n *\n * If you're reading this document and not the header file itself, it will\n * be incomplete because not all documentation has been converted yet.\n */\n\n/**\n * DOC: Frame format\n *\n * As a general rule, when frames are passed between mac80211 and the driver,\n * they start with the IEEE 802.11 header and include the same octets that are\n * sent over the air except for the FCS which should be calculated by the\n * hardware.\n *\n * There are, however, various exceptions to this rule for advanced features:\n *\n * The first exception is for hardware encryption and decryption offload\n * where the IV/ICV may or may not be generated in hardware.\n *\n * Secondly, when the hardware handles fragmentation, the frame handed to\n * the driver from mac80211 is the MSDU, not the MPDU.\n */\n\n/**\n * DOC: mac80211 workqueue\n *\n * mac80211 provides its own workqueue for drivers and internal mac80211 use.\n * The workqueue is a single threaded workqueue and can only be accessed by\n * helpers for sanity checking. Drivers must ensure all work added onto the\n * mac80211 workqueue should be cancelled on the driver stop() callback.\n *\n * mac80211 will flushed the workqueue upon interface removal and during\n * suspend.\n *\n * All work performed on the mac80211 workqueue must not acquire the RTNL lock.\n *\n */\n\n/**\n * DOC: mac80211 software tx queueing\n *\n * mac80211 provides an optional intermediate queueing implementation designed\n * to allow the driver to keep hardware queues short and provide some fairness\n * between different stations/interfaces.\n * In this model, the driver pulls data frames from the mac80211 queue instead\n * of letting mac80211 push them via drv_tx().\n * Other frames (e.g. control or management) are still pushed using drv_tx().\n *\n * Drivers indicate that they use this model by implementing the .wake_tx_queue\n * driver operation.\n *\n * Intermediate queues (struct ieee80211_txq) are kept per-sta per-tid, with\n * another per-sta for non-data/non-mgmt and bufferable management frames, and\n * a single per-vif queue for multicast data frames.\n *\n * The driver is expected to initialize its private per-queue data for stations\n * and interfaces in the .add_interface and .sta_add ops.\n *\n * The driver can't access the queue directly. To dequeue a frame from a\n * txq, it calls ieee80211_tx_dequeue(). Whenever mac80211 adds a new frame to a\n * queue, it calls the .wake_tx_queue driver op.\n *\n * Drivers can optionally delegate responsibility for scheduling queues to\n * mac80211, to take advantage of airtime fairness accounting. In this case, to\n * obtain the next queue to pull frames from, the driver calls\n * ieee80211_next_txq(). The driver is then expected to return the txq using\n * ieee80211_return_txq().\n *\n * For AP powersave TIM handling, the driver only needs to indicate if it has\n * buffered packets in the driver specific data structures by calling\n * ieee80211_sta_set_buffered(). For frames buffered in the ieee80211_txq\n * struct, mac80211 sets the appropriate TIM PVB bits and calls\n * .release_buffered_frames().\n * In that callback the driver is therefore expected to release its own\n * buffered frames and afterwards also frames from the ieee80211_txq (obtained\n * via the usual ieee80211_tx_dequeue).\n */\n\nstruct device;\n\n/**\n * enum ieee80211_max_queues - maximum number of queues\n *\n * @IEEE80211_MAX_QUEUES: Maximum number of regular device queues.\n * @IEEE80211_MAX_QUEUE_MAP: bitmap with maximum queues set\n */\nenum ieee80211_max_queues {\n\tIEEE80211_MAX_QUEUES =\t\t16,\n\tIEEE80211_MAX_QUEUE_MAP =\tBIT(IEEE80211_MAX_QUEUES) - 1,\n};\n\n#define IEEE80211_INVAL_HW_QUEUE\t0xff\n\n/**\n * enum ieee80211_ac_numbers - AC numbers as used in mac80211\n * @IEEE80211_AC_VO: voice\n * @IEEE80211_AC_VI: video\n * @IEEE80211_AC_BE: best effort\n * @IEEE80211_AC_BK: background\n */\nenum ieee80211_ac_numbers {\n\tIEEE80211_AC_VO\t\t= 0,\n\tIEEE80211_AC_VI\t\t= 1,\n\tIEEE80211_AC_BE\t\t= 2,\n\tIEEE80211_AC_BK\t\t= 3,\n};\n\n/**\n * struct ieee80211_tx_queue_params - transmit queue configuration\n *\n * The information provided in this structure is required for QoS\n * transmit queue configuration. Cf. IEEE 802.11 7.3.2.29.\n *\n * @aifs: arbitration interframe space [0..255]\n * @cw_min: minimum contention window [a value of the form\n *\t2^n-1 in the range 1..32767]\n * @cw_max: maximum contention window [like @cw_min]\n * @txop: maximum burst time in units of 32 usecs, 0 meaning disabled\n * @acm: is mandatory admission control required for the access category\n * @uapsd: is U-APSD mode enabled for the queue\n * @mu_edca: is the MU EDCA configured\n * @mu_edca_param_rec: MU EDCA Parameter Record for HE\n */\nstruct ieee80211_tx_queue_params {\n\tu16 txop;\n\tu16 cw_min;\n\tu16 cw_max;\n\tu8 aifs;\n\tbool acm;\n\tbool uapsd;\n\tbool mu_edca;\n\tstruct ieee80211_he_mu_edca_param_ac_rec mu_edca_param_rec;\n};\n\nstruct ieee80211_low_level_stats {\n\tunsigned int dot11ACKFailureCount;\n\tunsigned int dot11RTSFailureCount;\n\tunsigned int dot11FCSErrorCount;\n\tunsigned int dot11RTSSuccessCount;\n};\n\n/**\n * enum ieee80211_chanctx_change - change flag for channel context\n * @IEEE80211_CHANCTX_CHANGE_WIDTH: The channel width changed\n * @IEEE80211_CHANCTX_CHANGE_RX_CHAINS: The number of RX chains changed\n * @IEEE80211_CHANCTX_CHANGE_RADAR: radar detection flag changed\n * @IEEE80211_CHANCTX_CHANGE_CHANNEL: switched to another operating channel,\n *\tthis is used only with channel switching with CSA\n * @IEEE80211_CHANCTX_CHANGE_MIN_WIDTH: The min required channel width changed\n */\nenum ieee80211_chanctx_change {\n\tIEEE80211_CHANCTX_CHANGE_WIDTH\t\t= BIT(0),\n\tIEEE80211_CHANCTX_CHANGE_RX_CHAINS\t= BIT(1),\n\tIEEE80211_CHANCTX_CHANGE_RADAR\t\t= BIT(2),\n\tIEEE80211_CHANCTX_CHANGE_CHANNEL\t= BIT(3),\n\tIEEE80211_CHANCTX_CHANGE_MIN_WIDTH\t= BIT(4),\n};\n\n/**\n * struct ieee80211_chanctx_conf - channel context that vifs may be tuned to\n *\n * This is the driver-visible part. The ieee80211_chanctx\n * that contains it is visible in mac80211 only.\n *\n * @def: the channel definition\n * @min_def: the minimum channel definition currently required.\n * @rx_chains_static: The number of RX chains that must always be\n *\tactive on the channel to receive MIMO transmissions\n * @rx_chains_dynamic: The number of RX chains that must be enabled\n *\tafter RTS/CTS handshake to receive SMPS MIMO transmissions;\n *\tthis will always be >= @rx_chains_static.\n * @radar_enabled: whether radar detection is enabled on this channel.\n * @drv_priv: data area for driver use, will always be aligned to\n *\tsizeof(void *), size is determined in hw information.\n */\nstruct ieee80211_chanctx_conf {\n\tstruct cfg80211_chan_def def;\n\tstruct cfg80211_chan_def min_def;\n\n\tu8 rx_chains_static, rx_chains_dynamic;\n\n\tbool radar_enabled;\n\n\tu8 drv_priv[] __aligned(sizeof(void *));\n};\n\n/**\n * enum ieee80211_chanctx_switch_mode - channel context switch mode\n * @CHANCTX_SWMODE_REASSIGN_VIF: Both old and new contexts already\n *\texist (and will continue to exist), but the virtual interface\n *\tneeds to be switched from one to the other.\n * @CHANCTX_SWMODE_SWAP_CONTEXTS: The old context exists but will stop\n *      to exist with this call, the new context doesn't exist but\n *      will be active after this call, the virtual interface switches\n *      from the old to the new (note that the driver may of course\n *      implement this as an on-the-fly chandef switch of the existing\n *      hardware context, but the mac80211 pointer for the old context\n *      will cease to exist and only the new one will later be used\n *      for changes/removal.)\n */\nenum ieee80211_chanctx_switch_mode {\n\tCHANCTX_SWMODE_REASSIGN_VIF,\n\tCHANCTX_SWMODE_SWAP_CONTEXTS,\n};\n\n/**\n * struct ieee80211_vif_chanctx_switch - vif chanctx switch information\n *\n * This is structure is used to pass information about a vif that\n * needs to switch from one chanctx to another.  The\n * &ieee80211_chanctx_switch_mode defines how the switch should be\n * done.\n *\n * @vif: the vif that should be switched from old_ctx to new_ctx\n * @old_ctx: the old context to which the vif was assigned\n * @new_ctx: the new context to which the vif must be assigned\n */\nstruct ieee80211_vif_chanctx_switch {\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_chanctx_conf *old_ctx;\n\tstruct ieee80211_chanctx_conf *new_ctx;\n};\n\n/**\n * enum ieee80211_bss_change - BSS change notification flags\n *\n * These flags are used with the bss_info_changed() callback\n * to indicate which BSS parameter changed.\n *\n * @BSS_CHANGED_ASSOC: association status changed (associated/disassociated),\n *\talso implies a change in the AID.\n * @BSS_CHANGED_ERP_CTS_PROT: CTS protection changed\n * @BSS_CHANGED_ERP_PREAMBLE: preamble changed\n * @BSS_CHANGED_ERP_SLOT: slot timing changed\n * @BSS_CHANGED_HT: 802.11n parameters changed\n * @BSS_CHANGED_BASIC_RATES: Basic rateset changed\n * @BSS_CHANGED_BEACON_INT: Beacon interval changed\n * @BSS_CHANGED_BSSID: BSSID changed, for whatever\n *\treason (IBSS and managed mode)\n * @BSS_CHANGED_BEACON: Beacon data changed, retrieve\n *\tnew beacon (beaconing modes)\n * @BSS_CHANGED_BEACON_ENABLED: Beaconing should be\n *\tenabled/disabled (beaconing modes)\n * @BSS_CHANGED_CQM: Connection quality monitor config changed\n * @BSS_CHANGED_IBSS: IBSS join status changed\n * @BSS_CHANGED_ARP_FILTER: Hardware ARP filter address list or state changed.\n * @BSS_CHANGED_QOS: QoS for this association was enabled/disabled. Note\n *\tthat it is only ever disabled for station mode.\n * @BSS_CHANGED_IDLE: Idle changed for this BSS/interface.\n * @BSS_CHANGED_SSID: SSID changed for this BSS (AP and IBSS mode)\n * @BSS_CHANGED_AP_PROBE_RESP: Probe Response changed for this BSS (AP mode)\n * @BSS_CHANGED_PS: PS changed for this BSS (STA mode)\n * @BSS_CHANGED_TXPOWER: TX power setting changed for this interface\n * @BSS_CHANGED_P2P_PS: P2P powersave settings (CTWindow, opportunistic PS)\n *\tchanged\n * @BSS_CHANGED_BEACON_INFO: Data from the AP's beacon became available:\n *\tcurrently dtim_period only is under consideration.\n * @BSS_CHANGED_BANDWIDTH: The bandwidth used by this interface changed,\n *\tnote that this is only called when it changes after the channel\n *\tcontext had been assigned.\n * @BSS_CHANGED_OCB: OCB join status changed\n * @BSS_CHANGED_MU_GROUPS: VHT MU-MIMO group id or user position changed\n * @BSS_CHANGED_KEEP_ALIVE: keep alive options (idle period or protected\n *\tkeep alive) changed.\n * @BSS_CHANGED_MCAST_RATE: Multicast Rate setting changed for this interface\n * @BSS_CHANGED_FTM_RESPONDER: fine timing measurement request responder\n *\tfunctionality changed for this BSS (AP mode).\n * @BSS_CHANGED_TWT: TWT status changed\n * @BSS_CHANGED_HE_OBSS_PD: OBSS Packet Detection status changed.\n * @BSS_CHANGED_HE_BSS_COLOR: BSS Color has changed\n * @BSS_CHANGED_FILS_DISCOVERY: FILS discovery status changed.\n * @BSS_CHANGED_UNSOL_BCAST_PROBE_RESP: Unsolicited broadcast probe response\n *\tstatus changed.\n *\n */\nenum ieee80211_bss_change {\n\tBSS_CHANGED_ASSOC\t\t= 1<<0,\n\tBSS_CHANGED_ERP_CTS_PROT\t= 1<<1,\n\tBSS_CHANGED_ERP_PREAMBLE\t= 1<<2,\n\tBSS_CHANGED_ERP_SLOT\t\t= 1<<3,\n\tBSS_CHANGED_HT\t\t\t= 1<<4,\n\tBSS_CHANGED_BASIC_RATES\t\t= 1<<5,\n\tBSS_CHANGED_BEACON_INT\t\t= 1<<6,\n\tBSS_CHANGED_BSSID\t\t= 1<<7,\n\tBSS_CHANGED_BEACON\t\t= 1<<8,\n\tBSS_CHANGED_BEACON_ENABLED\t= 1<<9,\n\tBSS_CHANGED_CQM\t\t\t= 1<<10,\n\tBSS_CHANGED_IBSS\t\t= 1<<11,\n\tBSS_CHANGED_ARP_FILTER\t\t= 1<<12,\n\tBSS_CHANGED_QOS\t\t\t= 1<<13,\n\tBSS_CHANGED_IDLE\t\t= 1<<14,\n\tBSS_CHANGED_SSID\t\t= 1<<15,\n\tBSS_CHANGED_AP_PROBE_RESP\t= 1<<16,\n\tBSS_CHANGED_PS\t\t\t= 1<<17,\n\tBSS_CHANGED_TXPOWER\t\t= 1<<18,\n\tBSS_CHANGED_P2P_PS\t\t= 1<<19,\n\tBSS_CHANGED_BEACON_INFO\t\t= 1<<20,\n\tBSS_CHANGED_BANDWIDTH\t\t= 1<<21,\n\tBSS_CHANGED_OCB                 = 1<<22,\n\tBSS_CHANGED_MU_GROUPS\t\t= 1<<23,\n\tBSS_CHANGED_KEEP_ALIVE\t\t= 1<<24,\n\tBSS_CHANGED_MCAST_RATE\t\t= 1<<25,\n\tBSS_CHANGED_FTM_RESPONDER\t= 1<<26,\n\tBSS_CHANGED_TWT\t\t\t= 1<<27,\n\tBSS_CHANGED_HE_OBSS_PD\t\t= 1<<28,\n\tBSS_CHANGED_HE_BSS_COLOR\t= 1<<29,\n\tBSS_CHANGED_FILS_DISCOVERY      = 1<<30,\n\tBSS_CHANGED_UNSOL_BCAST_PROBE_RESP = 1<<31,\n\n\t/* when adding here, make sure to change ieee80211_reconfig */\n};\n\n/*\n * The maximum number of IPv4 addresses listed for ARP filtering. If the number\n * of addresses for an interface increase beyond this value, hardware ARP\n * filtering will be disabled.\n */\n#define IEEE80211_BSS_ARP_ADDR_LIST_LEN 4\n\n/**\n * enum ieee80211_event_type - event to be notified to the low level driver\n * @RSSI_EVENT: AP's rssi crossed the a threshold set by the driver.\n * @MLME_EVENT: event related to MLME\n * @BAR_RX_EVENT: a BAR was received\n * @BA_FRAME_TIMEOUT: Frames were released from the reordering buffer because\n *\tthey timed out. This won't be called for each frame released, but only\n *\tonce each time the timeout triggers.\n */\nenum ieee80211_event_type {\n\tRSSI_EVENT,\n\tMLME_EVENT,\n\tBAR_RX_EVENT,\n\tBA_FRAME_TIMEOUT,\n};\n\n/**\n * enum ieee80211_rssi_event_data - relevant when event type is %RSSI_EVENT\n * @RSSI_EVENT_HIGH: AP's rssi went below the threshold set by the driver.\n * @RSSI_EVENT_LOW: AP's rssi went above the threshold set by the driver.\n */\nenum ieee80211_rssi_event_data {\n\tRSSI_EVENT_HIGH,\n\tRSSI_EVENT_LOW,\n};\n\n/**\n * struct ieee80211_rssi_event - data attached to an %RSSI_EVENT\n * @data: See &enum ieee80211_rssi_event_data\n */\nstruct ieee80211_rssi_event {\n\tenum ieee80211_rssi_event_data data;\n};\n\n/**\n * enum ieee80211_mlme_event_data - relevant when event type is %MLME_EVENT\n * @AUTH_EVENT: the MLME operation is authentication\n * @ASSOC_EVENT: the MLME operation is association\n * @DEAUTH_RX_EVENT: deauth received..\n * @DEAUTH_TX_EVENT: deauth sent.\n */\nenum ieee80211_mlme_event_data {\n\tAUTH_EVENT,\n\tASSOC_EVENT,\n\tDEAUTH_RX_EVENT,\n\tDEAUTH_TX_EVENT,\n};\n\n/**\n * enum ieee80211_mlme_event_status - relevant when event type is %MLME_EVENT\n * @MLME_SUCCESS: the MLME operation completed successfully.\n * @MLME_DENIED: the MLME operation was denied by the peer.\n * @MLME_TIMEOUT: the MLME operation timed out.\n */\nenum ieee80211_mlme_event_status {\n\tMLME_SUCCESS,\n\tMLME_DENIED,\n\tMLME_TIMEOUT,\n};\n\n/**\n * struct ieee80211_mlme_event - data attached to an %MLME_EVENT\n * @data: See &enum ieee80211_mlme_event_data\n * @status: See &enum ieee80211_mlme_event_status\n * @reason: the reason code if applicable\n */\nstruct ieee80211_mlme_event {\n\tenum ieee80211_mlme_event_data data;\n\tenum ieee80211_mlme_event_status status;\n\tu16 reason;\n};\n\n/**\n * struct ieee80211_ba_event - data attached for BlockAck related events\n * @sta: pointer to the &ieee80211_sta to which this event relates\n * @tid: the tid\n * @ssn: the starting sequence number (for %BAR_RX_EVENT)\n */\nstruct ieee80211_ba_event {\n\tstruct ieee80211_sta *sta;\n\tu16 tid;\n\tu16 ssn;\n};\n\n/**\n * struct ieee80211_event - event to be sent to the driver\n * @type: The event itself. See &enum ieee80211_event_type.\n * @rssi: relevant if &type is %RSSI_EVENT\n * @mlme: relevant if &type is %AUTH_EVENT\n * @ba: relevant if &type is %BAR_RX_EVENT or %BA_FRAME_TIMEOUT\n * @u:union holding the fields above\n */\nstruct ieee80211_event {\n\tenum ieee80211_event_type type;\n\tunion {\n\t\tstruct ieee80211_rssi_event rssi;\n\t\tstruct ieee80211_mlme_event mlme;\n\t\tstruct ieee80211_ba_event ba;\n\t} u;\n};\n\n/**\n * struct ieee80211_mu_group_data - STA's VHT MU-MIMO group data\n *\n * This structure describes the group id data of VHT MU-MIMO\n *\n * @membership: 64 bits array - a bit is set if station is member of the group\n * @position: 2 bits per group id indicating the position in the group\n */\nstruct ieee80211_mu_group_data {\n\tu8 membership[WLAN_MEMBERSHIP_LEN];\n\tu8 position[WLAN_USER_POSITION_LEN];\n};\n\n/**\n * struct ieee80211_ftm_responder_params - FTM responder parameters\n *\n * @lci: LCI subelement content\n * @civicloc: CIVIC location subelement content\n * @lci_len: LCI data length\n * @civicloc_len: Civic data length\n */\nstruct ieee80211_ftm_responder_params {\n\tconst u8 *lci;\n\tconst u8 *civicloc;\n\tsize_t lci_len;\n\tsize_t civicloc_len;\n};\n\n/**\n * struct ieee80211_fils_discovery - FILS discovery parameters from\n * IEEE Std 802.11ai-2016, Annex C.3 MIB detail.\n *\n * @min_interval: Minimum packet interval in TUs (0 - 10000)\n * @max_interval: Maximum packet interval in TUs (0 - 10000)\n */\nstruct ieee80211_fils_discovery {\n\tu32 min_interval;\n\tu32 max_interval;\n};\n\n/**\n * struct ieee80211_bss_conf - holds the BSS's changing parameters\n *\n * This structure keeps information about a BSS (and an association\n * to that BSS) that can change during the lifetime of the BSS.\n *\n * @htc_trig_based_pkt_ext: default PE in 4us units, if BSS supports HE\n * @multi_sta_back_32bit: supports BA bitmap of 32-bits in Multi-STA BACK\n * @uora_exists: is the UORA element advertised by AP\n * @ack_enabled: indicates support to receive a multi-TID that solicits either\n *\tACK, BACK or both\n * @uora_ocw_range: UORA element's OCW Range field\n * @frame_time_rts_th: HE duration RTS threshold, in units of 32us\n * @he_support: does this BSS support HE\n * @twt_requester: does this BSS support TWT requester (relevant for managed\n *\tmode only, set if the AP advertises TWT responder role)\n * @twt_responder: does this BSS support TWT requester (relevant for managed\n *\tmode only, set if the AP advertises TWT responder role)\n * @twt_protected: does this BSS support protected TWT frames\n * @assoc: association status\n * @ibss_joined: indicates whether this station is part of an IBSS\n *\tor not\n * @ibss_creator: indicates if a new IBSS network is being created\n * @aid: association ID number, valid only when @assoc is true\n * @use_cts_prot: use CTS protection\n * @use_short_preamble: use 802.11b short preamble\n * @use_short_slot: use short slot time (only relevant for ERP)\n * @dtim_period: num of beacons before the next DTIM, for beaconing,\n *\tvalid in station mode only if after the driver was notified\n *\twith the %BSS_CHANGED_BEACON_INFO flag, will be non-zero then.\n * @sync_tsf: last beacon's/probe response's TSF timestamp (could be old\n *\tas it may have been received during scanning long ago). If the\n *\tHW flag %IEEE80211_HW_TIMING_BEACON_ONLY is set, then this can\n *\tonly come from a beacon, but might not become valid until after\n *\tassociation when a beacon is received (which is notified with the\n *\t%BSS_CHANGED_DTIM flag.). See also sync_dtim_count important notice.\n * @sync_device_ts: the device timestamp corresponding to the sync_tsf,\n *\tthe driver/device can use this to calculate synchronisation\n *\t(see @sync_tsf). See also sync_dtim_count important notice.\n * @sync_dtim_count: Only valid when %IEEE80211_HW_TIMING_BEACON_ONLY\n *\tis requested, see @sync_tsf/@sync_device_ts.\n *\tIMPORTANT: These three sync_* parameters would possibly be out of sync\n *\tby the time the driver will use them. The synchronized view is currently\n *\tguaranteed only in certain callbacks.\n * @beacon_int: beacon interval\n * @assoc_capability: capabilities taken from assoc resp\n * @basic_rates: bitmap of basic rates, each bit stands for an\n *\tindex into the rate table configured by the driver in\n *\tthe current band.\n * @beacon_rate: associated AP's beacon TX rate\n * @mcast_rate: per-band multicast rate index + 1 (0: disabled)\n * @bssid: The BSSID for this BSS\n * @enable_beacon: whether beaconing should be enabled or not\n * @chandef: Channel definition for this BSS -- the hardware might be\n *\tconfigured a higher bandwidth than this BSS uses, for example.\n * @mu_group: VHT MU-MIMO group membership data\n * @ht_operation_mode: HT operation mode like in &struct ieee80211_ht_operation.\n *\tThis field is only valid when the channel is a wide HT/VHT channel.\n *\tNote that with TDLS this can be the case (channel is HT, protection must\n *\tbe used from this field) even when the BSS association isn't using HT.\n * @cqm_rssi_thold: Connection quality monitor RSSI threshold, a zero value\n *\timplies disabled. As with the cfg80211 callback, a change here should\n *\tcause an event to be sent indicating where the current value is in\n *\trelation to the newly configured threshold.\n * @cqm_rssi_low: Connection quality monitor RSSI lower threshold, a zero value\n *\timplies disabled.  This is an alternative mechanism to the single\n *\tthreshold event and can't be enabled simultaneously with it.\n * @cqm_rssi_high: Connection quality monitor RSSI upper threshold.\n * @cqm_rssi_hyst: Connection quality monitor RSSI hysteresis\n * @arp_addr_list: List of IPv4 addresses for hardware ARP filtering. The\n *\tmay filter ARP queries targeted for other addresses than listed here.\n *\tThe driver must allow ARP queries targeted for all address listed here\n *\tto pass through. An empty list implies no ARP queries need to pass.\n * @arp_addr_cnt: Number of addresses currently on the list. Note that this\n *\tmay be larger than %IEEE80211_BSS_ARP_ADDR_LIST_LEN (the arp_addr_list\n *\tarray size), it's up to the driver what to do in that case.\n * @qos: This is a QoS-enabled BSS.\n * @idle: This interface is idle. There's also a global idle flag in the\n *\thardware config which may be more appropriate depending on what\n *\tyour driver/device needs to do.\n * @ps: power-save mode (STA only). This flag is NOT affected by\n *\toffchannel/dynamic_ps operations.\n * @ssid: The SSID of the current vif. Valid in AP and IBSS mode.\n * @ssid_len: Length of SSID given in @ssid.\n * @hidden_ssid: The SSID of the current vif is hidden. Only valid in AP-mode.\n * @txpower: TX power in dBm.  INT_MIN means not configured.\n * @txpower_type: TX power adjustment used to control per packet Transmit\n *\tPower Control (TPC) in lower driver for the current vif. In particular\n *\tTPC is enabled if value passed in %txpower_type is\n *\tNL80211_TX_POWER_LIMITED (allow using less than specified from\n *\tuserspace), whereas TPC is disabled if %txpower_type is set to\n *\tNL80211_TX_POWER_FIXED (use value configured from userspace)\n * @p2p_noa_attr: P2P NoA attribute for P2P powersave\n * @allow_p2p_go_ps: indication for AP or P2P GO interface, whether it's allowed\n *\tto use P2P PS mechanism or not. AP/P2P GO is not allowed to use P2P PS\n *\tif it has associated clients without P2P PS support.\n * @max_idle_period: the time period during which the station can refrain from\n *\ttransmitting frames to its associated AP without being disassociated.\n *\tIn units of 1000 TUs. Zero value indicates that the AP did not include\n *\ta (valid) BSS Max Idle Period Element.\n * @protected_keep_alive: if set, indicates that the station should send an RSN\n *\tprotected frame to the AP to reset the idle timer at the AP for the\n *\tstation.\n * @ftm_responder: whether to enable or disable fine timing measurement FTM\n *\tresponder functionality.\n * @ftmr_params: configurable lci/civic parameter when enabling FTM responder.\n * @nontransmitted: this BSS is a nontransmitted BSS profile\n * @transmitter_bssid: the address of transmitter AP\n * @bssid_index: index inside the multiple BSSID set\n * @bssid_indicator: 2^bssid_indicator is the maximum number of APs in set\n * @ema_ap: AP supports enhancements of discovery and advertisement of\n *\tnontransmitted BSSIDs\n * @profile_periodicity: the least number of beacon frames need to be received\n *\tin order to discover all the nontransmitted BSSIDs in the set.\n * @he_oper: HE operation information of the AP we are connected to\n * @he_obss_pd: OBSS Packet Detection parameters.\n * @he_bss_color: BSS coloring settings, if BSS supports HE\n * @fils_discovery: FILS discovery configuration\n * @unsol_bcast_probe_resp_interval: Unsolicited broadcast probe response\n *\tinterval.\n * @s1g: BSS is S1G BSS (affects Association Request format).\n * @beacon_tx_rate: The configured beacon transmit rate that needs to be passed\n *\tto driver when rate control is offloaded to firmware.\n */\nstruct ieee80211_bss_conf {\n\tconst u8 *bssid;\n\tu8 htc_trig_based_pkt_ext;\n\tbool multi_sta_back_32bit;\n\tbool uora_exists;\n\tbool ack_enabled;\n\tu8 uora_ocw_range;\n\tu16 frame_time_rts_th;\n\tbool he_support;\n\tbool twt_requester;\n\tbool twt_responder;\n\tbool twt_protected;\n\t/* association related data */\n\tbool assoc, ibss_joined;\n\tbool ibss_creator;\n\tu16 aid;\n\t/* erp related data */\n\tbool use_cts_prot;\n\tbool use_short_preamble;\n\tbool use_short_slot;\n\tbool enable_beacon;\n\tu8 dtim_period;\n\tu16 beacon_int;\n\tu16 assoc_capability;\n\tu64 sync_tsf;\n\tu32 sync_device_ts;\n\tu8 sync_dtim_count;\n\tu32 basic_rates;\n\tstruct ieee80211_rate *beacon_rate;\n\tint mcast_rate[NUM_NL80211_BANDS];\n\tu16 ht_operation_mode;\n\ts32 cqm_rssi_thold;\n\tu32 cqm_rssi_hyst;\n\ts32 cqm_rssi_low;\n\ts32 cqm_rssi_high;\n\tstruct cfg80211_chan_def chandef;\n\tstruct ieee80211_mu_group_data mu_group;\n\t__be32 arp_addr_list[IEEE80211_BSS_ARP_ADDR_LIST_LEN];\n\tint arp_addr_cnt;\n\tbool qos;\n\tbool idle;\n\tbool ps;\n\tu8 ssid[IEEE80211_MAX_SSID_LEN];\n\tsize_t ssid_len;\n\tbool hidden_ssid;\n\tint txpower;\n\tenum nl80211_tx_power_setting txpower_type;\n\tstruct ieee80211_p2p_noa_attr p2p_noa_attr;\n\tbool allow_p2p_go_ps;\n\tu16 max_idle_period;\n\tbool protected_keep_alive;\n\tbool ftm_responder;\n\tstruct ieee80211_ftm_responder_params *ftmr_params;\n\t/* Multiple BSSID data */\n\tbool nontransmitted;\n\tu8 transmitter_bssid[ETH_ALEN];\n\tu8 bssid_index;\n\tu8 bssid_indicator;\n\tbool ema_ap;\n\tu8 profile_periodicity;\n\tstruct {\n\t\tu32 params;\n\t\tu16 nss_set;\n\t} he_oper;\n\tstruct ieee80211_he_obss_pd he_obss_pd;\n\tstruct cfg80211_he_bss_color he_bss_color;\n\tstruct ieee80211_fils_discovery fils_discovery;\n\tu32 unsol_bcast_probe_resp_interval;\n\tbool s1g;\n\tstruct cfg80211_bitrate_mask beacon_tx_rate;\n};\n\n/**\n * enum mac80211_tx_info_flags - flags to describe transmission information/status\n *\n * These flags are used with the @flags member of &ieee80211_tx_info.\n *\n * @IEEE80211_TX_CTL_REQ_TX_STATUS: require TX status callback for this frame.\n * @IEEE80211_TX_CTL_ASSIGN_SEQ: The driver has to assign a sequence\n *\tnumber to this frame, taking care of not overwriting the fragment\n *\tnumber and increasing the sequence number only when the\n *\tIEEE80211_TX_CTL_FIRST_FRAGMENT flag is set. mac80211 will properly\n *\tassign sequence numbers to QoS-data frames but cannot do so correctly\n *\tfor non-QoS-data and management frames because beacons need them from\n *\tthat counter as well and mac80211 cannot guarantee proper sequencing.\n *\tIf this flag is set, the driver should instruct the hardware to\n *\tassign a sequence number to the frame or assign one itself. Cf. IEEE\n *\t802.11-2007 7.1.3.4.1 paragraph 3. This flag will always be set for\n *\tbeacons and always be clear for frames without a sequence number field.\n * @IEEE80211_TX_CTL_NO_ACK: tell the low level not to wait for an ack\n * @IEEE80211_TX_CTL_CLEAR_PS_FILT: clear powersave filter for destination\n *\tstation\n * @IEEE80211_TX_CTL_FIRST_FRAGMENT: this is a first fragment of the frame\n * @IEEE80211_TX_CTL_SEND_AFTER_DTIM: send this frame after DTIM beacon\n * @IEEE80211_TX_CTL_AMPDU: this frame should be sent as part of an A-MPDU\n * @IEEE80211_TX_CTL_INJECTED: Frame was injected, internal to mac80211.\n * @IEEE80211_TX_STAT_TX_FILTERED: The frame was not transmitted\n *\tbecause the destination STA was in powersave mode. Note that to\n *\tavoid race conditions, the filter must be set by the hardware or\n *\tfirmware upon receiving a frame that indicates that the station\n *\twent to sleep (must be done on device to filter frames already on\n *\tthe queue) and may only be unset after mac80211 gives the OK for\n *\tthat by setting the IEEE80211_TX_CTL_CLEAR_PS_FILT (see above),\n *\tsince only then is it guaranteed that no more frames are in the\n *\thardware queue.\n * @IEEE80211_TX_STAT_ACK: Frame was acknowledged\n * @IEEE80211_TX_STAT_AMPDU: The frame was aggregated, so status\n * \tis for the whole aggregation.\n * @IEEE80211_TX_STAT_AMPDU_NO_BACK: no block ack was returned,\n * \tso consider using block ack request (BAR).\n * @IEEE80211_TX_CTL_RATE_CTRL_PROBE: internal to mac80211, can be\n *\tset by rate control algorithms to indicate probe rate, will\n *\tbe cleared for fragmented frames (except on the last fragment)\n * @IEEE80211_TX_INTFL_OFFCHAN_TX_OK: Internal to mac80211. Used to indicate\n *\tthat a frame can be transmitted while the queues are stopped for\n *\toff-channel operation.\n * @IEEE80211_TX_CTL_HW_80211_ENCAP: This frame uses hardware encapsulation\n *\t(header conversion)\n * @IEEE80211_TX_INTFL_RETRIED: completely internal to mac80211,\n *\tused to indicate that a frame was already retried due to PS\n * @IEEE80211_TX_INTFL_DONT_ENCRYPT: completely internal to mac80211,\n *\tused to indicate frame should not be encrypted\n * @IEEE80211_TX_CTL_NO_PS_BUFFER: This frame is a response to a poll\n *\tframe (PS-Poll or uAPSD) or a non-bufferable MMPDU and must\n *\tbe sent although the station is in powersave mode.\n * @IEEE80211_TX_CTL_MORE_FRAMES: More frames will be passed to the\n *\ttransmit function after the current frame, this can be used\n *\tby drivers to kick the DMA queue only if unset or when the\n *\tqueue gets full.\n * @IEEE80211_TX_INTFL_RETRANSMISSION: This frame is being retransmitted\n *\tafter TX status because the destination was asleep, it must not\n *\tbe modified again (no seqno assignment, crypto, etc.)\n * @IEEE80211_TX_INTFL_MLME_CONN_TX: This frame was transmitted by the MLME\n *\tcode for connection establishment, this indicates that its status\n *\tshould kick the MLME state machine.\n * @IEEE80211_TX_INTFL_NL80211_FRAME_TX: Frame was requested through nl80211\n *\tMLME command (internal to mac80211 to figure out whether to send TX\n *\tstatus to user space)\n * @IEEE80211_TX_CTL_LDPC: tells the driver to use LDPC for this frame\n * @IEEE80211_TX_CTL_STBC: Enables Space-Time Block Coding (STBC) for this\n *\tframe and selects the maximum number of streams that it can use.\n * @IEEE80211_TX_CTL_TX_OFFCHAN: Marks this packet to be transmitted on\n *\tthe off-channel channel when a remain-on-channel offload is done\n *\tin hardware -- normal packets still flow and are expected to be\n *\thandled properly by the device.\n * @IEEE80211_TX_INTFL_TKIP_MIC_FAILURE: Marks this packet to be used for TKIP\n *\ttesting. It will be sent out with incorrect Michael MIC key to allow\n *\tTKIP countermeasures to be tested.\n * @IEEE80211_TX_CTL_NO_CCK_RATE: This frame will be sent at non CCK rate.\n *\tThis flag is actually used for management frame especially for P2P\n *\tframes not being sent at CCK rate in 2GHz band.\n * @IEEE80211_TX_STATUS_EOSP: This packet marks the end of service period,\n *\twhen its status is reported the service period ends. For frames in\n *\tan SP that mac80211 transmits, it is already set; for driver frames\n *\tthe driver may set this flag. It is also used to do the same for\n *\tPS-Poll responses.\n * @IEEE80211_TX_CTL_USE_MINRATE: This frame will be sent at lowest rate.\n *\tThis flag is used to send nullfunc frame at minimum rate when\n *\tthe nullfunc is used for connection monitoring purpose.\n * @IEEE80211_TX_CTL_DONTFRAG: Don't fragment this packet even if it\n *\twould be fragmented by size (this is optional, only used for\n *\tmonitor injection).\n * @IEEE80211_TX_STAT_NOACK_TRANSMITTED: A frame that was marked with\n *\tIEEE80211_TX_CTL_NO_ACK has been successfully transmitted without\n *\tany errors (like issues specific to the driver/HW).\n *\tThis flag must not be set for frames that don't request no-ack\n *\tbehaviour with IEEE80211_TX_CTL_NO_ACK.\n *\n * Note: If you have to add new flags to the enumeration, then don't\n *\t forget to update %IEEE80211_TX_TEMPORARY_FLAGS when necessary.\n */\nenum mac80211_tx_info_flags {\n\tIEEE80211_TX_CTL_REQ_TX_STATUS\t\t= BIT(0),\n\tIEEE80211_TX_CTL_ASSIGN_SEQ\t\t= BIT(1),\n\tIEEE80211_TX_CTL_NO_ACK\t\t\t= BIT(2),\n\tIEEE80211_TX_CTL_CLEAR_PS_FILT\t\t= BIT(3),\n\tIEEE80211_TX_CTL_FIRST_FRAGMENT\t\t= BIT(4),\n\tIEEE80211_TX_CTL_SEND_AFTER_DTIM\t= BIT(5),\n\tIEEE80211_TX_CTL_AMPDU\t\t\t= BIT(6),\n\tIEEE80211_TX_CTL_INJECTED\t\t= BIT(7),\n\tIEEE80211_TX_STAT_TX_FILTERED\t\t= BIT(8),\n\tIEEE80211_TX_STAT_ACK\t\t\t= BIT(9),\n\tIEEE80211_TX_STAT_AMPDU\t\t\t= BIT(10),\n\tIEEE80211_TX_STAT_AMPDU_NO_BACK\t\t= BIT(11),\n\tIEEE80211_TX_CTL_RATE_CTRL_PROBE\t= BIT(12),\n\tIEEE80211_TX_INTFL_OFFCHAN_TX_OK\t= BIT(13),\n\tIEEE80211_TX_CTL_HW_80211_ENCAP\t\t= BIT(14),\n\tIEEE80211_TX_INTFL_RETRIED\t\t= BIT(15),\n\tIEEE80211_TX_INTFL_DONT_ENCRYPT\t\t= BIT(16),\n\tIEEE80211_TX_CTL_NO_PS_BUFFER\t\t= BIT(17),\n\tIEEE80211_TX_CTL_MORE_FRAMES\t\t= BIT(18),\n\tIEEE80211_TX_INTFL_RETRANSMISSION\t= BIT(19),\n\tIEEE80211_TX_INTFL_MLME_CONN_TX\t\t= BIT(20),\n\tIEEE80211_TX_INTFL_NL80211_FRAME_TX\t= BIT(21),\n\tIEEE80211_TX_CTL_LDPC\t\t\t= BIT(22),\n\tIEEE80211_TX_CTL_STBC\t\t\t= BIT(23) | BIT(24),\n\tIEEE80211_TX_CTL_TX_OFFCHAN\t\t= BIT(25),\n\tIEEE80211_TX_INTFL_TKIP_MIC_FAILURE\t= BIT(26),\n\tIEEE80211_TX_CTL_NO_CCK_RATE\t\t= BIT(27),\n\tIEEE80211_TX_STATUS_EOSP\t\t= BIT(28),\n\tIEEE80211_TX_CTL_USE_MINRATE\t\t= BIT(29),\n\tIEEE80211_TX_CTL_DONTFRAG\t\t= BIT(30),\n\tIEEE80211_TX_STAT_NOACK_TRANSMITTED\t= BIT(31),\n};\n\n#define IEEE80211_TX_CTL_STBC_SHIFT\t\t23\n\n#define IEEE80211_TX_RC_S1G_MCS IEEE80211_TX_RC_VHT_MCS\n\n/**\n * enum mac80211_tx_control_flags - flags to describe transmit control\n *\n * @IEEE80211_TX_CTRL_PORT_CTRL_PROTO: this frame is a port control\n *\tprotocol frame (e.g. EAP)\n * @IEEE80211_TX_CTRL_PS_RESPONSE: This frame is a response to a poll\n *\tframe (PS-Poll or uAPSD).\n * @IEEE80211_TX_CTRL_RATE_INJECT: This frame is injected with rate information\n * @IEEE80211_TX_CTRL_AMSDU: This frame is an A-MSDU frame\n * @IEEE80211_TX_CTRL_FAST_XMIT: This frame is going through the fast_xmit path\n * @IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP: This frame skips mesh path lookup\n * @IEEE80211_TX_INTCFL_NEED_TXPROCESSING: completely internal to mac80211,\n *\tused to indicate that a pending frame requires TX processing before\n *\tit can be sent out.\n * @IEEE80211_TX_CTRL_NO_SEQNO: Do not overwrite the sequence number that\n *\thas already been assigned to this frame.\n *\n * These flags are used in tx_info->control.flags.\n */\nenum mac80211_tx_control_flags {\n\tIEEE80211_TX_CTRL_PORT_CTRL_PROTO\t= BIT(0),\n\tIEEE80211_TX_CTRL_PS_RESPONSE\t\t= BIT(1),\n\tIEEE80211_TX_CTRL_RATE_INJECT\t\t= BIT(2),\n\tIEEE80211_TX_CTRL_AMSDU\t\t\t= BIT(3),\n\tIEEE80211_TX_CTRL_FAST_XMIT\t\t= BIT(4),\n\tIEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP\t= BIT(5),\n\tIEEE80211_TX_INTCFL_NEED_TXPROCESSING\t= BIT(6),\n\tIEEE80211_TX_CTRL_NO_SEQNO\t\t= BIT(7),\n};\n\n/*\n * This definition is used as a mask to clear all temporary flags, which are\n * set by the tx handlers for each transmission attempt by the mac80211 stack.\n */\n#define IEEE80211_TX_TEMPORARY_FLAGS (IEEE80211_TX_CTL_NO_ACK |\t\t      \\\n\tIEEE80211_TX_CTL_CLEAR_PS_FILT | IEEE80211_TX_CTL_FIRST_FRAGMENT |    \\\n\tIEEE80211_TX_CTL_SEND_AFTER_DTIM | IEEE80211_TX_CTL_AMPDU |\t      \\\n\tIEEE80211_TX_STAT_TX_FILTERED |\tIEEE80211_TX_STAT_ACK |\t\t      \\\n\tIEEE80211_TX_STAT_AMPDU | IEEE80211_TX_STAT_AMPDU_NO_BACK |\t      \\\n\tIEEE80211_TX_CTL_RATE_CTRL_PROBE | IEEE80211_TX_CTL_NO_PS_BUFFER |    \\\n\tIEEE80211_TX_CTL_MORE_FRAMES | IEEE80211_TX_CTL_LDPC |\t\t      \\\n\tIEEE80211_TX_CTL_STBC | IEEE80211_TX_STATUS_EOSP)\n\n/**\n * enum mac80211_rate_control_flags - per-rate flags set by the\n *\tRate Control algorithm.\n *\n * These flags are set by the Rate control algorithm for each rate during tx,\n * in the @flags member of struct ieee80211_tx_rate.\n *\n * @IEEE80211_TX_RC_USE_RTS_CTS: Use RTS/CTS exchange for this rate.\n * @IEEE80211_TX_RC_USE_CTS_PROTECT: CTS-to-self protection is required.\n *\tThis is set if the current BSS requires ERP protection.\n * @IEEE80211_TX_RC_USE_SHORT_PREAMBLE: Use short preamble.\n * @IEEE80211_TX_RC_MCS: HT rate.\n * @IEEE80211_TX_RC_VHT_MCS: VHT MCS rate, in this case the idx field is split\n *\tinto a higher 4 bits (Nss) and lower 4 bits (MCS number)\n * @IEEE80211_TX_RC_GREEN_FIELD: Indicates whether this rate should be used in\n *\tGreenfield mode.\n * @IEEE80211_TX_RC_40_MHZ_WIDTH: Indicates if the Channel Width should be 40 MHz.\n * @IEEE80211_TX_RC_80_MHZ_WIDTH: Indicates 80 MHz transmission\n * @IEEE80211_TX_RC_160_MHZ_WIDTH: Indicates 160 MHz transmission\n *\t(80+80 isn't supported yet)\n * @IEEE80211_TX_RC_DUP_DATA: The frame should be transmitted on both of the\n *\tadjacent 20 MHz channels, if the current channel type is\n *\tNL80211_CHAN_HT40MINUS or NL80211_CHAN_HT40PLUS.\n * @IEEE80211_TX_RC_SHORT_GI: Short Guard interval should be used for this rate.\n */\nenum mac80211_rate_control_flags {\n\tIEEE80211_TX_RC_USE_RTS_CTS\t\t= BIT(0),\n\tIEEE80211_TX_RC_USE_CTS_PROTECT\t\t= BIT(1),\n\tIEEE80211_TX_RC_USE_SHORT_PREAMBLE\t= BIT(2),\n\n\t/* rate index is an HT/VHT MCS instead of an index */\n\tIEEE80211_TX_RC_MCS\t\t\t= BIT(3),\n\tIEEE80211_TX_RC_GREEN_FIELD\t\t= BIT(4),\n\tIEEE80211_TX_RC_40_MHZ_WIDTH\t\t= BIT(5),\n\tIEEE80211_TX_RC_DUP_DATA\t\t= BIT(6),\n\tIEEE80211_TX_RC_SHORT_GI\t\t= BIT(7),\n\tIEEE80211_TX_RC_VHT_MCS\t\t\t= BIT(8),\n\tIEEE80211_TX_RC_80_MHZ_WIDTH\t\t= BIT(9),\n\tIEEE80211_TX_RC_160_MHZ_WIDTH\t\t= BIT(10),\n};\n\n\n/* there are 40 bytes if you don't need the rateset to be kept */\n#define IEEE80211_TX_INFO_DRIVER_DATA_SIZE 40\n\n/* if you do need the rateset, then you have less space */\n#define IEEE80211_TX_INFO_RATE_DRIVER_DATA_SIZE 24\n\n/* maximum number of rate stages */\n#define IEEE80211_TX_MAX_RATES\t4\n\n/* maximum number of rate table entries */\n#define IEEE80211_TX_RATE_TABLE_SIZE\t4\n\n/**\n * struct ieee80211_tx_rate - rate selection/status\n *\n * @idx: rate index to attempt to send with\n * @flags: rate control flags (&enum mac80211_rate_control_flags)\n * @count: number of tries in this rate before going to the next rate\n *\n * A value of -1 for @idx indicates an invalid rate and, if used\n * in an array of retry rates, that no more rates should be tried.\n *\n * When used for transmit status reporting, the driver should\n * always report the rate along with the flags it used.\n *\n * &struct ieee80211_tx_info contains an array of these structs\n * in the control information, and it will be filled by the rate\n * control algorithm according to what should be sent. For example,\n * if this array contains, in the format { <idx>, <count> } the\n * information::\n *\n *    { 3, 2 }, { 2, 2 }, { 1, 4 }, { -1, 0 }, { -1, 0 }\n *\n * then this means that the frame should be transmitted\n * up to twice at rate 3, up to twice at rate 2, and up to four\n * times at rate 1 if it doesn't get acknowledged. Say it gets\n * acknowledged by the peer after the fifth attempt, the status\n * information should then contain::\n *\n *   { 3, 2 }, { 2, 2 }, { 1, 1 }, { -1, 0 } ...\n *\n * since it was transmitted twice at rate 3, twice at rate 2\n * and once at rate 1 after which we received an acknowledgement.\n */\nstruct ieee80211_tx_rate {\n\ts8 idx;\n\tu16 count:5,\n\t    flags:11;\n} __packed;\n\n#define IEEE80211_MAX_TX_RETRY\t\t31\n\nstatic inline void ieee80211_rate_set_vht(struct ieee80211_tx_rate *rate,\n\t\t\t\t\t  u8 mcs, u8 nss)\n{\n\tWARN_ON(mcs & ~0xF);\n\tWARN_ON((nss - 1) & ~0x7);\n\trate->idx = ((nss - 1) << 4) | mcs;\n}\n\nstatic inline u8\nieee80211_rate_get_vht_mcs(const struct ieee80211_tx_rate *rate)\n{\n\treturn rate->idx & 0xF;\n}\n\nstatic inline u8\nieee80211_rate_get_vht_nss(const struct ieee80211_tx_rate *rate)\n{\n\treturn (rate->idx >> 4) + 1;\n}\n\n/**\n * struct ieee80211_tx_info - skb transmit information\n *\n * This structure is placed in skb->cb for three uses:\n *  (1) mac80211 TX control - mac80211 tells the driver what to do\n *  (2) driver internal use (if applicable)\n *  (3) TX status information - driver tells mac80211 what happened\n *\n * @flags: transmit info flags, defined above\n * @band: the band to transmit on (use for checking for races)\n * @hw_queue: HW queue to put the frame on, skb_get_queue_mapping() gives the AC\n * @ack_frame_id: internal frame ID for TX status, used internally\n * @tx_time_est: TX time estimate in units of 4us, used internally\n * @control: union part for control data\n * @control.rates: TX rates array to try\n * @control.rts_cts_rate_idx: rate for RTS or CTS\n * @control.use_rts: use RTS\n * @control.use_cts_prot: use RTS/CTS\n * @control.short_preamble: use short preamble (CCK only)\n * @control.skip_table: skip externally configured rate table\n * @control.jiffies: timestamp for expiry on powersave clients\n * @control.vif: virtual interface (may be NULL)\n * @control.hw_key: key to encrypt with (may be NULL)\n * @control.flags: control flags, see &enum mac80211_tx_control_flags\n * @control.enqueue_time: enqueue time (for iTXQs)\n * @driver_rates: alias to @control.rates to reserve space\n * @pad: padding\n * @rate_driver_data: driver use area if driver needs @control.rates\n * @status: union part for status data\n * @status.rates: attempted rates\n * @status.ack_signal: ACK signal\n * @status.ampdu_ack_len: AMPDU ack length\n * @status.ampdu_len: AMPDU length\n * @status.antenna: (legacy, kept only for iwlegacy)\n * @status.tx_time: airtime consumed for transmission; note this is only\n *\tused for WMM AC, not for airtime fairness\n * @status.is_valid_ack_signal: ACK signal is valid\n * @status.status_driver_data: driver use area\n * @ack: union part for pure ACK data\n * @ack.cookie: cookie for the ACK\n * @driver_data: array of driver_data pointers\n * @ampdu_ack_len: number of acked aggregated frames.\n * \trelevant only if IEEE80211_TX_STAT_AMPDU was set.\n * @ampdu_len: number of aggregated frames.\n * \trelevant only if IEEE80211_TX_STAT_AMPDU was set.\n * @ack_signal: signal strength of the ACK frame\n */\nstruct ieee80211_tx_info {\n\t/* common information */\n\tu32 flags;\n\tu32 band:3,\n\t    ack_frame_id:13,\n\t    hw_queue:4,\n\t    tx_time_est:10;\n\t/* 2 free bits */\n\n\tunion {\n\t\tstruct {\n\t\t\tunion {\n\t\t\t\t/* rate control */\n\t\t\t\tstruct {\n\t\t\t\t\tstruct ieee80211_tx_rate rates[\n\t\t\t\t\t\tIEEE80211_TX_MAX_RATES];\n\t\t\t\t\ts8 rts_cts_rate_idx;\n\t\t\t\t\tu8 use_rts:1;\n\t\t\t\t\tu8 use_cts_prot:1;\n\t\t\t\t\tu8 short_preamble:1;\n\t\t\t\t\tu8 skip_table:1;\n\t\t\t\t\t/* 2 bytes free */\n\t\t\t\t};\n\t\t\t\t/* only needed before rate control */\n\t\t\t\tunsigned long jiffies;\n\t\t\t};\n\t\t\t/* NB: vif can be NULL for injected frames */\n\t\t\tstruct ieee80211_vif *vif;\n\t\t\tstruct ieee80211_key_conf *hw_key;\n\t\t\tu32 flags;\n\t\t\tcodel_time_t enqueue_time;\n\t\t} control;\n\t\tstruct {\n\t\t\tu64 cookie;\n\t\t} ack;\n\t\tstruct {\n\t\t\tstruct ieee80211_tx_rate rates[IEEE80211_TX_MAX_RATES];\n\t\t\ts32 ack_signal;\n\t\t\tu8 ampdu_ack_len;\n\t\t\tu8 ampdu_len;\n\t\t\tu8 antenna;\n\t\t\tu16 tx_time;\n\t\t\tbool is_valid_ack_signal;\n\t\t\tvoid *status_driver_data[19 / sizeof(void *)];\n\t\t} status;\n\t\tstruct {\n\t\t\tstruct ieee80211_tx_rate driver_rates[\n\t\t\t\tIEEE80211_TX_MAX_RATES];\n\t\t\tu8 pad[4];\n\n\t\t\tvoid *rate_driver_data[\n\t\t\t\tIEEE80211_TX_INFO_RATE_DRIVER_DATA_SIZE / sizeof(void *)];\n\t\t};\n\t\tvoid *driver_data[\n\t\t\tIEEE80211_TX_INFO_DRIVER_DATA_SIZE / sizeof(void *)];\n\t};\n};\n\nstatic inline u16\nieee80211_info_set_tx_time_est(struct ieee80211_tx_info *info, u16 tx_time_est)\n{\n\t/* We only have 10 bits in tx_time_est, so store airtime\n\t * in increments of 4us and clamp the maximum to 2**12-1\n\t */\n\tinfo->tx_time_est = min_t(u16, tx_time_est, 4095) >> 2;\n\treturn info->tx_time_est << 2;\n}\n\nstatic inline u16\nieee80211_info_get_tx_time_est(struct ieee80211_tx_info *info)\n{\n\treturn info->tx_time_est << 2;\n}\n\n/**\n * struct ieee80211_tx_status - extended tx status info for rate control\n *\n * @sta: Station that the packet was transmitted for\n * @info: Basic tx status information\n * @skb: Packet skb (can be NULL if not provided by the driver)\n * @rate: The TX rate that was used when sending the packet\n * @free_list: list where processed skbs are stored to be free'd by the driver\n */\nstruct ieee80211_tx_status {\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *skb;\n\tstruct rate_info *rate;\n\tstruct list_head *free_list;\n};\n\n/**\n * struct ieee80211_scan_ies - descriptors for different blocks of IEs\n *\n * This structure is used to point to different blocks of IEs in HW scan\n * and scheduled scan. These blocks contain the IEs passed by userspace\n * and the ones generated by mac80211.\n *\n * @ies: pointers to band specific IEs.\n * @len: lengths of band_specific IEs.\n * @common_ies: IEs for all bands (especially vendor specific ones)\n * @common_ie_len: length of the common_ies\n */\nstruct ieee80211_scan_ies {\n\tconst u8 *ies[NUM_NL80211_BANDS];\n\tsize_t len[NUM_NL80211_BANDS];\n\tconst u8 *common_ies;\n\tsize_t common_ie_len;\n};\n\n\nstatic inline struct ieee80211_tx_info *IEEE80211_SKB_CB(struct sk_buff *skb)\n{\n\treturn (struct ieee80211_tx_info *)skb->cb;\n}\n\nstatic inline struct ieee80211_rx_status *IEEE80211_SKB_RXCB(struct sk_buff *skb)\n{\n\treturn (struct ieee80211_rx_status *)skb->cb;\n}\n\n/**\n * ieee80211_tx_info_clear_status - clear TX status\n *\n * @info: The &struct ieee80211_tx_info to be cleared.\n *\n * When the driver passes an skb back to mac80211, it must report\n * a number of things in TX status. This function clears everything\n * in the TX status but the rate control information (it does clear\n * the count since you need to fill that in anyway).\n *\n * NOTE: You can only use this function if you do NOT use\n *\t info->driver_data! Use info->rate_driver_data\n *\t instead if you need only the less space that allows.\n */\nstatic inline void\nieee80211_tx_info_clear_status(struct ieee80211_tx_info *info)\n{\n\tint i;\n\n\tBUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) !=\n\t\t     offsetof(struct ieee80211_tx_info, control.rates));\n\tBUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) !=\n\t\t     offsetof(struct ieee80211_tx_info, driver_rates));\n\tBUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) != 8);\n\t/* clear the rate counts */\n\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++)\n\t\tinfo->status.rates[i].count = 0;\n\n\tBUILD_BUG_ON(\n\t    offsetof(struct ieee80211_tx_info, status.ack_signal) != 20);\n\tmemset(&info->status.ampdu_ack_len, 0,\n\t       sizeof(struct ieee80211_tx_info) -\n\t       offsetof(struct ieee80211_tx_info, status.ampdu_ack_len));\n}\n\n\n/**\n * enum mac80211_rx_flags - receive flags\n *\n * These flags are used with the @flag member of &struct ieee80211_rx_status.\n * @RX_FLAG_MMIC_ERROR: Michael MIC error was reported on this frame.\n *\tUse together with %RX_FLAG_MMIC_STRIPPED.\n * @RX_FLAG_DECRYPTED: This frame was decrypted in hardware.\n * @RX_FLAG_MMIC_STRIPPED: the Michael MIC is stripped off this frame,\n *\tverification has been done by the hardware.\n * @RX_FLAG_IV_STRIPPED: The IV and ICV are stripped from this frame.\n *\tIf this flag is set, the stack cannot do any replay detection\n *\thence the driver or hardware will have to do that.\n * @RX_FLAG_PN_VALIDATED: Currently only valid for CCMP/GCMP frames, this\n *\tflag indicates that the PN was verified for replay protection.\n *\tNote that this flag is also currently only supported when a frame\n *\tis also decrypted (ie. @RX_FLAG_DECRYPTED must be set)\n * @RX_FLAG_DUP_VALIDATED: The driver should set this flag if it did\n *\tde-duplication by itself.\n * @RX_FLAG_FAILED_FCS_CRC: Set this flag if the FCS check failed on\n *\tthe frame.\n * @RX_FLAG_FAILED_PLCP_CRC: Set this flag if the PCLP check failed on\n *\tthe frame.\n * @RX_FLAG_MACTIME_START: The timestamp passed in the RX status (@mactime\n *\tfield) is valid and contains the time the first symbol of the MPDU\n *\twas received. This is useful in monitor mode and for proper IBSS\n *\tmerging.\n * @RX_FLAG_MACTIME_END: The timestamp passed in the RX status (@mactime\n *\tfield) is valid and contains the time the last symbol of the MPDU\n *\t(including FCS) was received.\n * @RX_FLAG_MACTIME_PLCP_START: The timestamp passed in the RX status (@mactime\n *\tfield) is valid and contains the time the SYNC preamble was received.\n * @RX_FLAG_NO_SIGNAL_VAL: The signal strength value is not present.\n *\tValid only for data frames (mainly A-MPDU)\n * @RX_FLAG_AMPDU_DETAILS: A-MPDU details are known, in particular the reference\n *\tnumber (@ampdu_reference) must be populated and be a distinct number for\n *\teach A-MPDU\n * @RX_FLAG_AMPDU_LAST_KNOWN: last subframe is known, should be set on all\n *\tsubframes of a single A-MPDU\n * @RX_FLAG_AMPDU_IS_LAST: this subframe is the last subframe of the A-MPDU\n * @RX_FLAG_AMPDU_DELIM_CRC_ERROR: A delimiter CRC error has been detected\n *\ton this subframe\n * @RX_FLAG_AMPDU_DELIM_CRC_KNOWN: The delimiter CRC field is known (the CRC\n *\tis stored in the @ampdu_delimiter_crc field)\n * @RX_FLAG_MIC_STRIPPED: The mic was stripped of this packet. Decryption was\n *\tdone by the hardware\n * @RX_FLAG_ONLY_MONITOR: Report frame only to monitor interfaces without\n *\tprocessing it in any regular way.\n *\tThis is useful if drivers offload some frames but still want to report\n *\tthem for sniffing purposes.\n * @RX_FLAG_SKIP_MONITOR: Process and report frame to all interfaces except\n *\tmonitor interfaces.\n *\tThis is useful if drivers offload some frames but still want to report\n *\tthem for sniffing purposes.\n * @RX_FLAG_AMSDU_MORE: Some drivers may prefer to report separate A-MSDU\n *\tsubframes instead of a one huge frame for performance reasons.\n *\tAll, but the last MSDU from an A-MSDU should have this flag set. E.g.\n *\tif an A-MSDU has 3 frames, the first 2 must have the flag set, while\n *\tthe 3rd (last) one must not have this flag set. The flag is used to\n *\tdeal with retransmission/duplication recovery properly since A-MSDU\n *\tsubframes share the same sequence number. Reported subframes can be\n *\teither regular MSDU or singly A-MSDUs. Subframes must not be\n *\tinterleaved with other frames.\n * @RX_FLAG_RADIOTAP_VENDOR_DATA: This frame contains vendor-specific\n *\tradiotap data in the skb->data (before the frame) as described by\n *\tthe &struct ieee80211_vendor_radiotap.\n * @RX_FLAG_ALLOW_SAME_PN: Allow the same PN as same packet before.\n *\tThis is used for AMSDU subframes which can have the same PN as\n *\tthe first subframe.\n * @RX_FLAG_ICV_STRIPPED: The ICV is stripped from this frame. CRC checking must\n *\tbe done in the hardware.\n * @RX_FLAG_AMPDU_EOF_BIT: Value of the EOF bit in the A-MPDU delimiter for this\n *\tframe\n * @RX_FLAG_AMPDU_EOF_BIT_KNOWN: The EOF value is known\n * @RX_FLAG_RADIOTAP_HE: HE radiotap data is present\n *\t(&struct ieee80211_radiotap_he, mac80211 will fill in\n *\t\n *\t - DATA3_DATA_MCS\n *\t - DATA3_DATA_DCM\n *\t - DATA3_CODING\n *\t - DATA5_GI\n *\t - DATA5_DATA_BW_RU_ALLOC\n *\t - DATA6_NSTS\n *\t - DATA3_STBC\n *\t\n *\tfrom the RX info data, so leave those zeroed when building this data)\n * @RX_FLAG_RADIOTAP_HE_MU: HE MU radiotap data is present\n *\t(&struct ieee80211_radiotap_he_mu)\n * @RX_FLAG_RADIOTAP_LSIG: L-SIG radiotap data is present\n * @RX_FLAG_NO_PSDU: use the frame only for radiotap reporting, with\n *\tthe \"0-length PSDU\" field included there.  The value for it is\n *\tin &struct ieee80211_rx_status.  Note that if this value isn't\n *\tknown the frame shouldn't be reported.\n */\nenum mac80211_rx_flags {\n\tRX_FLAG_MMIC_ERROR\t\t= BIT(0),\n\tRX_FLAG_DECRYPTED\t\t= BIT(1),\n\tRX_FLAG_MACTIME_PLCP_START\t= BIT(2),\n\tRX_FLAG_MMIC_STRIPPED\t\t= BIT(3),\n\tRX_FLAG_IV_STRIPPED\t\t= BIT(4),\n\tRX_FLAG_FAILED_FCS_CRC\t\t= BIT(5),\n\tRX_FLAG_FAILED_PLCP_CRC \t= BIT(6),\n\tRX_FLAG_MACTIME_START\t\t= BIT(7),\n\tRX_FLAG_NO_SIGNAL_VAL\t\t= BIT(8),\n\tRX_FLAG_AMPDU_DETAILS\t\t= BIT(9),\n\tRX_FLAG_PN_VALIDATED\t\t= BIT(10),\n\tRX_FLAG_DUP_VALIDATED\t\t= BIT(11),\n\tRX_FLAG_AMPDU_LAST_KNOWN\t= BIT(12),\n\tRX_FLAG_AMPDU_IS_LAST\t\t= BIT(13),\n\tRX_FLAG_AMPDU_DELIM_CRC_ERROR\t= BIT(14),\n\tRX_FLAG_AMPDU_DELIM_CRC_KNOWN\t= BIT(15),\n\tRX_FLAG_MACTIME_END\t\t= BIT(16),\n\tRX_FLAG_ONLY_MONITOR\t\t= BIT(17),\n\tRX_FLAG_SKIP_MONITOR\t\t= BIT(18),\n\tRX_FLAG_AMSDU_MORE\t\t= BIT(19),\n\tRX_FLAG_RADIOTAP_VENDOR_DATA\t= BIT(20),\n\tRX_FLAG_MIC_STRIPPED\t\t= BIT(21),\n\tRX_FLAG_ALLOW_SAME_PN\t\t= BIT(22),\n\tRX_FLAG_ICV_STRIPPED\t\t= BIT(23),\n\tRX_FLAG_AMPDU_EOF_BIT\t\t= BIT(24),\n\tRX_FLAG_AMPDU_EOF_BIT_KNOWN\t= BIT(25),\n\tRX_FLAG_RADIOTAP_HE\t\t= BIT(26),\n\tRX_FLAG_RADIOTAP_HE_MU\t\t= BIT(27),\n\tRX_FLAG_RADIOTAP_LSIG\t\t= BIT(28),\n\tRX_FLAG_NO_PSDU\t\t\t= BIT(29),\n};\n\n/**\n * enum mac80211_rx_encoding_flags - MCS & bandwidth flags\n *\n * @RX_ENC_FLAG_SHORTPRE: Short preamble was used for this frame\n * @RX_ENC_FLAG_SHORT_GI: Short guard interval was used\n * @RX_ENC_FLAG_HT_GF: This frame was received in a HT-greenfield transmission,\n *\tif the driver fills this value it should add\n *\t%IEEE80211_RADIOTAP_MCS_HAVE_FMT\n *\tto @hw.radiotap_mcs_details to advertise that fact.\n * @RX_ENC_FLAG_LDPC: LDPC was used\n * @RX_ENC_FLAG_STBC_MASK: STBC 2 bit bitmask. 1 - Nss=1, 2 - Nss=2, 3 - Nss=3\n * @RX_ENC_FLAG_BF: packet was beamformed\n */\nenum mac80211_rx_encoding_flags {\n\tRX_ENC_FLAG_SHORTPRE\t\t= BIT(0),\n\tRX_ENC_FLAG_SHORT_GI\t\t= BIT(2),\n\tRX_ENC_FLAG_HT_GF\t\t= BIT(3),\n\tRX_ENC_FLAG_STBC_MASK\t\t= BIT(4) | BIT(5),\n\tRX_ENC_FLAG_LDPC\t\t= BIT(6),\n\tRX_ENC_FLAG_BF\t\t\t= BIT(7),\n};\n\n#define RX_ENC_FLAG_STBC_SHIFT\t\t4\n\nenum mac80211_rx_encoding {\n\tRX_ENC_LEGACY = 0,\n\tRX_ENC_HT,\n\tRX_ENC_VHT,\n\tRX_ENC_HE,\n};\n\n/**\n * struct ieee80211_rx_status - receive status\n *\n * The low-level driver should provide this information (the subset\n * supported by hardware) to the 802.11 code with each received\n * frame, in the skb's control buffer (cb).\n *\n * @mactime: value in microseconds of the 64-bit Time Synchronization Function\n * \t(TSF) timer when the first data symbol (MPDU) arrived at the hardware.\n * @boottime_ns: CLOCK_BOOTTIME timestamp the frame was received at, this is\n *\tneeded only for beacons and probe responses that update the scan cache.\n * @device_timestamp: arbitrary timestamp for the device, mac80211 doesn't use\n *\tit but can store it and pass it back to the driver for synchronisation\n * @band: the active band when this frame was received\n * @freq: frequency the radio was tuned to when receiving this frame, in MHz\n *\tThis field must be set for management frames, but isn't strictly needed\n *\tfor data (other) frames - for those it only affects radiotap reporting.\n * @freq_offset: @freq has a positive offset of 500Khz.\n * @signal: signal strength when receiving this frame, either in dBm, in dB or\n *\tunspecified depending on the hardware capabilities flags\n *\t@IEEE80211_HW_SIGNAL_*\n * @chains: bitmask of receive chains for which separate signal strength\n *\tvalues were filled.\n * @chain_signal: per-chain signal strength, in dBm (unlike @signal, doesn't\n *\tsupport dB or unspecified units)\n * @antenna: antenna used\n * @rate_idx: index of data rate into band's supported rates or MCS index if\n *\tHT or VHT is used (%RX_FLAG_HT/%RX_FLAG_VHT)\n * @nss: number of streams (VHT and HE only)\n * @flag: %RX_FLAG_\\*\n * @encoding: &enum mac80211_rx_encoding\n * @bw: &enum rate_info_bw\n * @enc_flags: uses bits from &enum mac80211_rx_encoding_flags\n * @he_ru: HE RU, from &enum nl80211_he_ru_alloc\n * @he_gi: HE GI, from &enum nl80211_he_gi\n * @he_dcm: HE DCM value\n * @rx_flags: internal RX flags for mac80211\n * @ampdu_reference: A-MPDU reference number, must be a different value for\n *\teach A-MPDU but the same for each subframe within one A-MPDU\n * @ampdu_delimiter_crc: A-MPDU delimiter CRC\n * @zero_length_psdu_type: radiotap type of the 0-length PSDU\n */\nstruct ieee80211_rx_status {\n\tu64 mactime;\n\tu64 boottime_ns;\n\tu32 device_timestamp;\n\tu32 ampdu_reference;\n\tu32 flag;\n\tu16 freq: 13, freq_offset: 1;\n\tu8 enc_flags;\n\tu8 encoding:2, bw:3, he_ru:3;\n\tu8 he_gi:2, he_dcm:1;\n\tu8 rate_idx;\n\tu8 nss;\n\tu8 rx_flags;\n\tu8 band;\n\tu8 antenna;\n\ts8 signal;\n\tu8 chains;\n\ts8 chain_signal[IEEE80211_MAX_CHAINS];\n\tu8 ampdu_delimiter_crc;\n\tu8 zero_length_psdu_type;\n};\n\nstatic inline u32\nieee80211_rx_status_to_khz(struct ieee80211_rx_status *rx_status)\n{\n\treturn MHZ_TO_KHZ(rx_status->freq) +\n\t       (rx_status->freq_offset ? 500 : 0);\n}\n\n/**\n * struct ieee80211_vendor_radiotap - vendor radiotap data information\n * @present: presence bitmap for this vendor namespace\n *\t(this could be extended in the future if any vendor needs more\n *\t bits, the radiotap spec does allow for that)\n * @align: radiotap vendor namespace alignment. This defines the needed\n *\talignment for the @data field below, not for the vendor namespace\n *\tdescription itself (which has a fixed 2-byte alignment)\n *\tMust be a power of two, and be set to at least 1!\n * @oui: radiotap vendor namespace OUI\n * @subns: radiotap vendor sub namespace\n * @len: radiotap vendor sub namespace skip length, if alignment is done\n *\tthen that's added to this, i.e. this is only the length of the\n *\t@data field.\n * @pad: number of bytes of padding after the @data, this exists so that\n *\tthe skb data alignment can be preserved even if the data has odd\n *\tlength\n * @data: the actual vendor namespace data\n *\n * This struct, including the vendor data, goes into the skb->data before\n * the 802.11 header. It's split up in mac80211 using the align/oui/subns\n * data.\n */\nstruct ieee80211_vendor_radiotap {\n\tu32 present;\n\tu8 align;\n\tu8 oui[3];\n\tu8 subns;\n\tu8 pad;\n\tu16 len;\n\tu8 data[];\n} __packed;\n\n/**\n * enum ieee80211_conf_flags - configuration flags\n *\n * Flags to define PHY configuration options\n *\n * @IEEE80211_CONF_MONITOR: there's a monitor interface present -- use this\n *\tto determine for example whether to calculate timestamps for packets\n *\tor not, do not use instead of filter flags!\n * @IEEE80211_CONF_PS: Enable 802.11 power save mode (managed mode only).\n *\tThis is the power save mode defined by IEEE 802.11-2007 section 11.2,\n *\tmeaning that the hardware still wakes up for beacons, is able to\n *\ttransmit frames and receive the possible acknowledgment frames.\n *\tNot to be confused with hardware specific wakeup/sleep states,\n *\tdriver is responsible for that. See the section \"Powersave support\"\n *\tfor more.\n * @IEEE80211_CONF_IDLE: The device is running, but idle; if the flag is set\n *\tthe driver should be prepared to handle configuration requests but\n *\tmay turn the device off as much as possible. Typically, this flag will\n *\tbe set when an interface is set UP but not associated or scanning, but\n *\tit can also be unset in that case when monitor interfaces are active.\n * @IEEE80211_CONF_OFFCHANNEL: The device is currently not on its main\n *\toperating channel.\n */\nenum ieee80211_conf_flags {\n\tIEEE80211_CONF_MONITOR\t\t= (1<<0),\n\tIEEE80211_CONF_PS\t\t= (1<<1),\n\tIEEE80211_CONF_IDLE\t\t= (1<<2),\n\tIEEE80211_CONF_OFFCHANNEL\t= (1<<3),\n};\n\n\n/**\n * enum ieee80211_conf_changed - denotes which configuration changed\n *\n * @IEEE80211_CONF_CHANGE_LISTEN_INTERVAL: the listen interval changed\n * @IEEE80211_CONF_CHANGE_MONITOR: the monitor flag changed\n * @IEEE80211_CONF_CHANGE_PS: the PS flag or dynamic PS timeout changed\n * @IEEE80211_CONF_CHANGE_POWER: the TX power changed\n * @IEEE80211_CONF_CHANGE_CHANNEL: the channel/channel_type changed\n * @IEEE80211_CONF_CHANGE_RETRY_LIMITS: retry limits changed\n * @IEEE80211_CONF_CHANGE_IDLE: Idle flag changed\n * @IEEE80211_CONF_CHANGE_SMPS: Spatial multiplexing powersave mode changed\n *\tNote that this is only valid if channel contexts are not used,\n *\totherwise each channel context has the number of chains listed.\n */\nenum ieee80211_conf_changed {\n\tIEEE80211_CONF_CHANGE_SMPS\t\t= BIT(1),\n\tIEEE80211_CONF_CHANGE_LISTEN_INTERVAL\t= BIT(2),\n\tIEEE80211_CONF_CHANGE_MONITOR\t\t= BIT(3),\n\tIEEE80211_CONF_CHANGE_PS\t\t= BIT(4),\n\tIEEE80211_CONF_CHANGE_POWER\t\t= BIT(5),\n\tIEEE80211_CONF_CHANGE_CHANNEL\t\t= BIT(6),\n\tIEEE80211_CONF_CHANGE_RETRY_LIMITS\t= BIT(7),\n\tIEEE80211_CONF_CHANGE_IDLE\t\t= BIT(8),\n};\n\n/**\n * enum ieee80211_smps_mode - spatial multiplexing power save mode\n *\n * @IEEE80211_SMPS_AUTOMATIC: automatic\n * @IEEE80211_SMPS_OFF: off\n * @IEEE80211_SMPS_STATIC: static\n * @IEEE80211_SMPS_DYNAMIC: dynamic\n * @IEEE80211_SMPS_NUM_MODES: internal, don't use\n */\nenum ieee80211_smps_mode {\n\tIEEE80211_SMPS_AUTOMATIC,\n\tIEEE80211_SMPS_OFF,\n\tIEEE80211_SMPS_STATIC,\n\tIEEE80211_SMPS_DYNAMIC,\n\n\t/* keep last */\n\tIEEE80211_SMPS_NUM_MODES,\n};\n\n/**\n * struct ieee80211_conf - configuration of the device\n *\n * This struct indicates how the driver shall configure the hardware.\n *\n * @flags: configuration flags defined above\n *\n * @listen_interval: listen interval in units of beacon interval\n * @ps_dtim_period: The DTIM period of the AP we're connected to, for use\n *\tin power saving. Power saving will not be enabled until a beacon\n *\thas been received and the DTIM period is known.\n * @dynamic_ps_timeout: The dynamic powersave timeout (in ms), see the\n *\tpowersave documentation below. This variable is valid only when\n *\tthe CONF_PS flag is set.\n *\n * @power_level: requested transmit power (in dBm), backward compatibility\n *\tvalue only that is set to the minimum of all interfaces\n *\n * @chandef: the channel definition to tune to\n * @radar_enabled: whether radar detection is enabled\n *\n * @long_frame_max_tx_count: Maximum number of transmissions for a \"long\" frame\n *\t(a frame not RTS protected), called \"dot11LongRetryLimit\" in 802.11,\n *\tbut actually means the number of transmissions not the number of retries\n * @short_frame_max_tx_count: Maximum number of transmissions for a \"short\"\n *\tframe, called \"dot11ShortRetryLimit\" in 802.11, but actually means the\n *\tnumber of transmissions not the number of retries\n *\n * @smps_mode: spatial multiplexing powersave mode; note that\n *\t%IEEE80211_SMPS_STATIC is used when the device is not\n *\tconfigured for an HT channel.\n *\tNote that this is only valid if channel contexts are not used,\n *\totherwise each channel context has the number of chains listed.\n */\nstruct ieee80211_conf {\n\tu32 flags;\n\tint power_level, dynamic_ps_timeout;\n\n\tu16 listen_interval;\n\tu8 ps_dtim_period;\n\n\tu8 long_frame_max_tx_count, short_frame_max_tx_count;\n\n\tstruct cfg80211_chan_def chandef;\n\tbool radar_enabled;\n\tenum ieee80211_smps_mode smps_mode;\n};\n\n/**\n * struct ieee80211_channel_switch - holds the channel switch data\n *\n * The information provided in this structure is required for channel switch\n * operation.\n *\n * @timestamp: value in microseconds of the 64-bit Time Synchronization\n *\tFunction (TSF) timer when the frame containing the channel switch\n *\tannouncement was received. This is simply the rx.mactime parameter\n *\tthe driver passed into mac80211.\n * @device_timestamp: arbitrary timestamp for the device, this is the\n *\trx.device_timestamp parameter the driver passed to mac80211.\n * @block_tx: Indicates whether transmission must be blocked before the\n *\tscheduled channel switch, as indicated by the AP.\n * @chandef: the new channel to switch to\n * @count: the number of TBTT's until the channel switch event\n * @delay: maximum delay between the time the AP transmitted the last beacon in\n  *\tcurrent channel and the expected time of the first beacon in the new\n  *\tchannel, expressed in TU.\n */\nstruct ieee80211_channel_switch {\n\tu64 timestamp;\n\tu32 device_timestamp;\n\tbool block_tx;\n\tstruct cfg80211_chan_def chandef;\n\tu8 count;\n\tu32 delay;\n};\n\n/**\n * enum ieee80211_vif_flags - virtual interface flags\n *\n * @IEEE80211_VIF_BEACON_FILTER: the device performs beacon filtering\n *\ton this virtual interface to avoid unnecessary CPU wakeups\n * @IEEE80211_VIF_SUPPORTS_CQM_RSSI: the device can do connection quality\n *\tmonitoring on this virtual interface -- i.e. it can monitor\n *\tconnection quality related parameters, such as the RSSI level and\n *\tprovide notifications if configured trigger levels are reached.\n * @IEEE80211_VIF_SUPPORTS_UAPSD: The device can do U-APSD for this\n *\tinterface. This flag should be set during interface addition,\n *\tbut may be set/cleared as late as authentication to an AP. It is\n *\tonly valid for managed/station mode interfaces.\n * @IEEE80211_VIF_GET_NOA_UPDATE: request to handle NOA attributes\n *\tand send P2P_PS notification to the driver if NOA changed, even\n *\tthis is not pure P2P vif.\n */\nenum ieee80211_vif_flags {\n\tIEEE80211_VIF_BEACON_FILTER\t\t= BIT(0),\n\tIEEE80211_VIF_SUPPORTS_CQM_RSSI\t\t= BIT(1),\n\tIEEE80211_VIF_SUPPORTS_UAPSD\t\t= BIT(2),\n\tIEEE80211_VIF_GET_NOA_UPDATE\t\t= BIT(3),\n};\n\n\n/**\n * enum ieee80211_offload_flags - virtual interface offload flags\n *\n * @IEEE80211_OFFLOAD_ENCAP_ENABLED: tx encapsulation offload is enabled\n *\tThe driver supports sending frames passed as 802.3 frames by mac80211.\n *\tIt must also support sending 802.11 packets for the same interface.\n * @IEEE80211_OFFLOAD_ENCAP_4ADDR: support 4-address mode encapsulation offload\n */\n\nenum ieee80211_offload_flags {\n\tIEEE80211_OFFLOAD_ENCAP_ENABLED\t\t= BIT(0),\n\tIEEE80211_OFFLOAD_ENCAP_4ADDR\t\t= BIT(1),\n};\n\n/**\n * struct ieee80211_vif - per-interface data\n *\n * Data in this structure is continually present for driver\n * use during the life of a virtual interface.\n *\n * @type: type of this virtual interface\n * @bss_conf: BSS configuration for this interface, either our own\n *\tor the BSS we're associated to\n * @addr: address of this interface\n * @p2p: indicates whether this AP or STA interface is a p2p\n *\tinterface, i.e. a GO or p2p-sta respectively\n * @csa_active: marks whether a channel switch is going on. Internally it is\n *\twrite-protected by sdata_lock and local->mtx so holding either is fine\n *\tfor read access.\n * @mu_mimo_owner: indicates interface owns MU-MIMO capability\n * @driver_flags: flags/capabilities the driver has for this interface,\n *\tthese need to be set (or cleared) when the interface is added\n *\tor, if supported by the driver, the interface type is changed\n *\tat runtime, mac80211 will never touch this field\n * @offloaad_flags: hardware offload capabilities/flags for this interface.\n *\tThese are initialized by mac80211 before calling .add_interface,\n *\t.change_interface or .update_vif_offload and updated by the driver\n *\twithin these ops, based on supported features or runtime change\n *\trestrictions.\n * @hw_queue: hardware queue for each AC\n * @cab_queue: content-after-beacon (DTIM beacon really) queue, AP mode only\n * @chanctx_conf: The channel context this interface is assigned to, or %NULL\n *\twhen it is not assigned. This pointer is RCU-protected due to the TX\n *\tpath needing to access it; even though the netdev carrier will always\n *\tbe off when it is %NULL there can still be races and packets could be\n *\tprocessed after it switches back to %NULL.\n * @debugfs_dir: debugfs dentry, can be used by drivers to create own per\n *\tinterface debug files. Note that it will be NULL for the virtual\n *\tmonitor interface (if that is requested.)\n * @probe_req_reg: probe requests should be reported to mac80211 for this\n *\tinterface.\n * @rx_mcast_action_reg: multicast Action frames should be reported to mac80211\n *\tfor this interface.\n * @drv_priv: data area for driver use, will always be aligned to\n *\tsizeof(void \\*).\n * @txq: the multicast data TX queue (if driver uses the TXQ abstraction)\n * @txqs_stopped: per AC flag to indicate that intermediate TXQs are stopped,\n *\tprotected by fq->lock.\n * @offload_flags: 802.3 -> 802.11 enapsulation offload flags, see\n *\t&enum ieee80211_offload_flags.\n */\nstruct ieee80211_vif {\n\tenum nl80211_iftype type;\n\tstruct ieee80211_bss_conf bss_conf;\n\tu8 addr[ETH_ALEN] __aligned(2);\n\tbool p2p;\n\tbool csa_active;\n\tbool mu_mimo_owner;\n\n\tu8 cab_queue;\n\tu8 hw_queue[IEEE80211_NUM_ACS];\n\n\tstruct ieee80211_txq *txq;\n\n\tstruct ieee80211_chanctx_conf __rcu *chanctx_conf;\n\n\tu32 driver_flags;\n\tu32 offload_flags;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tstruct dentry *debugfs_dir;\n#endif\n\n\tbool probe_req_reg;\n\tbool rx_mcast_action_reg;\n\n\tbool txqs_stopped[IEEE80211_NUM_ACS];\n\n\t/* must be last */\n\tu8 drv_priv[] __aligned(sizeof(void *));\n};\n\nstatic inline bool ieee80211_vif_is_mesh(struct ieee80211_vif *vif)\n{\n#ifdef CONFIG_MAC80211_MESH\n\treturn vif->type == NL80211_IFTYPE_MESH_POINT;\n#endif\n\treturn false;\n}\n\n/**\n * wdev_to_ieee80211_vif - return a vif struct from a wdev\n * @wdev: the wdev to get the vif for\n *\n * This can be used by mac80211 drivers with direct cfg80211 APIs\n * (like the vendor commands) that get a wdev.\n *\n * Note that this function may return %NULL if the given wdev isn't\n * associated with a vif that the driver knows about (e.g. monitor\n * or AP_VLAN interfaces.)\n */\nstruct ieee80211_vif *wdev_to_ieee80211_vif(struct wireless_dev *wdev);\n\n/**\n * ieee80211_vif_to_wdev - return a wdev struct from a vif\n * @vif: the vif to get the wdev for\n *\n * This can be used by mac80211 drivers with direct cfg80211 APIs\n * (like the vendor commands) that needs to get the wdev for a vif.\n *\n * Note that this function may return %NULL if the given wdev isn't\n * associated with a vif that the driver knows about (e.g. monitor\n * or AP_VLAN interfaces.)\n */\nstruct wireless_dev *ieee80211_vif_to_wdev(struct ieee80211_vif *vif);\n\n/**\n * enum ieee80211_key_flags - key flags\n *\n * These flags are used for communication about keys between the driver\n * and mac80211, with the @flags parameter of &struct ieee80211_key_conf.\n *\n * @IEEE80211_KEY_FLAG_GENERATE_IV: This flag should be set by the\n *\tdriver to indicate that it requires IV generation for this\n *\tparticular key. Setting this flag does not necessarily mean that SKBs\n *\twill have sufficient tailroom for ICV or MIC.\n * @IEEE80211_KEY_FLAG_GENERATE_MMIC: This flag should be set by\n *\tthe driver for a TKIP key if it requires Michael MIC\n *\tgeneration in software.\n * @IEEE80211_KEY_FLAG_PAIRWISE: Set by mac80211, this flag indicates\n *\tthat the key is pairwise rather then a shared key.\n * @IEEE80211_KEY_FLAG_SW_MGMT_TX: This flag should be set by the driver for a\n *\tCCMP/GCMP key if it requires CCMP/GCMP encryption of management frames\n *\t(MFP) to be done in software.\n * @IEEE80211_KEY_FLAG_PUT_IV_SPACE: This flag should be set by the driver\n *\tif space should be prepared for the IV, but the IV\n *\titself should not be generated. Do not set together with\n *\t@IEEE80211_KEY_FLAG_GENERATE_IV on the same key. Setting this flag does\n *\tnot necessarily mean that SKBs will have sufficient tailroom for ICV or\n *\tMIC.\n * @IEEE80211_KEY_FLAG_RX_MGMT: This key will be used to decrypt received\n *\tmanagement frames. The flag can help drivers that have a hardware\n *\tcrypto implementation that doesn't deal with management frames\n *\tproperly by allowing them to not upload the keys to hardware and\n *\tfall back to software crypto. Note that this flag deals only with\n *\tRX, if your crypto engine can't deal with TX you can also set the\n *\t%IEEE80211_KEY_FLAG_SW_MGMT_TX flag to encrypt such frames in SW.\n * @IEEE80211_KEY_FLAG_GENERATE_IV_MGMT: This flag should be set by the\n *\tdriver for a CCMP/GCMP key to indicate that is requires IV generation\n *\tonly for management frames (MFP).\n * @IEEE80211_KEY_FLAG_RESERVE_TAILROOM: This flag should be set by the\n *\tdriver for a key to indicate that sufficient tailroom must always\n *\tbe reserved for ICV or MIC, even when HW encryption is enabled.\n * @IEEE80211_KEY_FLAG_PUT_MIC_SPACE: This flag should be set by the driver for\n *\ta TKIP key if it only requires MIC space. Do not set together with\n *\t@IEEE80211_KEY_FLAG_GENERATE_MMIC on the same key.\n * @IEEE80211_KEY_FLAG_NO_AUTO_TX: Key needs explicit Tx activation.\n * @IEEE80211_KEY_FLAG_GENERATE_MMIE: This flag should be set by the driver\n *\tfor a AES_CMAC key to indicate that it requires sequence number\n *\tgeneration only\n */\nenum ieee80211_key_flags {\n\tIEEE80211_KEY_FLAG_GENERATE_IV_MGMT\t= BIT(0),\n\tIEEE80211_KEY_FLAG_GENERATE_IV\t\t= BIT(1),\n\tIEEE80211_KEY_FLAG_GENERATE_MMIC\t= BIT(2),\n\tIEEE80211_KEY_FLAG_PAIRWISE\t\t= BIT(3),\n\tIEEE80211_KEY_FLAG_SW_MGMT_TX\t\t= BIT(4),\n\tIEEE80211_KEY_FLAG_PUT_IV_SPACE\t\t= BIT(5),\n\tIEEE80211_KEY_FLAG_RX_MGMT\t\t= BIT(6),\n\tIEEE80211_KEY_FLAG_RESERVE_TAILROOM\t= BIT(7),\n\tIEEE80211_KEY_FLAG_PUT_MIC_SPACE\t= BIT(8),\n\tIEEE80211_KEY_FLAG_NO_AUTO_TX\t\t= BIT(9),\n\tIEEE80211_KEY_FLAG_GENERATE_MMIE\t= BIT(10),\n};\n\n/**\n * struct ieee80211_key_conf - key information\n *\n * This key information is given by mac80211 to the driver by\n * the set_key() callback in &struct ieee80211_ops.\n *\n * @hw_key_idx: To be set by the driver, this is the key index the driver\n *\twants to be given when a frame is transmitted and needs to be\n *\tencrypted in hardware.\n * @cipher: The key's cipher suite selector.\n * @tx_pn: PN used for TX keys, may be used by the driver as well if it\n *\tneeds to do software PN assignment by itself (e.g. due to TSO)\n * @flags: key flags, see &enum ieee80211_key_flags.\n * @keyidx: the key index (0-3)\n * @keylen: key material length\n * @key: key material. For ALG_TKIP the key is encoded as a 256-bit (32 byte)\n * \tdata block:\n * \t- Temporal Encryption Key (128 bits)\n * \t- Temporal Authenticator Tx MIC Key (64 bits)\n * \t- Temporal Authenticator Rx MIC Key (64 bits)\n * @icv_len: The ICV length for this key type\n * @iv_len: The IV length for this key type\n */\nstruct ieee80211_key_conf {\n\tatomic64_t tx_pn;\n\tu32 cipher;\n\tu8 icv_len;\n\tu8 iv_len;\n\tu8 hw_key_idx;\n\ts8 keyidx;\n\tu16 flags;\n\tu8 keylen;\n\tu8 key[];\n};\n\n#define IEEE80211_MAX_PN_LEN\t16\n\n#define TKIP_PN_TO_IV16(pn) ((u16)(pn & 0xffff))\n#define TKIP_PN_TO_IV32(pn) ((u32)((pn >> 16) & 0xffffffff))\n\n/**\n * struct ieee80211_key_seq - key sequence counter\n *\n * @tkip: TKIP data, containing IV32 and IV16 in host byte order\n * @ccmp: PN data, most significant byte first (big endian,\n *\treverse order than in packet)\n * @aes_cmac: PN data, most significant byte first (big endian,\n *\treverse order than in packet)\n * @aes_gmac: PN data, most significant byte first (big endian,\n *\treverse order than in packet)\n * @gcmp: PN data, most significant byte first (big endian,\n *\treverse order than in packet)\n * @hw: data for HW-only (e.g. cipher scheme) keys\n */\nstruct ieee80211_key_seq {\n\tunion {\n\t\tstruct {\n\t\t\tu32 iv32;\n\t\t\tu16 iv16;\n\t\t} tkip;\n\t\tstruct {\n\t\t\tu8 pn[6];\n\t\t} ccmp;\n\t\tstruct {\n\t\t\tu8 pn[6];\n\t\t} aes_cmac;\n\t\tstruct {\n\t\t\tu8 pn[6];\n\t\t} aes_gmac;\n\t\tstruct {\n\t\t\tu8 pn[6];\n\t\t} gcmp;\n\t\tstruct {\n\t\t\tu8 seq[IEEE80211_MAX_PN_LEN];\n\t\t\tu8 seq_len;\n\t\t} hw;\n\t};\n};\n\n/**\n * struct ieee80211_cipher_scheme - cipher scheme\n *\n * This structure contains a cipher scheme information defining\n * the secure packet crypto handling.\n *\n * @cipher: a cipher suite selector\n * @iftype: a cipher iftype bit mask indicating an allowed cipher usage\n * @hdr_len: a length of a security header used the cipher\n * @pn_len: a length of a packet number in the security header\n * @pn_off: an offset of pn from the beginning of the security header\n * @key_idx_off: an offset of key index byte in the security header\n * @key_idx_mask: a bit mask of key_idx bits\n * @key_idx_shift: a bit shift needed to get key_idx\n *     key_idx value calculation:\n *      (sec_header_base[key_idx_off] & key_idx_mask) >> key_idx_shift\n * @mic_len: a mic length in bytes\n */\nstruct ieee80211_cipher_scheme {\n\tu32 cipher;\n\tu16 iftype;\n\tu8 hdr_len;\n\tu8 pn_len;\n\tu8 pn_off;\n\tu8 key_idx_off;\n\tu8 key_idx_mask;\n\tu8 key_idx_shift;\n\tu8 mic_len;\n};\n\n/**\n * enum set_key_cmd - key command\n *\n * Used with the set_key() callback in &struct ieee80211_ops, this\n * indicates whether a key is being removed or added.\n *\n * @SET_KEY: a key is set\n * @DISABLE_KEY: a key must be disabled\n */\nenum set_key_cmd {\n\tSET_KEY, DISABLE_KEY,\n};\n\n/**\n * enum ieee80211_sta_state - station state\n *\n * @IEEE80211_STA_NOTEXIST: station doesn't exist at all,\n *\tthis is a special state for add/remove transitions\n * @IEEE80211_STA_NONE: station exists without special state\n * @IEEE80211_STA_AUTH: station is authenticated\n * @IEEE80211_STA_ASSOC: station is associated\n * @IEEE80211_STA_AUTHORIZED: station is authorized (802.1X)\n */\nenum ieee80211_sta_state {\n\t/* NOTE: These need to be ordered correctly! */\n\tIEEE80211_STA_NOTEXIST,\n\tIEEE80211_STA_NONE,\n\tIEEE80211_STA_AUTH,\n\tIEEE80211_STA_ASSOC,\n\tIEEE80211_STA_AUTHORIZED,\n};\n\n/**\n * enum ieee80211_sta_rx_bandwidth - station RX bandwidth\n * @IEEE80211_STA_RX_BW_20: station can only receive 20 MHz\n * @IEEE80211_STA_RX_BW_40: station can receive up to 40 MHz\n * @IEEE80211_STA_RX_BW_80: station can receive up to 80 MHz\n * @IEEE80211_STA_RX_BW_160: station can receive up to 160 MHz\n *\t(including 80+80 MHz)\n *\n * Implementation note: 20 must be zero to be initialized\n *\tcorrectly, the values must be sorted.\n */\nenum ieee80211_sta_rx_bandwidth {\n\tIEEE80211_STA_RX_BW_20 = 0,\n\tIEEE80211_STA_RX_BW_40,\n\tIEEE80211_STA_RX_BW_80,\n\tIEEE80211_STA_RX_BW_160,\n};\n\n/**\n * struct ieee80211_sta_rates - station rate selection table\n *\n * @rcu_head: RCU head used for freeing the table on update\n * @rate: transmit rates/flags to be used by default.\n *\tOverriding entries per-packet is possible by using cb tx control.\n */\nstruct ieee80211_sta_rates {\n\tstruct rcu_head rcu_head;\n\tstruct {\n\t\ts8 idx;\n\t\tu8 count;\n\t\tu8 count_cts;\n\t\tu8 count_rts;\n\t\tu16 flags;\n\t} rate[IEEE80211_TX_RATE_TABLE_SIZE];\n};\n\n/**\n * struct ieee80211_sta_txpwr - station txpower configuration\n *\n * Used to configure txpower for station.\n *\n * @power: indicates the tx power, in dBm, to be used when sending data frames\n *\tto the STA.\n * @type: In particular if TPC %type is NL80211_TX_POWER_LIMITED then tx power\n *\twill be less than or equal to specified from userspace, whereas if TPC\n *\t%type is NL80211_TX_POWER_AUTOMATIC then it indicates default tx power.\n *\tNL80211_TX_POWER_FIXED is not a valid configuration option for\n *\tper peer TPC.\n */\nstruct ieee80211_sta_txpwr {\n\ts16 power;\n\tenum nl80211_tx_power_setting type;\n};\n\n/**\n * struct ieee80211_sta - station table entry\n *\n * A station table entry represents a station we are possibly\n * communicating with. Since stations are RCU-managed in\n * mac80211, any ieee80211_sta pointer you get access to must\n * either be protected by rcu_read_lock() explicitly or implicitly,\n * or you must take good care to not use such a pointer after a\n * call to your sta_remove callback that removed it.\n *\n * @addr: MAC address\n * @aid: AID we assigned to the station if we're an AP\n * @supp_rates: Bitmap of supported rates (per band)\n * @ht_cap: HT capabilities of this STA; restricted to our own capabilities\n * @vht_cap: VHT capabilities of this STA; restricted to our own capabilities\n * @he_cap: HE capabilities of this STA\n * @he_6ghz_capa: on 6 GHz, holds the HE 6 GHz band capabilities\n * @max_rx_aggregation_subframes: maximal amount of frames in a single AMPDU\n *\tthat this station is allowed to transmit to us.\n *\tCan be modified by driver.\n * @wme: indicates whether the STA supports QoS/WME (if local devices does,\n *\totherwise always false)\n * @drv_priv: data area for driver use, will always be aligned to\n *\tsizeof(void \\*), size is determined in hw information.\n * @uapsd_queues: bitmap of queues configured for uapsd. Only valid\n *\tif wme is supported. The bits order is like in\n *\tIEEE80211_WMM_IE_STA_QOSINFO_AC_*.\n * @max_sp: max Service Period. Only valid if wme is supported.\n * @bandwidth: current bandwidth the station can receive with\n * @rx_nss: in HT/VHT, the maximum number of spatial streams the\n *\tstation can receive at the moment, changed by operating mode\n *\tnotifications and capabilities. The value is only valid after\n *\tthe station moves to associated state.\n * @smps_mode: current SMPS mode (off, static or dynamic)\n * @rates: rate control selection table\n * @tdls: indicates whether the STA is a TDLS peer\n * @tdls_initiator: indicates the STA is an initiator of the TDLS link. Only\n *\tvalid if the STA is a TDLS peer in the first place.\n * @mfp: indicates whether the STA uses management frame protection or not.\n * @max_amsdu_subframes: indicates the maximal number of MSDUs in a single\n *\tA-MSDU. Taken from the Extended Capabilities element. 0 means\n *\tunlimited.\n * @support_p2p_ps: indicates whether the STA supports P2P PS mechanism or not.\n * @max_rc_amsdu_len: Maximum A-MSDU size in bytes recommended by rate control.\n * @max_tid_amsdu_len: Maximum A-MSDU size in bytes for this TID\n * @txpwr: the station tx power configuration\n * @txq: per-TID data TX queues (if driver uses the TXQ abstraction); note that\n *\tthe last entry (%IEEE80211_NUM_TIDS) is used for non-data frames\n */\nstruct ieee80211_sta {\n\tu32 supp_rates[NUM_NL80211_BANDS];\n\tu8 addr[ETH_ALEN];\n\tu16 aid;\n\tstruct ieee80211_sta_ht_cap ht_cap;\n\tstruct ieee80211_sta_vht_cap vht_cap;\n\tstruct ieee80211_sta_he_cap he_cap;\n\tstruct ieee80211_he_6ghz_capa he_6ghz_capa;\n\tu16 max_rx_aggregation_subframes;\n\tbool wme;\n\tu8 uapsd_queues;\n\tu8 max_sp;\n\tu8 rx_nss;\n\tenum ieee80211_sta_rx_bandwidth bandwidth;\n\tenum ieee80211_smps_mode smps_mode;\n\tstruct ieee80211_sta_rates __rcu *rates;\n\tbool tdls;\n\tbool tdls_initiator;\n\tbool mfp;\n\tu8 max_amsdu_subframes;\n\n\t/**\n\t * @max_amsdu_len:\n\t * indicates the maximal length of an A-MSDU in bytes.\n\t * This field is always valid for packets with a VHT preamble.\n\t * For packets with a HT preamble, additional limits apply:\n\t *\n\t * * If the skb is transmitted as part of a BA agreement, the\n\t *   A-MSDU maximal size is min(max_amsdu_len, 4065) bytes.\n\t * * If the skb is not part of a BA agreement, the A-MSDU maximal\n\t *   size is min(max_amsdu_len, 7935) bytes.\n\t *\n\t * Both additional HT limits must be enforced by the low level\n\t * driver. This is defined by the spec (IEEE 802.11-2012 section\n\t * 8.3.2.2 NOTE 2).\n\t */\n\tu16 max_amsdu_len;\n\tbool support_p2p_ps;\n\tu16 max_rc_amsdu_len;\n\tu16 max_tid_amsdu_len[IEEE80211_NUM_TIDS];\n\tstruct ieee80211_sta_txpwr txpwr;\n\n\tstruct ieee80211_txq *txq[IEEE80211_NUM_TIDS + 1];\n\n\t/* must be last */\n\tu8 drv_priv[] __aligned(sizeof(void *));\n};\n\n/**\n * enum sta_notify_cmd - sta notify command\n *\n * Used with the sta_notify() callback in &struct ieee80211_ops, this\n * indicates if an associated station made a power state transition.\n *\n * @STA_NOTIFY_SLEEP: a station is now sleeping\n * @STA_NOTIFY_AWAKE: a sleeping station woke up\n */\nenum sta_notify_cmd {\n\tSTA_NOTIFY_SLEEP, STA_NOTIFY_AWAKE,\n};\n\n/**\n * struct ieee80211_tx_control - TX control data\n *\n * @sta: station table entry, this sta pointer may be NULL and\n * \tit is not allowed to copy the pointer, due to RCU.\n */\nstruct ieee80211_tx_control {\n\tstruct ieee80211_sta *sta;\n};\n\n/**\n * struct ieee80211_txq - Software intermediate tx queue\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @sta: station table entry, %NULL for per-vif queue\n * @tid: the TID for this queue (unused for per-vif queue),\n *\t%IEEE80211_NUM_TIDS for non-data (if enabled)\n * @ac: the AC for this queue\n * @drv_priv: driver private area, sized by hw->txq_data_size\n *\n * The driver can obtain packets from this queue by calling\n * ieee80211_tx_dequeue().\n */\nstruct ieee80211_txq {\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_sta *sta;\n\tu8 tid;\n\tu8 ac;\n\n\t/* must be last */\n\tu8 drv_priv[] __aligned(sizeof(void *));\n};\n\n/**\n * enum ieee80211_hw_flags - hardware flags\n *\n * These flags are used to indicate hardware capabilities to\n * the stack. Generally, flags here should have their meaning\n * done in a way that the simplest hardware doesn't need setting\n * any particular flags. There are some exceptions to this rule,\n * however, so you are advised to review these flags carefully.\n *\n * @IEEE80211_HW_HAS_RATE_CONTROL:\n *\tThe hardware or firmware includes rate control, and cannot be\n *\tcontrolled by the stack. As such, no rate control algorithm\n *\tshould be instantiated, and the TX rate reported to userspace\n *\twill be taken from the TX status instead of the rate control\n *\talgorithm.\n *\tNote that this requires that the driver implement a number of\n *\tcallbacks so it has the correct information, it needs to have\n *\tthe @set_rts_threshold callback and must look at the BSS config\n *\t@use_cts_prot for G/N protection, @use_short_slot for slot\n *\ttiming in 2.4 GHz and @use_short_preamble for preambles for\n *\tCCK frames.\n *\n * @IEEE80211_HW_RX_INCLUDES_FCS:\n *\tIndicates that received frames passed to the stack include\n *\tthe FCS at the end.\n *\n * @IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING:\n *\tSome wireless LAN chipsets buffer broadcast/multicast frames\n *\tfor power saving stations in the hardware/firmware and others\n *\trely on the host system for such buffering. This option is used\n *\tto configure the IEEE 802.11 upper layer to buffer broadcast and\n *\tmulticast frames when there are power saving stations so that\n *\tthe driver can fetch them with ieee80211_get_buffered_bc().\n *\n * @IEEE80211_HW_SIGNAL_UNSPEC:\n *\tHardware can provide signal values but we don't know its units. We\n *\texpect values between 0 and @max_signal.\n *\tIf possible please provide dB or dBm instead.\n *\n * @IEEE80211_HW_SIGNAL_DBM:\n *\tHardware gives signal values in dBm, decibel difference from\n *\tone milliwatt. This is the preferred method since it is standardized\n *\tbetween different devices. @max_signal does not need to be set.\n *\n * @IEEE80211_HW_SPECTRUM_MGMT:\n * \tHardware supports spectrum management defined in 802.11h\n * \tMeasurement, Channel Switch, Quieting, TPC\n *\n * @IEEE80211_HW_AMPDU_AGGREGATION:\n *\tHardware supports 11n A-MPDU aggregation.\n *\n * @IEEE80211_HW_SUPPORTS_PS:\n *\tHardware has power save support (i.e. can go to sleep).\n *\n * @IEEE80211_HW_PS_NULLFUNC_STACK:\n *\tHardware requires nullfunc frame handling in stack, implies\n *\tstack support for dynamic PS.\n *\n * @IEEE80211_HW_SUPPORTS_DYNAMIC_PS:\n *\tHardware has support for dynamic PS.\n *\n * @IEEE80211_HW_MFP_CAPABLE:\n *\tHardware supports management frame protection (MFP, IEEE 802.11w).\n *\n * @IEEE80211_HW_REPORTS_TX_ACK_STATUS:\n *\tHardware can provide ack status reports of Tx frames to\n *\tthe stack.\n *\n * @IEEE80211_HW_CONNECTION_MONITOR:\n *\tThe hardware performs its own connection monitoring, including\n *\tperiodic keep-alives to the AP and probing the AP on beacon loss.\n *\n * @IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC:\n *\tThis device needs to get data from beacon before association (i.e.\n *\tdtim_period).\n *\n * @IEEE80211_HW_SUPPORTS_PER_STA_GTK: The device's crypto engine supports\n *\tper-station GTKs as used by IBSS RSN or during fast transition. If\n *\tthe device doesn't support per-station GTKs, but can be asked not\n *\tto decrypt group addressed frames, then IBSS RSN support is still\n *\tpossible but software crypto will be used. Advertise the wiphy flag\n *\tonly in that case.\n *\n * @IEEE80211_HW_AP_LINK_PS: When operating in AP mode the device\n *\tautonomously manages the PS status of connected stations. When\n *\tthis flag is set mac80211 will not trigger PS mode for connected\n *\tstations based on the PM bit of incoming frames.\n *\tUse ieee80211_start_ps()/ieee8021_end_ps() to manually configure\n *\tthe PS mode of connected stations.\n *\n * @IEEE80211_HW_TX_AMPDU_SETUP_IN_HW: The device handles TX A-MPDU session\n *\tsetup strictly in HW. mac80211 should not attempt to do this in\n *\tsoftware.\n *\n * @IEEE80211_HW_WANT_MONITOR_VIF: The driver would like to be informed of\n *\ta virtual monitor interface when monitor interfaces are the only\n *\tactive interfaces.\n *\n * @IEEE80211_HW_NO_AUTO_VIF: The driver would like for no wlanX to\n *\tbe created.  It is expected user-space will create vifs as\n *\tdesired (and thus have them named as desired).\n *\n * @IEEE80211_HW_SW_CRYPTO_CONTROL: The driver wants to control which of the\n *\tcrypto algorithms can be done in software - so don't automatically\n *\ttry to fall back to it if hardware crypto fails, but do so only if\n *\tthe driver returns 1. This also forces the driver to advertise its\n *\tsupported cipher suites.\n *\n * @IEEE80211_HW_SUPPORT_FAST_XMIT: The driver/hardware supports fast-xmit,\n *\tthis currently requires only the ability to calculate the duration\n *\tfor frames.\n *\n * @IEEE80211_HW_QUEUE_CONTROL: The driver wants to control per-interface\n *\tqueue mapping in order to use different queues (not just one per AC)\n *\tfor different virtual interfaces. See the doc section on HW queue\n *\tcontrol for more details.\n *\n * @IEEE80211_HW_SUPPORTS_RC_TABLE: The driver supports using a rate\n *\tselection table provided by the rate control algorithm.\n *\n * @IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF: Use the P2P Device address for any\n *\tP2P Interface. This will be honoured even if more than one interface\n *\tis supported.\n *\n * @IEEE80211_HW_TIMING_BEACON_ONLY: Use sync timing from beacon frames\n *\tonly, to allow getting TBTT of a DTIM beacon.\n *\n * @IEEE80211_HW_SUPPORTS_HT_CCK_RATES: Hardware supports mixing HT/CCK rates\n *\tand can cope with CCK rates in an aggregation session (e.g. by not\n *\tusing aggregation for such frames.)\n *\n * @IEEE80211_HW_CHANCTX_STA_CSA: Support 802.11h based channel-switch (CSA)\n *\tfor a single active channel while using channel contexts. When support\n *\tis not enabled the default action is to disconnect when getting the\n *\tCSA frame.\n *\n * @IEEE80211_HW_SUPPORTS_CLONED_SKBS: The driver will never modify the payload\n *\tor tailroom of TX skbs without copying them first.\n *\n * @IEEE80211_HW_SINGLE_SCAN_ON_ALL_BANDS: The HW supports scanning on all bands\n *\tin one command, mac80211 doesn't have to run separate scans per band.\n *\n * @IEEE80211_HW_TDLS_WIDER_BW: The device/driver supports wider bandwidth\n *\tthan then BSS bandwidth for a TDLS link on the base channel.\n *\n * @IEEE80211_HW_SUPPORTS_AMSDU_IN_AMPDU: The driver supports receiving A-MSDUs\n *\twithin A-MPDU.\n *\n * @IEEE80211_HW_BEACON_TX_STATUS: The device/driver provides TX status\n *\tfor sent beacons.\n *\n * @IEEE80211_HW_NEEDS_UNIQUE_STA_ADDR: Hardware (or driver) requires that each\n *\tstation has a unique address, i.e. each station entry can be identified\n *\tby just its MAC address; this prevents, for example, the same station\n *\tfrom connecting to two virtual AP interfaces at the same time.\n *\n * @IEEE80211_HW_SUPPORTS_REORDERING_BUFFER: Hardware (or driver) manages the\n *\treordering buffer internally, guaranteeing mac80211 receives frames in\n *\torder and does not need to manage its own reorder buffer or BA session\n *\ttimeout.\n *\n * @IEEE80211_HW_USES_RSS: The device uses RSS and thus requires parallel RX,\n *\twhich implies using per-CPU station statistics.\n *\n * @IEEE80211_HW_TX_AMSDU: Hardware (or driver) supports software aggregated\n *\tA-MSDU frames. Requires software tx queueing and fast-xmit support.\n *\tWhen not using minstrel/minstrel_ht rate control, the driver must\n *\tlimit the maximum A-MSDU size based on the current tx rate by setting\n *\tmax_rc_amsdu_len in struct ieee80211_sta.\n *\n * @IEEE80211_HW_TX_FRAG_LIST: Hardware (or driver) supports sending frag_list\n *\tskbs, needed for zero-copy software A-MSDU.\n *\n * @IEEE80211_HW_REPORTS_LOW_ACK: The driver (or firmware) reports low ack event\n *\tby ieee80211_report_low_ack() based on its own algorithm. For such\n *\tdrivers, mac80211 packet loss mechanism will not be triggered and driver\n *\tis completely depending on firmware event for station kickout.\n *\n * @IEEE80211_HW_SUPPORTS_TX_FRAG: Hardware does fragmentation by itself.\n *\tThe stack will not do fragmentation.\n *\tThe callback for @set_frag_threshold should be set as well.\n *\n * @IEEE80211_HW_SUPPORTS_TDLS_BUFFER_STA: Hardware supports buffer STA on\n *\tTDLS links.\n *\n * @IEEE80211_HW_DEAUTH_NEED_MGD_TX_PREP: The driver requires the\n *\tmgd_prepare_tx() callback to be called before transmission of a\n *\tdeauthentication frame in case the association was completed but no\n *\tbeacon was heard. This is required in multi-channel scenarios, where the\n *\tvirtual interface might not be given air time for the transmission of\n *\tthe frame, as it is not synced with the AP/P2P GO yet, and thus the\n *\tdeauthentication frame might not be transmitted.\n *\n * @IEEE80211_HW_DOESNT_SUPPORT_QOS_NDP: The driver (or firmware) doesn't\n *\tsupport QoS NDP for AP probing - that's most likely a driver bug.\n *\n * @IEEE80211_HW_BUFF_MMPDU_TXQ: use the TXQ for bufferable MMPDUs, this of\n *\tcourse requires the driver to use TXQs to start with.\n *\n * @IEEE80211_HW_SUPPORTS_VHT_EXT_NSS_BW: (Hardware) rate control supports VHT\n *\textended NSS BW (dot11VHTExtendedNSSBWCapable). This flag will be set if\n *\tthe selected rate control algorithm sets %RATE_CTRL_CAPA_VHT_EXT_NSS_BW\n *\tbut if the rate control is built-in then it must be set by the driver.\n *\tSee also the documentation for that flag.\n *\n * @IEEE80211_HW_STA_MMPDU_TXQ: use the extra non-TID per-station TXQ for all\n *\tMMPDUs on station interfaces. This of course requires the driver to use\n *\tTXQs to start with.\n *\n * @IEEE80211_HW_TX_STATUS_NO_AMPDU_LEN: Driver does not report accurate A-MPDU\n *\tlength in tx status information\n *\n * @IEEE80211_HW_SUPPORTS_MULTI_BSSID: Hardware supports multi BSSID\n *\n * @IEEE80211_HW_SUPPORTS_ONLY_HE_MULTI_BSSID: Hardware supports multi BSSID\n *\tonly for HE APs. Applies if @IEEE80211_HW_SUPPORTS_MULTI_BSSID is set.\n *\n * @IEEE80211_HW_AMPDU_KEYBORDER_SUPPORT: The card and driver is only\n *\taggregating MPDUs with the same keyid, allowing mac80211 to keep Tx\n *\tA-MPDU sessions active while rekeying with Extended Key ID.\n *\n * @IEEE80211_HW_SUPPORTS_TX_ENCAP_OFFLOAD: Hardware supports tx encapsulation\n *\toffload\n *\n * @NUM_IEEE80211_HW_FLAGS: number of hardware flags, used for sizing arrays\n */\nenum ieee80211_hw_flags {\n\tIEEE80211_HW_HAS_RATE_CONTROL,\n\tIEEE80211_HW_RX_INCLUDES_FCS,\n\tIEEE80211_HW_HOST_BROADCAST_PS_BUFFERING,\n\tIEEE80211_HW_SIGNAL_UNSPEC,\n\tIEEE80211_HW_SIGNAL_DBM,\n\tIEEE80211_HW_NEED_DTIM_BEFORE_ASSOC,\n\tIEEE80211_HW_SPECTRUM_MGMT,\n\tIEEE80211_HW_AMPDU_AGGREGATION,\n\tIEEE80211_HW_SUPPORTS_PS,\n\tIEEE80211_HW_PS_NULLFUNC_STACK,\n\tIEEE80211_HW_SUPPORTS_DYNAMIC_PS,\n\tIEEE80211_HW_MFP_CAPABLE,\n\tIEEE80211_HW_WANT_MONITOR_VIF,\n\tIEEE80211_HW_NO_AUTO_VIF,\n\tIEEE80211_HW_SW_CRYPTO_CONTROL,\n\tIEEE80211_HW_SUPPORT_FAST_XMIT,\n\tIEEE80211_HW_REPORTS_TX_ACK_STATUS,\n\tIEEE80211_HW_CONNECTION_MONITOR,\n\tIEEE80211_HW_QUEUE_CONTROL,\n\tIEEE80211_HW_SUPPORTS_PER_STA_GTK,\n\tIEEE80211_HW_AP_LINK_PS,\n\tIEEE80211_HW_TX_AMPDU_SETUP_IN_HW,\n\tIEEE80211_HW_SUPPORTS_RC_TABLE,\n\tIEEE80211_HW_P2P_DEV_ADDR_FOR_INTF,\n\tIEEE80211_HW_TIMING_BEACON_ONLY,\n\tIEEE80211_HW_SUPPORTS_HT_CCK_RATES,\n\tIEEE80211_HW_CHANCTX_STA_CSA,\n\tIEEE80211_HW_SUPPORTS_CLONED_SKBS,\n\tIEEE80211_HW_SINGLE_SCAN_ON_ALL_BANDS,\n\tIEEE80211_HW_TDLS_WIDER_BW,\n\tIEEE80211_HW_SUPPORTS_AMSDU_IN_AMPDU,\n\tIEEE80211_HW_BEACON_TX_STATUS,\n\tIEEE80211_HW_NEEDS_UNIQUE_STA_ADDR,\n\tIEEE80211_HW_SUPPORTS_REORDERING_BUFFER,\n\tIEEE80211_HW_USES_RSS,\n\tIEEE80211_HW_TX_AMSDU,\n\tIEEE80211_HW_TX_FRAG_LIST,\n\tIEEE80211_HW_REPORTS_LOW_ACK,\n\tIEEE80211_HW_SUPPORTS_TX_FRAG,\n\tIEEE80211_HW_SUPPORTS_TDLS_BUFFER_STA,\n\tIEEE80211_HW_DEAUTH_NEED_MGD_TX_PREP,\n\tIEEE80211_HW_DOESNT_SUPPORT_QOS_NDP,\n\tIEEE80211_HW_BUFF_MMPDU_TXQ,\n\tIEEE80211_HW_SUPPORTS_VHT_EXT_NSS_BW,\n\tIEEE80211_HW_STA_MMPDU_TXQ,\n\tIEEE80211_HW_TX_STATUS_NO_AMPDU_LEN,\n\tIEEE80211_HW_SUPPORTS_MULTI_BSSID,\n\tIEEE80211_HW_SUPPORTS_ONLY_HE_MULTI_BSSID,\n\tIEEE80211_HW_AMPDU_KEYBORDER_SUPPORT,\n\tIEEE80211_HW_SUPPORTS_TX_ENCAP_OFFLOAD,\n\n\t/* keep last, obviously */\n\tNUM_IEEE80211_HW_FLAGS\n};\n\n/**\n * struct ieee80211_hw - hardware information and state\n *\n * This structure contains the configuration and hardware\n * information for an 802.11 PHY.\n *\n * @wiphy: This points to the &struct wiphy allocated for this\n *\t802.11 PHY. You must fill in the @perm_addr and @dev\n *\tmembers of this structure using SET_IEEE80211_DEV()\n *\tand SET_IEEE80211_PERM_ADDR(). Additionally, all supported\n *\tbands (with channels, bitrates) are registered here.\n *\n * @conf: &struct ieee80211_conf, device configuration, don't use.\n *\n * @priv: pointer to private area that was allocated for driver use\n *\talong with this structure.\n *\n * @flags: hardware flags, see &enum ieee80211_hw_flags.\n *\n * @extra_tx_headroom: headroom to reserve in each transmit skb\n *\tfor use by the driver (e.g. for transmit headers.)\n *\n * @extra_beacon_tailroom: tailroom to reserve in each beacon tx skb.\n *\tCan be used by drivers to add extra IEs.\n *\n * @max_signal: Maximum value for signal (rssi) in RX information, used\n *\tonly when @IEEE80211_HW_SIGNAL_UNSPEC or @IEEE80211_HW_SIGNAL_DB\n *\n * @max_listen_interval: max listen interval in units of beacon interval\n *\tthat HW supports\n *\n * @queues: number of available hardware transmit queues for\n *\tdata packets. WMM/QoS requires at least four, these\n *\tqueues need to have configurable access parameters.\n *\n * @rate_control_algorithm: rate control algorithm for this hardware.\n *\tIf unset (NULL), the default algorithm will be used. Must be\n *\tset before calling ieee80211_register_hw().\n *\n * @vif_data_size: size (in bytes) of the drv_priv data area\n *\twithin &struct ieee80211_vif.\n * @sta_data_size: size (in bytes) of the drv_priv data area\n *\twithin &struct ieee80211_sta.\n * @chanctx_data_size: size (in bytes) of the drv_priv data area\n *\twithin &struct ieee80211_chanctx_conf.\n * @txq_data_size: size (in bytes) of the drv_priv data area\n *\twithin @struct ieee80211_txq.\n *\n * @max_rates: maximum number of alternate rate retry stages the hw\n *\tcan handle.\n * @max_report_rates: maximum number of alternate rate retry stages\n *\tthe hw can report back.\n * @max_rate_tries: maximum number of tries for each stage\n *\n * @max_rx_aggregation_subframes: maximum buffer size (number of\n *\tsub-frames) to be used for A-MPDU block ack receiver\n *\taggregation.\n *\tThis is only relevant if the device has restrictions on the\n *\tnumber of subframes, if it relies on mac80211 to do reordering\n *\tit shouldn't be set.\n *\n * @max_tx_aggregation_subframes: maximum number of subframes in an\n *\taggregate an HT/HE device will transmit. In HT AddBA we'll\n *\tadvertise a constant value of 64 as some older APs crash if\n *\tthe window size is smaller (an example is LinkSys WRT120N\n *\twith FW v1.0.07 build 002 Jun 18 2012).\n *\tFor AddBA to HE capable peers this value will be used.\n *\n * @max_tx_fragments: maximum number of tx buffers per (A)-MSDU, sum\n *\tof 1 + skb_shinfo(skb)->nr_frags for each skb in the frag_list.\n *\n * @offchannel_tx_hw_queue: HW queue ID to use for offchannel TX\n *\t(if %IEEE80211_HW_QUEUE_CONTROL is set)\n *\n * @radiotap_mcs_details: lists which MCS information can the HW\n *\treports, by default it is set to _MCS, _GI and _BW but doesn't\n *\tinclude _FMT. Use %IEEE80211_RADIOTAP_MCS_HAVE_\\* values, only\n *\tadding _BW is supported today.\n *\n * @radiotap_vht_details: lists which VHT MCS information the HW reports,\n *\tthe default is _GI | _BANDWIDTH.\n *\tUse the %IEEE80211_RADIOTAP_VHT_KNOWN_\\* values.\n *\n * @radiotap_he: HE radiotap validity flags\n *\n * @radiotap_timestamp: Information for the radiotap timestamp field; if the\n *\t@units_pos member is set to a non-negative value then the timestamp\n *\tfield will be added and populated from the &struct ieee80211_rx_status\n *\tdevice_timestamp.\n * @radiotap_timestamp.units_pos: Must be set to a combination of a\n *\tIEEE80211_RADIOTAP_TIMESTAMP_UNIT_* and a\n *\tIEEE80211_RADIOTAP_TIMESTAMP_SPOS_* value.\n * @radiotap_timestamp.accuracy: If non-negative, fills the accuracy in the\n *\tradiotap field and the accuracy known flag will be set.\n *\n * @netdev_features: netdev features to be set in each netdev created\n *\tfrom this HW. Note that not all features are usable with mac80211,\n *\tother features will be rejected during HW registration.\n *\n * @uapsd_queues: This bitmap is included in (re)association frame to indicate\n *\tfor each access category if it is uAPSD trigger-enabled and delivery-\n *\tenabled. Use IEEE80211_WMM_IE_STA_QOSINFO_AC_* to set this bitmap.\n *\tEach bit corresponds to different AC. Value '1' in specific bit means\n *\tthat corresponding AC is both trigger- and delivery-enabled. '0' means\n *\tneither enabled.\n *\n * @uapsd_max_sp_len: maximum number of total buffered frames the WMM AP may\n *\tdeliver to a WMM STA during any Service Period triggered by the WMM STA.\n *\tUse IEEE80211_WMM_IE_STA_QOSINFO_SP_* for correct values.\n *\n * @n_cipher_schemes: a size of an array of cipher schemes definitions.\n * @cipher_schemes: a pointer to an array of cipher scheme definitions\n *\tsupported by HW.\n * @max_nan_de_entries: maximum number of NAN DE functions supported by the\n *\tdevice.\n *\n * @tx_sk_pacing_shift: Pacing shift to set on TCP sockets when frames from\n *\tthem are encountered. The default should typically not be changed,\n *\tunless the driver has good reasons for needing more buffers.\n *\n * @weight_multiplier: Driver specific airtime weight multiplier used while\n *\trefilling deficit of each TXQ.\n *\n * @max_mtu: the max mtu could be set.\n */\nstruct ieee80211_hw {\n\tstruct ieee80211_conf conf;\n\tstruct wiphy *wiphy;\n\tconst char *rate_control_algorithm;\n\tvoid *priv;\n\tunsigned long flags[BITS_TO_LONGS(NUM_IEEE80211_HW_FLAGS)];\n\tunsigned int extra_tx_headroom;\n\tunsigned int extra_beacon_tailroom;\n\tint vif_data_size;\n\tint sta_data_size;\n\tint chanctx_data_size;\n\tint txq_data_size;\n\tu16 queues;\n\tu16 max_listen_interval;\n\ts8 max_signal;\n\tu8 max_rates;\n\tu8 max_report_rates;\n\tu8 max_rate_tries;\n\tu16 max_rx_aggregation_subframes;\n\tu16 max_tx_aggregation_subframes;\n\tu8 max_tx_fragments;\n\tu8 offchannel_tx_hw_queue;\n\tu8 radiotap_mcs_details;\n\tu16 radiotap_vht_details;\n\tstruct {\n\t\tint units_pos;\n\t\ts16 accuracy;\n\t} radiotap_timestamp;\n\tnetdev_features_t netdev_features;\n\tu8 uapsd_queues;\n\tu8 uapsd_max_sp_len;\n\tu8 n_cipher_schemes;\n\tconst struct ieee80211_cipher_scheme *cipher_schemes;\n\tu8 max_nan_de_entries;\n\tu8 tx_sk_pacing_shift;\n\tu8 weight_multiplier;\n\tu32 max_mtu;\n};\n\nstatic inline bool _ieee80211_hw_check(struct ieee80211_hw *hw,\n\t\t\t\t       enum ieee80211_hw_flags flg)\n{\n\treturn test_bit(flg, hw->flags);\n}\n#define ieee80211_hw_check(hw, flg)\t_ieee80211_hw_check(hw, IEEE80211_HW_##flg)\n\nstatic inline void _ieee80211_hw_set(struct ieee80211_hw *hw,\n\t\t\t\t     enum ieee80211_hw_flags flg)\n{\n\treturn __set_bit(flg, hw->flags);\n}\n#define ieee80211_hw_set(hw, flg)\t_ieee80211_hw_set(hw, IEEE80211_HW_##flg)\n\n/**\n * struct ieee80211_scan_request - hw scan request\n *\n * @ies: pointers different parts of IEs (in req.ie)\n * @req: cfg80211 request.\n */\nstruct ieee80211_scan_request {\n\tstruct ieee80211_scan_ies ies;\n\n\t/* Keep last */\n\tstruct cfg80211_scan_request req;\n};\n\n/**\n * struct ieee80211_tdls_ch_sw_params - TDLS channel switch parameters\n *\n * @sta: peer this TDLS channel-switch request/response came from\n * @chandef: channel referenced in a TDLS channel-switch request\n * @action_code: see &enum ieee80211_tdls_actioncode\n * @status: channel-switch response status\n * @timestamp: time at which the frame was received\n * @switch_time: switch-timing parameter received in the frame\n * @switch_timeout: switch-timing parameter received in the frame\n * @tmpl_skb: TDLS switch-channel response template\n * @ch_sw_tm_ie: offset of the channel-switch timing IE inside @tmpl_skb\n */\nstruct ieee80211_tdls_ch_sw_params {\n\tstruct ieee80211_sta *sta;\n\tstruct cfg80211_chan_def *chandef;\n\tu8 action_code;\n\tu32 status;\n\tu32 timestamp;\n\tu16 switch_time;\n\tu16 switch_timeout;\n\tstruct sk_buff *tmpl_skb;\n\tu32 ch_sw_tm_ie;\n};\n\n/**\n * wiphy_to_ieee80211_hw - return a mac80211 driver hw struct from a wiphy\n *\n * @wiphy: the &struct wiphy which we want to query\n *\n * mac80211 drivers can use this to get to their respective\n * &struct ieee80211_hw. Drivers wishing to get to their own private\n * structure can then access it via hw->priv. Note that mac802111 drivers should\n * not use wiphy_priv() to try to get their private driver structure as this\n * is already used internally by mac80211.\n *\n * Return: The mac80211 driver hw struct of @wiphy.\n */\nstruct ieee80211_hw *wiphy_to_ieee80211_hw(struct wiphy *wiphy);\n\n/**\n * SET_IEEE80211_DEV - set device for 802.11 hardware\n *\n * @hw: the &struct ieee80211_hw to set the device for\n * @dev: the &struct device of this 802.11 device\n */\nstatic inline void SET_IEEE80211_DEV(struct ieee80211_hw *hw, struct device *dev)\n{\n\tset_wiphy_dev(hw->wiphy, dev);\n}\n\n/**\n * SET_IEEE80211_PERM_ADDR - set the permanent MAC address for 802.11 hardware\n *\n * @hw: the &struct ieee80211_hw to set the MAC address for\n * @addr: the address to set\n */\nstatic inline void SET_IEEE80211_PERM_ADDR(struct ieee80211_hw *hw, const u8 *addr)\n{\n\tmemcpy(hw->wiphy->perm_addr, addr, ETH_ALEN);\n}\n\nstatic inline struct ieee80211_rate *\nieee80211_get_tx_rate(const struct ieee80211_hw *hw,\n\t\t      const struct ieee80211_tx_info *c)\n{\n\tif (WARN_ON_ONCE(c->control.rates[0].idx < 0))\n\t\treturn NULL;\n\treturn &hw->wiphy->bands[c->band]->bitrates[c->control.rates[0].idx];\n}\n\nstatic inline struct ieee80211_rate *\nieee80211_get_rts_cts_rate(const struct ieee80211_hw *hw,\n\t\t\t   const struct ieee80211_tx_info *c)\n{\n\tif (c->control.rts_cts_rate_idx < 0)\n\t\treturn NULL;\n\treturn &hw->wiphy->bands[c->band]->bitrates[c->control.rts_cts_rate_idx];\n}\n\nstatic inline struct ieee80211_rate *\nieee80211_get_alt_retry_rate(const struct ieee80211_hw *hw,\n\t\t\t     const struct ieee80211_tx_info *c, int idx)\n{\n\tif (c->control.rates[idx + 1].idx < 0)\n\t\treturn NULL;\n\treturn &hw->wiphy->bands[c->band]->bitrates[c->control.rates[idx + 1].idx];\n}\n\n/**\n * ieee80211_free_txskb - free TX skb\n * @hw: the hardware\n * @skb: the skb\n *\n * Free a transmit skb. Use this function when some failure\n * to transmit happened and thus status cannot be reported.\n */\nvoid ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);\n\n/**\n * DOC: Hardware crypto acceleration\n *\n * mac80211 is capable of taking advantage of many hardware\n * acceleration designs for encryption and decryption operations.\n *\n * The set_key() callback in the &struct ieee80211_ops for a given\n * device is called to enable hardware acceleration of encryption and\n * decryption. The callback takes a @sta parameter that will be NULL\n * for default keys or keys used for transmission only, or point to\n * the station information for the peer for individual keys.\n * Multiple transmission keys with the same key index may be used when\n * VLANs are configured for an access point.\n *\n * When transmitting, the TX control data will use the @hw_key_idx\n * selected by the driver by modifying the &struct ieee80211_key_conf\n * pointed to by the @key parameter to the set_key() function.\n *\n * The set_key() call for the %SET_KEY command should return 0 if\n * the key is now in use, -%EOPNOTSUPP or -%ENOSPC if it couldn't be\n * added; if you return 0 then hw_key_idx must be assigned to the\n * hardware key index, you are free to use the full u8 range.\n *\n * Note that in the case that the @IEEE80211_HW_SW_CRYPTO_CONTROL flag is\n * set, mac80211 will not automatically fall back to software crypto if\n * enabling hardware crypto failed. The set_key() call may also return the\n * value 1 to permit this specific key/algorithm to be done in software.\n *\n * When the cmd is %DISABLE_KEY then it must succeed.\n *\n * Note that it is permissible to not decrypt a frame even if a key\n * for it has been uploaded to hardware, the stack will not make any\n * decision based on whether a key has been uploaded or not but rather\n * based on the receive flags.\n *\n * The &struct ieee80211_key_conf structure pointed to by the @key\n * parameter is guaranteed to be valid until another call to set_key()\n * removes it, but it can only be used as a cookie to differentiate\n * keys.\n *\n * In TKIP some HW need to be provided a phase 1 key, for RX decryption\n * acceleration (i.e. iwlwifi). Those drivers should provide update_tkip_key\n * handler.\n * The update_tkip_key() call updates the driver with the new phase 1 key.\n * This happens every time the iv16 wraps around (every 65536 packets). The\n * set_key() call will happen only once for each key (unless the AP did\n * rekeying), it will not include a valid phase 1 key. The valid phase 1 key is\n * provided by update_tkip_key only. The trigger that makes mac80211 call this\n * handler is software decryption with wrap around of iv16.\n *\n * The set_default_unicast_key() call updates the default WEP key index\n * configured to the hardware for WEP encryption type. This is required\n * for devices that support offload of data packets (e.g. ARP responses).\n *\n * Mac80211 drivers should set the @NL80211_EXT_FEATURE_CAN_REPLACE_PTK0 flag\n * when they are able to replace in-use PTK keys according to the following\n * requirements:\n * 1) They do not hand over frames decrypted with the old key to\n      mac80211 once the call to set_key() with command %DISABLE_KEY has been\n      completed when also setting @IEEE80211_KEY_FLAG_GENERATE_IV for any key,\n   2) either drop or continue to use the old key for any outgoing frames queued\n      at the time of the key deletion (including re-transmits),\n   3) never send out a frame queued prior to the set_key() %SET_KEY command\n      encrypted with the new key and\n   4) never send out a frame unencrypted when it should be encrypted.\n   Mac80211 will not queue any new frames for a deleted key to the driver.\n */\n\n/**\n * DOC: Powersave support\n *\n * mac80211 has support for various powersave implementations.\n *\n * First, it can support hardware that handles all powersaving by itself,\n * such hardware should simply set the %IEEE80211_HW_SUPPORTS_PS hardware\n * flag. In that case, it will be told about the desired powersave mode\n * with the %IEEE80211_CONF_PS flag depending on the association status.\n * The hardware must take care of sending nullfunc frames when necessary,\n * i.e. when entering and leaving powersave mode. The hardware is required\n * to look at the AID in beacons and signal to the AP that it woke up when\n * it finds traffic directed to it.\n *\n * %IEEE80211_CONF_PS flag enabled means that the powersave mode defined in\n * IEEE 802.11-2007 section 11.2 is enabled. This is not to be confused\n * with hardware wakeup and sleep states. Driver is responsible for waking\n * up the hardware before issuing commands to the hardware and putting it\n * back to sleep at appropriate times.\n *\n * When PS is enabled, hardware needs to wakeup for beacons and receive the\n * buffered multicast/broadcast frames after the beacon. Also it must be\n * possible to send frames and receive the acknowledment frame.\n *\n * Other hardware designs cannot send nullfunc frames by themselves and also\n * need software support for parsing the TIM bitmap. This is also supported\n * by mac80211 by combining the %IEEE80211_HW_SUPPORTS_PS and\n * %IEEE80211_HW_PS_NULLFUNC_STACK flags. The hardware is of course still\n * required to pass up beacons. The hardware is still required to handle\n * waking up for multicast traffic; if it cannot the driver must handle that\n * as best as it can, mac80211 is too slow to do that.\n *\n * Dynamic powersave is an extension to normal powersave in which the\n * hardware stays awake for a user-specified period of time after sending a\n * frame so that reply frames need not be buffered and therefore delayed to\n * the next wakeup. It's compromise of getting good enough latency when\n * there's data traffic and still saving significantly power in idle\n * periods.\n *\n * Dynamic powersave is simply supported by mac80211 enabling and disabling\n * PS based on traffic. Driver needs to only set %IEEE80211_HW_SUPPORTS_PS\n * flag and mac80211 will handle everything automatically. Additionally,\n * hardware having support for the dynamic PS feature may set the\n * %IEEE80211_HW_SUPPORTS_DYNAMIC_PS flag to indicate that it can support\n * dynamic PS mode itself. The driver needs to look at the\n * @dynamic_ps_timeout hardware configuration value and use it that value\n * whenever %IEEE80211_CONF_PS is set. In this case mac80211 will disable\n * dynamic PS feature in stack and will just keep %IEEE80211_CONF_PS\n * enabled whenever user has enabled powersave.\n *\n * Driver informs U-APSD client support by enabling\n * %IEEE80211_VIF_SUPPORTS_UAPSD flag. The mode is configured through the\n * uapsd parameter in conf_tx() operation. Hardware needs to send the QoS\n * Nullfunc frames and stay awake until the service period has ended. To\n * utilize U-APSD, dynamic powersave is disabled for voip AC and all frames\n * from that AC are transmitted with powersave enabled.\n *\n * Note: U-APSD client mode is not yet supported with\n * %IEEE80211_HW_PS_NULLFUNC_STACK.\n */\n\n/**\n * DOC: Beacon filter support\n *\n * Some hardware have beacon filter support to reduce host cpu wakeups\n * which will reduce system power consumption. It usually works so that\n * the firmware creates a checksum of the beacon but omits all constantly\n * changing elements (TSF, TIM etc). Whenever the checksum changes the\n * beacon is forwarded to the host, otherwise it will be just dropped. That\n * way the host will only receive beacons where some relevant information\n * (for example ERP protection or WMM settings) have changed.\n *\n * Beacon filter support is advertised with the %IEEE80211_VIF_BEACON_FILTER\n * interface capability. The driver needs to enable beacon filter support\n * whenever power save is enabled, that is %IEEE80211_CONF_PS is set. When\n * power save is enabled, the stack will not check for beacon loss and the\n * driver needs to notify about loss of beacons with ieee80211_beacon_loss().\n *\n * The time (or number of beacons missed) until the firmware notifies the\n * driver of a beacon loss event (which in turn causes the driver to call\n * ieee80211_beacon_loss()) should be configurable and will be controlled\n * by mac80211 and the roaming algorithm in the future.\n *\n * Since there may be constantly changing information elements that nothing\n * in the software stack cares about, we will, in the future, have mac80211\n * tell the driver which information elements are interesting in the sense\n * that we want to see changes in them. This will include\n *\n *  - a list of information element IDs\n *  - a list of OUIs for the vendor information element\n *\n * Ideally, the hardware would filter out any beacons without changes in the\n * requested elements, but if it cannot support that it may, at the expense\n * of some efficiency, filter out only a subset. For example, if the device\n * doesn't support checking for OUIs it should pass up all changes in all\n * vendor information elements.\n *\n * Note that change, for the sake of simplification, also includes information\n * elements appearing or disappearing from the beacon.\n *\n * Some hardware supports an \"ignore list\" instead, just make sure nothing\n * that was requested is on the ignore list, and include commonly changing\n * information element IDs in the ignore list, for example 11 (BSS load) and\n * the various vendor-assigned IEs with unknown contents (128, 129, 133-136,\n * 149, 150, 155, 156, 173, 176, 178, 179, 219); for forward compatibility\n * it could also include some currently unused IDs.\n *\n *\n * In addition to these capabilities, hardware should support notifying the\n * host of changes in the beacon RSSI. This is relevant to implement roaming\n * when no traffic is flowing (when traffic is flowing we see the RSSI of\n * the received data packets). This can consist in notifying the host when\n * the RSSI changes significantly or when it drops below or rises above\n * configurable thresholds. In the future these thresholds will also be\n * configured by mac80211 (which gets them from userspace) to implement\n * them as the roaming algorithm requires.\n *\n * If the hardware cannot implement this, the driver should ask it to\n * periodically pass beacon frames to the host so that software can do the\n * signal strength threshold checking.\n */\n\n/**\n * DOC: Spatial multiplexing power save\n *\n * SMPS (Spatial multiplexing power save) is a mechanism to conserve\n * power in an 802.11n implementation. For details on the mechanism\n * and rationale, please refer to 802.11 (as amended by 802.11n-2009)\n * \"11.2.3 SM power save\".\n *\n * The mac80211 implementation is capable of sending action frames\n * to update the AP about the station's SMPS mode, and will instruct\n * the driver to enter the specific mode. It will also announce the\n * requested SMPS mode during the association handshake. Hardware\n * support for this feature is required, and can be indicated by\n * hardware flags.\n *\n * The default mode will be \"automatic\", which nl80211/cfg80211\n * defines to be dynamic SMPS in (regular) powersave, and SMPS\n * turned off otherwise.\n *\n * To support this feature, the driver must set the appropriate\n * hardware support flags, and handle the SMPS flag to the config()\n * operation. It will then with this mechanism be instructed to\n * enter the requested SMPS mode while associated to an HT AP.\n */\n\n/**\n * DOC: Frame filtering\n *\n * mac80211 requires to see many management frames for proper\n * operation, and users may want to see many more frames when\n * in monitor mode. However, for best CPU usage and power consumption,\n * having as few frames as possible percolate through the stack is\n * desirable. Hence, the hardware should filter as much as possible.\n *\n * To achieve this, mac80211 uses filter flags (see below) to tell\n * the driver's configure_filter() function which frames should be\n * passed to mac80211 and which should be filtered out.\n *\n * Before configure_filter() is invoked, the prepare_multicast()\n * callback is invoked with the parameters @mc_count and @mc_list\n * for the combined multicast address list of all virtual interfaces.\n * It's use is optional, and it returns a u64 that is passed to\n * configure_filter(). Additionally, configure_filter() has the\n * arguments @changed_flags telling which flags were changed and\n * @total_flags with the new flag states.\n *\n * If your device has no multicast address filters your driver will\n * need to check both the %FIF_ALLMULTI flag and the @mc_count\n * parameter to see whether multicast frames should be accepted\n * or dropped.\n *\n * All unsupported flags in @total_flags must be cleared.\n * Hardware does not support a flag if it is incapable of _passing_\n * the frame to the stack. Otherwise the driver must ignore\n * the flag, but not clear it.\n * You must _only_ clear the flag (announce no support for the\n * flag to mac80211) if you are not able to pass the packet type\n * to the stack (so the hardware always filters it).\n * So for example, you should clear @FIF_CONTROL, if your hardware\n * always filters control frames. If your hardware always passes\n * control frames to the kernel and is incapable of filtering them,\n * you do _not_ clear the @FIF_CONTROL flag.\n * This rule applies to all other FIF flags as well.\n */\n\n/**\n * DOC: AP support for powersaving clients\n *\n * In order to implement AP and P2P GO modes, mac80211 has support for\n * client powersaving, both \"legacy\" PS (PS-Poll/null data) and uAPSD.\n * There currently is no support for sAPSD.\n *\n * There is one assumption that mac80211 makes, namely that a client\n * will not poll with PS-Poll and trigger with uAPSD at the same time.\n * Both are supported, and both can be used by the same client, but\n * they can't be used concurrently by the same client. This simplifies\n * the driver code.\n *\n * The first thing to keep in mind is that there is a flag for complete\n * driver implementation: %IEEE80211_HW_AP_LINK_PS. If this flag is set,\n * mac80211 expects the driver to handle most of the state machine for\n * powersaving clients and will ignore the PM bit in incoming frames.\n * Drivers then use ieee80211_sta_ps_transition() to inform mac80211 of\n * stations' powersave transitions. In this mode, mac80211 also doesn't\n * handle PS-Poll/uAPSD.\n *\n * In the mode without %IEEE80211_HW_AP_LINK_PS, mac80211 will check the\n * PM bit in incoming frames for client powersave transitions. When a\n * station goes to sleep, we will stop transmitting to it. There is,\n * however, a race condition: a station might go to sleep while there is\n * data buffered on hardware queues. If the device has support for this\n * it will reject frames, and the driver should give the frames back to\n * mac80211 with the %IEEE80211_TX_STAT_TX_FILTERED flag set which will\n * cause mac80211 to retry the frame when the station wakes up. The\n * driver is also notified of powersave transitions by calling its\n * @sta_notify callback.\n *\n * When the station is asleep, it has three choices: it can wake up,\n * it can PS-Poll, or it can possibly start a uAPSD service period.\n * Waking up is implemented by simply transmitting all buffered (and\n * filtered) frames to the station. This is the easiest case. When\n * the station sends a PS-Poll or a uAPSD trigger frame, mac80211\n * will inform the driver of this with the @allow_buffered_frames\n * callback; this callback is optional. mac80211 will then transmit\n * the frames as usual and set the %IEEE80211_TX_CTL_NO_PS_BUFFER\n * on each frame. The last frame in the service period (or the only\n * response to a PS-Poll) also has %IEEE80211_TX_STATUS_EOSP set to\n * indicate that it ends the service period; as this frame must have\n * TX status report it also sets %IEEE80211_TX_CTL_REQ_TX_STATUS.\n * When TX status is reported for this frame, the service period is\n * marked has having ended and a new one can be started by the peer.\n *\n * Additionally, non-bufferable MMPDUs can also be transmitted by\n * mac80211 with the %IEEE80211_TX_CTL_NO_PS_BUFFER set in them.\n *\n * Another race condition can happen on some devices like iwlwifi\n * when there are frames queued for the station and it wakes up\n * or polls; the frames that are already queued could end up being\n * transmitted first instead, causing reordering and/or wrong\n * processing of the EOSP. The cause is that allowing frames to be\n * transmitted to a certain station is out-of-band communication to\n * the device. To allow this problem to be solved, the driver can\n * call ieee80211_sta_block_awake() if frames are buffered when it\n * is notified that the station went to sleep. When all these frames\n * have been filtered (see above), it must call the function again\n * to indicate that the station is no longer blocked.\n *\n * If the driver buffers frames in the driver for aggregation in any\n * way, it must use the ieee80211_sta_set_buffered() call when it is\n * notified of the station going to sleep to inform mac80211 of any\n * TIDs that have frames buffered. Note that when a station wakes up\n * this information is reset (hence the requirement to call it when\n * informed of the station going to sleep). Then, when a service\n * period starts for any reason, @release_buffered_frames is called\n * with the number of frames to be released and which TIDs they are\n * to come from. In this case, the driver is responsible for setting\n * the EOSP (for uAPSD) and MORE_DATA bits in the released frames,\n * to help the @more_data parameter is passed to tell the driver if\n * there is more data on other TIDs -- the TIDs to release frames\n * from are ignored since mac80211 doesn't know how many frames the\n * buffers for those TIDs contain.\n *\n * If the driver also implement GO mode, where absence periods may\n * shorten service periods (or abort PS-Poll responses), it must\n * filter those response frames except in the case of frames that\n * are buffered in the driver -- those must remain buffered to avoid\n * reordering. Because it is possible that no frames are released\n * in this case, the driver must call ieee80211_sta_eosp()\n * to indicate to mac80211 that the service period ended anyway.\n *\n * Finally, if frames from multiple TIDs are released from mac80211\n * but the driver might reorder them, it must clear & set the flags\n * appropriately (only the last frame may have %IEEE80211_TX_STATUS_EOSP)\n * and also take care of the EOSP and MORE_DATA bits in the frame.\n * The driver may also use ieee80211_sta_eosp() in this case.\n *\n * Note that if the driver ever buffers frames other than QoS-data\n * frames, it must take care to never send a non-QoS-data frame as\n * the last frame in a service period, adding a QoS-nulldata frame\n * after a non-QoS-data frame if needed.\n */\n\n/**\n * DOC: HW queue control\n *\n * Before HW queue control was introduced, mac80211 only had a single static\n * assignment of per-interface AC software queues to hardware queues. This\n * was problematic for a few reasons:\n * 1) off-channel transmissions might get stuck behind other frames\n * 2) multiple virtual interfaces couldn't be handled correctly\n * 3) after-DTIM frames could get stuck behind other frames\n *\n * To solve this, hardware typically uses multiple different queues for all\n * the different usages, and this needs to be propagated into mac80211 so it\n * won't have the same problem with the software queues.\n *\n * Therefore, mac80211 now offers the %IEEE80211_HW_QUEUE_CONTROL capability\n * flag that tells it that the driver implements its own queue control. To do\n * so, the driver will set up the various queues in each &struct ieee80211_vif\n * and the offchannel queue in &struct ieee80211_hw. In response, mac80211 will\n * use those queue IDs in the hw_queue field of &struct ieee80211_tx_info and\n * if necessary will queue the frame on the right software queue that mirrors\n * the hardware queue.\n * Additionally, the driver has to then use these HW queue IDs for the queue\n * management functions (ieee80211_stop_queue() et al.)\n *\n * The driver is free to set up the queue mappings as needed, multiple virtual\n * interfaces may map to the same hardware queues if needed. The setup has to\n * happen during add_interface or change_interface callbacks. For example, a\n * driver supporting station+station and station+AP modes might decide to have\n * 10 hardware queues to handle different scenarios:\n *\n * 4 AC HW queues for 1st vif: 0, 1, 2, 3\n * 4 AC HW queues for 2nd vif: 4, 5, 6, 7\n * after-DTIM queue for AP:   8\n * off-channel queue:         9\n *\n * It would then set up the hardware like this:\n *   hw.offchannel_tx_hw_queue = 9\n *\n * and the first virtual interface that is added as follows:\n *   vif.hw_queue[IEEE80211_AC_VO] = 0\n *   vif.hw_queue[IEEE80211_AC_VI] = 1\n *   vif.hw_queue[IEEE80211_AC_BE] = 2\n *   vif.hw_queue[IEEE80211_AC_BK] = 3\n *   vif.cab_queue = 8 // if AP mode, otherwise %IEEE80211_INVAL_HW_QUEUE\n * and the second virtual interface with 4-7.\n *\n * If queue 6 gets full, for example, mac80211 would only stop the second\n * virtual interface's BE queue since virtual interface queues are per AC.\n *\n * Note that the vif.cab_queue value should be set to %IEEE80211_INVAL_HW_QUEUE\n * whenever the queue is not used (i.e. the interface is not in AP mode) if the\n * queue could potentially be shared since mac80211 will look at cab_queue when\n * a queue is stopped/woken even if the interface is not in AP mode.\n */\n\n/**\n * enum ieee80211_filter_flags - hardware filter flags\n *\n * These flags determine what the filter in hardware should be\n * programmed to let through and what should not be passed to the\n * stack. It is always safe to pass more frames than requested,\n * but this has negative impact on power consumption.\n *\n * @FIF_ALLMULTI: pass all multicast frames, this is used if requested\n *\tby the user or if the hardware is not capable of filtering by\n *\tmulticast address.\n *\n * @FIF_FCSFAIL: pass frames with failed FCS (but you need to set the\n *\t%RX_FLAG_FAILED_FCS_CRC for them)\n *\n * @FIF_PLCPFAIL: pass frames with failed PLCP CRC (but you need to set\n *\tthe %RX_FLAG_FAILED_PLCP_CRC for them\n *\n * @FIF_BCN_PRBRESP_PROMISC: This flag is set during scanning to indicate\n *\tto the hardware that it should not filter beacons or probe responses\n *\tby BSSID. Filtering them can greatly reduce the amount of processing\n *\tmac80211 needs to do and the amount of CPU wakeups, so you should\n *\thonour this flag if possible.\n *\n * @FIF_CONTROL: pass control frames (except for PS Poll) addressed to this\n *\tstation\n *\n * @FIF_OTHER_BSS: pass frames destined to other BSSes\n *\n * @FIF_PSPOLL: pass PS Poll frames\n *\n * @FIF_PROBE_REQ: pass probe request frames\n *\n * @FIF_MCAST_ACTION: pass multicast Action frames\n */\nenum ieee80211_filter_flags {\n\tFIF_ALLMULTI\t\t= 1<<1,\n\tFIF_FCSFAIL\t\t= 1<<2,\n\tFIF_PLCPFAIL\t\t= 1<<3,\n\tFIF_BCN_PRBRESP_PROMISC\t= 1<<4,\n\tFIF_CONTROL\t\t= 1<<5,\n\tFIF_OTHER_BSS\t\t= 1<<6,\n\tFIF_PSPOLL\t\t= 1<<7,\n\tFIF_PROBE_REQ\t\t= 1<<8,\n\tFIF_MCAST_ACTION\t= 1<<9,\n};\n\n/**\n * enum ieee80211_ampdu_mlme_action - A-MPDU actions\n *\n * These flags are used with the ampdu_action() callback in\n * &struct ieee80211_ops to indicate which action is needed.\n *\n * Note that drivers MUST be able to deal with a TX aggregation\n * session being stopped even before they OK'ed starting it by\n * calling ieee80211_start_tx_ba_cb_irqsafe, because the peer\n * might receive the addBA frame and send a delBA right away!\n *\n * @IEEE80211_AMPDU_RX_START: start RX aggregation\n * @IEEE80211_AMPDU_RX_STOP: stop RX aggregation\n * @IEEE80211_AMPDU_TX_START: start TX aggregation, the driver must either\n *\tcall ieee80211_start_tx_ba_cb_irqsafe() or\n *\tcall ieee80211_start_tx_ba_cb_irqsafe() with status\n *\t%IEEE80211_AMPDU_TX_START_DELAY_ADDBA to delay addba after\n *\tieee80211_start_tx_ba_cb_irqsafe is called, or just return the special\n *\tstatus %IEEE80211_AMPDU_TX_START_IMMEDIATE.\n * @IEEE80211_AMPDU_TX_OPERATIONAL: TX aggregation has become operational\n * @IEEE80211_AMPDU_TX_STOP_CONT: stop TX aggregation but continue transmitting\n *\tqueued packets, now unaggregated. After all packets are transmitted the\n *\tdriver has to call ieee80211_stop_tx_ba_cb_irqsafe().\n * @IEEE80211_AMPDU_TX_STOP_FLUSH: stop TX aggregation and flush all packets,\n *\tcalled when the station is removed. There's no need or reason to call\n *\tieee80211_stop_tx_ba_cb_irqsafe() in this case as mac80211 assumes the\n *\tsession is gone and removes the station.\n * @IEEE80211_AMPDU_TX_STOP_FLUSH_CONT: called when TX aggregation is stopped\n *\tbut the driver hasn't called ieee80211_stop_tx_ba_cb_irqsafe() yet and\n *\tnow the connection is dropped and the station will be removed. Drivers\n *\tshould clean up and drop remaining packets when this is called.\n */\nenum ieee80211_ampdu_mlme_action {\n\tIEEE80211_AMPDU_RX_START,\n\tIEEE80211_AMPDU_RX_STOP,\n\tIEEE80211_AMPDU_TX_START,\n\tIEEE80211_AMPDU_TX_STOP_CONT,\n\tIEEE80211_AMPDU_TX_STOP_FLUSH,\n\tIEEE80211_AMPDU_TX_STOP_FLUSH_CONT,\n\tIEEE80211_AMPDU_TX_OPERATIONAL,\n};\n\n#define IEEE80211_AMPDU_TX_START_IMMEDIATE 1\n#define IEEE80211_AMPDU_TX_START_DELAY_ADDBA 2\n\n/**\n * struct ieee80211_ampdu_params - AMPDU action parameters\n *\n * @action: the ampdu action, value from %ieee80211_ampdu_mlme_action.\n * @sta: peer of this AMPDU session\n * @tid: tid of the BA session\n * @ssn: start sequence number of the session. TX/RX_STOP can pass 0. When\n *\taction is set to %IEEE80211_AMPDU_RX_START the driver passes back the\n *\tactual ssn value used to start the session and writes the value here.\n * @buf_size: reorder buffer size  (number of subframes). Valid only when the\n *\taction is set to %IEEE80211_AMPDU_RX_START or\n *\t%IEEE80211_AMPDU_TX_OPERATIONAL\n * @amsdu: indicates the peer's ability to receive A-MSDU within A-MPDU.\n *\tvalid when the action is set to %IEEE80211_AMPDU_TX_OPERATIONAL\n * @timeout: BA session timeout. Valid only when the action is set to\n *\t%IEEE80211_AMPDU_RX_START\n */\nstruct ieee80211_ampdu_params {\n\tenum ieee80211_ampdu_mlme_action action;\n\tstruct ieee80211_sta *sta;\n\tu16 tid;\n\tu16 ssn;\n\tu16 buf_size;\n\tbool amsdu;\n\tu16 timeout;\n};\n\n/**\n * enum ieee80211_frame_release_type - frame release reason\n * @IEEE80211_FRAME_RELEASE_PSPOLL: frame released for PS-Poll\n * @IEEE80211_FRAME_RELEASE_UAPSD: frame(s) released due to\n *\tframe received on trigger-enabled AC\n */\nenum ieee80211_frame_release_type {\n\tIEEE80211_FRAME_RELEASE_PSPOLL,\n\tIEEE80211_FRAME_RELEASE_UAPSD,\n};\n\n/**\n * enum ieee80211_rate_control_changed - flags to indicate what changed\n *\n * @IEEE80211_RC_BW_CHANGED: The bandwidth that can be used to transmit\n *\tto this station changed. The actual bandwidth is in the station\n *\tinformation -- for HT20/40 the IEEE80211_HT_CAP_SUP_WIDTH_20_40\n *\tflag changes, for HT and VHT the bandwidth field changes.\n * @IEEE80211_RC_SMPS_CHANGED: The SMPS state of the station changed.\n * @IEEE80211_RC_SUPP_RATES_CHANGED: The supported rate set of this peer\n *\tchanged (in IBSS mode) due to discovering more information about\n *\tthe peer.\n * @IEEE80211_RC_NSS_CHANGED: N_SS (number of spatial streams) was changed\n *\tby the peer\n */\nenum ieee80211_rate_control_changed {\n\tIEEE80211_RC_BW_CHANGED\t\t= BIT(0),\n\tIEEE80211_RC_SMPS_CHANGED\t= BIT(1),\n\tIEEE80211_RC_SUPP_RATES_CHANGED\t= BIT(2),\n\tIEEE80211_RC_NSS_CHANGED\t= BIT(3),\n};\n\n/**\n * enum ieee80211_roc_type - remain on channel type\n *\n * With the support for multi channel contexts and multi channel operations,\n * remain on channel operations might be limited/deferred/aborted by other\n * flows/operations which have higher priority (and vice versa).\n * Specifying the ROC type can be used by devices to prioritize the ROC\n * operations compared to other operations/flows.\n *\n * @IEEE80211_ROC_TYPE_NORMAL: There are no special requirements for this ROC.\n * @IEEE80211_ROC_TYPE_MGMT_TX: The remain on channel request is required\n *\tfor sending management frames offchannel.\n */\nenum ieee80211_roc_type {\n\tIEEE80211_ROC_TYPE_NORMAL = 0,\n\tIEEE80211_ROC_TYPE_MGMT_TX,\n};\n\n/**\n * enum ieee80211_reconfig_complete_type - reconfig type\n *\n * This enum is used by the reconfig_complete() callback to indicate what\n * reconfiguration type was completed.\n *\n * @IEEE80211_RECONFIG_TYPE_RESTART: hw restart type\n *\t(also due to resume() callback returning 1)\n * @IEEE80211_RECONFIG_TYPE_SUSPEND: suspend type (regardless\n *\tof wowlan configuration)\n */\nenum ieee80211_reconfig_type {\n\tIEEE80211_RECONFIG_TYPE_RESTART,\n\tIEEE80211_RECONFIG_TYPE_SUSPEND,\n};\n\n/**\n * struct ieee80211_ops - callbacks from mac80211 to the driver\n *\n * This structure contains various callbacks that the driver may\n * handle or, in some cases, must handle, for example to configure\n * the hardware to a new channel or to transmit a frame.\n *\n * @tx: Handler that 802.11 module calls for each transmitted frame.\n *\tskb contains the buffer starting from the IEEE 802.11 header.\n *\tThe low-level driver should send the frame out based on\n *\tconfiguration in the TX control data. This handler should,\n *\tpreferably, never fail and stop queues appropriately.\n *\tMust be atomic.\n *\n * @start: Called before the first netdevice attached to the hardware\n *\tis enabled. This should turn on the hardware and must turn on\n *\tframe reception (for possibly enabled monitor interfaces.)\n *\tReturns negative error codes, these may be seen in userspace,\n *\tor zero.\n *\tWhen the device is started it should not have a MAC address\n *\tto avoid acknowledging frames before a non-monitor device\n *\tis added.\n *\tMust be implemented and can sleep.\n *\n * @stop: Called after last netdevice attached to the hardware\n *\tis disabled. This should turn off the hardware (at least\n *\tit must turn off frame reception.)\n *\tMay be called right after add_interface if that rejects\n *\tan interface. If you added any work onto the mac80211 workqueue\n *\tyou should ensure to cancel it on this callback.\n *\tMust be implemented and can sleep.\n *\n * @suspend: Suspend the device; mac80211 itself will quiesce before and\n *\tstop transmitting and doing any other configuration, and then\n *\task the device to suspend. This is only invoked when WoWLAN is\n *\tconfigured, otherwise the device is deconfigured completely and\n *\treconfigured at resume time.\n *\tThe driver may also impose special conditions under which it\n *\twants to use the \"normal\" suspend (deconfigure), say if it only\n *\tsupports WoWLAN when the device is associated. In this case, it\n *\tmust return 1 from this function.\n *\n * @resume: If WoWLAN was configured, this indicates that mac80211 is\n *\tnow resuming its operation, after this the device must be fully\n *\tfunctional again. If this returns an error, the only way out is\n *\tto also unregister the device. If it returns 1, then mac80211\n *\twill also go through the regular complete restart on resume.\n *\n * @set_wakeup: Enable or disable wakeup when WoWLAN configuration is\n *\tmodified. The reason is that device_set_wakeup_enable() is\n *\tsupposed to be called when the configuration changes, not only\n *\tin suspend().\n *\n * @add_interface: Called when a netdevice attached to the hardware is\n *\tenabled. Because it is not called for monitor mode devices, @start\n *\tand @stop must be implemented.\n *\tThe driver should perform any initialization it needs before\n *\tthe device can be enabled. The initial configuration for the\n *\tinterface is given in the conf parameter.\n *\tThe callback may refuse to add an interface by returning a\n *\tnegative error code (which will be seen in userspace.)\n *\tMust be implemented and can sleep.\n *\n * @change_interface: Called when a netdevice changes type. This callback\n *\tis optional, but only if it is supported can interface types be\n *\tswitched while the interface is UP. The callback may sleep.\n *\tNote that while an interface is being switched, it will not be\n *\tfound by the interface iteration callbacks.\n *\n * @remove_interface: Notifies a driver that an interface is going down.\n *\tThe @stop callback is called after this if it is the last interface\n *\tand no monitor interfaces are present.\n *\tWhen all interfaces are removed, the MAC address in the hardware\n *\tmust be cleared so the device no longer acknowledges packets,\n *\tthe mac_addr member of the conf structure is, however, set to the\n *\tMAC address of the device going away.\n *\tHence, this callback must be implemented. It can sleep.\n *\n * @config: Handler for configuration requests. IEEE 802.11 code calls this\n *\tfunction to change hardware configuration, e.g., channel.\n *\tThis function should never fail but returns a negative error code\n *\tif it does. The callback can sleep.\n *\n * @bss_info_changed: Handler for configuration requests related to BSS\n *\tparameters that may vary during BSS's lifespan, and may affect low\n *\tlevel driver (e.g. assoc/disassoc status, erp parameters).\n *\tThis function should not be used if no BSS has been set, unless\n *\tfor association indication. The @changed parameter indicates which\n *\tof the bss parameters has changed when a call is made. The callback\n *\tcan sleep.\n *\n * @prepare_multicast: Prepare for multicast filter configuration.\n *\tThis callback is optional, and its return value is passed\n *\tto configure_filter(). This callback must be atomic.\n *\n * @configure_filter: Configure the device's RX filter.\n *\tSee the section \"Frame filtering\" for more information.\n *\tThis callback must be implemented and can sleep.\n *\n * @config_iface_filter: Configure the interface's RX filter.\n *\tThis callback is optional and is used to configure which frames\n *\tshould be passed to mac80211. The filter_flags is the combination\n *\tof FIF_* flags. The changed_flags is a bit mask that indicates\n *\twhich flags are changed.\n *\tThis callback can sleep.\n *\n * @set_tim: Set TIM bit. mac80211 calls this function when a TIM bit\n * \tmust be set or cleared for a given STA. Must be atomic.\n *\n * @set_key: See the section \"Hardware crypto acceleration\"\n *\tThis callback is only called between add_interface and\n *\tremove_interface calls, i.e. while the given virtual interface\n *\tis enabled.\n *\tReturns a negative error code if the key can't be added.\n *\tThe callback can sleep.\n *\n * @update_tkip_key: See the section \"Hardware crypto acceleration\"\n * \tThis callback will be called in the context of Rx. Called for drivers\n * \twhich set IEEE80211_KEY_FLAG_TKIP_REQ_RX_P1_KEY.\n *\tThe callback must be atomic.\n *\n * @set_rekey_data: If the device supports GTK rekeying, for example while the\n *\thost is suspended, it can assign this callback to retrieve the data\n *\tnecessary to do GTK rekeying, this is the KEK, KCK and replay counter.\n *\tAfter rekeying was done it should (for example during resume) notify\n *\tuserspace of the new replay counter using ieee80211_gtk_rekey_notify().\n *\n * @set_default_unicast_key: Set the default (unicast) key index, useful for\n *\tWEP when the device sends data packets autonomously, e.g. for ARP\n *\toffloading. The index can be 0-3, or -1 for unsetting it.\n *\n * @hw_scan: Ask the hardware to service the scan request, no need to start\n *\tthe scan state machine in stack. The scan must honour the channel\n *\tconfiguration done by the regulatory agent in the wiphy's\n *\tregistered bands. The hardware (or the driver) needs to make sure\n *\tthat power save is disabled.\n *\tThe @req ie/ie_len members are rewritten by mac80211 to contain the\n *\tentire IEs after the SSID, so that drivers need not look at these\n *\tat all but just send them after the SSID -- mac80211 includes the\n *\t(extended) supported rates and HT information (where applicable).\n *\tWhen the scan finishes, ieee80211_scan_completed() must be called;\n *\tnote that it also must be called when the scan cannot finish due to\n *\tany error unless this callback returned a negative error code.\n *\tThis callback is also allowed to return the special return value 1,\n *\tthis indicates that hardware scan isn't desirable right now and a\n *\tsoftware scan should be done instead. A driver wishing to use this\n *\tcapability must ensure its (hardware) scan capabilities aren't\n *\tadvertised as more capable than mac80211's software scan is.\n *\tThe callback can sleep.\n *\n * @cancel_hw_scan: Ask the low-level tp cancel the active hw scan.\n *\tThe driver should ask the hardware to cancel the scan (if possible),\n *\tbut the scan will be completed only after the driver will call\n *\tieee80211_scan_completed().\n *\tThis callback is needed for wowlan, to prevent enqueueing a new\n *\tscan_work after the low-level driver was already suspended.\n *\tThe callback can sleep.\n *\n * @sched_scan_start: Ask the hardware to start scanning repeatedly at\n *\tspecific intervals.  The driver must call the\n *\tieee80211_sched_scan_results() function whenever it finds results.\n *\tThis process will continue until sched_scan_stop is called.\n *\n * @sched_scan_stop: Tell the hardware to stop an ongoing scheduled scan.\n *\tIn this case, ieee80211_sched_scan_stopped() must not be called.\n *\n * @sw_scan_start: Notifier function that is called just before a software scan\n *\tis started. Can be NULL, if the driver doesn't need this notification.\n *\tThe mac_addr parameter allows supporting NL80211_SCAN_FLAG_RANDOM_ADDR,\n *\tthe driver may set the NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR flag if it\n *\tcan use this parameter. The callback can sleep.\n *\n * @sw_scan_complete: Notifier function that is called just after a\n *\tsoftware scan finished. Can be NULL, if the driver doesn't need\n *\tthis notification.\n *\tThe callback can sleep.\n *\n * @get_stats: Return low-level statistics.\n * \tReturns zero if statistics are available.\n *\tThe callback can sleep.\n *\n * @get_key_seq: If your device implements encryption in hardware and does\n *\tIV/PN assignment then this callback should be provided to read the\n *\tIV/PN for the given key from hardware.\n *\tThe callback must be atomic.\n *\n * @set_frag_threshold: Configuration of fragmentation threshold. Assign this\n *\tif the device does fragmentation by itself. Note that to prevent the\n *\tstack from doing fragmentation IEEE80211_HW_SUPPORTS_TX_FRAG\n *\tshould be set as well.\n *\tThe callback can sleep.\n *\n * @set_rts_threshold: Configuration of RTS threshold (if device needs it)\n *\tThe callback can sleep.\n *\n * @sta_add: Notifies low level driver about addition of an associated station,\n *\tAP, IBSS/WDS/mesh peer etc. This callback can sleep.\n *\n * @sta_remove: Notifies low level driver about removal of an associated\n *\tstation, AP, IBSS/WDS/mesh peer etc. Note that after the callback\n *\treturns it isn't safe to use the pointer, not even RCU protected;\n *\tno RCU grace period is guaranteed between returning here and freeing\n *\tthe station. See @sta_pre_rcu_remove if needed.\n *\tThis callback can sleep.\n *\n * @sta_add_debugfs: Drivers can use this callback to add debugfs files\n *\twhen a station is added to mac80211's station list. This callback\n *\tshould be within a CONFIG_MAC80211_DEBUGFS conditional. This\n *\tcallback can sleep.\n *\n * @sta_notify: Notifies low level driver about power state transition of an\n *\tassociated station, AP,  IBSS/WDS/mesh peer etc. For a VIF operating\n *\tin AP mode, this callback will not be called when the flag\n *\t%IEEE80211_HW_AP_LINK_PS is set. Must be atomic.\n *\n * @sta_set_txpwr: Configure the station tx power. This callback set the tx\n *\tpower for the station.\n *\tThis callback can sleep.\n *\n * @sta_state: Notifies low level driver about state transition of a\n *\tstation (which can be the AP, a client, IBSS/WDS/mesh peer etc.)\n *\tThis callback is mutually exclusive with @sta_add/@sta_remove.\n *\tIt must not fail for down transitions but may fail for transitions\n *\tup the list of states. Also note that after the callback returns it\n *\tisn't safe to use the pointer, not even RCU protected - no RCU grace\n *\tperiod is guaranteed between returning here and freeing the station.\n *\tSee @sta_pre_rcu_remove if needed.\n *\tThe callback can sleep.\n *\n * @sta_pre_rcu_remove: Notify driver about station removal before RCU\n *\tsynchronisation. This is useful if a driver needs to have station\n *\tpointers protected using RCU, it can then use this call to clear\n *\tthe pointers instead of waiting for an RCU grace period to elapse\n *\tin @sta_state.\n *\tThe callback can sleep.\n *\n * @sta_rc_update: Notifies the driver of changes to the bitrates that can be\n *\tused to transmit to the station. The changes are advertised with bits\n *\tfrom &enum ieee80211_rate_control_changed and the values are reflected\n *\tin the station data. This callback should only be used when the driver\n *\tuses hardware rate control (%IEEE80211_HW_HAS_RATE_CONTROL) since\n *\totherwise the rate control algorithm is notified directly.\n *\tMust be atomic.\n * @sta_rate_tbl_update: Notifies the driver that the rate table changed. This\n *\tis only used if the configured rate control algorithm actually uses\n *\tthe new rate table API, and is therefore optional. Must be atomic.\n *\n * @sta_statistics: Get statistics for this station. For example with beacon\n *\tfiltering, the statistics kept by mac80211 might not be accurate, so\n *\tlet the driver pre-fill the statistics. The driver can fill most of\n *\tthe values (indicating which by setting the filled bitmap), but not\n *\tall of them make sense - see the source for which ones are possible.\n *\tStatistics that the driver doesn't fill will be filled by mac80211.\n *\tThe callback can sleep.\n *\n * @conf_tx: Configure TX queue parameters (EDCF (aifs, cw_min, cw_max),\n *\tbursting) for a hardware TX queue.\n *\tReturns a negative error code on failure.\n *\tThe callback can sleep.\n *\n * @get_tsf: Get the current TSF timer value from firmware/hardware. Currently,\n *\tthis is only used for IBSS mode BSSID merging and debugging. Is not a\n *\trequired function.\n *\tThe callback can sleep.\n *\n * @set_tsf: Set the TSF timer to the specified value in the firmware/hardware.\n *\tCurrently, this is only used for IBSS mode debugging. Is not a\n *\trequired function.\n *\tThe callback can sleep.\n *\n * @offset_tsf: Offset the TSF timer by the specified value in the\n *\tfirmware/hardware.  Preferred to set_tsf as it avoids delay between\n *\tcalling set_tsf() and hardware getting programmed, which will show up\n *\tas TSF delay. Is not a required function.\n *\tThe callback can sleep.\n *\n * @reset_tsf: Reset the TSF timer and allow firmware/hardware to synchronize\n *\twith other STAs in the IBSS. This is only used in IBSS mode. This\n *\tfunction is optional if the firmware/hardware takes full care of\n *\tTSF synchronization.\n *\tThe callback can sleep.\n *\n * @tx_last_beacon: Determine whether the last IBSS beacon was sent by us.\n *\tThis is needed only for IBSS mode and the result of this function is\n *\tused to determine whether to reply to Probe Requests.\n *\tReturns non-zero if this device sent the last beacon.\n *\tThe callback can sleep.\n *\n * @get_survey: Return per-channel survey information\n *\n * @rfkill_poll: Poll rfkill hardware state. If you need this, you also\n *\tneed to set wiphy->rfkill_poll to %true before registration,\n *\tand need to call wiphy_rfkill_set_hw_state() in the callback.\n *\tThe callback can sleep.\n *\n * @set_coverage_class: Set slot time for given coverage class as specified\n *\tin IEEE 802.11-2007 section 17.3.8.6 and modify ACK timeout\n *\taccordingly; coverage class equals to -1 to enable ACK timeout\n *\testimation algorithm (dynack). To disable dynack set valid value for\n *\tcoverage class. This callback is not required and may sleep.\n *\n * @testmode_cmd: Implement a cfg80211 test mode command. The passed @vif may\n *\tbe %NULL. The callback can sleep.\n * @testmode_dump: Implement a cfg80211 test mode dump. The callback can sleep.\n *\n * @flush: Flush all pending frames from the hardware queue, making sure\n *\tthat the hardware queues are empty. The @queues parameter is a bitmap\n *\tof queues to flush, which is useful if different virtual interfaces\n *\tuse different hardware queues; it may also indicate all queues.\n *\tIf the parameter @drop is set to %true, pending frames may be dropped.\n *\tNote that vif can be NULL.\n *\tThe callback can sleep.\n *\n * @channel_switch: Drivers that need (or want) to offload the channel\n *\tswitch operation for CSAs received from the AP may implement this\n *\tcallback. They must then call ieee80211_chswitch_done() to indicate\n *\tcompletion of the channel switch.\n *\n * @set_antenna: Set antenna configuration (tx_ant, rx_ant) on the device.\n *\tParameters are bitmaps of allowed antennas to use for TX/RX. Drivers may\n *\treject TX/RX mask combinations they cannot support by returning -EINVAL\n *\t(also see nl80211.h @NL80211_ATTR_WIPHY_ANTENNA_TX).\n *\n * @get_antenna: Get current antenna configuration from device (tx_ant, rx_ant).\n *\n * @remain_on_channel: Starts an off-channel period on the given channel, must\n *\tcall back to ieee80211_ready_on_channel() when on that channel. Note\n *\tthat normal channel traffic is not stopped as this is intended for hw\n *\toffload. Frames to transmit on the off-channel channel are transmitted\n *\tnormally except for the %IEEE80211_TX_CTL_TX_OFFCHAN flag. When the\n *\tduration (which will always be non-zero) expires, the driver must call\n *\tieee80211_remain_on_channel_expired().\n *\tNote that this callback may be called while the device is in IDLE and\n *\tmust be accepted in this case.\n *\tThis callback may sleep.\n * @cancel_remain_on_channel: Requests that an ongoing off-channel period is\n *\taborted before it expires. This callback may sleep.\n *\n * @set_ringparam: Set tx and rx ring sizes.\n *\n * @get_ringparam: Get tx and rx ring current and maximum sizes.\n *\n * @tx_frames_pending: Check if there is any pending frame in the hardware\n *\tqueues before entering power save.\n *\n * @set_bitrate_mask: Set a mask of rates to be used for rate control selection\n *\twhen transmitting a frame. Currently only legacy rates are handled.\n *\tThe callback can sleep.\n * @event_callback: Notify driver about any event in mac80211. See\n *\t&enum ieee80211_event_type for the different types.\n *\tThe callback must be atomic.\n *\n * @release_buffered_frames: Release buffered frames according to the given\n *\tparameters. In the case where the driver buffers some frames for\n *\tsleeping stations mac80211 will use this callback to tell the driver\n *\tto release some frames, either for PS-poll or uAPSD.\n *\tNote that if the @more_data parameter is %false the driver must check\n *\tif there are more frames on the given TIDs, and if there are more than\n *\tthe frames being released then it must still set the more-data bit in\n *\tthe frame. If the @more_data parameter is %true, then of course the\n *\tmore-data bit must always be set.\n *\tThe @tids parameter tells the driver which TIDs to release frames\n *\tfrom, for PS-poll it will always have only a single bit set.\n *\tIn the case this is used for a PS-poll initiated release, the\n *\t@num_frames parameter will always be 1 so code can be shared. In\n *\tthis case the driver must also set %IEEE80211_TX_STATUS_EOSP flag\n *\ton the TX status (and must report TX status) so that the PS-poll\n *\tperiod is properly ended. This is used to avoid sending multiple\n *\tresponses for a retried PS-poll frame.\n *\tIn the case this is used for uAPSD, the @num_frames parameter may be\n *\tbigger than one, but the driver may send fewer frames (it must send\n *\tat least one, however). In this case it is also responsible for\n *\tsetting the EOSP flag in the QoS header of the frames. Also, when the\n *\tservice period ends, the driver must set %IEEE80211_TX_STATUS_EOSP\n *\ton the last frame in the SP. Alternatively, it may call the function\n *\tieee80211_sta_eosp() to inform mac80211 of the end of the SP.\n *\tThis callback must be atomic.\n * @allow_buffered_frames: Prepare device to allow the given number of frames\n *\tto go out to the given station. The frames will be sent by mac80211\n *\tvia the usual TX path after this call. The TX information for frames\n *\treleased will also have the %IEEE80211_TX_CTL_NO_PS_BUFFER flag set\n *\tand the last one will also have %IEEE80211_TX_STATUS_EOSP set. In case\n *\tframes from multiple TIDs are released and the driver might reorder\n *\tthem between the TIDs, it must set the %IEEE80211_TX_STATUS_EOSP flag\n *\ton the last frame and clear it on all others and also handle the EOSP\n *\tbit in the QoS header correctly. Alternatively, it can also call the\n *\tieee80211_sta_eosp() function.\n *\tThe @tids parameter is a bitmap and tells the driver which TIDs the\n *\tframes will be on; it will at most have two bits set.\n *\tThis callback must be atomic.\n *\n * @get_et_sset_count:  Ethtool API to get string-set count.\n *\n * @get_et_stats:  Ethtool API to get a set of u64 stats.\n *\n * @get_et_strings:  Ethtool API to get a set of strings to describe stats\n *\tand perhaps other supported types of ethtool data-sets.\n *\n * @mgd_prepare_tx: Prepare for transmitting a management frame for association\n *\tbefore associated. In multi-channel scenarios, a virtual interface is\n *\tbound to a channel before it is associated, but as it isn't associated\n *\tyet it need not necessarily be given airtime, in particular since any\n *\ttransmission to a P2P GO needs to be synchronized against the GO's\n *\tpowersave state. mac80211 will call this function before transmitting a\n *\tmanagement frame prior to having successfully associated to allow the\n *\tdriver to give it channel time for the transmission, to get a response\n *\tand to be able to synchronize with the GO.\n *\tFor drivers that set %IEEE80211_HW_DEAUTH_NEED_MGD_TX_PREP, mac80211\n *\twould also call this function before transmitting a deauthentication\n *\tframe in case that no beacon was heard from the AP/P2P GO.\n *\tThe callback will be called before each transmission and upon return\n *\tmac80211 will transmit the frame right away.\n *      If duration is greater than zero, mac80211 hints to the driver the\n *      duration for which the operation is requested.\n *\tThe callback is optional and can (should!) sleep.\n *\n * @mgd_protect_tdls_discover: Protect a TDLS discovery session. After sending\n *\ta TDLS discovery-request, we expect a reply to arrive on the AP's\n *\tchannel. We must stay on the channel (no PSM, scan, etc.), since a TDLS\n *\tsetup-response is a direct packet not buffered by the AP.\n *\tmac80211 will call this function just before the transmission of a TDLS\n *\tdiscovery-request. The recommended period of protection is at least\n *\t2 * (DTIM period).\n *\tThe callback is optional and can sleep.\n *\n * @add_chanctx: Notifies device driver about new channel context creation.\n *\tThis callback may sleep.\n * @remove_chanctx: Notifies device driver about channel context destruction.\n *\tThis callback may sleep.\n * @change_chanctx: Notifies device driver about channel context changes that\n *\tmay happen when combining different virtual interfaces on the same\n *\tchannel context with different settings\n *\tThis callback may sleep.\n * @assign_vif_chanctx: Notifies device driver about channel context being bound\n *\tto vif. Possible use is for hw queue remapping.\n *\tThis callback may sleep.\n * @unassign_vif_chanctx: Notifies device driver about channel context being\n *\tunbound from vif.\n *\tThis callback may sleep.\n * @switch_vif_chanctx: switch a number of vifs from one chanctx to\n *\tanother, as specified in the list of\n *\t@ieee80211_vif_chanctx_switch passed to the driver, according\n *\tto the mode defined in &ieee80211_chanctx_switch_mode.\n *\tThis callback may sleep.\n *\n * @start_ap: Start operation on the AP interface, this is called after all the\n *\tinformation in bss_conf is set and beacon can be retrieved. A channel\n *\tcontext is bound before this is called. Note that if the driver uses\n *\tsoftware scan or ROC, this (and @stop_ap) isn't called when the AP is\n *\tjust \"paused\" for scanning/ROC, which is indicated by the beacon being\n *\tdisabled/enabled via @bss_info_changed.\n * @stop_ap: Stop operation on the AP interface.\n *\n * @reconfig_complete: Called after a call to ieee80211_restart_hw() and\n *\tduring resume, when the reconfiguration has completed.\n *\tThis can help the driver implement the reconfiguration step (and\n *\tindicate mac80211 is ready to receive frames).\n *\tThis callback may sleep.\n *\n * @ipv6_addr_change: IPv6 address assignment on the given interface changed.\n *\tCurrently, this is only called for managed or P2P client interfaces.\n *\tThis callback is optional; it must not sleep.\n *\n * @channel_switch_beacon: Starts a channel switch to a new channel.\n *\tBeacons are modified to include CSA or ECSA IEs before calling this\n *\tfunction. The corresponding count fields in these IEs must be\n *\tdecremented, and when they reach 1 the driver must call\n *\tieee80211_csa_finish(). Drivers which use ieee80211_beacon_get()\n *\tget the csa counter decremented by mac80211, but must check if it is\n *\t1 using ieee80211_beacon_counter_is_complete() after the beacon has been\n *\ttransmitted and then call ieee80211_csa_finish().\n *\tIf the CSA count starts as zero or 1, this function will not be called,\n *\tsince there won't be any time to beacon before the switch anyway.\n * @pre_channel_switch: This is an optional callback that is called\n *\tbefore a channel switch procedure is started (ie. when a STA\n *\tgets a CSA or a userspace initiated channel-switch), allowing\n *\tthe driver to prepare for the channel switch.\n * @post_channel_switch: This is an optional callback that is called\n *\tafter a channel switch procedure is completed, allowing the\n *\tdriver to go back to a normal configuration.\n * @abort_channel_switch: This is an optional callback that is called\n *\twhen channel switch procedure was completed, allowing the\n *\tdriver to go back to a normal configuration.\n * @channel_switch_rx_beacon: This is an optional callback that is called\n *\twhen channel switch procedure is in progress and additional beacon with\n *\tCSA IE was received, allowing driver to track changes in count.\n * @join_ibss: Join an IBSS (on an IBSS interface); this is called after all\n *\tinformation in bss_conf is set up and the beacon can be retrieved. A\n *\tchannel context is bound before this is called.\n * @leave_ibss: Leave the IBSS again.\n *\n * @get_expected_throughput: extract the expected throughput towards the\n *\tspecified station. The returned value is expressed in Kbps. It returns 0\n *\tif the RC algorithm does not have proper data to provide.\n *\n * @get_txpower: get current maximum tx power (in dBm) based on configuration\n *\tand hardware limits.\n *\n * @tdls_channel_switch: Start channel-switching with a TDLS peer. The driver\n *\tis responsible for continually initiating channel-switching operations\n *\tand returning to the base channel for communication with the AP. The\n *\tdriver receives a channel-switch request template and the location of\n *\tthe switch-timing IE within the template as part of the invocation.\n *\tThe template is valid only within the call, and the driver can\n *\toptionally copy the skb for further re-use.\n * @tdls_cancel_channel_switch: Stop channel-switching with a TDLS peer. Both\n *\tpeers must be on the base channel when the call completes.\n * @tdls_recv_channel_switch: a TDLS channel-switch related frame (request or\n *\tresponse) has been received from a remote peer. The driver gets\n *\tparameters parsed from the incoming frame and may use them to continue\n *\tan ongoing channel-switch operation. In addition, a channel-switch\n *\tresponse template is provided, together with the location of the\n *\tswitch-timing IE within the template. The skb can only be used within\n *\tthe function call.\n *\n * @wake_tx_queue: Called when new packets have been added to the queue.\n * @sync_rx_queues: Process all pending frames in RSS queues. This is a\n *\tsynchronization which is needed in case driver has in its RSS queues\n *\tpending frames that were received prior to the control path action\n *\tcurrently taken (e.g. disassociation) but are not processed yet.\n *\n * @start_nan: join an existing NAN cluster, or create a new one.\n * @stop_nan: leave the NAN cluster.\n * @nan_change_conf: change NAN configuration. The data in cfg80211_nan_conf\n *\tcontains full new configuration and changes specify which parameters\n *\tare changed with respect to the last NAN config.\n *\tThe driver gets both full configuration and the changed parameters since\n *\tsome devices may need the full configuration while others need only the\n *\tchanged parameters.\n * @add_nan_func: Add a NAN function. Returns 0 on success. The data in\n *\tcfg80211_nan_func must not be referenced outside the scope of\n *\tthis call.\n * @del_nan_func: Remove a NAN function. The driver must call\n *\tieee80211_nan_func_terminated() with\n *\tNL80211_NAN_FUNC_TERM_REASON_USER_REQUEST reason code upon removal.\n * @can_aggregate_in_amsdu: Called in order to determine if HW supports\n *\taggregating two specific frames in the same A-MSDU. The relation\n *\tbetween the skbs should be symmetric and transitive. Note that while\n *\tskb is always a real frame, head may or may not be an A-MSDU.\n * @get_ftm_responder_stats: Retrieve FTM responder statistics, if available.\n *\tStatistics should be cumulative, currently no way to reset is provided.\n *\n * @start_pmsr: start peer measurement (e.g. FTM) (this call can sleep)\n * @abort_pmsr: abort peer measurement (this call can sleep)\n * @set_tid_config: Apply TID specific configurations. This callback may sleep.\n * @reset_tid_config: Reset TID specific configuration for the peer.\n *\tThis callback may sleep.\n * @update_vif_offload: Update virtual interface offload flags\n *\tThis callback may sleep.\n * @sta_set_4addr: Called to notify the driver when a station starts/stops using\n *\t4-address mode\n */\nstruct ieee80211_ops {\n\tvoid (*tx)(struct ieee80211_hw *hw,\n\t\t   struct ieee80211_tx_control *control,\n\t\t   struct sk_buff *skb);\n\tint (*start)(struct ieee80211_hw *hw);\n\tvoid (*stop)(struct ieee80211_hw *hw);\n#ifdef CONFIG_PM\n\tint (*suspend)(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan);\n\tint (*resume)(struct ieee80211_hw *hw);\n\tvoid (*set_wakeup)(struct ieee80211_hw *hw, bool enabled);\n#endif\n\tint (*add_interface)(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif);\n\tint (*change_interface)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tenum nl80211_iftype new_type, bool p2p);\n\tvoid (*remove_interface)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif);\n\tint (*config)(struct ieee80211_hw *hw, u32 changed);\n\tvoid (*bss_info_changed)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_bss_conf *info,\n\t\t\t\t u32 changed);\n\n\tint (*start_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\tvoid (*stop_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\n\tu64 (*prepare_multicast)(struct ieee80211_hw *hw,\n\t\t\t\t struct netdev_hw_addr_list *mc_list);\n\tvoid (*configure_filter)(struct ieee80211_hw *hw,\n\t\t\t\t unsigned int changed_flags,\n\t\t\t\t unsigned int *total_flags,\n\t\t\t\t u64 multicast);\n\tvoid (*config_iface_filter)(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    unsigned int filter_flags,\n\t\t\t\t    unsigned int changed_flags);\n\tint (*set_tim)(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t       bool set);\n\tint (*set_key)(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t       struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t       struct ieee80211_key_conf *key);\n\tvoid (*update_tkip_key)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_key_conf *conf,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tu32 iv32, u16 *phase1key);\n\tvoid (*set_rekey_data)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct cfg80211_gtk_rekey_data *data);\n\tvoid (*set_default_unicast_key)(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif, int idx);\n\tint (*hw_scan)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_scan_request *req);\n\tvoid (*cancel_hw_scan)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif);\n\tint (*sched_scan_start)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct cfg80211_sched_scan_request *req,\n\t\t\t\tstruct ieee80211_scan_ies *ies);\n\tint (*sched_scan_stop)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif);\n\tvoid (*sw_scan_start)(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      const u8 *mac_addr);\n\tvoid (*sw_scan_complete)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif);\n\tint (*get_stats)(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_low_level_stats *stats);\n\tvoid (*get_key_seq)(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_key_conf *key,\n\t\t\t    struct ieee80211_key_seq *seq);\n\tint (*set_frag_threshold)(struct ieee80211_hw *hw, u32 value);\n\tint (*set_rts_threshold)(struct ieee80211_hw *hw, u32 value);\n\tint (*sta_add)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_sta *sta);\n\tint (*sta_remove)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_sta *sta);\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tvoid (*sta_add_debugfs)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tstruct dentry *dir);\n#endif\n\tvoid (*sta_notify)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tenum sta_notify_cmd, struct ieee80211_sta *sta);\n\tint (*sta_set_txpwr)(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_sta *sta);\n\tint (*sta_state)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_sta *sta,\n\t\t\t enum ieee80211_sta_state old_state,\n\t\t\t enum ieee80211_sta_state new_state);\n\tvoid (*sta_pre_rcu_remove)(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta);\n\tvoid (*sta_rc_update)(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta,\n\t\t\t      u32 changed);\n\tvoid (*sta_rate_tbl_update)(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_sta *sta);\n\tvoid (*sta_statistics)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       struct station_info *sinfo);\n\tint (*conf_tx)(struct ieee80211_hw *hw,\n\t\t       struct ieee80211_vif *vif, u16 ac,\n\t\t       const struct ieee80211_tx_queue_params *params);\n\tu64 (*get_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\tvoid (*set_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tu64 tsf);\n\tvoid (*offset_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   s64 offset);\n\tvoid (*reset_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\tint (*tx_last_beacon)(struct ieee80211_hw *hw);\n\n\t/**\n\t * @ampdu_action:\n\t * Perform a certain A-MPDU action.\n\t * The RA/TID combination determines the destination and TID we want\n\t * the ampdu action to be performed for. The action is defined through\n\t * ieee80211_ampdu_mlme_action.\n\t * When the action is set to %IEEE80211_AMPDU_TX_OPERATIONAL the driver\n\t * may neither send aggregates containing more subframes than @buf_size\n\t * nor send aggregates in a way that lost frames would exceed the\n\t * buffer size. If just limiting the aggregate size, this would be\n\t * possible with a buf_size of 8:\n\t *\n\t * - ``TX: 1.....7``\n\t * - ``RX:  2....7`` (lost frame #1)\n\t * - ``TX:        8..1...``\n\t *\n\t * which is invalid since #1 was now re-transmitted well past the\n\t * buffer size of 8. Correct ways to retransmit #1 would be:\n\t *\n\t * - ``TX:        1   or``\n\t * - ``TX:        18  or``\n\t * - ``TX:        81``\n\t *\n\t * Even ``189`` would be wrong since 1 could be lost again.\n\t *\n\t * Returns a negative error code on failure. The driver may return\n\t * %IEEE80211_AMPDU_TX_START_IMMEDIATE for %IEEE80211_AMPDU_TX_START\n\t * if the session can start immediately.\n\t *\n\t * The callback can sleep.\n\t */\n\tint (*ampdu_action)(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_ampdu_params *params);\n\tint (*get_survey)(struct ieee80211_hw *hw, int idx,\n\t\tstruct survey_info *survey);\n\tvoid (*rfkill_poll)(struct ieee80211_hw *hw);\n\tvoid (*set_coverage_class)(struct ieee80211_hw *hw, s16 coverage_class);\n#ifdef CONFIG_NL80211_TESTMODE\n\tint (*testmode_cmd)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t    void *data, int len);\n\tint (*testmode_dump)(struct ieee80211_hw *hw, struct sk_buff *skb,\n\t\t\t     struct netlink_callback *cb,\n\t\t\t     void *data, int len);\n#endif\n\tvoid (*flush)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t      u32 queues, bool drop);\n\tvoid (*channel_switch)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_channel_switch *ch_switch);\n\tint (*set_antenna)(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant);\n\tint (*get_antenna)(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant);\n\n\tint (*remain_on_channel)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_channel *chan,\n\t\t\t\t int duration,\n\t\t\t\t enum ieee80211_roc_type type);\n\tint (*cancel_remain_on_channel)(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif);\n\tint (*set_ringparam)(struct ieee80211_hw *hw, u32 tx, u32 rx);\n\tvoid (*get_ringparam)(struct ieee80211_hw *hw,\n\t\t\t      u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max);\n\tbool (*tx_frames_pending)(struct ieee80211_hw *hw);\n\tint (*set_bitrate_mask)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t\tconst struct cfg80211_bitrate_mask *mask);\n\tvoid (*event_callback)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       const struct ieee80211_event *event);\n\n\tvoid (*allow_buffered_frames)(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      u16 tids, int num_frames,\n\t\t\t\t      enum ieee80211_frame_release_type reason,\n\t\t\t\t      bool more_data);\n\tvoid (*release_buffered_frames)(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\tu16 tids, int num_frames,\n\t\t\t\t\tenum ieee80211_frame_release_type reason,\n\t\t\t\t\tbool more_data);\n\n\tint\t(*get_et_sset_count)(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif, int sset);\n\tvoid\t(*get_et_stats)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ethtool_stats *stats, u64 *data);\n\tvoid\t(*get_et_strings)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  u32 sset, u8 *data);\n\n\tvoid\t(*mgd_prepare_tx)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  u16 duration);\n\n\tvoid\t(*mgd_protect_tdls_discover)(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_vif *vif);\n\n\tint (*add_chanctx)(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_chanctx_conf *ctx);\n\tvoid (*remove_chanctx)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_chanctx_conf *ctx);\n\tvoid (*change_chanctx)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_chanctx_conf *ctx,\n\t\t\t       u32 changed);\n\tint (*assign_vif_chanctx)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_chanctx_conf *ctx);\n\tvoid (*unassign_vif_chanctx)(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_chanctx_conf *ctx);\n\tint (*switch_vif_chanctx)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t\t  int n_vifs,\n\t\t\t\t  enum ieee80211_chanctx_switch_mode mode);\n\n\tvoid (*reconfig_complete)(struct ieee80211_hw *hw,\n\t\t\t\t  enum ieee80211_reconfig_type reconfig_type);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tvoid (*ipv6_addr_change)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct inet6_dev *idev);\n#endif\n\tvoid (*channel_switch_beacon)(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct cfg80211_chan_def *chandef);\n\tint (*pre_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_channel_switch *ch_switch);\n\n\tint (*post_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif);\n\tvoid (*abort_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif);\n\tvoid (*channel_switch_rx_beacon)(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct ieee80211_channel_switch *ch_switch);\n\n\tint (*join_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\tvoid (*leave_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\tu32 (*get_expected_throughput)(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_sta *sta);\n\tint (*get_txpower)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   int *dbm);\n\n\tint (*tdls_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta, u8 oper_class,\n\t\t\t\t   struct cfg80211_chan_def *chandef,\n\t\t\t\t   struct sk_buff *tmpl_skb, u32 ch_sw_tm_ie);\n\tvoid (*tdls_cancel_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   struct ieee80211_sta *sta);\n\tvoid (*tdls_recv_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct ieee80211_tdls_ch_sw_params *params);\n\n\tvoid (*wake_tx_queue)(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_txq *txq);\n\tvoid (*sync_rx_queues)(struct ieee80211_hw *hw);\n\n\tint (*start_nan)(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t struct cfg80211_nan_conf *conf);\n\tint (*stop_nan)(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_vif *vif);\n\tint (*nan_change_conf)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct cfg80211_nan_conf *conf, u32 changes);\n\tint (*add_nan_func)(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    const struct cfg80211_nan_func *nan_func);\n\tvoid (*del_nan_func)(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    u8 instance_id);\n\tbool (*can_aggregate_in_amsdu)(struct ieee80211_hw *hw,\n\t\t\t\t       struct sk_buff *head,\n\t\t\t\t       struct sk_buff *skb);\n\tint (*get_ftm_responder_stats)(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct cfg80211_ftm_responder_stats *ftm_stats);\n\tint (*start_pmsr)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t  struct cfg80211_pmsr_request *request);\n\tvoid (*abort_pmsr)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   struct cfg80211_pmsr_request *request);\n\tint (*set_tid_config)(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta,\n\t\t\t      struct cfg80211_tid_config *tid_conf);\n\tint (*reset_tid_config)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta, u8 tids);\n\tvoid (*update_vif_offload)(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif);\n\tvoid (*sta_set_4addr)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta, bool enabled);\n};\n\n/**\n * ieee80211_alloc_hw_nm - Allocate a new hardware device\n *\n * This must be called once for each hardware device. The returned pointer\n * must be used to refer to this device when calling other functions.\n * mac80211 allocates a private data area for the driver pointed to by\n * @priv in &struct ieee80211_hw, the size of this area is given as\n * @priv_data_len.\n *\n * @priv_data_len: length of private data\n * @ops: callbacks for this device\n * @requested_name: Requested name for this device.\n *\tNULL is valid value, and means use the default naming (phy%d)\n *\n * Return: A pointer to the new hardware device, or %NULL on error.\n */\nstruct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,\n\t\t\t\t\t   const struct ieee80211_ops *ops,\n\t\t\t\t\t   const char *requested_name);\n\n/**\n * ieee80211_alloc_hw - Allocate a new hardware device\n *\n * This must be called once for each hardware device. The returned pointer\n * must be used to refer to this device when calling other functions.\n * mac80211 allocates a private data area for the driver pointed to by\n * @priv in &struct ieee80211_hw, the size of this area is given as\n * @priv_data_len.\n *\n * @priv_data_len: length of private data\n * @ops: callbacks for this device\n *\n * Return: A pointer to the new hardware device, or %NULL on error.\n */\nstatic inline\nstruct ieee80211_hw *ieee80211_alloc_hw(size_t priv_data_len,\n\t\t\t\t\tconst struct ieee80211_ops *ops)\n{\n\treturn ieee80211_alloc_hw_nm(priv_data_len, ops, NULL);\n}\n\n/**\n * ieee80211_register_hw - Register hardware device\n *\n * You must call this function before any other functions in\n * mac80211. Note that before a hardware can be registered, you\n * need to fill the contained wiphy's information.\n *\n * @hw: the device to register as returned by ieee80211_alloc_hw()\n *\n * Return: 0 on success. An error code otherwise.\n */\nint ieee80211_register_hw(struct ieee80211_hw *hw);\n\n/**\n * struct ieee80211_tpt_blink - throughput blink description\n * @throughput: throughput in Kbit/sec\n * @blink_time: blink time in milliseconds\n *\t(full cycle, ie. one off + one on period)\n */\nstruct ieee80211_tpt_blink {\n\tint throughput;\n\tint blink_time;\n};\n\n/**\n * enum ieee80211_tpt_led_trigger_flags - throughput trigger flags\n * @IEEE80211_TPT_LEDTRIG_FL_RADIO: enable blinking with radio\n * @IEEE80211_TPT_LEDTRIG_FL_WORK: enable blinking when working\n * @IEEE80211_TPT_LEDTRIG_FL_CONNECTED: enable blinking when at least one\n *\tinterface is connected in some way, including being an AP\n */\nenum ieee80211_tpt_led_trigger_flags {\n\tIEEE80211_TPT_LEDTRIG_FL_RADIO\t\t= BIT(0),\n\tIEEE80211_TPT_LEDTRIG_FL_WORK\t\t= BIT(1),\n\tIEEE80211_TPT_LEDTRIG_FL_CONNECTED\t= BIT(2),\n};\n\n#ifdef CONFIG_MAC80211_LEDS\nconst char *__ieee80211_get_tx_led_name(struct ieee80211_hw *hw);\nconst char *__ieee80211_get_rx_led_name(struct ieee80211_hw *hw);\nconst char *__ieee80211_get_assoc_led_name(struct ieee80211_hw *hw);\nconst char *__ieee80211_get_radio_led_name(struct ieee80211_hw *hw);\nconst char *\n__ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw,\n\t\t\t\t   unsigned int flags,\n\t\t\t\t   const struct ieee80211_tpt_blink *blink_table,\n\t\t\t\t   unsigned int blink_table_len);\n#endif\n/**\n * ieee80211_get_tx_led_name - get name of TX LED\n *\n * mac80211 creates a transmit LED trigger for each wireless hardware\n * that can be used to drive LEDs if your driver registers a LED device.\n * This function returns the name (or %NULL if not configured for LEDs)\n * of the trigger so you can automatically link the LED device.\n *\n * @hw: the hardware to get the LED trigger name for\n *\n * Return: The name of the LED trigger. %NULL if not configured for LEDs.\n */\nstatic inline const char *ieee80211_get_tx_led_name(struct ieee80211_hw *hw)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_get_tx_led_name(hw);\n#else\n\treturn NULL;\n#endif\n}\n\n/**\n * ieee80211_get_rx_led_name - get name of RX LED\n *\n * mac80211 creates a receive LED trigger for each wireless hardware\n * that can be used to drive LEDs if your driver registers a LED device.\n * This function returns the name (or %NULL if not configured for LEDs)\n * of the trigger so you can automatically link the LED device.\n *\n * @hw: the hardware to get the LED trigger name for\n *\n * Return: The name of the LED trigger. %NULL if not configured for LEDs.\n */\nstatic inline const char *ieee80211_get_rx_led_name(struct ieee80211_hw *hw)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_get_rx_led_name(hw);\n#else\n\treturn NULL;\n#endif\n}\n\n/**\n * ieee80211_get_assoc_led_name - get name of association LED\n *\n * mac80211 creates a association LED trigger for each wireless hardware\n * that can be used to drive LEDs if your driver registers a LED device.\n * This function returns the name (or %NULL if not configured for LEDs)\n * of the trigger so you can automatically link the LED device.\n *\n * @hw: the hardware to get the LED trigger name for\n *\n * Return: The name of the LED trigger. %NULL if not configured for LEDs.\n */\nstatic inline const char *ieee80211_get_assoc_led_name(struct ieee80211_hw *hw)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_get_assoc_led_name(hw);\n#else\n\treturn NULL;\n#endif\n}\n\n/**\n * ieee80211_get_radio_led_name - get name of radio LED\n *\n * mac80211 creates a radio change LED trigger for each wireless hardware\n * that can be used to drive LEDs if your driver registers a LED device.\n * This function returns the name (or %NULL if not configured for LEDs)\n * of the trigger so you can automatically link the LED device.\n *\n * @hw: the hardware to get the LED trigger name for\n *\n * Return: The name of the LED trigger. %NULL if not configured for LEDs.\n */\nstatic inline const char *ieee80211_get_radio_led_name(struct ieee80211_hw *hw)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_get_radio_led_name(hw);\n#else\n\treturn NULL;\n#endif\n}\n\n/**\n * ieee80211_create_tpt_led_trigger - create throughput LED trigger\n * @hw: the hardware to create the trigger for\n * @flags: trigger flags, see &enum ieee80211_tpt_led_trigger_flags\n * @blink_table: the blink table -- needs to be ordered by throughput\n * @blink_table_len: size of the blink table\n *\n * Return: %NULL (in case of error, or if no LED triggers are\n * configured) or the name of the new trigger.\n *\n * Note: This function must be called before ieee80211_register_hw().\n */\nstatic inline const char *\nieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw, unsigned int flags,\n\t\t\t\t const struct ieee80211_tpt_blink *blink_table,\n\t\t\t\t unsigned int blink_table_len)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_create_tpt_led_trigger(hw, flags, blink_table,\n\t\t\t\t\t\t  blink_table_len);\n#else\n\treturn NULL;\n#endif\n}\n\n/**\n * ieee80211_unregister_hw - Unregister a hardware device\n *\n * This function instructs mac80211 to free allocated resources\n * and unregister netdevices from the networking subsystem.\n *\n * @hw: the hardware to unregister\n */\nvoid ieee80211_unregister_hw(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_free_hw - free hardware descriptor\n *\n * This function frees everything that was allocated, including the\n * private data for the driver. You must call ieee80211_unregister_hw()\n * before calling this function.\n *\n * @hw: the hardware to free\n */\nvoid ieee80211_free_hw(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_restart_hw - restart hardware completely\n *\n * Call this function when the hardware was restarted for some reason\n * (hardware error, ...) and the driver is unable to restore its state\n * by itself. mac80211 assumes that at this point the driver/hardware\n * is completely uninitialised and stopped, it starts the process by\n * calling the ->start() operation. The driver will need to reset all\n * internal state that it has prior to calling this function.\n *\n * @hw: the hardware to restart\n */\nvoid ieee80211_restart_hw(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_rx_list - receive frame and store processed skbs in a list\n *\n * Use this function to hand received frames to mac80211. The receive\n * buffer in @skb must start with an IEEE 802.11 header. In case of a\n * paged @skb is used, the driver is recommended to put the ieee80211\n * header of the frame on the linear part of the @skb to avoid memory\n * allocation and/or memcpy by the stack.\n *\n * This function may not be called in IRQ context. Calls to this function\n * for a single hardware must be synchronized against each other. Calls to\n * this function, ieee80211_rx_ni() and ieee80211_rx_irqsafe() may not be\n * mixed for a single hardware. Must not run concurrently with\n * ieee80211_tx_status() or ieee80211_tx_status_ni().\n *\n * This function must be called with BHs disabled and RCU read lock\n *\n * @hw: the hardware this frame came in on\n * @sta: the station the frame was received from, or %NULL\n * @skb: the buffer to receive, owned by mac80211 after this call\n * @list: the destination list\n */\nvoid ieee80211_rx_list(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t       struct sk_buff *skb, struct list_head *list);\n\n/**\n * ieee80211_rx_napi - receive frame from NAPI context\n *\n * Use this function to hand received frames to mac80211. The receive\n * buffer in @skb must start with an IEEE 802.11 header. In case of a\n * paged @skb is used, the driver is recommended to put the ieee80211\n * header of the frame on the linear part of the @skb to avoid memory\n * allocation and/or memcpy by the stack.\n *\n * This function may not be called in IRQ context. Calls to this function\n * for a single hardware must be synchronized against each other. Calls to\n * this function, ieee80211_rx_ni() and ieee80211_rx_irqsafe() may not be\n * mixed for a single hardware. Must not run concurrently with\n * ieee80211_tx_status() or ieee80211_tx_status_ni().\n *\n * This function must be called with BHs disabled.\n *\n * @hw: the hardware this frame came in on\n * @sta: the station the frame was received from, or %NULL\n * @skb: the buffer to receive, owned by mac80211 after this call\n * @napi: the NAPI context\n */\nvoid ieee80211_rx_napi(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t       struct sk_buff *skb, struct napi_struct *napi);\n\n/**\n * ieee80211_rx - receive frame\n *\n * Use this function to hand received frames to mac80211. The receive\n * buffer in @skb must start with an IEEE 802.11 header. In case of a\n * paged @skb is used, the driver is recommended to put the ieee80211\n * header of the frame on the linear part of the @skb to avoid memory\n * allocation and/or memcpy by the stack.\n *\n * This function may not be called in IRQ context. Calls to this function\n * for a single hardware must be synchronized against each other. Calls to\n * this function, ieee80211_rx_ni() and ieee80211_rx_irqsafe() may not be\n * mixed for a single hardware. Must not run concurrently with\n * ieee80211_tx_status() or ieee80211_tx_status_ni().\n *\n * In process context use instead ieee80211_rx_ni().\n *\n * @hw: the hardware this frame came in on\n * @skb: the buffer to receive, owned by mac80211 after this call\n */\nstatic inline void ieee80211_rx(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tieee80211_rx_napi(hw, NULL, skb, NULL);\n}\n\n/**\n * ieee80211_rx_irqsafe - receive frame\n *\n * Like ieee80211_rx() but can be called in IRQ context\n * (internally defers to a tasklet.)\n *\n * Calls to this function, ieee80211_rx() or ieee80211_rx_ni() may not\n * be mixed for a single hardware.Must not run concurrently with\n * ieee80211_tx_status() or ieee80211_tx_status_ni().\n *\n * @hw: the hardware this frame came in on\n * @skb: the buffer to receive, owned by mac80211 after this call\n */\nvoid ieee80211_rx_irqsafe(struct ieee80211_hw *hw, struct sk_buff *skb);\n\n/**\n * ieee80211_rx_ni - receive frame (in process context)\n *\n * Like ieee80211_rx() but can be called in process context\n * (internally disables bottom halves).\n *\n * Calls to this function, ieee80211_rx() and ieee80211_rx_irqsafe() may\n * not be mixed for a single hardware. Must not run concurrently with\n * ieee80211_tx_status() or ieee80211_tx_status_ni().\n *\n * @hw: the hardware this frame came in on\n * @skb: the buffer to receive, owned by mac80211 after this call\n */\nstatic inline void ieee80211_rx_ni(struct ieee80211_hw *hw,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tlocal_bh_disable();\n\tieee80211_rx(hw, skb);\n\tlocal_bh_enable();\n}\n\n/**\n * ieee80211_sta_ps_transition - PS transition for connected sta\n *\n * When operating in AP mode with the %IEEE80211_HW_AP_LINK_PS\n * flag set, use this function to inform mac80211 about a connected station\n * entering/leaving PS mode.\n *\n * This function may not be called in IRQ context or with softirqs enabled.\n *\n * Calls to this function for a single hardware must be synchronized against\n * each other.\n *\n * @sta: currently connected sta\n * @start: start or stop PS\n *\n * Return: 0 on success. -EINVAL when the requested PS mode is already set.\n */\nint ieee80211_sta_ps_transition(struct ieee80211_sta *sta, bool start);\n\n/**\n * ieee80211_sta_ps_transition_ni - PS transition for connected sta\n *                                  (in process context)\n *\n * Like ieee80211_sta_ps_transition() but can be called in process context\n * (internally disables bottom halves). Concurrent call restriction still\n * applies.\n *\n * @sta: currently connected sta\n * @start: start or stop PS\n *\n * Return: Like ieee80211_sta_ps_transition().\n */\nstatic inline int ieee80211_sta_ps_transition_ni(struct ieee80211_sta *sta,\n\t\t\t\t\t\t  bool start)\n{\n\tint ret;\n\n\tlocal_bh_disable();\n\tret = ieee80211_sta_ps_transition(sta, start);\n\tlocal_bh_enable();\n\n\treturn ret;\n}\n\n/**\n * ieee80211_sta_pspoll - PS-Poll frame received\n * @sta: currently connected station\n *\n * When operating in AP mode with the %IEEE80211_HW_AP_LINK_PS flag set,\n * use this function to inform mac80211 that a PS-Poll frame from a\n * connected station was received.\n * This must be used in conjunction with ieee80211_sta_ps_transition()\n * and possibly ieee80211_sta_uapsd_trigger(); calls to all three must\n * be serialized.\n */\nvoid ieee80211_sta_pspoll(struct ieee80211_sta *sta);\n\n/**\n * ieee80211_sta_uapsd_trigger - (potential) U-APSD trigger frame received\n * @sta: currently connected station\n * @tid: TID of the received (potential) trigger frame\n *\n * When operating in AP mode with the %IEEE80211_HW_AP_LINK_PS flag set,\n * use this function to inform mac80211 that a (potential) trigger frame\n * from a connected station was received.\n * This must be used in conjunction with ieee80211_sta_ps_transition()\n * and possibly ieee80211_sta_pspoll(); calls to all three must be\n * serialized.\n * %IEEE80211_NUM_TIDS can be passed as the tid if the tid is unknown.\n * In this case, mac80211 will not check that this tid maps to an AC\n * that is trigger enabled and assume that the caller did the proper\n * checks.\n */\nvoid ieee80211_sta_uapsd_trigger(struct ieee80211_sta *sta, u8 tid);\n\n/*\n * The TX headroom reserved by mac80211 for its own tx_status functions.\n * This is enough for the radiotap header.\n */\n#define IEEE80211_TX_STATUS_HEADROOM\tALIGN(14, 4)\n\n/**\n * ieee80211_sta_set_buffered - inform mac80211 about driver-buffered frames\n * @sta: &struct ieee80211_sta pointer for the sleeping station\n * @tid: the TID that has buffered frames\n * @buffered: indicates whether or not frames are buffered for this TID\n *\n * If a driver buffers frames for a powersave station instead of passing\n * them back to mac80211 for retransmission, the station may still need\n * to be told that there are buffered frames via the TIM bit.\n *\n * This function informs mac80211 whether or not there are frames that are\n * buffered in the driver for a given TID; mac80211 can then use this data\n * to set the TIM bit (NOTE: This may call back into the driver's set_tim\n * call! Beware of the locking!)\n *\n * If all frames are released to the station (due to PS-poll or uAPSD)\n * then the driver needs to inform mac80211 that there no longer are\n * frames buffered. However, when the station wakes up mac80211 assumes\n * that all buffered frames will be transmitted and clears this data,\n * drivers need to make sure they inform mac80211 about all buffered\n * frames on the sleep transition (sta_notify() with %STA_NOTIFY_SLEEP).\n *\n * Note that technically mac80211 only needs to know this per AC, not per\n * TID, but since driver buffering will inevitably happen per TID (since\n * it is related to aggregation) it is easier to make mac80211 map the\n * TID to the AC as required instead of keeping track in all drivers that\n * use this API.\n */\nvoid ieee80211_sta_set_buffered(struct ieee80211_sta *sta,\n\t\t\t\tu8 tid, bool buffered);\n\n/**\n * ieee80211_get_tx_rates - get the selected transmit rates for a packet\n *\n * Call this function in a driver with per-packet rate selection support\n * to combine the rate info in the packet tx info with the most recent\n * rate selection table for the station entry.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @sta: the receiver station to which this packet is sent.\n * @skb: the frame to be transmitted.\n * @dest: buffer for extracted rate/retry information\n * @max_rates: maximum number of rates to fetch\n */\nvoid ieee80211_get_tx_rates(struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    struct ieee80211_tx_rate *dest,\n\t\t\t    int max_rates);\n\n/**\n * ieee80211_sta_set_expected_throughput - set the expected tpt for a station\n *\n * Call this function to notify mac80211 about a change in expected throughput\n * to a station. A driver for a device that does rate control in firmware can\n * call this function when the expected throughput estimate towards a station\n * changes. The information is used to tune the CoDel AQM applied to traffic\n * going towards that station (which can otherwise be too aggressive and cause\n * slow stations to starve).\n *\n * @pubsta: the station to set throughput for.\n * @thr: the current expected throughput in kbps.\n */\nvoid ieee80211_sta_set_expected_throughput(struct ieee80211_sta *pubsta,\n\t\t\t\t\t   u32 thr);\n\n/**\n * ieee80211_tx_rate_update - transmit rate update callback\n *\n * Drivers should call this functions with a non-NULL pub sta\n * This function can be used in drivers that does not have provision\n * in updating the tx rate in data path.\n *\n * @hw: the hardware the frame was transmitted by\n * @pubsta: the station to update the tx rate for.\n * @info: tx status information\n */\nvoid ieee80211_tx_rate_update(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_sta *pubsta,\n\t\t\t      struct ieee80211_tx_info *info);\n\n/**\n * ieee80211_tx_status - transmit status callback\n *\n * Call this function for all transmitted frames after they have been\n * transmitted. It is permissible to not call this function for\n * multicast frames but this can affect statistics.\n *\n * This function may not be called in IRQ context. Calls to this function\n * for a single hardware must be synchronized against each other. Calls\n * to this function, ieee80211_tx_status_ni() and ieee80211_tx_status_irqsafe()\n * may not be mixed for a single hardware. Must not run concurrently with\n * ieee80211_rx() or ieee80211_rx_ni().\n *\n * @hw: the hardware the frame was transmitted by\n * @skb: the frame that was transmitted, owned by mac80211 after this call\n */\nvoid ieee80211_tx_status(struct ieee80211_hw *hw,\n\t\t\t struct sk_buff *skb);\n\n/**\n * ieee80211_tx_status_ext - extended transmit status callback\n *\n * This function can be used as a replacement for ieee80211_tx_status\n * in drivers that may want to provide extra information that does not\n * fit into &struct ieee80211_tx_info.\n *\n * Calls to this function for a single hardware must be synchronized\n * against each other. Calls to this function, ieee80211_tx_status_ni()\n * and ieee80211_tx_status_irqsafe() may not be mixed for a single hardware.\n *\n * @hw: the hardware the frame was transmitted by\n * @status: tx status information\n */\nvoid ieee80211_tx_status_ext(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_tx_status *status);\n\n/**\n * ieee80211_tx_status_noskb - transmit status callback without skb\n *\n * This function can be used as a replacement for ieee80211_tx_status\n * in drivers that cannot reliably map tx status information back to\n * specific skbs.\n *\n * Calls to this function for a single hardware must be synchronized\n * against each other. Calls to this function, ieee80211_tx_status_ni()\n * and ieee80211_tx_status_irqsafe() may not be mixed for a single hardware.\n *\n * @hw: the hardware the frame was transmitted by\n * @sta: the receiver station to which this packet is sent\n *\t(NULL for multicast packets)\n * @info: tx status information\n */\nstatic inline void ieee80211_tx_status_noskb(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_sta *sta,\n\t\t\t\t\t     struct ieee80211_tx_info *info)\n{\n\tstruct ieee80211_tx_status status = {\n\t\t.sta = sta,\n\t\t.info = info,\n\t};\n\n\tieee80211_tx_status_ext(hw, &status);\n}\n\n/**\n * ieee80211_tx_status_ni - transmit status callback (in process context)\n *\n * Like ieee80211_tx_status() but can be called in process context.\n *\n * Calls to this function, ieee80211_tx_status() and\n * ieee80211_tx_status_irqsafe() may not be mixed\n * for a single hardware.\n *\n * @hw: the hardware the frame was transmitted by\n * @skb: the frame that was transmitted, owned by mac80211 after this call\n */\nstatic inline void ieee80211_tx_status_ni(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tlocal_bh_disable();\n\tieee80211_tx_status(hw, skb);\n\tlocal_bh_enable();\n}\n\n/**\n * ieee80211_tx_status_irqsafe - IRQ-safe transmit status callback\n *\n * Like ieee80211_tx_status() but can be called in IRQ context\n * (internally defers to a tasklet.)\n *\n * Calls to this function, ieee80211_tx_status() and\n * ieee80211_tx_status_ni() may not be mixed for a single hardware.\n *\n * @hw: the hardware the frame was transmitted by\n * @skb: the frame that was transmitted, owned by mac80211 after this call\n */\nvoid ieee80211_tx_status_irqsafe(struct ieee80211_hw *hw,\n\t\t\t\t struct sk_buff *skb);\n\n/**\n * ieee80211_tx_status_8023 - transmit status callback for 802.3 frame format\n *\n * Call this function for all transmitted data frames after their transmit\n * completion. This callback should only be called for data frames which\n * are using driver's (or hardware's) offload capability of encap/decap\n * 802.11 frames.\n *\n * This function may not be called in IRQ context. Calls to this function\n * for a single hardware must be synchronized against each other and all\n * calls in the same tx status family.\n *\n * @hw: the hardware the frame was transmitted by\n * @vif: the interface for which the frame was transmitted\n * @skb: the frame that was transmitted, owned by mac80211 after this call\n */\nvoid ieee80211_tx_status_8023(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct sk_buff *skb);\n\n/**\n * ieee80211_report_low_ack - report non-responding station\n *\n * When operating in AP-mode, call this function to report a non-responding\n * connected STA.\n *\n * @sta: the non-responding connected sta\n * @num_packets: number of packets sent to @sta without a response\n */\nvoid ieee80211_report_low_ack(struct ieee80211_sta *sta, u32 num_packets);\n\n#define IEEE80211_MAX_CNTDWN_COUNTERS_NUM 2\n\n/**\n * struct ieee80211_mutable_offsets - mutable beacon offsets\n * @tim_offset: position of TIM element\n * @tim_length: size of TIM element\n * @cntdwn_counter_offs: array of IEEE80211_MAX_CNTDWN_COUNTERS_NUM offsets\n *\tto countdown counters.  This array can contain zero values which\n *\tshould be ignored.\n */\nstruct ieee80211_mutable_offsets {\n\tu16 tim_offset;\n\tu16 tim_length;\n\n\tu16 cntdwn_counter_offs[IEEE80211_MAX_CNTDWN_COUNTERS_NUM];\n};\n\n/**\n * ieee80211_beacon_get_template - beacon template generation function\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @offs: &struct ieee80211_mutable_offsets pointer to struct that will\n *\treceive the offsets that may be updated by the driver.\n *\n * If the driver implements beaconing modes, it must use this function to\n * obtain the beacon template.\n *\n * This function should be used if the beacon frames are generated by the\n * device, and then the driver must use the returned beacon as the template\n * The driver or the device are responsible to update the DTIM and, when\n * applicable, the CSA count.\n *\n * The driver is responsible for freeing the returned skb.\n *\n * Return: The beacon template. %NULL on error.\n */\nstruct sk_buff *\nieee80211_beacon_get_template(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_mutable_offsets *offs);\n\n/**\n * ieee80211_beacon_get_tim - beacon generation function\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @tim_offset: pointer to variable that will receive the TIM IE offset.\n *\tSet to 0 if invalid (in non-AP modes).\n * @tim_length: pointer to variable that will receive the TIM IE length,\n *\t(including the ID and length bytes!).\n *\tSet to 0 if invalid (in non-AP modes).\n *\n * If the driver implements beaconing modes, it must use this function to\n * obtain the beacon frame.\n *\n * If the beacon frames are generated by the host system (i.e., not in\n * hardware/firmware), the driver uses this function to get each beacon\n * frame from mac80211 -- it is responsible for calling this function exactly\n * once before the beacon is needed (e.g. based on hardware interrupt).\n *\n * The driver is responsible for freeing the returned skb.\n *\n * Return: The beacon template. %NULL on error.\n */\nstruct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t u16 *tim_offset, u16 *tim_length);\n\n/**\n * ieee80211_beacon_get - beacon generation function\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * See ieee80211_beacon_get_tim().\n *\n * Return: See ieee80211_beacon_get_tim().\n */\nstatic inline struct sk_buff *ieee80211_beacon_get(struct ieee80211_hw *hw,\n\t\t\t\t\t\t   struct ieee80211_vif *vif)\n{\n\treturn ieee80211_beacon_get_tim(hw, vif, NULL, NULL);\n}\n\n/**\n * ieee80211_beacon_update_cntdwn - request mac80211 to decrement the beacon countdown\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * The beacon counter should be updated after each beacon transmission.\n * This function is called implicitly when\n * ieee80211_beacon_get/ieee80211_beacon_get_tim are called, however if the\n * beacon frames are generated by the device, the driver should call this\n * function after each beacon transmission to sync mac80211's beacon countdown.\n *\n * Return: new countdown value\n */\nu8 ieee80211_beacon_update_cntdwn(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_beacon_set_cntdwn - request mac80211 to set beacon countdown\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @counter: the new value for the counter\n *\n * The beacon countdown can be changed by the device, this API should be\n * used by the device driver to update csa counter in mac80211.\n *\n * It should never be used together with ieee80211_beacon_update_cntdwn(),\n * as it will cause a race condition around the counter value.\n */\nvoid ieee80211_beacon_set_cntdwn(struct ieee80211_vif *vif, u8 counter);\n\n/**\n * ieee80211_csa_finish - notify mac80211 about channel switch\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * After a channel switch announcement was scheduled and the counter in this\n * announcement hits 1, this function must be called by the driver to\n * notify mac80211 that the channel can be changed.\n */\nvoid ieee80211_csa_finish(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_beacon_cntdwn_is_complete - find out if countdown reached 1\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * This function returns whether the countdown reached zero.\n */\nbool ieee80211_beacon_cntdwn_is_complete(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_proberesp_get - retrieve a Probe Response template\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * Creates a Probe Response template which can, for example, be uploaded to\n * hardware. The destination address should be set by the caller.\n *\n * Can only be called in AP mode.\n *\n * Return: The Probe Response template. %NULL on error.\n */\nstruct sk_buff *ieee80211_proberesp_get(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif);\n\n/**\n * ieee80211_pspoll_get - retrieve a PS Poll template\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * Creates a PS Poll a template which can, for example, uploaded to\n * hardware. The template must be updated after association so that correct\n * AID, BSSID and MAC address is used.\n *\n * Note: Caller (or hardware) is responsible for setting the\n * &IEEE80211_FCTL_PM bit.\n *\n * Return: The PS Poll template. %NULL on error.\n */\nstruct sk_buff *ieee80211_pspoll_get(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif);\n\n/**\n * ieee80211_nullfunc_get - retrieve a nullfunc template\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @qos_ok: QoS NDP is acceptable to the caller, this should be set\n *\tif at all possible\n *\n * Creates a Nullfunc template which can, for example, uploaded to\n * hardware. The template must be updated after association so that correct\n * BSSID and address is used.\n *\n * If @qos_ndp is set and the association is to an AP with QoS/WMM, the\n * returned packet will be QoS NDP.\n *\n * Note: Caller (or hardware) is responsible for setting the\n * &IEEE80211_FCTL_PM bit as well as Duration and Sequence Control fields.\n *\n * Return: The nullfunc template. %NULL on error.\n */\nstruct sk_buff *ieee80211_nullfunc_get(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       bool qos_ok);\n\n/**\n * ieee80211_probereq_get - retrieve a Probe Request template\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @src_addr: source MAC address\n * @ssid: SSID buffer\n * @ssid_len: length of SSID\n * @tailroom: tailroom to reserve at end of SKB for IEs\n *\n * Creates a Probe Request template which can, for example, be uploaded to\n * hardware.\n *\n * Return: The Probe Request template. %NULL on error.\n */\nstruct sk_buff *ieee80211_probereq_get(struct ieee80211_hw *hw,\n\t\t\t\t       const u8 *src_addr,\n\t\t\t\t       const u8 *ssid, size_t ssid_len,\n\t\t\t\t       size_t tailroom);\n\n/**\n * ieee80211_rts_get - RTS frame generation function\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @frame: pointer to the frame that is going to be protected by the RTS.\n * @frame_len: the frame length (in octets).\n * @frame_txctl: &struct ieee80211_tx_info of the frame.\n * @rts: The buffer where to store the RTS frame.\n *\n * If the RTS frames are generated by the host system (i.e., not in\n * hardware/firmware), the low-level driver uses this function to receive\n * the next RTS frame from the 802.11 code. The low-level is responsible\n * for calling this function before and RTS frame is needed.\n */\nvoid ieee80211_rts_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       const void *frame, size_t frame_len,\n\t\t       const struct ieee80211_tx_info *frame_txctl,\n\t\t       struct ieee80211_rts *rts);\n\n/**\n * ieee80211_rts_duration - Get the duration field for an RTS frame\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @frame_len: the length of the frame that is going to be protected by the RTS.\n * @frame_txctl: &struct ieee80211_tx_info of the frame.\n *\n * If the RTS is generated in firmware, but the host system must provide\n * the duration field, the low-level driver uses this function to receive\n * the duration field value in little-endian byteorder.\n *\n * Return: The duration.\n */\n__le16 ieee80211_rts_duration(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif, size_t frame_len,\n\t\t\t      const struct ieee80211_tx_info *frame_txctl);\n\n/**\n * ieee80211_ctstoself_get - CTS-to-self frame generation function\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @frame: pointer to the frame that is going to be protected by the CTS-to-self.\n * @frame_len: the frame length (in octets).\n * @frame_txctl: &struct ieee80211_tx_info of the frame.\n * @cts: The buffer where to store the CTS-to-self frame.\n *\n * If the CTS-to-self frames are generated by the host system (i.e., not in\n * hardware/firmware), the low-level driver uses this function to receive\n * the next CTS-to-self frame from the 802.11 code. The low-level is responsible\n * for calling this function before and CTS-to-self frame is needed.\n */\nvoid ieee80211_ctstoself_get(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     const void *frame, size_t frame_len,\n\t\t\t     const struct ieee80211_tx_info *frame_txctl,\n\t\t\t     struct ieee80211_cts *cts);\n\n/**\n * ieee80211_ctstoself_duration - Get the duration field for a CTS-to-self frame\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @frame_len: the length of the frame that is going to be protected by the CTS-to-self.\n * @frame_txctl: &struct ieee80211_tx_info of the frame.\n *\n * If the CTS-to-self is generated in firmware, but the host system must provide\n * the duration field, the low-level driver uses this function to receive\n * the duration field value in little-endian byteorder.\n *\n * Return: The duration.\n */\n__le16 ieee80211_ctstoself_duration(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    size_t frame_len,\n\t\t\t\t    const struct ieee80211_tx_info *frame_txctl);\n\n/**\n * ieee80211_generic_frame_duration - Calculate the duration field for a frame\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @band: the band to calculate the frame duration on\n * @frame_len: the length of the frame.\n * @rate: the rate at which the frame is going to be transmitted.\n *\n * Calculate the duration field of some generic frame, given its\n * length and transmission rate (in 100kbps).\n *\n * Return: The duration.\n */\n__le16 ieee80211_generic_frame_duration(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tenum nl80211_band band,\n\t\t\t\t\tsize_t frame_len,\n\t\t\t\t\tstruct ieee80211_rate *rate);\n\n/**\n * ieee80211_get_buffered_bc - accessing buffered broadcast and multicast frames\n * @hw: pointer as obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * Function for accessing buffered broadcast and multicast frames. If\n * hardware/firmware does not implement buffering of broadcast/multicast\n * frames when power saving is used, 802.11 code buffers them in the host\n * memory. The low-level driver uses this function to fetch next buffered\n * frame. In most cases, this is used when generating beacon frame.\n *\n * Return: A pointer to the next buffered skb or NULL if no more buffered\n * frames are available.\n *\n * Note: buffered frames are returned only after DTIM beacon frame was\n * generated with ieee80211_beacon_get() and the low-level driver must thus\n * call ieee80211_beacon_get() first. ieee80211_get_buffered_bc() returns\n * NULL if the previous generated beacon was not DTIM, so the low-level driver\n * does not need to check for DTIM beacons separately and should be able to\n * use common code for all beacons.\n */\nstruct sk_buff *\nieee80211_get_buffered_bc(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\n/**\n * ieee80211_get_tkip_p1k_iv - get a TKIP phase 1 key for IV32\n *\n * This function returns the TKIP phase 1 key for the given IV32.\n *\n * @keyconf: the parameter passed with the set key\n * @iv32: IV32 to get the P1K for\n * @p1k: a buffer to which the key will be written, as 5 u16 values\n */\nvoid ieee80211_get_tkip_p1k_iv(struct ieee80211_key_conf *keyconf,\n\t\t\t       u32 iv32, u16 *p1k);\n\n/**\n * ieee80211_get_tkip_p1k - get a TKIP phase 1 key\n *\n * This function returns the TKIP phase 1 key for the IV32 taken\n * from the given packet.\n *\n * @keyconf: the parameter passed with the set key\n * @skb: the packet to take the IV32 value from that will be encrypted\n *\twith this P1K\n * @p1k: a buffer to which the key will be written, as 5 u16 values\n */\nstatic inline void ieee80211_get_tkip_p1k(struct ieee80211_key_conf *keyconf,\n\t\t\t\t\t  struct sk_buff *skb, u16 *p1k)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tconst u8 *data = (u8 *)hdr + ieee80211_hdrlen(hdr->frame_control);\n\tu32 iv32 = get_unaligned_le32(&data[4]);\n\n\tieee80211_get_tkip_p1k_iv(keyconf, iv32, p1k);\n}\n\n/**\n * ieee80211_get_tkip_rx_p1k - get a TKIP phase 1 key for RX\n *\n * This function returns the TKIP phase 1 key for the given IV32\n * and transmitter address.\n *\n * @keyconf: the parameter passed with the set key\n * @ta: TA that will be used with the key\n * @iv32: IV32 to get the P1K for\n * @p1k: a buffer to which the key will be written, as 5 u16 values\n */\nvoid ieee80211_get_tkip_rx_p1k(struct ieee80211_key_conf *keyconf,\n\t\t\t       const u8 *ta, u32 iv32, u16 *p1k);\n\n/**\n * ieee80211_get_tkip_p2k - get a TKIP phase 2 key\n *\n * This function computes the TKIP RC4 key for the IV values\n * in the packet.\n *\n * @keyconf: the parameter passed with the set key\n * @skb: the packet to take the IV32/IV16 values from that will be\n *\tencrypted with this key\n * @p2k: a buffer to which the key will be written, 16 bytes\n */\nvoid ieee80211_get_tkip_p2k(struct ieee80211_key_conf *keyconf,\n\t\t\t    struct sk_buff *skb, u8 *p2k);\n\n/**\n * ieee80211_tkip_add_iv - write TKIP IV and Ext. IV to pos\n *\n * @pos: start of crypto header\n * @keyconf: the parameter passed with the set key\n * @pn: PN to add\n *\n * Returns: pointer to the octet following IVs (i.e. beginning of\n * the packet payload)\n *\n * This function writes the tkip IV value to pos (which should\n * point to the crypto header)\n */\nu8 *ieee80211_tkip_add_iv(u8 *pos, struct ieee80211_key_conf *keyconf, u64 pn);\n\n/**\n * ieee80211_get_key_rx_seq - get key RX sequence counter\n *\n * @keyconf: the parameter passed with the set key\n * @tid: The TID, or -1 for the management frame value (CCMP/GCMP only);\n *\tthe value on TID 0 is also used for non-QoS frames. For\n *\tCMAC, only TID 0 is valid.\n * @seq: buffer to receive the sequence data\n *\n * This function allows a driver to retrieve the current RX IV/PNs\n * for the given key. It must not be called if IV checking is done\n * by the device and not by mac80211.\n *\n * Note that this function may only be called when no RX processing\n * can be done concurrently.\n */\nvoid ieee80211_get_key_rx_seq(struct ieee80211_key_conf *keyconf,\n\t\t\t      int tid, struct ieee80211_key_seq *seq);\n\n/**\n * ieee80211_set_key_rx_seq - set key RX sequence counter\n *\n * @keyconf: the parameter passed with the set key\n * @tid: The TID, or -1 for the management frame value (CCMP/GCMP only);\n *\tthe value on TID 0 is also used for non-QoS frames. For\n *\tCMAC, only TID 0 is valid.\n * @seq: new sequence data\n *\n * This function allows a driver to set the current RX IV/PNs for the\n * given key. This is useful when resuming from WoWLAN sleep and GTK\n * rekey may have been done while suspended. It should not be called\n * if IV checking is done by the device and not by mac80211.\n *\n * Note that this function may only be called when no RX processing\n * can be done concurrently.\n */\nvoid ieee80211_set_key_rx_seq(struct ieee80211_key_conf *keyconf,\n\t\t\t      int tid, struct ieee80211_key_seq *seq);\n\n/**\n * ieee80211_remove_key - remove the given key\n * @keyconf: the parameter passed with the set key\n *\n * Remove the given key. If the key was uploaded to the hardware at the\n * time this function is called, it is not deleted in the hardware but\n * instead assumed to have been removed already.\n *\n * Note that due to locking considerations this function can (currently)\n * only be called during key iteration (ieee80211_iter_keys().)\n */\nvoid ieee80211_remove_key(struct ieee80211_key_conf *keyconf);\n\n/**\n * ieee80211_gtk_rekey_add - add a GTK key from rekeying during WoWLAN\n * @vif: the virtual interface to add the key on\n * @keyconf: new key data\n *\n * When GTK rekeying was done while the system was suspended, (a) new\n * key(s) will be available. These will be needed by mac80211 for proper\n * RX processing, so this function allows setting them.\n *\n * The function returns the newly allocated key structure, which will\n * have similar contents to the passed key configuration but point to\n * mac80211-owned memory. In case of errors, the function returns an\n * ERR_PTR(), use IS_ERR() etc.\n *\n * Note that this function assumes the key isn't added to hardware\n * acceleration, so no TX will be done with the key. Since it's a GTK\n * on managed (station) networks, this is true anyway. If the driver\n * calls this function from the resume callback and subsequently uses\n * the return code 1 to reconfigure the device, this key will be part\n * of the reconfiguration.\n *\n * Note that the driver should also call ieee80211_set_key_rx_seq()\n * for the new key for each TID to set up sequence counters properly.\n *\n * IMPORTANT: If this replaces a key that is present in the hardware,\n * then it will attempt to remove it during this call. In many cases\n * this isn't what you want, so call ieee80211_remove_key() first for\n * the key that's being replaced.\n */\nstruct ieee80211_key_conf *\nieee80211_gtk_rekey_add(struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_key_conf *keyconf);\n\n/**\n * ieee80211_gtk_rekey_notify - notify userspace supplicant of rekeying\n * @vif: virtual interface the rekeying was done on\n * @bssid: The BSSID of the AP, for checking association\n * @replay_ctr: the new replay counter after GTK rekeying\n * @gfp: allocation flags\n */\nvoid ieee80211_gtk_rekey_notify(struct ieee80211_vif *vif, const u8 *bssid,\n\t\t\t\tconst u8 *replay_ctr, gfp_t gfp);\n\n/**\n * ieee80211_wake_queue - wake specific queue\n * @hw: pointer as obtained from ieee80211_alloc_hw().\n * @queue: queue number (counted from zero).\n *\n * Drivers should use this function instead of netif_wake_queue.\n */\nvoid ieee80211_wake_queue(struct ieee80211_hw *hw, int queue);\n\n/**\n * ieee80211_stop_queue - stop specific queue\n * @hw: pointer as obtained from ieee80211_alloc_hw().\n * @queue: queue number (counted from zero).\n *\n * Drivers should use this function instead of netif_stop_queue.\n */\nvoid ieee80211_stop_queue(struct ieee80211_hw *hw, int queue);\n\n/**\n * ieee80211_queue_stopped - test status of the queue\n * @hw: pointer as obtained from ieee80211_alloc_hw().\n * @queue: queue number (counted from zero).\n *\n * Drivers should use this function instead of netif_stop_queue.\n *\n * Return: %true if the queue is stopped. %false otherwise.\n */\n\nint ieee80211_queue_stopped(struct ieee80211_hw *hw, int queue);\n\n/**\n * ieee80211_stop_queues - stop all queues\n * @hw: pointer as obtained from ieee80211_alloc_hw().\n *\n * Drivers should use this function instead of netif_stop_queue.\n */\nvoid ieee80211_stop_queues(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_wake_queues - wake all queues\n * @hw: pointer as obtained from ieee80211_alloc_hw().\n *\n * Drivers should use this function instead of netif_wake_queue.\n */\nvoid ieee80211_wake_queues(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_scan_completed - completed hardware scan\n *\n * When hardware scan offload is used (i.e. the hw_scan() callback is\n * assigned) this function needs to be called by the driver to notify\n * mac80211 that the scan finished. This function can be called from\n * any context, including hardirq context.\n *\n * @hw: the hardware that finished the scan\n * @info: information about the completed scan\n */\nvoid ieee80211_scan_completed(struct ieee80211_hw *hw,\n\t\t\t      struct cfg80211_scan_info *info);\n\n/**\n * ieee80211_sched_scan_results - got results from scheduled scan\n *\n * When a scheduled scan is running, this function needs to be called by the\n * driver whenever there are new scan results available.\n *\n * @hw: the hardware that is performing scheduled scans\n */\nvoid ieee80211_sched_scan_results(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_sched_scan_stopped - inform that the scheduled scan has stopped\n *\n * When a scheduled scan is running, this function can be called by\n * the driver if it needs to stop the scan to perform another task.\n * Usual scenarios are drivers that cannot continue the scheduled scan\n * while associating, for instance.\n *\n * @hw: the hardware that is performing scheduled scans\n */\nvoid ieee80211_sched_scan_stopped(struct ieee80211_hw *hw);\n\n/**\n * enum ieee80211_interface_iteration_flags - interface iteration flags\n * @IEEE80211_IFACE_ITER_NORMAL: Iterate over all interfaces that have\n *\tbeen added to the driver; However, note that during hardware\n *\treconfiguration (after restart_hw) it will iterate over a new\n *\tinterface and over all the existing interfaces even if they\n *\thaven't been re-added to the driver yet.\n * @IEEE80211_IFACE_ITER_RESUME_ALL: During resume, iterate over all\n *\tinterfaces, even if they haven't been re-added to the driver yet.\n * @IEEE80211_IFACE_ITER_ACTIVE: Iterate only active interfaces (netdev is up).\n * @IEEE80211_IFACE_SKIP_SDATA_NOT_IN_DRIVER: Skip any interfaces where SDATA\n *\tis not in the driver.  This may fix crashes during firmware recovery\n *\tfor instance.\n */\nenum ieee80211_interface_iteration_flags {\n\tIEEE80211_IFACE_ITER_NORMAL\t= 0,\n\tIEEE80211_IFACE_ITER_RESUME_ALL\t= BIT(0),\n\tIEEE80211_IFACE_ITER_ACTIVE\t= BIT(1),\n\tIEEE80211_IFACE_SKIP_SDATA_NOT_IN_DRIVER\t= BIT(2),\n};\n\n/**\n * ieee80211_iterate_interfaces - iterate interfaces\n *\n * This function iterates over the interfaces associated with a given\n * hardware and calls the callback for them. This includes active as well as\n * inactive interfaces. This function allows the iterator function to sleep.\n * Will iterate over a new interface during add_interface().\n *\n * @hw: the hardware struct of which the interfaces should be iterated over\n * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags\n * @iterator: the iterator function to call\n * @data: first argument of the iterator function\n */\nvoid ieee80211_iterate_interfaces(struct ieee80211_hw *hw, u32 iter_flags,\n\t\t\t\t  void (*iterator)(void *data, u8 *mac,\n\t\t\t\t\t\t   struct ieee80211_vif *vif),\n\t\t\t\t  void *data);\n\n/**\n * ieee80211_iterate_active_interfaces - iterate active interfaces\n *\n * This function iterates over the interfaces associated with a given\n * hardware that are currently active and calls the callback for them.\n * This function allows the iterator function to sleep, when the iterator\n * function is atomic @ieee80211_iterate_active_interfaces_atomic can\n * be used.\n * Does not iterate over a new interface during add_interface().\n *\n * @hw: the hardware struct of which the interfaces should be iterated over\n * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags\n * @iterator: the iterator function to call\n * @data: first argument of the iterator function\n */\nstatic inline void\nieee80211_iterate_active_interfaces(struct ieee80211_hw *hw, u32 iter_flags,\n\t\t\t\t    void (*iterator)(void *data, u8 *mac,\n\t\t\t\t\t\t     struct ieee80211_vif *vif),\n\t\t\t\t    void *data)\n{\n\tieee80211_iterate_interfaces(hw,\n\t\t\t\t     iter_flags | IEEE80211_IFACE_ITER_ACTIVE,\n\t\t\t\t     iterator, data);\n}\n\n/**\n * ieee80211_iterate_active_interfaces_atomic - iterate active interfaces\n *\n * This function iterates over the interfaces associated with a given\n * hardware that are currently active and calls the callback for them.\n * This function requires the iterator callback function to be atomic,\n * if that is not desired, use @ieee80211_iterate_active_interfaces instead.\n * Does not iterate over a new interface during add_interface().\n *\n * @hw: the hardware struct of which the interfaces should be iterated over\n * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags\n * @iterator: the iterator function to call, cannot sleep\n * @data: first argument of the iterator function\n */\nvoid ieee80211_iterate_active_interfaces_atomic(struct ieee80211_hw *hw,\n\t\t\t\t\t\tu32 iter_flags,\n\t\t\t\t\t\tvoid (*iterator)(void *data,\n\t\t\t\t\t\t    u8 *mac,\n\t\t\t\t\t\t    struct ieee80211_vif *vif),\n\t\t\t\t\t\tvoid *data);\n\n/**\n * ieee80211_iterate_active_interfaces_rtnl - iterate active interfaces\n *\n * This function iterates over the interfaces associated with a given\n * hardware that are currently active and calls the callback for them.\n * This version can only be used while holding the RTNL.\n *\n * @hw: the hardware struct of which the interfaces should be iterated over\n * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags\n * @iterator: the iterator function to call, cannot sleep\n * @data: first argument of the iterator function\n */\nvoid ieee80211_iterate_active_interfaces_rtnl(struct ieee80211_hw *hw,\n\t\t\t\t\t      u32 iter_flags,\n\t\t\t\t\t      void (*iterator)(void *data,\n\t\t\t\t\t\tu8 *mac,\n\t\t\t\t\t\tstruct ieee80211_vif *vif),\n\t\t\t\t\t      void *data);\n\n/**\n * ieee80211_iterate_stations_atomic - iterate stations\n *\n * This function iterates over all stations associated with a given\n * hardware that are currently uploaded to the driver and calls the callback\n * function for them.\n * This function requires the iterator callback function to be atomic,\n *\n * @hw: the hardware struct of which the interfaces should be iterated over\n * @iterator: the iterator function to call, cannot sleep\n * @data: first argument of the iterator function\n */\nvoid ieee80211_iterate_stations_atomic(struct ieee80211_hw *hw,\n\t\t\t\t       void (*iterator)(void *data,\n\t\t\t\t\t\tstruct ieee80211_sta *sta),\n\t\t\t\t       void *data);\n/**\n * ieee80211_queue_work - add work onto the mac80211 workqueue\n *\n * Drivers and mac80211 use this to add work onto the mac80211 workqueue.\n * This helper ensures drivers are not queueing work when they should not be.\n *\n * @hw: the hardware struct for the interface we are adding work for\n * @work: the work we want to add onto the mac80211 workqueue\n */\nvoid ieee80211_queue_work(struct ieee80211_hw *hw, struct work_struct *work);\n\n/**\n * ieee80211_queue_delayed_work - add work onto the mac80211 workqueue\n *\n * Drivers and mac80211 use this to queue delayed work onto the mac80211\n * workqueue.\n *\n * @hw: the hardware struct for the interface we are adding work for\n * @dwork: delayable work to queue onto the mac80211 workqueue\n * @delay: number of jiffies to wait before queueing\n */\nvoid ieee80211_queue_delayed_work(struct ieee80211_hw *hw,\n\t\t\t\t  struct delayed_work *dwork,\n\t\t\t\t  unsigned long delay);\n\n/**\n * ieee80211_start_tx_ba_session - Start a tx Block Ack session.\n * @sta: the station for which to start a BA session\n * @tid: the TID to BA on.\n * @timeout: session timeout value (in TUs)\n *\n * Return: success if addBA request was sent, failure otherwise\n *\n * Although mac80211/low level driver/user space application can estimate\n * the need to start aggregation on a certain RA/TID, the session level\n * will be managed by the mac80211.\n */\nint ieee80211_start_tx_ba_session(struct ieee80211_sta *sta, u16 tid,\n\t\t\t\t  u16 timeout);\n\n/**\n * ieee80211_start_tx_ba_cb_irqsafe - low level driver ready to aggregate.\n * @vif: &struct ieee80211_vif pointer from the add_interface callback\n * @ra: receiver address of the BA session recipient.\n * @tid: the TID to BA on.\n *\n * This function must be called by low level driver once it has\n * finished with preparations for the BA session. It can be called\n * from any context.\n */\nvoid ieee80211_start_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,\n\t\t\t\t      u16 tid);\n\n/**\n * ieee80211_stop_tx_ba_session - Stop a Block Ack session.\n * @sta: the station whose BA session to stop\n * @tid: the TID to stop BA.\n *\n * Return: negative error if the TID is invalid, or no aggregation active\n *\n * Although mac80211/low level driver/user space application can estimate\n * the need to stop aggregation on a certain RA/TID, the session level\n * will be managed by the mac80211.\n */\nint ieee80211_stop_tx_ba_session(struct ieee80211_sta *sta, u16 tid);\n\n/**\n * ieee80211_stop_tx_ba_cb_irqsafe - low level driver ready to stop aggregate.\n * @vif: &struct ieee80211_vif pointer from the add_interface callback\n * @ra: receiver address of the BA session recipient.\n * @tid: the desired TID to BA on.\n *\n * This function must be called by low level driver once it has\n * finished with preparations for the BA session tear down. It\n * can be called from any context.\n */\nvoid ieee80211_stop_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,\n\t\t\t\t     u16 tid);\n\n/**\n * ieee80211_find_sta - find a station\n *\n * @vif: virtual interface to look for station on\n * @addr: station's address\n *\n * Return: The station, if found. %NULL otherwise.\n *\n * Note: This function must be called under RCU lock and the\n * resulting pointer is only valid under RCU lock as well.\n */\nstruct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif *vif,\n\t\t\t\t\t const u8 *addr);\n\n/**\n * ieee80211_find_sta_by_ifaddr - find a station on hardware\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @addr: remote station's address\n * @localaddr: local address (vif->sdata->vif.addr). Use NULL for 'any'.\n *\n * Return: The station, if found. %NULL otherwise.\n *\n * Note: This function must be called under RCU lock and the\n * resulting pointer is only valid under RCU lock as well.\n *\n * NOTE: You may pass NULL for localaddr, but then you will just get\n *      the first STA that matches the remote address 'addr'.\n *      We can have multiple STA associated with multiple\n *      logical stations (e.g. consider a station connecting to another\n *      BSSID on the same AP hardware without disconnecting first).\n *      In this case, the result of this method with localaddr NULL\n *      is not reliable.\n *\n * DO NOT USE THIS FUNCTION with localaddr NULL if at all possible.\n */\nstruct ieee80211_sta *ieee80211_find_sta_by_ifaddr(struct ieee80211_hw *hw,\n\t\t\t\t\t       const u8 *addr,\n\t\t\t\t\t       const u8 *localaddr);\n\n/**\n * ieee80211_sta_block_awake - block station from waking up\n * @hw: the hardware\n * @pubsta: the station\n * @block: whether to block or unblock\n *\n * Some devices require that all frames that are on the queues\n * for a specific station that went to sleep are flushed before\n * a poll response or frames after the station woke up can be\n * delivered to that it. Note that such frames must be rejected\n * by the driver as filtered, with the appropriate status flag.\n *\n * This function allows implementing this mode in a race-free\n * manner.\n *\n * To do this, a driver must keep track of the number of frames\n * still enqueued for a specific station. If this number is not\n * zero when the station goes to sleep, the driver must call\n * this function to force mac80211 to consider the station to\n * be asleep regardless of the station's actual state. Once the\n * number of outstanding frames reaches zero, the driver must\n * call this function again to unblock the station. That will\n * cause mac80211 to be able to send ps-poll responses, and if\n * the station queried in the meantime then frames will also\n * be sent out as a result of this. Additionally, the driver\n * will be notified that the station woke up some time after\n * it is unblocked, regardless of whether the station actually\n * woke up while blocked or not.\n */\nvoid ieee80211_sta_block_awake(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_sta *pubsta, bool block);\n\n/**\n * ieee80211_sta_eosp - notify mac80211 about end of SP\n * @pubsta: the station\n *\n * When a device transmits frames in a way that it can't tell\n * mac80211 in the TX status about the EOSP, it must clear the\n * %IEEE80211_TX_STATUS_EOSP bit and call this function instead.\n * This applies for PS-Poll as well as uAPSD.\n *\n * Note that just like with _tx_status() and _rx() drivers must\n * not mix calls to irqsafe/non-irqsafe versions, this function\n * must not be mixed with those either. Use the all irqsafe, or\n * all non-irqsafe, don't mix!\n *\n * NB: the _irqsafe version of this function doesn't exist, no\n *     driver needs it right now. Don't call this function if\n *     you'd need the _irqsafe version, look at the git history\n *     and restore the _irqsafe version!\n */\nvoid ieee80211_sta_eosp(struct ieee80211_sta *pubsta);\n\n/**\n * ieee80211_send_eosp_nullfunc - ask mac80211 to send NDP with EOSP\n * @pubsta: the station\n * @tid: the tid of the NDP\n *\n * Sometimes the device understands that it needs to close\n * the Service Period unexpectedly. This can happen when\n * sending frames that are filling holes in the BA window.\n * In this case, the device can ask mac80211 to send a\n * Nullfunc frame with EOSP set. When that happens, the\n * driver must have called ieee80211_sta_set_buffered() to\n * let mac80211 know that there are no buffered frames any\n * more, otherwise mac80211 will get the more_data bit wrong.\n * The low level driver must have made sure that the frame\n * will be sent despite the station being in power-save.\n * Mac80211 won't call allow_buffered_frames().\n * Note that calling this function, doesn't exempt the driver\n * from closing the EOSP properly, it will still have to call\n * ieee80211_sta_eosp when the NDP is sent.\n */\nvoid ieee80211_send_eosp_nullfunc(struct ieee80211_sta *pubsta, int tid);\n\n/**\n * ieee80211_sta_register_airtime - register airtime usage for a sta/tid\n *\n * Register airtime usage for a given sta on a given tid. The driver must call\n * this function to notify mac80211 that a station used a certain amount of\n * airtime. This information will be used by the TXQ scheduler to schedule\n * stations in a way that ensures airtime fairness.\n *\n * The reported airtime should as a minimum include all time that is spent\n * transmitting to the remote station, including overhead and padding, but not\n * including time spent waiting for a TXOP. If the time is not reported by the\n * hardware it can in some cases be calculated from the rate and known frame\n * composition. When possible, the time should include any failed transmission\n * attempts.\n *\n * The driver can either call this function synchronously for every packet or\n * aggregate, or asynchronously as airtime usage information becomes available.\n * TX and RX airtime can be reported together, or separately by setting one of\n * them to 0.\n *\n * @pubsta: the station\n * @tid: the TID to register airtime for\n * @tx_airtime: airtime used during TX (in usec)\n * @rx_airtime: airtime used during RX (in usec)\n */\nvoid ieee80211_sta_register_airtime(struct ieee80211_sta *pubsta, u8 tid,\n\t\t\t\t    u32 tx_airtime, u32 rx_airtime);\n\n/**\n * ieee80211_txq_airtime_check - check if a txq can send frame to device\n *\n * @hw: pointer obtained from ieee80211_alloc_hw()\n * @txq: pointer obtained from station or virtual interface\n *\n * Return true if the AQL's airtime limit has not been reached and the txq can\n * continue to send more packets to the device. Otherwise return false.\n */\nbool\nieee80211_txq_airtime_check(struct ieee80211_hw *hw, struct ieee80211_txq *txq);\n\n/**\n * ieee80211_iter_keys - iterate keys programmed into the device\n * @hw: pointer obtained from ieee80211_alloc_hw()\n * @vif: virtual interface to iterate, may be %NULL for all\n * @iter: iterator function that will be called for each key\n * @iter_data: custom data to pass to the iterator function\n *\n * This function can be used to iterate all the keys known to\n * mac80211, even those that weren't previously programmed into\n * the device. This is intended for use in WoWLAN if the device\n * needs reprogramming of the keys during suspend. Note that due\n * to locking reasons, it is also only safe to call this at few\n * spots since it must hold the RTNL and be able to sleep.\n *\n * The order in which the keys are iterated matches the order\n * in which they were originally installed and handed to the\n * set_key callback.\n */\nvoid ieee80211_iter_keys(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t void (*iter)(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      struct ieee80211_key_conf *key,\n\t\t\t\t      void *data),\n\t\t\t void *iter_data);\n\n/**\n * ieee80211_iter_keys_rcu - iterate keys programmed into the device\n * @hw: pointer obtained from ieee80211_alloc_hw()\n * @vif: virtual interface to iterate, may be %NULL for all\n * @iter: iterator function that will be called for each key\n * @iter_data: custom data to pass to the iterator function\n *\n * This function can be used to iterate all the keys known to\n * mac80211, even those that weren't previously programmed into\n * the device. Note that due to locking reasons, keys of station\n * in removal process will be skipped.\n *\n * This function requires being called in an RCU critical section,\n * and thus iter must be atomic.\n */\nvoid ieee80211_iter_keys_rcu(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     void (*iter)(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t\t  struct ieee80211_key_conf *key,\n\t\t\t\t\t  void *data),\n\t\t\t     void *iter_data);\n\n/**\n * ieee80211_iter_chan_contexts_atomic - iterate channel contexts\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @iter: iterator function\n * @iter_data: data passed to iterator function\n *\n * Iterate all active channel contexts. This function is atomic and\n * doesn't acquire any locks internally that might be held in other\n * places while calling into the driver.\n *\n * The iterator will not find a context that's being added (during\n * the driver callback to add it) but will find it while it's being\n * removed.\n *\n * Note that during hardware restart, all contexts that existed\n * before the restart are considered already present so will be\n * found while iterating, whether they've been re-added already\n * or not.\n */\nvoid ieee80211_iter_chan_contexts_atomic(\n\tstruct ieee80211_hw *hw,\n\tvoid (*iter)(struct ieee80211_hw *hw,\n\t\t     struct ieee80211_chanctx_conf *chanctx_conf,\n\t\t     void *data),\n\tvoid *iter_data);\n\n/**\n * ieee80211_ap_probereq_get - retrieve a Probe Request template\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * Creates a Probe Request template which can, for example, be uploaded to\n * hardware. The template is filled with bssid, ssid and supported rate\n * information. This function must only be called from within the\n * .bss_info_changed callback function and only in managed mode. The function\n * is only useful when the interface is associated, otherwise it will return\n * %NULL.\n *\n * Return: The Probe Request template. %NULL on error.\n */\nstruct sk_buff *ieee80211_ap_probereq_get(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif);\n\n/**\n * ieee80211_beacon_loss - inform hardware does not receive beacons\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * When beacon filtering is enabled with %IEEE80211_VIF_BEACON_FILTER and\n * %IEEE80211_CONF_PS is set, the driver needs to inform whenever the\n * hardware is not receiving beacons with this function.\n */\nvoid ieee80211_beacon_loss(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_connection_loss - inform hardware has lost connection to the AP\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * When beacon filtering is enabled with %IEEE80211_VIF_BEACON_FILTER, and\n * %IEEE80211_CONF_PS and %IEEE80211_HW_CONNECTION_MONITOR are set, the driver\n * needs to inform if the connection to the AP has been lost.\n * The function may also be called if the connection needs to be terminated\n * for some other reason, even if %IEEE80211_HW_CONNECTION_MONITOR isn't set.\n *\n * This function will cause immediate change to disassociated state,\n * without connection recovery attempts.\n */\nvoid ieee80211_connection_loss(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_resume_disconnect - disconnect from AP after resume\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * Instructs mac80211 to disconnect from the AP after resume.\n * Drivers can use this after WoWLAN if they know that the\n * connection cannot be kept up, for example because keys were\n * used while the device was asleep but the replay counters or\n * similar cannot be retrieved from the device during resume.\n *\n * Note that due to implementation issues, if the driver uses\n * the reconfiguration functionality during resume the interface\n * will still be added as associated first during resume and then\n * disconnect normally later.\n *\n * This function can only be called from the resume callback and\n * the driver must not be holding any of its own locks while it\n * calls this function, or at least not any locks it needs in the\n * key configuration paths (if it supports HW crypto).\n */\nvoid ieee80211_resume_disconnect(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_cqm_rssi_notify - inform a configured connection quality monitoring\n *\trssi threshold triggered\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @rssi_event: the RSSI trigger event type\n * @rssi_level: new RSSI level value or 0 if not available\n * @gfp: context flags\n *\n * When the %IEEE80211_VIF_SUPPORTS_CQM_RSSI is set, and a connection quality\n * monitoring is configured with an rssi threshold, the driver will inform\n * whenever the rssi level reaches the threshold.\n */\nvoid ieee80211_cqm_rssi_notify(struct ieee80211_vif *vif,\n\t\t\t       enum nl80211_cqm_rssi_threshold_event rssi_event,\n\t\t\t       s32 rssi_level,\n\t\t\t       gfp_t gfp);\n\n/**\n * ieee80211_cqm_beacon_loss_notify - inform CQM of beacon loss\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @gfp: context flags\n */\nvoid ieee80211_cqm_beacon_loss_notify(struct ieee80211_vif *vif, gfp_t gfp);\n\n/**\n * ieee80211_radar_detected - inform that a radar was detected\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n */\nvoid ieee80211_radar_detected(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_chswitch_done - Complete channel switch process\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @success: make the channel switch successful or not\n *\n * Complete the channel switch post-process: set the new operational channel\n * and wake up the suspended queues.\n */\nvoid ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success);\n\n/**\n * ieee80211_request_smps - request SM PS transition\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @smps_mode: new SM PS mode\n *\n * This allows the driver to request an SM PS transition in managed\n * mode. This is useful when the driver has more information than\n * the stack about possible interference, for example by bluetooth.\n */\nvoid ieee80211_request_smps(struct ieee80211_vif *vif,\n\t\t\t    enum ieee80211_smps_mode smps_mode);\n\n/**\n * ieee80211_ready_on_channel - notification of remain-on-channel start\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n */\nvoid ieee80211_ready_on_channel(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_remain_on_channel_expired - remain_on_channel duration expired\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n */\nvoid ieee80211_remain_on_channel_expired(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_stop_rx_ba_session - callback to stop existing BA sessions\n *\n * in order not to harm the system performance and user experience, the device\n * may request not to allow any rx ba session and tear down existing rx ba\n * sessions based on system constraints such as periodic BT activity that needs\n * to limit wlan activity (eg.sco or a2dp).\"\n * in such cases, the intention is to limit the duration of the rx ppdu and\n * therefore prevent the peer device to use a-mpdu aggregation.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @ba_rx_bitmap: Bit map of open rx ba per tid\n * @addr: & to bssid mac address\n */\nvoid ieee80211_stop_rx_ba_session(struct ieee80211_vif *vif, u16 ba_rx_bitmap,\n\t\t\t\t  const u8 *addr);\n\n/**\n * ieee80211_mark_rx_ba_filtered_frames - move RX BA window and mark filtered\n * @pubsta: station struct\n * @tid: the session's TID\n * @ssn: starting sequence number of the bitmap, all frames before this are\n *\tassumed to be out of the window after the call\n * @filtered: bitmap of filtered frames, BIT(0) is the @ssn entry etc.\n * @received_mpdus: number of received mpdus in firmware\n *\n * This function moves the BA window and releases all frames before @ssn, and\n * marks frames marked in the bitmap as having been filtered. Afterwards, it\n * checks if any frames in the window starting from @ssn can now be released\n * (in case they were only waiting for frames that were filtered.)\n */\nvoid ieee80211_mark_rx_ba_filtered_frames(struct ieee80211_sta *pubsta, u8 tid,\n\t\t\t\t\t  u16 ssn, u64 filtered,\n\t\t\t\t\t  u16 received_mpdus);\n\n/**\n * ieee80211_send_bar - send a BlockAckReq frame\n *\n * can be used to flush pending frames from the peer's aggregation reorder\n * buffer.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @ra: the peer's destination address\n * @tid: the TID of the aggregation session\n * @ssn: the new starting sequence number for the receiver\n */\nvoid ieee80211_send_bar(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn);\n\n/**\n * ieee80211_manage_rx_ba_offl - helper to queue an RX BA work\n * @vif: &struct ieee80211_vif pointer from the add_interface callback\n * @addr: station mac address\n * @tid: the rx tid\n */\nvoid ieee80211_manage_rx_ba_offl(struct ieee80211_vif *vif, const u8 *addr,\n\t\t\t\t unsigned int tid);\n\n/**\n * ieee80211_start_rx_ba_session_offl - start a Rx BA session\n *\n * Some device drivers may offload part of the Rx aggregation flow including\n * AddBa/DelBa negotiation but may otherwise be incapable of full Rx\n * reordering.\n *\n * Create structures responsible for reordering so device drivers may call here\n * when they complete AddBa negotiation.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback\n * @addr: station mac address\n * @tid: the rx tid\n */\nstatic inline void ieee80211_start_rx_ba_session_offl(struct ieee80211_vif *vif,\n\t\t\t\t\t\t      const u8 *addr, u16 tid)\n{\n\tif (WARN_ON(tid >= IEEE80211_NUM_TIDS))\n\t\treturn;\n\tieee80211_manage_rx_ba_offl(vif, addr, tid);\n}\n\n/**\n * ieee80211_stop_rx_ba_session_offl - stop a Rx BA session\n *\n * Some device drivers may offload part of the Rx aggregation flow including\n * AddBa/DelBa negotiation but may otherwise be incapable of full Rx\n * reordering.\n *\n * Destroy structures responsible for reordering so device drivers may call here\n * when they complete DelBa negotiation.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback\n * @addr: station mac address\n * @tid: the rx tid\n */\nstatic inline void ieee80211_stop_rx_ba_session_offl(struct ieee80211_vif *vif,\n\t\t\t\t\t\t     const u8 *addr, u16 tid)\n{\n\tif (WARN_ON(tid >= IEEE80211_NUM_TIDS))\n\t\treturn;\n\tieee80211_manage_rx_ba_offl(vif, addr, tid + IEEE80211_NUM_TIDS);\n}\n\n/**\n * ieee80211_rx_ba_timer_expired - stop a Rx BA session due to timeout\n *\n * Some device drivers do not offload AddBa/DelBa negotiation, but handle rx\n * buffer reording internally, and therefore also handle the session timer.\n *\n * Trigger the timeout flow, which sends a DelBa.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback\n * @addr: station mac address\n * @tid: the rx tid\n */\nvoid ieee80211_rx_ba_timer_expired(struct ieee80211_vif *vif,\n\t\t\t\t   const u8 *addr, unsigned int tid);\n\n/* Rate control API */\n\n/**\n * struct ieee80211_tx_rate_control - rate control information for/from RC algo\n *\n * @hw: The hardware the algorithm is invoked for.\n * @sband: The band this frame is being transmitted on.\n * @bss_conf: the current BSS configuration\n * @skb: the skb that will be transmitted, the control information in it needs\n *\tto be filled in\n * @reported_rate: The rate control algorithm can fill this in to indicate\n *\twhich rate should be reported to userspace as the current rate and\n *\tused for rate calculations in the mesh network.\n * @rts: whether RTS will be used for this frame because it is longer than the\n *\tRTS threshold\n * @short_preamble: whether mac80211 will request short-preamble transmission\n *\tif the selected rate supports it\n * @rate_idx_mask: user-requested (legacy) rate mask\n * @rate_idx_mcs_mask: user-requested MCS rate mask (NULL if not in use)\n * @bss: whether this frame is sent out in AP or IBSS mode\n */\nstruct ieee80211_tx_rate_control {\n\tstruct ieee80211_hw *hw;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_bss_conf *bss_conf;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_rate reported_rate;\n\tbool rts, short_preamble;\n\tu32 rate_idx_mask;\n\tu8 *rate_idx_mcs_mask;\n\tbool bss;\n};\n\n/**\n * enum rate_control_capabilities - rate control capabilities\n */\nenum rate_control_capabilities {\n\t/**\n\t * @RATE_CTRL_CAPA_VHT_EXT_NSS_BW:\n\t * Support for extended NSS BW support (dot11VHTExtendedNSSCapable)\n\t * Note that this is only looked at if the minimum number of chains\n\t * that the AP uses is < the number of TX chains the hardware has,\n\t * otherwise the NSS difference doesn't bother us.\n\t */\n\tRATE_CTRL_CAPA_VHT_EXT_NSS_BW = BIT(0),\n};\n\nstruct rate_control_ops {\n\tunsigned long capa;\n\tconst char *name;\n\tvoid *(*alloc)(struct ieee80211_hw *hw);\n\tvoid (*add_debugfs)(struct ieee80211_hw *hw, void *priv,\n\t\t\t    struct dentry *debugfsdir);\n\tvoid (*free)(void *priv);\n\n\tvoid *(*alloc_sta)(void *priv, struct ieee80211_sta *sta, gfp_t gfp);\n\tvoid (*rate_init)(void *priv, struct ieee80211_supported_band *sband,\n\t\t\t  struct cfg80211_chan_def *chandef,\n\t\t\t  struct ieee80211_sta *sta, void *priv_sta);\n\tvoid (*rate_update)(void *priv, struct ieee80211_supported_band *sband,\n\t\t\t    struct cfg80211_chan_def *chandef,\n\t\t\t    struct ieee80211_sta *sta, void *priv_sta,\n\t\t\t    u32 changed);\n\tvoid (*free_sta)(void *priv, struct ieee80211_sta *sta,\n\t\t\t void *priv_sta);\n\n\tvoid (*tx_status_ext)(void *priv,\n\t\t\t      struct ieee80211_supported_band *sband,\n\t\t\t      void *priv_sta, struct ieee80211_tx_status *st);\n\tvoid (*tx_status)(void *priv, struct ieee80211_supported_band *sband,\n\t\t\t  struct ieee80211_sta *sta, void *priv_sta,\n\t\t\t  struct sk_buff *skb);\n\tvoid (*get_rate)(void *priv, struct ieee80211_sta *sta, void *priv_sta,\n\t\t\t struct ieee80211_tx_rate_control *txrc);\n\n\tvoid (*add_sta_debugfs)(void *priv, void *priv_sta,\n\t\t\t\tstruct dentry *dir);\n\n\tu32 (*get_expected_throughput)(void *priv_sta);\n};\n\nstatic inline int rate_supported(struct ieee80211_sta *sta,\n\t\t\t\t enum nl80211_band band,\n\t\t\t\t int index)\n{\n\treturn (sta == NULL || sta->supp_rates[band] & BIT(index));\n}\n\nstatic inline s8\nrate_lowest_index(struct ieee80211_supported_band *sband,\n\t\t  struct ieee80211_sta *sta)\n{\n\tint i;\n\n\tfor (i = 0; i < sband->n_bitrates; i++)\n\t\tif (rate_supported(sta, sband->band, i))\n\t\t\treturn i;\n\n\t/* warn when we cannot find a rate. */\n\tWARN_ON_ONCE(1);\n\n\t/* and return 0 (the lowest index) */\n\treturn 0;\n}\n\nstatic inline\nbool rate_usable_index_exists(struct ieee80211_supported_band *sband,\n\t\t\t      struct ieee80211_sta *sta)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < sband->n_bitrates; i++)\n\t\tif (rate_supported(sta, sband->band, i))\n\t\t\treturn true;\n\treturn false;\n}\n\n/**\n * rate_control_set_rates - pass the sta rate selection to mac80211/driver\n *\n * When not doing a rate control probe to test rates, rate control should pass\n * its rate selection to mac80211. If the driver supports receiving a station\n * rate table, it will use it to ensure that frames are always sent based on\n * the most recent rate control module decision.\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @pubsta: &struct ieee80211_sta pointer to the target destination.\n * @rates: new tx rate set to be used for this station.\n */\nint rate_control_set_rates(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_sta *pubsta,\n\t\t\t   struct ieee80211_sta_rates *rates);\n\nint ieee80211_rate_control_register(const struct rate_control_ops *ops);\nvoid ieee80211_rate_control_unregister(const struct rate_control_ops *ops);\n\nstatic inline bool\nconf_is_ht20(struct ieee80211_conf *conf)\n{\n\treturn conf->chandef.width == NL80211_CHAN_WIDTH_20;\n}\n\nstatic inline bool\nconf_is_ht40_minus(struct ieee80211_conf *conf)\n{\n\treturn conf->chandef.width == NL80211_CHAN_WIDTH_40 &&\n\t       conf->chandef.center_freq1 < conf->chandef.chan->center_freq;\n}\n\nstatic inline bool\nconf_is_ht40_plus(struct ieee80211_conf *conf)\n{\n\treturn conf->chandef.width == NL80211_CHAN_WIDTH_40 &&\n\t       conf->chandef.center_freq1 > conf->chandef.chan->center_freq;\n}\n\nstatic inline bool\nconf_is_ht40(struct ieee80211_conf *conf)\n{\n\treturn conf->chandef.width == NL80211_CHAN_WIDTH_40;\n}\n\nstatic inline bool\nconf_is_ht(struct ieee80211_conf *conf)\n{\n\treturn (conf->chandef.width != NL80211_CHAN_WIDTH_5) &&\n\t\t(conf->chandef.width != NL80211_CHAN_WIDTH_10) &&\n\t\t(conf->chandef.width != NL80211_CHAN_WIDTH_20_NOHT);\n}\n\nstatic inline enum nl80211_iftype\nieee80211_iftype_p2p(enum nl80211_iftype type, bool p2p)\n{\n\tif (p2p) {\n\t\tswitch (type) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\treturn NL80211_IFTYPE_P2P_CLIENT;\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\treturn NL80211_IFTYPE_P2P_GO;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn type;\n}\n\nstatic inline enum nl80211_iftype\nieee80211_vif_type_p2p(struct ieee80211_vif *vif)\n{\n\treturn ieee80211_iftype_p2p(vif->type, vif->p2p);\n}\n\n/**\n * ieee80211_update_mu_groups - set the VHT MU-MIMO groud data\n *\n * @vif: the specified virtual interface\n * @membership: 64 bits array - a bit is set if station is member of the group\n * @position: 2 bits per group id indicating the position in the group\n *\n * Note: This function assumes that the given vif is valid and the position and\n * membership data is of the correct size and are in the same byte order as the\n * matching GroupId management frame.\n * Calls to this function need to be serialized with RX path.\n */\nvoid ieee80211_update_mu_groups(struct ieee80211_vif *vif,\n\t\t\t\tconst u8 *membership, const u8 *position);\n\nvoid ieee80211_enable_rssi_reports(struct ieee80211_vif *vif,\n\t\t\t\t   int rssi_min_thold,\n\t\t\t\t   int rssi_max_thold);\n\nvoid ieee80211_disable_rssi_reports(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_ave_rssi - report the average RSSI for the specified interface\n *\n * @vif: the specified virtual interface\n *\n * Note: This function assumes that the given vif is valid.\n *\n * Return: The average RSSI value for the requested interface, or 0 if not\n * applicable.\n */\nint ieee80211_ave_rssi(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_report_wowlan_wakeup - report WoWLAN wakeup\n * @vif: virtual interface\n * @wakeup: wakeup reason(s)\n * @gfp: allocation flags\n *\n * See cfg80211_report_wowlan_wakeup().\n */\nvoid ieee80211_report_wowlan_wakeup(struct ieee80211_vif *vif,\n\t\t\t\t    struct cfg80211_wowlan_wakeup *wakeup,\n\t\t\t\t    gfp_t gfp);\n\n/**\n * ieee80211_tx_prepare_skb - prepare an 802.11 skb for transmission\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @vif: virtual interface\n * @skb: frame to be sent from within the driver\n * @band: the band to transmit on\n * @sta: optional pointer to get the station to send the frame to\n *\n * Note: must be called under RCU lock\n */\nbool ieee80211_tx_prepare_skb(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif, struct sk_buff *skb,\n\t\t\t      int band, struct ieee80211_sta **sta);\n\n/**\n * Sanity-check and parse the radiotap header of injected frames\n * @skb: packet injected by userspace\n * @dev: the &struct device of this 802.11 device\n */\nbool ieee80211_parse_tx_radiotap(struct sk_buff *skb,\n\t\t\t\t struct net_device *dev);\n\n/**\n * struct ieee80211_noa_data - holds temporary data for tracking P2P NoA state\n *\n * @next_tsf: TSF timestamp of the next absent state change\n * @has_next_tsf: next absent state change event pending\n *\n * @absent: descriptor bitmask, set if GO is currently absent\n *\n * private:\n *\n * @count: count fields from the NoA descriptors\n * @desc: adjusted data from the NoA\n */\nstruct ieee80211_noa_data {\n\tu32 next_tsf;\n\tbool has_next_tsf;\n\n\tu8 absent;\n\n\tu8 count[IEEE80211_P2P_NOA_DESC_MAX];\n\tstruct {\n\t\tu32 start;\n\t\tu32 duration;\n\t\tu32 interval;\n\t} desc[IEEE80211_P2P_NOA_DESC_MAX];\n};\n\n/**\n * ieee80211_parse_p2p_noa - initialize NoA tracking data from P2P IE\n *\n * @attr: P2P NoA IE\n * @data: NoA tracking data\n * @tsf: current TSF timestamp\n *\n * Return: number of successfully parsed descriptors\n */\nint ieee80211_parse_p2p_noa(const struct ieee80211_p2p_noa_attr *attr,\n\t\t\t    struct ieee80211_noa_data *data, u32 tsf);\n\n/**\n * ieee80211_update_p2p_noa - get next pending P2P GO absent state change\n *\n * @data: NoA tracking data\n * @tsf: current TSF timestamp\n */\nvoid ieee80211_update_p2p_noa(struct ieee80211_noa_data *data, u32 tsf);\n\n/**\n * ieee80211_tdls_oper - request userspace to perform a TDLS operation\n * @vif: virtual interface\n * @peer: the peer's destination address\n * @oper: the requested TDLS operation\n * @reason_code: reason code for the operation, valid for TDLS teardown\n * @gfp: allocation flags\n *\n * See cfg80211_tdls_oper_request().\n */\nvoid ieee80211_tdls_oper_request(struct ieee80211_vif *vif, const u8 *peer,\n\t\t\t\t enum nl80211_tdls_operation oper,\n\t\t\t\t u16 reason_code, gfp_t gfp);\n\n/**\n * ieee80211_reserve_tid - request to reserve a specific TID\n *\n * There is sometimes a need (such as in TDLS) for blocking the driver from\n * using a specific TID so that the FW can use it for certain operations such\n * as sending PTI requests. To make sure that the driver doesn't use that TID,\n * this function must be called as it flushes out packets on this TID and marks\n * it as blocked, so that any transmit for the station on this TID will be\n * redirected to the alternative TID in the same AC.\n *\n * Note that this function blocks and may call back into the driver, so it\n * should be called without driver locks held. Also note this function should\n * only be called from the driver's @sta_state callback.\n *\n * @sta: the station to reserve the TID for\n * @tid: the TID to reserve\n *\n * Returns: 0 on success, else on failure\n */\nint ieee80211_reserve_tid(struct ieee80211_sta *sta, u8 tid);\n\n/**\n * ieee80211_unreserve_tid - request to unreserve a specific TID\n *\n * Once there is no longer any need for reserving a certain TID, this function\n * should be called, and no longer will packets have their TID modified for\n * preventing use of this TID in the driver.\n *\n * Note that this function blocks and acquires a lock, so it should be called\n * without driver locks held. Also note this function should only be called\n * from the driver's @sta_state callback.\n *\n * @sta: the station\n * @tid: the TID to unreserve\n */\nvoid ieee80211_unreserve_tid(struct ieee80211_sta *sta, u8 tid);\n\n/**\n * ieee80211_tx_dequeue - dequeue a packet from a software tx queue\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @txq: pointer obtained from station or virtual interface, or from\n *\tieee80211_next_txq()\n *\n * Returns the skb if successful, %NULL if no frame was available.\n *\n * Note that this must be called in an rcu_read_lock() critical section,\n * which can only be released after the SKB was handled. Some pointers in\n * skb->cb, e.g. the key pointer, are protected by RCU and thus the\n * critical section must persist not just for the duration of this call\n * but for the duration of the frame handling.\n * However, also note that while in the wake_tx_queue() method,\n * rcu_read_lock() is already held.\n *\n * softirqs must also be disabled when this function is called.\n * In process context, use ieee80211_tx_dequeue_ni() instead.\n */\nstruct sk_buff *ieee80211_tx_dequeue(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_txq *txq);\n\n/**\n * ieee80211_tx_dequeue_ni - dequeue a packet from a software tx queue\n * (in process context)\n *\n * Like ieee80211_tx_dequeue() but can be called in process context\n * (internally disables bottom halves).\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @txq: pointer obtained from station or virtual interface, or from\n *\tieee80211_next_txq()\n */\nstatic inline struct sk_buff *ieee80211_tx_dequeue_ni(struct ieee80211_hw *hw,\n\t\t\t\t\t\t      struct ieee80211_txq *txq)\n{\n\tstruct sk_buff *skb;\n\n\tlocal_bh_disable();\n\tskb = ieee80211_tx_dequeue(hw, txq);\n\tlocal_bh_enable();\n\n\treturn skb;\n}\n\n/**\n * ieee80211_next_txq - get next tx queue to pull packets from\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @ac: AC number to return packets from.\n *\n * Returns the next txq if successful, %NULL if no queue is eligible. If a txq\n * is returned, it should be returned with ieee80211_return_txq() after the\n * driver has finished scheduling it.\n */\nstruct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac);\n\n/**\n * ieee80211_txq_schedule_start - start new scheduling round for TXQs\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @ac: AC number to acquire locks for\n *\n * Should be called before ieee80211_next_txq() or ieee80211_return_txq().\n * The driver must not call multiple TXQ scheduling rounds concurrently.\n */\nvoid ieee80211_txq_schedule_start(struct ieee80211_hw *hw, u8 ac);\n\n/* (deprecated) */\nstatic inline void ieee80211_txq_schedule_end(struct ieee80211_hw *hw, u8 ac)\n{\n}\n\nvoid __ieee80211_schedule_txq(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_txq *txq, bool force);\n\n/**\n * ieee80211_schedule_txq - schedule a TXQ for transmission\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @txq: pointer obtained from station or virtual interface\n *\n * Schedules a TXQ for transmission if it is not already scheduled,\n * even if mac80211 does not have any packets buffered.\n *\n * The driver may call this function if it has buffered packets for\n * this TXQ internally.\n */\nstatic inline void\nieee80211_schedule_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq)\n{\n\t__ieee80211_schedule_txq(hw, txq, true);\n}\n\n/**\n * ieee80211_return_txq - return a TXQ previously acquired by ieee80211_next_txq()\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @txq: pointer obtained from station or virtual interface\n * @force: schedule txq even if mac80211 does not have any buffered packets.\n *\n * The driver may set force=true if it has buffered packets for this TXQ\n * internally.\n */\nstatic inline void\nieee80211_return_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq,\n\t\t     bool force)\n{\n\t__ieee80211_schedule_txq(hw, txq, force);\n}\n\n/**\n * ieee80211_txq_may_transmit - check whether TXQ is allowed to transmit\n *\n * This function is used to check whether given txq is allowed to transmit by\n * the airtime scheduler, and can be used by drivers to access the airtime\n * fairness accounting without going using the scheduling order enfored by\n * next_txq().\n *\n * Returns %true if the airtime scheduler thinks the TXQ should be allowed to\n * transmit, and %false if it should be throttled. This function can also have\n * the side effect of rotating the TXQ in the scheduler rotation, which will\n * eventually bring the deficit to positive and allow the station to transmit\n * again.\n *\n * The API ieee80211_txq_may_transmit() also ensures that TXQ list will be\n * aligned against driver's own round-robin scheduler list. i.e it rotates\n * the TXQ list till it makes the requested node becomes the first entry\n * in TXQ list. Thus both the TXQ list and driver's list are in sync. If this\n * function returns %true, the driver is expected to schedule packets\n * for transmission, and then return the TXQ through ieee80211_return_txq().\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @txq: pointer obtained from station or virtual interface\n */\nbool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_txq *txq);\n\n/**\n * ieee80211_txq_get_depth - get pending frame/byte count of given txq\n *\n * The values are not guaranteed to be coherent with regard to each other, i.e.\n * txq state can change half-way of this function and the caller may end up\n * with \"new\" frame_cnt and \"old\" byte_cnt or vice-versa.\n *\n * @txq: pointer obtained from station or virtual interface\n * @frame_cnt: pointer to store frame count\n * @byte_cnt: pointer to store byte count\n */\nvoid ieee80211_txq_get_depth(struct ieee80211_txq *txq,\n\t\t\t     unsigned long *frame_cnt,\n\t\t\t     unsigned long *byte_cnt);\n\n/**\n * ieee80211_nan_func_terminated - notify about NAN function termination.\n *\n * This function is used to notify mac80211 about NAN function termination.\n * Note that this function can't be called from hard irq.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @inst_id: the local instance id\n * @reason: termination reason (one of the NL80211_NAN_FUNC_TERM_REASON_*)\n * @gfp: allocation flags\n */\nvoid ieee80211_nan_func_terminated(struct ieee80211_vif *vif,\n\t\t\t\t   u8 inst_id,\n\t\t\t\t   enum nl80211_nan_func_term_reason reason,\n\t\t\t\t   gfp_t gfp);\n\n/**\n * ieee80211_nan_func_match - notify about NAN function match event.\n *\n * This function is used to notify mac80211 about NAN function match. The\n * cookie inside the match struct will be assigned by mac80211.\n * Note that this function can't be called from hard irq.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @match: match event information\n * @gfp: allocation flags\n */\nvoid ieee80211_nan_func_match(struct ieee80211_vif *vif,\n\t\t\t      struct cfg80211_nan_match_params *match,\n\t\t\t      gfp_t gfp);\n\n/**\n * ieee80211_calc_rx_airtime - calculate estimated transmission airtime for RX.\n *\n * This function calculates the estimated airtime usage of a frame based on the\n * rate information in the RX status struct and the frame length.\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @status: &struct ieee80211_rx_status containing the transmission rate\n *          information.\n * @len: frame length in bytes\n */\nu32 ieee80211_calc_rx_airtime(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_rx_status *status,\n\t\t\t      int len);\n\n/**\n * ieee80211_calc_tx_airtime - calculate estimated transmission airtime for TX.\n *\n * This function calculates the estimated airtime usage of a frame based on the\n * rate information in the TX info struct and the frame length.\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @info: &struct ieee80211_tx_info of the frame.\n * @len: frame length in bytes\n */\nu32 ieee80211_calc_tx_airtime(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_tx_info *info,\n\t\t\t      int len);\n/**\n * ieee80211_set_hw_80211_encap - enable hardware encapsulation offloading.\n *\n * This function is used to notify mac80211 that a vif can be passed raw 802.3\n * frames. The driver needs to then handle the 802.11 encapsulation inside the\n * hardware or firmware.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @enable: indicate if the feature should be turned on or off\n */\nbool ieee80211_set_hw_80211_encap(struct ieee80211_vif *vif, bool enable);\n\n/**\n * ieee80211_get_fils_discovery_tmpl - Get FILS discovery template.\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * The driver is responsible for freeing the returned skb.\n *\n * Return: FILS discovery template. %NULL on error.\n */\nstruct sk_buff *ieee80211_get_fils_discovery_tmpl(struct ieee80211_hw *hw,\n\t\t\t\t\t\t  struct ieee80211_vif *vif);\n\n/**\n * ieee80211_get_unsol_bcast_probe_resp_tmpl - Get unsolicited broadcast\n *\tprobe response template.\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * The driver is responsible for freeing the returned skb.\n *\n * Return: Unsolicited broadcast probe response template. %NULL on error.\n */\nstruct sk_buff *\nieee80211_get_unsol_bcast_probe_resp_tmpl(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif);\n#endif /* MAC80211_H */\n"}}, "reports": [{"events": [{"location": {"col": -1, "file": 0, "line": 1116}, "message": "ieee80211_info_get_tx_time_est() set_param_user_data: no type for 'info->priority'"}], "macros": [], "notes": [], "path": "/src/include/net/mac80211.h", "reportHash": "a570542c0949a4a1a8259fc2564653d4", "checkerName": "smatch", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": -1, "file": 0, "line": 1116}, "message": "ieee80211_info_get_tx_time_est() set_param_user_data: no type for 'info->tail'"}], "macros": [], "notes": [], "path": "/src/include/net/mac80211.h", "reportHash": "3ba0fcc30de8d958852d23c26798423f", "checkerName": "smatch", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
