<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c", "content": "/*\n * This file is part of the Chelsio T4 Ethernet driver for Linux.\n *\n * Copyright (c) 2003-2016 Chelsio Communications, Inc. All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bitmap.h>\n#include <linux/crc32.h>\n#include <linux/ctype.h>\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/etherdevice.h>\n#include <linux/firmware.h>\n#include <linux/if.h>\n#include <linux/if_vlan.h>\n#include <linux/init.h>\n#include <linux/log2.h>\n#include <linux/mdio.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mutex.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/aer.h>\n#include <linux/rtnetlink.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/sockios.h>\n#include <linux/vmalloc.h>\n#include <linux/workqueue.h>\n#include <net/neighbour.h>\n#include <net/netevent.h>\n#include <net/addrconf.h>\n#include <net/bonding.h>\n#include <linux/uaccess.h>\n#include <linux/crash_dump.h>\n#include <net/udp_tunnel.h>\n#include <net/xfrm.h>\n#if IS_ENABLED(CONFIG_CHELSIO_TLS_DEVICE)\n#include <net/tls.h>\n#endif\n\n#include \"cxgb4.h\"\n#include \"cxgb4_filter.h\"\n#include \"t4_regs.h\"\n#include \"t4_values.h\"\n#include \"t4_msg.h\"\n#include \"t4fw_api.h\"\n#include \"t4fw_version.h\"\n#include \"cxgb4_dcb.h\"\n#include \"srq.h\"\n#include \"cxgb4_debugfs.h\"\n#include \"clip_tbl.h\"\n#include \"l2t.h\"\n#include \"smt.h\"\n#include \"sched.h\"\n#include \"cxgb4_tc_u32.h\"\n#include \"cxgb4_tc_flower.h\"\n#include \"cxgb4_tc_mqprio.h\"\n#include \"cxgb4_tc_matchall.h\"\n#include \"cxgb4_ptp.h\"\n#include \"cxgb4_cudbg.h\"\n\nchar cxgb4_driver_name[] = KBUILD_MODNAME;\n\n#define DRV_DESC \"Chelsio T4/T5/T6 Network Driver\"\n\n#define DFLT_MSG_ENABLE (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK | \\\n\t\t\t NETIF_MSG_TIMER | NETIF_MSG_IFDOWN | NETIF_MSG_IFUP |\\\n\t\t\t NETIF_MSG_RX_ERR | NETIF_MSG_TX_ERR)\n\n/* Macros needed to support the PCI Device ID Table ...\n */\n#define CH_PCI_DEVICE_ID_TABLE_DEFINE_BEGIN \\\n\tstatic const struct pci_device_id cxgb4_pci_tbl[] = {\n#define CXGB4_UNIFIED_PF 0x4\n\n#define CH_PCI_DEVICE_ID_FUNCTION CXGB4_UNIFIED_PF\n\n/* Include PCI Device IDs for both PF4 and PF0-3 so our PCI probe() routine is\n * called for both.\n */\n#define CH_PCI_DEVICE_ID_FUNCTION2 0x0\n\n#define CH_PCI_ID_TABLE_ENTRY(devid) \\\n\t\t{PCI_VDEVICE(CHELSIO, (devid)), CXGB4_UNIFIED_PF}\n\n#define CH_PCI_DEVICE_ID_TABLE_DEFINE_END \\\n\t\t{ 0, } \\\n\t}\n\n#include \"t4_pci_id_tbl.h\"\n\n#define FW4_FNAME \"cxgb4/t4fw.bin\"\n#define FW5_FNAME \"cxgb4/t5fw.bin\"\n#define FW6_FNAME \"cxgb4/t6fw.bin\"\n#define FW4_CFNAME \"cxgb4/t4-config.txt\"\n#define FW5_CFNAME \"cxgb4/t5-config.txt\"\n#define FW6_CFNAME \"cxgb4/t6-config.txt\"\n#define PHY_AQ1202_FIRMWARE \"cxgb4/aq1202_fw.cld\"\n#define PHY_BCM84834_FIRMWARE \"cxgb4/bcm8483.bin\"\n#define PHY_AQ1202_DEVICEID 0x4409\n#define PHY_BCM84834_DEVICEID 0x4486\n\nMODULE_DESCRIPTION(DRV_DESC);\nMODULE_AUTHOR(\"Chelsio Communications\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DEVICE_TABLE(pci, cxgb4_pci_tbl);\nMODULE_FIRMWARE(FW4_FNAME);\nMODULE_FIRMWARE(FW5_FNAME);\nMODULE_FIRMWARE(FW6_FNAME);\n\n/*\n * The driver uses the best interrupt scheme available on a platform in the\n * order MSI-X, MSI, legacy INTx interrupts.  This parameter determines which\n * of these schemes the driver may consider as follows:\n *\n * msi = 2: choose from among all three options\n * msi = 1: only consider MSI and INTx interrupts\n * msi = 0: force INTx interrupts\n */\nstatic int msi = 2;\n\nmodule_param(msi, int, 0644);\nMODULE_PARM_DESC(msi, \"whether to use INTx (0), MSI (1) or MSI-X (2)\");\n\n/*\n * Normally we tell the chip to deliver Ingress Packets into our DMA buffers\n * offset by 2 bytes in order to have the IP headers line up on 4-byte\n * boundaries.  This is a requirement for many architectures which will throw\n * a machine check fault if an attempt is made to access one of the 4-byte IP\n * header fields on a non-4-byte boundary.  And it's a major performance issue\n * even on some architectures which allow it like some implementations of the\n * x86 ISA.  However, some architectures don't mind this and for some very\n * edge-case performance sensitive applications (like forwarding large volumes\n * of small packets), setting this DMA offset to 0 will decrease the number of\n * PCI-E Bus transfers enough to measurably affect performance.\n */\nstatic int rx_dma_offset = 2;\n\n/* TX Queue select used to determine what algorithm to use for selecting TX\n * queue. Select between the kernel provided function (select_queue=0) or user\n * cxgb_select_queue function (select_queue=1)\n *\n * Default: select_queue=0\n */\nstatic int select_queue;\nmodule_param(select_queue, int, 0644);\nMODULE_PARM_DESC(select_queue,\n\t\t \"Select between kernel provided method of selecting or driver method of selecting TX queue. Default is kernel method.\");\n\nstatic struct dentry *cxgb4_debugfs_root;\n\nLIST_HEAD(adapter_list);\nDEFINE_MUTEX(uld_mutex);\nLIST_HEAD(uld_list);\n\nstatic int cfg_queues(struct adapter *adap);\n\nstatic void link_report(struct net_device *dev)\n{\n\tif (!netif_carrier_ok(dev))\n\t\tnetdev_info(dev, \"link down\\n\");\n\telse {\n\t\tstatic const char *fc[] = { \"no\", \"Rx\", \"Tx\", \"Tx/Rx\" };\n\n\t\tconst char *s;\n\t\tconst struct port_info *p = netdev_priv(dev);\n\n\t\tswitch (p->link_cfg.speed) {\n\t\tcase 100:\n\t\t\ts = \"100Mbps\";\n\t\t\tbreak;\n\t\tcase 1000:\n\t\t\ts = \"1Gbps\";\n\t\t\tbreak;\n\t\tcase 10000:\n\t\t\ts = \"10Gbps\";\n\t\t\tbreak;\n\t\tcase 25000:\n\t\t\ts = \"25Gbps\";\n\t\t\tbreak;\n\t\tcase 40000:\n\t\t\ts = \"40Gbps\";\n\t\t\tbreak;\n\t\tcase 50000:\n\t\t\ts = \"50Gbps\";\n\t\t\tbreak;\n\t\tcase 100000:\n\t\t\ts = \"100Gbps\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"%s: unsupported speed: %d\\n\",\n\t\t\t\tdev->name, p->link_cfg.speed);\n\t\t\treturn;\n\t\t}\n\n\t\tnetdev_info(dev, \"link up, %s, full-duplex, %s PAUSE\\n\", s,\n\t\t\t    fc[p->link_cfg.fc]);\n\t}\n}\n\n#ifdef CONFIG_CHELSIO_T4_DCB\n/* Set up/tear down Data Center Bridging Priority mapping for a net device. */\nstatic void dcb_tx_queue_prio_enable(struct net_device *dev, int enable)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tstruct sge_eth_txq *txq = &adap->sge.ethtxq[pi->first_qset];\n\tint i;\n\n\t/* We use a simple mapping of Port TX Queue Index to DCB\n\t * Priority when we're enabling DCB.\n\t */\n\tfor (i = 0; i < pi->nqsets; i++, txq++) {\n\t\tu32 name, value;\n\t\tint err;\n\n\t\tname = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DMAQ) |\n\t\t\tFW_PARAMS_PARAM_X_V(\n\t\t\t\tFW_PARAMS_PARAM_DMAQ_EQ_DCBPRIO_ETH) |\n\t\t\tFW_PARAMS_PARAM_YZ_V(txq->q.cntxt_id));\n\t\tvalue = enable ? i : 0xffffffff;\n\n\t\t/* Since we can be called while atomic (from \"interrupt\n\t\t * level\") we need to issue the Set Parameters Commannd\n\t\t * without sleeping (timeout < 0).\n\t\t */\n\t\terr = t4_set_params_timeout(adap, adap->mbox, adap->pf, 0, 1,\n\t\t\t\t\t    &name, &value,\n\t\t\t\t\t    -FW_CMD_MAX_TIMEOUT);\n\n\t\tif (err)\n\t\t\tdev_err(adap->pdev_dev,\n\t\t\t\t\"Can't %s DCB Priority on port %d, TX Queue %d: err=%d\\n\",\n\t\t\t\tenable ? \"set\" : \"unset\", pi->port_id, i, -err);\n\t\telse\n\t\t\ttxq->dcb_prio = enable ? value : 0;\n\t}\n}\n\nint cxgb4_dcb_enabled(const struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\n\tif (!pi->dcb.enabled)\n\t\treturn 0;\n\n\treturn ((pi->dcb.state == CXGB4_DCB_STATE_FW_ALLSYNCED) ||\n\t\t(pi->dcb.state == CXGB4_DCB_STATE_HOST));\n}\n#endif /* CONFIG_CHELSIO_T4_DCB */\n\nvoid t4_os_link_changed(struct adapter *adapter, int port_id, int link_stat)\n{\n\tstruct net_device *dev = adapter->port[port_id];\n\n\t/* Skip changes from disabled ports. */\n\tif (netif_running(dev) && link_stat != netif_carrier_ok(dev)) {\n\t\tif (link_stat)\n\t\t\tnetif_carrier_on(dev);\n\t\telse {\n#ifdef CONFIG_CHELSIO_T4_DCB\n\t\t\tif (cxgb4_dcb_enabled(dev)) {\n\t\t\t\tcxgb4_dcb_reset(dev);\n\t\t\t\tdcb_tx_queue_prio_enable(dev, false);\n\t\t\t}\n#endif /* CONFIG_CHELSIO_T4_DCB */\n\t\t\tnetif_carrier_off(dev);\n\t\t}\n\n\t\tlink_report(dev);\n\t}\n}\n\nvoid t4_os_portmod_changed(struct adapter *adap, int port_id)\n{\n\tstatic const char *mod_str[] = {\n\t\tNULL, \"LR\", \"SR\", \"ER\", \"passive DA\", \"active DA\", \"LRM\"\n\t};\n\n\tstruct net_device *dev = adap->port[port_id];\n\tstruct port_info *pi = netdev_priv(dev);\n\n\tif (pi->mod_type == FW_PORT_MOD_TYPE_NONE)\n\t\tnetdev_info(dev, \"port module unplugged\\n\");\n\telse if (pi->mod_type < ARRAY_SIZE(mod_str))\n\t\tnetdev_info(dev, \"%s module inserted\\n\", mod_str[pi->mod_type]);\n\telse if (pi->mod_type == FW_PORT_MOD_TYPE_NOTSUPPORTED)\n\t\tnetdev_info(dev, \"%s: unsupported port module inserted\\n\",\n\t\t\t    dev->name);\n\telse if (pi->mod_type == FW_PORT_MOD_TYPE_UNKNOWN)\n\t\tnetdev_info(dev, \"%s: unknown port module inserted\\n\",\n\t\t\t    dev->name);\n\telse if (pi->mod_type == FW_PORT_MOD_TYPE_ERROR)\n\t\tnetdev_info(dev, \"%s: transceiver module error\\n\", dev->name);\n\telse\n\t\tnetdev_info(dev, \"%s: unknown module type %d inserted\\n\",\n\t\t\t    dev->name, pi->mod_type);\n\n\t/* If the interface is running, then we'll need any \"sticky\" Link\n\t * Parameters redone with a new Transceiver Module.\n\t */\n\tpi->link_cfg.redo_l1cfg = netif_running(dev);\n}\n\nint dbfifo_int_thresh = 10; /* 10 == 640 entry threshold */\nmodule_param(dbfifo_int_thresh, int, 0644);\nMODULE_PARM_DESC(dbfifo_int_thresh, \"doorbell fifo interrupt threshold\");\n\n/*\n * usecs to sleep while draining the dbfifo\n */\nstatic int dbfifo_drain_delay = 1000;\nmodule_param(dbfifo_drain_delay, int, 0644);\nMODULE_PARM_DESC(dbfifo_drain_delay,\n\t\t \"usecs to sleep while draining the dbfifo\");\n\nstatic inline int cxgb4_set_addr_hash(struct port_info *pi)\n{\n\tstruct adapter *adap = pi->adapter;\n\tu64 vec = 0;\n\tbool ucast = false;\n\tstruct hash_mac_addr *entry;\n\n\t/* Calculate the hash vector for the updated list and program it */\n\tlist_for_each_entry(entry, &adap->mac_hlist, list) {\n\t\tucast |= is_unicast_ether_addr(entry->addr);\n\t\tvec |= (1ULL << hash_mac_addr(entry->addr));\n\t}\n\treturn t4_set_addr_hash(adap, adap->mbox, pi->viid, ucast,\n\t\t\t\tvec, false);\n}\n\nstatic int cxgb4_mac_sync(struct net_device *netdev, const u8 *mac_addr)\n{\n\tstruct port_info *pi = netdev_priv(netdev);\n\tstruct adapter *adap = pi->adapter;\n\tint ret;\n\tu64 mhash = 0;\n\tu64 uhash = 0;\n\t/* idx stores the index of allocated filters,\n\t * its size should be modified based on the number of\n\t * MAC addresses that we allocate filters for\n\t */\n\n\tu16 idx[1] = {};\n\tbool free = false;\n\tbool ucast = is_unicast_ether_addr(mac_addr);\n\tconst u8 *maclist[1] = {mac_addr};\n\tstruct hash_mac_addr *new_entry;\n\n\tret = cxgb4_alloc_mac_filt(adap, pi->viid, free, 1, maclist,\n\t\t\t\t   idx, ucast ? &uhash : &mhash, false);\n\tif (ret < 0)\n\t\tgoto out;\n\t/* if hash != 0, then add the addr to hash addr list\n\t * so on the end we will calculate the hash for the\n\t * list and program it\n\t */\n\tif (uhash || mhash) {\n\t\tnew_entry = kzalloc(sizeof(*new_entry), GFP_ATOMIC);\n\t\tif (!new_entry)\n\t\t\treturn -ENOMEM;\n\t\tether_addr_copy(new_entry->addr, mac_addr);\n\t\tlist_add_tail(&new_entry->list, &adap->mac_hlist);\n\t\tret = cxgb4_set_addr_hash(pi);\n\t}\nout:\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int cxgb4_mac_unsync(struct net_device *netdev, const u8 *mac_addr)\n{\n\tstruct port_info *pi = netdev_priv(netdev);\n\tstruct adapter *adap = pi->adapter;\n\tint ret;\n\tconst u8 *maclist[1] = {mac_addr};\n\tstruct hash_mac_addr *entry, *tmp;\n\n\t/* If the MAC address to be removed is in the hash addr\n\t * list, delete it from the list and update hash vector\n\t */\n\tlist_for_each_entry_safe(entry, tmp, &adap->mac_hlist, list) {\n\t\tif (ether_addr_equal(entry->addr, mac_addr)) {\n\t\t\tlist_del(&entry->list);\n\t\t\tkfree(entry);\n\t\t\treturn cxgb4_set_addr_hash(pi);\n\t\t}\n\t}\n\n\tret = cxgb4_free_mac_filt(adap, pi->viid, 1, maclist, false);\n\treturn ret < 0 ? -EINVAL : 0;\n}\n\n/*\n * Set Rx properties of a port, such as promiscruity, address filters, and MTU.\n * If @mtu is -1 it is left unchanged.\n */\nstatic int set_rxmode(struct net_device *dev, int mtu, bool sleep_ok)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\n\t__dev_uc_sync(dev, cxgb4_mac_sync, cxgb4_mac_unsync);\n\t__dev_mc_sync(dev, cxgb4_mac_sync, cxgb4_mac_unsync);\n\n\treturn t4_set_rxmode(adapter, adapter->mbox, pi->viid, pi->viid_mirror,\n\t\t\t     mtu, (dev->flags & IFF_PROMISC) ? 1 : 0,\n\t\t\t     (dev->flags & IFF_ALLMULTI) ? 1 : 0, 1, -1,\n\t\t\t     sleep_ok);\n}\n\n/**\n *\tcxgb4_change_mac - Update match filter for a MAC address.\n *\t@pi: the port_info\n *\t@viid: the VI id\n *\t@tcam_idx: TCAM index of existing filter for old value of MAC address,\n *\t\t   or -1\n *\t@addr: the new MAC address value\n *\t@persist: whether a new MAC allocation should be persistent\n *\t@smt_idx: the destination to store the new SMT index.\n *\n *\tModifies an MPS filter and sets it to the new MAC address if\n *\t@tcam_idx >= 0, or adds the MAC address to a new filter if\n *\t@tcam_idx < 0. In the latter case the address is added persistently\n *\tif @persist is %true.\n *\tAddresses are programmed to hash region, if tcam runs out of entries.\n *\n */\nint cxgb4_change_mac(struct port_info *pi, unsigned int viid,\n\t\t     int *tcam_idx, const u8 *addr, bool persist,\n\t\t     u8 *smt_idx)\n{\n\tstruct adapter *adapter = pi->adapter;\n\tstruct hash_mac_addr *entry, *new_entry;\n\tint ret;\n\n\tret = t4_change_mac(adapter, adapter->mbox, viid,\n\t\t\t    *tcam_idx, addr, persist, smt_idx);\n\t/* We ran out of TCAM entries. try programming hash region. */\n\tif (ret == -ENOMEM) {\n\t\t/* If the MAC address to be updated is in the hash addr\n\t\t * list, update it from the list\n\t\t */\n\t\tlist_for_each_entry(entry, &adapter->mac_hlist, list) {\n\t\t\tif (entry->iface_mac) {\n\t\t\t\tether_addr_copy(entry->addr, addr);\n\t\t\t\tgoto set_hash;\n\t\t\t}\n\t\t}\n\t\tnew_entry = kzalloc(sizeof(*new_entry), GFP_KERNEL);\n\t\tif (!new_entry)\n\t\t\treturn -ENOMEM;\n\t\tether_addr_copy(new_entry->addr, addr);\n\t\tnew_entry->iface_mac = true;\n\t\tlist_add_tail(&new_entry->list, &adapter->mac_hlist);\nset_hash:\n\t\tret = cxgb4_set_addr_hash(pi);\n\t} else if (ret >= 0) {\n\t\t*tcam_idx = ret;\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n/*\n *\tlink_start - enable a port\n *\t@dev: the port to enable\n *\n *\tPerforms the MAC and PHY actions needed to enable a port.\n */\nstatic int link_start(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tunsigned int mb = pi->adapter->mbox;\n\tint ret;\n\n\t/*\n\t * We do not set address filters and promiscuity here, the stack does\n\t * that step explicitly.\n\t */\n\tret = t4_set_rxmode(pi->adapter, mb, pi->viid, pi->viid_mirror,\n\t\t\t    dev->mtu, -1, -1, -1,\n\t\t\t    !!(dev->features & NETIF_F_HW_VLAN_CTAG_RX), true);\n\tif (ret == 0)\n\t\tret = cxgb4_update_mac_filt(pi, pi->viid, &pi->xact_addr_filt,\n\t\t\t\t\t    dev->dev_addr, true, &pi->smt_idx);\n\tif (ret == 0)\n\t\tret = t4_link_l1cfg(pi->adapter, mb, pi->tx_chan,\n\t\t\t\t    &pi->link_cfg);\n\tif (ret == 0) {\n\t\tlocal_bh_disable();\n\t\tret = t4_enable_pi_params(pi->adapter, mb, pi, true,\n\t\t\t\t\t  true, CXGB4_DCB_ENABLED);\n\t\tlocal_bh_enable();\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_CHELSIO_T4_DCB\n/* Handle a Data Center Bridging update message from the firmware. */\nstatic void dcb_rpl(struct adapter *adap, const struct fw_port_cmd *pcmd)\n{\n\tint port = FW_PORT_CMD_PORTID_G(ntohl(pcmd->op_to_portid));\n\tstruct net_device *dev = adap->port[adap->chan_map[port]];\n\tint old_dcb_enabled = cxgb4_dcb_enabled(dev);\n\tint new_dcb_enabled;\n\n\tcxgb4_dcb_handle_fw_update(adap, pcmd);\n\tnew_dcb_enabled = cxgb4_dcb_enabled(dev);\n\n\t/* If the DCB has become enabled or disabled on the port then we're\n\t * going to need to set up/tear down DCB Priority parameters for the\n\t * TX Queues associated with the port.\n\t */\n\tif (new_dcb_enabled != old_dcb_enabled)\n\t\tdcb_tx_queue_prio_enable(dev, new_dcb_enabled);\n}\n#endif /* CONFIG_CHELSIO_T4_DCB */\n\n/* Response queue handler for the FW event queue.\n */\nstatic int fwevtq_handler(struct sge_rspq *q, const __be64 *rsp,\n\t\t\t  const struct pkt_gl *gl)\n{\n\tu8 opcode = ((const struct rss_header *)rsp)->opcode;\n\n\trsp++;                                          /* skip RSS header */\n\n\t/* FW can send EGR_UPDATEs encapsulated in a CPL_FW4_MSG.\n\t */\n\tif (unlikely(opcode == CPL_FW4_MSG &&\n\t   ((const struct cpl_fw4_msg *)rsp)->type == FW_TYPE_RSSCPL)) {\n\t\trsp++;\n\t\topcode = ((const struct rss_header *)rsp)->opcode;\n\t\trsp++;\n\t\tif (opcode != CPL_SGE_EGR_UPDATE) {\n\t\t\tdev_err(q->adap->pdev_dev, \"unexpected FW4/CPL %#x on FW event queue\\n\"\n\t\t\t\t, opcode);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (likely(opcode == CPL_SGE_EGR_UPDATE)) {\n\t\tconst struct cpl_sge_egr_update *p = (void *)rsp;\n\t\tunsigned int qid = EGR_QID_G(ntohl(p->opcode_qid));\n\t\tstruct sge_txq *txq;\n\n\t\ttxq = q->adap->sge.egr_map[qid - q->adap->sge.egr_start];\n\t\ttxq->restarts++;\n\t\tif (txq->q_type == CXGB4_TXQ_ETH) {\n\t\t\tstruct sge_eth_txq *eq;\n\n\t\t\teq = container_of(txq, struct sge_eth_txq, q);\n\t\t\tt4_sge_eth_txq_egress_update(q->adap, eq, -1);\n\t\t} else {\n\t\t\tstruct sge_uld_txq *oq;\n\n\t\t\toq = container_of(txq, struct sge_uld_txq, q);\n\t\t\ttasklet_schedule(&oq->qresume_tsk);\n\t\t}\n\t} else if (opcode == CPL_FW6_MSG || opcode == CPL_FW4_MSG) {\n\t\tconst struct cpl_fw6_msg *p = (void *)rsp;\n\n#ifdef CONFIG_CHELSIO_T4_DCB\n\t\tconst struct fw_port_cmd *pcmd = (const void *)p->data;\n\t\tunsigned int cmd = FW_CMD_OP_G(ntohl(pcmd->op_to_portid));\n\t\tunsigned int action =\n\t\t\tFW_PORT_CMD_ACTION_G(ntohl(pcmd->action_to_len16));\n\n\t\tif (cmd == FW_PORT_CMD &&\n\t\t    (action == FW_PORT_ACTION_GET_PORT_INFO ||\n\t\t     action == FW_PORT_ACTION_GET_PORT_INFO32)) {\n\t\t\tint port = FW_PORT_CMD_PORTID_G(\n\t\t\t\t\tbe32_to_cpu(pcmd->op_to_portid));\n\t\t\tstruct net_device *dev;\n\t\t\tint dcbxdis, state_input;\n\n\t\t\tdev = q->adap->port[q->adap->chan_map[port]];\n\t\t\tdcbxdis = (action == FW_PORT_ACTION_GET_PORT_INFO\n\t\t\t  ? !!(pcmd->u.info.dcbxdis_pkd & FW_PORT_CMD_DCBXDIS_F)\n\t\t\t  : !!(be32_to_cpu(pcmd->u.info32.lstatus32_to_cbllen32)\n\t\t\t       & FW_PORT_CMD_DCBXDIS32_F));\n\t\t\tstate_input = (dcbxdis\n\t\t\t\t       ? CXGB4_DCB_INPUT_FW_DISABLED\n\t\t\t\t       : CXGB4_DCB_INPUT_FW_ENABLED);\n\n\t\t\tcxgb4_dcb_state_fsm(dev, state_input);\n\t\t}\n\n\t\tif (cmd == FW_PORT_CMD &&\n\t\t    action == FW_PORT_ACTION_L2_DCB_CFG)\n\t\t\tdcb_rpl(q->adap, pcmd);\n\t\telse\n#endif\n\t\t\tif (p->type == 0)\n\t\t\t\tt4_handle_fw_rpl(q->adap, p->data);\n\t} else if (opcode == CPL_L2T_WRITE_RPL) {\n\t\tconst struct cpl_l2t_write_rpl *p = (void *)rsp;\n\n\t\tdo_l2t_write_rpl(q->adap, p);\n\t} else if (opcode == CPL_SMT_WRITE_RPL) {\n\t\tconst struct cpl_smt_write_rpl *p = (void *)rsp;\n\n\t\tdo_smt_write_rpl(q->adap, p);\n\t} else if (opcode == CPL_SET_TCB_RPL) {\n\t\tconst struct cpl_set_tcb_rpl *p = (void *)rsp;\n\n\t\tfilter_rpl(q->adap, p);\n\t} else if (opcode == CPL_ACT_OPEN_RPL) {\n\t\tconst struct cpl_act_open_rpl *p = (void *)rsp;\n\n\t\thash_filter_rpl(q->adap, p);\n\t} else if (opcode == CPL_ABORT_RPL_RSS) {\n\t\tconst struct cpl_abort_rpl_rss *p = (void *)rsp;\n\n\t\thash_del_filter_rpl(q->adap, p);\n\t} else if (opcode == CPL_SRQ_TABLE_RPL) {\n\t\tconst struct cpl_srq_table_rpl *p = (void *)rsp;\n\n\t\tdo_srq_table_rpl(q->adap, p);\n\t} else\n\t\tdev_err(q->adap->pdev_dev,\n\t\t\t\"unexpected CPL %#x on FW event queue\\n\", opcode);\nout:\n\treturn 0;\n}\n\nstatic void disable_msi(struct adapter *adapter)\n{\n\tif (adapter->flags & CXGB4_USING_MSIX) {\n\t\tpci_disable_msix(adapter->pdev);\n\t\tadapter->flags &= ~CXGB4_USING_MSIX;\n\t} else if (adapter->flags & CXGB4_USING_MSI) {\n\t\tpci_disable_msi(adapter->pdev);\n\t\tadapter->flags &= ~CXGB4_USING_MSI;\n\t}\n}\n\n/*\n * Interrupt handler for non-data events used with MSI-X.\n */\nstatic irqreturn_t t4_nondata_intr(int irq, void *cookie)\n{\n\tstruct adapter *adap = cookie;\n\tu32 v = t4_read_reg(adap, MYPF_REG(PL_PF_INT_CAUSE_A));\n\n\tif (v & PFSW_F) {\n\t\tadap->swintr = 1;\n\t\tt4_write_reg(adap, MYPF_REG(PL_PF_INT_CAUSE_A), v);\n\t}\n\tif (adap->flags & CXGB4_MASTER_PF)\n\t\tt4_slow_intr_handler(adap);\n\treturn IRQ_HANDLED;\n}\n\nint cxgb4_set_msix_aff(struct adapter *adap, unsigned short vec,\n\t\t       cpumask_var_t *aff_mask, int idx)\n{\n\tint rv;\n\n\tif (!zalloc_cpumask_var(aff_mask, GFP_KERNEL)) {\n\t\tdev_err(adap->pdev_dev, \"alloc_cpumask_var failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcpumask_set_cpu(cpumask_local_spread(idx, dev_to_node(adap->pdev_dev)),\n\t\t\t*aff_mask);\n\n\trv = irq_set_affinity_hint(vec, *aff_mask);\n\tif (rv)\n\t\tdev_warn(adap->pdev_dev,\n\t\t\t \"irq_set_affinity_hint %u failed %d\\n\",\n\t\t\t vec, rv);\n\n\treturn 0;\n}\n\nvoid cxgb4_clear_msix_aff(unsigned short vec, cpumask_var_t aff_mask)\n{\n\tirq_set_affinity_hint(vec, NULL);\n\tfree_cpumask_var(aff_mask);\n}\n\nstatic int request_msix_queue_irqs(struct adapter *adap)\n{\n\tstruct sge *s = &adap->sge;\n\tstruct msix_info *minfo;\n\tint err, ethqidx;\n\n\tif (s->fwevtq_msix_idx < 0)\n\t\treturn -ENOMEM;\n\n\terr = request_irq(adap->msix_info[s->fwevtq_msix_idx].vec,\n\t\t\t  t4_sge_intr_msix, 0,\n\t\t\t  adap->msix_info[s->fwevtq_msix_idx].desc,\n\t\t\t  &s->fw_evtq);\n\tif (err)\n\t\treturn err;\n\n\tfor_each_ethrxq(s, ethqidx) {\n\t\tminfo = s->ethrxq[ethqidx].msix;\n\t\terr = request_irq(minfo->vec,\n\t\t\t\t  t4_sge_intr_msix, 0,\n\t\t\t\t  minfo->desc,\n\t\t\t\t  &s->ethrxq[ethqidx].rspq);\n\t\tif (err)\n\t\t\tgoto unwind;\n\n\t\tcxgb4_set_msix_aff(adap, minfo->vec,\n\t\t\t\t   &minfo->aff_mask, ethqidx);\n\t}\n\treturn 0;\n\nunwind:\n\twhile (--ethqidx >= 0) {\n\t\tminfo = s->ethrxq[ethqidx].msix;\n\t\tcxgb4_clear_msix_aff(minfo->vec, minfo->aff_mask);\n\t\tfree_irq(minfo->vec, &s->ethrxq[ethqidx].rspq);\n\t}\n\tfree_irq(adap->msix_info[s->fwevtq_msix_idx].vec, &s->fw_evtq);\n\treturn err;\n}\n\nstatic void free_msix_queue_irqs(struct adapter *adap)\n{\n\tstruct sge *s = &adap->sge;\n\tstruct msix_info *minfo;\n\tint i;\n\n\tfree_irq(adap->msix_info[s->fwevtq_msix_idx].vec, &s->fw_evtq);\n\tfor_each_ethrxq(s, i) {\n\t\tminfo = s->ethrxq[i].msix;\n\t\tcxgb4_clear_msix_aff(minfo->vec, minfo->aff_mask);\n\t\tfree_irq(minfo->vec, &s->ethrxq[i].rspq);\n\t}\n}\n\nstatic int setup_ppod_edram(struct adapter *adap)\n{\n\tunsigned int param, val;\n\tint ret;\n\n\t/* Driver sends FW_PARAMS_PARAM_DEV_PPOD_EDRAM read command to check\n\t * if firmware supports ppod edram feature or not. If firmware\n\t * returns 1, then driver can enable this feature by sending\n\t * FW_PARAMS_PARAM_DEV_PPOD_EDRAM write command with value 1 to\n\t * enable ppod edram feature.\n\t */\n\tparam = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\tFW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_PPOD_EDRAM));\n\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 1, &param, &val);\n\tif (ret < 0) {\n\t\tdev_warn(adap->pdev_dev,\n\t\t\t \"querying PPOD_EDRAM support failed: %d\\n\",\n\t\t\t ret);\n\t\treturn -1;\n\t}\n\n\tif (val != 1)\n\t\treturn -1;\n\n\tret = t4_set_params(adap, adap->mbox, adap->pf, 0, 1, &param, &val);\n\tif (ret < 0) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"setting PPOD_EDRAM failed: %d\\n\", ret);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void adap_config_hpfilter(struct adapter *adapter)\n{\n\tu32 param, val = 0;\n\tint ret;\n\n\t/* Enable HP filter region. Older fw will fail this request and\n\t * it is fine.\n\t */\n\tparam = FW_PARAM_DEV(HPFILTER_REGION_SUPPORT);\n\tret = t4_set_params(adapter, adapter->mbox, adapter->pf, 0,\n\t\t\t    1, &param, &val);\n\n\t/* An error means FW doesn't know about HP filter support,\n\t * it's not a problem, don't return an error.\n\t */\n\tif (ret < 0)\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"HP filter region isn't supported by FW\\n\");\n}\n\nstatic int cxgb4_config_rss(const struct port_info *pi, u16 *rss,\n\t\t\t    u16 rss_size, u16 viid)\n{\n\tstruct adapter *adap = pi->adapter;\n\tint ret;\n\n\tret = t4_config_rss_range(adap, adap->mbox, viid, 0, rss_size, rss,\n\t\t\t\t  rss_size);\n\tif (ret)\n\t\treturn ret;\n\n\t/* If Tunnel All Lookup isn't specified in the global RSS\n\t * Configuration, then we need to specify a default Ingress\n\t * Queue for any ingress packets which aren't hashed.  We'll\n\t * use our first ingress queue ...\n\t */\n\treturn t4_config_vi_rss(adap, adap->mbox, viid,\n\t\t\t\tFW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN_F |\n\t\t\t\tFW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN_F |\n\t\t\t\tFW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN_F |\n\t\t\t\tFW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN_F |\n\t\t\t\tFW_RSS_VI_CONFIG_CMD_UDPEN_F,\n\t\t\t\trss[0]);\n}\n\n/**\n *\tcxgb4_write_rss - write the RSS table for a given port\n *\t@pi: the port\n *\t@queues: array of queue indices for RSS\n *\n *\tSets up the portion of the HW RSS table for the port's VI to distribute\n *\tpackets to the Rx queues in @queues.\n *\tShould never be called before setting up sge eth rx queues\n */\nint cxgb4_write_rss(const struct port_info *pi, const u16 *queues)\n{\n\tstruct adapter *adapter = pi->adapter;\n\tconst struct sge_eth_rxq *rxq;\n\tint i, err;\n\tu16 *rss;\n\n\trxq = &adapter->sge.ethrxq[pi->first_qset];\n\trss = kmalloc_array(pi->rss_size, sizeof(u16), GFP_KERNEL);\n\tif (!rss)\n\t\treturn -ENOMEM;\n\n\t/* map the queue indices to queue ids */\n\tfor (i = 0; i < pi->rss_size; i++, queues++)\n\t\trss[i] = rxq[*queues].rspq.abs_id;\n\n\terr = cxgb4_config_rss(pi, rss, pi->rss_size, pi->viid);\n\tkfree(rss);\n\treturn err;\n}\n\n/**\n *\tsetup_rss - configure RSS\n *\t@adap: the adapter\n *\n *\tSets up RSS for each port.\n */\nstatic int setup_rss(struct adapter *adap)\n{\n\tint i, j, err;\n\n\tfor_each_port(adap, i) {\n\t\tconst struct port_info *pi = adap2pinfo(adap, i);\n\n\t\t/* Fill default values with equal distribution */\n\t\tfor (j = 0; j < pi->rss_size; j++)\n\t\t\tpi->rss[j] = j % pi->nqsets;\n\n\t\terr = cxgb4_write_rss(pi, pi->rss);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n/*\n * Return the channel of the ingress queue with the given qid.\n */\nstatic unsigned int rxq_to_chan(const struct sge *p, unsigned int qid)\n{\n\tqid -= p->ingr_start;\n\treturn netdev2pinfo(p->ingr_map[qid]->netdev)->tx_chan;\n}\n\nvoid cxgb4_quiesce_rx(struct sge_rspq *q)\n{\n\tif (q->handler)\n\t\tnapi_disable(&q->napi);\n}\n\n/*\n * Wait until all NAPI handlers are descheduled.\n */\nstatic void quiesce_rx(struct adapter *adap)\n{\n\tint i;\n\n\tfor (i = 0; i < adap->sge.ingr_sz; i++) {\n\t\tstruct sge_rspq *q = adap->sge.ingr_map[i];\n\n\t\tif (!q)\n\t\t\tcontinue;\n\n\t\tcxgb4_quiesce_rx(q);\n\t}\n}\n\n/* Disable interrupt and napi handler */\nstatic void disable_interrupts(struct adapter *adap)\n{\n\tstruct sge *s = &adap->sge;\n\n\tif (adap->flags & CXGB4_FULL_INIT_DONE) {\n\t\tt4_intr_disable(adap);\n\t\tif (adap->flags & CXGB4_USING_MSIX) {\n\t\t\tfree_msix_queue_irqs(adap);\n\t\t\tfree_irq(adap->msix_info[s->nd_msix_idx].vec,\n\t\t\t\t adap);\n\t\t} else {\n\t\t\tfree_irq(adap->pdev->irq, adap);\n\t\t}\n\t\tquiesce_rx(adap);\n\t}\n}\n\nvoid cxgb4_enable_rx(struct adapter *adap, struct sge_rspq *q)\n{\n\tif (q->handler)\n\t\tnapi_enable(&q->napi);\n\n\t/* 0-increment GTS to start the timer and enable interrupts */\n\tt4_write_reg(adap, MYPF_REG(SGE_PF_GTS_A),\n\t\t     SEINTARM_V(q->intr_params) |\n\t\t     INGRESSQID_V(q->cntxt_id));\n}\n\n/*\n * Enable NAPI scheduling and interrupt generation for all Rx queues.\n */\nstatic void enable_rx(struct adapter *adap)\n{\n\tint i;\n\n\tfor (i = 0; i < adap->sge.ingr_sz; i++) {\n\t\tstruct sge_rspq *q = adap->sge.ingr_map[i];\n\n\t\tif (!q)\n\t\t\tcontinue;\n\n\t\tcxgb4_enable_rx(adap, q);\n\t}\n}\n\nstatic int setup_non_data_intr(struct adapter *adap)\n{\n\tint msix;\n\n\tadap->sge.nd_msix_idx = -1;\n\tif (!(adap->flags & CXGB4_USING_MSIX))\n\t\treturn 0;\n\n\t/* Request MSI-X vector for non-data interrupt */\n\tmsix = cxgb4_get_msix_idx_from_bmap(adap);\n\tif (msix < 0)\n\t\treturn -ENOMEM;\n\n\tsnprintf(adap->msix_info[msix].desc,\n\t\t sizeof(adap->msix_info[msix].desc),\n\t\t \"%s\", adap->port[0]->name);\n\n\tadap->sge.nd_msix_idx = msix;\n\treturn 0;\n}\n\nstatic int setup_fw_sge_queues(struct adapter *adap)\n{\n\tstruct sge *s = &adap->sge;\n\tint msix, err = 0;\n\n\tbitmap_zero(s->starving_fl, s->egr_sz);\n\tbitmap_zero(s->txq_maperr, s->egr_sz);\n\n\tif (adap->flags & CXGB4_USING_MSIX) {\n\t\ts->fwevtq_msix_idx = -1;\n\t\tmsix = cxgb4_get_msix_idx_from_bmap(adap);\n\t\tif (msix < 0)\n\t\t\treturn -ENOMEM;\n\n\t\tsnprintf(adap->msix_info[msix].desc,\n\t\t\t sizeof(adap->msix_info[msix].desc),\n\t\t\t \"%s-FWeventq\", adap->port[0]->name);\n\t} else {\n\t\terr = t4_sge_alloc_rxq(adap, &s->intrq, false, adap->port[0], 0,\n\t\t\t\t       NULL, NULL, NULL, -1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tmsix = -((int)s->intrq.abs_id + 1);\n\t}\n\n\terr = t4_sge_alloc_rxq(adap, &s->fw_evtq, true, adap->port[0],\n\t\t\t       msix, NULL, fwevtq_handler, NULL, -1);\n\tif (err && msix >= 0)\n\t\tcxgb4_free_msix_idx_in_bmap(adap, msix);\n\n\ts->fwevtq_msix_idx = msix;\n\treturn err;\n}\n\n/**\n *\tsetup_sge_queues - configure SGE Tx/Rx/response queues\n *\t@adap: the adapter\n *\n *\tDetermines how many sets of SGE queues to use and initializes them.\n *\tWe support multiple queue sets per port if we have MSI-X, otherwise\n *\tjust one queue set per port.\n */\nstatic int setup_sge_queues(struct adapter *adap)\n{\n\tstruct sge_uld_rxq_info *rxq_info = NULL;\n\tstruct sge *s = &adap->sge;\n\tunsigned int cmplqid = 0;\n\tint err, i, j, msix = 0;\n\n\tif (is_uld(adap))\n\t\trxq_info = s->uld_rxq_info[CXGB4_ULD_RDMA];\n\n\tif (!(adap->flags & CXGB4_USING_MSIX))\n\t\tmsix = -((int)s->intrq.abs_id + 1);\n\n\tfor_each_port(adap, i) {\n\t\tstruct net_device *dev = adap->port[i];\n\t\tstruct port_info *pi = netdev_priv(dev);\n\t\tstruct sge_eth_rxq *q = &s->ethrxq[pi->first_qset];\n\t\tstruct sge_eth_txq *t = &s->ethtxq[pi->first_qset];\n\n\t\tfor (j = 0; j < pi->nqsets; j++, q++) {\n\t\t\tif (msix >= 0) {\n\t\t\t\tmsix = cxgb4_get_msix_idx_from_bmap(adap);\n\t\t\t\tif (msix < 0) {\n\t\t\t\t\terr = msix;\n\t\t\t\t\tgoto freeout;\n\t\t\t\t}\n\n\t\t\t\tsnprintf(adap->msix_info[msix].desc,\n\t\t\t\t\t sizeof(adap->msix_info[msix].desc),\n\t\t\t\t\t \"%s-Rx%d\", dev->name, j);\n\t\t\t\tq->msix = &adap->msix_info[msix];\n\t\t\t}\n\n\t\t\terr = t4_sge_alloc_rxq(adap, &q->rspq, false, dev,\n\t\t\t\t\t       msix, &q->fl,\n\t\t\t\t\t       t4_ethrx_handler,\n\t\t\t\t\t       NULL,\n\t\t\t\t\t       t4_get_tp_ch_map(adap,\n\t\t\t\t\t\t\t\tpi->tx_chan));\n\t\t\tif (err)\n\t\t\t\tgoto freeout;\n\t\t\tq->rspq.idx = j;\n\t\t\tmemset(&q->stats, 0, sizeof(q->stats));\n\t\t}\n\n\t\tq = &s->ethrxq[pi->first_qset];\n\t\tfor (j = 0; j < pi->nqsets; j++, t++, q++) {\n\t\t\terr = t4_sge_alloc_eth_txq(adap, t, dev,\n\t\t\t\t\tnetdev_get_tx_queue(dev, j),\n\t\t\t\t\tq->rspq.cntxt_id,\n\t\t\t\t\t!!(adap->flags & CXGB4_SGE_DBQ_TIMER));\n\t\t\tif (err)\n\t\t\t\tgoto freeout;\n\t\t}\n\t}\n\n\tfor_each_port(adap, i) {\n\t\t/* Note that cmplqid below is 0 if we don't\n\t\t * have RDMA queues, and that's the right value.\n\t\t */\n\t\tif (rxq_info)\n\t\t\tcmplqid\t= rxq_info->uldrxq[i].rspq.cntxt_id;\n\n\t\terr = t4_sge_alloc_ctrl_txq(adap, &s->ctrlq[i], adap->port[i],\n\t\t\t\t\t    s->fw_evtq.cntxt_id, cmplqid);\n\t\tif (err)\n\t\t\tgoto freeout;\n\t}\n\n\tif (!is_t4(adap->params.chip)) {\n\t\terr = t4_sge_alloc_eth_txq(adap, &s->ptptxq, adap->port[0],\n\t\t\t\t\t   netdev_get_tx_queue(adap->port[0], 0)\n\t\t\t\t\t   , s->fw_evtq.cntxt_id, false);\n\t\tif (err)\n\t\t\tgoto freeout;\n\t}\n\n\tt4_write_reg(adap, is_t4(adap->params.chip) ?\n\t\t\t\tMPS_TRC_RSS_CONTROL_A :\n\t\t\t\tMPS_T5_TRC_RSS_CONTROL_A,\n\t\t     RSSCONTROL_V(netdev2pinfo(adap->port[0])->tx_chan) |\n\t\t     QUEUENUMBER_V(s->ethrxq[0].rspq.abs_id));\n\treturn 0;\nfreeout:\n\tdev_err(adap->pdev_dev, \"Can't allocate queues, err=%d\\n\", -err);\n\tt4_free_sge_resources(adap);\n\treturn err;\n}\n\nstatic u16 cxgb_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t\t     struct net_device *sb_dev)\n{\n\tint txq;\n\n#ifdef CONFIG_CHELSIO_T4_DCB\n\t/* If a Data Center Bridging has been successfully negotiated on this\n\t * link then we'll use the skb's priority to map it to a TX Queue.\n\t * The skb's priority is determined via the VLAN Tag Priority Code\n\t * Point field.\n\t */\n\tif (cxgb4_dcb_enabled(dev) && !is_kdump_kernel()) {\n\t\tu16 vlan_tci;\n\t\tint err;\n\n\t\terr = vlan_get_tag(skb, &vlan_tci);\n\t\tif (unlikely(err)) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tnetdev_warn(dev,\n\t\t\t\t\t    \"TX Packet without VLAN Tag on DCB Link\\n\");\n\t\t\ttxq = 0;\n\t\t} else {\n\t\t\ttxq = (vlan_tci & VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT;\n#ifdef CONFIG_CHELSIO_T4_FCOE\n\t\t\tif (skb->protocol == htons(ETH_P_FCOE))\n\t\t\t\ttxq = skb->priority & 0x7;\n#endif /* CONFIG_CHELSIO_T4_FCOE */\n\t\t}\n\t\treturn txq;\n\t}\n#endif /* CONFIG_CHELSIO_T4_DCB */\n\n\tif (dev->num_tc) {\n\t\tstruct port_info *pi = netdev2pinfo(dev);\n\t\tu8 ver, proto;\n\n\t\tver = ip_hdr(skb)->version;\n\t\tproto = (ver == 6) ? ipv6_hdr(skb)->nexthdr :\n\t\t\t\t     ip_hdr(skb)->protocol;\n\n\t\t/* Send unsupported traffic pattern to normal NIC queues. */\n\t\ttxq = netdev_pick_tx(dev, skb, sb_dev);\n\t\tif (xfrm_offload(skb) || is_ptp_enabled(skb, dev) ||\n\t\t    skb->encapsulation ||\n\t\t    (proto != IPPROTO_TCP && proto != IPPROTO_UDP))\n\t\t\ttxq = txq % pi->nqsets;\n\n\t\treturn txq;\n\t}\n\n\tif (select_queue) {\n\t\ttxq = (skb_rx_queue_recorded(skb)\n\t\t\t? skb_get_rx_queue(skb)\n\t\t\t: smp_processor_id());\n\n\t\twhile (unlikely(txq >= dev->real_num_tx_queues))\n\t\t\ttxq -= dev->real_num_tx_queues;\n\n\t\treturn txq;\n\t}\n\n\treturn netdev_pick_tx(dev, skb, NULL) % dev->real_num_tx_queues;\n}\n\nstatic int closest_timer(const struct sge *s, int time)\n{\n\tint i, delta, match = 0, min_delta = INT_MAX;\n\n\tfor (i = 0; i < ARRAY_SIZE(s->timer_val); i++) {\n\t\tdelta = time - s->timer_val[i];\n\t\tif (delta < 0)\n\t\t\tdelta = -delta;\n\t\tif (delta < min_delta) {\n\t\t\tmin_delta = delta;\n\t\t\tmatch = i;\n\t\t}\n\t}\n\treturn match;\n}\n\nstatic int closest_thres(const struct sge *s, int thres)\n{\n\tint i, delta, match = 0, min_delta = INT_MAX;\n\n\tfor (i = 0; i < ARRAY_SIZE(s->counter_val); i++) {\n\t\tdelta = thres - s->counter_val[i];\n\t\tif (delta < 0)\n\t\t\tdelta = -delta;\n\t\tif (delta < min_delta) {\n\t\t\tmin_delta = delta;\n\t\t\tmatch = i;\n\t\t}\n\t}\n\treturn match;\n}\n\n/**\n *\tcxgb4_set_rspq_intr_params - set a queue's interrupt holdoff parameters\n *\t@q: the Rx queue\n *\t@us: the hold-off time in us, or 0 to disable timer\n *\t@cnt: the hold-off packet count, or 0 to disable counter\n *\n *\tSets an Rx queue's interrupt hold-off time and packet count.  At least\n *\tone of the two needs to be enabled for the queue to generate interrupts.\n */\nint cxgb4_set_rspq_intr_params(struct sge_rspq *q,\n\t\t\t       unsigned int us, unsigned int cnt)\n{\n\tstruct adapter *adap = q->adap;\n\n\tif ((us | cnt) == 0)\n\t\tcnt = 1;\n\n\tif (cnt) {\n\t\tint err;\n\t\tu32 v, new_idx;\n\n\t\tnew_idx = closest_thres(&adap->sge, cnt);\n\t\tif (q->desc && q->pktcnt_idx != new_idx) {\n\t\t\t/* the queue has already been created, update it */\n\t\t\tv = FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DMAQ) |\n\t\t\t    FW_PARAMS_PARAM_X_V(\n\t\t\t\t\tFW_PARAMS_PARAM_DMAQ_IQ_INTCNTTHRESH) |\n\t\t\t    FW_PARAMS_PARAM_YZ_V(q->cntxt_id);\n\t\t\terr = t4_set_params(adap, adap->mbox, adap->pf, 0, 1,\n\t\t\t\t\t    &v, &new_idx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tq->pktcnt_idx = new_idx;\n\t}\n\n\tus = us == 0 ? 6 : closest_timer(&adap->sge, us);\n\tq->intr_params = QINTR_TIMER_IDX_V(us) | QINTR_CNT_EN_V(cnt > 0);\n\treturn 0;\n}\n\nstatic int cxgb_set_features(struct net_device *dev, netdev_features_t features)\n{\n\tnetdev_features_t changed = dev->features ^ features;\n\tconst struct port_info *pi = netdev_priv(dev);\n\tint err;\n\n\tif (!(changed & NETIF_F_HW_VLAN_CTAG_RX))\n\t\treturn 0;\n\n\terr = t4_set_rxmode(pi->adapter, pi->adapter->mbox, pi->viid,\n\t\t\t    pi->viid_mirror, -1, -1, -1, -1,\n\t\t\t    !!(features & NETIF_F_HW_VLAN_CTAG_RX), true);\n\tif (unlikely(err))\n\t\tdev->features = features ^ NETIF_F_HW_VLAN_CTAG_RX;\n\treturn err;\n}\n\nstatic int setup_debugfs(struct adapter *adap)\n{\n\tif (IS_ERR_OR_NULL(adap->debugfs_root))\n\t\treturn -1;\n\n#ifdef CONFIG_DEBUG_FS\n\tt4_setup_debugfs(adap);\n#endif\n\treturn 0;\n}\n\nstatic void cxgb4_port_mirror_free_rxq(struct adapter *adap,\n\t\t\t\t       struct sge_eth_rxq *mirror_rxq)\n{\n\tif ((adap->flags & CXGB4_FULL_INIT_DONE) &&\n\t    !(adap->flags & CXGB4_SHUTTING_DOWN))\n\t\tcxgb4_quiesce_rx(&mirror_rxq->rspq);\n\n\tif (adap->flags & CXGB4_USING_MSIX) {\n\t\tcxgb4_clear_msix_aff(mirror_rxq->msix->vec,\n\t\t\t\t     mirror_rxq->msix->aff_mask);\n\t\tfree_irq(mirror_rxq->msix->vec, &mirror_rxq->rspq);\n\t\tcxgb4_free_msix_idx_in_bmap(adap, mirror_rxq->msix->idx);\n\t}\n\n\tfree_rspq_fl(adap, &mirror_rxq->rspq, &mirror_rxq->fl);\n}\n\nstatic int cxgb4_port_mirror_alloc_queues(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct sge_eth_rxq *mirror_rxq;\n\tstruct sge *s = &adap->sge;\n\tint ret = 0, msix = 0;\n\tu16 i, rxqid;\n\tu16 *rss;\n\n\tif (!pi->vi_mirror_count)\n\t\treturn 0;\n\n\tif (s->mirror_rxq[pi->port_id])\n\t\treturn 0;\n\n\tmirror_rxq = kcalloc(pi->nmirrorqsets, sizeof(*mirror_rxq), GFP_KERNEL);\n\tif (!mirror_rxq)\n\t\treturn -ENOMEM;\n\n\ts->mirror_rxq[pi->port_id] = mirror_rxq;\n\n\tif (!(adap->flags & CXGB4_USING_MSIX))\n\t\tmsix = -((int)adap->sge.intrq.abs_id + 1);\n\n\tfor (i = 0, rxqid = 0; i < pi->nmirrorqsets; i++, rxqid++) {\n\t\tmirror_rxq = &s->mirror_rxq[pi->port_id][i];\n\n\t\t/* Allocate Mirror Rxqs */\n\t\tif (msix >= 0) {\n\t\t\tmsix = cxgb4_get_msix_idx_from_bmap(adap);\n\t\t\tif (msix < 0) {\n\t\t\t\tret = msix;\n\t\t\t\tgoto out_free_queues;\n\t\t\t}\n\n\t\t\tmirror_rxq->msix = &adap->msix_info[msix];\n\t\t\tsnprintf(mirror_rxq->msix->desc,\n\t\t\t\t sizeof(mirror_rxq->msix->desc),\n\t\t\t\t \"%s-mirrorrxq%d\", dev->name, i);\n\t\t}\n\n\t\tinit_rspq(adap, &mirror_rxq->rspq,\n\t\t\t  CXGB4_MIRROR_RXQ_DEFAULT_INTR_USEC,\n\t\t\t  CXGB4_MIRROR_RXQ_DEFAULT_PKT_CNT,\n\t\t\t  CXGB4_MIRROR_RXQ_DEFAULT_DESC_NUM,\n\t\t\t  CXGB4_MIRROR_RXQ_DEFAULT_DESC_SIZE);\n\n\t\tmirror_rxq->fl.size = CXGB4_MIRROR_FLQ_DEFAULT_DESC_NUM;\n\n\t\tret = t4_sge_alloc_rxq(adap, &mirror_rxq->rspq, false,\n\t\t\t\t       dev, msix, &mirror_rxq->fl,\n\t\t\t\t       t4_ethrx_handler, NULL, 0);\n\t\tif (ret)\n\t\t\tgoto out_free_msix_idx;\n\n\t\t/* Setup MSI-X vectors for Mirror Rxqs */\n\t\tif (adap->flags & CXGB4_USING_MSIX) {\n\t\t\tret = request_irq(mirror_rxq->msix->vec,\n\t\t\t\t\t  t4_sge_intr_msix, 0,\n\t\t\t\t\t  mirror_rxq->msix->desc,\n\t\t\t\t\t  &mirror_rxq->rspq);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_rxq;\n\n\t\t\tcxgb4_set_msix_aff(adap, mirror_rxq->msix->vec,\n\t\t\t\t\t   &mirror_rxq->msix->aff_mask, i);\n\t\t}\n\n\t\t/* Start NAPI for Mirror Rxqs */\n\t\tcxgb4_enable_rx(adap, &mirror_rxq->rspq);\n\t}\n\n\t/* Setup RSS for Mirror Rxqs */\n\trss = kcalloc(pi->rss_size, sizeof(u16), GFP_KERNEL);\n\tif (!rss) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_queues;\n\t}\n\n\tmirror_rxq = &s->mirror_rxq[pi->port_id][0];\n\tfor (i = 0; i < pi->rss_size; i++)\n\t\trss[i] = mirror_rxq[i % pi->nmirrorqsets].rspq.abs_id;\n\n\tret = cxgb4_config_rss(pi, rss, pi->rss_size, pi->viid_mirror);\n\tkfree(rss);\n\tif (ret)\n\t\tgoto out_free_queues;\n\n\treturn 0;\n\nout_free_rxq:\n\tfree_rspq_fl(adap, &mirror_rxq->rspq, &mirror_rxq->fl);\n\nout_free_msix_idx:\n\tcxgb4_free_msix_idx_in_bmap(adap, mirror_rxq->msix->idx);\n\nout_free_queues:\n\twhile (rxqid-- > 0)\n\t\tcxgb4_port_mirror_free_rxq(adap,\n\t\t\t\t\t   &s->mirror_rxq[pi->port_id][rxqid]);\n\n\tkfree(s->mirror_rxq[pi->port_id]);\n\ts->mirror_rxq[pi->port_id] = NULL;\n\treturn ret;\n}\n\nstatic void cxgb4_port_mirror_free_queues(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct sge *s = &adap->sge;\n\tu16 i;\n\n\tif (!pi->vi_mirror_count)\n\t\treturn;\n\n\tif (!s->mirror_rxq[pi->port_id])\n\t\treturn;\n\n\tfor (i = 0; i < pi->nmirrorqsets; i++)\n\t\tcxgb4_port_mirror_free_rxq(adap,\n\t\t\t\t\t   &s->mirror_rxq[pi->port_id][i]);\n\n\tkfree(s->mirror_rxq[pi->port_id]);\n\ts->mirror_rxq[pi->port_id] = NULL;\n}\n\nstatic int cxgb4_port_mirror_start(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tint ret, idx = -1;\n\n\tif (!pi->vi_mirror_count)\n\t\treturn 0;\n\n\t/* Mirror VIs can be created dynamically after stack had\n\t * already setup Rx modes like MTU, promisc, allmulti, etc.\n\t * on main VI. So, parse what the stack had setup on the\n\t * main VI and update the same on the mirror VI.\n\t */\n\tret = t4_set_rxmode(adap, adap->mbox, pi->viid, pi->viid_mirror,\n\t\t\t    dev->mtu, (dev->flags & IFF_PROMISC) ? 1 : 0,\n\t\t\t    (dev->flags & IFF_ALLMULTI) ? 1 : 0, 1,\n\t\t\t    !!(dev->features & NETIF_F_HW_VLAN_CTAG_RX), true);\n\tif (ret) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Failed start up Rx mode for Mirror VI 0x%x, ret: %d\\n\",\n\t\t\tpi->viid_mirror, ret);\n\t\treturn ret;\n\t}\n\n\t/* Enable replication bit for the device's MAC address\n\t * in MPS TCAM, so that the packets for the main VI are\n\t * replicated to mirror VI.\n\t */\n\tret = cxgb4_update_mac_filt(pi, pi->viid_mirror, &idx,\n\t\t\t\t    dev->dev_addr, true, NULL);\n\tif (ret) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Failed updating MAC filter for Mirror VI 0x%x, ret: %d\\n\",\n\t\t\tpi->viid_mirror, ret);\n\t\treturn ret;\n\t}\n\n\t/* Enabling a Virtual Interface can result in an interrupt\n\t * during the processing of the VI Enable command and, in some\n\t * paths, result in an attempt to issue another command in the\n\t * interrupt context. Thus, we disable interrupts during the\n\t * course of the VI Enable command ...\n\t */\n\tlocal_bh_disable();\n\tret = t4_enable_vi_params(adap, adap->mbox, pi->viid_mirror, true, true,\n\t\t\t\t  false);\n\tlocal_bh_enable();\n\tif (ret)\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Failed starting Mirror VI 0x%x, ret: %d\\n\",\n\t\t\tpi->viid_mirror, ret);\n\n\treturn ret;\n}\n\nstatic void cxgb4_port_mirror_stop(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\n\tif (!pi->vi_mirror_count)\n\t\treturn;\n\n\tt4_enable_vi_params(adap, adap->mbox, pi->viid_mirror, false, false,\n\t\t\t    false);\n}\n\nint cxgb4_port_mirror_alloc(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tint ret = 0;\n\n\tif (!pi->nmirrorqsets)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&pi->vi_mirror_mutex);\n\tif (pi->viid_mirror) {\n\t\tpi->vi_mirror_count++;\n\t\tgoto out_unlock;\n\t}\n\n\tret = t4_init_port_mirror(pi, adap->mbox, pi->port_id, adap->pf, 0,\n\t\t\t\t  &pi->viid_mirror);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tpi->vi_mirror_count = 1;\n\n\tif (adap->flags & CXGB4_FULL_INIT_DONE) {\n\t\tret = cxgb4_port_mirror_alloc_queues(dev);\n\t\tif (ret)\n\t\t\tgoto out_free_vi;\n\n\t\tret = cxgb4_port_mirror_start(dev);\n\t\tif (ret)\n\t\t\tgoto out_free_queues;\n\t}\n\n\tmutex_unlock(&pi->vi_mirror_mutex);\n\treturn 0;\n\nout_free_queues:\n\tcxgb4_port_mirror_free_queues(dev);\n\nout_free_vi:\n\tpi->vi_mirror_count = 0;\n\tt4_free_vi(adap, adap->mbox, adap->pf, 0, pi->viid_mirror);\n\tpi->viid_mirror = 0;\n\nout_unlock:\n\tmutex_unlock(&pi->vi_mirror_mutex);\n\treturn ret;\n}\n\nvoid cxgb4_port_mirror_free(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\n\tmutex_lock(&pi->vi_mirror_mutex);\n\tif (!pi->viid_mirror)\n\t\tgoto out_unlock;\n\n\tif (pi->vi_mirror_count > 1) {\n\t\tpi->vi_mirror_count--;\n\t\tgoto out_unlock;\n\t}\n\n\tcxgb4_port_mirror_stop(dev);\n\tcxgb4_port_mirror_free_queues(dev);\n\n\tpi->vi_mirror_count = 0;\n\tt4_free_vi(adap, adap->mbox, adap->pf, 0, pi->viid_mirror);\n\tpi->viid_mirror = 0;\n\nout_unlock:\n\tmutex_unlock(&pi->vi_mirror_mutex);\n}\n\n/*\n * upper-layer driver support\n */\n\n/*\n * Allocate an active-open TID and set it to the supplied value.\n */\nint cxgb4_alloc_atid(struct tid_info *t, void *data)\n{\n\tint atid = -1;\n\n\tspin_lock_bh(&t->atid_lock);\n\tif (t->afree) {\n\t\tunion aopen_entry *p = t->afree;\n\n\t\tatid = (p - t->atid_tab) + t->atid_base;\n\t\tt->afree = p->next;\n\t\tp->data = data;\n\t\tt->atids_in_use++;\n\t}\n\tspin_unlock_bh(&t->atid_lock);\n\treturn atid;\n}\nEXPORT_SYMBOL(cxgb4_alloc_atid);\n\n/*\n * Release an active-open TID.\n */\nvoid cxgb4_free_atid(struct tid_info *t, unsigned int atid)\n{\n\tunion aopen_entry *p = &t->atid_tab[atid - t->atid_base];\n\n\tspin_lock_bh(&t->atid_lock);\n\tp->next = t->afree;\n\tt->afree = p;\n\tt->atids_in_use--;\n\tspin_unlock_bh(&t->atid_lock);\n}\nEXPORT_SYMBOL(cxgb4_free_atid);\n\n/*\n * Allocate a server TID and set it to the supplied value.\n */\nint cxgb4_alloc_stid(struct tid_info *t, int family, void *data)\n{\n\tint stid;\n\n\tspin_lock_bh(&t->stid_lock);\n\tif (family == PF_INET) {\n\t\tstid = find_first_zero_bit(t->stid_bmap, t->nstids);\n\t\tif (stid < t->nstids)\n\t\t\t__set_bit(stid, t->stid_bmap);\n\t\telse\n\t\t\tstid = -1;\n\t} else {\n\t\tstid = bitmap_find_free_region(t->stid_bmap, t->nstids, 1);\n\t\tif (stid < 0)\n\t\t\tstid = -1;\n\t}\n\tif (stid >= 0) {\n\t\tt->stid_tab[stid].data = data;\n\t\tstid += t->stid_base;\n\t\t/* IPv6 requires max of 520 bits or 16 cells in TCAM\n\t\t * This is equivalent to 4 TIDs. With CLIP enabled it\n\t\t * needs 2 TIDs.\n\t\t */\n\t\tif (family == PF_INET6) {\n\t\t\tt->stids_in_use += 2;\n\t\t\tt->v6_stids_in_use += 2;\n\t\t} else {\n\t\t\tt->stids_in_use++;\n\t\t}\n\t}\n\tspin_unlock_bh(&t->stid_lock);\n\treturn stid;\n}\nEXPORT_SYMBOL(cxgb4_alloc_stid);\n\n/* Allocate a server filter TID and set it to the supplied value.\n */\nint cxgb4_alloc_sftid(struct tid_info *t, int family, void *data)\n{\n\tint stid;\n\n\tspin_lock_bh(&t->stid_lock);\n\tif (family == PF_INET) {\n\t\tstid = find_next_zero_bit(t->stid_bmap,\n\t\t\t\tt->nstids + t->nsftids, t->nstids);\n\t\tif (stid < (t->nstids + t->nsftids))\n\t\t\t__set_bit(stid, t->stid_bmap);\n\t\telse\n\t\t\tstid = -1;\n\t} else {\n\t\tstid = -1;\n\t}\n\tif (stid >= 0) {\n\t\tt->stid_tab[stid].data = data;\n\t\tstid -= t->nstids;\n\t\tstid += t->sftid_base;\n\t\tt->sftids_in_use++;\n\t}\n\tspin_unlock_bh(&t->stid_lock);\n\treturn stid;\n}\nEXPORT_SYMBOL(cxgb4_alloc_sftid);\n\n/* Release a server TID.\n */\nvoid cxgb4_free_stid(struct tid_info *t, unsigned int stid, int family)\n{\n\t/* Is it a server filter TID? */\n\tif (t->nsftids && (stid >= t->sftid_base)) {\n\t\tstid -= t->sftid_base;\n\t\tstid += t->nstids;\n\t} else {\n\t\tstid -= t->stid_base;\n\t}\n\n\tspin_lock_bh(&t->stid_lock);\n\tif (family == PF_INET)\n\t\t__clear_bit(stid, t->stid_bmap);\n\telse\n\t\tbitmap_release_region(t->stid_bmap, stid, 1);\n\tt->stid_tab[stid].data = NULL;\n\tif (stid < t->nstids) {\n\t\tif (family == PF_INET6) {\n\t\t\tt->stids_in_use -= 2;\n\t\t\tt->v6_stids_in_use -= 2;\n\t\t} else {\n\t\t\tt->stids_in_use--;\n\t\t}\n\t} else {\n\t\tt->sftids_in_use--;\n\t}\n\n\tspin_unlock_bh(&t->stid_lock);\n}\nEXPORT_SYMBOL(cxgb4_free_stid);\n\n/*\n * Populate a TID_RELEASE WR.  Caller must properly size the skb.\n */\nstatic void mk_tid_release(struct sk_buff *skb, unsigned int chan,\n\t\t\t   unsigned int tid)\n{\n\tstruct cpl_tid_release *req;\n\n\tset_wr_txq(skb, CPL_PRIORITY_SETUP, chan);\n\treq = __skb_put(skb, sizeof(*req));\n\tINIT_TP_WR(req, tid);\n\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_TID_RELEASE, tid));\n}\n\n/*\n * Queue a TID release request and if necessary schedule a work queue to\n * process it.\n */\nstatic void cxgb4_queue_tid_release(struct tid_info *t, unsigned int chan,\n\t\t\t\t    unsigned int tid)\n{\n\tstruct adapter *adap = container_of(t, struct adapter, tids);\n\tvoid **p = &t->tid_tab[tid - t->tid_base];\n\n\tspin_lock_bh(&adap->tid_release_lock);\n\t*p = adap->tid_release_head;\n\t/* Low 2 bits encode the Tx channel number */\n\tadap->tid_release_head = (void **)((uintptr_t)p | chan);\n\tif (!adap->tid_release_task_busy) {\n\t\tadap->tid_release_task_busy = true;\n\t\tqueue_work(adap->workq, &adap->tid_release_task);\n\t}\n\tspin_unlock_bh(&adap->tid_release_lock);\n}\n\n/*\n * Process the list of pending TID release requests.\n */\nstatic void process_tid_release_list(struct work_struct *work)\n{\n\tstruct sk_buff *skb;\n\tstruct adapter *adap;\n\n\tadap = container_of(work, struct adapter, tid_release_task);\n\n\tspin_lock_bh(&adap->tid_release_lock);\n\twhile (adap->tid_release_head) {\n\t\tvoid **p = adap->tid_release_head;\n\t\tunsigned int chan = (uintptr_t)p & 3;\n\t\tp = (void *)p - chan;\n\n\t\tadap->tid_release_head = *p;\n\t\t*p = NULL;\n\t\tspin_unlock_bh(&adap->tid_release_lock);\n\n\t\twhile (!(skb = alloc_skb(sizeof(struct cpl_tid_release),\n\t\t\t\t\t GFP_KERNEL)))\n\t\t\tschedule_timeout_uninterruptible(1);\n\n\t\tmk_tid_release(skb, chan, p - adap->tids.tid_tab);\n\t\tt4_ofld_send(adap, skb);\n\t\tspin_lock_bh(&adap->tid_release_lock);\n\t}\n\tadap->tid_release_task_busy = false;\n\tspin_unlock_bh(&adap->tid_release_lock);\n}\n\n/*\n * Release a TID and inform HW.  If we are unable to allocate the release\n * message we defer to a work queue.\n */\nvoid cxgb4_remove_tid(struct tid_info *t, unsigned int chan, unsigned int tid,\n\t\t      unsigned short family)\n{\n\tstruct adapter *adap = container_of(t, struct adapter, tids);\n\tstruct sk_buff *skb;\n\n\tWARN_ON(tid_out_of_range(&adap->tids, tid));\n\n\tif (t->tid_tab[tid - adap->tids.tid_base]) {\n\t\tt->tid_tab[tid - adap->tids.tid_base] = NULL;\n\t\tatomic_dec(&t->conns_in_use);\n\t\tif (t->hash_base && (tid >= t->hash_base)) {\n\t\t\tif (family == AF_INET6)\n\t\t\t\tatomic_sub(2, &t->hash_tids_in_use);\n\t\t\telse\n\t\t\t\tatomic_dec(&t->hash_tids_in_use);\n\t\t} else {\n\t\t\tif (family == AF_INET6)\n\t\t\t\tatomic_sub(2, &t->tids_in_use);\n\t\t\telse\n\t\t\t\tatomic_dec(&t->tids_in_use);\n\t\t}\n\t}\n\n\tskb = alloc_skb(sizeof(struct cpl_tid_release), GFP_ATOMIC);\n\tif (likely(skb)) {\n\t\tmk_tid_release(skb, chan, tid);\n\t\tt4_ofld_send(adap, skb);\n\t} else\n\t\tcxgb4_queue_tid_release(t, chan, tid);\n}\nEXPORT_SYMBOL(cxgb4_remove_tid);\n\n/*\n * Allocate and initialize the TID tables.  Returns 0 on success.\n */\nstatic int tid_init(struct tid_info *t)\n{\n\tstruct adapter *adap = container_of(t, struct adapter, tids);\n\tunsigned int max_ftids = t->nftids + t->nsftids;\n\tunsigned int natids = t->natids;\n\tunsigned int hpftid_bmap_size;\n\tunsigned int eotid_bmap_size;\n\tunsigned int stid_bmap_size;\n\tunsigned int ftid_bmap_size;\n\tsize_t size;\n\n\tstid_bmap_size = BITS_TO_LONGS(t->nstids + t->nsftids);\n\tftid_bmap_size = BITS_TO_LONGS(t->nftids);\n\thpftid_bmap_size = BITS_TO_LONGS(t->nhpftids);\n\teotid_bmap_size = BITS_TO_LONGS(t->neotids);\n\tsize = t->ntids * sizeof(*t->tid_tab) +\n\t       natids * sizeof(*t->atid_tab) +\n\t       t->nstids * sizeof(*t->stid_tab) +\n\t       t->nsftids * sizeof(*t->stid_tab) +\n\t       stid_bmap_size * sizeof(long) +\n\t       t->nhpftids * sizeof(*t->hpftid_tab) +\n\t       hpftid_bmap_size * sizeof(long) +\n\t       max_ftids * sizeof(*t->ftid_tab) +\n\t       ftid_bmap_size * sizeof(long) +\n\t       t->neotids * sizeof(*t->eotid_tab) +\n\t       eotid_bmap_size * sizeof(long);\n\n\tt->tid_tab = kvzalloc(size, GFP_KERNEL);\n\tif (!t->tid_tab)\n\t\treturn -ENOMEM;\n\n\tt->atid_tab = (union aopen_entry *)&t->tid_tab[t->ntids];\n\tt->stid_tab = (struct serv_entry *)&t->atid_tab[natids];\n\tt->stid_bmap = (unsigned long *)&t->stid_tab[t->nstids + t->nsftids];\n\tt->hpftid_tab = (struct filter_entry *)&t->stid_bmap[stid_bmap_size];\n\tt->hpftid_bmap = (unsigned long *)&t->hpftid_tab[t->nhpftids];\n\tt->ftid_tab = (struct filter_entry *)&t->hpftid_bmap[hpftid_bmap_size];\n\tt->ftid_bmap = (unsigned long *)&t->ftid_tab[max_ftids];\n\tt->eotid_tab = (struct eotid_entry *)&t->ftid_bmap[ftid_bmap_size];\n\tt->eotid_bmap = (unsigned long *)&t->eotid_tab[t->neotids];\n\tspin_lock_init(&t->stid_lock);\n\tspin_lock_init(&t->atid_lock);\n\tspin_lock_init(&t->ftid_lock);\n\n\tt->stids_in_use = 0;\n\tt->v6_stids_in_use = 0;\n\tt->sftids_in_use = 0;\n\tt->afree = NULL;\n\tt->atids_in_use = 0;\n\tatomic_set(&t->tids_in_use, 0);\n\tatomic_set(&t->conns_in_use, 0);\n\tatomic_set(&t->hash_tids_in_use, 0);\n\tatomic_set(&t->eotids_in_use, 0);\n\n\t/* Setup the free list for atid_tab and clear the stid bitmap. */\n\tif (natids) {\n\t\twhile (--natids)\n\t\t\tt->atid_tab[natids - 1].next = &t->atid_tab[natids];\n\t\tt->afree = t->atid_tab;\n\t}\n\n\tif (is_offload(adap)) {\n\t\tbitmap_zero(t->stid_bmap, t->nstids + t->nsftids);\n\t\t/* Reserve stid 0 for T4/T5 adapters */\n\t\tif (!t->stid_base &&\n\t\t    CHELSIO_CHIP_VERSION(adap->params.chip) <= CHELSIO_T5)\n\t\t\t__set_bit(0, t->stid_bmap);\n\n\t\tif (t->neotids)\n\t\t\tbitmap_zero(t->eotid_bmap, t->neotids);\n\t}\n\n\tif (t->nhpftids)\n\t\tbitmap_zero(t->hpftid_bmap, t->nhpftids);\n\tbitmap_zero(t->ftid_bmap, t->nftids);\n\treturn 0;\n}\n\n/**\n *\tcxgb4_create_server - create an IP server\n *\t@dev: the device\n *\t@stid: the server TID\n *\t@sip: local IP address to bind server to\n *\t@sport: the server's TCP port\n *\t@vlan: the VLAN header information\n *\t@queue: queue to direct messages from this server to\n *\n *\tCreate an IP server for the given port and address.\n *\tReturns <0 on error and one of the %NET_XMIT_* values on success.\n */\nint cxgb4_create_server(const struct net_device *dev, unsigned int stid,\n\t\t\t__be32 sip, __be16 sport, __be16 vlan,\n\t\t\tunsigned int queue)\n{\n\tunsigned int chan;\n\tstruct sk_buff *skb;\n\tstruct adapter *adap;\n\tstruct cpl_pass_open_req *req;\n\tint ret;\n\n\tskb = alloc_skb(sizeof(*req), GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tadap = netdev2adap(dev);\n\treq = __skb_put(skb, sizeof(*req));\n\tINIT_TP_WR(req, 0);\n\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_PASS_OPEN_REQ, stid));\n\treq->local_port = sport;\n\treq->peer_port = htons(0);\n\treq->local_ip = sip;\n\treq->peer_ip = htonl(0);\n\tchan = rxq_to_chan(&adap->sge, queue);\n\treq->opt0 = cpu_to_be64(TX_CHAN_V(chan));\n\treq->opt1 = cpu_to_be64(CONN_POLICY_V(CPL_CONN_POLICY_ASK) |\n\t\t\t\tSYN_RSS_ENABLE_F | SYN_RSS_QUEUE_V(queue));\n\tret = t4_mgmt_tx(adap, skb);\n\treturn net_xmit_eval(ret);\n}\nEXPORT_SYMBOL(cxgb4_create_server);\n\n/*\tcxgb4_create_server6 - create an IPv6 server\n *\t@dev: the device\n *\t@stid: the server TID\n *\t@sip: local IPv6 address to bind server to\n *\t@sport: the server's TCP port\n *\t@queue: queue to direct messages from this server to\n *\n *\tCreate an IPv6 server for the given port and address.\n *\tReturns <0 on error and one of the %NET_XMIT_* values on success.\n */\nint cxgb4_create_server6(const struct net_device *dev, unsigned int stid,\n\t\t\t const struct in6_addr *sip, __be16 sport,\n\t\t\t unsigned int queue)\n{\n\tunsigned int chan;\n\tstruct sk_buff *skb;\n\tstruct adapter *adap;\n\tstruct cpl_pass_open_req6 *req;\n\tint ret;\n\n\tskb = alloc_skb(sizeof(*req), GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tadap = netdev2adap(dev);\n\treq = __skb_put(skb, sizeof(*req));\n\tINIT_TP_WR(req, 0);\n\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_PASS_OPEN_REQ6, stid));\n\treq->local_port = sport;\n\treq->peer_port = htons(0);\n\treq->local_ip_hi = *(__be64 *)(sip->s6_addr);\n\treq->local_ip_lo = *(__be64 *)(sip->s6_addr + 8);\n\treq->peer_ip_hi = cpu_to_be64(0);\n\treq->peer_ip_lo = cpu_to_be64(0);\n\tchan = rxq_to_chan(&adap->sge, queue);\n\treq->opt0 = cpu_to_be64(TX_CHAN_V(chan));\n\treq->opt1 = cpu_to_be64(CONN_POLICY_V(CPL_CONN_POLICY_ASK) |\n\t\t\t\tSYN_RSS_ENABLE_F | SYN_RSS_QUEUE_V(queue));\n\tret = t4_mgmt_tx(adap, skb);\n\treturn net_xmit_eval(ret);\n}\nEXPORT_SYMBOL(cxgb4_create_server6);\n\nint cxgb4_remove_server(const struct net_device *dev, unsigned int stid,\n\t\t\tunsigned int queue, bool ipv6)\n{\n\tstruct sk_buff *skb;\n\tstruct adapter *adap;\n\tstruct cpl_close_listsvr_req *req;\n\tint ret;\n\n\tadap = netdev2adap(dev);\n\n\tskb = alloc_skb(sizeof(*req), GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\treq = __skb_put(skb, sizeof(*req));\n\tINIT_TP_WR(req, 0);\n\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_CLOSE_LISTSRV_REQ, stid));\n\treq->reply_ctrl = htons(NO_REPLY_V(0) | (ipv6 ? LISTSVR_IPV6_V(1) :\n\t\t\t\tLISTSVR_IPV6_V(0)) | QUEUENO_V(queue));\n\tret = t4_mgmt_tx(adap, skb);\n\treturn net_xmit_eval(ret);\n}\nEXPORT_SYMBOL(cxgb4_remove_server);\n\n/**\n *\tcxgb4_best_mtu - find the entry in the MTU table closest to an MTU\n *\t@mtus: the HW MTU table\n *\t@mtu: the target MTU\n *\t@idx: index of selected entry in the MTU table\n *\n *\tReturns the index and the value in the HW MTU table that is closest to\n *\tbut does not exceed @mtu, unless @mtu is smaller than any value in the\n *\ttable, in which case that smallest available value is selected.\n */\nunsigned int cxgb4_best_mtu(const unsigned short *mtus, unsigned short mtu,\n\t\t\t    unsigned int *idx)\n{\n\tunsigned int i = 0;\n\n\twhile (i < NMTUS - 1 && mtus[i + 1] <= mtu)\n\t\t++i;\n\tif (idx)\n\t\t*idx = i;\n\treturn mtus[i];\n}\nEXPORT_SYMBOL(cxgb4_best_mtu);\n\n/**\n *     cxgb4_best_aligned_mtu - find best MTU, [hopefully] data size aligned\n *     @mtus: the HW MTU table\n *     @header_size: Header Size\n *     @data_size_max: maximum Data Segment Size\n *     @data_size_align: desired Data Segment Size Alignment (2^N)\n *     @mtu_idxp: HW MTU Table Index return value pointer (possibly NULL)\n *\n *     Similar to cxgb4_best_mtu() but instead of searching the Hardware\n *     MTU Table based solely on a Maximum MTU parameter, we break that\n *     parameter up into a Header Size and Maximum Data Segment Size, and\n *     provide a desired Data Segment Size Alignment.  If we find an MTU in\n *     the Hardware MTU Table which will result in a Data Segment Size with\n *     the requested alignment _and_ that MTU isn't \"too far\" from the\n *     closest MTU, then we'll return that rather than the closest MTU.\n */\nunsigned int cxgb4_best_aligned_mtu(const unsigned short *mtus,\n\t\t\t\t    unsigned short header_size,\n\t\t\t\t    unsigned short data_size_max,\n\t\t\t\t    unsigned short data_size_align,\n\t\t\t\t    unsigned int *mtu_idxp)\n{\n\tunsigned short max_mtu = header_size + data_size_max;\n\tunsigned short data_size_align_mask = data_size_align - 1;\n\tint mtu_idx, aligned_mtu_idx;\n\n\t/* Scan the MTU Table till we find an MTU which is larger than our\n\t * Maximum MTU or we reach the end of the table.  Along the way,\n\t * record the last MTU found, if any, which will result in a Data\n\t * Segment Length matching the requested alignment.\n\t */\n\tfor (mtu_idx = 0, aligned_mtu_idx = -1; mtu_idx < NMTUS; mtu_idx++) {\n\t\tunsigned short data_size = mtus[mtu_idx] - header_size;\n\n\t\t/* If this MTU minus the Header Size would result in a\n\t\t * Data Segment Size of the desired alignment, remember it.\n\t\t */\n\t\tif ((data_size & data_size_align_mask) == 0)\n\t\t\taligned_mtu_idx = mtu_idx;\n\n\t\t/* If we're not at the end of the Hardware MTU Table and the\n\t\t * next element is larger than our Maximum MTU, drop out of\n\t\t * the loop.\n\t\t */\n\t\tif (mtu_idx+1 < NMTUS && mtus[mtu_idx+1] > max_mtu)\n\t\t\tbreak;\n\t}\n\n\t/* If we fell out of the loop because we ran to the end of the table,\n\t * then we just have to use the last [largest] entry.\n\t */\n\tif (mtu_idx == NMTUS)\n\t\tmtu_idx--;\n\n\t/* If we found an MTU which resulted in the requested Data Segment\n\t * Length alignment and that's \"not far\" from the largest MTU which is\n\t * less than or equal to the maximum MTU, then use that.\n\t */\n\tif (aligned_mtu_idx >= 0 &&\n\t    mtu_idx - aligned_mtu_idx <= 1)\n\t\tmtu_idx = aligned_mtu_idx;\n\n\t/* If the caller has passed in an MTU Index pointer, pass the\n\t * MTU Index back.  Return the MTU value.\n\t */\n\tif (mtu_idxp)\n\t\t*mtu_idxp = mtu_idx;\n\treturn mtus[mtu_idx];\n}\nEXPORT_SYMBOL(cxgb4_best_aligned_mtu);\n\n/**\n *\tcxgb4_port_chan - get the HW channel of a port\n *\t@dev: the net device for the port\n *\n *\tReturn the HW Tx channel of the given port.\n */\nunsigned int cxgb4_port_chan(const struct net_device *dev)\n{\n\treturn netdev2pinfo(dev)->tx_chan;\n}\nEXPORT_SYMBOL(cxgb4_port_chan);\n\n/**\n *      cxgb4_port_e2cchan - get the HW c-channel of a port\n *      @dev: the net device for the port\n *\n *      Return the HW RX c-channel of the given port.\n */\nunsigned int cxgb4_port_e2cchan(const struct net_device *dev)\n{\n\treturn netdev2pinfo(dev)->rx_cchan;\n}\nEXPORT_SYMBOL(cxgb4_port_e2cchan);\n\nunsigned int cxgb4_dbfifo_count(const struct net_device *dev, int lpfifo)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\tu32 v1, v2, lp_count, hp_count;\n\n\tv1 = t4_read_reg(adap, SGE_DBFIFO_STATUS_A);\n\tv2 = t4_read_reg(adap, SGE_DBFIFO_STATUS2_A);\n\tif (is_t4(adap->params.chip)) {\n\t\tlp_count = LP_COUNT_G(v1);\n\t\thp_count = HP_COUNT_G(v1);\n\t} else {\n\t\tlp_count = LP_COUNT_T5_G(v1);\n\t\thp_count = HP_COUNT_T5_G(v2);\n\t}\n\treturn lpfifo ? lp_count : hp_count;\n}\nEXPORT_SYMBOL(cxgb4_dbfifo_count);\n\n/**\n *\tcxgb4_port_viid - get the VI id of a port\n *\t@dev: the net device for the port\n *\n *\tReturn the VI id of the given port.\n */\nunsigned int cxgb4_port_viid(const struct net_device *dev)\n{\n\treturn netdev2pinfo(dev)->viid;\n}\nEXPORT_SYMBOL(cxgb4_port_viid);\n\n/**\n *\tcxgb4_port_idx - get the index of a port\n *\t@dev: the net device for the port\n *\n *\tReturn the index of the given port.\n */\nunsigned int cxgb4_port_idx(const struct net_device *dev)\n{\n\treturn netdev2pinfo(dev)->port_id;\n}\nEXPORT_SYMBOL(cxgb4_port_idx);\n\nvoid cxgb4_get_tcp_stats(struct pci_dev *pdev, struct tp_tcp_stats *v4,\n\t\t\t struct tp_tcp_stats *v6)\n{\n\tstruct adapter *adap = pci_get_drvdata(pdev);\n\n\tspin_lock(&adap->stats_lock);\n\tt4_tp_get_tcp_stats(adap, v4, v6, false);\n\tspin_unlock(&adap->stats_lock);\n}\nEXPORT_SYMBOL(cxgb4_get_tcp_stats);\n\nvoid cxgb4_iscsi_init(struct net_device *dev, unsigned int tag_mask,\n\t\t      const unsigned int *pgsz_order)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\n\tt4_write_reg(adap, ULP_RX_ISCSI_TAGMASK_A, tag_mask);\n\tt4_write_reg(adap, ULP_RX_ISCSI_PSZ_A, HPZ0_V(pgsz_order[0]) |\n\t\t     HPZ1_V(pgsz_order[1]) | HPZ2_V(pgsz_order[2]) |\n\t\t     HPZ3_V(pgsz_order[3]));\n}\nEXPORT_SYMBOL(cxgb4_iscsi_init);\n\nint cxgb4_flush_eq_cache(struct net_device *dev)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\n\treturn t4_sge_ctxt_flush(adap, adap->mbox, CTXT_EGRESS);\n}\nEXPORT_SYMBOL(cxgb4_flush_eq_cache);\n\nstatic int read_eq_indices(struct adapter *adap, u16 qid, u16 *pidx, u16 *cidx)\n{\n\tu32 addr = t4_read_reg(adap, SGE_DBQ_CTXT_BADDR_A) + 24 * qid + 8;\n\t__be64 indices;\n\tint ret;\n\n\tspin_lock(&adap->win0_lock);\n\tret = t4_memory_rw(adap, 0, MEM_EDC0, addr,\n\t\t\t   sizeof(indices), (__be32 *)&indices,\n\t\t\t   T4_MEMORY_READ);\n\tspin_unlock(&adap->win0_lock);\n\tif (!ret) {\n\t\t*cidx = (be64_to_cpu(indices) >> 25) & 0xffff;\n\t\t*pidx = (be64_to_cpu(indices) >> 9) & 0xffff;\n\t}\n\treturn ret;\n}\n\nint cxgb4_sync_txq_pidx(struct net_device *dev, u16 qid, u16 pidx,\n\t\t\tu16 size)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\tu16 hw_pidx, hw_cidx;\n\tint ret;\n\n\tret = read_eq_indices(adap, qid, &hw_pidx, &hw_cidx);\n\tif (ret)\n\t\tgoto out;\n\n\tif (pidx != hw_pidx) {\n\t\tu16 delta;\n\t\tu32 val;\n\n\t\tif (pidx >= hw_pidx)\n\t\t\tdelta = pidx - hw_pidx;\n\t\telse\n\t\t\tdelta = size - hw_pidx + pidx;\n\n\t\tif (is_t4(adap->params.chip))\n\t\t\tval = PIDX_V(delta);\n\t\telse\n\t\t\tval = PIDX_T5_V(delta);\n\t\twmb();\n\t\tt4_write_reg(adap, MYPF_REG(SGE_PF_KDOORBELL_A),\n\t\t\t     QID_V(qid) | val);\n\t}\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL(cxgb4_sync_txq_pidx);\n\nint cxgb4_read_tpte(struct net_device *dev, u32 stag, __be32 *tpte)\n{\n\tu32 edc0_size, edc1_size, mc0_size, mc1_size, size;\n\tu32 edc0_end, edc1_end, mc0_end, mc1_end;\n\tu32 offset, memtype, memaddr;\n\tstruct adapter *adap;\n\tu32 hma_size = 0;\n\tint ret;\n\n\tadap = netdev2adap(dev);\n\n\toffset = ((stag >> 8) * 32) + adap->vres.stag.start;\n\n\t/* Figure out where the offset lands in the Memory Type/Address scheme.\n\t * This code assumes that the memory is laid out starting at offset 0\n\t * with no breaks as: EDC0, EDC1, MC0, MC1. All cards have both EDC0\n\t * and EDC1.  Some cards will have neither MC0 nor MC1, most cards have\n\t * MC0, and some have both MC0 and MC1.\n\t */\n\tsize = t4_read_reg(adap, MA_EDRAM0_BAR_A);\n\tedc0_size = EDRAM0_SIZE_G(size) << 20;\n\tsize = t4_read_reg(adap, MA_EDRAM1_BAR_A);\n\tedc1_size = EDRAM1_SIZE_G(size) << 20;\n\tsize = t4_read_reg(adap, MA_EXT_MEMORY0_BAR_A);\n\tmc0_size = EXT_MEM0_SIZE_G(size) << 20;\n\n\tif (t4_read_reg(adap, MA_TARGET_MEM_ENABLE_A) & HMA_MUX_F) {\n\t\tsize = t4_read_reg(adap, MA_EXT_MEMORY1_BAR_A);\n\t\thma_size = EXT_MEM1_SIZE_G(size) << 20;\n\t}\n\tedc0_end = edc0_size;\n\tedc1_end = edc0_end + edc1_size;\n\tmc0_end = edc1_end + mc0_size;\n\n\tif (offset < edc0_end) {\n\t\tmemtype = MEM_EDC0;\n\t\tmemaddr = offset;\n\t} else if (offset < edc1_end) {\n\t\tmemtype = MEM_EDC1;\n\t\tmemaddr = offset - edc0_end;\n\t} else {\n\t\tif (hma_size && (offset < (edc1_end + hma_size))) {\n\t\t\tmemtype = MEM_HMA;\n\t\t\tmemaddr = offset - edc1_end;\n\t\t} else if (offset < mc0_end) {\n\t\t\tmemtype = MEM_MC0;\n\t\t\tmemaddr = offset - edc1_end;\n\t\t} else if (is_t5(adap->params.chip)) {\n\t\t\tsize = t4_read_reg(adap, MA_EXT_MEMORY1_BAR_A);\n\t\t\tmc1_size = EXT_MEM1_SIZE_G(size) << 20;\n\t\t\tmc1_end = mc0_end + mc1_size;\n\t\t\tif (offset < mc1_end) {\n\t\t\t\tmemtype = MEM_MC1;\n\t\t\t\tmemaddr = offset - mc0_end;\n\t\t\t} else {\n\t\t\t\t/* offset beyond the end of any memory */\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\t/* T4/T6 only has a single memory channel */\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tspin_lock(&adap->win0_lock);\n\tret = t4_memory_rw(adap, 0, memtype, memaddr, 32, tpte, T4_MEMORY_READ);\n\tspin_unlock(&adap->win0_lock);\n\treturn ret;\n\nerr:\n\tdev_err(adap->pdev_dev, \"stag %#x, offset %#x out of range\\n\",\n\t\tstag, offset);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(cxgb4_read_tpte);\n\nu64 cxgb4_read_sge_timestamp(struct net_device *dev)\n{\n\tu32 hi, lo;\n\tstruct adapter *adap;\n\n\tadap = netdev2adap(dev);\n\tlo = t4_read_reg(adap, SGE_TIMESTAMP_LO_A);\n\thi = TSVAL_G(t4_read_reg(adap, SGE_TIMESTAMP_HI_A));\n\n\treturn ((u64)hi << 32) | (u64)lo;\n}\nEXPORT_SYMBOL(cxgb4_read_sge_timestamp);\n\nint cxgb4_bar2_sge_qregs(struct net_device *dev,\n\t\t\t unsigned int qid,\n\t\t\t enum cxgb4_bar2_qtype qtype,\n\t\t\t int user,\n\t\t\t u64 *pbar2_qoffset,\n\t\t\t unsigned int *pbar2_qid)\n{\n\treturn t4_bar2_sge_qregs(netdev2adap(dev),\n\t\t\t\t qid,\n\t\t\t\t (qtype == CXGB4_BAR2_QTYPE_EGRESS\n\t\t\t\t  ? T4_BAR2_QTYPE_EGRESS\n\t\t\t\t  : T4_BAR2_QTYPE_INGRESS),\n\t\t\t\t user,\n\t\t\t\t pbar2_qoffset,\n\t\t\t\t pbar2_qid);\n}\nEXPORT_SYMBOL(cxgb4_bar2_sge_qregs);\n\nstatic struct pci_driver cxgb4_driver;\n\nstatic void check_neigh_update(struct neighbour *neigh)\n{\n\tconst struct device *parent;\n\tconst struct net_device *netdev = neigh->dev;\n\n\tif (is_vlan_dev(netdev))\n\t\tnetdev = vlan_dev_real_dev(netdev);\n\tparent = netdev->dev.parent;\n\tif (parent && parent->driver == &cxgb4_driver.driver)\n\t\tt4_l2t_update(dev_get_drvdata(parent), neigh);\n}\n\nstatic int netevent_cb(struct notifier_block *nb, unsigned long event,\n\t\t       void *data)\n{\n\tswitch (event) {\n\tcase NETEVENT_NEIGH_UPDATE:\n\t\tcheck_neigh_update(data);\n\t\tbreak;\n\tcase NETEVENT_REDIRECT:\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic bool netevent_registered;\nstatic struct notifier_block cxgb4_netevent_nb = {\n\t.notifier_call = netevent_cb\n};\n\nstatic void drain_db_fifo(struct adapter *adap, int usecs)\n{\n\tu32 v1, v2, lp_count, hp_count;\n\n\tdo {\n\t\tv1 = t4_read_reg(adap, SGE_DBFIFO_STATUS_A);\n\t\tv2 = t4_read_reg(adap, SGE_DBFIFO_STATUS2_A);\n\t\tif (is_t4(adap->params.chip)) {\n\t\t\tlp_count = LP_COUNT_G(v1);\n\t\t\thp_count = HP_COUNT_G(v1);\n\t\t} else {\n\t\t\tlp_count = LP_COUNT_T5_G(v1);\n\t\t\thp_count = HP_COUNT_T5_G(v2);\n\t\t}\n\n\t\tif (lp_count == 0 && hp_count == 0)\n\t\t\tbreak;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(usecs_to_jiffies(usecs));\n\t} while (1);\n}\n\nstatic void disable_txq_db(struct sge_txq *q)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&q->db_lock, flags);\n\tq->db_disabled = 1;\n\tspin_unlock_irqrestore(&q->db_lock, flags);\n}\n\nstatic void enable_txq_db(struct adapter *adap, struct sge_txq *q)\n{\n\tspin_lock_irq(&q->db_lock);\n\tif (q->db_pidx_inc) {\n\t\t/* Make sure that all writes to the TX descriptors\n\t\t * are committed before we tell HW about them.\n\t\t */\n\t\twmb();\n\t\tt4_write_reg(adap, MYPF_REG(SGE_PF_KDOORBELL_A),\n\t\t\t     QID_V(q->cntxt_id) | PIDX_V(q->db_pidx_inc));\n\t\tq->db_pidx_inc = 0;\n\t}\n\tq->db_disabled = 0;\n\tspin_unlock_irq(&q->db_lock);\n}\n\nstatic void disable_dbs(struct adapter *adap)\n{\n\tint i;\n\n\tfor_each_ethrxq(&adap->sge, i)\n\t\tdisable_txq_db(&adap->sge.ethtxq[i].q);\n\tif (is_offload(adap)) {\n\t\tstruct sge_uld_txq_info *txq_info =\n\t\t\tadap->sge.uld_txq_info[CXGB4_TX_OFLD];\n\n\t\tif (txq_info) {\n\t\t\tfor_each_ofldtxq(&adap->sge, i) {\n\t\t\t\tstruct sge_uld_txq *txq = &txq_info->uldtxq[i];\n\n\t\t\t\tdisable_txq_db(&txq->q);\n\t\t\t}\n\t\t}\n\t}\n\tfor_each_port(adap, i)\n\t\tdisable_txq_db(&adap->sge.ctrlq[i].q);\n}\n\nstatic void enable_dbs(struct adapter *adap)\n{\n\tint i;\n\n\tfor_each_ethrxq(&adap->sge, i)\n\t\tenable_txq_db(adap, &adap->sge.ethtxq[i].q);\n\tif (is_offload(adap)) {\n\t\tstruct sge_uld_txq_info *txq_info =\n\t\t\tadap->sge.uld_txq_info[CXGB4_TX_OFLD];\n\n\t\tif (txq_info) {\n\t\t\tfor_each_ofldtxq(&adap->sge, i) {\n\t\t\t\tstruct sge_uld_txq *txq = &txq_info->uldtxq[i];\n\n\t\t\t\tenable_txq_db(adap, &txq->q);\n\t\t\t}\n\t\t}\n\t}\n\tfor_each_port(adap, i)\n\t\tenable_txq_db(adap, &adap->sge.ctrlq[i].q);\n}\n\nstatic void notify_rdma_uld(struct adapter *adap, enum cxgb4_control cmd)\n{\n\tenum cxgb4_uld type = CXGB4_ULD_RDMA;\n\n\tif (adap->uld && adap->uld[type].handle)\n\t\tadap->uld[type].control(adap->uld[type].handle, cmd);\n}\n\nstatic void process_db_full(struct work_struct *work)\n{\n\tstruct adapter *adap;\n\n\tadap = container_of(work, struct adapter, db_full_task);\n\n\tdrain_db_fifo(adap, dbfifo_drain_delay);\n\tenable_dbs(adap);\n\tnotify_rdma_uld(adap, CXGB4_CONTROL_DB_EMPTY);\n\tif (CHELSIO_CHIP_VERSION(adap->params.chip) <= CHELSIO_T5)\n\t\tt4_set_reg_field(adap, SGE_INT_ENABLE3_A,\n\t\t\t\t DBFIFO_HP_INT_F | DBFIFO_LP_INT_F,\n\t\t\t\t DBFIFO_HP_INT_F | DBFIFO_LP_INT_F);\n\telse\n\t\tt4_set_reg_field(adap, SGE_INT_ENABLE3_A,\n\t\t\t\t DBFIFO_LP_INT_F, DBFIFO_LP_INT_F);\n}\n\nstatic void sync_txq_pidx(struct adapter *adap, struct sge_txq *q)\n{\n\tu16 hw_pidx, hw_cidx;\n\tint ret;\n\n\tspin_lock_irq(&q->db_lock);\n\tret = read_eq_indices(adap, (u16)q->cntxt_id, &hw_pidx, &hw_cidx);\n\tif (ret)\n\t\tgoto out;\n\tif (q->db_pidx != hw_pidx) {\n\t\tu16 delta;\n\t\tu32 val;\n\n\t\tif (q->db_pidx >= hw_pidx)\n\t\t\tdelta = q->db_pidx - hw_pidx;\n\t\telse\n\t\t\tdelta = q->size - hw_pidx + q->db_pidx;\n\n\t\tif (is_t4(adap->params.chip))\n\t\t\tval = PIDX_V(delta);\n\t\telse\n\t\t\tval = PIDX_T5_V(delta);\n\t\twmb();\n\t\tt4_write_reg(adap, MYPF_REG(SGE_PF_KDOORBELL_A),\n\t\t\t     QID_V(q->cntxt_id) | val);\n\t}\nout:\n\tq->db_disabled = 0;\n\tq->db_pidx_inc = 0;\n\tspin_unlock_irq(&q->db_lock);\n\tif (ret)\n\t\tCH_WARN(adap, \"DB drop recovery failed.\\n\");\n}\n\nstatic void recover_all_queues(struct adapter *adap)\n{\n\tint i;\n\n\tfor_each_ethrxq(&adap->sge, i)\n\t\tsync_txq_pidx(adap, &adap->sge.ethtxq[i].q);\n\tif (is_offload(adap)) {\n\t\tstruct sge_uld_txq_info *txq_info =\n\t\t\tadap->sge.uld_txq_info[CXGB4_TX_OFLD];\n\t\tif (txq_info) {\n\t\t\tfor_each_ofldtxq(&adap->sge, i) {\n\t\t\t\tstruct sge_uld_txq *txq = &txq_info->uldtxq[i];\n\n\t\t\t\tsync_txq_pidx(adap, &txq->q);\n\t\t\t}\n\t\t}\n\t}\n\tfor_each_port(adap, i)\n\t\tsync_txq_pidx(adap, &adap->sge.ctrlq[i].q);\n}\n\nstatic void process_db_drop(struct work_struct *work)\n{\n\tstruct adapter *adap;\n\n\tadap = container_of(work, struct adapter, db_drop_task);\n\n\tif (is_t4(adap->params.chip)) {\n\t\tdrain_db_fifo(adap, dbfifo_drain_delay);\n\t\tnotify_rdma_uld(adap, CXGB4_CONTROL_DB_DROP);\n\t\tdrain_db_fifo(adap, dbfifo_drain_delay);\n\t\trecover_all_queues(adap);\n\t\tdrain_db_fifo(adap, dbfifo_drain_delay);\n\t\tenable_dbs(adap);\n\t\tnotify_rdma_uld(adap, CXGB4_CONTROL_DB_EMPTY);\n\t} else if (is_t5(adap->params.chip)) {\n\t\tu32 dropped_db = t4_read_reg(adap, 0x010ac);\n\t\tu16 qid = (dropped_db >> 15) & 0x1ffff;\n\t\tu16 pidx_inc = dropped_db & 0x1fff;\n\t\tu64 bar2_qoffset;\n\t\tunsigned int bar2_qid;\n\t\tint ret;\n\n\t\tret = t4_bar2_sge_qregs(adap, qid, T4_BAR2_QTYPE_EGRESS,\n\t\t\t\t\t0, &bar2_qoffset, &bar2_qid);\n\t\tif (ret)\n\t\t\tdev_err(adap->pdev_dev, \"doorbell drop recovery: \"\n\t\t\t\t\"qid=%d, pidx_inc=%d\\n\", qid, pidx_inc);\n\t\telse\n\t\t\twritel(PIDX_T5_V(pidx_inc) | QID_V(bar2_qid),\n\t\t\t       adap->bar2 + bar2_qoffset + SGE_UDB_KDOORBELL);\n\n\t\t/* Re-enable BAR2 WC */\n\t\tt4_set_reg_field(adap, 0x10b0, 1<<15, 1<<15);\n\t}\n\n\tif (CHELSIO_CHIP_VERSION(adap->params.chip) <= CHELSIO_T5)\n\t\tt4_set_reg_field(adap, SGE_DOORBELL_CONTROL_A, DROPPED_DB_F, 0);\n}\n\nvoid t4_db_full(struct adapter *adap)\n{\n\tif (is_t4(adap->params.chip)) {\n\t\tdisable_dbs(adap);\n\t\tnotify_rdma_uld(adap, CXGB4_CONTROL_DB_FULL);\n\t\tt4_set_reg_field(adap, SGE_INT_ENABLE3_A,\n\t\t\t\t DBFIFO_HP_INT_F | DBFIFO_LP_INT_F, 0);\n\t\tqueue_work(adap->workq, &adap->db_full_task);\n\t}\n}\n\nvoid t4_db_dropped(struct adapter *adap)\n{\n\tif (is_t4(adap->params.chip)) {\n\t\tdisable_dbs(adap);\n\t\tnotify_rdma_uld(adap, CXGB4_CONTROL_DB_FULL);\n\t}\n\tqueue_work(adap->workq, &adap->db_drop_task);\n}\n\nvoid t4_register_netevent_notifier(void)\n{\n\tif (!netevent_registered) {\n\t\tregister_netevent_notifier(&cxgb4_netevent_nb);\n\t\tnetevent_registered = true;\n\t}\n}\n\nstatic void detach_ulds(struct adapter *adap)\n{\n\tunsigned int i;\n\n\tmutex_lock(&uld_mutex);\n\tlist_del(&adap->list_node);\n\n\tfor (i = 0; i < CXGB4_ULD_MAX; i++)\n\t\tif (adap->uld && adap->uld[i].handle)\n\t\t\tadap->uld[i].state_change(adap->uld[i].handle,\n\t\t\t\t\t     CXGB4_STATE_DETACH);\n\n\tif (netevent_registered && list_empty(&adapter_list)) {\n\t\tunregister_netevent_notifier(&cxgb4_netevent_nb);\n\t\tnetevent_registered = false;\n\t}\n\tmutex_unlock(&uld_mutex);\n}\n\nstatic void notify_ulds(struct adapter *adap, enum cxgb4_state new_state)\n{\n\tunsigned int i;\n\n\tmutex_lock(&uld_mutex);\n\tfor (i = 0; i < CXGB4_ULD_MAX; i++)\n\t\tif (adap->uld && adap->uld[i].handle)\n\t\t\tadap->uld[i].state_change(adap->uld[i].handle,\n\t\t\t\t\t\t  new_state);\n\tmutex_unlock(&uld_mutex);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int cxgb4_inet6addr_handler(struct notifier_block *this,\n\t\t\t\t   unsigned long event, void *data)\n{\n\tstruct inet6_ifaddr *ifa = data;\n\tstruct net_device *event_dev = ifa->idev->dev;\n\tconst struct device *parent = NULL;\n#if IS_ENABLED(CONFIG_BONDING)\n\tstruct adapter *adap;\n#endif\n\tif (is_vlan_dev(event_dev))\n\t\tevent_dev = vlan_dev_real_dev(event_dev);\n#if IS_ENABLED(CONFIG_BONDING)\n\tif (event_dev->flags & IFF_MASTER) {\n\t\tlist_for_each_entry(adap, &adapter_list, list_node) {\n\t\t\tswitch (event) {\n\t\t\tcase NETDEV_UP:\n\t\t\t\tcxgb4_clip_get(adap->port[0],\n\t\t\t\t\t       (const u32 *)ifa, 1);\n\t\t\t\tbreak;\n\t\t\tcase NETDEV_DOWN:\n\t\t\t\tcxgb4_clip_release(adap->port[0],\n\t\t\t\t\t\t   (const u32 *)ifa, 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn NOTIFY_OK;\n\t}\n#endif\n\n\tif (event_dev)\n\t\tparent = event_dev->dev.parent;\n\n\tif (parent && parent->driver == &cxgb4_driver.driver) {\n\t\tswitch (event) {\n\t\tcase NETDEV_UP:\n\t\t\tcxgb4_clip_get(event_dev, (const u32 *)ifa, 1);\n\t\t\tbreak;\n\t\tcase NETDEV_DOWN:\n\t\t\tcxgb4_clip_release(event_dev, (const u32 *)ifa, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic bool inet6addr_registered;\nstatic struct notifier_block cxgb4_inet6addr_notifier = {\n\t.notifier_call = cxgb4_inet6addr_handler\n};\n\nstatic void update_clip(const struct adapter *adap)\n{\n\tint i;\n\tstruct net_device *dev;\n\tint ret;\n\n\trcu_read_lock();\n\n\tfor (i = 0; i < MAX_NPORTS; i++) {\n\t\tdev = adap->port[i];\n\t\tret = 0;\n\n\t\tif (dev)\n\t\t\tret = cxgb4_update_root_dev_clip(dev);\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}\n#endif /* IS_ENABLED(CONFIG_IPV6) */\n\n/**\n *\tcxgb_up - enable the adapter\n *\t@adap: adapter being enabled\n *\n *\tCalled when the first port is enabled, this function performs the\n *\tactions necessary to make an adapter operational, such as completing\n *\tthe initialization of HW modules, and enabling interrupts.\n *\n *\tMust be called with the rtnl lock held.\n */\nstatic int cxgb_up(struct adapter *adap)\n{\n\tstruct sge *s = &adap->sge;\n\tint err;\n\n\tmutex_lock(&uld_mutex);\n\terr = setup_sge_queues(adap);\n\tif (err)\n\t\tgoto rel_lock;\n\terr = setup_rss(adap);\n\tif (err)\n\t\tgoto freeq;\n\n\tif (adap->flags & CXGB4_USING_MSIX) {\n\t\tif (s->nd_msix_idx < 0) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto irq_err;\n\t\t}\n\n\t\terr = request_irq(adap->msix_info[s->nd_msix_idx].vec,\n\t\t\t\t  t4_nondata_intr, 0,\n\t\t\t\t  adap->msix_info[s->nd_msix_idx].desc, adap);\n\t\tif (err)\n\t\t\tgoto irq_err;\n\n\t\terr = request_msix_queue_irqs(adap);\n\t\tif (err)\n\t\t\tgoto irq_err_free_nd_msix;\n\t} else {\n\t\terr = request_irq(adap->pdev->irq, t4_intr_handler(adap),\n\t\t\t\t  (adap->flags & CXGB4_USING_MSI) ? 0\n\t\t\t\t\t\t\t\t  : IRQF_SHARED,\n\t\t\t\t  adap->port[0]->name, adap);\n\t\tif (err)\n\t\t\tgoto irq_err;\n\t}\n\n\tenable_rx(adap);\n\tt4_sge_start(adap);\n\tt4_intr_enable(adap);\n\tadap->flags |= CXGB4_FULL_INIT_DONE;\n\tmutex_unlock(&uld_mutex);\n\n\tnotify_ulds(adap, CXGB4_STATE_UP);\n#if IS_ENABLED(CONFIG_IPV6)\n\tupdate_clip(adap);\n#endif\n\treturn err;\n\nirq_err_free_nd_msix:\n\tfree_irq(adap->msix_info[s->nd_msix_idx].vec, adap);\nirq_err:\n\tdev_err(adap->pdev_dev, \"request_irq failed, err %d\\n\", err);\nfreeq:\n\tt4_free_sge_resources(adap);\nrel_lock:\n\tmutex_unlock(&uld_mutex);\n\treturn err;\n}\n\nstatic void cxgb_down(struct adapter *adapter)\n{\n\tcancel_work_sync(&adapter->tid_release_task);\n\tcancel_work_sync(&adapter->db_full_task);\n\tcancel_work_sync(&adapter->db_drop_task);\n\tadapter->tid_release_task_busy = false;\n\tadapter->tid_release_head = NULL;\n\n\tt4_sge_stop(adapter);\n\tt4_free_sge_resources(adapter);\n\n\tadapter->flags &= ~CXGB4_FULL_INIT_DONE;\n}\n\n/*\n * net_device operations\n */\nint cxgb_open(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tint err;\n\n\tnetif_carrier_off(dev);\n\n\tif (!(adapter->flags & CXGB4_FULL_INIT_DONE)) {\n\t\terr = cxgb_up(adapter);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t/* It's possible that the basic port information could have\n\t * changed since we first read it.\n\t */\n\terr = t4_update_port_info(pi);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = link_start(dev);\n\tif (err)\n\t\treturn err;\n\n\tif (pi->nmirrorqsets) {\n\t\tmutex_lock(&pi->vi_mirror_mutex);\n\t\terr = cxgb4_port_mirror_alloc_queues(dev);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\n\t\terr = cxgb4_port_mirror_start(dev);\n\t\tif (err)\n\t\t\tgoto out_free_queues;\n\t\tmutex_unlock(&pi->vi_mirror_mutex);\n\t}\n\n\tnetif_tx_start_all_queues(dev);\n\treturn 0;\n\nout_free_queues:\n\tcxgb4_port_mirror_free_queues(dev);\n\nout_unlock:\n\tmutex_unlock(&pi->vi_mirror_mutex);\n\treturn err;\n}\n\nint cxgb_close(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tint ret;\n\n\tnetif_tx_stop_all_queues(dev);\n\tnetif_carrier_off(dev);\n\tret = t4_enable_pi_params(adapter, adapter->pf, pi,\n\t\t\t\t  false, false, false);\n#ifdef CONFIG_CHELSIO_T4_DCB\n\tcxgb4_dcb_reset(dev);\n\tdcb_tx_queue_prio_enable(dev, false);\n#endif\n\tif (ret)\n\t\treturn ret;\n\n\tif (pi->nmirrorqsets) {\n\t\tmutex_lock(&pi->vi_mirror_mutex);\n\t\tcxgb4_port_mirror_stop(dev);\n\t\tcxgb4_port_mirror_free_queues(dev);\n\t\tmutex_unlock(&pi->vi_mirror_mutex);\n\t}\n\n\treturn 0;\n}\n\nint cxgb4_create_server_filter(const struct net_device *dev, unsigned int stid,\n\t\t__be32 sip, __be16 sport, __be16 vlan,\n\t\tunsigned int queue, unsigned char port, unsigned char mask)\n{\n\tint ret;\n\tstruct filter_entry *f;\n\tstruct adapter *adap;\n\tint i;\n\tu8 *val;\n\n\tadap = netdev2adap(dev);\n\n\t/* Adjust stid to correct filter index */\n\tstid -= adap->tids.sftid_base;\n\tstid += adap->tids.nftids;\n\n\t/* Check to make sure the filter requested is writable ...\n\t */\n\tf = &adap->tids.ftid_tab[stid];\n\tret = writable_filter(f);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Clear out any old resources being used by the filter before\n\t * we start constructing the new filter.\n\t */\n\tif (f->valid)\n\t\tclear_filter(adap, f);\n\n\t/* Clear out filter specifications */\n\tmemset(&f->fs, 0, sizeof(struct ch_filter_specification));\n\tf->fs.val.lport = be16_to_cpu(sport);\n\tf->fs.mask.lport  = ~0;\n\tval = (u8 *)&sip;\n\tif ((val[0] | val[1] | val[2] | val[3]) != 0) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tf->fs.val.lip[i] = val[i];\n\t\t\tf->fs.mask.lip[i] = ~0;\n\t\t}\n\t\tif (adap->params.tp.vlan_pri_map & PORT_F) {\n\t\t\tf->fs.val.iport = port;\n\t\t\tf->fs.mask.iport = mask;\n\t\t}\n\t}\n\n\tif (adap->params.tp.vlan_pri_map & PROTOCOL_F) {\n\t\tf->fs.val.proto = IPPROTO_TCP;\n\t\tf->fs.mask.proto = ~0;\n\t}\n\n\tf->fs.dirsteer = 1;\n\tf->fs.iq = queue;\n\t/* Mark filter as locked */\n\tf->locked = 1;\n\tf->fs.rpttid = 1;\n\n\t/* Save the actual tid. We need this to get the corresponding\n\t * filter entry structure in filter_rpl.\n\t */\n\tf->tid = stid + adap->tids.ftid_base;\n\tret = set_filter_wr(adap, stid);\n\tif (ret) {\n\t\tclear_filter(adap, f);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cxgb4_create_server_filter);\n\nint cxgb4_remove_server_filter(const struct net_device *dev, unsigned int stid,\n\t\tunsigned int queue, bool ipv6)\n{\n\tstruct filter_entry *f;\n\tstruct adapter *adap;\n\n\tadap = netdev2adap(dev);\n\n\t/* Adjust stid to correct filter index */\n\tstid -= adap->tids.sftid_base;\n\tstid += adap->tids.nftids;\n\n\tf = &adap->tids.ftid_tab[stid];\n\t/* Unlock the filter */\n\tf->locked = 0;\n\n\treturn delete_filter(adap, stid);\n}\nEXPORT_SYMBOL(cxgb4_remove_server_filter);\n\nstatic void cxgb_get_stats(struct net_device *dev,\n\t\t\t   struct rtnl_link_stats64 *ns)\n{\n\tstruct port_stats stats;\n\tstruct port_info *p = netdev_priv(dev);\n\tstruct adapter *adapter = p->adapter;\n\n\t/* Block retrieving statistics during EEH error\n\t * recovery. Otherwise, the recovery might fail\n\t * and the PCI device will be removed permanently\n\t */\n\tspin_lock(&adapter->stats_lock);\n\tif (!netif_device_present(dev)) {\n\t\tspin_unlock(&adapter->stats_lock);\n\t\treturn;\n\t}\n\tt4_get_port_stats_offset(adapter, p->tx_chan, &stats,\n\t\t\t\t &p->stats_base);\n\tspin_unlock(&adapter->stats_lock);\n\n\tns->tx_bytes   = stats.tx_octets;\n\tns->tx_packets = stats.tx_frames;\n\tns->rx_bytes   = stats.rx_octets;\n\tns->rx_packets = stats.rx_frames;\n\tns->multicast  = stats.rx_mcast_frames;\n\n\t/* detailed rx_errors */\n\tns->rx_length_errors = stats.rx_jabber + stats.rx_too_long +\n\t\t\t       stats.rx_runt;\n\tns->rx_over_errors   = 0;\n\tns->rx_crc_errors    = stats.rx_fcs_err;\n\tns->rx_frame_errors  = stats.rx_symbol_err;\n\tns->rx_dropped\t     = stats.rx_ovflow0 + stats.rx_ovflow1 +\n\t\t\t       stats.rx_ovflow2 + stats.rx_ovflow3 +\n\t\t\t       stats.rx_trunc0 + stats.rx_trunc1 +\n\t\t\t       stats.rx_trunc2 + stats.rx_trunc3;\n\tns->rx_missed_errors = 0;\n\n\t/* detailed tx_errors */\n\tns->tx_aborted_errors   = 0;\n\tns->tx_carrier_errors   = 0;\n\tns->tx_fifo_errors      = 0;\n\tns->tx_heartbeat_errors = 0;\n\tns->tx_window_errors    = 0;\n\n\tns->tx_errors = stats.tx_error_frames;\n\tns->rx_errors = stats.rx_symbol_err + stats.rx_fcs_err +\n\t\tns->rx_length_errors + stats.rx_len_err + ns->rx_fifo_errors;\n}\n\nstatic int cxgb_ioctl(struct net_device *dev, struct ifreq *req, int cmd)\n{\n\tunsigned int mbox;\n\tint ret = 0, prtad, devad;\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tstruct mii_ioctl_data *data = (struct mii_ioctl_data *)&req->ifr_data;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tif (pi->mdio_addr < 0)\n\t\t\treturn -EOPNOTSUPP;\n\t\tdata->phy_id = pi->mdio_addr;\n\t\tbreak;\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\tif (mdio_phy_id_is_c45(data->phy_id)) {\n\t\t\tprtad = mdio_phy_id_prtad(data->phy_id);\n\t\t\tdevad = mdio_phy_id_devad(data->phy_id);\n\t\t} else if (data->phy_id < 32) {\n\t\t\tprtad = data->phy_id;\n\t\t\tdevad = 0;\n\t\t\tdata->reg_num &= 0x1f;\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\tmbox = pi->adapter->pf;\n\t\tif (cmd == SIOCGMIIREG)\n\t\t\tret = t4_mdio_rd(pi->adapter, mbox, prtad, devad,\n\t\t\t\t\t data->reg_num, &data->val_out);\n\t\telse\n\t\t\tret = t4_mdio_wr(pi->adapter, mbox, prtad, devad,\n\t\t\t\t\t data->reg_num, data->val_in);\n\t\tbreak;\n\tcase SIOCGHWTSTAMP:\n\t\treturn copy_to_user(req->ifr_data, &pi->tstamp_config,\n\t\t\t\t    sizeof(pi->tstamp_config)) ?\n\t\t\t-EFAULT : 0;\n\tcase SIOCSHWTSTAMP:\n\t\tif (copy_from_user(&pi->tstamp_config, req->ifr_data,\n\t\t\t\t   sizeof(pi->tstamp_config)))\n\t\t\treturn -EFAULT;\n\n\t\tif (!is_t4(adapter->params.chip)) {\n\t\t\tswitch (pi->tstamp_config.tx_type) {\n\t\t\tcase HWTSTAMP_TX_OFF:\n\t\t\tcase HWTSTAMP_TX_ON:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -ERANGE;\n\t\t\t}\n\n\t\t\tswitch (pi->tstamp_config.rx_filter) {\n\t\t\tcase HWTSTAMP_FILTER_NONE:\n\t\t\t\tpi->rxtstamp = false;\n\t\t\t\tbreak;\n\t\t\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\t\t\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\t\t\t\tcxgb4_ptprx_timestamping(pi, pi->port_id,\n\t\t\t\t\t\t\t PTP_TS_L4);\n\t\t\t\tbreak;\n\t\t\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\t\t\t\tcxgb4_ptprx_timestamping(pi, pi->port_id,\n\t\t\t\t\t\t\t PTP_TS_L2_L4);\n\t\t\t\tbreak;\n\t\t\tcase HWTSTAMP_FILTER_ALL:\n\t\t\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\t\t\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\t\t\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\t\t\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\t\t\t\tpi->rxtstamp = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpi->tstamp_config.rx_filter =\n\t\t\t\t\tHWTSTAMP_FILTER_NONE;\n\t\t\t\treturn -ERANGE;\n\t\t\t}\n\n\t\t\tif ((pi->tstamp_config.tx_type == HWTSTAMP_TX_OFF) &&\n\t\t\t    (pi->tstamp_config.rx_filter ==\n\t\t\t\tHWTSTAMP_FILTER_NONE)) {\n\t\t\t\tif (cxgb4_ptp_txtype(adapter, pi->port_id) >= 0)\n\t\t\t\t\tpi->ptp_enable = false;\n\t\t\t}\n\n\t\t\tif (pi->tstamp_config.rx_filter !=\n\t\t\t\tHWTSTAMP_FILTER_NONE) {\n\t\t\t\tif (cxgb4_ptp_redirect_rx_packet(adapter,\n\t\t\t\t\t\t\t\t pi) >= 0)\n\t\t\t\t\tpi->ptp_enable = true;\n\t\t\t}\n\t\t} else {\n\t\t\t/* For T4 Adapters */\n\t\t\tswitch (pi->tstamp_config.rx_filter) {\n\t\t\tcase HWTSTAMP_FILTER_NONE:\n\t\t\tpi->rxtstamp = false;\n\t\t\tbreak;\n\t\t\tcase HWTSTAMP_FILTER_ALL:\n\t\t\tpi->rxtstamp = true;\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tpi->tstamp_config.rx_filter =\n\t\t\tHWTSTAMP_FILTER_NONE;\n\t\t\treturn -ERANGE;\n\t\t\t}\n\t\t}\n\t\treturn copy_to_user(req->ifr_data, &pi->tstamp_config,\n\t\t\t\t    sizeof(pi->tstamp_config)) ?\n\t\t\t-EFAULT : 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn ret;\n}\n\nstatic void cxgb_set_rxmode(struct net_device *dev)\n{\n\t/* unfortunately we can't return errors to the stack */\n\tset_rxmode(dev, -1, false);\n}\n\nstatic int cxgb_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tint ret;\n\n\tret = t4_set_rxmode(pi->adapter, pi->adapter->mbox, pi->viid,\n\t\t\t    pi->viid_mirror, new_mtu, -1, -1, -1, -1, true);\n\tif (!ret)\n\t\tdev->mtu = new_mtu;\n\treturn ret;\n}\n\n#ifdef CONFIG_PCI_IOV\nstatic int cxgb4_mgmt_open(struct net_device *dev)\n{\n\t/* Turn carrier off since we don't have to transmit anything on this\n\t * interface.\n\t */\n\tnetif_carrier_off(dev);\n\treturn 0;\n}\n\n/* Fill MAC address that will be assigned by the FW */\nstatic void cxgb4_mgmt_fill_vf_station_mac_addr(struct adapter *adap)\n{\n\tu8 hw_addr[ETH_ALEN], macaddr[ETH_ALEN];\n\tunsigned int i, vf, nvfs;\n\tu16 a, b;\n\tint err;\n\tu8 *na;\n\n\tadap->params.pci.vpd_cap_addr = pci_find_capability(adap->pdev,\n\t\t\t\t\t\t\t    PCI_CAP_ID_VPD);\n\terr = t4_get_raw_vpd_params(adap, &adap->params.vpd);\n\tif (err)\n\t\treturn;\n\n\tna = adap->params.vpd.na;\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\thw_addr[i] = (hex2val(na[2 * i + 0]) * 16 +\n\t\t\t      hex2val(na[2 * i + 1]));\n\n\ta = (hw_addr[0] << 8) | hw_addr[1];\n\tb = (hw_addr[1] << 8) | hw_addr[2];\n\ta ^= b;\n\ta |= 0x0200;    /* locally assigned Ethernet MAC address */\n\ta &= ~0x0100;   /* not a multicast Ethernet MAC address */\n\tmacaddr[0] = a >> 8;\n\tmacaddr[1] = a & 0xff;\n\n\tfor (i = 2; i < 5; i++)\n\t\tmacaddr[i] = hw_addr[i + 1];\n\n\tfor (vf = 0, nvfs = pci_sriov_get_totalvfs(adap->pdev);\n\t\tvf < nvfs; vf++) {\n\t\tmacaddr[5] = adap->pf * nvfs + vf;\n\t\tether_addr_copy(adap->vfinfo[vf].vf_mac_addr, macaddr);\n\t}\n}\n\nstatic int cxgb4_mgmt_set_vf_mac(struct net_device *dev, int vf, u8 *mac)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tint ret;\n\n\t/* verify MAC addr is valid */\n\tif (!is_valid_ether_addr(mac)) {\n\t\tdev_err(pi->adapter->pdev_dev,\n\t\t\t\"Invalid Ethernet address %pM for VF %d\\n\",\n\t\t\tmac, vf);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(pi->adapter->pdev_dev,\n\t\t \"Setting MAC %pM on VF %d\\n\", mac, vf);\n\tret = t4_set_vf_mac_acl(adap, vf + 1, 1, mac);\n\tif (!ret)\n\t\tether_addr_copy(adap->vfinfo[vf].vf_mac_addr, mac);\n\treturn ret;\n}\n\nstatic int cxgb4_mgmt_get_vf_config(struct net_device *dev,\n\t\t\t\t    int vf, struct ifla_vf_info *ivi)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tstruct vf_info *vfinfo;\n\n\tif (vf >= adap->num_vfs)\n\t\treturn -EINVAL;\n\tvfinfo = &adap->vfinfo[vf];\n\n\tivi->vf = vf;\n\tivi->max_tx_rate = vfinfo->tx_rate;\n\tivi->min_tx_rate = 0;\n\tether_addr_copy(ivi->mac, vfinfo->vf_mac_addr);\n\tivi->vlan = vfinfo->vlan;\n\tivi->linkstate = vfinfo->link_state;\n\treturn 0;\n}\n\nstatic int cxgb4_mgmt_get_phys_port_id(struct net_device *dev,\n\t\t\t\t       struct netdev_phys_item_id *ppid)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tunsigned int phy_port_id;\n\n\tphy_port_id = pi->adapter->adap_idx * 10 + pi->port_id;\n\tppid->id_len = sizeof(phy_port_id);\n\tmemcpy(ppid->id, &phy_port_id, ppid->id_len);\n\treturn 0;\n}\n\nstatic int cxgb4_mgmt_set_vf_rate(struct net_device *dev, int vf,\n\t\t\t\t  int min_tx_rate, int max_tx_rate)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tunsigned int link_ok, speed, mtu;\n\tu32 fw_pfvf, fw_class;\n\tint class_id = vf;\n\tint ret;\n\tu16 pktsize;\n\n\tif (vf >= adap->num_vfs)\n\t\treturn -EINVAL;\n\n\tif (min_tx_rate) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Min tx rate (%d) (> 0) for VF %d is Invalid.\\n\",\n\t\t\tmin_tx_rate, vf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (max_tx_rate == 0) {\n\t\t/* unbind VF to to any Traffic Class */\n\t\tfw_pfvf =\n\t\t    (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_PFVF) |\n\t\t     FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_PFVF_SCHEDCLASS_ETH));\n\t\tfw_class = 0xffffffff;\n\t\tret = t4_set_params(adap, adap->mbox, adap->pf, vf + 1, 1,\n\t\t\t\t    &fw_pfvf, &fw_class);\n\t\tif (ret) {\n\t\t\tdev_err(adap->pdev_dev,\n\t\t\t\t\"Err %d in unbinding PF %d VF %d from TX Rate Limiting\\n\",\n\t\t\t\tret, adap->pf, vf);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdev_info(adap->pdev_dev,\n\t\t\t \"PF %d VF %d is unbound from TX Rate Limiting\\n\",\n\t\t\t adap->pf, vf);\n\t\tadap->vfinfo[vf].tx_rate = 0;\n\t\treturn 0;\n\t}\n\n\tret = t4_get_link_params(pi, &link_ok, &speed, &mtu);\n\tif (ret != FW_SUCCESS) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Failed to get link information for VF %d\\n\", vf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!link_ok) {\n\t\tdev_err(adap->pdev_dev, \"Link down for VF %d\\n\", vf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (max_tx_rate > speed) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Max tx rate %d for VF %d can't be > link-speed %u\",\n\t\t\tmax_tx_rate, vf, speed);\n\t\treturn -EINVAL;\n\t}\n\n\tpktsize = mtu;\n\t/* subtract ethhdr size and 4 bytes crc since, f/w appends it */\n\tpktsize = pktsize - sizeof(struct ethhdr) - 4;\n\t/* subtract ipv4 hdr size, tcp hdr size to get typical IPv4 MSS size */\n\tpktsize = pktsize - sizeof(struct iphdr) - sizeof(struct tcphdr);\n\t/* configure Traffic Class for rate-limiting */\n\tret = t4_sched_params(adap, SCHED_CLASS_TYPE_PACKET,\n\t\t\t      SCHED_CLASS_LEVEL_CL_RL,\n\t\t\t      SCHED_CLASS_MODE_CLASS,\n\t\t\t      SCHED_CLASS_RATEUNIT_BITS,\n\t\t\t      SCHED_CLASS_RATEMODE_ABS,\n\t\t\t      pi->tx_chan, class_id, 0,\n\t\t\t      max_tx_rate * 1000, 0, pktsize, 0);\n\tif (ret) {\n\t\tdev_err(adap->pdev_dev, \"Err %d for Traffic Class config\\n\",\n\t\t\tret);\n\t\treturn -EINVAL;\n\t}\n\tdev_info(adap->pdev_dev,\n\t\t \"Class %d with MSS %u configured with rate %u\\n\",\n\t\t class_id, pktsize, max_tx_rate);\n\n\t/* bind VF to configured Traffic Class */\n\tfw_pfvf = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_PFVF) |\n\t\t   FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_PFVF_SCHEDCLASS_ETH));\n\tfw_class = class_id;\n\tret = t4_set_params(adap, adap->mbox, adap->pf, vf + 1, 1, &fw_pfvf,\n\t\t\t    &fw_class);\n\tif (ret) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Err %d in binding PF %d VF %d to Traffic Class %d\\n\",\n\t\t\tret, adap->pf, vf, class_id);\n\t\treturn -EINVAL;\n\t}\n\tdev_info(adap->pdev_dev, \"PF %d VF %d is bound to Class %d\\n\",\n\t\t adap->pf, vf, class_id);\n\tadap->vfinfo[vf].tx_rate = max_tx_rate;\n\treturn 0;\n}\n\nstatic int cxgb4_mgmt_set_vf_vlan(struct net_device *dev, int vf,\n\t\t\t\t  u16 vlan, u8 qos, __be16 vlan_proto)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tint ret;\n\n\tif (vf >= adap->num_vfs || vlan > 4095 || qos > 7)\n\t\treturn -EINVAL;\n\n\tif (vlan_proto != htons(ETH_P_8021Q) || qos != 0)\n\t\treturn -EPROTONOSUPPORT;\n\n\tret = t4_set_vlan_acl(adap, adap->mbox, vf + 1, vlan);\n\tif (!ret) {\n\t\tadap->vfinfo[vf].vlan = vlan;\n\t\treturn 0;\n\t}\n\n\tdev_err(adap->pdev_dev, \"Err %d %s VLAN ACL for PF/VF %d/%d\\n\",\n\t\tret, (vlan ? \"setting\" : \"clearing\"), adap->pf, vf);\n\treturn ret;\n}\n\nstatic int cxgb4_mgmt_set_vf_link_state(struct net_device *dev, int vf,\n\t\t\t\t\tint link)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tu32 param, val;\n\tint ret = 0;\n\n\tif (vf >= adap->num_vfs)\n\t\treturn -EINVAL;\n\n\tswitch (link) {\n\tcase IFLA_VF_LINK_STATE_AUTO:\n\t\tval = FW_VF_LINK_STATE_AUTO;\n\t\tbreak;\n\n\tcase IFLA_VF_LINK_STATE_ENABLE:\n\t\tval = FW_VF_LINK_STATE_ENABLE;\n\t\tbreak;\n\n\tcase IFLA_VF_LINK_STATE_DISABLE:\n\t\tval = FW_VF_LINK_STATE_DISABLE;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tparam = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_PFVF) |\n\t\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_PFVF_LINK_STATE));\n\tret = t4_set_params(adap, adap->mbox, adap->pf, vf + 1, 1,\n\t\t\t    &param, &val);\n\tif (ret) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Error %d in setting PF %d VF %d link state\\n\",\n\t\t\tret, adap->pf, vf);\n\t\treturn -EINVAL;\n\t}\n\n\tadap->vfinfo[vf].link_state = link;\n\treturn ret;\n}\n#endif /* CONFIG_PCI_IOV */\n\nstatic int cxgb_set_mac_addr(struct net_device *dev, void *p)\n{\n\tint ret;\n\tstruct sockaddr *addr = p;\n\tstruct port_info *pi = netdev_priv(dev);\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tret = cxgb4_update_mac_filt(pi, pi->viid, &pi->xact_addr_filt,\n\t\t\t\t    addr->sa_data, true, &pi->smt_idx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\n\treturn 0;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void cxgb_netpoll(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\n\tif (adap->flags & CXGB4_USING_MSIX) {\n\t\tint i;\n\t\tstruct sge_eth_rxq *rx = &adap->sge.ethrxq[pi->first_qset];\n\n\t\tfor (i = pi->nqsets; i; i--, rx++)\n\t\t\tt4_sge_intr_msix(0, &rx->rspq);\n\t} else\n\t\tt4_intr_handler(adap)(0, adap);\n}\n#endif\n\nstatic int cxgb_set_tx_maxrate(struct net_device *dev, int index, u32 rate)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tstruct ch_sched_queue qe = { 0 };\n\tstruct ch_sched_params p = { 0 };\n\tstruct sched_class *e;\n\tu32 req_rate;\n\tint err = 0;\n\n\tif (!can_sched(dev))\n\t\treturn -ENOTSUPP;\n\n\tif (index < 0 || index > pi->nqsets - 1)\n\t\treturn -EINVAL;\n\n\tif (!(adap->flags & CXGB4_FULL_INIT_DONE)) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Failed to rate limit on queue %d. Link Down?\\n\",\n\t\t\tindex);\n\t\treturn -EINVAL;\n\t}\n\n\tqe.queue = index;\n\te = cxgb4_sched_queue_lookup(dev, &qe);\n\tif (e && e->info.u.params.level != SCHED_CLASS_LEVEL_CL_RL) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Queue %u already bound to class %u of type: %u\\n\",\n\t\t\tindex, e->idx, e->info.u.params.level);\n\t\treturn -EBUSY;\n\t}\n\n\t/* Convert from Mbps to Kbps */\n\treq_rate = rate * 1000;\n\n\t/* Max rate is 100 Gbps */\n\tif (req_rate > SCHED_MAX_RATE_KBPS) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Invalid rate %u Mbps, Max rate is %u Mbps\\n\",\n\t\t\trate, SCHED_MAX_RATE_KBPS / 1000);\n\t\treturn -ERANGE;\n\t}\n\n\t/* First unbind the queue from any existing class */\n\tmemset(&qe, 0, sizeof(qe));\n\tqe.queue = index;\n\tqe.class = SCHED_CLS_NONE;\n\n\terr = cxgb4_sched_class_unbind(dev, (void *)(&qe), SCHED_QUEUE);\n\tif (err) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Unbinding Queue %d on port %d fail. Err: %d\\n\",\n\t\t\tindex, pi->port_id, err);\n\t\treturn err;\n\t}\n\n\t/* Queue already unbound */\n\tif (!req_rate)\n\t\treturn 0;\n\n\t/* Fetch any available unused or matching scheduling class */\n\tp.type = SCHED_CLASS_TYPE_PACKET;\n\tp.u.params.level    = SCHED_CLASS_LEVEL_CL_RL;\n\tp.u.params.mode     = SCHED_CLASS_MODE_CLASS;\n\tp.u.params.rateunit = SCHED_CLASS_RATEUNIT_BITS;\n\tp.u.params.ratemode = SCHED_CLASS_RATEMODE_ABS;\n\tp.u.params.channel  = pi->tx_chan;\n\tp.u.params.class    = SCHED_CLS_NONE;\n\tp.u.params.minrate  = 0;\n\tp.u.params.maxrate  = req_rate;\n\tp.u.params.weight   = 0;\n\tp.u.params.pktsize  = dev->mtu;\n\n\te = cxgb4_sched_class_alloc(dev, &p);\n\tif (!e)\n\t\treturn -ENOMEM;\n\n\t/* Bind the queue to a scheduling class */\n\tmemset(&qe, 0, sizeof(qe));\n\tqe.queue = index;\n\tqe.class = e->idx;\n\n\terr = cxgb4_sched_class_bind(dev, (void *)(&qe), SCHED_QUEUE);\n\tif (err)\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Queue rate limiting failed. Err: %d\\n\", err);\n\treturn err;\n}\n\nstatic int cxgb_setup_tc_flower(struct net_device *dev,\n\t\t\t\tstruct flow_cls_offload *cls_flower)\n{\n\tswitch (cls_flower->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\treturn cxgb4_tc_flower_replace(dev, cls_flower);\n\tcase FLOW_CLS_DESTROY:\n\t\treturn cxgb4_tc_flower_destroy(dev, cls_flower);\n\tcase FLOW_CLS_STATS:\n\t\treturn cxgb4_tc_flower_stats(dev, cls_flower);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int cxgb_setup_tc_cls_u32(struct net_device *dev,\n\t\t\t\t struct tc_cls_u32_offload *cls_u32)\n{\n\tswitch (cls_u32->command) {\n\tcase TC_CLSU32_NEW_KNODE:\n\tcase TC_CLSU32_REPLACE_KNODE:\n\t\treturn cxgb4_config_knode(dev, cls_u32);\n\tcase TC_CLSU32_DELETE_KNODE:\n\t\treturn cxgb4_delete_knode(dev, cls_u32);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int cxgb_setup_tc_matchall(struct net_device *dev,\n\t\t\t\t  struct tc_cls_matchall_offload *cls_matchall,\n\t\t\t\t  bool ingress)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\n\tif (!adap->tc_matchall)\n\t\treturn -ENOMEM;\n\n\tswitch (cls_matchall->command) {\n\tcase TC_CLSMATCHALL_REPLACE:\n\t\treturn cxgb4_tc_matchall_replace(dev, cls_matchall, ingress);\n\tcase TC_CLSMATCHALL_DESTROY:\n\t\treturn cxgb4_tc_matchall_destroy(dev, cls_matchall, ingress);\n\tcase TC_CLSMATCHALL_STATS:\n\t\tif (ingress)\n\t\t\treturn cxgb4_tc_matchall_stats(dev, cls_matchall);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int cxgb_setup_tc_block_ingress_cb(enum tc_setup_type type,\n\t\t\t\t\t  void *type_data, void *cb_priv)\n{\n\tstruct net_device *dev = cb_priv;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\n\tif (!(adap->flags & CXGB4_FULL_INIT_DONE)) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Failed to setup tc on port %d. Link Down?\\n\",\n\t\t\tpi->port_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!tc_cls_can_offload_and_chain0(dev, type_data))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSU32:\n\t\treturn cxgb_setup_tc_cls_u32(dev, type_data);\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn cxgb_setup_tc_flower(dev, type_data);\n\tcase TC_SETUP_CLSMATCHALL:\n\t\treturn cxgb_setup_tc_matchall(dev, type_data, true);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int cxgb_setup_tc_block_egress_cb(enum tc_setup_type type,\n\t\t\t\t\t void *type_data, void *cb_priv)\n{\n\tstruct net_device *dev = cb_priv;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\n\tif (!(adap->flags & CXGB4_FULL_INIT_DONE)) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Failed to setup tc on port %d. Link Down?\\n\",\n\t\t\tpi->port_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!tc_cls_can_offload_and_chain0(dev, type_data))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSMATCHALL:\n\t\treturn cxgb_setup_tc_matchall(dev, type_data, false);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int cxgb_setup_tc_mqprio(struct net_device *dev,\n\t\t\t\tstruct tc_mqprio_qopt_offload *mqprio)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\n\tif (!is_ethofld(adap) || !adap->tc_mqprio)\n\t\treturn -ENOMEM;\n\n\treturn cxgb4_setup_tc_mqprio(dev, mqprio);\n}\n\nstatic LIST_HEAD(cxgb_block_cb_list);\n\nstatic int cxgb_setup_tc_block(struct net_device *dev,\n\t\t\t       struct flow_block_offload *f)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tflow_setup_cb_t *cb;\n\tbool ingress_only;\n\n\tpi->tc_block_shared = f->block_shared;\n\tif (f->binder_type == FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS) {\n\t\tcb = cxgb_setup_tc_block_egress_cb;\n\t\tingress_only = false;\n\t} else {\n\t\tcb = cxgb_setup_tc_block_ingress_cb;\n\t\tingress_only = true;\n\t}\n\n\treturn flow_block_cb_setup_simple(f, &cxgb_block_cb_list,\n\t\t\t\t\t  cb, pi, dev, ingress_only);\n}\n\nstatic int cxgb_setup_tc(struct net_device *dev, enum tc_setup_type type,\n\t\t\t void *type_data)\n{\n\tswitch (type) {\n\tcase TC_SETUP_QDISC_MQPRIO:\n\t\treturn cxgb_setup_tc_mqprio(dev, type_data);\n\tcase TC_SETUP_BLOCK:\n\t\treturn cxgb_setup_tc_block(dev, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int cxgb_udp_tunnel_unset_port(struct net_device *netdev,\n\t\t\t\t      unsigned int table, unsigned int entry,\n\t\t\t\t      struct udp_tunnel_info *ti)\n{\n\tstruct port_info *pi = netdev_priv(netdev);\n\tstruct adapter *adapter = pi->adapter;\n\tu8 match_all_mac[] = { 0, 0, 0, 0, 0, 0 };\n\tint ret = 0, i;\n\n\tswitch (ti->type) {\n\tcase UDP_TUNNEL_TYPE_VXLAN:\n\t\tadapter->vxlan_port = 0;\n\t\tt4_write_reg(adapter, MPS_RX_VXLAN_TYPE_A, 0);\n\t\tbreak;\n\tcase UDP_TUNNEL_TYPE_GENEVE:\n\t\tadapter->geneve_port = 0;\n\t\tt4_write_reg(adapter, MPS_RX_GENEVE_TYPE_A, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* Matchall mac entries can be deleted only after all tunnel ports\n\t * are brought down or removed.\n\t */\n\tif (!adapter->rawf_cnt)\n\t\treturn 0;\n\tfor_each_port(adapter, i) {\n\t\tpi = adap2pinfo(adapter, i);\n\t\tret = t4_free_raw_mac_filt(adapter, pi->viid,\n\t\t\t\t\t   match_all_mac, match_all_mac,\n\t\t\t\t\t   adapter->rawf_start + pi->port_id,\n\t\t\t\t\t   1, pi->port_id, false);\n\t\tif (ret < 0) {\n\t\t\tnetdev_info(netdev, \"Failed to free mac filter entry, for port %d\\n\",\n\t\t\t\t    i);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cxgb_udp_tunnel_set_port(struct net_device *netdev,\n\t\t\t\t    unsigned int table, unsigned int entry,\n\t\t\t\t    struct udp_tunnel_info *ti)\n{\n\tstruct port_info *pi = netdev_priv(netdev);\n\tstruct adapter *adapter = pi->adapter;\n\tu8 match_all_mac[] = { 0, 0, 0, 0, 0, 0 };\n\tint i, ret;\n\n\tswitch (ti->type) {\n\tcase UDP_TUNNEL_TYPE_VXLAN:\n\t\tadapter->vxlan_port = ti->port;\n\t\tt4_write_reg(adapter, MPS_RX_VXLAN_TYPE_A,\n\t\t\t     VXLAN_V(be16_to_cpu(ti->port)) | VXLAN_EN_F);\n\t\tbreak;\n\tcase UDP_TUNNEL_TYPE_GENEVE:\n\t\tadapter->geneve_port = ti->port;\n\t\tt4_write_reg(adapter, MPS_RX_GENEVE_TYPE_A,\n\t\t\t     GENEVE_V(be16_to_cpu(ti->port)) | GENEVE_EN_F);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* Create a 'match all' mac filter entry for inner mac,\n\t * if raw mac interface is supported. Once the linux kernel provides\n\t * driver entry points for adding/deleting the inner mac addresses,\n\t * we will remove this 'match all' entry and fallback to adding\n\t * exact match filters.\n\t */\n\tfor_each_port(adapter, i) {\n\t\tpi = adap2pinfo(adapter, i);\n\n\t\tret = t4_alloc_raw_mac_filt(adapter, pi->viid,\n\t\t\t\t\t    match_all_mac,\n\t\t\t\t\t    match_all_mac,\n\t\t\t\t\t    adapter->rawf_start + pi->port_id,\n\t\t\t\t\t    1, pi->port_id, false);\n\t\tif (ret < 0) {\n\t\t\tnetdev_info(netdev, \"Failed to allocate a mac filter entry, not adding port %d\\n\",\n\t\t\t\t    be16_to_cpu(ti->port));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct udp_tunnel_nic_info cxgb_udp_tunnels = {\n\t.set_port\t= cxgb_udp_tunnel_set_port,\n\t.unset_port\t= cxgb_udp_tunnel_unset_port,\n\t.tables\t\t= {\n\t\t{ .n_entries = 1, .tunnel_types = UDP_TUNNEL_TYPE_VXLAN,  },\n\t\t{ .n_entries = 1, .tunnel_types = UDP_TUNNEL_TYPE_GENEVE, },\n\t},\n};\n\nstatic netdev_features_t cxgb_features_check(struct sk_buff *skb,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     netdev_features_t features)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\n\tif (CHELSIO_CHIP_VERSION(adapter->params.chip) < CHELSIO_T6)\n\t\treturn features;\n\n\t/* Check if hw supports offload for this packet */\n\tif (!skb->encapsulation || cxgb_encap_offload_supported(skb))\n\t\treturn features;\n\n\t/* Offload is not supported for this encapsulated packet */\n\treturn features & ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);\n}\n\nstatic netdev_features_t cxgb_fix_features(struct net_device *dev,\n\t\t\t\t\t   netdev_features_t features)\n{\n\t/* Disable GRO, if RX_CSUM is disabled */\n\tif (!(features & NETIF_F_RXCSUM))\n\t\tfeatures &= ~NETIF_F_GRO;\n\n\treturn features;\n}\n\nstatic const struct net_device_ops cxgb4_netdev_ops = {\n\t.ndo_open             = cxgb_open,\n\t.ndo_stop             = cxgb_close,\n\t.ndo_start_xmit       = t4_start_xmit,\n\t.ndo_select_queue     =\tcxgb_select_queue,\n\t.ndo_get_stats64      = cxgb_get_stats,\n\t.ndo_set_rx_mode      = cxgb_set_rxmode,\n\t.ndo_set_mac_address  = cxgb_set_mac_addr,\n\t.ndo_set_features     = cxgb_set_features,\n\t.ndo_validate_addr    = eth_validate_addr,\n\t.ndo_do_ioctl         = cxgb_ioctl,\n\t.ndo_change_mtu       = cxgb_change_mtu,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller  = cxgb_netpoll,\n#endif\n#ifdef CONFIG_CHELSIO_T4_FCOE\n\t.ndo_fcoe_enable      = cxgb_fcoe_enable,\n\t.ndo_fcoe_disable     = cxgb_fcoe_disable,\n#endif /* CONFIG_CHELSIO_T4_FCOE */\n\t.ndo_set_tx_maxrate   = cxgb_set_tx_maxrate,\n\t.ndo_setup_tc         = cxgb_setup_tc,\n\t.ndo_udp_tunnel_add   = udp_tunnel_nic_add_port,\n\t.ndo_udp_tunnel_del   = udp_tunnel_nic_del_port,\n\t.ndo_features_check   = cxgb_features_check,\n\t.ndo_fix_features     = cxgb_fix_features,\n};\n\n#ifdef CONFIG_PCI_IOV\nstatic const struct net_device_ops cxgb4_mgmt_netdev_ops = {\n\t.ndo_open               = cxgb4_mgmt_open,\n\t.ndo_set_vf_mac         = cxgb4_mgmt_set_vf_mac,\n\t.ndo_get_vf_config      = cxgb4_mgmt_get_vf_config,\n\t.ndo_set_vf_rate        = cxgb4_mgmt_set_vf_rate,\n\t.ndo_get_phys_port_id   = cxgb4_mgmt_get_phys_port_id,\n\t.ndo_set_vf_vlan        = cxgb4_mgmt_set_vf_vlan,\n\t.ndo_set_vf_link_state\t= cxgb4_mgmt_set_vf_link_state,\n};\n#endif\n\nstatic void cxgb4_mgmt_get_drvinfo(struct net_device *dev,\n\t\t\t\t   struct ethtool_drvinfo *info)\n{\n\tstruct adapter *adapter = netdev2adap(dev);\n\n\tstrlcpy(info->driver, cxgb4_driver_name, sizeof(info->driver));\n\tstrlcpy(info->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(info->bus_info));\n}\n\nstatic const struct ethtool_ops cxgb4_mgmt_ethtool_ops = {\n\t.get_drvinfo       = cxgb4_mgmt_get_drvinfo,\n};\n\nstatic void notify_fatal_err(struct work_struct *work)\n{\n\tstruct adapter *adap;\n\n\tadap = container_of(work, struct adapter, fatal_err_notify_task);\n\tnotify_ulds(adap, CXGB4_STATE_FATAL_ERROR);\n}\n\nvoid t4_fatal_err(struct adapter *adap)\n{\n\tint port;\n\n\tif (pci_channel_offline(adap->pdev))\n\t\treturn;\n\n\t/* Disable the SGE since ULDs are going to free resources that\n\t * could be exposed to the adapter.  RDMA MWs for example...\n\t */\n\tt4_shutdown_adapter(adap);\n\tfor_each_port(adap, port) {\n\t\tstruct net_device *dev = adap->port[port];\n\n\t\t/* If we get here in very early initialization the network\n\t\t * devices may not have been set up yet.\n\t\t */\n\t\tif (!dev)\n\t\t\tcontinue;\n\n\t\tnetif_tx_stop_all_queues(dev);\n\t\tnetif_carrier_off(dev);\n\t}\n\tdev_alert(adap->pdev_dev, \"encountered fatal error, adapter stopped\\n\");\n\tqueue_work(adap->workq, &adap->fatal_err_notify_task);\n}\n\nstatic void setup_memwin(struct adapter *adap)\n{\n\tu32 nic_win_base = t4_get_util_window(adap);\n\n\tt4_setup_memwin(adap, nic_win_base, MEMWIN_NIC);\n}\n\nstatic void setup_memwin_rdma(struct adapter *adap)\n{\n\tif (adap->vres.ocq.size) {\n\t\tu32 start;\n\t\tunsigned int sz_kb;\n\n\t\tstart = t4_read_pcie_cfg4(adap, PCI_BASE_ADDRESS_2);\n\t\tstart &= PCI_BASE_ADDRESS_MEM_MASK;\n\t\tstart += OCQ_WIN_OFFSET(adap->pdev, &adap->vres);\n\t\tsz_kb = roundup_pow_of_two(adap->vres.ocq.size) >> 10;\n\t\tt4_write_reg(adap,\n\t\t\t     PCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_BASE_WIN_A, 3),\n\t\t\t     start | BIR_V(1) | WINDOW_V(ilog2(sz_kb)));\n\t\tt4_write_reg(adap,\n\t\t\t     PCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_OFFSET_A, 3),\n\t\t\t     adap->vres.ocq.start);\n\t\tt4_read_reg(adap,\n\t\t\t    PCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_OFFSET_A, 3));\n\t}\n}\n\n/* HMA Definitions */\n\n/* The maximum number of address that can be send in a single FW cmd */\n#define HMA_MAX_ADDR_IN_CMD\t5\n\n#define HMA_PAGE_SIZE\t\tPAGE_SIZE\n\n#define HMA_MAX_NO_FW_ADDRESS\t(16 << 10)  /* FW supports 16K addresses */\n\n#define HMA_PAGE_ORDER\t\t\t\t\t\\\n\t((HMA_PAGE_SIZE < HMA_MAX_NO_FW_ADDRESS) ?\t\\\n\tilog2(HMA_MAX_NO_FW_ADDRESS / HMA_PAGE_SIZE) : 0)\n\n/* The minimum and maximum possible HMA sizes that can be specified in the FW\n * configuration(in units of MB).\n */\n#define HMA_MIN_TOTAL_SIZE\t1\n#define HMA_MAX_TOTAL_SIZE\t\t\t\t\\\n\t(((HMA_PAGE_SIZE << HMA_PAGE_ORDER) *\t\t\\\n\t  HMA_MAX_NO_FW_ADDRESS) >> 20)\n\nstatic void adap_free_hma_mem(struct adapter *adapter)\n{\n\tstruct scatterlist *iter;\n\tstruct page *page;\n\tint i;\n\n\tif (!adapter->hma.sgt)\n\t\treturn;\n\n\tif (adapter->hma.flags & HMA_DMA_MAPPED_FLAG) {\n\t\tdma_unmap_sg(adapter->pdev_dev, adapter->hma.sgt->sgl,\n\t\t\t     adapter->hma.sgt->nents, PCI_DMA_BIDIRECTIONAL);\n\t\tadapter->hma.flags &= ~HMA_DMA_MAPPED_FLAG;\n\t}\n\n\tfor_each_sg(adapter->hma.sgt->sgl, iter,\n\t\t    adapter->hma.sgt->orig_nents, i) {\n\t\tpage = sg_page(iter);\n\t\tif (page)\n\t\t\t__free_pages(page, HMA_PAGE_ORDER);\n\t}\n\n\tkfree(adapter->hma.phy_addr);\n\tsg_free_table(adapter->hma.sgt);\n\tkfree(adapter->hma.sgt);\n\tadapter->hma.sgt = NULL;\n}\n\nstatic int adap_config_hma(struct adapter *adapter)\n{\n\tstruct scatterlist *sgl, *iter;\n\tstruct sg_table *sgt;\n\tstruct page *newpage;\n\tunsigned int i, j, k;\n\tu32 param, hma_size;\n\tunsigned int ncmds;\n\tsize_t page_size;\n\tu32 page_order;\n\tint node, ret;\n\n\t/* HMA is supported only for T6+ cards.\n\t * Avoid initializing HMA in kdump kernels.\n\t */\n\tif (is_kdump_kernel() ||\n\t    CHELSIO_CHIP_VERSION(adapter->params.chip) < CHELSIO_T6)\n\t\treturn 0;\n\n\t/* Get the HMA region size required by fw */\n\tparam = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_HMA_SIZE));\n\tret = t4_query_params(adapter, adapter->mbox, adapter->pf, 0,\n\t\t\t      1, &param, &hma_size);\n\t/* An error means card has its own memory or HMA is not supported by\n\t * the firmware. Return without any errors.\n\t */\n\tif (ret || !hma_size)\n\t\treturn 0;\n\n\tif (hma_size < HMA_MIN_TOTAL_SIZE ||\n\t    hma_size > HMA_MAX_TOTAL_SIZE) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"HMA size %uMB beyond bounds(%u-%lu)MB\\n\",\n\t\t\thma_size, HMA_MIN_TOTAL_SIZE, HMA_MAX_TOTAL_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tpage_size = HMA_PAGE_SIZE;\n\tpage_order = HMA_PAGE_ORDER;\n\tadapter->hma.sgt = kzalloc(sizeof(*adapter->hma.sgt), GFP_KERNEL);\n\tif (unlikely(!adapter->hma.sgt)) {\n\t\tdev_err(adapter->pdev_dev, \"HMA SG table allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tsgt = adapter->hma.sgt;\n\t/* FW returned value will be in MB's\n\t */\n\tsgt->orig_nents = (hma_size << 20) / (page_size << page_order);\n\tif (sg_alloc_table(sgt, sgt->orig_nents, GFP_KERNEL)) {\n\t\tdev_err(adapter->pdev_dev, \"HMA SGL allocation failed\\n\");\n\t\tkfree(adapter->hma.sgt);\n\t\tadapter->hma.sgt = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tsgl = adapter->hma.sgt->sgl;\n\tnode = dev_to_node(adapter->pdev_dev);\n\tfor_each_sg(sgl, iter, sgt->orig_nents, i) {\n\t\tnewpage = alloc_pages_node(node, __GFP_NOWARN | GFP_KERNEL |\n\t\t\t\t\t   __GFP_ZERO, page_order);\n\t\tif (!newpage) {\n\t\t\tdev_err(adapter->pdev_dev,\n\t\t\t\t\"Not enough memory for HMA page allocation\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_hma;\n\t\t}\n\t\tsg_set_page(iter, newpage, page_size << page_order, 0);\n\t}\n\n\tsgt->nents = dma_map_sg(adapter->pdev_dev, sgl, sgt->orig_nents,\n\t\t\t\tDMA_BIDIRECTIONAL);\n\tif (!sgt->nents) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"Not enough memory for HMA DMA mapping\");\n\t\tret = -ENOMEM;\n\t\tgoto free_hma;\n\t}\n\tadapter->hma.flags |= HMA_DMA_MAPPED_FLAG;\n\n\tadapter->hma.phy_addr = kcalloc(sgt->nents, sizeof(dma_addr_t),\n\t\t\t\t\tGFP_KERNEL);\n\tif (unlikely(!adapter->hma.phy_addr))\n\t\tgoto free_hma;\n\n\tfor_each_sg(sgl, iter, sgt->nents, i) {\n\t\tnewpage = sg_page(iter);\n\t\tadapter->hma.phy_addr[i] = sg_dma_address(iter);\n\t}\n\n\tncmds = DIV_ROUND_UP(sgt->nents, HMA_MAX_ADDR_IN_CMD);\n\t/* Pass on the addresses to firmware */\n\tfor (i = 0, k = 0; i < ncmds; i++, k += HMA_MAX_ADDR_IN_CMD) {\n\t\tstruct fw_hma_cmd hma_cmd;\n\t\tu8 naddr = HMA_MAX_ADDR_IN_CMD;\n\t\tu8 soc = 0, eoc = 0;\n\t\tu8 hma_mode = 1; /* Presently we support only Page table mode */\n\n\t\tsoc = (i == 0) ? 1 : 0;\n\t\teoc = (i == ncmds - 1) ? 1 : 0;\n\n\t\t/* For last cmd, set naddr corresponding to remaining\n\t\t * addresses\n\t\t */\n\t\tif (i == ncmds - 1) {\n\t\t\tnaddr = sgt->nents % HMA_MAX_ADDR_IN_CMD;\n\t\t\tnaddr = naddr ? naddr : HMA_MAX_ADDR_IN_CMD;\n\t\t}\n\t\tmemset(&hma_cmd, 0, sizeof(hma_cmd));\n\t\thma_cmd.op_pkd = htonl(FW_CMD_OP_V(FW_HMA_CMD) |\n\t\t\t\t       FW_CMD_REQUEST_F | FW_CMD_WRITE_F);\n\t\thma_cmd.retval_len16 = htonl(FW_LEN16(hma_cmd));\n\n\t\thma_cmd.mode_to_pcie_params =\n\t\t\thtonl(FW_HMA_CMD_MODE_V(hma_mode) |\n\t\t\t      FW_HMA_CMD_SOC_V(soc) | FW_HMA_CMD_EOC_V(eoc));\n\n\t\t/* HMA cmd size specified in MB's */\n\t\thma_cmd.naddr_size =\n\t\t\thtonl(FW_HMA_CMD_SIZE_V(hma_size) |\n\t\t\t      FW_HMA_CMD_NADDR_V(naddr));\n\n\t\t/* Total Page size specified in units of 4K */\n\t\thma_cmd.addr_size_pkd =\n\t\t\thtonl(FW_HMA_CMD_ADDR_SIZE_V\n\t\t\t\t((page_size << page_order) >> 12));\n\n\t\t/* Fill the 5 addresses */\n\t\tfor (j = 0; j < naddr; j++) {\n\t\t\thma_cmd.phy_address[j] =\n\t\t\t\tcpu_to_be64(adapter->hma.phy_addr[j + k]);\n\t\t}\n\t\tret = t4_wr_mbox(adapter, adapter->mbox, &hma_cmd,\n\t\t\t\t sizeof(hma_cmd), &hma_cmd);\n\t\tif (ret) {\n\t\t\tdev_err(adapter->pdev_dev,\n\t\t\t\t\"HMA FW command failed with err %d\\n\", ret);\n\t\t\tgoto free_hma;\n\t\t}\n\t}\n\n\tif (!ret)\n\t\tdev_info(adapter->pdev_dev,\n\t\t\t \"Reserved %uMB host memory for HMA\\n\", hma_size);\n\treturn ret;\n\nfree_hma:\n\tadap_free_hma_mem(adapter);\n\treturn ret;\n}\n\nstatic int adap_init1(struct adapter *adap, struct fw_caps_config_cmd *c)\n{\n\tu32 v;\n\tint ret;\n\n\t/* Now that we've successfully configured and initialized the adapter\n\t * can ask the Firmware what resources it has provisioned for us.\n\t */\n\tret = t4_get_pfres(adap);\n\tif (ret) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Unable to retrieve resource provisioning information\\n\");\n\t\treturn ret;\n\t}\n\n\t/* get device capabilities */\n\tmemset(c, 0, sizeof(*c));\n\tc->op_to_write = htonl(FW_CMD_OP_V(FW_CAPS_CONFIG_CMD) |\n\t\t\t       FW_CMD_REQUEST_F | FW_CMD_READ_F);\n\tc->cfvalid_to_len16 = htonl(FW_LEN16(*c));\n\tret = t4_wr_mbox(adap, adap->mbox, c, sizeof(*c), c);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tc->op_to_write = htonl(FW_CMD_OP_V(FW_CAPS_CONFIG_CMD) |\n\t\t\t       FW_CMD_REQUEST_F | FW_CMD_WRITE_F);\n\tret = t4_wr_mbox(adap, adap->mbox, c, sizeof(*c), NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = t4_config_glbl_rss(adap, adap->pf,\n\t\t\t\t FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL,\n\t\t\t\t FW_RSS_GLB_CONFIG_CMD_TNLMAPEN_F |\n\t\t\t\t FW_RSS_GLB_CONFIG_CMD_TNLALLLKP_F);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = t4_cfg_pfvf(adap, adap->mbox, adap->pf, 0, adap->sge.egr_sz, 64,\n\t\t\t  MAX_INGQ, 0, 0, 4, 0xf, 0xf, 16, FW_CMD_CAP_PF,\n\t\t\t  FW_CMD_CAP_PF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tt4_sge_init(adap);\n\n\t/* tweak some settings */\n\tt4_write_reg(adap, TP_SHIFT_CNT_A, 0x64f8849);\n\tt4_write_reg(adap, ULP_RX_TDDP_PSZ_A, HPZ0_V(PAGE_SHIFT - 12));\n\tt4_write_reg(adap, TP_PIO_ADDR_A, TP_INGRESS_CONFIG_A);\n\tv = t4_read_reg(adap, TP_PIO_DATA_A);\n\tt4_write_reg(adap, TP_PIO_DATA_A, v & ~CSUM_HAS_PSEUDO_HDR_F);\n\n\t/* first 4 Tx modulation queues point to consecutive Tx channels */\n\tadap->params.tp.tx_modq_map = 0xE4;\n\tt4_write_reg(adap, TP_TX_MOD_QUEUE_REQ_MAP_A,\n\t\t     TX_MOD_QUEUE_REQ_MAP_V(adap->params.tp.tx_modq_map));\n\n\t/* associate each Tx modulation queue with consecutive Tx channels */\n\tv = 0x84218421;\n\tt4_write_indirect(adap, TP_PIO_ADDR_A, TP_PIO_DATA_A,\n\t\t\t  &v, 1, TP_TX_SCHED_HDR_A);\n\tt4_write_indirect(adap, TP_PIO_ADDR_A, TP_PIO_DATA_A,\n\t\t\t  &v, 1, TP_TX_SCHED_FIFO_A);\n\tt4_write_indirect(adap, TP_PIO_ADDR_A, TP_PIO_DATA_A,\n\t\t\t  &v, 1, TP_TX_SCHED_PCMD_A);\n\n#define T4_TX_MODQ_10G_WEIGHT_DEFAULT 16 /* in KB units */\n\tif (is_offload(adap)) {\n\t\tt4_write_reg(adap, TP_TX_MOD_QUEUE_WEIGHT0_A,\n\t\t\t     TX_MODQ_WEIGHT0_V(T4_TX_MODQ_10G_WEIGHT_DEFAULT) |\n\t\t\t     TX_MODQ_WEIGHT1_V(T4_TX_MODQ_10G_WEIGHT_DEFAULT) |\n\t\t\t     TX_MODQ_WEIGHT2_V(T4_TX_MODQ_10G_WEIGHT_DEFAULT) |\n\t\t\t     TX_MODQ_WEIGHT3_V(T4_TX_MODQ_10G_WEIGHT_DEFAULT));\n\t\tt4_write_reg(adap, TP_TX_MOD_CHANNEL_WEIGHT_A,\n\t\t\t     TX_MODQ_WEIGHT0_V(T4_TX_MODQ_10G_WEIGHT_DEFAULT) |\n\t\t\t     TX_MODQ_WEIGHT1_V(T4_TX_MODQ_10G_WEIGHT_DEFAULT) |\n\t\t\t     TX_MODQ_WEIGHT2_V(T4_TX_MODQ_10G_WEIGHT_DEFAULT) |\n\t\t\t     TX_MODQ_WEIGHT3_V(T4_TX_MODQ_10G_WEIGHT_DEFAULT));\n\t}\n\n\t/* get basic stuff going */\n\treturn t4_early_init(adap, adap->pf);\n}\n\n/*\n * Max # of ATIDs.  The absolute HW max is 16K but we keep it lower.\n */\n#define MAX_ATIDS 8192U\n\n/*\n * Phase 0 of initialization: contact FW, obtain config, perform basic init.\n *\n * If the firmware we're dealing with has Configuration File support, then\n * we use that to perform all configuration\n */\n\n/*\n * Tweak configuration based on module parameters, etc.  Most of these have\n * defaults assigned to them by Firmware Configuration Files (if we're using\n * them) but need to be explicitly set if we're using hard-coded\n * initialization.  But even in the case of using Firmware Configuration\n * Files, we'd like to expose the ability to change these via module\n * parameters so these are essentially common tweaks/settings for\n * Configuration Files and hard-coded initialization ...\n */\nstatic int adap_init0_tweaks(struct adapter *adapter)\n{\n\t/*\n\t * Fix up various Host-Dependent Parameters like Page Size, Cache\n\t * Line Size, etc.  The firmware default is for a 4KB Page Size and\n\t * 64B Cache Line Size ...\n\t */\n\tt4_fixup_host_params(adapter, PAGE_SIZE, L1_CACHE_BYTES);\n\n\t/*\n\t * Process module parameters which affect early initialization.\n\t */\n\tif (rx_dma_offset != 2 && rx_dma_offset != 0) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Ignoring illegal rx_dma_offset=%d, using 2\\n\",\n\t\t\trx_dma_offset);\n\t\trx_dma_offset = 2;\n\t}\n\tt4_set_reg_field(adapter, SGE_CONTROL_A,\n\t\t\t PKTSHIFT_V(PKTSHIFT_M),\n\t\t\t PKTSHIFT_V(rx_dma_offset));\n\n\t/*\n\t * Don't include the \"IP Pseudo Header\" in CPL_RX_PKT checksums: Linux\n\t * adds the pseudo header itself.\n\t */\n\tt4_tp_wr_bits_indirect(adapter, TP_INGRESS_CONFIG_A,\n\t\t\t       CSUM_HAS_PSEUDO_HDR_F, 0);\n\n\treturn 0;\n}\n\n/* 10Gb/s-BT PHY Support. chip-external 10Gb/s-BT PHYs are complex chips\n * unto themselves and they contain their own firmware to perform their\n * tasks ...\n */\nstatic int phy_aq1202_version(const u8 *phy_fw_data,\n\t\t\t      size_t phy_fw_size)\n{\n\tint offset;\n\n\t/* At offset 0x8 you're looking for the primary image's\n\t * starting offset which is 3 Bytes wide\n\t *\n\t * At offset 0xa of the primary image, you look for the offset\n\t * of the DRAM segment which is 3 Bytes wide.\n\t *\n\t * The FW version is at offset 0x27e of the DRAM and is 2 Bytes\n\t * wide\n\t */\n\t#define be16(__p) (((__p)[0] << 8) | (__p)[1])\n\t#define le16(__p) ((__p)[0] | ((__p)[1] << 8))\n\t#define le24(__p) (le16(__p) | ((__p)[2] << 16))\n\n\toffset = le24(phy_fw_data + 0x8) << 12;\n\toffset = le24(phy_fw_data + offset + 0xa);\n\treturn be16(phy_fw_data + offset + 0x27e);\n\n\t#undef be16\n\t#undef le16\n\t#undef le24\n}\n\nstatic struct info_10gbt_phy_fw {\n\tunsigned int phy_fw_id;\t\t/* PCI Device ID */\n\tchar *phy_fw_file;\t\t/* /lib/firmware/ PHY Firmware file */\n\tint (*phy_fw_version)(const u8 *phy_fw_data, size_t phy_fw_size);\n\tint phy_flash;\t\t\t/* Has FLASH for PHY Firmware */\n} phy_info_array[] = {\n\t{\n\t\tPHY_AQ1202_DEVICEID,\n\t\tPHY_AQ1202_FIRMWARE,\n\t\tphy_aq1202_version,\n\t\t1,\n\t},\n\t{\n\t\tPHY_BCM84834_DEVICEID,\n\t\tPHY_BCM84834_FIRMWARE,\n\t\tNULL,\n\t\t0,\n\t},\n\t{ 0, NULL, NULL },\n};\n\nstatic struct info_10gbt_phy_fw *find_phy_info(int devid)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(phy_info_array); i++) {\n\t\tif (phy_info_array[i].phy_fw_id == devid)\n\t\t\treturn &phy_info_array[i];\n\t}\n\treturn NULL;\n}\n\n/* Handle updating of chip-external 10Gb/s-BT PHY firmware.  This needs to\n * happen after the FW_RESET_CMD but before the FW_INITIALIZE_CMD.  On error\n * we return a negative error number.  If we transfer new firmware we return 1\n * (from t4_load_phy_fw()).  If we don't do anything we return 0.\n */\nstatic int adap_init0_phy(struct adapter *adap)\n{\n\tconst struct firmware *phyf;\n\tint ret;\n\tstruct info_10gbt_phy_fw *phy_info;\n\n\t/* Use the device ID to determine which PHY file to flash.\n\t */\n\tphy_info = find_phy_info(adap->pdev->device);\n\tif (!phy_info) {\n\t\tdev_warn(adap->pdev_dev,\n\t\t\t \"No PHY Firmware file found for this PHY\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* If we have a T4 PHY firmware file under /lib/firmware/cxgb4/, then\n\t * use that. The adapter firmware provides us with a memory buffer\n\t * where we can load a PHY firmware file from the host if we want to\n\t * override the PHY firmware File in flash.\n\t */\n\tret = request_firmware_direct(&phyf, phy_info->phy_fw_file,\n\t\t\t\t      adap->pdev_dev);\n\tif (ret < 0) {\n\t\t/* For adapters without FLASH attached to PHY for their\n\t\t * firmware, it's obviously a fatal error if we can't get the\n\t\t * firmware to the adapter.  For adapters with PHY firmware\n\t\t * FLASH storage, it's worth a warning if we can't find the\n\t\t * PHY Firmware but we'll neuter the error ...\n\t\t */\n\t\tdev_err(adap->pdev_dev, \"unable to find PHY Firmware image \"\n\t\t\t\"/lib/firmware/%s, error %d\\n\",\n\t\t\tphy_info->phy_fw_file, -ret);\n\t\tif (phy_info->phy_flash) {\n\t\t\tint cur_phy_fw_ver = 0;\n\n\t\t\tt4_phy_fw_ver(adap, &cur_phy_fw_ver);\n\t\t\tdev_warn(adap->pdev_dev, \"continuing with, on-adapter \"\n\t\t\t\t \"FLASH copy, version %#x\\n\", cur_phy_fw_ver);\n\t\t\tret = 0;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\t/* Load PHY Firmware onto adapter.\n\t */\n\tspin_lock_bh(&adap->win0_lock);\n\tret = t4_load_phy_fw(adap, MEMWIN_NIC, phy_info->phy_fw_version,\n\t\t\t     (u8 *)phyf->data, phyf->size);\n\tspin_unlock_bh(&adap->win0_lock);\n\tif (ret < 0)\n\t\tdev_err(adap->pdev_dev, \"PHY Firmware transfer error %d\\n\",\n\t\t\t-ret);\n\telse if (ret > 0) {\n\t\tint new_phy_fw_ver = 0;\n\n\t\tif (phy_info->phy_fw_version)\n\t\t\tnew_phy_fw_ver = phy_info->phy_fw_version(phyf->data,\n\t\t\t\t\t\t\t\t  phyf->size);\n\t\tdev_info(adap->pdev_dev, \"Successfully transferred PHY \"\n\t\t\t \"Firmware /lib/firmware/%s, version %#x\\n\",\n\t\t\t phy_info->phy_fw_file, new_phy_fw_ver);\n\t}\n\n\trelease_firmware(phyf);\n\n\treturn ret;\n}\n\n/*\n * Attempt to initialize the adapter via a Firmware Configuration File.\n */\nstatic int adap_init0_config(struct adapter *adapter, int reset)\n{\n\tchar *fw_config_file, fw_config_file_path[256];\n\tu32 finiver, finicsum, cfcsum, param, val;\n\tstruct fw_caps_config_cmd caps_cmd;\n\tunsigned long mtype = 0, maddr = 0;\n\tconst struct firmware *cf;\n\tchar *config_name = NULL;\n\tint config_issued = 0;\n\tint ret;\n\n\t/*\n\t * Reset device if necessary.\n\t */\n\tif (reset) {\n\t\tret = t4_fw_reset(adapter, adapter->mbox,\n\t\t\t\t  PIORSTMODE_F | PIORST_F);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t}\n\n\t/* If this is a 10Gb/s-BT adapter make sure the chip-external\n\t * 10Gb/s-BT PHYs have up-to-date firmware.  Note that this step needs\n\t * to be performed after any global adapter RESET above since some\n\t * PHYs only have local RAM copies of the PHY firmware.\n\t */\n\tif (is_10gbt_device(adapter->pdev->device)) {\n\t\tret = adap_init0_phy(adapter);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t}\n\t/*\n\t * If we have a T4 configuration file under /lib/firmware/cxgb4/,\n\t * then use that.  Otherwise, use the configuration file stored\n\t * in the adapter flash ...\n\t */\n\tswitch (CHELSIO_CHIP_VERSION(adapter->params.chip)) {\n\tcase CHELSIO_T4:\n\t\tfw_config_file = FW4_CFNAME;\n\t\tbreak;\n\tcase CHELSIO_T5:\n\t\tfw_config_file = FW5_CFNAME;\n\t\tbreak;\n\tcase CHELSIO_T6:\n\t\tfw_config_file = FW6_CFNAME;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(adapter->pdev_dev, \"Device %d is not supported\\n\",\n\t\t       adapter->pdev->device);\n\t\tret = -EINVAL;\n\t\tgoto bye;\n\t}\n\n\tret = request_firmware(&cf, fw_config_file, adapter->pdev_dev);\n\tif (ret < 0) {\n\t\tconfig_name = \"On FLASH\";\n\t\tmtype = FW_MEMTYPE_CF_FLASH;\n\t\tmaddr = t4_flash_cfg_addr(adapter);\n\t} else {\n\t\tu32 params[7], val[7];\n\n\t\tsprintf(fw_config_file_path,\n\t\t\t\"/lib/firmware/%s\", fw_config_file);\n\t\tconfig_name = fw_config_file_path;\n\n\t\tif (cf->size >= FLASH_CFG_MAX_SIZE)\n\t\t\tret = -ENOMEM;\n\t\telse {\n\t\t\tparams[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t\t     FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_CF));\n\t\t\tret = t4_query_params(adapter, adapter->mbox,\n\t\t\t\t\t      adapter->pf, 0, 1, params, val);\n\t\t\tif (ret == 0) {\n\t\t\t\t/*\n\t\t\t\t * For t4_memory_rw() below addresses and\n\t\t\t\t * sizes have to be in terms of multiples of 4\n\t\t\t\t * bytes.  So, if the Configuration File isn't\n\t\t\t\t * a multiple of 4 bytes in length we'll have\n\t\t\t\t * to write that out separately since we can't\n\t\t\t\t * guarantee that the bytes following the\n\t\t\t\t * residual byte in the buffer returned by\n\t\t\t\t * request_firmware() are zeroed out ...\n\t\t\t\t */\n\t\t\t\tsize_t resid = cf->size & 0x3;\n\t\t\t\tsize_t size = cf->size & ~0x3;\n\t\t\t\t__be32 *data = (__be32 *)cf->data;\n\n\t\t\t\tmtype = FW_PARAMS_PARAM_Y_G(val[0]);\n\t\t\t\tmaddr = FW_PARAMS_PARAM_Z_G(val[0]) << 16;\n\n\t\t\t\tspin_lock(&adapter->win0_lock);\n\t\t\t\tret = t4_memory_rw(adapter, 0, mtype, maddr,\n\t\t\t\t\t\t   size, data, T4_MEMORY_WRITE);\n\t\t\t\tif (ret == 0 && resid != 0) {\n\t\t\t\t\tunion {\n\t\t\t\t\t\t__be32 word;\n\t\t\t\t\t\tchar buf[4];\n\t\t\t\t\t} last;\n\t\t\t\t\tint i;\n\n\t\t\t\t\tlast.word = data[size >> 2];\n\t\t\t\t\tfor (i = resid; i < 4; i++)\n\t\t\t\t\t\tlast.buf[i] = 0;\n\t\t\t\t\tret = t4_memory_rw(adapter, 0, mtype,\n\t\t\t\t\t\t\t   maddr + size,\n\t\t\t\t\t\t\t   4, &last.word,\n\t\t\t\t\t\t\t   T4_MEMORY_WRITE);\n\t\t\t\t}\n\t\t\t\tspin_unlock(&adapter->win0_lock);\n\t\t\t}\n\t\t}\n\n\t\trelease_firmware(cf);\n\t\tif (ret)\n\t\t\tgoto bye;\n\t}\n\n\tval = 0;\n\n\t/* Ofld + Hash filter is supported. Older fw will fail this request and\n\t * it is fine.\n\t */\n\tparam = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_HASHFILTER_WITH_OFLD));\n\tret = t4_set_params(adapter, adapter->mbox, adapter->pf, 0,\n\t\t\t    1, &param, &val);\n\n\t/* FW doesn't know about Hash filter + ofld support,\n\t * it's not a problem, don't return an error.\n\t */\n\tif (ret < 0) {\n\t\tdev_warn(adapter->pdev_dev,\n\t\t\t \"Hash filter with ofld is not supported by FW\\n\");\n\t}\n\n\t/*\n\t * Issue a Capability Configuration command to the firmware to get it\n\t * to parse the Configuration File.  We don't use t4_fw_config_file()\n\t * because we want the ability to modify various features after we've\n\t * processed the configuration file ...\n\t */\n\tmemset(&caps_cmd, 0, sizeof(caps_cmd));\n\tcaps_cmd.op_to_write =\n\t\thtonl(FW_CMD_OP_V(FW_CAPS_CONFIG_CMD) |\n\t\t      FW_CMD_REQUEST_F |\n\t\t      FW_CMD_READ_F);\n\tcaps_cmd.cfvalid_to_len16 =\n\t\thtonl(FW_CAPS_CONFIG_CMD_CFVALID_F |\n\t\t      FW_CAPS_CONFIG_CMD_MEMTYPE_CF_V(mtype) |\n\t\t      FW_CAPS_CONFIG_CMD_MEMADDR64K_CF_V(maddr >> 16) |\n\t\t      FW_LEN16(caps_cmd));\n\tret = t4_wr_mbox(adapter, adapter->mbox, &caps_cmd, sizeof(caps_cmd),\n\t\t\t &caps_cmd);\n\n\t/* If the CAPS_CONFIG failed with an ENOENT (for a Firmware\n\t * Configuration File in FLASH), our last gasp effort is to use the\n\t * Firmware Configuration File which is embedded in the firmware.  A\n\t * very few early versions of the firmware didn't have one embedded\n\t * but we can ignore those.\n\t */\n\tif (ret == -ENOENT) {\n\t\tmemset(&caps_cmd, 0, sizeof(caps_cmd));\n\t\tcaps_cmd.op_to_write =\n\t\t\thtonl(FW_CMD_OP_V(FW_CAPS_CONFIG_CMD) |\n\t\t\t\t\tFW_CMD_REQUEST_F |\n\t\t\t\t\tFW_CMD_READ_F);\n\t\tcaps_cmd.cfvalid_to_len16 = htonl(FW_LEN16(caps_cmd));\n\t\tret = t4_wr_mbox(adapter, adapter->mbox, &caps_cmd,\n\t\t\t\tsizeof(caps_cmd), &caps_cmd);\n\t\tconfig_name = \"Firmware Default\";\n\t}\n\n\tconfig_issued = 1;\n\tif (ret < 0)\n\t\tgoto bye;\n\n\tfiniver = ntohl(caps_cmd.finiver);\n\tfinicsum = ntohl(caps_cmd.finicsum);\n\tcfcsum = ntohl(caps_cmd.cfcsum);\n\tif (finicsum != cfcsum)\n\t\tdev_warn(adapter->pdev_dev, \"Configuration File checksum \"\\\n\t\t\t \"mismatch: [fini] csum=%#x, computed csum=%#x\\n\",\n\t\t\t finicsum, cfcsum);\n\n\t/*\n\t * And now tell the firmware to use the configuration we just loaded.\n\t */\n\tcaps_cmd.op_to_write =\n\t\thtonl(FW_CMD_OP_V(FW_CAPS_CONFIG_CMD) |\n\t\t      FW_CMD_REQUEST_F |\n\t\t      FW_CMD_WRITE_F);\n\tcaps_cmd.cfvalid_to_len16 = htonl(FW_LEN16(caps_cmd));\n\tret = t4_wr_mbox(adapter, adapter->mbox, &caps_cmd, sizeof(caps_cmd),\n\t\t\t NULL);\n\tif (ret < 0)\n\t\tgoto bye;\n\n\t/*\n\t * Tweak configuration based on system architecture, module\n\t * parameters, etc.\n\t */\n\tret = adap_init0_tweaks(adapter);\n\tif (ret < 0)\n\t\tgoto bye;\n\n\t/* We will proceed even if HMA init fails. */\n\tret = adap_config_hma(adapter);\n\tif (ret)\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"HMA configuration failed with error %d\\n\", ret);\n\n\tif (is_t6(adapter->params.chip)) {\n\t\tadap_config_hpfilter(adapter);\n\t\tret = setup_ppod_edram(adapter);\n\t\tif (!ret)\n\t\t\tdev_info(adapter->pdev_dev, \"Successfully enabled \"\n\t\t\t\t \"ppod edram feature\\n\");\n\t}\n\n\t/*\n\t * And finally tell the firmware to initialize itself using the\n\t * parameters from the Configuration File.\n\t */\n\tret = t4_fw_initialize(adapter, adapter->mbox);\n\tif (ret < 0)\n\t\tgoto bye;\n\n\t/* Emit Firmware Configuration File information and return\n\t * successfully.\n\t */\n\tdev_info(adapter->pdev_dev, \"Successfully configured using Firmware \"\\\n\t\t \"Configuration File \\\"%s\\\", version %#x, computed checksum %#x\\n\",\n\t\t config_name, finiver, cfcsum);\n\treturn 0;\n\n\t/*\n\t * Something bad happened.  Return the error ...  (If the \"error\"\n\t * is that there's no Configuration File on the adapter we don't\n\t * want to issue a warning since this is fairly common.)\n\t */\nbye:\n\tif (config_issued && ret != -ENOENT)\n\t\tdev_warn(adapter->pdev_dev, \"\\\"%s\\\" configuration file error %d\\n\",\n\t\t\t config_name, -ret);\n\treturn ret;\n}\n\nstatic struct fw_info fw_info_array[] = {\n\t{\n\t\t.chip = CHELSIO_T4,\n\t\t.fs_name = FW4_CFNAME,\n\t\t.fw_mod_name = FW4_FNAME,\n\t\t.fw_hdr = {\n\t\t\t.chip = FW_HDR_CHIP_T4,\n\t\t\t.fw_ver = __cpu_to_be32(FW_VERSION(T4)),\n\t\t\t.intfver_nic = FW_INTFVER(T4, NIC),\n\t\t\t.intfver_vnic = FW_INTFVER(T4, VNIC),\n\t\t\t.intfver_ri = FW_INTFVER(T4, RI),\n\t\t\t.intfver_iscsi = FW_INTFVER(T4, ISCSI),\n\t\t\t.intfver_fcoe = FW_INTFVER(T4, FCOE),\n\t\t},\n\t}, {\n\t\t.chip = CHELSIO_T5,\n\t\t.fs_name = FW5_CFNAME,\n\t\t.fw_mod_name = FW5_FNAME,\n\t\t.fw_hdr = {\n\t\t\t.chip = FW_HDR_CHIP_T5,\n\t\t\t.fw_ver = __cpu_to_be32(FW_VERSION(T5)),\n\t\t\t.intfver_nic = FW_INTFVER(T5, NIC),\n\t\t\t.intfver_vnic = FW_INTFVER(T5, VNIC),\n\t\t\t.intfver_ri = FW_INTFVER(T5, RI),\n\t\t\t.intfver_iscsi = FW_INTFVER(T5, ISCSI),\n\t\t\t.intfver_fcoe = FW_INTFVER(T5, FCOE),\n\t\t},\n\t}, {\n\t\t.chip = CHELSIO_T6,\n\t\t.fs_name = FW6_CFNAME,\n\t\t.fw_mod_name = FW6_FNAME,\n\t\t.fw_hdr = {\n\t\t\t.chip = FW_HDR_CHIP_T6,\n\t\t\t.fw_ver = __cpu_to_be32(FW_VERSION(T6)),\n\t\t\t.intfver_nic = FW_INTFVER(T6, NIC),\n\t\t\t.intfver_vnic = FW_INTFVER(T6, VNIC),\n\t\t\t.intfver_ofld = FW_INTFVER(T6, OFLD),\n\t\t\t.intfver_ri = FW_INTFVER(T6, RI),\n\t\t\t.intfver_iscsipdu = FW_INTFVER(T6, ISCSIPDU),\n\t\t\t.intfver_iscsi = FW_INTFVER(T6, ISCSI),\n\t\t\t.intfver_fcoepdu = FW_INTFVER(T6, FCOEPDU),\n\t\t\t.intfver_fcoe = FW_INTFVER(T6, FCOE),\n\t\t},\n\t}\n\n};\n\nstatic struct fw_info *find_fw_info(int chip)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fw_info_array); i++) {\n\t\tif (fw_info_array[i].chip == chip)\n\t\t\treturn &fw_info_array[i];\n\t}\n\treturn NULL;\n}\n\n/*\n * Phase 0 of initialization: contact FW, obtain config, perform basic init.\n */\nstatic int adap_init0(struct adapter *adap, int vpd_skip)\n{\n\tstruct fw_caps_config_cmd caps_cmd;\n\tu32 params[7], val[7];\n\tenum dev_state state;\n\tu32 v, port_vec;\n\tint reset = 1;\n\tint ret;\n\n\t/* Grab Firmware Device Log parameters as early as possible so we have\n\t * access to it for debugging, etc.\n\t */\n\tret = t4_init_devlog_params(adap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* Contact FW, advertising Master capability */\n\tret = t4_fw_hello(adap, adap->mbox, adap->mbox,\n\t\t\t  is_kdump_kernel() ? MASTER_MUST : MASTER_MAY, &state);\n\tif (ret < 0) {\n\t\tdev_err(adap->pdev_dev, \"could not connect to FW, error %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tif (ret == adap->mbox)\n\t\tadap->flags |= CXGB4_MASTER_PF;\n\n\t/*\n\t * If we're the Master PF Driver and the device is uninitialized,\n\t * then let's consider upgrading the firmware ...  (We always want\n\t * to check the firmware version number in order to A. get it for\n\t * later reporting and B. to warn if the currently loaded firmware\n\t * is excessively mismatched relative to the driver.)\n\t */\n\n\tt4_get_version_info(adap);\n\tret = t4_check_fw_version(adap);\n\t/* If firmware is too old (not supported by driver) force an update. */\n\tif (ret)\n\t\tstate = DEV_STATE_UNINIT;\n\tif ((adap->flags & CXGB4_MASTER_PF) && state != DEV_STATE_INIT) {\n\t\tstruct fw_info *fw_info;\n\t\tstruct fw_hdr *card_fw;\n\t\tconst struct firmware *fw;\n\t\tconst u8 *fw_data = NULL;\n\t\tunsigned int fw_size = 0;\n\n\t\t/* This is the firmware whose headers the driver was compiled\n\t\t * against\n\t\t */\n\t\tfw_info = find_fw_info(CHELSIO_CHIP_VERSION(adap->params.chip));\n\t\tif (fw_info == NULL) {\n\t\t\tdev_err(adap->pdev_dev,\n\t\t\t\t\"unable to get firmware info for chip %d.\\n\",\n\t\t\t\tCHELSIO_CHIP_VERSION(adap->params.chip));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* allocate memory to read the header of the firmware on the\n\t\t * card\n\t\t */\n\t\tcard_fw = kvzalloc(sizeof(*card_fw), GFP_KERNEL);\n\t\tif (!card_fw) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto bye;\n\t\t}\n\n\t\t/* Get FW from from /lib/firmware/ */\n\t\tret = request_firmware(&fw, fw_info->fw_mod_name,\n\t\t\t\t       adap->pdev_dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(adap->pdev_dev,\n\t\t\t\t\"unable to load firmware image %s, error %d\\n\",\n\t\t\t\tfw_info->fw_mod_name, ret);\n\t\t} else {\n\t\t\tfw_data = fw->data;\n\t\t\tfw_size = fw->size;\n\t\t}\n\n\t\t/* upgrade FW logic */\n\t\tret = t4_prep_fw(adap, fw_info, fw_data, fw_size, card_fw,\n\t\t\t\t state, &reset);\n\n\t\t/* Cleaning up */\n\t\trelease_firmware(fw);\n\t\tkvfree(card_fw);\n\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t}\n\n\t/* If the firmware is initialized already, emit a simply note to that\n\t * effect. Otherwise, it's time to try initializing the adapter.\n\t */\n\tif (state == DEV_STATE_INIT) {\n\t\tret = adap_config_hma(adap);\n\t\tif (ret)\n\t\t\tdev_err(adap->pdev_dev,\n\t\t\t\t\"HMA configuration failed with error %d\\n\",\n\t\t\t\tret);\n\t\tdev_info(adap->pdev_dev, \"Coming up as %s: \"\\\n\t\t\t \"Adapter already initialized\\n\",\n\t\t\t adap->flags & CXGB4_MASTER_PF ? \"MASTER\" : \"SLAVE\");\n\t} else {\n\t\tdev_info(adap->pdev_dev, \"Coming up as MASTER: \"\\\n\t\t\t \"Initializing adapter\\n\");\n\n\t\t/* Find out whether we're dealing with a version of the\n\t\t * firmware which has configuration file support.\n\t\t */\n\t\tparams[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t\t     FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_CF));\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 1,\n\t\t\t\t      params, val);\n\n\t\t/* If the firmware doesn't support Configuration Files,\n\t\t * return an error.\n\t\t */\n\t\tif (ret < 0) {\n\t\t\tdev_err(adap->pdev_dev, \"firmware doesn't support \"\n\t\t\t\t\"Firmware Configuration Files\\n\");\n\t\t\tgoto bye;\n\t\t}\n\n\t\t/* The firmware provides us with a memory buffer where we can\n\t\t * load a Configuration File from the host if we want to\n\t\t * override the Configuration File in flash.\n\t\t */\n\t\tret = adap_init0_config(adap, reset);\n\t\tif (ret == -ENOENT) {\n\t\t\tdev_err(adap->pdev_dev, \"no Configuration File \"\n\t\t\t\t\"present on adapter.\\n\");\n\t\t\tgoto bye;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(adap->pdev_dev, \"could not initialize \"\n\t\t\t\t\"adapter, error %d\\n\", -ret);\n\t\t\tgoto bye;\n\t\t}\n\t}\n\n\t/* Now that we've successfully configured and initialized the adapter\n\t * (or found it already initialized), we can ask the Firmware what\n\t * resources it has provisioned for us.\n\t */\n\tret = t4_get_pfres(adap);\n\tif (ret) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Unable to retrieve resource provisioning information\\n\");\n\t\tgoto bye;\n\t}\n\n\t/* Grab VPD parameters.  This should be done after we establish a\n\t * connection to the firmware since some of the VPD parameters\n\t * (notably the Core Clock frequency) are retrieved via requests to\n\t * the firmware.  On the other hand, we need these fairly early on\n\t * so we do this right after getting ahold of the firmware.\n\t *\n\t * We need to do this after initializing the adapter because someone\n\t * could have FLASHed a new VPD which won't be read by the firmware\n\t * until we do the RESET ...\n\t */\n\tif (!vpd_skip) {\n\t\tret = t4_get_vpd_params(adap, &adap->params.vpd);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t}\n\n\t/* Find out what ports are available to us.  Note that we need to do\n\t * this before calling adap_init0_no_config() since it needs nports\n\t * and portvec ...\n\t */\n\tv =\n\t    FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t    FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_PORTVEC);\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 1, &v, &port_vec);\n\tif (ret < 0)\n\t\tgoto bye;\n\n\tadap->params.nports = hweight32(port_vec);\n\tadap->params.portvec = port_vec;\n\n\t/* Give the SGE code a chance to pull in anything that it needs ...\n\t * Note that this must be called after we retrieve our VPD parameters\n\t * in order to know how to convert core ticks to seconds, etc.\n\t */\n\tret = t4_sge_init(adap);\n\tif (ret < 0)\n\t\tgoto bye;\n\n\t/* Grab the SGE Doorbell Queue Timer values.  If successful, that\n\t * indicates that the Firmware and Hardware support this.\n\t */\n\tparams[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t    FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_DBQ_TIMERTICK));\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0,\n\t\t\t      1, params, val);\n\n\tif (!ret) {\n\t\tadap->sge.dbqtimer_tick = val[0];\n\t\tret = t4_read_sge_dbqtimers(adap,\n\t\t\t\t\t    ARRAY_SIZE(adap->sge.dbqtimer_val),\n\t\t\t\t\t    adap->sge.dbqtimer_val);\n\t}\n\n\tif (!ret)\n\t\tadap->flags |= CXGB4_SGE_DBQ_TIMER;\n\n\tif (is_bypass_device(adap->pdev->device))\n\t\tadap->params.bypass = 1;\n\n\t/*\n\t * Grab some of our basic fundamental operating parameters.\n\t */\n\tparams[0] = FW_PARAM_PFVF(EQ_START);\n\tparams[1] = FW_PARAM_PFVF(L2T_START);\n\tparams[2] = FW_PARAM_PFVF(L2T_END);\n\tparams[3] = FW_PARAM_PFVF(FILTER_START);\n\tparams[4] = FW_PARAM_PFVF(FILTER_END);\n\tparams[5] = FW_PARAM_PFVF(IQFLINT_START);\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 6, params, val);\n\tif (ret < 0)\n\t\tgoto bye;\n\tadap->sge.egr_start = val[0];\n\tadap->l2t_start = val[1];\n\tadap->l2t_end = val[2];\n\tadap->tids.ftid_base = val[3];\n\tadap->tids.nftids = val[4] - val[3] + 1;\n\tadap->sge.ingr_start = val[5];\n\n\tif (CHELSIO_CHIP_VERSION(adap->params.chip) > CHELSIO_T5) {\n\t\tparams[0] = FW_PARAM_PFVF(HPFILTER_START);\n\t\tparams[1] = FW_PARAM_PFVF(HPFILTER_END);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2,\n\t\t\t\t      params, val);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\n\t\tadap->tids.hpftid_base = val[0];\n\t\tadap->tids.nhpftids = val[1] - val[0] + 1;\n\n\t\t/* Read the raw mps entries. In T6, the last 2 tcam entries\n\t\t * are reserved for raw mac addresses (rawf = 2, one per port).\n\t\t */\n\t\tparams[0] = FW_PARAM_PFVF(RAWF_START);\n\t\tparams[1] = FW_PARAM_PFVF(RAWF_END);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2,\n\t\t\t\t      params, val);\n\t\tif (ret == 0) {\n\t\t\tadap->rawf_start = val[0];\n\t\t\tadap->rawf_cnt = val[1] - val[0] + 1;\n\t\t}\n\n\t\tadap->tids.tid_base =\n\t\t\tt4_read_reg(adap, LE_DB_ACTIVE_TABLE_START_INDEX_A);\n\t}\n\n\t/* qids (ingress/egress) returned from firmware can be anywhere\n\t * in the range from EQ(IQFLINT)_START to EQ(IQFLINT)_END.\n\t * Hence driver needs to allocate memory for this range to\n\t * store the queue info. Get the highest IQFLINT/EQ index returned\n\t * in FW_EQ_*_CMD.alloc command.\n\t */\n\tparams[0] = FW_PARAM_PFVF(EQ_END);\n\tparams[1] = FW_PARAM_PFVF(IQFLINT_END);\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2, params, val);\n\tif (ret < 0)\n\t\tgoto bye;\n\tadap->sge.egr_sz = val[0] - adap->sge.egr_start + 1;\n\tadap->sge.ingr_sz = val[1] - adap->sge.ingr_start + 1;\n\n\tadap->sge.egr_map = kcalloc(adap->sge.egr_sz,\n\t\t\t\t    sizeof(*adap->sge.egr_map), GFP_KERNEL);\n\tif (!adap->sge.egr_map) {\n\t\tret = -ENOMEM;\n\t\tgoto bye;\n\t}\n\n\tadap->sge.ingr_map = kcalloc(adap->sge.ingr_sz,\n\t\t\t\t     sizeof(*adap->sge.ingr_map), GFP_KERNEL);\n\tif (!adap->sge.ingr_map) {\n\t\tret = -ENOMEM;\n\t\tgoto bye;\n\t}\n\n\t/* Allocate the memory for the vaious egress queue bitmaps\n\t * ie starving_fl, txq_maperr and blocked_fl.\n\t */\n\tadap->sge.starving_fl =\tkcalloc(BITS_TO_LONGS(adap->sge.egr_sz),\n\t\t\t\t\tsizeof(long), GFP_KERNEL);\n\tif (!adap->sge.starving_fl) {\n\t\tret = -ENOMEM;\n\t\tgoto bye;\n\t}\n\n\tadap->sge.txq_maperr = kcalloc(BITS_TO_LONGS(adap->sge.egr_sz),\n\t\t\t\t       sizeof(long), GFP_KERNEL);\n\tif (!adap->sge.txq_maperr) {\n\t\tret = -ENOMEM;\n\t\tgoto bye;\n\t}\n\n#ifdef CONFIG_DEBUG_FS\n\tadap->sge.blocked_fl = kcalloc(BITS_TO_LONGS(adap->sge.egr_sz),\n\t\t\t\t       sizeof(long), GFP_KERNEL);\n\tif (!adap->sge.blocked_fl) {\n\t\tret = -ENOMEM;\n\t\tgoto bye;\n\t}\n#endif\n\n\tparams[0] = FW_PARAM_PFVF(CLIP_START);\n\tparams[1] = FW_PARAM_PFVF(CLIP_END);\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2, params, val);\n\tif (ret < 0)\n\t\tgoto bye;\n\tadap->clipt_start = val[0];\n\tadap->clipt_end = val[1];\n\n\t/* Get the supported number of traffic classes */\n\tparams[0] = FW_PARAM_DEV(NUM_TM_CLASS);\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 1, params, val);\n\tif (ret < 0) {\n\t\t/* We couldn't retrieve the number of Traffic Classes\n\t\t * supported by the hardware/firmware. So we hard\n\t\t * code it here.\n\t\t */\n\t\tadap->params.nsched_cls = is_t4(adap->params.chip) ? 15 : 16;\n\t} else {\n\t\tadap->params.nsched_cls = val[0];\n\t}\n\n\t/* query params related to active filter region */\n\tparams[0] = FW_PARAM_PFVF(ACTIVE_FILTER_START);\n\tparams[1] = FW_PARAM_PFVF(ACTIVE_FILTER_END);\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2, params, val);\n\t/* If Active filter size is set we enable establishing\n\t * offload connection through firmware work request\n\t */\n\tif ((val[0] != val[1]) && (ret >= 0)) {\n\t\tadap->flags |= CXGB4_FW_OFLD_CONN;\n\t\tadap->tids.aftid_base = val[0];\n\t\tadap->tids.aftid_end = val[1];\n\t}\n\n\t/* If we're running on newer firmware, let it know that we're\n\t * prepared to deal with encapsulated CPL messages.  Older\n\t * firmware won't understand this and we'll just get\n\t * unencapsulated messages ...\n\t */\n\tparams[0] = FW_PARAM_PFVF(CPLFW4MSG_ENCAP);\n\tval[0] = 1;\n\t(void)t4_set_params(adap, adap->mbox, adap->pf, 0, 1, params, val);\n\n\t/*\n\t * Find out whether we're allowed to use the T5+ ULPTX MEMWRITE DSGL\n\t * capability.  Earlier versions of the firmware didn't have the\n\t * ULPTX_MEMWRITE_DSGL so we'll interpret a query failure as no\n\t * permission to use ULPTX MEMWRITE DSGL.\n\t */\n\tif (is_t4(adap->params.chip)) {\n\t\tadap->params.ulptx_memwrite_dsgl = false;\n\t} else {\n\t\tparams[0] = FW_PARAM_DEV(ULPTX_MEMWRITE_DSGL);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0,\n\t\t\t\t      1, params, val);\n\t\tadap->params.ulptx_memwrite_dsgl = (ret == 0 && val[0] != 0);\n\t}\n\n\t/* See if FW supports FW_RI_FR_NSMR_TPTE_WR work request */\n\tparams[0] = FW_PARAM_DEV(RI_FR_NSMR_TPTE_WR);\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0,\n\t\t\t      1, params, val);\n\tadap->params.fr_nsmr_tpte_wr_support = (ret == 0 && val[0] != 0);\n\n\t/* See if FW supports FW_FILTER2 work request */\n\tif (is_t4(adap->params.chip)) {\n\t\tadap->params.filter2_wr_support = 0;\n\t} else {\n\t\tparams[0] = FW_PARAM_DEV(FILTER2_WR);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0,\n\t\t\t\t      1, params, val);\n\t\tadap->params.filter2_wr_support = (ret == 0 && val[0] != 0);\n\t}\n\n\t/* Check if FW supports returning vin and smt index.\n\t * If this is not supported, driver will interpret\n\t * these values from viid.\n\t */\n\tparams[0] = FW_PARAM_DEV(OPAQUE_VIID_SMT_EXTN);\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0,\n\t\t\t      1, params, val);\n\tadap->params.viid_smt_extn_support = (ret == 0 && val[0] != 0);\n\n\t/*\n\t * Get device capabilities so we can determine what resources we need\n\t * to manage.\n\t */\n\tmemset(&caps_cmd, 0, sizeof(caps_cmd));\n\tcaps_cmd.op_to_write = htonl(FW_CMD_OP_V(FW_CAPS_CONFIG_CMD) |\n\t\t\t\t     FW_CMD_REQUEST_F | FW_CMD_READ_F);\n\tcaps_cmd.cfvalid_to_len16 = htonl(FW_LEN16(caps_cmd));\n\tret = t4_wr_mbox(adap, adap->mbox, &caps_cmd, sizeof(caps_cmd),\n\t\t\t &caps_cmd);\n\tif (ret < 0)\n\t\tgoto bye;\n\n\t/* hash filter has some mandatory register settings to be tested and for\n\t * that it needs to test whether offload is enabled or not, hence\n\t * checking and setting it here.\n\t */\n\tif (caps_cmd.ofldcaps)\n\t\tadap->params.offload = 1;\n\n\tif (caps_cmd.ofldcaps ||\n\t    (caps_cmd.niccaps & htons(FW_CAPS_CONFIG_NIC_HASHFILTER)) ||\n\t    (caps_cmd.niccaps & htons(FW_CAPS_CONFIG_NIC_ETHOFLD))) {\n\t\t/* query offload-related parameters */\n\t\tparams[0] = FW_PARAM_DEV(NTID);\n\t\tparams[1] = FW_PARAM_PFVF(SERVER_START);\n\t\tparams[2] = FW_PARAM_PFVF(SERVER_END);\n\t\tparams[3] = FW_PARAM_PFVF(TDDP_START);\n\t\tparams[4] = FW_PARAM_PFVF(TDDP_END);\n\t\tparams[5] = FW_PARAM_DEV(FLOWC_BUFFIFO_SZ);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 6,\n\t\t\t\t      params, val);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t\tadap->tids.ntids = val[0];\n\t\tadap->tids.natids = min(adap->tids.ntids / 2, MAX_ATIDS);\n\t\tadap->tids.stid_base = val[1];\n\t\tadap->tids.nstids = val[2] - val[1] + 1;\n\t\t/*\n\t\t * Setup server filter region. Divide the available filter\n\t\t * region into two parts. Regular filters get 1/3rd and server\n\t\t * filters get 2/3rd part. This is only enabled if workarond\n\t\t * path is enabled.\n\t\t * 1. For regular filters.\n\t\t * 2. Server filter: This are special filters which are used\n\t\t * to redirect SYN packets to offload queue.\n\t\t */\n\t\tif (adap->flags & CXGB4_FW_OFLD_CONN && !is_bypass(adap)) {\n\t\t\tadap->tids.sftid_base = adap->tids.ftid_base +\n\t\t\t\t\tDIV_ROUND_UP(adap->tids.nftids, 3);\n\t\t\tadap->tids.nsftids = adap->tids.nftids -\n\t\t\t\t\t DIV_ROUND_UP(adap->tids.nftids, 3);\n\t\t\tadap->tids.nftids = adap->tids.sftid_base -\n\t\t\t\t\t\tadap->tids.ftid_base;\n\t\t}\n\t\tadap->vres.ddp.start = val[3];\n\t\tadap->vres.ddp.size = val[4] - val[3] + 1;\n\t\tadap->params.ofldq_wr_cred = val[5];\n\n\t\tif (caps_cmd.niccaps & htons(FW_CAPS_CONFIG_NIC_HASHFILTER)) {\n\t\t\tinit_hash_filter(adap);\n\t\t} else {\n\t\t\tadap->num_ofld_uld += 1;\n\t\t}\n\n\t\tif (caps_cmd.niccaps & htons(FW_CAPS_CONFIG_NIC_ETHOFLD)) {\n\t\t\tparams[0] = FW_PARAM_PFVF(ETHOFLD_START);\n\t\t\tparams[1] = FW_PARAM_PFVF(ETHOFLD_END);\n\t\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2,\n\t\t\t\t\t      params, val);\n\t\t\tif (!ret) {\n\t\t\t\tadap->tids.eotid_base = val[0];\n\t\t\t\tadap->tids.neotids = min_t(u32, MAX_ATIDS,\n\t\t\t\t\t\t\t   val[1] - val[0] + 1);\n\t\t\t\tadap->params.ethofld = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (caps_cmd.rdmacaps) {\n\t\tparams[0] = FW_PARAM_PFVF(STAG_START);\n\t\tparams[1] = FW_PARAM_PFVF(STAG_END);\n\t\tparams[2] = FW_PARAM_PFVF(RQ_START);\n\t\tparams[3] = FW_PARAM_PFVF(RQ_END);\n\t\tparams[4] = FW_PARAM_PFVF(PBL_START);\n\t\tparams[5] = FW_PARAM_PFVF(PBL_END);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 6,\n\t\t\t\t      params, val);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t\tadap->vres.stag.start = val[0];\n\t\tadap->vres.stag.size = val[1] - val[0] + 1;\n\t\tadap->vres.rq.start = val[2];\n\t\tadap->vres.rq.size = val[3] - val[2] + 1;\n\t\tadap->vres.pbl.start = val[4];\n\t\tadap->vres.pbl.size = val[5] - val[4] + 1;\n\n\t\tparams[0] = FW_PARAM_PFVF(SRQ_START);\n\t\tparams[1] = FW_PARAM_PFVF(SRQ_END);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2,\n\t\t\t\t      params, val);\n\t\tif (!ret) {\n\t\t\tadap->vres.srq.start = val[0];\n\t\t\tadap->vres.srq.size = val[1] - val[0] + 1;\n\t\t}\n\t\tif (adap->vres.srq.size) {\n\t\t\tadap->srq = t4_init_srq(adap->vres.srq.size);\n\t\t\tif (!adap->srq)\n\t\t\t\tdev_warn(&adap->pdev->dev, \"could not allocate SRQ, continuing\\n\");\n\t\t}\n\n\t\tparams[0] = FW_PARAM_PFVF(SQRQ_START);\n\t\tparams[1] = FW_PARAM_PFVF(SQRQ_END);\n\t\tparams[2] = FW_PARAM_PFVF(CQ_START);\n\t\tparams[3] = FW_PARAM_PFVF(CQ_END);\n\t\tparams[4] = FW_PARAM_PFVF(OCQ_START);\n\t\tparams[5] = FW_PARAM_PFVF(OCQ_END);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 6, params,\n\t\t\t\t      val);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t\tadap->vres.qp.start = val[0];\n\t\tadap->vres.qp.size = val[1] - val[0] + 1;\n\t\tadap->vres.cq.start = val[2];\n\t\tadap->vres.cq.size = val[3] - val[2] + 1;\n\t\tadap->vres.ocq.start = val[4];\n\t\tadap->vres.ocq.size = val[5] - val[4] + 1;\n\n\t\tparams[0] = FW_PARAM_DEV(MAXORDIRD_QP);\n\t\tparams[1] = FW_PARAM_DEV(MAXIRD_ADAPTER);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2, params,\n\t\t\t\t      val);\n\t\tif (ret < 0) {\n\t\t\tadap->params.max_ordird_qp = 8;\n\t\t\tadap->params.max_ird_adapter = 32 * adap->tids.ntids;\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tadap->params.max_ordird_qp = val[0];\n\t\t\tadap->params.max_ird_adapter = val[1];\n\t\t}\n\t\tdev_info(adap->pdev_dev,\n\t\t\t \"max_ordird_qp %d max_ird_adapter %d\\n\",\n\t\t\t adap->params.max_ordird_qp,\n\t\t\t adap->params.max_ird_adapter);\n\n\t\t/* Enable write_with_immediate if FW supports it */\n\t\tparams[0] = FW_PARAM_DEV(RDMA_WRITE_WITH_IMM);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 1, params,\n\t\t\t\t      val);\n\t\tadap->params.write_w_imm_support = (ret == 0 && val[0] != 0);\n\n\t\t/* Enable write_cmpl if FW supports it */\n\t\tparams[0] = FW_PARAM_DEV(RI_WRITE_CMPL_WR);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 1, params,\n\t\t\t\t      val);\n\t\tadap->params.write_cmpl_support = (ret == 0 && val[0] != 0);\n\t\tadap->num_ofld_uld += 2;\n\t}\n\tif (caps_cmd.iscsicaps) {\n\t\tparams[0] = FW_PARAM_PFVF(ISCSI_START);\n\t\tparams[1] = FW_PARAM_PFVF(ISCSI_END);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2,\n\t\t\t\t      params, val);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t\tadap->vres.iscsi.start = val[0];\n\t\tadap->vres.iscsi.size = val[1] - val[0] + 1;\n\t\tif (is_t6(adap->params.chip)) {\n\t\t\tparams[0] = FW_PARAM_PFVF(PPOD_EDRAM_START);\n\t\t\tparams[1] = FW_PARAM_PFVF(PPOD_EDRAM_END);\n\t\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2,\n\t\t\t\t\t      params, val);\n\t\t\tif (!ret) {\n\t\t\t\tadap->vres.ppod_edram.start = val[0];\n\t\t\t\tadap->vres.ppod_edram.size =\n\t\t\t\t\tval[1] - val[0] + 1;\n\n\t\t\t\tdev_info(adap->pdev_dev,\n\t\t\t\t\t \"ppod edram start 0x%x end 0x%x size 0x%x\\n\",\n\t\t\t\t\t val[0], val[1],\n\t\t\t\t\t adap->vres.ppod_edram.size);\n\t\t\t}\n\t\t}\n\t\t/* LIO target and cxgb4i initiaitor */\n\t\tadap->num_ofld_uld += 2;\n\t}\n\tif (caps_cmd.cryptocaps) {\n\t\tif (ntohs(caps_cmd.cryptocaps) &\n\t\t    FW_CAPS_CONFIG_CRYPTO_LOOKASIDE) {\n\t\t\tparams[0] = FW_PARAM_PFVF(NCRYPTO_LOOKASIDE);\n\t\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0,\n\t\t\t\t\t      2, params, val);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (ret != -EINVAL)\n\t\t\t\t\tgoto bye;\n\t\t\t} else {\n\t\t\t\tadap->vres.ncrypto_fc = val[0];\n\t\t\t}\n\t\t\tadap->num_ofld_uld += 1;\n\t\t}\n\t\tif (ntohs(caps_cmd.cryptocaps) &\n\t\t    FW_CAPS_CONFIG_TLS_INLINE) {\n\t\t\tparams[0] = FW_PARAM_PFVF(TLS_START);\n\t\t\tparams[1] = FW_PARAM_PFVF(TLS_END);\n\t\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0,\n\t\t\t\t\t      2, params, val);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto bye;\n\t\t\tadap->vres.key.start = val[0];\n\t\t\tadap->vres.key.size = val[1] - val[0] + 1;\n\t\t\tadap->num_uld += 1;\n\t\t}\n\t\tadap->params.crypto = ntohs(caps_cmd.cryptocaps);\n\t}\n\n\t/* The MTU/MSS Table is initialized by now, so load their values.  If\n\t * we're initializing the adapter, then we'll make any modifications\n\t * we want to the MTU/MSS Table and also initialize the congestion\n\t * parameters.\n\t */\n\tt4_read_mtu_tbl(adap, adap->params.mtus, NULL);\n\tif (state != DEV_STATE_INIT) {\n\t\tint i;\n\n\t\t/* The default MTU Table contains values 1492 and 1500.\n\t\t * However, for TCP, it's better to have two values which are\n\t\t * a multiple of 8 +/- 4 bytes apart near this popular MTU.\n\t\t * This allows us to have a TCP Data Payload which is a\n\t\t * multiple of 8 regardless of what combination of TCP Options\n\t\t * are in use (always a multiple of 4 bytes) which is\n\t\t * important for performance reasons.  For instance, if no\n\t\t * options are in use, then we have a 20-byte IP header and a\n\t\t * 20-byte TCP header.  In this case, a 1500-byte MSS would\n\t\t * result in a TCP Data Payload of 1500 - 40 == 1460 bytes\n\t\t * which is not a multiple of 8.  So using an MSS of 1488 in\n\t\t * this case results in a TCP Data Payload of 1448 bytes which\n\t\t * is a multiple of 8.  On the other hand, if 12-byte TCP Time\n\t\t * Stamps have been negotiated, then an MTU of 1500 bytes\n\t\t * results in a TCP Data Payload of 1448 bytes which, as\n\t\t * above, is a multiple of 8 bytes ...\n\t\t */\n\t\tfor (i = 0; i < NMTUS; i++)\n\t\t\tif (adap->params.mtus[i] == 1492) {\n\t\t\t\tadap->params.mtus[i] = 1488;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tt4_load_mtus(adap, adap->params.mtus, adap->params.a_wnd,\n\t\t\t     adap->params.b_wnd);\n\t}\n\tt4_init_sge_params(adap);\n\tadap->flags |= CXGB4_FW_OK;\n\tt4_init_tp_params(adap, true);\n\treturn 0;\n\n\t/*\n\t * Something bad happened.  If a command timed out or failed with EIO\n\t * FW does not operate within its spec or something catastrophic\n\t * happened to HW/FW, stop issuing commands.\n\t */\nbye:\n\tadap_free_hma_mem(adap);\n\tkfree(adap->sge.egr_map);\n\tkfree(adap->sge.ingr_map);\n\tkfree(adap->sge.starving_fl);\n\tkfree(adap->sge.txq_maperr);\n#ifdef CONFIG_DEBUG_FS\n\tkfree(adap->sge.blocked_fl);\n#endif\n\tif (ret != -ETIMEDOUT && ret != -EIO)\n\t\tt4_fw_bye(adap, adap->mbox);\n\treturn ret;\n}\n\n/* EEH callbacks */\n\nstatic pci_ers_result_t eeh_err_detected(struct pci_dev *pdev,\n\t\t\t\t\t pci_channel_state_t state)\n{\n\tint i;\n\tstruct adapter *adap = pci_get_drvdata(pdev);\n\n\tif (!adap)\n\t\tgoto out;\n\n\trtnl_lock();\n\tadap->flags &= ~CXGB4_FW_OK;\n\tnotify_ulds(adap, CXGB4_STATE_START_RECOVERY);\n\tspin_lock(&adap->stats_lock);\n\tfor_each_port(adap, i) {\n\t\tstruct net_device *dev = adap->port[i];\n\t\tif (dev) {\n\t\t\tnetif_device_detach(dev);\n\t\t\tnetif_carrier_off(dev);\n\t\t}\n\t}\n\tspin_unlock(&adap->stats_lock);\n\tdisable_interrupts(adap);\n\tif (adap->flags & CXGB4_FULL_INIT_DONE)\n\t\tcxgb_down(adap);\n\trtnl_unlock();\n\tif ((adap->flags & CXGB4_DEV_ENABLED)) {\n\t\tpci_disable_device(pdev);\n\t\tadap->flags &= ~CXGB4_DEV_ENABLED;\n\t}\nout:\treturn state == pci_channel_io_perm_failure ?\n\t\tPCI_ERS_RESULT_DISCONNECT : PCI_ERS_RESULT_NEED_RESET;\n}\n\nstatic pci_ers_result_t eeh_slot_reset(struct pci_dev *pdev)\n{\n\tint i, ret;\n\tstruct fw_caps_config_cmd c;\n\tstruct adapter *adap = pci_get_drvdata(pdev);\n\n\tif (!adap) {\n\t\tpci_restore_state(pdev);\n\t\tpci_save_state(pdev);\n\t\treturn PCI_ERS_RESULT_RECOVERED;\n\t}\n\n\tif (!(adap->flags & CXGB4_DEV_ENABLED)) {\n\t\tif (pci_enable_device(pdev)) {\n\t\t\tdev_err(&pdev->dev, \"Cannot reenable PCI \"\n\t\t\t\t\t    \"device after reset\\n\");\n\t\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t\t}\n\t\tadap->flags |= CXGB4_DEV_ENABLED;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_restore_state(pdev);\n\tpci_save_state(pdev);\n\n\tif (t4_wait_dev_ready(adap->regs) < 0)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\tif (t4_fw_hello(adap, adap->mbox, adap->pf, MASTER_MUST, NULL) < 0)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\tadap->flags |= CXGB4_FW_OK;\n\tif (adap_init1(adap, &c))\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tfor_each_port(adap, i) {\n\t\tstruct port_info *pi = adap2pinfo(adap, i);\n\t\tu8 vivld = 0, vin = 0;\n\n\t\tret = t4_alloc_vi(adap, adap->mbox, pi->tx_chan, adap->pf, 0, 1,\n\t\t\t\t  NULL, NULL, &vivld, &vin);\n\t\tif (ret < 0)\n\t\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t\tpi->viid = ret;\n\t\tpi->xact_addr_filt = -1;\n\t\t/* If fw supports returning the VIN as part of FW_VI_CMD,\n\t\t * save the returned values.\n\t\t */\n\t\tif (adap->params.viid_smt_extn_support) {\n\t\t\tpi->vivld = vivld;\n\t\t\tpi->vin = vin;\n\t\t} else {\n\t\t\t/* Retrieve the values from VIID */\n\t\t\tpi->vivld = FW_VIID_VIVLD_G(pi->viid);\n\t\t\tpi->vin = FW_VIID_VIN_G(pi->viid);\n\t\t}\n\t}\n\n\tt4_load_mtus(adap, adap->params.mtus, adap->params.a_wnd,\n\t\t     adap->params.b_wnd);\n\tsetup_memwin(adap);\n\tif (cxgb_up(adap))\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\nstatic void eeh_resume(struct pci_dev *pdev)\n{\n\tint i;\n\tstruct adapter *adap = pci_get_drvdata(pdev);\n\n\tif (!adap)\n\t\treturn;\n\n\trtnl_lock();\n\tfor_each_port(adap, i) {\n\t\tstruct net_device *dev = adap->port[i];\n\t\tif (dev) {\n\t\t\tif (netif_running(dev)) {\n\t\t\t\tlink_start(dev);\n\t\t\t\tcxgb_set_rxmode(dev);\n\t\t\t}\n\t\t\tnetif_device_attach(dev);\n\t\t}\n\t}\n\trtnl_unlock();\n}\n\nstatic void eeh_reset_prepare(struct pci_dev *pdev)\n{\n\tstruct adapter *adapter = pci_get_drvdata(pdev);\n\tint i;\n\n\tif (adapter->pf != 4)\n\t\treturn;\n\n\tadapter->flags &= ~CXGB4_FW_OK;\n\n\tnotify_ulds(adapter, CXGB4_STATE_DOWN);\n\n\tfor_each_port(adapter, i)\n\t\tif (adapter->port[i]->reg_state == NETREG_REGISTERED)\n\t\t\tcxgb_close(adapter->port[i]);\n\n\tdisable_interrupts(adapter);\n\tcxgb4_free_mps_ref_entries(adapter);\n\n\tadap_free_hma_mem(adapter);\n\n\tif (adapter->flags & CXGB4_FULL_INIT_DONE)\n\t\tcxgb_down(adapter);\n}\n\nstatic void eeh_reset_done(struct pci_dev *pdev)\n{\n\tstruct adapter *adapter = pci_get_drvdata(pdev);\n\tint err, i;\n\n\tif (adapter->pf != 4)\n\t\treturn;\n\n\terr = t4_wait_dev_ready(adapter->regs);\n\tif (err < 0) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"Device not ready, err %d\", err);\n\t\treturn;\n\t}\n\n\tsetup_memwin(adapter);\n\n\terr = adap_init0(adapter, 1);\n\tif (err) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"Adapter init failed, err %d\", err);\n\t\treturn;\n\t}\n\n\tsetup_memwin_rdma(adapter);\n\n\tif (adapter->flags & CXGB4_FW_OK) {\n\t\terr = t4_port_init(adapter, adapter->pf, adapter->pf, 0);\n\t\tif (err) {\n\t\t\tdev_err(adapter->pdev_dev,\n\t\t\t\t\"Port init failed, err %d\", err);\n\t\t\treturn;\n\t\t}\n\t}\n\n\terr = cfg_queues(adapter);\n\tif (err) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"Config queues failed, err %d\", err);\n\t\treturn;\n\t}\n\n\tcxgb4_init_mps_ref_entries(adapter);\n\n\terr = setup_fw_sge_queues(adapter);\n\tif (err) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"FW sge queue allocation failed, err %d\", err);\n\t\treturn;\n\t}\n\n\tfor_each_port(adapter, i)\n\t\tif (adapter->port[i]->reg_state == NETREG_REGISTERED)\n\t\t\tcxgb_open(adapter->port[i]);\n}\n\nstatic const struct pci_error_handlers cxgb4_eeh = {\n\t.error_detected = eeh_err_detected,\n\t.slot_reset     = eeh_slot_reset,\n\t.resume         = eeh_resume,\n\t.reset_prepare  = eeh_reset_prepare,\n\t.reset_done     = eeh_reset_done,\n};\n\n/* Return true if the Link Configuration supports \"High Speeds\" (those greater\n * than 1Gb/s).\n */\nstatic inline bool is_x_10g_port(const struct link_config *lc)\n{\n\tunsigned int speeds, high_speeds;\n\n\tspeeds = FW_PORT_CAP32_SPEED_V(FW_PORT_CAP32_SPEED_G(lc->pcaps));\n\thigh_speeds = speeds &\n\t\t\t~(FW_PORT_CAP32_SPEED_100M | FW_PORT_CAP32_SPEED_1G);\n\n\treturn high_speeds != 0;\n}\n\n/* Perform default configuration of DMA queues depending on the number and type\n * of ports we found and the number of available CPUs.  Most settings can be\n * modified by the admin prior to actual use.\n */\nstatic int cfg_queues(struct adapter *adap)\n{\n\tu32 avail_qsets, avail_eth_qsets, avail_uld_qsets;\n\tu32 ncpus = num_online_cpus();\n\tu32 niqflint, neq, num_ulds;\n\tstruct sge *s = &adap->sge;\n\tu32 i, n10g = 0, qidx = 0;\n\tu32 q10g = 0, q1g;\n\n\t/* Reduce memory usage in kdump environment, disable all offload. */\n\tif (is_kdump_kernel() || (is_uld(adap) && t4_uld_mem_alloc(adap))) {\n\t\tadap->params.offload = 0;\n\t\tadap->params.crypto = 0;\n\t\tadap->params.ethofld = 0;\n\t}\n\n\t/* Calculate the number of Ethernet Queue Sets available based on\n\t * resources provisioned for us.  We always have an Asynchronous\n\t * Firmware Event Ingress Queue.  If we're operating in MSI or Legacy\n\t * IRQ Pin Interrupt mode, then we'll also have a Forwarded Interrupt\n\t * Ingress Queue.  Meanwhile, we need two Egress Queues for each\n\t * Queue Set: one for the Free List and one for the Ethernet TX Queue.\n\t *\n\t * Note that we should also take into account all of the various\n\t * Offload Queues.  But, in any situation where we're operating in\n\t * a Resource Constrained Provisioning environment, doing any Offload\n\t * at all is problematic ...\n\t */\n\tniqflint = adap->params.pfres.niqflint - 1;\n\tif (!(adap->flags & CXGB4_USING_MSIX))\n\t\tniqflint--;\n\tneq = adap->params.pfres.neq / 2;\n\tavail_qsets = min(niqflint, neq);\n\n\tif (avail_qsets < adap->params.nports) {\n\t\tdev_err(adap->pdev_dev, \"avail_eth_qsets=%d < nports=%d\\n\",\n\t\t\tavail_qsets, adap->params.nports);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Count the number of 10Gb/s or better ports */\n\tfor_each_port(adap, i)\n\t\tn10g += is_x_10g_port(&adap2pinfo(adap, i)->link_cfg);\n\n\tavail_eth_qsets = min_t(u32, avail_qsets, MAX_ETH_QSETS);\n\n\t/* We default to 1 queue per non-10G port and up to # of cores queues\n\t * per 10G port.\n\t */\n\tif (n10g)\n\t\tq10g = (avail_eth_qsets - (adap->params.nports - n10g)) / n10g;\n\n#ifdef CONFIG_CHELSIO_T4_DCB\n\t/* For Data Center Bridging support we need to be able to support up\n\t * to 8 Traffic Priorities; each of which will be assigned to its\n\t * own TX Queue in order to prevent Head-Of-Line Blocking.\n\t */\n\tq1g = 8;\n\tif (adap->params.nports * 8 > avail_eth_qsets) {\n\t\tdev_err(adap->pdev_dev, \"DCB avail_eth_qsets=%d < %d!\\n\",\n\t\t\tavail_eth_qsets, adap->params.nports * 8);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (adap->params.nports * ncpus < avail_eth_qsets)\n\t\tq10g = max(8U, ncpus);\n\telse\n\t\tq10g = max(8U, q10g);\n\n\twhile ((q10g * n10g) >\n\t       (avail_eth_qsets - (adap->params.nports - n10g) * q1g))\n\t\tq10g--;\n\n#else /* !CONFIG_CHELSIO_T4_DCB */\n\tq1g = 1;\n\tq10g = min(q10g, ncpus);\n#endif /* !CONFIG_CHELSIO_T4_DCB */\n\tif (is_kdump_kernel()) {\n\t\tq10g = 1;\n\t\tq1g = 1;\n\t}\n\n\tfor_each_port(adap, i) {\n\t\tstruct port_info *pi = adap2pinfo(adap, i);\n\n\t\tpi->first_qset = qidx;\n\t\tpi->nqsets = is_x_10g_port(&pi->link_cfg) ? q10g : q1g;\n\t\tqidx += pi->nqsets;\n\t}\n\n\ts->ethqsets = qidx;\n\ts->max_ethqsets = qidx;   /* MSI-X may lower it later */\n\tavail_qsets -= qidx;\n\n\tif (is_uld(adap)) {\n\t\t/* For offload we use 1 queue/channel if all ports are up to 1G,\n\t\t * otherwise we divide all available queues amongst the channels\n\t\t * capped by the number of available cores.\n\t\t */\n\t\tnum_ulds = adap->num_uld + adap->num_ofld_uld;\n\t\ti = min_t(u32, MAX_OFLD_QSETS, ncpus);\n\t\tavail_uld_qsets = roundup(i, adap->params.nports);\n\t\tif (avail_qsets < num_ulds * adap->params.nports) {\n\t\t\tadap->params.offload = 0;\n\t\t\tadap->params.crypto = 0;\n\t\t\ts->ofldqsets = 0;\n\t\t} else if (avail_qsets < num_ulds * avail_uld_qsets || !n10g) {\n\t\t\ts->ofldqsets = adap->params.nports;\n\t\t} else {\n\t\t\ts->ofldqsets = avail_uld_qsets;\n\t\t}\n\n\t\tavail_qsets -= num_ulds * s->ofldqsets;\n\t}\n\n\t/* ETHOFLD Queues used for QoS offload should follow same\n\t * allocation scheme as normal Ethernet Queues.\n\t */\n\tif (is_ethofld(adap)) {\n\t\tif (avail_qsets < s->max_ethqsets) {\n\t\t\tadap->params.ethofld = 0;\n\t\t\ts->eoqsets = 0;\n\t\t} else {\n\t\t\ts->eoqsets = s->max_ethqsets;\n\t\t}\n\t\tavail_qsets -= s->eoqsets;\n\t}\n\n\t/* Mirror queues must follow same scheme as normal Ethernet\n\t * Queues, when there are enough queues available. Otherwise,\n\t * allocate at least 1 queue per port. If even 1 queue is not\n\t * available, then disable mirror queues support.\n\t */\n\tif (avail_qsets >= s->max_ethqsets)\n\t\ts->mirrorqsets = s->max_ethqsets;\n\telse if (avail_qsets >= adap->params.nports)\n\t\ts->mirrorqsets = adap->params.nports;\n\telse\n\t\ts->mirrorqsets = 0;\n\tavail_qsets -= s->mirrorqsets;\n\n\tfor (i = 0; i < ARRAY_SIZE(s->ethrxq); i++) {\n\t\tstruct sge_eth_rxq *r = &s->ethrxq[i];\n\n\t\tinit_rspq(adap, &r->rspq, 5, 10, 1024, 64);\n\t\tr->fl.size = 72;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(s->ethtxq); i++)\n\t\ts->ethtxq[i].q.size = 1024;\n\n\tfor (i = 0; i < ARRAY_SIZE(s->ctrlq); i++)\n\t\ts->ctrlq[i].q.size = 512;\n\n\tif (!is_t4(adap->params.chip))\n\t\ts->ptptxq.q.size = 8;\n\n\tinit_rspq(adap, &s->fw_evtq, 0, 1, 1024, 64);\n\tinit_rspq(adap, &s->intrq, 0, 1, 512, 64);\n\n\treturn 0;\n}\n\n/*\n * Reduce the number of Ethernet queues across all ports to at most n.\n * n provides at least one queue per port.\n */\nstatic void reduce_ethqs(struct adapter *adap, int n)\n{\n\tint i;\n\tstruct port_info *pi;\n\n\twhile (n < adap->sge.ethqsets)\n\t\tfor_each_port(adap, i) {\n\t\t\tpi = adap2pinfo(adap, i);\n\t\t\tif (pi->nqsets > 1) {\n\t\t\t\tpi->nqsets--;\n\t\t\t\tadap->sge.ethqsets--;\n\t\t\t\tif (adap->sge.ethqsets <= n)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tn = 0;\n\tfor_each_port(adap, i) {\n\t\tpi = adap2pinfo(adap, i);\n\t\tpi->first_qset = n;\n\t\tn += pi->nqsets;\n\t}\n}\n\nstatic int alloc_msix_info(struct adapter *adap, u32 num_vec)\n{\n\tstruct msix_info *msix_info;\n\n\tmsix_info = kcalloc(num_vec, sizeof(*msix_info), GFP_KERNEL);\n\tif (!msix_info)\n\t\treturn -ENOMEM;\n\n\tadap->msix_bmap.msix_bmap = kcalloc(BITS_TO_LONGS(num_vec),\n\t\t\t\t\t    sizeof(long), GFP_KERNEL);\n\tif (!adap->msix_bmap.msix_bmap) {\n\t\tkfree(msix_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_init(&adap->msix_bmap.lock);\n\tadap->msix_bmap.mapsize = num_vec;\n\n\tadap->msix_info = msix_info;\n\treturn 0;\n}\n\nstatic void free_msix_info(struct adapter *adap)\n{\n\tkfree(adap->msix_bmap.msix_bmap);\n\tkfree(adap->msix_info);\n}\n\nint cxgb4_get_msix_idx_from_bmap(struct adapter *adap)\n{\n\tstruct msix_bmap *bmap = &adap->msix_bmap;\n\tunsigned int msix_idx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bmap->lock, flags);\n\tmsix_idx = find_first_zero_bit(bmap->msix_bmap, bmap->mapsize);\n\tif (msix_idx < bmap->mapsize) {\n\t\t__set_bit(msix_idx, bmap->msix_bmap);\n\t} else {\n\t\tspin_unlock_irqrestore(&bmap->lock, flags);\n\t\treturn -ENOSPC;\n\t}\n\n\tspin_unlock_irqrestore(&bmap->lock, flags);\n\treturn msix_idx;\n}\n\nvoid cxgb4_free_msix_idx_in_bmap(struct adapter *adap,\n\t\t\t\t unsigned int msix_idx)\n{\n\tstruct msix_bmap *bmap = &adap->msix_bmap;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bmap->lock, flags);\n\t__clear_bit(msix_idx, bmap->msix_bmap);\n\tspin_unlock_irqrestore(&bmap->lock, flags);\n}\n\n/* 2 MSI-X vectors needed for the FW queue and non-data interrupts */\n#define EXTRA_VECS 2\n\nstatic int enable_msix(struct adapter *adap)\n{\n\tu32 eth_need, uld_need = 0, ethofld_need = 0, mirror_need = 0;\n\tu32 ethqsets = 0, ofldqsets = 0, eoqsets = 0, mirrorqsets = 0;\n\tu8 num_uld = 0, nchan = adap->params.nports;\n\tu32 i, want, need, num_vec;\n\tstruct sge *s = &adap->sge;\n\tstruct msix_entry *entries;\n\tstruct port_info *pi;\n\tint allocated, ret;\n\n\twant = s->max_ethqsets;\n#ifdef CONFIG_CHELSIO_T4_DCB\n\t/* For Data Center Bridging we need 8 Ethernet TX Priority Queues for\n\t * each port.\n\t */\n\tneed = 8 * nchan;\n#else\n\tneed = nchan;\n#endif\n\teth_need = need;\n\tif (is_uld(adap)) {\n\t\tnum_uld = adap->num_ofld_uld + adap->num_uld;\n\t\twant += num_uld * s->ofldqsets;\n\t\tuld_need = num_uld * nchan;\n\t\tneed += uld_need;\n\t}\n\n\tif (is_ethofld(adap)) {\n\t\twant += s->eoqsets;\n\t\tethofld_need = eth_need;\n\t\tneed += ethofld_need;\n\t}\n\n\tif (s->mirrorqsets) {\n\t\twant += s->mirrorqsets;\n\t\tmirror_need = nchan;\n\t\tneed += mirror_need;\n\t}\n\n\twant += EXTRA_VECS;\n\tneed += EXTRA_VECS;\n\n\tentries = kmalloc_array(want, sizeof(*entries), GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < want; i++)\n\t\tentries[i].entry = i;\n\n\tallocated = pci_enable_msix_range(adap->pdev, entries, need, want);\n\tif (allocated < 0) {\n\t\t/* Disable offload and attempt to get vectors for NIC\n\t\t * only mode.\n\t\t */\n\t\twant = s->max_ethqsets + EXTRA_VECS;\n\t\tneed = eth_need + EXTRA_VECS;\n\t\tallocated = pci_enable_msix_range(adap->pdev, entries,\n\t\t\t\t\t\t  need, want);\n\t\tif (allocated < 0) {\n\t\t\tdev_info(adap->pdev_dev,\n\t\t\t\t \"Disabling MSI-X due to insufficient MSI-X vectors\\n\");\n\t\t\tret = allocated;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tdev_info(adap->pdev_dev,\n\t\t\t \"Disabling offload due to insufficient MSI-X vectors\\n\");\n\t\tadap->params.offload = 0;\n\t\tadap->params.crypto = 0;\n\t\tadap->params.ethofld = 0;\n\t\ts->ofldqsets = 0;\n\t\ts->eoqsets = 0;\n\t\ts->mirrorqsets = 0;\n\t\tuld_need = 0;\n\t\tethofld_need = 0;\n\t\tmirror_need = 0;\n\t}\n\n\tnum_vec = allocated;\n\tif (num_vec < want) {\n\t\t/* Distribute available vectors to the various queue groups.\n\t\t * Every group gets its minimum requirement and NIC gets top\n\t\t * priority for leftovers.\n\t\t */\n\t\tethqsets = eth_need;\n\t\tif (is_uld(adap))\n\t\t\tofldqsets = nchan;\n\t\tif (is_ethofld(adap))\n\t\t\teoqsets = ethofld_need;\n\t\tif (s->mirrorqsets)\n\t\t\tmirrorqsets = mirror_need;\n\n\t\tnum_vec -= need;\n\t\twhile (num_vec) {\n\t\t\tif (num_vec < eth_need + ethofld_need ||\n\t\t\t    ethqsets > s->max_ethqsets)\n\t\t\t\tbreak;\n\n\t\t\tfor_each_port(adap, i) {\n\t\t\t\tpi = adap2pinfo(adap, i);\n\t\t\t\tif (pi->nqsets < 2)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tethqsets++;\n\t\t\t\tnum_vec--;\n\t\t\t\tif (ethofld_need) {\n\t\t\t\t\teoqsets++;\n\t\t\t\t\tnum_vec--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (is_uld(adap)) {\n\t\t\twhile (num_vec) {\n\t\t\t\tif (num_vec < uld_need ||\n\t\t\t\t    ofldqsets > s->ofldqsets)\n\t\t\t\t\tbreak;\n\n\t\t\t\tofldqsets++;\n\t\t\t\tnum_vec -= uld_need;\n\t\t\t}\n\t\t}\n\n\t\tif (s->mirrorqsets) {\n\t\t\twhile (num_vec) {\n\t\t\t\tif (num_vec < mirror_need ||\n\t\t\t\t    mirrorqsets > s->mirrorqsets)\n\t\t\t\t\tbreak;\n\n\t\t\t\tmirrorqsets++;\n\t\t\t\tnum_vec -= mirror_need;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tethqsets = s->max_ethqsets;\n\t\tif (is_uld(adap))\n\t\t\tofldqsets = s->ofldqsets;\n\t\tif (is_ethofld(adap))\n\t\t\teoqsets = s->eoqsets;\n\t\tif (s->mirrorqsets)\n\t\t\tmirrorqsets = s->mirrorqsets;\n\t}\n\n\tif (ethqsets < s->max_ethqsets) {\n\t\ts->max_ethqsets = ethqsets;\n\t\treduce_ethqs(adap, ethqsets);\n\t}\n\n\tif (is_uld(adap)) {\n\t\ts->ofldqsets = ofldqsets;\n\t\ts->nqs_per_uld = s->ofldqsets;\n\t}\n\n\tif (is_ethofld(adap))\n\t\ts->eoqsets = eoqsets;\n\n\tif (s->mirrorqsets) {\n\t\ts->mirrorqsets = mirrorqsets;\n\t\tfor_each_port(adap, i) {\n\t\t\tpi = adap2pinfo(adap, i);\n\t\t\tpi->nmirrorqsets = s->mirrorqsets / nchan;\n\t\t\tmutex_init(&pi->vi_mirror_mutex);\n\t\t}\n\t}\n\n\t/* map for msix */\n\tret = alloc_msix_info(adap, allocated);\n\tif (ret)\n\t\tgoto out_disable_msix;\n\n\tfor (i = 0; i < allocated; i++) {\n\t\tadap->msix_info[i].vec = entries[i].vector;\n\t\tadap->msix_info[i].idx = i;\n\t}\n\n\tdev_info(adap->pdev_dev,\n\t\t \"%d MSI-X vectors allocated, nic %d eoqsets %d per uld %d mirrorqsets %d\\n\",\n\t\t allocated, s->max_ethqsets, s->eoqsets, s->nqs_per_uld,\n\t\t s->mirrorqsets);\n\n\tkfree(entries);\n\treturn 0;\n\nout_disable_msix:\n\tpci_disable_msix(adap->pdev);\n\nout_free:\n\tkfree(entries);\n\treturn ret;\n}\n\n#undef EXTRA_VECS\n\nstatic int init_rss(struct adapter *adap)\n{\n\tunsigned int i;\n\tint err;\n\n\terr = t4_init_rss_mode(adap, adap->mbox);\n\tif (err)\n\t\treturn err;\n\n\tfor_each_port(adap, i) {\n\t\tstruct port_info *pi = adap2pinfo(adap, i);\n\n\t\tpi->rss = kcalloc(pi->rss_size, sizeof(u16), GFP_KERNEL);\n\t\tif (!pi->rss)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n/* Dump basic information about the adapter */\nstatic void print_adapter_info(struct adapter *adapter)\n{\n\t/* Hardware/Firmware/etc. Version/Revision IDs */\n\tt4_dump_version_info(adapter);\n\n\t/* Software/Hardware configuration */\n\tdev_info(adapter->pdev_dev, \"Configuration: %sNIC %s, %s capable\\n\",\n\t\t is_offload(adapter) ? \"R\" : \"\",\n\t\t ((adapter->flags & CXGB4_USING_MSIX) ? \"MSI-X\" :\n\t\t  (adapter->flags & CXGB4_USING_MSI) ? \"MSI\" : \"\"),\n\t\t is_offload(adapter) ? \"Offload\" : \"non-Offload\");\n}\n\nstatic void print_port_info(const struct net_device *dev)\n{\n\tchar buf[80];\n\tchar *bufp = buf;\n\tconst struct port_info *pi = netdev_priv(dev);\n\tconst struct adapter *adap = pi->adapter;\n\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_SPEED_100M)\n\t\tbufp += sprintf(bufp, \"100M/\");\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_SPEED_1G)\n\t\tbufp += sprintf(bufp, \"1G/\");\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_SPEED_10G)\n\t\tbufp += sprintf(bufp, \"10G/\");\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_SPEED_25G)\n\t\tbufp += sprintf(bufp, \"25G/\");\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_SPEED_40G)\n\t\tbufp += sprintf(bufp, \"40G/\");\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_SPEED_50G)\n\t\tbufp += sprintf(bufp, \"50G/\");\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_SPEED_100G)\n\t\tbufp += sprintf(bufp, \"100G/\");\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_SPEED_200G)\n\t\tbufp += sprintf(bufp, \"200G/\");\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_SPEED_400G)\n\t\tbufp += sprintf(bufp, \"400G/\");\n\tif (bufp != buf)\n\t\t--bufp;\n\tsprintf(bufp, \"BASE-%s\", t4_get_port_type_description(pi->port_type));\n\n\tnetdev_info(dev, \"%s: Chelsio %s (%s) %s\\n\",\n\t\t    dev->name, adap->params.vpd.id, adap->name, buf);\n}\n\n/*\n * Free the following resources:\n * - memory used for tables\n * - MSI/MSI-X\n * - net devices\n * - resources FW is holding for us\n */\nstatic void free_some_resources(struct adapter *adapter)\n{\n\tunsigned int i;\n\n\tkvfree(adapter->smt);\n\tkvfree(adapter->l2t);\n\tkvfree(adapter->srq);\n\tt4_cleanup_sched(adapter);\n\tkvfree(adapter->tids.tid_tab);\n\tcxgb4_cleanup_tc_matchall(adapter);\n\tcxgb4_cleanup_tc_mqprio(adapter);\n\tcxgb4_cleanup_tc_flower(adapter);\n\tcxgb4_cleanup_tc_u32(adapter);\n\tcxgb4_cleanup_ethtool_filters(adapter);\n\tkfree(adapter->sge.egr_map);\n\tkfree(adapter->sge.ingr_map);\n\tkfree(adapter->sge.starving_fl);\n\tkfree(adapter->sge.txq_maperr);\n#ifdef CONFIG_DEBUG_FS\n\tkfree(adapter->sge.blocked_fl);\n#endif\n\tdisable_msi(adapter);\n\n\tfor_each_port(adapter, i)\n\t\tif (adapter->port[i]) {\n\t\t\tstruct port_info *pi = adap2pinfo(adapter, i);\n\n\t\t\tif (pi->viid != 0)\n\t\t\t\tt4_free_vi(adapter, adapter->mbox, adapter->pf,\n\t\t\t\t\t   0, pi->viid);\n\t\t\tkfree(adap2pinfo(adapter, i)->rss);\n\t\t\tfree_netdev(adapter->port[i]);\n\t\t}\n\tif (adapter->flags & CXGB4_FW_OK)\n\t\tt4_fw_bye(adapter, adapter->pf);\n}\n\n#define TSO_FLAGS (NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_TSO_ECN | \\\n\t\t   NETIF_F_GSO_UDP_L4)\n#define VLAN_FEAT (NETIF_F_SG | NETIF_F_IP_CSUM | TSO_FLAGS | \\\n\t\t   NETIF_F_GRO | NETIF_F_IPV6_CSUM | NETIF_F_HIGHDMA)\n#define SEGMENT_SIZE 128\n\nstatic int t4_get_chip_type(struct adapter *adap, int ver)\n{\n\tu32 pl_rev = REV_G(t4_read_reg(adap, PL_REV_A));\n\n\tswitch (ver) {\n\tcase CHELSIO_T4:\n\t\treturn CHELSIO_CHIP_CODE(CHELSIO_T4, pl_rev);\n\tcase CHELSIO_T5:\n\t\treturn CHELSIO_CHIP_CODE(CHELSIO_T5, pl_rev);\n\tcase CHELSIO_T6:\n\t\treturn CHELSIO_CHIP_CODE(CHELSIO_T6, pl_rev);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_PCI_IOV\nstatic void cxgb4_mgmt_setup(struct net_device *dev)\n{\n\tdev->type = ARPHRD_NONE;\n\tdev->mtu = 0;\n\tdev->hard_header_len = 0;\n\tdev->addr_len = 0;\n\tdev->tx_queue_len = 0;\n\tdev->flags |= IFF_NOARP;\n\tdev->priv_flags |= IFF_NO_QUEUE;\n\n\t/* Initialize the device structure. */\n\tdev->netdev_ops = &cxgb4_mgmt_netdev_ops;\n\tdev->ethtool_ops = &cxgb4_mgmt_ethtool_ops;\n}\n\nstatic int cxgb4_iov_configure(struct pci_dev *pdev, int num_vfs)\n{\n\tstruct adapter *adap = pci_get_drvdata(pdev);\n\tint err = 0;\n\tint current_vfs = pci_num_vf(pdev);\n\tu32 pcie_fw;\n\n\tpcie_fw = readl(adap->regs + PCIE_FW_A);\n\t/* Check if fw is initialized */\n\tif (!(pcie_fw & PCIE_FW_INIT_F)) {\n\t\tdev_warn(&pdev->dev, \"Device not initialized\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* If any of the VF's is already assigned to Guest OS, then\n\t * SRIOV for the same cannot be modified\n\t */\n\tif (current_vfs && pci_vfs_assigned(pdev)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot modify SR-IOV while VFs are assigned\\n\");\n\t\treturn current_vfs;\n\t}\n\t/* Note that the upper-level code ensures that we're never called with\n\t * a non-zero \"num_vfs\" when we already have VFs instantiated.  But\n\t * it never hurts to code defensively.\n\t */\n\tif (num_vfs != 0 && current_vfs != 0)\n\t\treturn -EBUSY;\n\n\t/* Nothing to do for no change. */\n\tif (num_vfs == current_vfs)\n\t\treturn num_vfs;\n\n\t/* Disable SRIOV when zero is passed. */\n\tif (!num_vfs) {\n\t\tpci_disable_sriov(pdev);\n\t\t/* free VF Management Interface */\n\t\tunregister_netdev(adap->port[0]);\n\t\tfree_netdev(adap->port[0]);\n\t\tadap->port[0] = NULL;\n\n\t\t/* free VF resources */\n\t\tadap->num_vfs = 0;\n\t\tkfree(adap->vfinfo);\n\t\tadap->vfinfo = NULL;\n\t\treturn 0;\n\t}\n\n\tif (!current_vfs) {\n\t\tstruct fw_pfvf_cmd port_cmd, port_rpl;\n\t\tstruct net_device *netdev;\n\t\tunsigned int pmask, port;\n\t\tstruct pci_dev *pbridge;\n\t\tstruct port_info *pi;\n\t\tchar name[IFNAMSIZ];\n\t\tu32 devcap2;\n\t\tu16 flags;\n\n\t\t/* If we want to instantiate Virtual Functions, then our\n\t\t * parent bridge's PCI-E needs to support Alternative Routing\n\t\t * ID (ARI) because our VFs will show up at function offset 8\n\t\t * and above.\n\t\t */\n\t\tpbridge = pdev->bus->self;\n\t\tpcie_capability_read_word(pbridge, PCI_EXP_FLAGS, &flags);\n\t\tpcie_capability_read_dword(pbridge, PCI_EXP_DEVCAP2, &devcap2);\n\n\t\tif ((flags & PCI_EXP_FLAGS_VERS) < 2 ||\n\t\t    !(devcap2 & PCI_EXP_DEVCAP2_ARI)) {\n\t\t\t/* Our parent bridge does not support ARI so issue a\n\t\t\t * warning and skip instantiating the VFs.  They\n\t\t\t * won't be reachable.\n\t\t\t */\n\t\t\tdev_warn(&pdev->dev, \"Parent bridge %02x:%02x.%x doesn't support ARI; can't instantiate Virtual Functions\\n\",\n\t\t\t\t pbridge->bus->number, PCI_SLOT(pbridge->devfn),\n\t\t\t\t PCI_FUNC(pbridge->devfn));\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tmemset(&port_cmd, 0, sizeof(port_cmd));\n\t\tport_cmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_PFVF_CMD) |\n\t\t\t\t\t\t FW_CMD_REQUEST_F |\n\t\t\t\t\t\t FW_CMD_READ_F |\n\t\t\t\t\t\t FW_PFVF_CMD_PFN_V(adap->pf) |\n\t\t\t\t\t\t FW_PFVF_CMD_VFN_V(0));\n\t\tport_cmd.retval_len16 = cpu_to_be32(FW_LEN16(port_cmd));\n\t\terr = t4_wr_mbox(adap, adap->mbox, &port_cmd, sizeof(port_cmd),\n\t\t\t\t &port_rpl);\n\t\tif (err)\n\t\t\treturn err;\n\t\tpmask = FW_PFVF_CMD_PMASK_G(be32_to_cpu(port_rpl.type_to_neq));\n\t\tport = ffs(pmask) - 1;\n\t\t/* Allocate VF Management Interface. */\n\t\tsnprintf(name, IFNAMSIZ, \"mgmtpf%d,%d\", adap->adap_idx,\n\t\t\t adap->pf);\n\t\tnetdev = alloc_netdev(sizeof(struct port_info),\n\t\t\t\t      name, NET_NAME_UNKNOWN, cxgb4_mgmt_setup);\n\t\tif (!netdev)\n\t\t\treturn -ENOMEM;\n\n\t\tpi = netdev_priv(netdev);\n\t\tpi->adapter = adap;\n\t\tpi->lport = port;\n\t\tpi->tx_chan = port;\n\t\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\t\tadap->port[0] = netdev;\n\t\tpi->port_id = 0;\n\n\t\terr = register_netdev(adap->port[0]);\n\t\tif (err) {\n\t\t\tpr_info(\"Unable to register VF mgmt netdev %s\\n\", name);\n\t\t\tfree_netdev(adap->port[0]);\n\t\t\tadap->port[0] = NULL;\n\t\t\treturn err;\n\t\t}\n\t\t/* Allocate and set up VF Information. */\n\t\tadap->vfinfo = kcalloc(pci_sriov_get_totalvfs(pdev),\n\t\t\t\t       sizeof(struct vf_info), GFP_KERNEL);\n\t\tif (!adap->vfinfo) {\n\t\t\tunregister_netdev(adap->port[0]);\n\t\t\tfree_netdev(adap->port[0]);\n\t\t\tadap->port[0] = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tcxgb4_mgmt_fill_vf_station_mac_addr(adap);\n\t}\n\t/* Instantiate the requested number of VFs. */\n\terr = pci_enable_sriov(pdev, num_vfs);\n\tif (err) {\n\t\tpr_info(\"Unable to instantiate %d VFs\\n\", num_vfs);\n\t\tif (!current_vfs) {\n\t\t\tunregister_netdev(adap->port[0]);\n\t\t\tfree_netdev(adap->port[0]);\n\t\t\tadap->port[0] = NULL;\n\t\t\tkfree(adap->vfinfo);\n\t\t\tadap->vfinfo = NULL;\n\t\t}\n\t\treturn err;\n\t}\n\n\tadap->num_vfs = num_vfs;\n\treturn num_vfs;\n}\n#endif /* CONFIG_PCI_IOV */\n\n#if IS_ENABLED(CONFIG_CHELSIO_TLS_DEVICE) || IS_ENABLED(CONFIG_CHELSIO_IPSEC_INLINE)\n\nstatic int chcr_offload_state(struct adapter *adap,\n\t\t\t      enum cxgb4_netdev_tls_ops op_val)\n{\n\tswitch (op_val) {\n#if IS_ENABLED(CONFIG_CHELSIO_TLS_DEVICE)\n\tcase CXGB4_TLSDEV_OPS:\n\t\tif (!adap->uld[CXGB4_ULD_KTLS].handle) {\n\t\t\tdev_dbg(adap->pdev_dev, \"ch_ktls driver is not loaded\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (!adap->uld[CXGB4_ULD_KTLS].tlsdev_ops) {\n\t\t\tdev_dbg(adap->pdev_dev,\n\t\t\t\t\"ch_ktls driver has no registered tlsdev_ops\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n#endif /* CONFIG_CHELSIO_TLS_DEVICE */\n#if IS_ENABLED(CONFIG_CHELSIO_IPSEC_INLINE)\n\tcase CXGB4_XFRMDEV_OPS:\n\t\tif (!adap->uld[CXGB4_ULD_IPSEC].handle) {\n\t\t\tdev_dbg(adap->pdev_dev, \"chipsec driver is not loaded\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (!adap->uld[CXGB4_ULD_IPSEC].xfrmdev_ops) {\n\t\t\tdev_dbg(adap->pdev_dev,\n\t\t\t\t\"chipsec driver has no registered xfrmdev_ops\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n#endif /* CONFIG_CHELSIO_IPSEC_INLINE */\n\tdefault:\n\t\tdev_dbg(adap->pdev_dev,\n\t\t\t\"driver has no support for offload %d\\n\", op_val);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n#endif /* CONFIG_CHELSIO_TLS_DEVICE || CONFIG_CHELSIO_IPSEC_INLINE */\n\n#if IS_ENABLED(CONFIG_CHELSIO_TLS_DEVICE)\n\nstatic int cxgb4_ktls_dev_add(struct net_device *netdev, struct sock *sk,\n\t\t\t      enum tls_offload_ctx_dir direction,\n\t\t\t      struct tls_crypto_info *crypto_info,\n\t\t\t      u32 tcp_sn)\n{\n\tstruct adapter *adap = netdev2adap(netdev);\n\tint ret;\n\n\tmutex_lock(&uld_mutex);\n\tret = chcr_offload_state(adap, CXGB4_TLSDEV_OPS);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = cxgb4_set_ktls_feature(adap, FW_PARAMS_PARAM_DEV_KTLS_HW_ENABLE);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = adap->uld[CXGB4_ULD_KTLS].tlsdev_ops->tls_dev_add(netdev, sk,\n\t\t\t\t\t\t\t\tdirection,\n\t\t\t\t\t\t\t\tcrypto_info,\n\t\t\t\t\t\t\t\ttcp_sn);\n\t/* if there is a failure, clear the refcount */\n\tif (ret)\n\t\tcxgb4_set_ktls_feature(adap,\n\t\t\t\t       FW_PARAMS_PARAM_DEV_KTLS_HW_DISABLE);\nout_unlock:\n\tmutex_unlock(&uld_mutex);\n\treturn ret;\n}\n\nstatic void cxgb4_ktls_dev_del(struct net_device *netdev,\n\t\t\t       struct tls_context *tls_ctx,\n\t\t\t       enum tls_offload_ctx_dir direction)\n{\n\tstruct adapter *adap = netdev2adap(netdev);\n\n\tmutex_lock(&uld_mutex);\n\tif (chcr_offload_state(adap, CXGB4_TLSDEV_OPS))\n\t\tgoto out_unlock;\n\n\tadap->uld[CXGB4_ULD_KTLS].tlsdev_ops->tls_dev_del(netdev, tls_ctx,\n\t\t\t\t\t\t\t  direction);\n\tcxgb4_set_ktls_feature(adap, FW_PARAMS_PARAM_DEV_KTLS_HW_DISABLE);\n\nout_unlock:\n\tmutex_unlock(&uld_mutex);\n}\n\nstatic const struct tlsdev_ops cxgb4_ktls_ops = {\n\t.tls_dev_add = cxgb4_ktls_dev_add,\n\t.tls_dev_del = cxgb4_ktls_dev_del,\n};\n#endif /* CONFIG_CHELSIO_TLS_DEVICE */\n\n#if IS_ENABLED(CONFIG_CHELSIO_IPSEC_INLINE)\n\nstatic int cxgb4_xfrm_add_state(struct xfrm_state *x)\n{\n\tstruct adapter *adap = netdev2adap(x->xso.dev);\n\tint ret;\n\n\tif (!mutex_trylock(&uld_mutex)) {\n\t\tdev_dbg(adap->pdev_dev,\n\t\t\t\"crypto uld critical resource is under use\\n\");\n\t\treturn -EBUSY;\n\t}\n\tret = chcr_offload_state(adap, CXGB4_XFRMDEV_OPS);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = adap->uld[CXGB4_ULD_IPSEC].xfrmdev_ops->xdo_dev_state_add(x);\n\nout_unlock:\n\tmutex_unlock(&uld_mutex);\n\n\treturn ret;\n}\n\nstatic void cxgb4_xfrm_del_state(struct xfrm_state *x)\n{\n\tstruct adapter *adap = netdev2adap(x->xso.dev);\n\n\tif (!mutex_trylock(&uld_mutex)) {\n\t\tdev_dbg(adap->pdev_dev,\n\t\t\t\"crypto uld critical resource is under use\\n\");\n\t\treturn;\n\t}\n\tif (chcr_offload_state(adap, CXGB4_XFRMDEV_OPS))\n\t\tgoto out_unlock;\n\n\tadap->uld[CXGB4_ULD_IPSEC].xfrmdev_ops->xdo_dev_state_delete(x);\n\nout_unlock:\n\tmutex_unlock(&uld_mutex);\n}\n\nstatic void cxgb4_xfrm_free_state(struct xfrm_state *x)\n{\n\tstruct adapter *adap = netdev2adap(x->xso.dev);\n\n\tif (!mutex_trylock(&uld_mutex)) {\n\t\tdev_dbg(adap->pdev_dev,\n\t\t\t\"crypto uld critical resource is under use\\n\");\n\t\treturn;\n\t}\n\tif (chcr_offload_state(adap, CXGB4_XFRMDEV_OPS))\n\t\tgoto out_unlock;\n\n\tadap->uld[CXGB4_ULD_IPSEC].xfrmdev_ops->xdo_dev_state_free(x);\n\nout_unlock:\n\tmutex_unlock(&uld_mutex);\n}\n\nstatic bool cxgb4_ipsec_offload_ok(struct sk_buff *skb, struct xfrm_state *x)\n{\n\tstruct adapter *adap = netdev2adap(x->xso.dev);\n\tbool ret = false;\n\n\tif (!mutex_trylock(&uld_mutex)) {\n\t\tdev_dbg(adap->pdev_dev,\n\t\t\t\"crypto uld critical resource is under use\\n\");\n\t\treturn ret;\n\t}\n\tif (chcr_offload_state(adap, CXGB4_XFRMDEV_OPS))\n\t\tgoto out_unlock;\n\n\tret = adap->uld[CXGB4_ULD_IPSEC].xfrmdev_ops->xdo_dev_offload_ok(skb, x);\n\nout_unlock:\n\tmutex_unlock(&uld_mutex);\n\treturn ret;\n}\n\nstatic void cxgb4_advance_esn_state(struct xfrm_state *x)\n{\n\tstruct adapter *adap = netdev2adap(x->xso.dev);\n\n\tif (!mutex_trylock(&uld_mutex)) {\n\t\tdev_dbg(adap->pdev_dev,\n\t\t\t\"crypto uld critical resource is under use\\n\");\n\t\treturn;\n\t}\n\tif (chcr_offload_state(adap, CXGB4_XFRMDEV_OPS))\n\t\tgoto out_unlock;\n\n\tadap->uld[CXGB4_ULD_IPSEC].xfrmdev_ops->xdo_dev_state_advance_esn(x);\n\nout_unlock:\n\tmutex_unlock(&uld_mutex);\n}\n\nstatic const struct xfrmdev_ops cxgb4_xfrmdev_ops = {\n\t.xdo_dev_state_add      = cxgb4_xfrm_add_state,\n\t.xdo_dev_state_delete   = cxgb4_xfrm_del_state,\n\t.xdo_dev_state_free     = cxgb4_xfrm_free_state,\n\t.xdo_dev_offload_ok     = cxgb4_ipsec_offload_ok,\n\t.xdo_dev_state_advance_esn = cxgb4_advance_esn_state,\n};\n\n#endif /* CONFIG_CHELSIO_IPSEC_INLINE */\n\nstatic int init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *netdev;\n\tstruct adapter *adapter;\n\tstatic int adap_idx = 1;\n\tint s_qpp, qpp, num_seg;\n\tstruct port_info *pi;\n\tbool highdma = false;\n\tenum chip_type chip;\n\tvoid __iomem *regs;\n\tint func, chip_ver;\n\tu16 device_id;\n\tint i, err;\n\tu32 whoami;\n\n\terr = pci_request_regions(pdev, KBUILD_MODNAME);\n\tif (err) {\n\t\t/* Just info, some other driver may have claimed the device. */\n\t\tdev_info(&pdev->dev, \"cannot obtain PCI resources\\n\");\n\t\treturn err;\n\t}\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"cannot enable PCI device\\n\");\n\t\tgoto out_release_regions;\n\t}\n\n\tregs = pci_ioremap_bar(pdev, 0);\n\tif (!regs) {\n\t\tdev_err(&pdev->dev, \"cannot map device registers\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out_disable_device;\n\t}\n\n\tadapter = kzalloc(sizeof(*adapter), GFP_KERNEL);\n\tif (!adapter) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unmap_bar0;\n\t}\n\n\tadapter->regs = regs;\n\terr = t4_wait_dev_ready(regs);\n\tif (err < 0)\n\t\tgoto out_free_adapter;\n\n\t/* We control everything through one PF */\n\twhoami = t4_read_reg(adapter, PL_WHOAMI_A);\n\tpci_read_config_word(pdev, PCI_DEVICE_ID, &device_id);\n\tchip = t4_get_chip_type(adapter, CHELSIO_PCI_ID_VER(device_id));\n\tif ((int)chip < 0) {\n\t\tdev_err(&pdev->dev, \"Device %d is not supported\\n\", device_id);\n\t\terr = chip;\n\t\tgoto out_free_adapter;\n\t}\n\tchip_ver = CHELSIO_CHIP_VERSION(chip);\n\tfunc = chip_ver <= CHELSIO_T5 ?\n\t       SOURCEPF_G(whoami) : T6_SOURCEPF_G(whoami);\n\n\tadapter->pdev = pdev;\n\tadapter->pdev_dev = &pdev->dev;\n\tadapter->name = pci_name(pdev);\n\tadapter->mbox = func;\n\tadapter->pf = func;\n\tadapter->params.chip = chip;\n\tadapter->adap_idx = adap_idx;\n\tadapter->msg_enable = DFLT_MSG_ENABLE;\n\tadapter->mbox_log = kzalloc(sizeof(*adapter->mbox_log) +\n\t\t\t\t    (sizeof(struct mbox_cmd) *\n\t\t\t\t     T4_OS_LOG_MBOX_CMDS),\n\t\t\t\t    GFP_KERNEL);\n\tif (!adapter->mbox_log) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_adapter;\n\t}\n\tspin_lock_init(&adapter->mbox_lock);\n\tINIT_LIST_HEAD(&adapter->mlist.list);\n\tadapter->mbox_log->size = T4_OS_LOG_MBOX_CMDS;\n\tpci_set_drvdata(pdev, adapter);\n\n\tif (func != ent->driver_data) {\n\t\tpci_disable_device(pdev);\n\t\tpci_save_state(pdev);        /* to restore SR-IOV later */\n\t\treturn 0;\n\t}\n\n\tif (!pci_set_dma_mask(pdev, DMA_BIT_MASK(64))) {\n\t\thighdma = true;\n\t\terr = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"unable to obtain 64-bit DMA for \"\n\t\t\t\t\"coherent allocations\\n\");\n\t\t\tgoto out_free_adapter;\n\t\t}\n\t} else {\n\t\terr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"no usable DMA configuration\\n\");\n\t\t\tgoto out_free_adapter;\n\t\t}\n\t}\n\n\tpci_enable_pcie_error_reporting(pdev);\n\tpci_set_master(pdev);\n\tpci_save_state(pdev);\n\tadap_idx++;\n\tadapter->workq = create_singlethread_workqueue(\"cxgb4\");\n\tif (!adapter->workq) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_adapter;\n\t}\n\n\t/* PCI device has been enabled */\n\tadapter->flags |= CXGB4_DEV_ENABLED;\n\tmemset(adapter->chan_map, 0xff, sizeof(adapter->chan_map));\n\n\t/* If possible, we use PCIe Relaxed Ordering Attribute to deliver\n\t * Ingress Packet Data to Free List Buffers in order to allow for\n\t * chipset performance optimizations between the Root Complex and\n\t * Memory Controllers.  (Messages to the associated Ingress Queue\n\t * notifying new Packet Placement in the Free Lists Buffers will be\n\t * send without the Relaxed Ordering Attribute thus guaranteeing that\n\t * all preceding PCIe Transaction Layer Packets will be processed\n\t * first.)  But some Root Complexes have various issues with Upstream\n\t * Transaction Layer Packets with the Relaxed Ordering Attribute set.\n\t * The PCIe devices which under the Root Complexes will be cleared the\n\t * Relaxed Ordering bit in the configuration space, So we check our\n\t * PCIe configuration space to see if it's flagged with advice against\n\t * using Relaxed Ordering.\n\t */\n\tif (!pcie_relaxed_ordering_enabled(pdev))\n\t\tadapter->flags |= CXGB4_ROOT_NO_RELAXED_ORDERING;\n\n\tspin_lock_init(&adapter->stats_lock);\n\tspin_lock_init(&adapter->tid_release_lock);\n\tspin_lock_init(&adapter->win0_lock);\n\n\tINIT_WORK(&adapter->tid_release_task, process_tid_release_list);\n\tINIT_WORK(&adapter->db_full_task, process_db_full);\n\tINIT_WORK(&adapter->db_drop_task, process_db_drop);\n\tINIT_WORK(&adapter->fatal_err_notify_task, notify_fatal_err);\n\n\terr = t4_prep_adapter(adapter);\n\tif (err)\n\t\tgoto out_free_adapter;\n\n\tif (is_kdump_kernel()) {\n\t\t/* Collect hardware state and append to /proc/vmcore */\n\t\terr = cxgb4_cudbg_vmcore_add_dump(adapter);\n\t\tif (err) {\n\t\t\tdev_warn(adapter->pdev_dev,\n\t\t\t\t \"Fail collecting vmcore device dump, err: %d. Continuing\\n\",\n\t\t\t\t err);\n\t\t\terr = 0;\n\t\t}\n\t}\n\n\tif (!is_t4(adapter->params.chip)) {\n\t\ts_qpp = (QUEUESPERPAGEPF0_S +\n\t\t\t(QUEUESPERPAGEPF1_S - QUEUESPERPAGEPF0_S) *\n\t\t\tadapter->pf);\n\t\tqpp = 1 << QUEUESPERPAGEPF0_G(t4_read_reg(adapter,\n\t\t      SGE_EGRESS_QUEUES_PER_PAGE_PF_A) >> s_qpp);\n\t\tnum_seg = PAGE_SIZE / SEGMENT_SIZE;\n\n\t\t/* Each segment size is 128B. Write coalescing is enabled only\n\t\t * when SGE_EGRESS_QUEUES_PER_PAGE_PF reg value for the\n\t\t * queue is less no of segments that can be accommodated in\n\t\t * a page size.\n\t\t */\n\t\tif (qpp > num_seg) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Incorrect number of egress queues per page\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_adapter;\n\t\t}\n\t\tadapter->bar2 = ioremap_wc(pci_resource_start(pdev, 2),\n\t\tpci_resource_len(pdev, 2));\n\t\tif (!adapter->bar2) {\n\t\t\tdev_err(&pdev->dev, \"cannot map device bar2 region\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_adapter;\n\t\t}\n\t}\n\n\tsetup_memwin(adapter);\n\terr = adap_init0(adapter, 0);\n#ifdef CONFIG_DEBUG_FS\n\tbitmap_zero(adapter->sge.blocked_fl, adapter->sge.egr_sz);\n#endif\n\tsetup_memwin_rdma(adapter);\n\tif (err)\n\t\tgoto out_unmap_bar;\n\n\t/* configure SGE_STAT_CFG_A to read WC stats */\n\tif (!is_t4(adapter->params.chip))\n\t\tt4_write_reg(adapter, SGE_STAT_CFG_A, STATSOURCE_T5_V(7) |\n\t\t\t     (is_t5(adapter->params.chip) ? STATMODE_V(0) :\n\t\t\t      T6_STATMODE_V(0)));\n\n\t/* Initialize hash mac addr list */\n\tINIT_LIST_HEAD(&adapter->mac_hlist);\n\n\tfor_each_port(adapter, i) {\n\t\t/* For supporting MQPRIO Offload, need some extra\n\t\t * queues for each ETHOFLD TIDs. Keep it equal to\n\t\t * MAX_ATIDs for now. Once we connect to firmware\n\t\t * later and query the EOTID params, we'll come to\n\t\t * know the actual # of EOTIDs supported.\n\t\t */\n\t\tnetdev = alloc_etherdev_mq(sizeof(struct port_info),\n\t\t\t\t\t   MAX_ETH_QSETS + MAX_ATIDS);\n\t\tif (!netdev) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_dev;\n\t\t}\n\n\t\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\t\tadapter->port[i] = netdev;\n\t\tpi = netdev_priv(netdev);\n\t\tpi->adapter = adapter;\n\t\tpi->xact_addr_filt = -1;\n\t\tpi->port_id = i;\n\t\tnetdev->irq = pdev->irq;\n\n\t\tnetdev->hw_features = NETIF_F_SG | TSO_FLAGS |\n\t\t\tNETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\n\t\t\tNETIF_F_RXCSUM | NETIF_F_RXHASH | NETIF_F_GRO |\n\t\t\tNETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\tNETIF_F_HW_TC | NETIF_F_NTUPLE;\n\n\t\tif (chip_ver > CHELSIO_T5) {\n\t\t\tnetdev->hw_enc_features |= NETIF_F_IP_CSUM |\n\t\t\t\t\t\t   NETIF_F_IPV6_CSUM |\n\t\t\t\t\t\t   NETIF_F_RXCSUM |\n\t\t\t\t\t\t   NETIF_F_GSO_UDP_TUNNEL |\n\t\t\t\t\t\t   NETIF_F_GSO_UDP_TUNNEL_CSUM |\n\t\t\t\t\t\t   NETIF_F_TSO | NETIF_F_TSO6;\n\n\t\t\tnetdev->hw_features |= NETIF_F_GSO_UDP_TUNNEL |\n\t\t\t\t\t       NETIF_F_GSO_UDP_TUNNEL_CSUM |\n\t\t\t\t\t       NETIF_F_HW_TLS_RECORD;\n\n\t\t\tif (adapter->rawf_cnt)\n\t\t\t\tnetdev->udp_tunnel_nic_info = &cxgb_udp_tunnels;\n\t\t}\n\n\t\tif (highdma)\n\t\t\tnetdev->hw_features |= NETIF_F_HIGHDMA;\n\t\tnetdev->features |= netdev->hw_features;\n\t\tnetdev->vlan_features = netdev->features & VLAN_FEAT;\n#if IS_ENABLED(CONFIG_CHELSIO_TLS_DEVICE)\n\t\tif (pi->adapter->params.crypto & FW_CAPS_CONFIG_TLS_HW) {\n\t\t\tnetdev->hw_features |= NETIF_F_HW_TLS_TX;\n\t\t\tnetdev->tlsdev_ops = &cxgb4_ktls_ops;\n\t\t\t/* initialize the refcount */\n\t\t\trefcount_set(&pi->adapter->chcr_ktls.ktls_refcount, 0);\n\t\t}\n#endif /* CONFIG_CHELSIO_TLS_DEVICE */\n#if IS_ENABLED(CONFIG_CHELSIO_IPSEC_INLINE)\n\t\tif (pi->adapter->params.crypto & FW_CAPS_CONFIG_IPSEC_INLINE) {\n\t\t\tnetdev->hw_enc_features |= NETIF_F_HW_ESP;\n\t\t\tnetdev->features |= NETIF_F_HW_ESP;\n\t\t\tnetdev->xfrmdev_ops = &cxgb4_xfrmdev_ops;\n\t\t}\n#endif /* CONFIG_CHELSIO_IPSEC_INLINE */\n\n\t\tnetdev->priv_flags |= IFF_UNICAST_FLT;\n\n\t\t/* MTU range: 81 - 9600 */\n\t\tnetdev->min_mtu = 81;              /* accommodate SACK */\n\t\tnetdev->max_mtu = MAX_MTU;\n\n\t\tnetdev->netdev_ops = &cxgb4_netdev_ops;\n#ifdef CONFIG_CHELSIO_T4_DCB\n\t\tnetdev->dcbnl_ops = &cxgb4_dcb_ops;\n\t\tcxgb4_dcb_state_init(netdev);\n\t\tcxgb4_dcb_version_init(netdev);\n#endif\n\t\tcxgb4_set_ethtool_ops(netdev);\n\t}\n\n\tcxgb4_init_ethtool_dump(adapter);\n\n\tpci_set_drvdata(pdev, adapter);\n\n\tif (adapter->flags & CXGB4_FW_OK) {\n\t\terr = t4_port_init(adapter, func, func, 0);\n\t\tif (err)\n\t\t\tgoto out_free_dev;\n\t} else if (adapter->params.nports == 1) {\n\t\t/* If we don't have a connection to the firmware -- possibly\n\t\t * because of an error -- grab the raw VPD parameters so we\n\t\t * can set the proper MAC Address on the debug network\n\t\t * interface that we've created.\n\t\t */\n\t\tu8 hw_addr[ETH_ALEN];\n\t\tu8 *na = adapter->params.vpd.na;\n\n\t\terr = t4_get_raw_vpd_params(adapter, &adapter->params.vpd);\n\t\tif (!err) {\n\t\t\tfor (i = 0; i < ETH_ALEN; i++)\n\t\t\t\thw_addr[i] = (hex2val(na[2 * i + 0]) * 16 +\n\t\t\t\t\t      hex2val(na[2 * i + 1]));\n\t\t\tt4_set_hw_addr(adapter, 0, hw_addr);\n\t\t}\n\t}\n\n\tif (!(adapter->flags & CXGB4_FW_OK))\n\t\tgoto fw_attach_fail;\n\n\t/* Configure queues and allocate tables now, they can be needed as\n\t * soon as the first register_netdev completes.\n\t */\n\terr = cfg_queues(adapter);\n\tif (err)\n\t\tgoto out_free_dev;\n\n\tadapter->smt = t4_init_smt();\n\tif (!adapter->smt) {\n\t\t/* We tolerate a lack of SMT, giving up some functionality */\n\t\tdev_warn(&pdev->dev, \"could not allocate SMT, continuing\\n\");\n\t}\n\n\tadapter->l2t = t4_init_l2t(adapter->l2t_start, adapter->l2t_end);\n\tif (!adapter->l2t) {\n\t\t/* We tolerate a lack of L2T, giving up some functionality */\n\t\tdev_warn(&pdev->dev, \"could not allocate L2T, continuing\\n\");\n\t\tadapter->params.offload = 0;\n\t}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (chip_ver <= CHELSIO_T5 &&\n\t    (!(t4_read_reg(adapter, LE_DB_CONFIG_A) & ASLIPCOMPEN_F))) {\n\t\t/* CLIP functionality is not present in hardware,\n\t\t * hence disable all offload features\n\t\t */\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"CLIP not enabled in hardware, continuing\\n\");\n\t\tadapter->params.offload = 0;\n\t} else {\n\t\tadapter->clipt = t4_init_clip_tbl(adapter->clipt_start,\n\t\t\t\t\t\t  adapter->clipt_end);\n\t\tif (!adapter->clipt) {\n\t\t\t/* We tolerate a lack of clip_table, giving up\n\t\t\t * some functionality\n\t\t\t */\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"could not allocate Clip table, continuing\\n\");\n\t\t\tadapter->params.offload = 0;\n\t\t}\n\t}\n#endif\n\n\tfor_each_port(adapter, i) {\n\t\tpi = adap2pinfo(adapter, i);\n\t\tpi->sched_tbl = t4_init_sched(adapter->params.nsched_cls);\n\t\tif (!pi->sched_tbl)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"could not activate scheduling on port %d\\n\",\n\t\t\t\t i);\n\t}\n\n\tif (is_offload(adapter) || is_hashfilter(adapter)) {\n\t\tif (t4_read_reg(adapter, LE_DB_CONFIG_A) & HASHEN_F) {\n\t\t\tu32 v;\n\n\t\t\tv = t4_read_reg(adapter, LE_DB_HASH_CONFIG_A);\n\t\t\tif (chip_ver <= CHELSIO_T5) {\n\t\t\t\tadapter->tids.nhash = 1 << HASHTIDSIZE_G(v);\n\t\t\t\tv = t4_read_reg(adapter, LE_DB_TID_HASHBASE_A);\n\t\t\t\tadapter->tids.hash_base = v / 4;\n\t\t\t} else {\n\t\t\t\tadapter->tids.nhash = HASHTBLSIZE_G(v) << 3;\n\t\t\t\tv = t4_read_reg(adapter,\n\t\t\t\t\t\tT6_LE_DB_HASH_TID_BASE_A);\n\t\t\t\tadapter->tids.hash_base = v;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tid_init(&adapter->tids) < 0) {\n\t\tdev_warn(&pdev->dev, \"could not allocate TID table, \"\n\t\t\t \"continuing\\n\");\n\t\tadapter->params.offload = 0;\n\t} else {\n\t\tadapter->tc_u32 = cxgb4_init_tc_u32(adapter);\n\t\tif (!adapter->tc_u32)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"could not offload tc u32, continuing\\n\");\n\n\t\tif (cxgb4_init_tc_flower(adapter))\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"could not offload tc flower, continuing\\n\");\n\n\t\tif (cxgb4_init_tc_mqprio(adapter))\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"could not offload tc mqprio, continuing\\n\");\n\n\t\tif (cxgb4_init_tc_matchall(adapter))\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"could not offload tc matchall, continuing\\n\");\n\t\tif (cxgb4_init_ethtool_filters(adapter))\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"could not initialize ethtool filters, continuing\\n\");\n\t}\n\n\t/* See what interrupts we'll be using */\n\tif (msi > 1 && enable_msix(adapter) == 0)\n\t\tadapter->flags |= CXGB4_USING_MSIX;\n\telse if (msi > 0 && pci_enable_msi(pdev) == 0) {\n\t\tadapter->flags |= CXGB4_USING_MSI;\n\t\tif (msi > 1)\n\t\t\tfree_msix_info(adapter);\n\t}\n\n\t/* check for PCI Express bandwidth capabiltites */\n\tpcie_print_link_status(pdev);\n\n\tcxgb4_init_mps_ref_entries(adapter);\n\n\terr = init_rss(adapter);\n\tif (err)\n\t\tgoto out_free_dev;\n\n\terr = setup_non_data_intr(adapter);\n\tif (err) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"Non Data interrupt allocation failed, err: %d\\n\", err);\n\t\tgoto out_free_dev;\n\t}\n\n\terr = setup_fw_sge_queues(adapter);\n\tif (err) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"FW sge queue allocation failed, err %d\", err);\n\t\tgoto out_free_dev;\n\t}\n\nfw_attach_fail:\n\t/*\n\t * The card is now ready to go.  If any errors occur during device\n\t * registration we do not fail the whole card but rather proceed only\n\t * with the ports we manage to register successfully.  However we must\n\t * register at least one net device.\n\t */\n\tfor_each_port(adapter, i) {\n\t\tpi = adap2pinfo(adapter, i);\n\t\tadapter->port[i]->dev_port = pi->lport;\n\t\tnetif_set_real_num_tx_queues(adapter->port[i], pi->nqsets);\n\t\tnetif_set_real_num_rx_queues(adapter->port[i], pi->nqsets);\n\n\t\tnetif_carrier_off(adapter->port[i]);\n\n\t\terr = register_netdev(adapter->port[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t\tadapter->chan_map[pi->tx_chan] = i;\n\t\tprint_port_info(adapter->port[i]);\n\t}\n\tif (i == 0) {\n\t\tdev_err(&pdev->dev, \"could not register any net devices\\n\");\n\t\tgoto out_free_dev;\n\t}\n\tif (err) {\n\t\tdev_warn(&pdev->dev, \"only %d net devices registered\\n\", i);\n\t\terr = 0;\n\t}\n\n\tif (cxgb4_debugfs_root) {\n\t\tadapter->debugfs_root = debugfs_create_dir(pci_name(pdev),\n\t\t\t\t\t\t\t   cxgb4_debugfs_root);\n\t\tsetup_debugfs(adapter);\n\t}\n\n\t/* PCIe EEH recovery on powerpc platforms needs fundamental reset */\n\tpdev->needs_freset = 1;\n\n\tif (is_uld(adapter))\n\t\tcxgb4_uld_enable(adapter);\n\n\tif (!is_t4(adapter->params.chip))\n\t\tcxgb4_ptp_init(adapter);\n\n\tif (IS_REACHABLE(CONFIG_THERMAL) &&\n\t    !is_t4(adapter->params.chip) && (adapter->flags & CXGB4_FW_OK))\n\t\tcxgb4_thermal_init(adapter);\n\n\tprint_adapter_info(adapter);\n\treturn 0;\n\n out_free_dev:\n\tt4_free_sge_resources(adapter);\n\tfree_some_resources(adapter);\n\tif (adapter->flags & CXGB4_USING_MSIX)\n\t\tfree_msix_info(adapter);\n\tif (adapter->num_uld || adapter->num_ofld_uld)\n\t\tt4_uld_mem_free(adapter);\n out_unmap_bar:\n\tif (!is_t4(adapter->params.chip))\n\t\tiounmap(adapter->bar2);\n out_free_adapter:\n\tif (adapter->workq)\n\t\tdestroy_workqueue(adapter->workq);\n\n\tkfree(adapter->mbox_log);\n\tkfree(adapter);\n out_unmap_bar0:\n\tiounmap(regs);\n out_disable_device:\n\tpci_disable_pcie_error_reporting(pdev);\n\tpci_disable_device(pdev);\n out_release_regions:\n\tpci_release_regions(pdev);\n\treturn err;\n}\n\nstatic void remove_one(struct pci_dev *pdev)\n{\n\tstruct adapter *adapter = pci_get_drvdata(pdev);\n\tstruct hash_mac_addr *entry, *tmp;\n\n\tif (!adapter) {\n\t\tpci_release_regions(pdev);\n\t\treturn;\n\t}\n\n\t/* If we allocated filters, free up state associated with any\n\t * valid filters ...\n\t */\n\tclear_all_filters(adapter);\n\n\tadapter->flags |= CXGB4_SHUTTING_DOWN;\n\n\tif (adapter->pf == 4) {\n\t\tint i;\n\n\t\t/* Tear down per-adapter Work Queue first since it can contain\n\t\t * references to our adapter data structure.\n\t\t */\n\t\tdestroy_workqueue(adapter->workq);\n\n\t\tif (is_uld(adapter)) {\n\t\t\tdetach_ulds(adapter);\n\t\t\tt4_uld_clean_up(adapter);\n\t\t}\n\n\t\tadap_free_hma_mem(adapter);\n\n\t\tdisable_interrupts(adapter);\n\n\t\tcxgb4_free_mps_ref_entries(adapter);\n\n\t\tfor_each_port(adapter, i)\n\t\t\tif (adapter->port[i]->reg_state == NETREG_REGISTERED)\n\t\t\t\tunregister_netdev(adapter->port[i]);\n\n\t\tdebugfs_remove_recursive(adapter->debugfs_root);\n\n\t\tif (!is_t4(adapter->params.chip))\n\t\t\tcxgb4_ptp_stop(adapter);\n\t\tif (IS_REACHABLE(CONFIG_THERMAL))\n\t\t\tcxgb4_thermal_remove(adapter);\n\n\t\tif (adapter->flags & CXGB4_FULL_INIT_DONE)\n\t\t\tcxgb_down(adapter);\n\n\t\tif (adapter->flags & CXGB4_USING_MSIX)\n\t\t\tfree_msix_info(adapter);\n\t\tif (adapter->num_uld || adapter->num_ofld_uld)\n\t\t\tt4_uld_mem_free(adapter);\n\t\tfree_some_resources(adapter);\n\t\tlist_for_each_entry_safe(entry, tmp, &adapter->mac_hlist,\n\t\t\t\t\t list) {\n\t\t\tlist_del(&entry->list);\n\t\t\tkfree(entry);\n\t\t}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tt4_cleanup_clip_tbl(adapter);\n#endif\n\t\tif (!is_t4(adapter->params.chip))\n\t\t\tiounmap(adapter->bar2);\n\t}\n#ifdef CONFIG_PCI_IOV\n\telse {\n\t\tcxgb4_iov_configure(adapter->pdev, 0);\n\t}\n#endif\n\tiounmap(adapter->regs);\n\tpci_disable_pcie_error_reporting(pdev);\n\tif ((adapter->flags & CXGB4_DEV_ENABLED)) {\n\t\tpci_disable_device(pdev);\n\t\tadapter->flags &= ~CXGB4_DEV_ENABLED;\n\t}\n\tpci_release_regions(pdev);\n\tkfree(adapter->mbox_log);\n\tsynchronize_rcu();\n\tkfree(adapter);\n}\n\n/* \"Shutdown\" quiesces the device, stopping Ingress Packet and Interrupt\n * delivery.  This is essentially a stripped down version of the PCI remove()\n * function where we do the minimal amount of work necessary to shutdown any\n * further activity.\n */\nstatic void shutdown_one(struct pci_dev *pdev)\n{\n\tstruct adapter *adapter = pci_get_drvdata(pdev);\n\n\t/* As with remove_one() above (see extended comment), we only want do\n\t * do cleanup on PCI Devices which went all the way through init_one()\n\t * ...\n\t */\n\tif (!adapter) {\n\t\tpci_release_regions(pdev);\n\t\treturn;\n\t}\n\n\tadapter->flags |= CXGB4_SHUTTING_DOWN;\n\n\tif (adapter->pf == 4) {\n\t\tint i;\n\n\t\tfor_each_port(adapter, i)\n\t\t\tif (adapter->port[i]->reg_state == NETREG_REGISTERED)\n\t\t\t\tcxgb_close(adapter->port[i]);\n\n\t\trtnl_lock();\n\t\tcxgb4_mqprio_stop_offload(adapter);\n\t\trtnl_unlock();\n\n\t\tif (is_uld(adapter)) {\n\t\t\tdetach_ulds(adapter);\n\t\t\tt4_uld_clean_up(adapter);\n\t\t}\n\n\t\tdisable_interrupts(adapter);\n\t\tdisable_msi(adapter);\n\n\t\tt4_sge_stop(adapter);\n\t\tif (adapter->flags & CXGB4_FW_OK)\n\t\t\tt4_fw_bye(adapter, adapter->mbox);\n\t}\n}\n\nstatic struct pci_driver cxgb4_driver = {\n\t.name     = KBUILD_MODNAME,\n\t.id_table = cxgb4_pci_tbl,\n\t.probe    = init_one,\n\t.remove   = remove_one,\n\t.shutdown = shutdown_one,\n#ifdef CONFIG_PCI_IOV\n\t.sriov_configure = cxgb4_iov_configure,\n#endif\n\t.err_handler = &cxgb4_eeh,\n};\n\nstatic int __init cxgb4_init_module(void)\n{\n\tint ret;\n\n\tcxgb4_debugfs_root = debugfs_create_dir(KBUILD_MODNAME, NULL);\n\n\tret = pci_register_driver(&cxgb4_driver);\n\tif (ret < 0)\n\t\tgoto err_pci;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (!inet6addr_registered) {\n\t\tret = register_inet6addr_notifier(&cxgb4_inet6addr_notifier);\n\t\tif (ret)\n\t\t\tpci_unregister_driver(&cxgb4_driver);\n\t\telse\n\t\t\tinet6addr_registered = true;\n\t}\n#endif\n\n\tif (ret == 0)\n\t\treturn ret;\n\nerr_pci:\n\tdebugfs_remove(cxgb4_debugfs_root);\n\n\treturn ret;\n}\n\nstatic void __exit cxgb4_cleanup_module(void)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (inet6addr_registered) {\n\t\tunregister_inet6addr_notifier(&cxgb4_inet6addr_notifier);\n\t\tinet6addr_registered = false;\n\t}\n#endif\n\tpci_unregister_driver(&cxgb4_driver);\n\tdebugfs_remove(cxgb4_debugfs_root);  /* NULL ok */\n}\n\nmodule_init(cxgb4_init_module);\nmodule_exit(cxgb4_cleanup_module);\n"}}, "reports": [{"events": [{"location": {"col": 2, "file": 0, "line": 5141}, "message": "WARNING: Assignment of 0/1 to bool variable"}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c", "reportHash": "d970b8c66fdc6a3a5966ef75ab878013", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
