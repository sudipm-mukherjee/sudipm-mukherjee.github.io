<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/net/wireless/intel/ipw2x00/ipw2100.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/******************************************************************************\n\n  Copyright(c) 2003 - 2006 Intel Corporation. All rights reserved.\n\n\n  Contact Information:\n  Intel Linux Wireless <ilw@linux.intel.com>\n  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497\n\n  Portions of this file are based on the sample_* files provided by Wireless\n  Extensions 0.26 package and copyright (c) 1997-2003 Jean Tourrilhes\n  <jt@hpl.hp.com>\n\n  Portions of this file are based on the Host AP project,\n  Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen\n    <j@w1.fi>\n  Copyright (c) 2002-2003, Jouni Malinen <j@w1.fi>\n\n  Portions of ipw2100_mod_firmware_load, ipw2100_do_mod_firmware_load, and\n  ipw2100_fw_load are loosely based on drivers/sound/sound_firmware.c\n  available in the 2.4.25 kernel sources, and are copyright (c) Alan Cox\n\n******************************************************************************/\n/*\n\n Initial driver on which this is based was developed by Janusz Gorycki,\n Maciej Urbaniak, and Maciej Sosnowski.\n\n Promiscuous mode support added by Jacek Wysoczynski and Maciej Urbaniak.\n\nTheory of Operation\n\nTx - Commands and Data\n\nFirmware and host share a circular queue of Transmit Buffer Descriptors (TBDs)\nEach TBD contains a pointer to the physical (dma_addr_t) address of data being\nsent to the firmware as well as the length of the data.\n\nThe host writes to the TBD queue at the WRITE index.  The WRITE index points\nto the _next_ packet to be written and is advanced when after the TBD has been\nfilled.\n\nThe firmware pulls from the TBD queue at the READ index.  The READ index points\nto the currently being read entry, and is advanced once the firmware is\ndone with a packet.\n\nWhen data is sent to the firmware, the first TBD is used to indicate to the\nfirmware if a Command or Data is being sent.  If it is Command, all of the\ncommand information is contained within the physical address referred to by the\nTBD.  If it is Data, the first TBD indicates the type of data packet, number\nof fragments, etc.  The next TBD then refers to the actual packet location.\n\nThe Tx flow cycle is as follows:\n\n1) ipw2100_tx() is called by kernel with SKB to transmit\n2) Packet is move from the tx_free_list and appended to the transmit pending\n   list (tx_pend_list)\n3) work is scheduled to move pending packets into the shared circular queue.\n4) when placing packet in the circular queue, the incoming SKB is DMA mapped\n   to a physical address.  That address is entered into a TBD.  Two TBDs are\n   filled out.  The first indicating a data packet, the second referring to the\n   actual payload data.\n5) the packet is removed from tx_pend_list and placed on the end of the\n   firmware pending list (fw_pend_list)\n6) firmware is notified that the WRITE index has\n7) Once the firmware has processed the TBD, INTA is triggered.\n8) For each Tx interrupt received from the firmware, the READ index is checked\n   to see which TBDs are done being processed.\n9) For each TBD that has been processed, the ISR pulls the oldest packet\n   from the fw_pend_list.\n10)The packet structure contained in the fw_pend_list is then used\n   to unmap the DMA address and to free the SKB originally passed to the driver\n   from the kernel.\n11)The packet structure is placed onto the tx_free_list\n\nThe above steps are the same for commands, only the msg_free_list/msg_pend_list\nare used instead of tx_free_list/tx_pend_list\n\n...\n\nCritical Sections / Locking :\n\nThere are two locks utilized.  The first is the low level lock (priv->low_lock)\nthat protects the following:\n\n- Access to the Tx/Rx queue lists via priv->low_lock. The lists are as follows:\n\n  tx_free_list : Holds pre-allocated Tx buffers.\n    TAIL modified in __ipw2100_tx_process()\n    HEAD modified in ipw2100_tx()\n\n  tx_pend_list : Holds used Tx buffers waiting to go into the TBD ring\n    TAIL modified ipw2100_tx()\n    HEAD modified by ipw2100_tx_send_data()\n\n  msg_free_list : Holds pre-allocated Msg (Command) buffers\n    TAIL modified in __ipw2100_tx_process()\n    HEAD modified in ipw2100_hw_send_command()\n\n  msg_pend_list : Holds used Msg buffers waiting to go into the TBD ring\n    TAIL modified in ipw2100_hw_send_command()\n    HEAD modified in ipw2100_tx_send_commands()\n\n  The flow of data on the TX side is as follows:\n\n  MSG_FREE_LIST + COMMAND => MSG_PEND_LIST => TBD => MSG_FREE_LIST\n  TX_FREE_LIST + DATA => TX_PEND_LIST => TBD => TX_FREE_LIST\n\n  The methods that work on the TBD ring are protected via priv->low_lock.\n\n- The internal data state of the device itself\n- Access to the firmware read/write indexes for the BD queues\n  and associated logic\n\nAll external entry functions are locked with the priv->action_lock to ensure\nthat only one external action is invoked at a time.\n\n\n*/\n\n#include <linux/compiler.h>\n#include <linux/errno.h>\n#include <linux/if_arp.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/kmod.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/uaccess.h>\n#include <asm/io.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stringify.h>\n#include <linux/tcp.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/firmware.h>\n#include <linux/acpi.h>\n#include <linux/ctype.h>\n#include <linux/pm_qos.h>\n\n#include <net/lib80211.h>\n\n#include \"ipw2100.h\"\n#include \"ipw.h\"\n\n#define IPW2100_VERSION \"git-1.2.2\"\n\n#define DRV_NAME\t\"ipw2100\"\n#define DRV_VERSION\tIPW2100_VERSION\n#define DRV_DESCRIPTION\t\"Intel(R) PRO/Wireless 2100 Network Driver\"\n#define DRV_COPYRIGHT\t\"Copyright(c) 2003-2006 Intel Corporation\"\n\nstatic struct pm_qos_request ipw2100_pm_qos_req;\n\n/* Debugging stuff */\n#ifdef CONFIG_IPW2100_DEBUG\n#define IPW2100_RX_DEBUG\t/* Reception debugging */\n#endif\n\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_VERSION(DRV_VERSION);\nMODULE_AUTHOR(DRV_COPYRIGHT);\nMODULE_LICENSE(\"GPL\");\n\nstatic int debug = 0;\nstatic int network_mode = 0;\nstatic int channel = 0;\nstatic int associate = 0;\nstatic int disable = 0;\n#ifdef CONFIG_PM\nstatic struct ipw2100_fw ipw2100_firmware;\n#endif\n\n#include <linux/moduleparam.h>\nmodule_param(debug, int, 0444);\nmodule_param_named(mode, network_mode, int, 0444);\nmodule_param(channel, int, 0444);\nmodule_param(associate, int, 0444);\nmodule_param(disable, int, 0444);\n\nMODULE_PARM_DESC(debug, \"debug level\");\nMODULE_PARM_DESC(mode, \"network mode (0=BSS,1=IBSS,2=Monitor)\");\nMODULE_PARM_DESC(channel, \"channel\");\nMODULE_PARM_DESC(associate, \"auto associate when scanning (default off)\");\nMODULE_PARM_DESC(disable, \"manually disable the radio (default 0 [radio on])\");\n\nstatic u32 ipw2100_debug_level = IPW_DL_NONE;\n\n#ifdef CONFIG_IPW2100_DEBUG\n#define IPW_DEBUG(level, message...) \\\ndo { \\\n\tif (ipw2100_debug_level & (level)) { \\\n\t\tprintk(KERN_DEBUG \"ipw2100: %s \", __func__); \\\n\t\tprintk(message); \\\n\t} \\\n} while (0)\n#else\n#define IPW_DEBUG(level, message...) do {} while (0)\n#endif\t\t\t\t/* CONFIG_IPW2100_DEBUG */\n\n#ifdef CONFIG_IPW2100_DEBUG\nstatic const char *command_types[] = {\n\t\"undefined\",\n\t\"unused\",\t\t/* HOST_ATTENTION */\n\t\"HOST_COMPLETE\",\n\t\"unused\",\t\t/* SLEEP */\n\t\"unused\",\t\t/* HOST_POWER_DOWN */\n\t\"unused\",\n\t\"SYSTEM_CONFIG\",\n\t\"unused\",\t\t/* SET_IMR */\n\t\"SSID\",\n\t\"MANDATORY_BSSID\",\n\t\"AUTHENTICATION_TYPE\",\n\t\"ADAPTER_ADDRESS\",\n\t\"PORT_TYPE\",\n\t\"INTERNATIONAL_MODE\",\n\t\"CHANNEL\",\n\t\"RTS_THRESHOLD\",\n\t\"FRAG_THRESHOLD\",\n\t\"POWER_MODE\",\n\t\"TX_RATES\",\n\t\"BASIC_TX_RATES\",\n\t\"WEP_KEY_INFO\",\n\t\"unused\",\n\t\"unused\",\n\t\"unused\",\n\t\"unused\",\n\t\"WEP_KEY_INDEX\",\n\t\"WEP_FLAGS\",\n\t\"ADD_MULTICAST\",\n\t\"CLEAR_ALL_MULTICAST\",\n\t\"BEACON_INTERVAL\",\n\t\"ATIM_WINDOW\",\n\t\"CLEAR_STATISTICS\",\n\t\"undefined\",\n\t\"undefined\",\n\t\"undefined\",\n\t\"undefined\",\n\t\"TX_POWER_INDEX\",\n\t\"undefined\",\n\t\"undefined\",\n\t\"undefined\",\n\t\"undefined\",\n\t\"undefined\",\n\t\"undefined\",\n\t\"BROADCAST_SCAN\",\n\t\"CARD_DISABLE\",\n\t\"PREFERRED_BSSID\",\n\t\"SET_SCAN_OPTIONS\",\n\t\"SCAN_DWELL_TIME\",\n\t\"SWEEP_TABLE\",\n\t\"AP_OR_STATION_TABLE\",\n\t\"GROUP_ORDINALS\",\n\t\"SHORT_RETRY_LIMIT\",\n\t\"LONG_RETRY_LIMIT\",\n\t\"unused\",\t\t/* SAVE_CALIBRATION */\n\t\"unused\",\t\t/* RESTORE_CALIBRATION */\n\t\"undefined\",\n\t\"undefined\",\n\t\"undefined\",\n\t\"HOST_PRE_POWER_DOWN\",\n\t\"unused\",\t\t/* HOST_INTERRUPT_COALESCING */\n\t\"undefined\",\n\t\"CARD_DISABLE_PHY_OFF\",\n\t\"MSDU_TX_RATES\",\n\t\"undefined\",\n\t\"SET_STATION_STAT_BITS\",\n\t\"CLEAR_STATIONS_STAT_BITS\",\n\t\"LEAP_ROGUE_MODE\",\n\t\"SET_SECURITY_INFORMATION\",\n\t\"DISASSOCIATION_BSSID\",\n\t\"SET_WPA_ASS_IE\"\n};\n#endif\n\nstatic const long ipw2100_frequencies[] = {\n\t2412, 2417, 2422, 2427,\n\t2432, 2437, 2442, 2447,\n\t2452, 2457, 2462, 2467,\n\t2472, 2484\n};\n\n#define FREQ_COUNT\tARRAY_SIZE(ipw2100_frequencies)\n\nstatic struct ieee80211_rate ipw2100_bg_rates[] = {\n\t{ .bitrate = 10 },\n\t{ .bitrate = 20, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n};\n\n#define RATE_COUNT ARRAY_SIZE(ipw2100_bg_rates)\n\n/* Pre-decl until we get the code solid and then we can clean it up */\nstatic void ipw2100_tx_send_commands(struct ipw2100_priv *priv);\nstatic void ipw2100_tx_send_data(struct ipw2100_priv *priv);\nstatic int ipw2100_adapter_setup(struct ipw2100_priv *priv);\n\nstatic void ipw2100_queues_initialize(struct ipw2100_priv *priv);\nstatic void ipw2100_queues_free(struct ipw2100_priv *priv);\nstatic int ipw2100_queues_allocate(struct ipw2100_priv *priv);\n\nstatic int ipw2100_fw_download(struct ipw2100_priv *priv,\n\t\t\t       struct ipw2100_fw *fw);\nstatic int ipw2100_get_firmware(struct ipw2100_priv *priv,\n\t\t\t\tstruct ipw2100_fw *fw);\nstatic int ipw2100_get_fwversion(struct ipw2100_priv *priv, char *buf,\n\t\t\t\t size_t max);\nstatic int ipw2100_get_ucodeversion(struct ipw2100_priv *priv, char *buf,\n\t\t\t\t    size_t max);\nstatic void ipw2100_release_firmware(struct ipw2100_priv *priv,\n\t\t\t\t     struct ipw2100_fw *fw);\nstatic int ipw2100_ucode_download(struct ipw2100_priv *priv,\n\t\t\t\t  struct ipw2100_fw *fw);\nstatic void ipw2100_wx_event_work(struct work_struct *work);\nstatic struct iw_statistics *ipw2100_wx_wireless_stats(struct net_device *dev);\nstatic const struct iw_handler_def ipw2100_wx_handler_def;\n\nstatic inline void read_register(struct net_device *dev, u32 reg, u32 * val)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\t*val = ioread32(priv->ioaddr + reg);\n\tIPW_DEBUG_IO(\"r: 0x%08X => 0x%08X\\n\", reg, *val);\n}\n\nstatic inline void write_register(struct net_device *dev, u32 reg, u32 val)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\tiowrite32(val, priv->ioaddr + reg);\n\tIPW_DEBUG_IO(\"w: 0x%08X <= 0x%08X\\n\", reg, val);\n}\n\nstatic inline void read_register_word(struct net_device *dev, u32 reg,\n\t\t\t\t      u16 * val)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\t*val = ioread16(priv->ioaddr + reg);\n\tIPW_DEBUG_IO(\"r: 0x%08X => %04X\\n\", reg, *val);\n}\n\nstatic inline void read_register_byte(struct net_device *dev, u32 reg, u8 * val)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\t*val = ioread8(priv->ioaddr + reg);\n\tIPW_DEBUG_IO(\"r: 0x%08X => %02X\\n\", reg, *val);\n}\n\nstatic inline void write_register_word(struct net_device *dev, u32 reg, u16 val)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\tiowrite16(val, priv->ioaddr + reg);\n\tIPW_DEBUG_IO(\"w: 0x%08X <= %04X\\n\", reg, val);\n}\n\nstatic inline void write_register_byte(struct net_device *dev, u32 reg, u8 val)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\tiowrite8(val, priv->ioaddr + reg);\n\tIPW_DEBUG_IO(\"w: 0x%08X =< %02X\\n\", reg, val);\n}\n\nstatic inline void read_nic_dword(struct net_device *dev, u32 addr, u32 * val)\n{\n\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\n\t\t       addr & IPW_REG_INDIRECT_ADDR_MASK);\n\tread_register(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);\n}\n\nstatic inline void write_nic_dword(struct net_device *dev, u32 addr, u32 val)\n{\n\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\n\t\t       addr & IPW_REG_INDIRECT_ADDR_MASK);\n\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);\n}\n\nstatic inline void read_nic_word(struct net_device *dev, u32 addr, u16 * val)\n{\n\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\n\t\t       addr & IPW_REG_INDIRECT_ADDR_MASK);\n\tread_register_word(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);\n}\n\nstatic inline void write_nic_word(struct net_device *dev, u32 addr, u16 val)\n{\n\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\n\t\t       addr & IPW_REG_INDIRECT_ADDR_MASK);\n\twrite_register_word(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);\n}\n\nstatic inline void read_nic_byte(struct net_device *dev, u32 addr, u8 * val)\n{\n\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\n\t\t       addr & IPW_REG_INDIRECT_ADDR_MASK);\n\tread_register_byte(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);\n}\n\nstatic inline void write_nic_byte(struct net_device *dev, u32 addr, u8 val)\n{\n\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\n\t\t       addr & IPW_REG_INDIRECT_ADDR_MASK);\n\twrite_register_byte(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);\n}\n\nstatic inline void write_nic_auto_inc_address(struct net_device *dev, u32 addr)\n{\n\twrite_register(dev, IPW_REG_AUTOINCREMENT_ADDRESS,\n\t\t       addr & IPW_REG_INDIRECT_ADDR_MASK);\n}\n\nstatic inline void write_nic_dword_auto_inc(struct net_device *dev, u32 val)\n{\n\twrite_register(dev, IPW_REG_AUTOINCREMENT_DATA, val);\n}\n\nstatic void write_nic_memory(struct net_device *dev, u32 addr, u32 len,\n\t\t\t\t    const u8 * buf)\n{\n\tu32 aligned_addr;\n\tu32 aligned_len;\n\tu32 dif_len;\n\tu32 i;\n\n\t/* read first nibble byte by byte */\n\taligned_addr = addr & (~0x3);\n\tdif_len = addr - aligned_addr;\n\tif (dif_len) {\n\t\t/* Start reading at aligned_addr + dif_len */\n\t\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\n\t\t\t       aligned_addr);\n\t\tfor (i = dif_len; i < 4; i++, buf++)\n\t\t\twrite_register_byte(dev,\n\t\t\t\t\t    IPW_REG_INDIRECT_ACCESS_DATA + i,\n\t\t\t\t\t    *buf);\n\n\t\tlen -= dif_len;\n\t\taligned_addr += 4;\n\t}\n\n\t/* read DWs through autoincrement registers */\n\twrite_register(dev, IPW_REG_AUTOINCREMENT_ADDRESS, aligned_addr);\n\taligned_len = len & (~0x3);\n\tfor (i = 0; i < aligned_len; i += 4, buf += 4, aligned_addr += 4)\n\t\twrite_register(dev, IPW_REG_AUTOINCREMENT_DATA, *(u32 *) buf);\n\n\t/* copy the last nibble */\n\tdif_len = len - aligned_len;\n\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS, aligned_addr);\n\tfor (i = 0; i < dif_len; i++, buf++)\n\t\twrite_register_byte(dev, IPW_REG_INDIRECT_ACCESS_DATA + i,\n\t\t\t\t    *buf);\n}\n\nstatic void read_nic_memory(struct net_device *dev, u32 addr, u32 len,\n\t\t\t\t   u8 * buf)\n{\n\tu32 aligned_addr;\n\tu32 aligned_len;\n\tu32 dif_len;\n\tu32 i;\n\n\t/* read first nibble byte by byte */\n\taligned_addr = addr & (~0x3);\n\tdif_len = addr - aligned_addr;\n\tif (dif_len) {\n\t\t/* Start reading at aligned_addr + dif_len */\n\t\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\n\t\t\t       aligned_addr);\n\t\tfor (i = dif_len; i < 4; i++, buf++)\n\t\t\tread_register_byte(dev,\n\t\t\t\t\t   IPW_REG_INDIRECT_ACCESS_DATA + i,\n\t\t\t\t\t   buf);\n\n\t\tlen -= dif_len;\n\t\taligned_addr += 4;\n\t}\n\n\t/* read DWs through autoincrement registers */\n\twrite_register(dev, IPW_REG_AUTOINCREMENT_ADDRESS, aligned_addr);\n\taligned_len = len & (~0x3);\n\tfor (i = 0; i < aligned_len; i += 4, buf += 4, aligned_addr += 4)\n\t\tread_register(dev, IPW_REG_AUTOINCREMENT_DATA, (u32 *) buf);\n\n\t/* copy the last nibble */\n\tdif_len = len - aligned_len;\n\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS, aligned_addr);\n\tfor (i = 0; i < dif_len; i++, buf++)\n\t\tread_register_byte(dev, IPW_REG_INDIRECT_ACCESS_DATA + i, buf);\n}\n\nstatic bool ipw2100_hw_is_adapter_in_system(struct net_device *dev)\n{\n\tu32 dbg;\n\n\tread_register(dev, IPW_REG_DOA_DEBUG_AREA_START, &dbg);\n\n\treturn dbg == IPW_DATA_DOA_DEBUG_VALUE;\n}\n\nstatic int ipw2100_get_ordinal(struct ipw2100_priv *priv, u32 ord,\n\t\t\t       void *val, u32 * len)\n{\n\tstruct ipw2100_ordinals *ordinals = &priv->ordinals;\n\tu32 addr;\n\tu32 field_info;\n\tu16 field_len;\n\tu16 field_count;\n\tu32 total_length;\n\n\tif (ordinals->table1_addr == 0) {\n\t\tprintk(KERN_WARNING DRV_NAME \": attempt to use fw ordinals \"\n\t\t       \"before they have been loaded.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ORDINAL_TABLE_ONE(ordinals, ord)) {\n\t\tif (*len < IPW_ORD_TAB_1_ENTRY_SIZE) {\n\t\t\t*len = IPW_ORD_TAB_1_ENTRY_SIZE;\n\n\t\t\tprintk(KERN_WARNING DRV_NAME\n\t\t\t       \": ordinal buffer length too small, need %zd\\n\",\n\t\t\t       IPW_ORD_TAB_1_ENTRY_SIZE);\n\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tread_nic_dword(priv->net_dev,\n\t\t\t       ordinals->table1_addr + (ord << 2), &addr);\n\t\tread_nic_dword(priv->net_dev, addr, val);\n\n\t\t*len = IPW_ORD_TAB_1_ENTRY_SIZE;\n\n\t\treturn 0;\n\t}\n\n\tif (IS_ORDINAL_TABLE_TWO(ordinals, ord)) {\n\n\t\tord -= IPW_START_ORD_TAB_2;\n\n\t\t/* get the address of statistic */\n\t\tread_nic_dword(priv->net_dev,\n\t\t\t       ordinals->table2_addr + (ord << 3), &addr);\n\n\t\t/* get the second DW of statistics ;\n\t\t * two 16-bit words - first is length, second is count */\n\t\tread_nic_dword(priv->net_dev,\n\t\t\t       ordinals->table2_addr + (ord << 3) + sizeof(u32),\n\t\t\t       &field_info);\n\n\t\t/* get each entry length */\n\t\tfield_len = *((u16 *) & field_info);\n\n\t\t/* get number of entries */\n\t\tfield_count = *(((u16 *) & field_info) + 1);\n\n\t\t/* abort if no enough memory */\n\t\ttotal_length = field_len * field_count;\n\t\tif (total_length > *len) {\n\t\t\t*len = total_length;\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*len = total_length;\n\t\tif (!total_length)\n\t\t\treturn 0;\n\n\t\t/* read the ordinal data from the SRAM */\n\t\tread_nic_memory(priv->net_dev, addr, total_length, val);\n\n\t\treturn 0;\n\t}\n\n\tprintk(KERN_WARNING DRV_NAME \": ordinal %d neither in table 1 nor \"\n\t       \"in table 2\\n\", ord);\n\n\treturn -EINVAL;\n}\n\nstatic int ipw2100_set_ordinal(struct ipw2100_priv *priv, u32 ord, u32 * val,\n\t\t\t       u32 * len)\n{\n\tstruct ipw2100_ordinals *ordinals = &priv->ordinals;\n\tu32 addr;\n\n\tif (IS_ORDINAL_TABLE_ONE(ordinals, ord)) {\n\t\tif (*len != IPW_ORD_TAB_1_ENTRY_SIZE) {\n\t\t\t*len = IPW_ORD_TAB_1_ENTRY_SIZE;\n\t\t\tIPW_DEBUG_INFO(\"wrong size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tread_nic_dword(priv->net_dev,\n\t\t\t       ordinals->table1_addr + (ord << 2), &addr);\n\n\t\twrite_nic_dword(priv->net_dev, addr, *val);\n\n\t\t*len = IPW_ORD_TAB_1_ENTRY_SIZE;\n\n\t\treturn 0;\n\t}\n\n\tIPW_DEBUG_INFO(\"wrong table\\n\");\n\tif (IS_ORDINAL_TABLE_TWO(ordinals, ord))\n\t\treturn -EINVAL;\n\n\treturn -EINVAL;\n}\n\nstatic char *snprint_line(char *buf, size_t count,\n\t\t\t  const u8 * data, u32 len, u32 ofs)\n{\n\tint out, i, j, l;\n\tchar c;\n\n\tout = scnprintf(buf, count, \"%08X\", ofs);\n\n\tfor (l = 0, i = 0; i < 2; i++) {\n\t\tout += scnprintf(buf + out, count - out, \" \");\n\t\tfor (j = 0; j < 8 && l < len; j++, l++)\n\t\t\tout += scnprintf(buf + out, count - out, \"%02X \",\n\t\t\t\t\tdata[(i * 8 + j)]);\n\t\tfor (; j < 8; j++)\n\t\t\tout += scnprintf(buf + out, count - out, \"   \");\n\t}\n\n\tout += scnprintf(buf + out, count - out, \" \");\n\tfor (l = 0, i = 0; i < 2; i++) {\n\t\tout += scnprintf(buf + out, count - out, \" \");\n\t\tfor (j = 0; j < 8 && l < len; j++, l++) {\n\t\t\tc = data[(i * 8 + j)];\n\t\t\tif (!isascii(c) || !isprint(c))\n\t\t\t\tc = '.';\n\n\t\t\tout += scnprintf(buf + out, count - out, \"%c\", c);\n\t\t}\n\n\t\tfor (; j < 8; j++)\n\t\t\tout += scnprintf(buf + out, count - out, \" \");\n\t}\n\n\treturn buf;\n}\n\nstatic void printk_buf(int level, const u8 * data, u32 len)\n{\n\tchar line[81];\n\tu32 ofs = 0;\n\tif (!(ipw2100_debug_level & level))\n\t\treturn;\n\n\twhile (len) {\n\t\tprintk(KERN_DEBUG \"%s\\n\",\n\t\t       snprint_line(line, sizeof(line), &data[ofs],\n\t\t\t\t    min(len, 16U), ofs));\n\t\tofs += 16;\n\t\tlen -= min(len, 16U);\n\t}\n}\n\n#define MAX_RESET_BACKOFF 10\n\nstatic void schedule_reset(struct ipw2100_priv *priv)\n{\n\ttime64_t now = ktime_get_boottime_seconds();\n\n\t/* If we haven't received a reset request within the backoff period,\n\t * then we can reset the backoff interval so this reset occurs\n\t * immediately */\n\tif (priv->reset_backoff &&\n\t    (now - priv->last_reset > priv->reset_backoff))\n\t\tpriv->reset_backoff = 0;\n\n\tpriv->last_reset = now;\n\n\tif (!(priv->status & STATUS_RESET_PENDING)) {\n\t\tIPW_DEBUG_INFO(\"%s: Scheduling firmware restart (%llds).\\n\",\n\t\t\t       priv->net_dev->name, priv->reset_backoff);\n\t\tnetif_carrier_off(priv->net_dev);\n\t\tnetif_stop_queue(priv->net_dev);\n\t\tpriv->status |= STATUS_RESET_PENDING;\n\t\tif (priv->reset_backoff)\n\t\t\tschedule_delayed_work(&priv->reset_work,\n\t\t\t\t\t      priv->reset_backoff * HZ);\n\t\telse\n\t\t\tschedule_delayed_work(&priv->reset_work, 0);\n\n\t\tif (priv->reset_backoff < MAX_RESET_BACKOFF)\n\t\t\tpriv->reset_backoff++;\n\n\t\twake_up_interruptible(&priv->wait_command_queue);\n\t} else\n\t\tIPW_DEBUG_INFO(\"%s: Firmware restart already in progress.\\n\",\n\t\t\t       priv->net_dev->name);\n\n}\n\n#define HOST_COMPLETE_TIMEOUT (2 * HZ)\nstatic int ipw2100_hw_send_command(struct ipw2100_priv *priv,\n\t\t\t\t   struct host_command *cmd)\n{\n\tstruct list_head *element;\n\tstruct ipw2100_tx_packet *packet;\n\tunsigned long flags;\n\tint err = 0;\n\n\tIPW_DEBUG_HC(\"Sending %s command (#%d), %d bytes\\n\",\n\t\t     command_types[cmd->host_command], cmd->host_command,\n\t\t     cmd->host_command_length);\n\tprintk_buf(IPW_DL_HC, (u8 *) cmd->host_command_parameters,\n\t\t   cmd->host_command_length);\n\n\tspin_lock_irqsave(&priv->low_lock, flags);\n\n\tif (priv->fatal_error) {\n\t\tIPW_DEBUG_INFO\n\t\t    (\"Attempt to send command while hardware in fatal error condition.\\n\");\n\t\terr = -EIO;\n\t\tgoto fail_unlock;\n\t}\n\n\tif (!(priv->status & STATUS_RUNNING)) {\n\t\tIPW_DEBUG_INFO\n\t\t    (\"Attempt to send command while hardware is not running.\\n\");\n\t\terr = -EIO;\n\t\tgoto fail_unlock;\n\t}\n\n\tif (priv->status & STATUS_CMD_ACTIVE) {\n\t\tIPW_DEBUG_INFO\n\t\t    (\"Attempt to send command while another command is pending.\\n\");\n\t\terr = -EBUSY;\n\t\tgoto fail_unlock;\n\t}\n\n\tif (list_empty(&priv->msg_free_list)) {\n\t\tIPW_DEBUG_INFO(\"no available msg buffers\\n\");\n\t\tgoto fail_unlock;\n\t}\n\n\tpriv->status |= STATUS_CMD_ACTIVE;\n\tpriv->messages_sent++;\n\n\telement = priv->msg_free_list.next;\n\n\tpacket = list_entry(element, struct ipw2100_tx_packet, list);\n\tpacket->jiffy_start = jiffies;\n\n\t/* initialize the firmware command packet */\n\tpacket->info.c_struct.cmd->host_command_reg = cmd->host_command;\n\tpacket->info.c_struct.cmd->host_command_reg1 = cmd->host_command1;\n\tpacket->info.c_struct.cmd->host_command_len_reg =\n\t    cmd->host_command_length;\n\tpacket->info.c_struct.cmd->sequence = cmd->host_command_sequence;\n\n\tmemcpy(packet->info.c_struct.cmd->host_command_params_reg,\n\t       cmd->host_command_parameters,\n\t       sizeof(packet->info.c_struct.cmd->host_command_params_reg));\n\n\tlist_del(element);\n\tDEC_STAT(&priv->msg_free_stat);\n\n\tlist_add_tail(element, &priv->msg_pend_list);\n\tINC_STAT(&priv->msg_pend_stat);\n\n\tipw2100_tx_send_commands(priv);\n\tipw2100_tx_send_data(priv);\n\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\n\t/*\n\t * We must wait for this command to complete before another\n\t * command can be sent...  but if we wait more than 3 seconds\n\t * then there is a problem.\n\t */\n\n\terr =\n\t    wait_event_interruptible_timeout(priv->wait_command_queue,\n\t\t\t\t\t     !(priv->\n\t\t\t\t\t       status & STATUS_CMD_ACTIVE),\n\t\t\t\t\t     HOST_COMPLETE_TIMEOUT);\n\n\tif (err == 0) {\n\t\tIPW_DEBUG_INFO(\"Command completion failed out after %dms.\\n\",\n\t\t\t       1000 * (HOST_COMPLETE_TIMEOUT / HZ));\n\t\tpriv->fatal_error = IPW2100_ERR_MSG_TIMEOUT;\n\t\tpriv->status &= ~STATUS_CMD_ACTIVE;\n\t\tschedule_reset(priv);\n\t\treturn -EIO;\n\t}\n\n\tif (priv->fatal_error) {\n\t\tprintk(KERN_WARNING DRV_NAME \": %s: firmware fatal error\\n\",\n\t\t       priv->net_dev->name);\n\t\treturn -EIO;\n\t}\n\n\t/* !!!!! HACK TEST !!!!!\n\t * When lots of debug trace statements are enabled, the driver\n\t * doesn't seem to have as many firmware restart cycles...\n\t *\n\t * As a test, we're sticking in a 1/100s delay here */\n\tschedule_timeout_uninterruptible(msecs_to_jiffies(10));\n\n\treturn 0;\n\n      fail_unlock:\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\n\treturn err;\n}\n\n/*\n * Verify the values and data access of the hardware\n * No locks needed or used.  No functions called.\n */\nstatic int ipw2100_verify(struct ipw2100_priv *priv)\n{\n\tu32 data1, data2;\n\tu32 address;\n\n\tu32 val1 = 0x76543210;\n\tu32 val2 = 0xFEDCBA98;\n\n\t/* Domain 0 check - all values should be DOA_DEBUG */\n\tfor (address = IPW_REG_DOA_DEBUG_AREA_START;\n\t     address < IPW_REG_DOA_DEBUG_AREA_END; address += sizeof(u32)) {\n\t\tread_register(priv->net_dev, address, &data1);\n\t\tif (data1 != IPW_DATA_DOA_DEBUG_VALUE)\n\t\t\treturn -EIO;\n\t}\n\n\t/* Domain 1 check - use arbitrary read/write compare  */\n\tfor (address = 0; address < 5; address++) {\n\t\t/* The memory area is not used now */\n\t\twrite_register(priv->net_dev, IPW_REG_DOMAIN_1_OFFSET + 0x32,\n\t\t\t       val1);\n\t\twrite_register(priv->net_dev, IPW_REG_DOMAIN_1_OFFSET + 0x36,\n\t\t\t       val2);\n\t\tread_register(priv->net_dev, IPW_REG_DOMAIN_1_OFFSET + 0x32,\n\t\t\t      &data1);\n\t\tread_register(priv->net_dev, IPW_REG_DOMAIN_1_OFFSET + 0x36,\n\t\t\t      &data2);\n\t\tif (val1 == data1 && val2 == data2)\n\t\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}\n\n/*\n *\n * Loop until the CARD_DISABLED bit is the same value as the\n * supplied parameter\n *\n * TODO: See if it would be more efficient to do a wait/wake\n *       cycle and have the completion event trigger the wakeup\n *\n */\n#define IPW_CARD_DISABLE_COMPLETE_WAIT\t\t    100\t// 100 milli\nstatic int ipw2100_wait_for_card_state(struct ipw2100_priv *priv, int state)\n{\n\tint i;\n\tu32 card_state;\n\tu32 len = sizeof(card_state);\n\tint err;\n\n\tfor (i = 0; i <= IPW_CARD_DISABLE_COMPLETE_WAIT * 1000; i += 50) {\n\t\terr = ipw2100_get_ordinal(priv, IPW_ORD_CARD_DISABLED,\n\t\t\t\t\t  &card_state, &len);\n\t\tif (err) {\n\t\t\tIPW_DEBUG_INFO(\"Query of CARD_DISABLED ordinal \"\n\t\t\t\t       \"failed.\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* We'll break out if either the HW state says it is\n\t\t * in the state we want, or if HOST_COMPLETE command\n\t\t * finishes */\n\t\tif ((card_state == state) ||\n\t\t    ((priv->status & STATUS_ENABLED) ?\n\t\t     IPW_HW_STATE_ENABLED : IPW_HW_STATE_DISABLED) == state) {\n\t\t\tif (state == IPW_HW_STATE_ENABLED)\n\t\t\t\tpriv->status |= STATUS_ENABLED;\n\t\t\telse\n\t\t\t\tpriv->status &= ~STATUS_ENABLED;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tudelay(50);\n\t}\n\n\tIPW_DEBUG_INFO(\"ipw2100_wait_for_card_state to %s state timed out\\n\",\n\t\t       state ? \"DISABLED\" : \"ENABLED\");\n\treturn -EIO;\n}\n\n/*********************************************************************\n    Procedure   :   sw_reset_and_clock\n    Purpose     :   Asserts s/w reset, asserts clock initialization\n                    and waits for clock stabilization\n ********************************************************************/\nstatic int sw_reset_and_clock(struct ipw2100_priv *priv)\n{\n\tint i;\n\tu32 r;\n\n\t// assert s/w reset\n\twrite_register(priv->net_dev, IPW_REG_RESET_REG,\n\t\t       IPW_AUX_HOST_RESET_REG_SW_RESET);\n\n\t// wait for clock stabilization\n\tfor (i = 0; i < 1000; i++) {\n\t\tudelay(IPW_WAIT_RESET_ARC_COMPLETE_DELAY);\n\n\t\t// check clock ready bit\n\t\tread_register(priv->net_dev, IPW_REG_RESET_REG, &r);\n\t\tif (r & IPW_AUX_HOST_RESET_REG_PRINCETON_RESET)\n\t\t\tbreak;\n\t}\n\n\tif (i == 1000)\n\t\treturn -EIO;\t// TODO: better error value\n\n\t/* set \"initialization complete\" bit to move adapter to\n\t * D0 state */\n\twrite_register(priv->net_dev, IPW_REG_GP_CNTRL,\n\t\t       IPW_AUX_HOST_GP_CNTRL_BIT_INIT_DONE);\n\n\t/* wait for clock stabilization */\n\tfor (i = 0; i < 10000; i++) {\n\t\tudelay(IPW_WAIT_CLOCK_STABILIZATION_DELAY * 4);\n\n\t\t/* check clock ready bit */\n\t\tread_register(priv->net_dev, IPW_REG_GP_CNTRL, &r);\n\t\tif (r & IPW_AUX_HOST_GP_CNTRL_BIT_CLOCK_READY)\n\t\t\tbreak;\n\t}\n\n\tif (i == 10000)\n\t\treturn -EIO;\t/* TODO: better error value */\n\n\t/* set D0 standby bit */\n\tread_register(priv->net_dev, IPW_REG_GP_CNTRL, &r);\n\twrite_register(priv->net_dev, IPW_REG_GP_CNTRL,\n\t\t       r | IPW_AUX_HOST_GP_CNTRL_BIT_HOST_ALLOWS_STANDBY);\n\n\treturn 0;\n}\n\n/*********************************************************************\n    Procedure   :   ipw2100_download_firmware\n    Purpose     :   Initiaze adapter after power on.\n                    The sequence is:\n                    1. assert s/w reset first!\n                    2. awake clocks & wait for clock stabilization\n                    3. hold ARC (don't ask me why...)\n                    4. load Dino ucode and reset/clock init again\n                    5. zero-out shared mem\n                    6. download f/w\n *******************************************************************/\nstatic int ipw2100_download_firmware(struct ipw2100_priv *priv)\n{\n\tu32 address;\n\tint err;\n\n#ifndef CONFIG_PM\n\t/* Fetch the firmware and microcode */\n\tstruct ipw2100_fw ipw2100_firmware;\n#endif\n\n\tif (priv->fatal_error) {\n\t\tIPW_DEBUG_ERROR(\"%s: ipw2100_download_firmware called after \"\n\t\t\t\t\"fatal error %d.  Interface must be brought down.\\n\",\n\t\t\t\tpriv->net_dev->name, priv->fatal_error);\n\t\treturn -EINVAL;\n\t}\n#ifdef CONFIG_PM\n\tif (!ipw2100_firmware.version) {\n\t\terr = ipw2100_get_firmware(priv, &ipw2100_firmware);\n\t\tif (err) {\n\t\t\tIPW_DEBUG_ERROR(\"%s: ipw2100_get_firmware failed: %d\\n\",\n\t\t\t\t\tpriv->net_dev->name, err);\n\t\t\tpriv->fatal_error = IPW2100_ERR_FW_LOAD;\n\t\t\tgoto fail;\n\t\t}\n\t}\n#else\n\terr = ipw2100_get_firmware(priv, &ipw2100_firmware);\n\tif (err) {\n\t\tIPW_DEBUG_ERROR(\"%s: ipw2100_get_firmware failed: %d\\n\",\n\t\t\t\tpriv->net_dev->name, err);\n\t\tpriv->fatal_error = IPW2100_ERR_FW_LOAD;\n\t\tgoto fail;\n\t}\n#endif\n\tpriv->firmware_version = ipw2100_firmware.version;\n\n\t/* s/w reset and clock stabilization */\n\terr = sw_reset_and_clock(priv);\n\tif (err) {\n\t\tIPW_DEBUG_ERROR(\"%s: sw_reset_and_clock failed: %d\\n\",\n\t\t\t\tpriv->net_dev->name, err);\n\t\tgoto fail;\n\t}\n\n\terr = ipw2100_verify(priv);\n\tif (err) {\n\t\tIPW_DEBUG_ERROR(\"%s: ipw2100_verify failed: %d\\n\",\n\t\t\t\tpriv->net_dev->name, err);\n\t\tgoto fail;\n\t}\n\n\t/* Hold ARC */\n\twrite_nic_dword(priv->net_dev,\n\t\t\tIPW_INTERNAL_REGISTER_HALT_AND_RESET, 0x80000000);\n\n\t/* allow ARC to run */\n\twrite_register(priv->net_dev, IPW_REG_RESET_REG, 0);\n\n\t/* load microcode */\n\terr = ipw2100_ucode_download(priv, &ipw2100_firmware);\n\tif (err) {\n\t\tprintk(KERN_ERR DRV_NAME \": %s: Error loading microcode: %d\\n\",\n\t\t       priv->net_dev->name, err);\n\t\tgoto fail;\n\t}\n\n\t/* release ARC */\n\twrite_nic_dword(priv->net_dev,\n\t\t\tIPW_INTERNAL_REGISTER_HALT_AND_RESET, 0x00000000);\n\n\t/* s/w reset and clock stabilization (again!!!) */\n\terr = sw_reset_and_clock(priv);\n\tif (err) {\n\t\tprintk(KERN_ERR DRV_NAME\n\t\t       \": %s: sw_reset_and_clock failed: %d\\n\",\n\t\t       priv->net_dev->name, err);\n\t\tgoto fail;\n\t}\n\n\t/* load f/w */\n\terr = ipw2100_fw_download(priv, &ipw2100_firmware);\n\tif (err) {\n\t\tIPW_DEBUG_ERROR(\"%s: Error loading firmware: %d\\n\",\n\t\t\t\tpriv->net_dev->name, err);\n\t\tgoto fail;\n\t}\n#ifndef CONFIG_PM\n\t/*\n\t * When the .resume method of the driver is called, the other\n\t * part of the system, i.e. the ide driver could still stay in\n\t * the suspend stage. This prevents us from loading the firmware\n\t * from the disk.  --YZ\n\t */\n\n\t/* free any storage allocated for firmware image */\n\tipw2100_release_firmware(priv, &ipw2100_firmware);\n#endif\n\n\t/* zero out Domain 1 area indirectly (Si requirement) */\n\tfor (address = IPW_HOST_FW_SHARED_AREA0;\n\t     address < IPW_HOST_FW_SHARED_AREA0_END; address += 4)\n\t\twrite_nic_dword(priv->net_dev, address, 0);\n\tfor (address = IPW_HOST_FW_SHARED_AREA1;\n\t     address < IPW_HOST_FW_SHARED_AREA1_END; address += 4)\n\t\twrite_nic_dword(priv->net_dev, address, 0);\n\tfor (address = IPW_HOST_FW_SHARED_AREA2;\n\t     address < IPW_HOST_FW_SHARED_AREA2_END; address += 4)\n\t\twrite_nic_dword(priv->net_dev, address, 0);\n\tfor (address = IPW_HOST_FW_SHARED_AREA3;\n\t     address < IPW_HOST_FW_SHARED_AREA3_END; address += 4)\n\t\twrite_nic_dword(priv->net_dev, address, 0);\n\tfor (address = IPW_HOST_FW_INTERRUPT_AREA;\n\t     address < IPW_HOST_FW_INTERRUPT_AREA_END; address += 4)\n\t\twrite_nic_dword(priv->net_dev, address, 0);\n\n\treturn 0;\n\n      fail:\n\tipw2100_release_firmware(priv, &ipw2100_firmware);\n\treturn err;\n}\n\nstatic inline void ipw2100_enable_interrupts(struct ipw2100_priv *priv)\n{\n\tif (priv->status & STATUS_INT_ENABLED)\n\t\treturn;\n\tpriv->status |= STATUS_INT_ENABLED;\n\twrite_register(priv->net_dev, IPW_REG_INTA_MASK, IPW_INTERRUPT_MASK);\n}\n\nstatic inline void ipw2100_disable_interrupts(struct ipw2100_priv *priv)\n{\n\tif (!(priv->status & STATUS_INT_ENABLED))\n\t\treturn;\n\tpriv->status &= ~STATUS_INT_ENABLED;\n\twrite_register(priv->net_dev, IPW_REG_INTA_MASK, 0x0);\n}\n\nstatic void ipw2100_initialize_ordinals(struct ipw2100_priv *priv)\n{\n\tstruct ipw2100_ordinals *ord = &priv->ordinals;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tread_register(priv->net_dev, IPW_MEM_HOST_SHARED_ORDINALS_TABLE_1,\n\t\t      &ord->table1_addr);\n\n\tread_register(priv->net_dev, IPW_MEM_HOST_SHARED_ORDINALS_TABLE_2,\n\t\t      &ord->table2_addr);\n\n\tread_nic_dword(priv->net_dev, ord->table1_addr, &ord->table1_size);\n\tread_nic_dword(priv->net_dev, ord->table2_addr, &ord->table2_size);\n\n\tord->table2_size &= 0x0000FFFF;\n\n\tIPW_DEBUG_INFO(\"table 1 size: %d\\n\", ord->table1_size);\n\tIPW_DEBUG_INFO(\"table 2 size: %d\\n\", ord->table2_size);\n\tIPW_DEBUG_INFO(\"exit\\n\");\n}\n\nstatic inline void ipw2100_hw_set_gpio(struct ipw2100_priv *priv)\n{\n\tu32 reg = 0;\n\t/*\n\t * Set GPIO 3 writable by FW; GPIO 1 writable\n\t * by driver and enable clock\n\t */\n\treg = (IPW_BIT_GPIO_GPIO3_MASK | IPW_BIT_GPIO_GPIO1_ENABLE |\n\t       IPW_BIT_GPIO_LED_OFF);\n\twrite_register(priv->net_dev, IPW_REG_GPIO, reg);\n}\n\nstatic int rf_kill_active(struct ipw2100_priv *priv)\n{\n#define MAX_RF_KILL_CHECKS 5\n#define RF_KILL_CHECK_DELAY 40\n\n\tunsigned short value = 0;\n\tu32 reg = 0;\n\tint i;\n\n\tif (!(priv->hw_features & HW_FEATURE_RFKILL)) {\n\t\twiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, false);\n\t\tpriv->status &= ~STATUS_RF_KILL_HW;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < MAX_RF_KILL_CHECKS; i++) {\n\t\tudelay(RF_KILL_CHECK_DELAY);\n\t\tread_register(priv->net_dev, IPW_REG_GPIO, &reg);\n\t\tvalue = (value << 1) | ((reg & IPW_BIT_GPIO_RF_KILL) ? 0 : 1);\n\t}\n\n\tif (value == 0) {\n\t\twiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, true);\n\t\tpriv->status |= STATUS_RF_KILL_HW;\n\t} else {\n\t\twiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, false);\n\t\tpriv->status &= ~STATUS_RF_KILL_HW;\n\t}\n\n\treturn (value == 0);\n}\n\nstatic int ipw2100_get_hw_features(struct ipw2100_priv *priv)\n{\n\tu32 addr, len;\n\tu32 val;\n\n\t/*\n\t * EEPROM_SRAM_DB_START_ADDRESS using ordinal in ordinal table 1\n\t */\n\tlen = sizeof(addr);\n\tif (ipw2100_get_ordinal\n\t    (priv, IPW_ORD_EEPROM_SRAM_DB_BLOCK_START_ADDRESS, &addr, &len)) {\n\t\tIPW_DEBUG_INFO(\"failed querying ordinals at line %d\\n\",\n\t\t\t       __LINE__);\n\t\treturn -EIO;\n\t}\n\n\tIPW_DEBUG_INFO(\"EEPROM address: %08X\\n\", addr);\n\n\t/*\n\t * EEPROM version is the byte at offset 0xfd in firmware\n\t * We read 4 bytes, then shift out the byte we actually want */\n\tread_nic_dword(priv->net_dev, addr + 0xFC, &val);\n\tpriv->eeprom_version = (val >> 24) & 0xFF;\n\tIPW_DEBUG_INFO(\"EEPROM version: %d\\n\", priv->eeprom_version);\n\n\t/*\n\t *  HW RF Kill enable is bit 0 in byte at offset 0x21 in firmware\n\t *\n\t *  notice that the EEPROM bit is reverse polarity, i.e.\n\t *     bit = 0  signifies HW RF kill switch is supported\n\t *     bit = 1  signifies HW RF kill switch is NOT supported\n\t */\n\tread_nic_dword(priv->net_dev, addr + 0x20, &val);\n\tif (!((val >> 24) & 0x01))\n\t\tpriv->hw_features |= HW_FEATURE_RFKILL;\n\n\tIPW_DEBUG_INFO(\"HW RF Kill: %ssupported.\\n\",\n\t\t       (priv->hw_features & HW_FEATURE_RFKILL) ? \"\" : \"not \");\n\n\treturn 0;\n}\n\n/*\n * Start firmware execution after power on and initialization\n * The sequence is:\n *  1. Release ARC\n *  2. Wait for f/w initialization completes;\n */\nstatic int ipw2100_start_adapter(struct ipw2100_priv *priv)\n{\n\tint i;\n\tu32 inta, inta_mask, gpio;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tif (priv->status & STATUS_RUNNING)\n\t\treturn 0;\n\n\t/*\n\t * Initialize the hw - drive adapter to DO state by setting\n\t * init_done bit. Wait for clk_ready bit and Download\n\t * fw & dino ucode\n\t */\n\tif (ipw2100_download_firmware(priv)) {\n\t\tprintk(KERN_ERR DRV_NAME\n\t\t       \": %s: Failed to power on the adapter.\\n\",\n\t\t       priv->net_dev->name);\n\t\treturn -EIO;\n\t}\n\n\t/* Clear the Tx, Rx and Msg queues and the r/w indexes\n\t * in the firmware RBD and TBD ring queue */\n\tipw2100_queues_initialize(priv);\n\n\tipw2100_hw_set_gpio(priv);\n\n\t/* TODO -- Look at disabling interrupts here to make sure none\n\t * get fired during FW initialization */\n\n\t/* Release ARC - clear reset bit */\n\twrite_register(priv->net_dev, IPW_REG_RESET_REG, 0);\n\n\t/* wait for f/w initialization complete */\n\tIPW_DEBUG_FW(\"Waiting for f/w initialization to complete...\\n\");\n\ti = 5000;\n\tdo {\n\t\tschedule_timeout_uninterruptible(msecs_to_jiffies(40));\n\t\t/* Todo... wait for sync command ... */\n\n\t\tread_register(priv->net_dev, IPW_REG_INTA, &inta);\n\n\t\t/* check \"init done\" bit */\n\t\tif (inta & IPW2100_INTA_FW_INIT_DONE) {\n\t\t\t/* reset \"init done\" bit */\n\t\t\twrite_register(priv->net_dev, IPW_REG_INTA,\n\t\t\t\t       IPW2100_INTA_FW_INIT_DONE);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check error conditions : we check these after the firmware\n\t\t * check so that if there is an error, the interrupt handler\n\t\t * will see it and the adapter will be reset */\n\t\tif (inta &\n\t\t    (IPW2100_INTA_FATAL_ERROR | IPW2100_INTA_PARITY_ERROR)) {\n\t\t\t/* clear error conditions */\n\t\t\twrite_register(priv->net_dev, IPW_REG_INTA,\n\t\t\t\t       IPW2100_INTA_FATAL_ERROR |\n\t\t\t\t       IPW2100_INTA_PARITY_ERROR);\n\t\t}\n\t} while (--i);\n\n\t/* Clear out any pending INTAs since we aren't supposed to have\n\t * interrupts enabled at this point... */\n\tread_register(priv->net_dev, IPW_REG_INTA, &inta);\n\tread_register(priv->net_dev, IPW_REG_INTA_MASK, &inta_mask);\n\tinta &= IPW_INTERRUPT_MASK;\n\t/* Clear out any pending interrupts */\n\tif (inta & inta_mask)\n\t\twrite_register(priv->net_dev, IPW_REG_INTA, inta);\n\n\tIPW_DEBUG_FW(\"f/w initialization complete: %s\\n\",\n\t\t     i ? \"SUCCESS\" : \"FAILED\");\n\n\tif (!i) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \": %s: Firmware did not initialize.\\n\",\n\t\t       priv->net_dev->name);\n\t\treturn -EIO;\n\t}\n\n\t/* allow firmware to write to GPIO1 & GPIO3 */\n\tread_register(priv->net_dev, IPW_REG_GPIO, &gpio);\n\n\tgpio |= (IPW_BIT_GPIO_GPIO1_MASK | IPW_BIT_GPIO_GPIO3_MASK);\n\n\twrite_register(priv->net_dev, IPW_REG_GPIO, gpio);\n\n\t/* Ready to receive commands */\n\tpriv->status |= STATUS_RUNNING;\n\n\t/* The adapter has been reset; we are not associated */\n\tpriv->status &= ~(STATUS_ASSOCIATING | STATUS_ASSOCIATED);\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\n\treturn 0;\n}\n\nstatic inline void ipw2100_reset_fatalerror(struct ipw2100_priv *priv)\n{\n\tif (!priv->fatal_error)\n\t\treturn;\n\n\tpriv->fatal_errors[priv->fatal_index++] = priv->fatal_error;\n\tpriv->fatal_index %= IPW2100_ERROR_QUEUE;\n\tpriv->fatal_error = 0;\n}\n\n/* NOTE: Our interrupt is disabled when this method is called */\nstatic int ipw2100_power_cycle_adapter(struct ipw2100_priv *priv)\n{\n\tu32 reg;\n\tint i;\n\n\tIPW_DEBUG_INFO(\"Power cycling the hardware.\\n\");\n\n\tipw2100_hw_set_gpio(priv);\n\n\t/* Step 1. Stop Master Assert */\n\twrite_register(priv->net_dev, IPW_REG_RESET_REG,\n\t\t       IPW_AUX_HOST_RESET_REG_STOP_MASTER);\n\n\t/* Step 2. Wait for stop Master Assert\n\t *         (not more than 50us, otherwise ret error */\n\ti = 5;\n\tdo {\n\t\tudelay(IPW_WAIT_RESET_MASTER_ASSERT_COMPLETE_DELAY);\n\t\tread_register(priv->net_dev, IPW_REG_RESET_REG, &reg);\n\n\t\tif (reg & IPW_AUX_HOST_RESET_REG_MASTER_DISABLED)\n\t\t\tbreak;\n\t} while (--i);\n\n\tpriv->status &= ~STATUS_RESET_PENDING;\n\n\tif (!i) {\n\t\tIPW_DEBUG_INFO\n\t\t    (\"exit - waited too long for master assert stop\\n\");\n\t\treturn -EIO;\n\t}\n\n\twrite_register(priv->net_dev, IPW_REG_RESET_REG,\n\t\t       IPW_AUX_HOST_RESET_REG_SW_RESET);\n\n\t/* Reset any fatal_error conditions */\n\tipw2100_reset_fatalerror(priv);\n\n\t/* At this point, the adapter is now stopped and disabled */\n\tpriv->status &= ~(STATUS_RUNNING | STATUS_ASSOCIATING |\n\t\t\t  STATUS_ASSOCIATED | STATUS_ENABLED);\n\n\treturn 0;\n}\n\n/*\n * Send the CARD_DISABLE_PHY_OFF command to the card to disable it\n *\n * After disabling, if the card was associated, a STATUS_ASSN_LOST will be sent.\n *\n * STATUS_CARD_DISABLE_NOTIFICATION will be sent regardless of\n * if STATUS_ASSN_LOST is sent.\n */\nstatic int ipw2100_hw_phy_off(struct ipw2100_priv *priv)\n{\n\n#define HW_PHY_OFF_LOOP_DELAY (msecs_to_jiffies(50))\n\n\tstruct host_command cmd = {\n\t\t.host_command = CARD_DISABLE_PHY_OFF,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 0,\n\t};\n\tint err, i;\n\tu32 val1, val2;\n\n\tIPW_DEBUG_HC(\"CARD_DISABLE_PHY_OFF\\n\");\n\n\t/* Turn off the radio */\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < 2500; i++) {\n\t\tread_nic_dword(priv->net_dev, IPW2100_CONTROL_REG, &val1);\n\t\tread_nic_dword(priv->net_dev, IPW2100_COMMAND, &val2);\n\n\t\tif ((val1 & IPW2100_CONTROL_PHY_OFF) &&\n\t\t    (val2 & IPW2100_COMMAND_PHY_OFF))\n\t\t\treturn 0;\n\n\t\tschedule_timeout_uninterruptible(HW_PHY_OFF_LOOP_DELAY);\n\t}\n\n\treturn -EIO;\n}\n\nstatic int ipw2100_enable_adapter(struct ipw2100_priv *priv)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = HOST_COMPLETE,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 0\n\t};\n\tint err = 0;\n\n\tIPW_DEBUG_HC(\"HOST_COMPLETE\\n\");\n\n\tif (priv->status & STATUS_ENABLED)\n\t\treturn 0;\n\n\tmutex_lock(&priv->adapter_mutex);\n\n\tif (rf_kill_active(priv)) {\n\t\tIPW_DEBUG_HC(\"Command aborted due to RF kill active.\\n\");\n\t\tgoto fail_up;\n\t}\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err) {\n\t\tIPW_DEBUG_INFO(\"Failed to send HOST_COMPLETE command\\n\");\n\t\tgoto fail_up;\n\t}\n\n\terr = ipw2100_wait_for_card_state(priv, IPW_HW_STATE_ENABLED);\n\tif (err) {\n\t\tIPW_DEBUG_INFO(\"%s: card not responding to init command.\\n\",\n\t\t\t       priv->net_dev->name);\n\t\tgoto fail_up;\n\t}\n\n\tif (priv->stop_hang_check) {\n\t\tpriv->stop_hang_check = 0;\n\t\tschedule_delayed_work(&priv->hang_check, HZ / 2);\n\t}\n\n      fail_up:\n\tmutex_unlock(&priv->adapter_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_hw_stop_adapter(struct ipw2100_priv *priv)\n{\n#define HW_POWER_DOWN_DELAY (msecs_to_jiffies(100))\n\n\tstruct host_command cmd = {\n\t\t.host_command = HOST_PRE_POWER_DOWN,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 0,\n\t};\n\tint err, i;\n\tu32 reg;\n\n\tif (!(priv->status & STATUS_RUNNING))\n\t\treturn 0;\n\n\tpriv->status |= STATUS_STOPPING;\n\n\t/* We can only shut down the card if the firmware is operational.  So,\n\t * if we haven't reset since a fatal_error, then we can not send the\n\t * shutdown commands. */\n\tif (!priv->fatal_error) {\n\t\t/* First, make sure the adapter is enabled so that the PHY_OFF\n\t\t * command can shut it down */\n\t\tipw2100_enable_adapter(priv);\n\n\t\terr = ipw2100_hw_phy_off(priv);\n\t\tif (err)\n\t\t\tprintk(KERN_WARNING DRV_NAME\n\t\t\t       \": Error disabling radio %d\\n\", err);\n\n\t\t/*\n\t\t * If in D0-standby mode going directly to D3 may cause a\n\t\t * PCI bus violation.  Therefore we must change out of the D0\n\t\t * state.\n\t\t *\n\t\t * Sending the PREPARE_FOR_POWER_DOWN will restrict the\n\t\t * hardware from going into standby mode and will transition\n\t\t * out of D0-standby if it is already in that state.\n\t\t *\n\t\t * STATUS_PREPARE_POWER_DOWN_COMPLETE will be sent by the\n\t\t * driver upon completion.  Once received, the driver can\n\t\t * proceed to the D3 state.\n\t\t *\n\t\t * Prepare for power down command to fw.  This command would\n\t\t * take HW out of D0-standby and prepare it for D3 state.\n\t\t *\n\t\t * Currently FW does not support event notification for this\n\t\t * event. Therefore, skip waiting for it.  Just wait a fixed\n\t\t * 100ms\n\t\t */\n\t\tIPW_DEBUG_HC(\"HOST_PRE_POWER_DOWN\\n\");\n\n\t\terr = ipw2100_hw_send_command(priv, &cmd);\n\t\tif (err)\n\t\t\tprintk(KERN_WARNING DRV_NAME \": \"\n\t\t\t       \"%s: Power down command failed: Error %d\\n\",\n\t\t\t       priv->net_dev->name, err);\n\t\telse\n\t\t\tschedule_timeout_uninterruptible(HW_POWER_DOWN_DELAY);\n\t}\n\n\tpriv->status &= ~STATUS_ENABLED;\n\n\t/*\n\t * Set GPIO 3 writable by FW; GPIO 1 writable\n\t * by driver and enable clock\n\t */\n\tipw2100_hw_set_gpio(priv);\n\n\t/*\n\t * Power down adapter.  Sequence:\n\t * 1. Stop master assert (RESET_REG[9]=1)\n\t * 2. Wait for stop master (RESET_REG[8]==1)\n\t * 3. S/w reset assert (RESET_REG[7] = 1)\n\t */\n\n\t/* Stop master assert */\n\twrite_register(priv->net_dev, IPW_REG_RESET_REG,\n\t\t       IPW_AUX_HOST_RESET_REG_STOP_MASTER);\n\n\t/* wait stop master not more than 50 usec.\n\t * Otherwise return error. */\n\tfor (i = 5; i > 0; i--) {\n\t\tudelay(10);\n\n\t\t/* Check master stop bit */\n\t\tread_register(priv->net_dev, IPW_REG_RESET_REG, &reg);\n\n\t\tif (reg & IPW_AUX_HOST_RESET_REG_MASTER_DISABLED)\n\t\t\tbreak;\n\t}\n\n\tif (i == 0)\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \": %s: Could now power down adapter.\\n\",\n\t\t       priv->net_dev->name);\n\n\t/* assert s/w reset */\n\twrite_register(priv->net_dev, IPW_REG_RESET_REG,\n\t\t       IPW_AUX_HOST_RESET_REG_SW_RESET);\n\n\tpriv->status &= ~(STATUS_RUNNING | STATUS_STOPPING);\n\n\treturn 0;\n}\n\nstatic int ipw2100_disable_adapter(struct ipw2100_priv *priv)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = CARD_DISABLE,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 0\n\t};\n\tint err = 0;\n\n\tIPW_DEBUG_HC(\"CARD_DISABLE\\n\");\n\n\tif (!(priv->status & STATUS_ENABLED))\n\t\treturn 0;\n\n\t/* Make sure we clear the associated state */\n\tpriv->status &= ~(STATUS_ASSOCIATED | STATUS_ASSOCIATING);\n\n\tif (!priv->stop_hang_check) {\n\t\tpriv->stop_hang_check = 1;\n\t\tcancel_delayed_work(&priv->hang_check);\n\t}\n\n\tmutex_lock(&priv->adapter_mutex);\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \": exit - failed to send CARD_DISABLE command\\n\");\n\t\tgoto fail_up;\n\t}\n\n\terr = ipw2100_wait_for_card_state(priv, IPW_HW_STATE_DISABLED);\n\tif (err) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \": exit - card failed to change to DISABLED\\n\");\n\t\tgoto fail_up;\n\t}\n\n\tIPW_DEBUG_INFO(\"TODO: implement scan state machine\\n\");\n\n      fail_up:\n\tmutex_unlock(&priv->adapter_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_set_scan_options(struct ipw2100_priv *priv)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = SET_SCAN_OPTIONS,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 8\n\t};\n\tint err;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tIPW_DEBUG_SCAN(\"setting scan options\\n\");\n\n\tcmd.host_command_parameters[0] = 0;\n\n\tif (!(priv->config & CFG_ASSOCIATE))\n\t\tcmd.host_command_parameters[0] |= IPW_SCAN_NOASSOCIATE;\n\tif ((priv->ieee->sec.flags & SEC_ENABLED) && priv->ieee->sec.enabled)\n\t\tcmd.host_command_parameters[0] |= IPW_SCAN_MIXED_CELL;\n\tif (priv->config & CFG_PASSIVE_SCAN)\n\t\tcmd.host_command_parameters[0] |= IPW_SCAN_PASSIVE;\n\n\tcmd.host_command_parameters[1] = priv->channel_mask;\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tIPW_DEBUG_HC(\"SET_SCAN_OPTIONS 0x%04X\\n\",\n\t\t     cmd.host_command_parameters[0]);\n\n\treturn err;\n}\n\nstatic int ipw2100_start_scan(struct ipw2100_priv *priv)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = BROADCAST_SCAN,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4\n\t};\n\tint err;\n\n\tIPW_DEBUG_HC(\"START_SCAN\\n\");\n\n\tcmd.host_command_parameters[0] = 0;\n\n\t/* No scanning if in monitor mode */\n\tif (priv->ieee->iw_mode == IW_MODE_MONITOR)\n\t\treturn 1;\n\n\tif (priv->status & STATUS_SCANNING) {\n\t\tIPW_DEBUG_SCAN(\"Scan requested while already in scan...\\n\");\n\t\treturn 0;\n\t}\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\t/* Not clearing here; doing so makes iwlist always return nothing...\n\t *\n\t * We should modify the table logic to use aging tables vs. clearing\n\t * the table on each scan start.\n\t */\n\tIPW_DEBUG_SCAN(\"starting scan\\n\");\n\n\tpriv->status |= STATUS_SCANNING;\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err)\n\t\tpriv->status &= ~STATUS_SCANNING;\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\n\treturn err;\n}\n\nstatic const struct libipw_geo ipw_geos[] = {\n\t{\t\t\t/* Restricted */\n\t \"---\",\n\t .bg_channels = 14,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}, {2467, 12},\n\t\t{2472, 13}, {2484, 14}},\n\t },\n};\n\nstatic int ipw2100_up(struct ipw2100_priv *priv, int deferred)\n{\n\tunsigned long flags;\n\tint err = 0;\n\tu32 lock;\n\tu32 ord_len = sizeof(lock);\n\n\t/* Age scan list entries found before suspend */\n\tif (priv->suspend_time) {\n\t\tlibipw_networks_age(priv->ieee, priv->suspend_time);\n\t\tpriv->suspend_time = 0;\n\t}\n\n\t/* Quiet if manually disabled. */\n\tif (priv->status & STATUS_RF_KILL_SW) {\n\t\tIPW_DEBUG_INFO(\"%s: Radio is disabled by Manual Disable \"\n\t\t\t       \"switch\\n\", priv->net_dev->name);\n\t\treturn 0;\n\t}\n\n\t/* the ipw2100 hardware really doesn't want power management delays\n\t * longer than 175usec\n\t */\n\tcpu_latency_qos_update_request(&ipw2100_pm_qos_req, 175);\n\n\t/* If the interrupt is enabled, turn it off... */\n\tspin_lock_irqsave(&priv->low_lock, flags);\n\tipw2100_disable_interrupts(priv);\n\n\t/* Reset any fatal_error conditions */\n\tipw2100_reset_fatalerror(priv);\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\n\tif (priv->status & STATUS_POWERED ||\n\t    (priv->status & STATUS_RESET_PENDING)) {\n\t\t/* Power cycle the card ... */\n\t\terr = ipw2100_power_cycle_adapter(priv);\n\t\tif (err) {\n\t\t\tprintk(KERN_WARNING DRV_NAME\n\t\t\t       \": %s: Could not cycle adapter.\\n\",\n\t\t\t       priv->net_dev->name);\n\t\t\tgoto exit;\n\t\t}\n\t} else\n\t\tpriv->status |= STATUS_POWERED;\n\n\t/* Load the firmware, start the clocks, etc. */\n\terr = ipw2100_start_adapter(priv);\n\tif (err) {\n\t\tprintk(KERN_ERR DRV_NAME\n\t\t       \": %s: Failed to start the firmware.\\n\",\n\t\t       priv->net_dev->name);\n\t\tgoto exit;\n\t}\n\n\tipw2100_initialize_ordinals(priv);\n\n\t/* Determine capabilities of this particular HW configuration */\n\terr = ipw2100_get_hw_features(priv);\n\tif (err) {\n\t\tprintk(KERN_ERR DRV_NAME\n\t\t       \": %s: Failed to determine HW features.\\n\",\n\t\t       priv->net_dev->name);\n\t\tgoto exit;\n\t}\n\n\t/* Initialize the geo */\n\tlibipw_set_geo(priv->ieee, &ipw_geos[0]);\n\tpriv->ieee->freq_band = LIBIPW_24GHZ_BAND;\n\n\tlock = LOCK_NONE;\n\terr = ipw2100_set_ordinal(priv, IPW_ORD_PERS_DB_LOCK, &lock, &ord_len);\n\tif (err) {\n\t\tprintk(KERN_ERR DRV_NAME\n\t\t       \": %s: Failed to clear ordinal lock.\\n\",\n\t\t       priv->net_dev->name);\n\t\tgoto exit;\n\t}\n\n\tpriv->status &= ~STATUS_SCANNING;\n\n\tif (rf_kill_active(priv)) {\n\t\tprintk(KERN_INFO \"%s: Radio is disabled by RF switch.\\n\",\n\t\t       priv->net_dev->name);\n\n\t\tif (priv->stop_rf_kill) {\n\t\t\tpriv->stop_rf_kill = 0;\n\t\t\tschedule_delayed_work(&priv->rf_kill,\n\t\t\t\t\t      round_jiffies_relative(HZ));\n\t\t}\n\n\t\tdeferred = 1;\n\t}\n\n\t/* Turn on the interrupt so that commands can be processed */\n\tipw2100_enable_interrupts(priv);\n\n\t/* Send all of the commands that must be sent prior to\n\t * HOST_COMPLETE */\n\terr = ipw2100_adapter_setup(priv);\n\tif (err) {\n\t\tprintk(KERN_ERR DRV_NAME \": %s: Failed to start the card.\\n\",\n\t\t       priv->net_dev->name);\n\t\tgoto exit;\n\t}\n\n\tif (!deferred) {\n\t\t/* Enable the adapter - sends HOST_COMPLETE */\n\t\terr = ipw2100_enable_adapter(priv);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR DRV_NAME \": \"\n\t\t\t       \"%s: failed in call to enable adapter.\\n\",\n\t\t\t       priv->net_dev->name);\n\t\t\tipw2100_hw_stop_adapter(priv);\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* Start a scan . . . */\n\t\tipw2100_set_scan_options(priv);\n\t\tipw2100_start_scan(priv);\n\t}\n\n      exit:\n\treturn err;\n}\n\nstatic void ipw2100_down(struct ipw2100_priv *priv)\n{\n\tunsigned long flags;\n\tunion iwreq_data wrqu = {\n\t\t.ap_addr = {\n\t\t\t    .sa_family = ARPHRD_ETHER}\n\t};\n\tint associated = priv->status & STATUS_ASSOCIATED;\n\n\t/* Kill the RF switch timer */\n\tif (!priv->stop_rf_kill) {\n\t\tpriv->stop_rf_kill = 1;\n\t\tcancel_delayed_work(&priv->rf_kill);\n\t}\n\n\t/* Kill the firmware hang check timer */\n\tif (!priv->stop_hang_check) {\n\t\tpriv->stop_hang_check = 1;\n\t\tcancel_delayed_work(&priv->hang_check);\n\t}\n\n\t/* Kill any pending resets */\n\tif (priv->status & STATUS_RESET_PENDING)\n\t\tcancel_delayed_work(&priv->reset_work);\n\n\t/* Make sure the interrupt is on so that FW commands will be\n\t * processed correctly */\n\tspin_lock_irqsave(&priv->low_lock, flags);\n\tipw2100_enable_interrupts(priv);\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\n\tif (ipw2100_hw_stop_adapter(priv))\n\t\tprintk(KERN_ERR DRV_NAME \": %s: Error stopping adapter.\\n\",\n\t\t       priv->net_dev->name);\n\n\t/* Do not disable the interrupt until _after_ we disable\n\t * the adaptor.  Otherwise the CARD_DISABLE command will never\n\t * be ack'd by the firmware */\n\tspin_lock_irqsave(&priv->low_lock, flags);\n\tipw2100_disable_interrupts(priv);\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\n\tcpu_latency_qos_update_request(&ipw2100_pm_qos_req,\n\t\t\t\t       PM_QOS_DEFAULT_VALUE);\n\n\t/* We have to signal any supplicant if we are disassociating */\n\tif (associated)\n\t\twireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);\n\n\tpriv->status &= ~(STATUS_ASSOCIATED | STATUS_ASSOCIATING);\n\tnetif_carrier_off(priv->net_dev);\n\tnetif_stop_queue(priv->net_dev);\n}\n\nstatic int ipw2100_wdev_init(struct net_device *dev)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\n\tstruct wireless_dev *wdev = &priv->ieee->wdev;\n\tint i;\n\n\tmemcpy(wdev->wiphy->perm_addr, priv->mac_addr, ETH_ALEN);\n\n\t/* fill-out priv->ieee->bg_band */\n\tif (geo->bg_channels) {\n\t\tstruct ieee80211_supported_band *bg_band = &priv->ieee->bg_band;\n\n\t\tbg_band->band = NL80211_BAND_2GHZ;\n\t\tbg_band->n_channels = geo->bg_channels;\n\t\tbg_band->channels = kcalloc(geo->bg_channels,\n\t\t\t\t\t    sizeof(struct ieee80211_channel),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!bg_band->channels) {\n\t\t\tipw2100_down(priv);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t/* translate geo->bg to bg_band.channels */\n\t\tfor (i = 0; i < geo->bg_channels; i++) {\n\t\t\tbg_band->channels[i].band = NL80211_BAND_2GHZ;\n\t\t\tbg_band->channels[i].center_freq = geo->bg[i].freq;\n\t\t\tbg_band->channels[i].hw_value = geo->bg[i].channel;\n\t\t\tbg_band->channels[i].max_power = geo->bg[i].max_power;\n\t\t\tif (geo->bg[i].flags & LIBIPW_CH_PASSIVE_ONLY)\n\t\t\t\tbg_band->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_NO_IR;\n\t\t\tif (geo->bg[i].flags & LIBIPW_CH_NO_IBSS)\n\t\t\t\tbg_band->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_NO_IR;\n\t\t\tif (geo->bg[i].flags & LIBIPW_CH_RADAR_DETECT)\n\t\t\t\tbg_band->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_RADAR;\n\t\t\t/* No equivalent for LIBIPW_CH_80211H_RULES,\n\t\t\t   LIBIPW_CH_UNIFORM_SPREADING, or\n\t\t\t   LIBIPW_CH_B_ONLY... */\n\t\t}\n\t\t/* point at bitrate info */\n\t\tbg_band->bitrates = ipw2100_bg_rates;\n\t\tbg_band->n_bitrates = RATE_COUNT;\n\n\t\twdev->wiphy->bands[NL80211_BAND_2GHZ] = bg_band;\n\t}\n\n\twdev->wiphy->cipher_suites = ipw_cipher_suites;\n\twdev->wiphy->n_cipher_suites = ARRAY_SIZE(ipw_cipher_suites);\n\n\tset_wiphy_dev(wdev->wiphy, &priv->pci_dev->dev);\n\tif (wiphy_register(wdev->wiphy))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic void ipw2100_reset_adapter(struct work_struct *work)\n{\n\tstruct ipw2100_priv *priv =\n\t\tcontainer_of(work, struct ipw2100_priv, reset_work.work);\n\tunsigned long flags;\n\tunion iwreq_data wrqu = {\n\t\t.ap_addr = {\n\t\t\t    .sa_family = ARPHRD_ETHER}\n\t};\n\tint associated = priv->status & STATUS_ASSOCIATED;\n\n\tspin_lock_irqsave(&priv->low_lock, flags);\n\tIPW_DEBUG_INFO(\": %s: Restarting adapter.\\n\", priv->net_dev->name);\n\tpriv->resets++;\n\tpriv->status &= ~(STATUS_ASSOCIATED | STATUS_ASSOCIATING);\n\tpriv->status |= STATUS_SECURITY_UPDATED;\n\n\t/* Force a power cycle even if interface hasn't been opened\n\t * yet */\n\tcancel_delayed_work(&priv->reset_work);\n\tpriv->status |= STATUS_RESET_PENDING;\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\n\tmutex_lock(&priv->action_mutex);\n\t/* stop timed checks so that they don't interfere with reset */\n\tpriv->stop_hang_check = 1;\n\tcancel_delayed_work(&priv->hang_check);\n\n\t/* We have to signal any supplicant if we are disassociating */\n\tif (associated)\n\t\twireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);\n\n\tipw2100_up(priv, 0);\n\tmutex_unlock(&priv->action_mutex);\n\n}\n\nstatic void isr_indicate_associated(struct ipw2100_priv *priv, u32 status)\n{\n\n#define MAC_ASSOCIATION_READ_DELAY (HZ)\n\tint ret;\n\tunsigned int len, essid_len;\n\tchar essid[IW_ESSID_MAX_SIZE];\n\tu32 txrate;\n\tu32 chan;\n\tchar *txratename;\n\tu8 bssid[ETH_ALEN];\n\n\t/*\n\t * TBD: BSSID is usually 00:00:00:00:00:00 here and not\n\t *      an actual MAC of the AP. Seems like FW sets this\n\t *      address too late. Read it later and expose through\n\t *      /proc or schedule a later task to query and update\n\t */\n\n\tessid_len = IW_ESSID_MAX_SIZE;\n\tret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_SSID,\n\t\t\t\t  essid, &essid_len);\n\tif (ret) {\n\t\tIPW_DEBUG_INFO(\"failed querying ordinals at line %d\\n\",\n\t\t\t       __LINE__);\n\t\treturn;\n\t}\n\n\tlen = sizeof(u32);\n\tret = ipw2100_get_ordinal(priv, IPW_ORD_CURRENT_TX_RATE, &txrate, &len);\n\tif (ret) {\n\t\tIPW_DEBUG_INFO(\"failed querying ordinals at line %d\\n\",\n\t\t\t       __LINE__);\n\t\treturn;\n\t}\n\n\tlen = sizeof(u32);\n\tret = ipw2100_get_ordinal(priv, IPW_ORD_OUR_FREQ, &chan, &len);\n\tif (ret) {\n\t\tIPW_DEBUG_INFO(\"failed querying ordinals at line %d\\n\",\n\t\t\t       __LINE__);\n\t\treturn;\n\t}\n\tlen = ETH_ALEN;\n\tret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_AP_BSSID, bssid,\n\t\t\t\t  &len);\n\tif (ret) {\n\t\tIPW_DEBUG_INFO(\"failed querying ordinals at line %d\\n\",\n\t\t\t       __LINE__);\n\t\treturn;\n\t}\n\tmemcpy(priv->ieee->bssid, bssid, ETH_ALEN);\n\n\tswitch (txrate) {\n\tcase TX_RATE_1_MBIT:\n\t\ttxratename = \"1Mbps\";\n\t\tbreak;\n\tcase TX_RATE_2_MBIT:\n\t\ttxratename = \"2Mbsp\";\n\t\tbreak;\n\tcase TX_RATE_5_5_MBIT:\n\t\ttxratename = \"5.5Mbps\";\n\t\tbreak;\n\tcase TX_RATE_11_MBIT:\n\t\ttxratename = \"11Mbps\";\n\t\tbreak;\n\tdefault:\n\t\tIPW_DEBUG_INFO(\"Unknown rate: %d\\n\", txrate);\n\t\ttxratename = \"unknown rate\";\n\t\tbreak;\n\t}\n\n\tIPW_DEBUG_INFO(\"%s: Associated with '%*pE' at %s, channel %d (BSSID=%pM)\\n\",\n\t\t       priv->net_dev->name, essid_len, essid,\n\t\t       txratename, chan, bssid);\n\n\t/* now we copy read ssid into dev */\n\tif (!(priv->config & CFG_STATIC_ESSID)) {\n\t\tpriv->essid_len = min((u8) essid_len, (u8) IW_ESSID_MAX_SIZE);\n\t\tmemcpy(priv->essid, essid, priv->essid_len);\n\t}\n\tpriv->channel = chan;\n\tmemcpy(priv->bssid, bssid, ETH_ALEN);\n\n\tpriv->status |= STATUS_ASSOCIATING;\n\tpriv->connect_start = ktime_get_boottime_seconds();\n\n\tschedule_delayed_work(&priv->wx_event_work, HZ / 10);\n}\n\nstatic int ipw2100_set_essid(struct ipw2100_priv *priv, char *essid,\n\t\t\t     int length, int batch_mode)\n{\n\tint ssid_len = min(length, IW_ESSID_MAX_SIZE);\n\tstruct host_command cmd = {\n\t\t.host_command = SSID,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = ssid_len\n\t};\n\tint err;\n\n\tIPW_DEBUG_HC(\"SSID: '%*pE'\\n\", ssid_len, essid);\n\n\tif (ssid_len)\n\t\tmemcpy(cmd.host_command_parameters, essid, ssid_len);\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* Bug in FW currently doesn't honor bit 0 in SET_SCAN_OPTIONS to\n\t * disable auto association -- so we cheat by setting a bogus SSID */\n\tif (!ssid_len && !(priv->config & CFG_ASSOCIATE)) {\n\t\tint i;\n\t\tu8 *bogus = (u8 *) cmd.host_command_parameters;\n\t\tfor (i = 0; i < IW_ESSID_MAX_SIZE; i++)\n\t\t\tbogus[i] = 0x18 + i;\n\t\tcmd.host_command_length = IW_ESSID_MAX_SIZE;\n\t}\n\n\t/* NOTE:  We always send the SSID command even if the provided ESSID is\n\t * the same as what we currently think is set. */\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (!err) {\n\t\tmemset(priv->essid + ssid_len, 0, IW_ESSID_MAX_SIZE - ssid_len);\n\t\tmemcpy(priv->essid, essid, ssid_len);\n\t\tpriv->essid_len = ssid_len;\n\t}\n\n\tif (!batch_mode) {\n\t\tif (ipw2100_enable_adapter(priv))\n\t\t\terr = -EIO;\n\t}\n\n\treturn err;\n}\n\nstatic void isr_indicate_association_lost(struct ipw2100_priv *priv, u32 status)\n{\n\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE | IPW_DL_ASSOC,\n\t\t  \"disassociated: '%*pE' %pM\\n\", priv->essid_len, priv->essid,\n\t\t  priv->bssid);\n\n\tpriv->status &= ~(STATUS_ASSOCIATED | STATUS_ASSOCIATING);\n\n\tif (priv->status & STATUS_STOPPING) {\n\t\tIPW_DEBUG_INFO(\"Card is stopping itself, discard ASSN_LOST.\\n\");\n\t\treturn;\n\t}\n\n\teth_zero_addr(priv->bssid);\n\teth_zero_addr(priv->ieee->bssid);\n\n\tnetif_carrier_off(priv->net_dev);\n\tnetif_stop_queue(priv->net_dev);\n\n\tif (!(priv->status & STATUS_RUNNING))\n\t\treturn;\n\n\tif (priv->status & STATUS_SECURITY_UPDATED)\n\t\tschedule_delayed_work(&priv->security_work, 0);\n\n\tschedule_delayed_work(&priv->wx_event_work, 0);\n}\n\nstatic void isr_indicate_rf_kill(struct ipw2100_priv *priv, u32 status)\n{\n\tIPW_DEBUG_INFO(\"%s: RF Kill state changed to radio OFF.\\n\",\n\t\t       priv->net_dev->name);\n\n\t/* RF_KILL is now enabled (else we wouldn't be here) */\n\twiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, true);\n\tpriv->status |= STATUS_RF_KILL_HW;\n\n\t/* Make sure the RF Kill check timer is running */\n\tpriv->stop_rf_kill = 0;\n\tmod_delayed_work(system_wq, &priv->rf_kill, round_jiffies_relative(HZ));\n}\n\nstatic void ipw2100_scan_event(struct work_struct *work)\n{\n\tstruct ipw2100_priv *priv = container_of(work, struct ipw2100_priv,\n\t\t\t\t\t\t scan_event.work);\n\tunion iwreq_data wrqu;\n\n\twrqu.data.length = 0;\n\twrqu.data.flags = 0;\n\twireless_send_event(priv->net_dev, SIOCGIWSCAN, &wrqu, NULL);\n}\n\nstatic void isr_scan_complete(struct ipw2100_priv *priv, u32 status)\n{\n\tIPW_DEBUG_SCAN(\"scan complete\\n\");\n\t/* Age the scan results... */\n\tpriv->ieee->scans++;\n\tpriv->status &= ~STATUS_SCANNING;\n\n\t/* Only userspace-requested scan completion events go out immediately */\n\tif (!priv->user_requested_scan) {\n\t\tschedule_delayed_work(&priv->scan_event,\n\t\t\t\t      round_jiffies_relative(msecs_to_jiffies(4000)));\n\t} else {\n\t\tpriv->user_requested_scan = 0;\n\t\tmod_delayed_work(system_wq, &priv->scan_event, 0);\n\t}\n}\n\n#ifdef CONFIG_IPW2100_DEBUG\n#define IPW2100_HANDLER(v, f) { v, f, # v }\nstruct ipw2100_status_indicator {\n\tint status;\n\tvoid (*cb) (struct ipw2100_priv * priv, u32 status);\n\tchar *name;\n};\n#else\n#define IPW2100_HANDLER(v, f) { v, f }\nstruct ipw2100_status_indicator {\n\tint status;\n\tvoid (*cb) (struct ipw2100_priv * priv, u32 status);\n};\n#endif\t\t\t\t/* CONFIG_IPW2100_DEBUG */\n\nstatic void isr_indicate_scanning(struct ipw2100_priv *priv, u32 status)\n{\n\tIPW_DEBUG_SCAN(\"Scanning...\\n\");\n\tpriv->status |= STATUS_SCANNING;\n}\n\nstatic const struct ipw2100_status_indicator status_handlers[] = {\n\tIPW2100_HANDLER(IPW_STATE_INITIALIZED, NULL),\n\tIPW2100_HANDLER(IPW_STATE_COUNTRY_FOUND, NULL),\n\tIPW2100_HANDLER(IPW_STATE_ASSOCIATED, isr_indicate_associated),\n\tIPW2100_HANDLER(IPW_STATE_ASSN_LOST, isr_indicate_association_lost),\n\tIPW2100_HANDLER(IPW_STATE_ASSN_CHANGED, NULL),\n\tIPW2100_HANDLER(IPW_STATE_SCAN_COMPLETE, isr_scan_complete),\n\tIPW2100_HANDLER(IPW_STATE_ENTERED_PSP, NULL),\n\tIPW2100_HANDLER(IPW_STATE_LEFT_PSP, NULL),\n\tIPW2100_HANDLER(IPW_STATE_RF_KILL, isr_indicate_rf_kill),\n\tIPW2100_HANDLER(IPW_STATE_DISABLED, NULL),\n\tIPW2100_HANDLER(IPW_STATE_POWER_DOWN, NULL),\n\tIPW2100_HANDLER(IPW_STATE_SCANNING, isr_indicate_scanning),\n\tIPW2100_HANDLER(-1, NULL)\n};\n\nstatic void isr_status_change(struct ipw2100_priv *priv, int status)\n{\n\tint i;\n\n\tif (status == IPW_STATE_SCANNING &&\n\t    priv->status & STATUS_ASSOCIATED &&\n\t    !(priv->status & STATUS_SCANNING)) {\n\t\tIPW_DEBUG_INFO(\"Scan detected while associated, with \"\n\t\t\t       \"no scan request.  Restarting firmware.\\n\");\n\n\t\t/* Wake up any sleeping jobs */\n\t\tschedule_reset(priv);\n\t}\n\n\tfor (i = 0; status_handlers[i].status != -1; i++) {\n\t\tif (status == status_handlers[i].status) {\n\t\t\tIPW_DEBUG_NOTIF(\"Status change: %s\\n\",\n\t\t\t\t\tstatus_handlers[i].name);\n\t\t\tif (status_handlers[i].cb)\n\t\t\t\tstatus_handlers[i].cb(priv, status);\n\t\t\tpriv->wstats.status = status;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tIPW_DEBUG_NOTIF(\"unknown status received: %04x\\n\", status);\n}\n\nstatic void isr_rx_complete_command(struct ipw2100_priv *priv,\n\t\t\t\t    struct ipw2100_cmd_header *cmd)\n{\n#ifdef CONFIG_IPW2100_DEBUG\n\tif (cmd->host_command_reg < ARRAY_SIZE(command_types)) {\n\t\tIPW_DEBUG_HC(\"Command completed '%s (%d)'\\n\",\n\t\t\t     command_types[cmd->host_command_reg],\n\t\t\t     cmd->host_command_reg);\n\t}\n#endif\n\tif (cmd->host_command_reg == HOST_COMPLETE)\n\t\tpriv->status |= STATUS_ENABLED;\n\n\tif (cmd->host_command_reg == CARD_DISABLE)\n\t\tpriv->status &= ~STATUS_ENABLED;\n\n\tpriv->status &= ~STATUS_CMD_ACTIVE;\n\n\twake_up_interruptible(&priv->wait_command_queue);\n}\n\n#ifdef CONFIG_IPW2100_DEBUG\nstatic const char *frame_types[] = {\n\t\"COMMAND_STATUS_VAL\",\n\t\"STATUS_CHANGE_VAL\",\n\t\"P80211_DATA_VAL\",\n\t\"P8023_DATA_VAL\",\n\t\"HOST_NOTIFICATION_VAL\"\n};\n#endif\n\nstatic int ipw2100_alloc_skb(struct ipw2100_priv *priv,\n\t\t\t\t    struct ipw2100_rx_packet *packet)\n{\n\tpacket->skb = dev_alloc_skb(sizeof(struct ipw2100_rx));\n\tif (!packet->skb)\n\t\treturn -ENOMEM;\n\n\tpacket->rxp = (struct ipw2100_rx *)packet->skb->data;\n\tpacket->dma_addr = dma_map_single(&priv->pci_dev->dev,\n\t\t\t\t\t  packet->skb->data,\n\t\t\t\t\t  sizeof(struct ipw2100_rx),\n\t\t\t\t\t  DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&priv->pci_dev->dev, packet->dma_addr)) {\n\t\tdev_kfree_skb(packet->skb);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n#define SEARCH_ERROR   0xffffffff\n#define SEARCH_FAIL    0xfffffffe\n#define SEARCH_SUCCESS 0xfffffff0\n#define SEARCH_DISCARD 0\n#define SEARCH_SNAPSHOT 1\n\n#define SNAPSHOT_ADDR(ofs) (priv->snapshot[((ofs) >> 12) & 0xff] + ((ofs) & 0xfff))\nstatic void ipw2100_snapshot_free(struct ipw2100_priv *priv)\n{\n\tint i;\n\tif (!priv->snapshot[0])\n\t\treturn;\n\tfor (i = 0; i < 0x30; i++)\n\t\tkfree(priv->snapshot[i]);\n\tpriv->snapshot[0] = NULL;\n}\n\n#ifdef IPW2100_DEBUG_C3\nstatic int ipw2100_snapshot_alloc(struct ipw2100_priv *priv)\n{\n\tint i;\n\tif (priv->snapshot[0])\n\t\treturn 1;\n\tfor (i = 0; i < 0x30; i++) {\n\t\tpriv->snapshot[i] = kmalloc(0x1000, GFP_ATOMIC);\n\t\tif (!priv->snapshot[i]) {\n\t\t\tIPW_DEBUG_INFO(\"%s: Error allocating snapshot \"\n\t\t\t\t       \"buffer %d\\n\", priv->net_dev->name, i);\n\t\t\twhile (i > 0)\n\t\t\t\tkfree(priv->snapshot[--i]);\n\t\t\tpriv->snapshot[0] = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic u32 ipw2100_match_buf(struct ipw2100_priv *priv, u8 * in_buf,\n\t\t\t\t    size_t len, int mode)\n{\n\tu32 i, j;\n\tu32 tmp;\n\tu8 *s, *d;\n\tu32 ret;\n\n\ts = in_buf;\n\tif (mode == SEARCH_SNAPSHOT) {\n\t\tif (!ipw2100_snapshot_alloc(priv))\n\t\t\tmode = SEARCH_DISCARD;\n\t}\n\n\tfor (ret = SEARCH_FAIL, i = 0; i < 0x30000; i += 4) {\n\t\tread_nic_dword(priv->net_dev, i, &tmp);\n\t\tif (mode == SEARCH_SNAPSHOT)\n\t\t\t*(u32 *) SNAPSHOT_ADDR(i) = tmp;\n\t\tif (ret == SEARCH_FAIL) {\n\t\t\td = (u8 *) & tmp;\n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\tif (*s != *d) {\n\t\t\t\t\ts = in_buf;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ts++;\n\t\t\t\td++;\n\n\t\t\t\tif ((s - in_buf) == len)\n\t\t\t\t\tret = (i + j) - len + 1;\n\t\t\t}\n\t\t} else if (mode == SEARCH_DISCARD)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n#endif\n\n/*\n *\n * 0) Disconnect the SKB from the firmware (just unmap)\n * 1) Pack the ETH header into the SKB\n * 2) Pass the SKB to the network stack\n *\n * When packet is provided by the firmware, it contains the following:\n *\n * .  libipw_hdr\n * .  libipw_snap_hdr\n *\n * The size of the constructed ethernet\n *\n */\n#ifdef IPW2100_RX_DEBUG\nstatic u8 packet_data[IPW_RX_NIC_BUFFER_LENGTH];\n#endif\n\nstatic void ipw2100_corruption_detected(struct ipw2100_priv *priv, int i)\n{\n#ifdef IPW2100_DEBUG_C3\n\tstruct ipw2100_status *status = &priv->status_queue.drv[i];\n\tu32 match, reg;\n\tint j;\n#endif\n\n\tIPW_DEBUG_INFO(\": PCI latency error detected at 0x%04zX.\\n\",\n\t\t       i * sizeof(struct ipw2100_status));\n\n#ifdef IPW2100_DEBUG_C3\n\t/* Halt the firmware so we can get a good image */\n\twrite_register(priv->net_dev, IPW_REG_RESET_REG,\n\t\t       IPW_AUX_HOST_RESET_REG_STOP_MASTER);\n\tj = 5;\n\tdo {\n\t\tudelay(IPW_WAIT_RESET_MASTER_ASSERT_COMPLETE_DELAY);\n\t\tread_register(priv->net_dev, IPW_REG_RESET_REG, &reg);\n\n\t\tif (reg & IPW_AUX_HOST_RESET_REG_MASTER_DISABLED)\n\t\t\tbreak;\n\t} while (j--);\n\n\tmatch = ipw2100_match_buf(priv, (u8 *) status,\n\t\t\t\t  sizeof(struct ipw2100_status),\n\t\t\t\t  SEARCH_SNAPSHOT);\n\tif (match < SEARCH_SUCCESS)\n\t\tIPW_DEBUG_INFO(\"%s: DMA status match in Firmware at \"\n\t\t\t       \"offset 0x%06X, length %d:\\n\",\n\t\t\t       priv->net_dev->name, match,\n\t\t\t       sizeof(struct ipw2100_status));\n\telse\n\t\tIPW_DEBUG_INFO(\"%s: No DMA status match in \"\n\t\t\t       \"Firmware.\\n\", priv->net_dev->name);\n\n\tprintk_buf((u8 *) priv->status_queue.drv,\n\t\t   sizeof(struct ipw2100_status) * RX_QUEUE_LENGTH);\n#endif\n\n\tpriv->fatal_error = IPW2100_ERR_C3_CORRUPTION;\n\tpriv->net_dev->stats.rx_errors++;\n\tschedule_reset(priv);\n}\n\nstatic void isr_rx(struct ipw2100_priv *priv, int i,\n\t\t\t  struct libipw_rx_stats *stats)\n{\n\tstruct net_device *dev = priv->net_dev;\n\tstruct ipw2100_status *status = &priv->status_queue.drv[i];\n\tstruct ipw2100_rx_packet *packet = &priv->rx_buffers[i];\n\n\tIPW_DEBUG_RX(\"Handler...\\n\");\n\n\tif (unlikely(status->frame_size > skb_tailroom(packet->skb))) {\n\t\tIPW_DEBUG_INFO(\"%s: frame_size (%u) > skb_tailroom (%u)!\"\n\t\t\t       \"  Dropping.\\n\",\n\t\t\t       dev->name,\n\t\t\t       status->frame_size, skb_tailroom(packet->skb));\n\t\tdev->stats.rx_errors++;\n\t\treturn;\n\t}\n\n\tif (unlikely(!netif_running(dev))) {\n\t\tdev->stats.rx_errors++;\n\t\tpriv->wstats.discard.misc++;\n\t\tIPW_DEBUG_DROP(\"Dropping packet while interface is not up.\\n\");\n\t\treturn;\n\t}\n\n\tif (unlikely(priv->ieee->iw_mode != IW_MODE_MONITOR &&\n\t\t     !(priv->status & STATUS_ASSOCIATED))) {\n\t\tIPW_DEBUG_DROP(\"Dropping packet while not associated.\\n\");\n\t\tpriv->wstats.discard.misc++;\n\t\treturn;\n\t}\n\n\tdma_unmap_single(&priv->pci_dev->dev, packet->dma_addr,\n\t\t\t sizeof(struct ipw2100_rx), DMA_FROM_DEVICE);\n\n\tskb_put(packet->skb, status->frame_size);\n\n#ifdef IPW2100_RX_DEBUG\n\t/* Make a copy of the frame so we can dump it to the logs if\n\t * libipw_rx fails */\n\tskb_copy_from_linear_data(packet->skb, packet_data,\n\t\t\t\t  min_t(u32, status->frame_size,\n\t\t\t\t\t     IPW_RX_NIC_BUFFER_LENGTH));\n#endif\n\n\tif (!libipw_rx(priv->ieee, packet->skb, stats)) {\n#ifdef IPW2100_RX_DEBUG\n\t\tIPW_DEBUG_DROP(\"%s: Non consumed packet:\\n\",\n\t\t\t       dev->name);\n\t\tprintk_buf(IPW_DL_DROP, packet_data, status->frame_size);\n#endif\n\t\tdev->stats.rx_errors++;\n\n\t\t/* libipw_rx failed, so it didn't free the SKB */\n\t\tdev_kfree_skb_any(packet->skb);\n\t\tpacket->skb = NULL;\n\t}\n\n\t/* We need to allocate a new SKB and attach it to the RDB. */\n\tif (unlikely(ipw2100_alloc_skb(priv, packet))) {\n\t\tprintk(KERN_WARNING DRV_NAME \": \"\n\t\t       \"%s: Unable to allocate SKB onto RBD ring - disabling \"\n\t\t       \"adapter.\\n\", dev->name);\n\t\t/* TODO: schedule adapter shutdown */\n\t\tIPW_DEBUG_INFO(\"TODO: Shutdown adapter...\\n\");\n\t}\n\n\t/* Update the RDB entry */\n\tpriv->rx_queue.drv[i].host_addr = packet->dma_addr;\n}\n\n#ifdef CONFIG_IPW2100_MONITOR\n\nstatic void isr_rx_monitor(struct ipw2100_priv *priv, int i,\n\t\t   struct libipw_rx_stats *stats)\n{\n\tstruct net_device *dev = priv->net_dev;\n\tstruct ipw2100_status *status = &priv->status_queue.drv[i];\n\tstruct ipw2100_rx_packet *packet = &priv->rx_buffers[i];\n\n\t/* Magic struct that slots into the radiotap header -- no reason\n\t * to build this manually element by element, we can write it much\n\t * more efficiently than we can parse it. ORDER MATTERS HERE */\n\tstruct ipw_rt_hdr {\n\t\tstruct ieee80211_radiotap_header rt_hdr;\n\t\ts8 rt_dbmsignal; /* signal in dbM, kluged to signed */\n\t} *ipw_rt;\n\n\tIPW_DEBUG_RX(\"Handler...\\n\");\n\n\tif (unlikely(status->frame_size > skb_tailroom(packet->skb) -\n\t\t\t\tsizeof(struct ipw_rt_hdr))) {\n\t\tIPW_DEBUG_INFO(\"%s: frame_size (%u) > skb_tailroom (%u)!\"\n\t\t\t       \"  Dropping.\\n\",\n\t\t\t       dev->name,\n\t\t\t       status->frame_size,\n\t\t\t       skb_tailroom(packet->skb));\n\t\tdev->stats.rx_errors++;\n\t\treturn;\n\t}\n\n\tif (unlikely(!netif_running(dev))) {\n\t\tdev->stats.rx_errors++;\n\t\tpriv->wstats.discard.misc++;\n\t\tIPW_DEBUG_DROP(\"Dropping packet while interface is not up.\\n\");\n\t\treturn;\n\t}\n\n\tif (unlikely(priv->config & CFG_CRC_CHECK &&\n\t\t     status->flags & IPW_STATUS_FLAG_CRC_ERROR)) {\n\t\tIPW_DEBUG_RX(\"CRC error in packet.  Dropping.\\n\");\n\t\tdev->stats.rx_errors++;\n\t\treturn;\n\t}\n\n\tdma_unmap_single(&priv->pci_dev->dev, packet->dma_addr,\n\t\t\t sizeof(struct ipw2100_rx), DMA_FROM_DEVICE);\n\tmemmove(packet->skb->data + sizeof(struct ipw_rt_hdr),\n\t\tpacket->skb->data, status->frame_size);\n\n\tipw_rt = (struct ipw_rt_hdr *) packet->skb->data;\n\n\tipw_rt->rt_hdr.it_version = PKTHDR_RADIOTAP_VERSION;\n\tipw_rt->rt_hdr.it_pad = 0; /* always good to zero */\n\tipw_rt->rt_hdr.it_len = cpu_to_le16(sizeof(struct ipw_rt_hdr)); /* total hdr+data */\n\n\tipw_rt->rt_hdr.it_present = cpu_to_le32(1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL);\n\n\tipw_rt->rt_dbmsignal = status->rssi + IPW2100_RSSI_TO_DBM;\n\n\tskb_put(packet->skb, status->frame_size + sizeof(struct ipw_rt_hdr));\n\n\tif (!libipw_rx(priv->ieee, packet->skb, stats)) {\n\t\tdev->stats.rx_errors++;\n\n\t\t/* libipw_rx failed, so it didn't free the SKB */\n\t\tdev_kfree_skb_any(packet->skb);\n\t\tpacket->skb = NULL;\n\t}\n\n\t/* We need to allocate a new SKB and attach it to the RDB. */\n\tif (unlikely(ipw2100_alloc_skb(priv, packet))) {\n\t\tIPW_DEBUG_WARNING(\n\t\t\t\"%s: Unable to allocate SKB onto RBD ring - disabling \"\n\t\t\t\"adapter.\\n\", dev->name);\n\t\t/* TODO: schedule adapter shutdown */\n\t\tIPW_DEBUG_INFO(\"TODO: Shutdown adapter...\\n\");\n\t}\n\n\t/* Update the RDB entry */\n\tpriv->rx_queue.drv[i].host_addr = packet->dma_addr;\n}\n\n#endif\n\nstatic int ipw2100_corruption_check(struct ipw2100_priv *priv, int i)\n{\n\tstruct ipw2100_status *status = &priv->status_queue.drv[i];\n\tstruct ipw2100_rx *u = priv->rx_buffers[i].rxp;\n\tu16 frame_type = status->status_fields & STATUS_TYPE_MASK;\n\n\tswitch (frame_type) {\n\tcase COMMAND_STATUS_VAL:\n\t\treturn (status->frame_size != sizeof(u->rx_data.command));\n\tcase STATUS_CHANGE_VAL:\n\t\treturn (status->frame_size != sizeof(u->rx_data.status));\n\tcase HOST_NOTIFICATION_VAL:\n\t\treturn (status->frame_size < sizeof(u->rx_data.notification));\n\tcase P80211_DATA_VAL:\n\tcase P8023_DATA_VAL:\n#ifdef CONFIG_IPW2100_MONITOR\n\t\treturn 0;\n#else\n\t\tswitch (WLAN_FC_GET_TYPE(le16_to_cpu(u->rx_data.header.frame_ctl))) {\n\t\tcase IEEE80211_FTYPE_MGMT:\n\t\tcase IEEE80211_FTYPE_CTL:\n\t\t\treturn 0;\n\t\tcase IEEE80211_FTYPE_DATA:\n\t\t\treturn (status->frame_size >\n\t\t\t\tIPW_MAX_802_11_PAYLOAD_LENGTH);\n\t\t}\n#endif\n\t}\n\n\treturn 1;\n}\n\n/*\n * ipw2100 interrupts are disabled at this point, and the ISR\n * is the only code that calls this method.  So, we do not need\n * to play with any locks.\n *\n * RX Queue works as follows:\n *\n * Read index - firmware places packet in entry identified by the\n *              Read index and advances Read index.  In this manner,\n *              Read index will always point to the next packet to\n *              be filled--but not yet valid.\n *\n * Write index - driver fills this entry with an unused RBD entry.\n *               This entry has not filled by the firmware yet.\n *\n * In between the W and R indexes are the RBDs that have been received\n * but not yet processed.\n *\n * The process of handling packets will start at WRITE + 1 and advance\n * until it reaches the READ index.\n *\n * The WRITE index is cached in the variable 'priv->rx_queue.next'.\n *\n */\nstatic void __ipw2100_rx_process(struct ipw2100_priv *priv)\n{\n\tstruct ipw2100_bd_queue *rxq = &priv->rx_queue;\n\tstruct ipw2100_status_queue *sq = &priv->status_queue;\n\tstruct ipw2100_rx_packet *packet;\n\tu16 frame_type;\n\tu32 r, w, i, s;\n\tstruct ipw2100_rx *u;\n\tstruct libipw_rx_stats stats = {\n\t\t.mac_time = jiffies,\n\t};\n\n\tread_register(priv->net_dev, IPW_MEM_HOST_SHARED_RX_READ_INDEX, &r);\n\tread_register(priv->net_dev, IPW_MEM_HOST_SHARED_RX_WRITE_INDEX, &w);\n\n\tif (r >= rxq->entries) {\n\t\tIPW_DEBUG_RX(\"exit - bad read index\\n\");\n\t\treturn;\n\t}\n\n\ti = (rxq->next + 1) % rxq->entries;\n\ts = i;\n\twhile (i != r) {\n\t\t/* IPW_DEBUG_RX(\"r = %d : w = %d : processing = %d\\n\",\n\t\t   r, rxq->next, i); */\n\n\t\tpacket = &priv->rx_buffers[i];\n\n\t\t/* Sync the DMA for the RX buffer so CPU is sure to get\n\t\t * the correct values */\n\t\tdma_sync_single_for_cpu(&priv->pci_dev->dev, packet->dma_addr,\n\t\t\t\t\tsizeof(struct ipw2100_rx),\n\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\tif (unlikely(ipw2100_corruption_check(priv, i))) {\n\t\t\tipw2100_corruption_detected(priv, i);\n\t\t\tgoto increment;\n\t\t}\n\n\t\tu = packet->rxp;\n\t\tframe_type = sq->drv[i].status_fields & STATUS_TYPE_MASK;\n\t\tstats.rssi = sq->drv[i].rssi + IPW2100_RSSI_TO_DBM;\n\t\tstats.len = sq->drv[i].frame_size;\n\n\t\tstats.mask = 0;\n\t\tif (stats.rssi != 0)\n\t\t\tstats.mask |= LIBIPW_STATMASK_RSSI;\n\t\tstats.freq = LIBIPW_24GHZ_BAND;\n\n\t\tIPW_DEBUG_RX(\"%s: '%s' frame type received (%d).\\n\",\n\t\t\t     priv->net_dev->name, frame_types[frame_type],\n\t\t\t     stats.len);\n\n\t\tswitch (frame_type) {\n\t\tcase COMMAND_STATUS_VAL:\n\t\t\t/* Reset Rx watchdog */\n\t\t\tisr_rx_complete_command(priv, &u->rx_data.command);\n\t\t\tbreak;\n\n\t\tcase STATUS_CHANGE_VAL:\n\t\t\tisr_status_change(priv, u->rx_data.status);\n\t\t\tbreak;\n\n\t\tcase P80211_DATA_VAL:\n\t\tcase P8023_DATA_VAL:\n#ifdef CONFIG_IPW2100_MONITOR\n\t\t\tif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\n\t\t\t\tisr_rx_monitor(priv, i, &stats);\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\tif (stats.len < sizeof(struct libipw_hdr_3addr))\n\t\t\t\tbreak;\n\t\t\tswitch (WLAN_FC_GET_TYPE(le16_to_cpu(u->rx_data.header.frame_ctl))) {\n\t\t\tcase IEEE80211_FTYPE_MGMT:\n\t\t\t\tlibipw_rx_mgt(priv->ieee,\n\t\t\t\t\t\t &u->rx_data.header, &stats);\n\t\t\t\tbreak;\n\n\t\t\tcase IEEE80211_FTYPE_CTL:\n\t\t\t\tbreak;\n\n\t\t\tcase IEEE80211_FTYPE_DATA:\n\t\t\t\tisr_rx(priv, i, &stats);\n\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t      increment:\n\t\t/* clear status field associated with this RBD */\n\t\trxq->drv[i].status.info.field = 0;\n\n\t\ti = (i + 1) % rxq->entries;\n\t}\n\n\tif (i != s) {\n\t\t/* backtrack one entry, wrapping to end if at 0 */\n\t\trxq->next = (i ? i : rxq->entries) - 1;\n\n\t\twrite_register(priv->net_dev,\n\t\t\t       IPW_MEM_HOST_SHARED_RX_WRITE_INDEX, rxq->next);\n\t}\n}\n\n/*\n * __ipw2100_tx_process\n *\n * This routine will determine whether the next packet on\n * the fw_pend_list has been processed by the firmware yet.\n *\n * If not, then it does nothing and returns.\n *\n * If so, then it removes the item from the fw_pend_list, frees\n * any associated storage, and places the item back on the\n * free list of its source (either msg_free_list or tx_free_list)\n *\n * TX Queue works as follows:\n *\n * Read index - points to the next TBD that the firmware will\n *              process.  The firmware will read the data, and once\n *              done processing, it will advance the Read index.\n *\n * Write index - driver fills this entry with an constructed TBD\n *               entry.  The Write index is not advanced until the\n *               packet has been configured.\n *\n * In between the W and R indexes are the TBDs that have NOT been\n * processed.  Lagging behind the R index are packets that have\n * been processed but have not been freed by the driver.\n *\n * In order to free old storage, an internal index will be maintained\n * that points to the next packet to be freed.  When all used\n * packets have been freed, the oldest index will be the same as the\n * firmware's read index.\n *\n * The OLDEST index is cached in the variable 'priv->tx_queue.oldest'\n *\n * Because the TBD structure can not contain arbitrary data, the\n * driver must keep an internal queue of cached allocations such that\n * it can put that data back into the tx_free_list and msg_free_list\n * for use by future command and data packets.\n *\n */\nstatic int __ipw2100_tx_process(struct ipw2100_priv *priv)\n{\n\tstruct ipw2100_bd_queue *txq = &priv->tx_queue;\n\tstruct ipw2100_bd *tbd;\n\tstruct list_head *element;\n\tstruct ipw2100_tx_packet *packet;\n\tint descriptors_used;\n\tint e, i;\n\tu32 r, w, frag_num = 0;\n\n\tif (list_empty(&priv->fw_pend_list))\n\t\treturn 0;\n\n\telement = priv->fw_pend_list.next;\n\n\tpacket = list_entry(element, struct ipw2100_tx_packet, list);\n\ttbd = &txq->drv[packet->index];\n\n\t/* Determine how many TBD entries must be finished... */\n\tswitch (packet->type) {\n\tcase COMMAND:\n\t\t/* COMMAND uses only one slot; don't advance */\n\t\tdescriptors_used = 1;\n\t\te = txq->oldest;\n\t\tbreak;\n\n\tcase DATA:\n\t\t/* DATA uses two slots; advance and loop position. */\n\t\tdescriptors_used = tbd->num_fragments;\n\t\tfrag_num = tbd->num_fragments - 1;\n\t\te = txq->oldest + frag_num;\n\t\te %= txq->entries;\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_WARNING DRV_NAME \": %s: Bad fw_pend_list entry!\\n\",\n\t\t       priv->net_dev->name);\n\t\treturn 0;\n\t}\n\n\t/* if the last TBD is not done by NIC yet, then packet is\n\t * not ready to be released.\n\t *\n\t */\n\tread_register(priv->net_dev, IPW_MEM_HOST_SHARED_TX_QUEUE_READ_INDEX,\n\t\t      &r);\n\tread_register(priv->net_dev, IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX,\n\t\t      &w);\n\tif (w != txq->next)\n\t\tprintk(KERN_WARNING DRV_NAME \": %s: write index mismatch\\n\",\n\t\t       priv->net_dev->name);\n\n\t/*\n\t * txq->next is the index of the last packet written txq->oldest is\n\t * the index of the r is the index of the next packet to be read by\n\t * firmware\n\t */\n\n\t/*\n\t * Quick graphic to help you visualize the following\n\t * if / else statement\n\t *\n\t * ===>|                     s---->|===============\n\t *                               e>|\n\t * | a | b | c | d | e | f | g | h | i | j | k | l\n\t *       r---->|\n\t *               w\n\t *\n\t * w - updated by driver\n\t * r - updated by firmware\n\t * s - start of oldest BD entry (txq->oldest)\n\t * e - end of oldest BD entry\n\t *\n\t */\n\tif (!((r <= w && (e < r || e >= w)) || (e < r && e >= w))) {\n\t\tIPW_DEBUG_TX(\"exit - no processed packets ready to release.\\n\");\n\t\treturn 0;\n\t}\n\n\tlist_del(element);\n\tDEC_STAT(&priv->fw_pend_stat);\n\n#ifdef CONFIG_IPW2100_DEBUG\n\t{\n\t\ti = txq->oldest;\n\t\tIPW_DEBUG_TX(\"TX%d V=%p P=%04X T=%04X L=%d\\n\", i,\n\t\t\t     &txq->drv[i],\n\t\t\t     (u32) (txq->nic + i * sizeof(struct ipw2100_bd)),\n\t\t\t     txq->drv[i].host_addr, txq->drv[i].buf_length);\n\n\t\tif (packet->type == DATA) {\n\t\t\ti = (i + 1) % txq->entries;\n\n\t\t\tIPW_DEBUG_TX(\"TX%d V=%p P=%04X T=%04X L=%d\\n\", i,\n\t\t\t\t     &txq->drv[i],\n\t\t\t\t     (u32) (txq->nic + i *\n\t\t\t\t\t    sizeof(struct ipw2100_bd)),\n\t\t\t\t     (u32) txq->drv[i].host_addr,\n\t\t\t\t     txq->drv[i].buf_length);\n\t\t}\n\t}\n#endif\n\n\tswitch (packet->type) {\n\tcase DATA:\n\t\tif (txq->drv[txq->oldest].status.info.fields.txType != 0)\n\t\t\tprintk(KERN_WARNING DRV_NAME \": %s: Queue mismatch.  \"\n\t\t\t       \"Expecting DATA TBD but pulled \"\n\t\t\t       \"something else: ids %d=%d.\\n\",\n\t\t\t       priv->net_dev->name, txq->oldest, packet->index);\n\n\t\t/* DATA packet; we have to unmap and free the SKB */\n\t\tfor (i = 0; i < frag_num; i++) {\n\t\t\ttbd = &txq->drv[(packet->index + 1 + i) % txq->entries];\n\n\t\t\tIPW_DEBUG_TX(\"TX%d P=%08x L=%d\\n\",\n\t\t\t\t     (packet->index + 1 + i) % txq->entries,\n\t\t\t\t     tbd->host_addr, tbd->buf_length);\n\n\t\t\tdma_unmap_single(&priv->pci_dev->dev, tbd->host_addr,\n\t\t\t\t\t tbd->buf_length, DMA_TO_DEVICE);\n\t\t}\n\n\t\tlibipw_txb_free(packet->info.d_struct.txb);\n\t\tpacket->info.d_struct.txb = NULL;\n\n\t\tlist_add_tail(element, &priv->tx_free_list);\n\t\tINC_STAT(&priv->tx_free_stat);\n\n\t\t/* We have a free slot in the Tx queue, so wake up the\n\t\t * transmit layer if it is stopped. */\n\t\tif (priv->status & STATUS_ASSOCIATED)\n\t\t\tnetif_wake_queue(priv->net_dev);\n\n\t\t/* A packet was processed by the hardware, so update the\n\t\t * watchdog */\n\t\tnetif_trans_update(priv->net_dev);\n\n\t\tbreak;\n\n\tcase COMMAND:\n\t\tif (txq->drv[txq->oldest].status.info.fields.txType != 1)\n\t\t\tprintk(KERN_WARNING DRV_NAME \": %s: Queue mismatch.  \"\n\t\t\t       \"Expecting COMMAND TBD but pulled \"\n\t\t\t       \"something else: ids %d=%d.\\n\",\n\t\t\t       priv->net_dev->name, txq->oldest, packet->index);\n\n#ifdef CONFIG_IPW2100_DEBUG\n\t\tif (packet->info.c_struct.cmd->host_command_reg <\n\t\t    ARRAY_SIZE(command_types))\n\t\t\tIPW_DEBUG_TX(\"Command '%s (%d)' processed: %d.\\n\",\n\t\t\t\t     command_types[packet->info.c_struct.cmd->\n\t\t\t\t\t\t   host_command_reg],\n\t\t\t\t     packet->info.c_struct.cmd->\n\t\t\t\t     host_command_reg,\n\t\t\t\t     packet->info.c_struct.cmd->cmd_status_reg);\n#endif\n\n\t\tlist_add_tail(element, &priv->msg_free_list);\n\t\tINC_STAT(&priv->msg_free_stat);\n\t\tbreak;\n\t}\n\n\t/* advance oldest used TBD pointer to start of next entry */\n\ttxq->oldest = (e + 1) % txq->entries;\n\t/* increase available TBDs number */\n\ttxq->available += descriptors_used;\n\tSET_STAT(&priv->txq_stat, txq->available);\n\n\tIPW_DEBUG_TX(\"packet latency (send to process)  %ld jiffies\\n\",\n\t\t     jiffies - packet->jiffy_start);\n\n\treturn (!list_empty(&priv->fw_pend_list));\n}\n\nstatic inline void __ipw2100_tx_complete(struct ipw2100_priv *priv)\n{\n\tint i = 0;\n\n\twhile (__ipw2100_tx_process(priv) && i < 200)\n\t\ti++;\n\n\tif (i == 200) {\n\t\tprintk(KERN_WARNING DRV_NAME \": \"\n\t\t       \"%s: Driver is running slow (%d iters).\\n\",\n\t\t       priv->net_dev->name, i);\n\t}\n}\n\nstatic void ipw2100_tx_send_commands(struct ipw2100_priv *priv)\n{\n\tstruct list_head *element;\n\tstruct ipw2100_tx_packet *packet;\n\tstruct ipw2100_bd_queue *txq = &priv->tx_queue;\n\tstruct ipw2100_bd *tbd;\n\tint next = txq->next;\n\n\twhile (!list_empty(&priv->msg_pend_list)) {\n\t\t/* if there isn't enough space in TBD queue, then\n\t\t * don't stuff a new one in.\n\t\t * NOTE: 3 are needed as a command will take one,\n\t\t *       and there is a minimum of 2 that must be\n\t\t *       maintained between the r and w indexes\n\t\t */\n\t\tif (txq->available <= 3) {\n\t\t\tIPW_DEBUG_TX(\"no room in tx_queue\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\telement = priv->msg_pend_list.next;\n\t\tlist_del(element);\n\t\tDEC_STAT(&priv->msg_pend_stat);\n\n\t\tpacket = list_entry(element, struct ipw2100_tx_packet, list);\n\n\t\tIPW_DEBUG_TX(\"using TBD at virt=%p, phys=%04X\\n\",\n\t\t\t     &txq->drv[txq->next],\n\t\t\t     (u32) (txq->nic + txq->next *\n\t\t\t\t      sizeof(struct ipw2100_bd)));\n\n\t\tpacket->index = txq->next;\n\n\t\ttbd = &txq->drv[txq->next];\n\n\t\t/* initialize TBD */\n\t\ttbd->host_addr = packet->info.c_struct.cmd_phys;\n\t\ttbd->buf_length = sizeof(struct ipw2100_cmd_header);\n\t\t/* not marking number of fragments causes problems\n\t\t * with f/w debug version */\n\t\ttbd->num_fragments = 1;\n\t\ttbd->status.info.field =\n\t\t    IPW_BD_STATUS_TX_FRAME_COMMAND |\n\t\t    IPW_BD_STATUS_TX_INTERRUPT_ENABLE;\n\n\t\t/* update TBD queue counters */\n\t\ttxq->next++;\n\t\ttxq->next %= txq->entries;\n\t\ttxq->available--;\n\t\tDEC_STAT(&priv->txq_stat);\n\n\t\tlist_add_tail(element, &priv->fw_pend_list);\n\t\tINC_STAT(&priv->fw_pend_stat);\n\t}\n\n\tif (txq->next != next) {\n\t\t/* kick off the DMA by notifying firmware the\n\t\t * write index has moved; make sure TBD stores are sync'd */\n\t\twmb();\n\t\twrite_register(priv->net_dev,\n\t\t\t       IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX,\n\t\t\t       txq->next);\n\t}\n}\n\n/*\n * ipw2100_tx_send_data\n *\n */\nstatic void ipw2100_tx_send_data(struct ipw2100_priv *priv)\n{\n\tstruct list_head *element;\n\tstruct ipw2100_tx_packet *packet;\n\tstruct ipw2100_bd_queue *txq = &priv->tx_queue;\n\tstruct ipw2100_bd *tbd;\n\tint next = txq->next;\n\tint i = 0;\n\tstruct ipw2100_data_header *ipw_hdr;\n\tstruct libipw_hdr_3addr *hdr;\n\n\twhile (!list_empty(&priv->tx_pend_list)) {\n\t\t/* if there isn't enough space in TBD queue, then\n\t\t * don't stuff a new one in.\n\t\t * NOTE: 4 are needed as a data will take two,\n\t\t *       and there is a minimum of 2 that must be\n\t\t *       maintained between the r and w indexes\n\t\t */\n\t\telement = priv->tx_pend_list.next;\n\t\tpacket = list_entry(element, struct ipw2100_tx_packet, list);\n\n\t\tif (unlikely(1 + packet->info.d_struct.txb->nr_frags >\n\t\t\t     IPW_MAX_BDS)) {\n\t\t\t/* TODO: Support merging buffers if more than\n\t\t\t * IPW_MAX_BDS are used */\n\t\t\tIPW_DEBUG_INFO(\"%s: Maximum BD threshold exceeded.  \"\n\t\t\t\t       \"Increase fragmentation level.\\n\",\n\t\t\t\t       priv->net_dev->name);\n\t\t}\n\n\t\tif (txq->available <= 3 + packet->info.d_struct.txb->nr_frags) {\n\t\t\tIPW_DEBUG_TX(\"no room in tx_queue\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_del(element);\n\t\tDEC_STAT(&priv->tx_pend_stat);\n\n\t\ttbd = &txq->drv[txq->next];\n\n\t\tpacket->index = txq->next;\n\n\t\tipw_hdr = packet->info.d_struct.data;\n\t\thdr = (struct libipw_hdr_3addr *)packet->info.d_struct.txb->\n\t\t    fragments[0]->data;\n\n\t\tif (priv->ieee->iw_mode == IW_MODE_INFRA) {\n\t\t\t/* To DS: Addr1 = BSSID, Addr2 = SA,\n\t\t\t   Addr3 = DA */\n\t\t\tmemcpy(ipw_hdr->src_addr, hdr->addr2, ETH_ALEN);\n\t\t\tmemcpy(ipw_hdr->dst_addr, hdr->addr3, ETH_ALEN);\n\t\t} else if (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\t\t/* not From/To DS: Addr1 = DA, Addr2 = SA,\n\t\t\t   Addr3 = BSSID */\n\t\t\tmemcpy(ipw_hdr->src_addr, hdr->addr2, ETH_ALEN);\n\t\t\tmemcpy(ipw_hdr->dst_addr, hdr->addr1, ETH_ALEN);\n\t\t}\n\n\t\tipw_hdr->host_command_reg = SEND;\n\t\tipw_hdr->host_command_reg1 = 0;\n\n\t\t/* For now we only support host based encryption */\n\t\tipw_hdr->needs_encryption = 0;\n\t\tipw_hdr->encrypted = packet->info.d_struct.txb->encrypted;\n\t\tif (packet->info.d_struct.txb->nr_frags > 1)\n\t\t\tipw_hdr->fragment_size =\n\t\t\t    packet->info.d_struct.txb->frag_size -\n\t\t\t    LIBIPW_3ADDR_LEN;\n\t\telse\n\t\t\tipw_hdr->fragment_size = 0;\n\n\t\ttbd->host_addr = packet->info.d_struct.data_phys;\n\t\ttbd->buf_length = sizeof(struct ipw2100_data_header);\n\t\ttbd->num_fragments = 1 + packet->info.d_struct.txb->nr_frags;\n\t\ttbd->status.info.field =\n\t\t    IPW_BD_STATUS_TX_FRAME_802_3 |\n\t\t    IPW_BD_STATUS_TX_FRAME_NOT_LAST_FRAGMENT;\n\t\ttxq->next++;\n\t\ttxq->next %= txq->entries;\n\n\t\tIPW_DEBUG_TX(\"data header tbd TX%d P=%08x L=%d\\n\",\n\t\t\t     packet->index, tbd->host_addr, tbd->buf_length);\n#ifdef CONFIG_IPW2100_DEBUG\n\t\tif (packet->info.d_struct.txb->nr_frags > 1)\n\t\t\tIPW_DEBUG_FRAG(\"fragment Tx: %d frames\\n\",\n\t\t\t\t       packet->info.d_struct.txb->nr_frags);\n#endif\n\n\t\tfor (i = 0; i < packet->info.d_struct.txb->nr_frags; i++) {\n\t\t\ttbd = &txq->drv[txq->next];\n\t\t\tif (i == packet->info.d_struct.txb->nr_frags - 1)\n\t\t\t\ttbd->status.info.field =\n\t\t\t\t    IPW_BD_STATUS_TX_FRAME_802_3 |\n\t\t\t\t    IPW_BD_STATUS_TX_INTERRUPT_ENABLE;\n\t\t\telse\n\t\t\t\ttbd->status.info.field =\n\t\t\t\t    IPW_BD_STATUS_TX_FRAME_802_3 |\n\t\t\t\t    IPW_BD_STATUS_TX_FRAME_NOT_LAST_FRAGMENT;\n\n\t\t\ttbd->buf_length = packet->info.d_struct.txb->\n\t\t\t    fragments[i]->len - LIBIPW_3ADDR_LEN;\n\n\t\t\ttbd->host_addr = dma_map_single(&priv->pci_dev->dev,\n\t\t\t\t\t\t\tpacket->info.d_struct.\n\t\t\t\t\t\t\ttxb->fragments[i]->data +\n\t\t\t\t\t\t\tLIBIPW_3ADDR_LEN,\n\t\t\t\t\t\t\ttbd->buf_length,\n\t\t\t\t\t\t\tDMA_TO_DEVICE);\n\t\t\tif (dma_mapping_error(&priv->pci_dev->dev, tbd->host_addr)) {\n\t\t\t\tIPW_DEBUG_TX(\"dma mapping error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tIPW_DEBUG_TX(\"data frag tbd TX%d P=%08x L=%d\\n\",\n\t\t\t\t     txq->next, tbd->host_addr,\n\t\t\t\t     tbd->buf_length);\n\n\t\t\tdma_sync_single_for_device(&priv->pci_dev->dev,\n\t\t\t\t\t\t   tbd->host_addr,\n\t\t\t\t\t\t   tbd->buf_length,\n\t\t\t\t\t\t   DMA_TO_DEVICE);\n\n\t\t\ttxq->next++;\n\t\t\ttxq->next %= txq->entries;\n\t\t}\n\n\t\ttxq->available -= 1 + packet->info.d_struct.txb->nr_frags;\n\t\tSET_STAT(&priv->txq_stat, txq->available);\n\n\t\tlist_add_tail(element, &priv->fw_pend_list);\n\t\tINC_STAT(&priv->fw_pend_stat);\n\t}\n\n\tif (txq->next != next) {\n\t\t/* kick off the DMA by notifying firmware the\n\t\t * write index has moved; make sure TBD stores are sync'd */\n\t\twrite_register(priv->net_dev,\n\t\t\t       IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX,\n\t\t\t       txq->next);\n\t}\n}\n\nstatic void ipw2100_irq_tasklet(struct tasklet_struct *t)\n{\n\tstruct ipw2100_priv *priv = from_tasklet(priv, t, irq_tasklet);\n\tstruct net_device *dev = priv->net_dev;\n\tunsigned long flags;\n\tu32 inta, tmp;\n\n\tspin_lock_irqsave(&priv->low_lock, flags);\n\tipw2100_disable_interrupts(priv);\n\n\tread_register(dev, IPW_REG_INTA, &inta);\n\n\tIPW_DEBUG_ISR(\"enter - INTA: 0x%08lX\\n\",\n\t\t      (unsigned long)inta & IPW_INTERRUPT_MASK);\n\n\tpriv->in_isr++;\n\tpriv->interrupts++;\n\n\t/* We do not loop and keep polling for more interrupts as this\n\t * is frowned upon and doesn't play nicely with other potentially\n\t * chained IRQs */\n\tIPW_DEBUG_ISR(\"INTA: 0x%08lX\\n\",\n\t\t      (unsigned long)inta & IPW_INTERRUPT_MASK);\n\n\tif (inta & IPW2100_INTA_FATAL_ERROR) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \": Fatal interrupt. Scheduling firmware restart.\\n\");\n\t\tpriv->inta_other++;\n\t\twrite_register(dev, IPW_REG_INTA, IPW2100_INTA_FATAL_ERROR);\n\n\t\tread_nic_dword(dev, IPW_NIC_FATAL_ERROR, &priv->fatal_error);\n\t\tIPW_DEBUG_INFO(\"%s: Fatal error value: 0x%08X\\n\",\n\t\t\t       priv->net_dev->name, priv->fatal_error);\n\n\t\tread_nic_dword(dev, IPW_ERROR_ADDR(priv->fatal_error), &tmp);\n\t\tIPW_DEBUG_INFO(\"%s: Fatal error address value: 0x%08X\\n\",\n\t\t\t       priv->net_dev->name, tmp);\n\n\t\t/* Wake up any sleeping jobs */\n\t\tschedule_reset(priv);\n\t}\n\n\tif (inta & IPW2100_INTA_PARITY_ERROR) {\n\t\tprintk(KERN_ERR DRV_NAME\n\t\t       \": ***** PARITY ERROR INTERRUPT !!!!\\n\");\n\t\tpriv->inta_other++;\n\t\twrite_register(dev, IPW_REG_INTA, IPW2100_INTA_PARITY_ERROR);\n\t}\n\n\tif (inta & IPW2100_INTA_RX_TRANSFER) {\n\t\tIPW_DEBUG_ISR(\"RX interrupt\\n\");\n\n\t\tpriv->rx_interrupts++;\n\n\t\twrite_register(dev, IPW_REG_INTA, IPW2100_INTA_RX_TRANSFER);\n\n\t\t__ipw2100_rx_process(priv);\n\t\t__ipw2100_tx_complete(priv);\n\t}\n\n\tif (inta & IPW2100_INTA_TX_TRANSFER) {\n\t\tIPW_DEBUG_ISR(\"TX interrupt\\n\");\n\n\t\tpriv->tx_interrupts++;\n\n\t\twrite_register(dev, IPW_REG_INTA, IPW2100_INTA_TX_TRANSFER);\n\n\t\t__ipw2100_tx_complete(priv);\n\t\tipw2100_tx_send_commands(priv);\n\t\tipw2100_tx_send_data(priv);\n\t}\n\n\tif (inta & IPW2100_INTA_TX_COMPLETE) {\n\t\tIPW_DEBUG_ISR(\"TX complete\\n\");\n\t\tpriv->inta_other++;\n\t\twrite_register(dev, IPW_REG_INTA, IPW2100_INTA_TX_COMPLETE);\n\n\t\t__ipw2100_tx_complete(priv);\n\t}\n\n\tif (inta & IPW2100_INTA_EVENT_INTERRUPT) {\n\t\t/* ipw2100_handle_event(dev); */\n\t\tpriv->inta_other++;\n\t\twrite_register(dev, IPW_REG_INTA, IPW2100_INTA_EVENT_INTERRUPT);\n\t}\n\n\tif (inta & IPW2100_INTA_FW_INIT_DONE) {\n\t\tIPW_DEBUG_ISR(\"FW init done interrupt\\n\");\n\t\tpriv->inta_other++;\n\n\t\tread_register(dev, IPW_REG_INTA, &tmp);\n\t\tif (tmp & (IPW2100_INTA_FATAL_ERROR |\n\t\t\t   IPW2100_INTA_PARITY_ERROR)) {\n\t\t\twrite_register(dev, IPW_REG_INTA,\n\t\t\t\t       IPW2100_INTA_FATAL_ERROR |\n\t\t\t\t       IPW2100_INTA_PARITY_ERROR);\n\t\t}\n\n\t\twrite_register(dev, IPW_REG_INTA, IPW2100_INTA_FW_INIT_DONE);\n\t}\n\n\tif (inta & IPW2100_INTA_STATUS_CHANGE) {\n\t\tIPW_DEBUG_ISR(\"Status change interrupt\\n\");\n\t\tpriv->inta_other++;\n\t\twrite_register(dev, IPW_REG_INTA, IPW2100_INTA_STATUS_CHANGE);\n\t}\n\n\tif (inta & IPW2100_INTA_SLAVE_MODE_HOST_COMMAND_DONE) {\n\t\tIPW_DEBUG_ISR(\"slave host mode interrupt\\n\");\n\t\tpriv->inta_other++;\n\t\twrite_register(dev, IPW_REG_INTA,\n\t\t\t       IPW2100_INTA_SLAVE_MODE_HOST_COMMAND_DONE);\n\t}\n\n\tpriv->in_isr--;\n\tipw2100_enable_interrupts(priv);\n\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\n\tIPW_DEBUG_ISR(\"exit\\n\");\n}\n\nstatic irqreturn_t ipw2100_interrupt(int irq, void *data)\n{\n\tstruct ipw2100_priv *priv = data;\n\tu32 inta, inta_mask;\n\n\tif (!data)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&priv->low_lock);\n\n\t/* We check to see if we should be ignoring interrupts before\n\t * we touch the hardware.  During ucode load if we try and handle\n\t * an interrupt we can cause keyboard problems as well as cause\n\t * the ucode to fail to initialize */\n\tif (!(priv->status & STATUS_INT_ENABLED)) {\n\t\t/* Shared IRQ */\n\t\tgoto none;\n\t}\n\n\tread_register(priv->net_dev, IPW_REG_INTA_MASK, &inta_mask);\n\tread_register(priv->net_dev, IPW_REG_INTA, &inta);\n\n\tif (inta == 0xFFFFFFFF) {\n\t\t/* Hardware disappeared */\n\t\tprintk(KERN_WARNING DRV_NAME \": IRQ INTA == 0xFFFFFFFF\\n\");\n\t\tgoto none;\n\t}\n\n\tinta &= IPW_INTERRUPT_MASK;\n\n\tif (!(inta & inta_mask)) {\n\t\t/* Shared interrupt */\n\t\tgoto none;\n\t}\n\n\t/* We disable the hardware interrupt here just to prevent unneeded\n\t * calls to be made.  We disable this again within the actual\n\t * work tasklet, so if another part of the code re-enables the\n\t * interrupt, that is fine */\n\tipw2100_disable_interrupts(priv);\n\n\ttasklet_schedule(&priv->irq_tasklet);\n\tspin_unlock(&priv->low_lock);\n\n\treturn IRQ_HANDLED;\n      none:\n\tspin_unlock(&priv->low_lock);\n\treturn IRQ_NONE;\n}\n\nstatic netdev_tx_t ipw2100_tx(struct libipw_txb *txb,\n\t\t\t      struct net_device *dev, int pri)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct list_head *element;\n\tstruct ipw2100_tx_packet *packet;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->low_lock, flags);\n\n\tif (!(priv->status & STATUS_ASSOCIATED)) {\n\t\tIPW_DEBUG_INFO(\"Can not transmit when not connected.\\n\");\n\t\tpriv->net_dev->stats.tx_carrier_errors++;\n\t\tnetif_stop_queue(dev);\n\t\tgoto fail_unlock;\n\t}\n\n\tif (list_empty(&priv->tx_free_list))\n\t\tgoto fail_unlock;\n\n\telement = priv->tx_free_list.next;\n\tpacket = list_entry(element, struct ipw2100_tx_packet, list);\n\n\tpacket->info.d_struct.txb = txb;\n\n\tIPW_DEBUG_TX(\"Sending fragment (%d bytes):\\n\", txb->fragments[0]->len);\n\tprintk_buf(IPW_DL_TX, txb->fragments[0]->data, txb->fragments[0]->len);\n\n\tpacket->jiffy_start = jiffies;\n\n\tlist_del(element);\n\tDEC_STAT(&priv->tx_free_stat);\n\n\tlist_add_tail(element, &priv->tx_pend_list);\n\tINC_STAT(&priv->tx_pend_stat);\n\n\tipw2100_tx_send_data(priv);\n\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\treturn NETDEV_TX_OK;\n\nfail_unlock:\n\tnetif_stop_queue(dev);\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\treturn NETDEV_TX_BUSY;\n}\n\nstatic int ipw2100_msg_allocate(struct ipw2100_priv *priv)\n{\n\tint i, j, err = -EINVAL;\n\tvoid *v;\n\tdma_addr_t p;\n\n\tpriv->msg_buffers =\n\t    kmalloc_array(IPW_COMMAND_POOL_SIZE,\n\t\t\t  sizeof(struct ipw2100_tx_packet),\n\t\t\t  GFP_KERNEL);\n\tif (!priv->msg_buffers)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < IPW_COMMAND_POOL_SIZE; i++) {\n\t\tv = dma_alloc_coherent(&priv->pci_dev->dev,\n\t\t\t\t       sizeof(struct ipw2100_cmd_header), &p,\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!v) {\n\t\t\tprintk(KERN_ERR DRV_NAME \": \"\n\t\t\t       \"%s: PCI alloc failed for msg \"\n\t\t\t       \"buffers.\\n\", priv->net_dev->name);\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tpriv->msg_buffers[i].type = COMMAND;\n\t\tpriv->msg_buffers[i].info.c_struct.cmd =\n\t\t    (struct ipw2100_cmd_header *)v;\n\t\tpriv->msg_buffers[i].info.c_struct.cmd_phys = p;\n\t}\n\n\tif (i == IPW_COMMAND_POOL_SIZE)\n\t\treturn 0;\n\n\tfor (j = 0; j < i; j++) {\n\t\tdma_free_coherent(&priv->pci_dev->dev,\n\t\t\t\t  sizeof(struct ipw2100_cmd_header),\n\t\t\t\t  priv->msg_buffers[j].info.c_struct.cmd,\n\t\t\t\t  priv->msg_buffers[j].info.c_struct.cmd_phys);\n\t}\n\n\tkfree(priv->msg_buffers);\n\tpriv->msg_buffers = NULL;\n\n\treturn err;\n}\n\nstatic int ipw2100_msg_initialize(struct ipw2100_priv *priv)\n{\n\tint i;\n\n\tINIT_LIST_HEAD(&priv->msg_free_list);\n\tINIT_LIST_HEAD(&priv->msg_pend_list);\n\n\tfor (i = 0; i < IPW_COMMAND_POOL_SIZE; i++)\n\t\tlist_add_tail(&priv->msg_buffers[i].list, &priv->msg_free_list);\n\tSET_STAT(&priv->msg_free_stat, i);\n\n\treturn 0;\n}\n\nstatic void ipw2100_msg_free(struct ipw2100_priv *priv)\n{\n\tint i;\n\n\tif (!priv->msg_buffers)\n\t\treturn;\n\n\tfor (i = 0; i < IPW_COMMAND_POOL_SIZE; i++) {\n\t\tdma_free_coherent(&priv->pci_dev->dev,\n\t\t\t\t  sizeof(struct ipw2100_cmd_header),\n\t\t\t\t  priv->msg_buffers[i].info.c_struct.cmd,\n\t\t\t\t  priv->msg_buffers[i].info.c_struct.cmd_phys);\n\t}\n\n\tkfree(priv->msg_buffers);\n\tpriv->msg_buffers = NULL;\n}\n\nstatic ssize_t show_pci(struct device *d, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(d);\n\tchar *out = buf;\n\tint i, j;\n\tu32 val;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tout += sprintf(out, \"[%08X] \", i * 16);\n\t\tfor (j = 0; j < 16; j += 4) {\n\t\t\tpci_read_config_dword(pci_dev, i * 16 + j, &val);\n\t\t\tout += sprintf(out, \"%08X \", val);\n\t\t}\n\t\tout += sprintf(out, \"\\n\");\n\t}\n\n\treturn out - buf;\n}\n\nstatic DEVICE_ATTR(pci, 0444, show_pci, NULL);\n\nstatic ssize_t show_cfg(struct device *d, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct ipw2100_priv *p = dev_get_drvdata(d);\n\treturn sprintf(buf, \"0x%08x\\n\", (int)p->config);\n}\n\nstatic DEVICE_ATTR(cfg, 0444, show_cfg, NULL);\n\nstatic ssize_t show_status(struct device *d, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct ipw2100_priv *p = dev_get_drvdata(d);\n\treturn sprintf(buf, \"0x%08x\\n\", (int)p->status);\n}\n\nstatic DEVICE_ATTR(status, 0444, show_status, NULL);\n\nstatic ssize_t show_capability(struct device *d, struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct ipw2100_priv *p = dev_get_drvdata(d);\n\treturn sprintf(buf, \"0x%08x\\n\", (int)p->capability);\n}\n\nstatic DEVICE_ATTR(capability, 0444, show_capability, NULL);\n\n#define IPW2100_REG(x) { IPW_ ##x, #x }\nstatic const struct {\n\tu32 addr;\n\tconst char *name;\n} hw_data[] = {\nIPW2100_REG(REG_GP_CNTRL),\n\t    IPW2100_REG(REG_GPIO),\n\t    IPW2100_REG(REG_INTA),\n\t    IPW2100_REG(REG_INTA_MASK), IPW2100_REG(REG_RESET_REG),};\n#define IPW2100_NIC(x, s) { x, #x, s }\nstatic const struct {\n\tu32 addr;\n\tconst char *name;\n\tsize_t size;\n} nic_data[] = {\nIPW2100_NIC(IPW2100_CONTROL_REG, 2),\n\t    IPW2100_NIC(0x210014, 1), IPW2100_NIC(0x210000, 1),};\n#define IPW2100_ORD(x, d) { IPW_ORD_ ##x, #x, d }\nstatic const struct {\n\tu8 index;\n\tconst char *name;\n\tconst char *desc;\n} ord_data[] = {\nIPW2100_ORD(STAT_TX_HOST_REQUESTS, \"requested Host Tx's (MSDU)\"),\n\t    IPW2100_ORD(STAT_TX_HOST_COMPLETE,\n\t\t\t\t\"successful Host Tx's (MSDU)\"),\n\t    IPW2100_ORD(STAT_TX_DIR_DATA,\n\t\t\t\t\"successful Directed Tx's (MSDU)\"),\n\t    IPW2100_ORD(STAT_TX_DIR_DATA1,\n\t\t\t\t\"successful Directed Tx's (MSDU) @ 1MB\"),\n\t    IPW2100_ORD(STAT_TX_DIR_DATA2,\n\t\t\t\t\"successful Directed Tx's (MSDU) @ 2MB\"),\n\t    IPW2100_ORD(STAT_TX_DIR_DATA5_5,\n\t\t\t\t\"successful Directed Tx's (MSDU) @ 5_5MB\"),\n\t    IPW2100_ORD(STAT_TX_DIR_DATA11,\n\t\t\t\t\"successful Directed Tx's (MSDU) @ 11MB\"),\n\t    IPW2100_ORD(STAT_TX_NODIR_DATA1,\n\t\t\t\t\"successful Non_Directed Tx's (MSDU) @ 1MB\"),\n\t    IPW2100_ORD(STAT_TX_NODIR_DATA2,\n\t\t\t\t\"successful Non_Directed Tx's (MSDU) @ 2MB\"),\n\t    IPW2100_ORD(STAT_TX_NODIR_DATA5_5,\n\t\t\t\t\"successful Non_Directed Tx's (MSDU) @ 5.5MB\"),\n\t    IPW2100_ORD(STAT_TX_NODIR_DATA11,\n\t\t\t\t\"successful Non_Directed Tx's (MSDU) @ 11MB\"),\n\t    IPW2100_ORD(STAT_NULL_DATA, \"successful NULL data Tx's\"),\n\t    IPW2100_ORD(STAT_TX_RTS, \"successful Tx RTS\"),\n\t    IPW2100_ORD(STAT_TX_CTS, \"successful Tx CTS\"),\n\t    IPW2100_ORD(STAT_TX_ACK, \"successful Tx ACK\"),\n\t    IPW2100_ORD(STAT_TX_ASSN, \"successful Association Tx's\"),\n\t    IPW2100_ORD(STAT_TX_ASSN_RESP,\n\t\t\t\t\"successful Association response Tx's\"),\n\t    IPW2100_ORD(STAT_TX_REASSN,\n\t\t\t\t\"successful Reassociation Tx's\"),\n\t    IPW2100_ORD(STAT_TX_REASSN_RESP,\n\t\t\t\t\"successful Reassociation response Tx's\"),\n\t    IPW2100_ORD(STAT_TX_PROBE,\n\t\t\t\t\"probes successfully transmitted\"),\n\t    IPW2100_ORD(STAT_TX_PROBE_RESP,\n\t\t\t\t\"probe responses successfully transmitted\"),\n\t    IPW2100_ORD(STAT_TX_BEACON, \"tx beacon\"),\n\t    IPW2100_ORD(STAT_TX_ATIM, \"Tx ATIM\"),\n\t    IPW2100_ORD(STAT_TX_DISASSN,\n\t\t\t\t\"successful Disassociation TX\"),\n\t    IPW2100_ORD(STAT_TX_AUTH, \"successful Authentication Tx\"),\n\t    IPW2100_ORD(STAT_TX_DEAUTH,\n\t\t\t\t\"successful Deauthentication TX\"),\n\t    IPW2100_ORD(STAT_TX_TOTAL_BYTES,\n\t\t\t\t\"Total successful Tx data bytes\"),\n\t    IPW2100_ORD(STAT_TX_RETRIES, \"Tx retries\"),\n\t    IPW2100_ORD(STAT_TX_RETRY1, \"Tx retries at 1MBPS\"),\n\t    IPW2100_ORD(STAT_TX_RETRY2, \"Tx retries at 2MBPS\"),\n\t    IPW2100_ORD(STAT_TX_RETRY5_5, \"Tx retries at 5.5MBPS\"),\n\t    IPW2100_ORD(STAT_TX_RETRY11, \"Tx retries at 11MBPS\"),\n\t    IPW2100_ORD(STAT_TX_FAILURES, \"Tx Failures\"),\n\t    IPW2100_ORD(STAT_TX_MAX_TRIES_IN_HOP,\n\t\t\t\t\"times max tries in a hop failed\"),\n\t    IPW2100_ORD(STAT_TX_DISASSN_FAIL,\n\t\t\t\t\"times disassociation failed\"),\n\t    IPW2100_ORD(STAT_TX_ERR_CTS, \"missed/bad CTS frames\"),\n\t    IPW2100_ORD(STAT_TX_ERR_ACK, \"tx err due to acks\"),\n\t    IPW2100_ORD(STAT_RX_HOST, \"packets passed to host\"),\n\t    IPW2100_ORD(STAT_RX_DIR_DATA, \"directed packets\"),\n\t    IPW2100_ORD(STAT_RX_DIR_DATA1, \"directed packets at 1MB\"),\n\t    IPW2100_ORD(STAT_RX_DIR_DATA2, \"directed packets at 2MB\"),\n\t    IPW2100_ORD(STAT_RX_DIR_DATA5_5,\n\t\t\t\t\"directed packets at 5.5MB\"),\n\t    IPW2100_ORD(STAT_RX_DIR_DATA11, \"directed packets at 11MB\"),\n\t    IPW2100_ORD(STAT_RX_NODIR_DATA, \"nondirected packets\"),\n\t    IPW2100_ORD(STAT_RX_NODIR_DATA1,\n\t\t\t\t\"nondirected packets at 1MB\"),\n\t    IPW2100_ORD(STAT_RX_NODIR_DATA2,\n\t\t\t\t\"nondirected packets at 2MB\"),\n\t    IPW2100_ORD(STAT_RX_NODIR_DATA5_5,\n\t\t\t\t\"nondirected packets at 5.5MB\"),\n\t    IPW2100_ORD(STAT_RX_NODIR_DATA11,\n\t\t\t\t\"nondirected packets at 11MB\"),\n\t    IPW2100_ORD(STAT_RX_NULL_DATA, \"null data rx's\"),\n\t    IPW2100_ORD(STAT_RX_RTS, \"Rx RTS\"), IPW2100_ORD(STAT_RX_CTS,\n\t\t\t\t\t\t\t\t    \"Rx CTS\"),\n\t    IPW2100_ORD(STAT_RX_ACK, \"Rx ACK\"),\n\t    IPW2100_ORD(STAT_RX_CFEND, \"Rx CF End\"),\n\t    IPW2100_ORD(STAT_RX_CFEND_ACK, \"Rx CF End + CF Ack\"),\n\t    IPW2100_ORD(STAT_RX_ASSN, \"Association Rx's\"),\n\t    IPW2100_ORD(STAT_RX_ASSN_RESP, \"Association response Rx's\"),\n\t    IPW2100_ORD(STAT_RX_REASSN, \"Reassociation Rx's\"),\n\t    IPW2100_ORD(STAT_RX_REASSN_RESP,\n\t\t\t\t\"Reassociation response Rx's\"),\n\t    IPW2100_ORD(STAT_RX_PROBE, \"probe Rx's\"),\n\t    IPW2100_ORD(STAT_RX_PROBE_RESP, \"probe response Rx's\"),\n\t    IPW2100_ORD(STAT_RX_BEACON, \"Rx beacon\"),\n\t    IPW2100_ORD(STAT_RX_ATIM, \"Rx ATIM\"),\n\t    IPW2100_ORD(STAT_RX_DISASSN, \"disassociation Rx\"),\n\t    IPW2100_ORD(STAT_RX_AUTH, \"authentication Rx\"),\n\t    IPW2100_ORD(STAT_RX_DEAUTH, \"deauthentication Rx\"),\n\t    IPW2100_ORD(STAT_RX_TOTAL_BYTES,\n\t\t\t\t\"Total rx data bytes received\"),\n\t    IPW2100_ORD(STAT_RX_ERR_CRC, \"packets with Rx CRC error\"),\n\t    IPW2100_ORD(STAT_RX_ERR_CRC1, \"Rx CRC errors at 1MB\"),\n\t    IPW2100_ORD(STAT_RX_ERR_CRC2, \"Rx CRC errors at 2MB\"),\n\t    IPW2100_ORD(STAT_RX_ERR_CRC5_5, \"Rx CRC errors at 5.5MB\"),\n\t    IPW2100_ORD(STAT_RX_ERR_CRC11, \"Rx CRC errors at 11MB\"),\n\t    IPW2100_ORD(STAT_RX_DUPLICATE1,\n\t\t\t\t\"duplicate rx packets at 1MB\"),\n\t    IPW2100_ORD(STAT_RX_DUPLICATE2,\n\t\t\t\t\"duplicate rx packets at 2MB\"),\n\t    IPW2100_ORD(STAT_RX_DUPLICATE5_5,\n\t\t\t\t\"duplicate rx packets at 5.5MB\"),\n\t    IPW2100_ORD(STAT_RX_DUPLICATE11,\n\t\t\t\t\"duplicate rx packets at 11MB\"),\n\t    IPW2100_ORD(STAT_RX_DUPLICATE, \"duplicate rx packets\"),\n\t    IPW2100_ORD(PERS_DB_LOCK, \"locking fw permanent  db\"),\n\t    IPW2100_ORD(PERS_DB_SIZE, \"size of fw permanent  db\"),\n\t    IPW2100_ORD(PERS_DB_ADDR, \"address of fw permanent  db\"),\n\t    IPW2100_ORD(STAT_RX_INVALID_PROTOCOL,\n\t\t\t\t\"rx frames with invalid protocol\"),\n\t    IPW2100_ORD(SYS_BOOT_TIME, \"Boot time\"),\n\t    IPW2100_ORD(STAT_RX_NO_BUFFER,\n\t\t\t\t\"rx frames rejected due to no buffer\"),\n\t    IPW2100_ORD(STAT_RX_MISSING_FRAG,\n\t\t\t\t\"rx frames dropped due to missing fragment\"),\n\t    IPW2100_ORD(STAT_RX_ORPHAN_FRAG,\n\t\t\t\t\"rx frames dropped due to non-sequential fragment\"),\n\t    IPW2100_ORD(STAT_RX_ORPHAN_FRAME,\n\t\t\t\t\"rx frames dropped due to unmatched 1st frame\"),\n\t    IPW2100_ORD(STAT_RX_FRAG_AGEOUT,\n\t\t\t\t\"rx frames dropped due to uncompleted frame\"),\n\t    IPW2100_ORD(STAT_RX_ICV_ERRORS,\n\t\t\t\t\"ICV errors during decryption\"),\n\t    IPW2100_ORD(STAT_PSP_SUSPENSION, \"times adapter suspended\"),\n\t    IPW2100_ORD(STAT_PSP_BCN_TIMEOUT, \"beacon timeout\"),\n\t    IPW2100_ORD(STAT_PSP_POLL_TIMEOUT,\n\t\t\t\t\"poll response timeouts\"),\n\t    IPW2100_ORD(STAT_PSP_NONDIR_TIMEOUT,\n\t\t\t\t\"timeouts waiting for last {broad,multi}cast pkt\"),\n\t    IPW2100_ORD(STAT_PSP_RX_DTIMS, \"PSP DTIMs received\"),\n\t    IPW2100_ORD(STAT_PSP_RX_TIMS, \"PSP TIMs received\"),\n\t    IPW2100_ORD(STAT_PSP_STATION_ID, \"PSP Station ID\"),\n\t    IPW2100_ORD(LAST_ASSN_TIME, \"RTC time of last association\"),\n\t    IPW2100_ORD(STAT_PERCENT_MISSED_BCNS,\n\t\t\t\t\"current calculation of % missed beacons\"),\n\t    IPW2100_ORD(STAT_PERCENT_RETRIES,\n\t\t\t\t\"current calculation of % missed tx retries\"),\n\t    IPW2100_ORD(ASSOCIATED_AP_PTR,\n\t\t\t\t\"0 if not associated, else pointer to AP table entry\"),\n\t    IPW2100_ORD(AVAILABLE_AP_CNT,\n\t\t\t\t\"AP's described in the AP table\"),\n\t    IPW2100_ORD(AP_LIST_PTR, \"Ptr to list of available APs\"),\n\t    IPW2100_ORD(STAT_AP_ASSNS, \"associations\"),\n\t    IPW2100_ORD(STAT_ASSN_FAIL, \"association failures\"),\n\t    IPW2100_ORD(STAT_ASSN_RESP_FAIL,\n\t\t\t\t\"failures due to response fail\"),\n\t    IPW2100_ORD(STAT_FULL_SCANS, \"full scans\"),\n\t    IPW2100_ORD(CARD_DISABLED, \"Card Disabled\"),\n\t    IPW2100_ORD(STAT_ROAM_INHIBIT,\n\t\t\t\t\"times roaming was inhibited due to activity\"),\n\t    IPW2100_ORD(RSSI_AT_ASSN,\n\t\t\t\t\"RSSI of associated AP at time of association\"),\n\t    IPW2100_ORD(STAT_ASSN_CAUSE1,\n\t\t\t\t\"reassociation: no probe response or TX on hop\"),\n\t    IPW2100_ORD(STAT_ASSN_CAUSE2,\n\t\t\t\t\"reassociation: poor tx/rx quality\"),\n\t    IPW2100_ORD(STAT_ASSN_CAUSE3,\n\t\t\t\t\"reassociation: tx/rx quality (excessive AP load\"),\n\t    IPW2100_ORD(STAT_ASSN_CAUSE4,\n\t\t\t\t\"reassociation: AP RSSI level\"),\n\t    IPW2100_ORD(STAT_ASSN_CAUSE5,\n\t\t\t\t\"reassociations due to load leveling\"),\n\t    IPW2100_ORD(STAT_AUTH_FAIL, \"times authentication failed\"),\n\t    IPW2100_ORD(STAT_AUTH_RESP_FAIL,\n\t\t\t\t\"times authentication response failed\"),\n\t    IPW2100_ORD(STATION_TABLE_CNT,\n\t\t\t\t\"entries in association table\"),\n\t    IPW2100_ORD(RSSI_AVG_CURR, \"Current avg RSSI\"),\n\t    IPW2100_ORD(POWER_MGMT_MODE, \"Power mode - 0=CAM, 1=PSP\"),\n\t    IPW2100_ORD(COUNTRY_CODE,\n\t\t\t\t\"IEEE country code as recv'd from beacon\"),\n\t    IPW2100_ORD(COUNTRY_CHANNELS,\n\t\t\t\t\"channels supported by country\"),\n\t    IPW2100_ORD(RESET_CNT, \"adapter resets (warm)\"),\n\t    IPW2100_ORD(BEACON_INTERVAL, \"Beacon interval\"),\n\t    IPW2100_ORD(ANTENNA_DIVERSITY,\n\t\t\t\t\"TRUE if antenna diversity is disabled\"),\n\t    IPW2100_ORD(DTIM_PERIOD, \"beacon intervals between DTIMs\"),\n\t    IPW2100_ORD(OUR_FREQ,\n\t\t\t\t\"current radio freq lower digits - channel ID\"),\n\t    IPW2100_ORD(RTC_TIME, \"current RTC time\"),\n\t    IPW2100_ORD(PORT_TYPE, \"operating mode\"),\n\t    IPW2100_ORD(CURRENT_TX_RATE, \"current tx rate\"),\n\t    IPW2100_ORD(SUPPORTED_RATES, \"supported tx rates\"),\n\t    IPW2100_ORD(ATIM_WINDOW, \"current ATIM Window\"),\n\t    IPW2100_ORD(BASIC_RATES, \"basic tx rates\"),\n\t    IPW2100_ORD(NIC_HIGHEST_RATE, \"NIC highest tx rate\"),\n\t    IPW2100_ORD(AP_HIGHEST_RATE, \"AP highest tx rate\"),\n\t    IPW2100_ORD(CAPABILITIES,\n\t\t\t\t\"Management frame capability field\"),\n\t    IPW2100_ORD(AUTH_TYPE, \"Type of authentication\"),\n\t    IPW2100_ORD(RADIO_TYPE, \"Adapter card platform type\"),\n\t    IPW2100_ORD(RTS_THRESHOLD,\n\t\t\t\t\"Min packet length for RTS handshaking\"),\n\t    IPW2100_ORD(INT_MODE, \"International mode\"),\n\t    IPW2100_ORD(FRAGMENTATION_THRESHOLD,\n\t\t\t\t\"protocol frag threshold\"),\n\t    IPW2100_ORD(EEPROM_SRAM_DB_BLOCK_START_ADDRESS,\n\t\t\t\t\"EEPROM offset in SRAM\"),\n\t    IPW2100_ORD(EEPROM_SRAM_DB_BLOCK_SIZE,\n\t\t\t\t\"EEPROM size in SRAM\"),\n\t    IPW2100_ORD(EEPROM_SKU_CAPABILITY, \"EEPROM SKU Capability\"),\n\t    IPW2100_ORD(EEPROM_IBSS_11B_CHANNELS,\n\t\t\t\t\"EEPROM IBSS 11b channel set\"),\n\t    IPW2100_ORD(MAC_VERSION, \"MAC Version\"),\n\t    IPW2100_ORD(MAC_REVISION, \"MAC Revision\"),\n\t    IPW2100_ORD(RADIO_VERSION, \"Radio Version\"),\n\t    IPW2100_ORD(NIC_MANF_DATE_TIME, \"MANF Date/Time STAMP\"),\n\t    IPW2100_ORD(UCODE_VERSION, \"Ucode Version\"),};\n\nstatic ssize_t show_registers(struct device *d, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tint i;\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tstruct net_device *dev = priv->net_dev;\n\tchar *out = buf;\n\tu32 val = 0;\n\n\tout += sprintf(out, \"%30s [Address ] : Hex\\n\", \"Register\");\n\n\tfor (i = 0; i < ARRAY_SIZE(hw_data); i++) {\n\t\tread_register(dev, hw_data[i].addr, &val);\n\t\tout += sprintf(out, \"%30s [%08X] : %08X\\n\",\n\t\t\t       hw_data[i].name, hw_data[i].addr, val);\n\t}\n\n\treturn out - buf;\n}\n\nstatic DEVICE_ATTR(registers, 0444, show_registers, NULL);\n\nstatic ssize_t show_hardware(struct device *d, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tstruct net_device *dev = priv->net_dev;\n\tchar *out = buf;\n\tint i;\n\n\tout += sprintf(out, \"%30s [Address ] : Hex\\n\", \"NIC entry\");\n\n\tfor (i = 0; i < ARRAY_SIZE(nic_data); i++) {\n\t\tu8 tmp8;\n\t\tu16 tmp16;\n\t\tu32 tmp32;\n\n\t\tswitch (nic_data[i].size) {\n\t\tcase 1:\n\t\t\tread_nic_byte(dev, nic_data[i].addr, &tmp8);\n\t\t\tout += sprintf(out, \"%30s [%08X] : %02X\\n\",\n\t\t\t\t       nic_data[i].name, nic_data[i].addr,\n\t\t\t\t       tmp8);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tread_nic_word(dev, nic_data[i].addr, &tmp16);\n\t\t\tout += sprintf(out, \"%30s [%08X] : %04X\\n\",\n\t\t\t\t       nic_data[i].name, nic_data[i].addr,\n\t\t\t\t       tmp16);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tread_nic_dword(dev, nic_data[i].addr, &tmp32);\n\t\t\tout += sprintf(out, \"%30s [%08X] : %08X\\n\",\n\t\t\t\t       nic_data[i].name, nic_data[i].addr,\n\t\t\t\t       tmp32);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn out - buf;\n}\n\nstatic DEVICE_ATTR(hardware, 0444, show_hardware, NULL);\n\nstatic ssize_t show_memory(struct device *d, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tstruct net_device *dev = priv->net_dev;\n\tstatic unsigned long loop = 0;\n\tint len = 0;\n\tu32 buffer[4];\n\tint i;\n\tchar line[81];\n\n\tif (loop >= 0x30000)\n\t\tloop = 0;\n\n\t/* sysfs provides us PAGE_SIZE buffer */\n\twhile (len < PAGE_SIZE - 128 && loop < 0x30000) {\n\n\t\tif (priv->snapshot[0])\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tbuffer[i] =\n\t\t\t\t    *(u32 *) SNAPSHOT_ADDR(loop + i * 4);\n\t\telse\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tread_nic_dword(dev, loop + i * 4, &buffer[i]);\n\n\t\tif (priv->dump_raw)\n\t\t\tlen += sprintf(buf + len,\n\t\t\t\t       \"%c%c%c%c\"\n\t\t\t\t       \"%c%c%c%c\"\n\t\t\t\t       \"%c%c%c%c\"\n\t\t\t\t       \"%c%c%c%c\",\n\t\t\t\t       ((u8 *) buffer)[0x0],\n\t\t\t\t       ((u8 *) buffer)[0x1],\n\t\t\t\t       ((u8 *) buffer)[0x2],\n\t\t\t\t       ((u8 *) buffer)[0x3],\n\t\t\t\t       ((u8 *) buffer)[0x4],\n\t\t\t\t       ((u8 *) buffer)[0x5],\n\t\t\t\t       ((u8 *) buffer)[0x6],\n\t\t\t\t       ((u8 *) buffer)[0x7],\n\t\t\t\t       ((u8 *) buffer)[0x8],\n\t\t\t\t       ((u8 *) buffer)[0x9],\n\t\t\t\t       ((u8 *) buffer)[0xa],\n\t\t\t\t       ((u8 *) buffer)[0xb],\n\t\t\t\t       ((u8 *) buffer)[0xc],\n\t\t\t\t       ((u8 *) buffer)[0xd],\n\t\t\t\t       ((u8 *) buffer)[0xe],\n\t\t\t\t       ((u8 *) buffer)[0xf]);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \"%s\\n\",\n\t\t\t\t       snprint_line(line, sizeof(line),\n\t\t\t\t\t\t    (u8 *) buffer, 16, loop));\n\t\tloop += 16;\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t store_memory(struct device *d, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tstruct net_device *dev = priv->net_dev;\n\tconst char *p = buf;\n\n\t(void)dev;\t\t/* kill unused-var warning for debug-only code */\n\n\tif (count < 1)\n\t\treturn count;\n\n\tif (p[0] == '1' ||\n\t    (count >= 2 && tolower(p[0]) == 'o' && tolower(p[1]) == 'n')) {\n\t\tIPW_DEBUG_INFO(\"%s: Setting memory dump to RAW mode.\\n\",\n\t\t\t       dev->name);\n\t\tpriv->dump_raw = 1;\n\n\t} else if (p[0] == '0' || (count >= 2 && tolower(p[0]) == 'o' &&\n\t\t\t\t   tolower(p[1]) == 'f')) {\n\t\tIPW_DEBUG_INFO(\"%s: Setting memory dump to HEX mode.\\n\",\n\t\t\t       dev->name);\n\t\tpriv->dump_raw = 0;\n\n\t} else if (tolower(p[0]) == 'r') {\n\t\tIPW_DEBUG_INFO(\"%s: Resetting firmware snapshot.\\n\", dev->name);\n\t\tipw2100_snapshot_free(priv);\n\n\t} else\n\t\tIPW_DEBUG_INFO(\"%s: Usage: 0|on = HEX, 1|off = RAW, \"\n\t\t\t       \"reset = clear memory snapshot\\n\", dev->name);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(memory, 0644, show_memory, store_memory);\n\nstatic ssize_t show_ordinals(struct device *d, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tu32 val = 0;\n\tint len = 0;\n\tu32 val_len;\n\tstatic int loop = 0;\n\n\tif (priv->status & STATUS_RF_KILL_MASK)\n\t\treturn 0;\n\n\tif (loop >= ARRAY_SIZE(ord_data))\n\t\tloop = 0;\n\n\t/* sysfs provides us PAGE_SIZE buffer */\n\twhile (len < PAGE_SIZE - 128 && loop < ARRAY_SIZE(ord_data)) {\n\t\tval_len = sizeof(u32);\n\n\t\tif (ipw2100_get_ordinal(priv, ord_data[loop].index, &val,\n\t\t\t\t\t&val_len))\n\t\t\tlen += sprintf(buf + len, \"[0x%02X] = ERROR    %s\\n\",\n\t\t\t\t       ord_data[loop].index,\n\t\t\t\t       ord_data[loop].desc);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \"[0x%02X] = 0x%08X %s\\n\",\n\t\t\t\t       ord_data[loop].index, val,\n\t\t\t\t       ord_data[loop].desc);\n\t\tloop++;\n\t}\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR(ordinals, 0444, show_ordinals, NULL);\n\nstatic ssize_t show_stats(struct device *d, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tchar *out = buf;\n\n\tout += sprintf(out, \"interrupts: %d {tx: %d, rx: %d, other: %d}\\n\",\n\t\t       priv->interrupts, priv->tx_interrupts,\n\t\t       priv->rx_interrupts, priv->inta_other);\n\tout += sprintf(out, \"firmware resets: %d\\n\", priv->resets);\n\tout += sprintf(out, \"firmware hangs: %d\\n\", priv->hangs);\n#ifdef CONFIG_IPW2100_DEBUG\n\tout += sprintf(out, \"packet mismatch image: %s\\n\",\n\t\t       priv->snapshot[0] ? \"YES\" : \"NO\");\n#endif\n\n\treturn out - buf;\n}\n\nstatic DEVICE_ATTR(stats, 0444, show_stats, NULL);\n\nstatic int ipw2100_switch_mode(struct ipw2100_priv *priv, u32 mode)\n{\n\tint err;\n\n\tif (mode == priv->ieee->iw_mode)\n\t\treturn 0;\n\n\terr = ipw2100_disable_adapter(priv);\n\tif (err) {\n\t\tprintk(KERN_ERR DRV_NAME \": %s: Could not disable adapter %d\\n\",\n\t\t       priv->net_dev->name, err);\n\t\treturn err;\n\t}\n\n\tswitch (mode) {\n\tcase IW_MODE_INFRA:\n\t\tpriv->net_dev->type = ARPHRD_ETHER;\n\t\tbreak;\n\tcase IW_MODE_ADHOC:\n\t\tpriv->net_dev->type = ARPHRD_ETHER;\n\t\tbreak;\n#ifdef CONFIG_IPW2100_MONITOR\n\tcase IW_MODE_MONITOR:\n\t\tpriv->last_mode = priv->ieee->iw_mode;\n\t\tpriv->net_dev->type = ARPHRD_IEEE80211_RADIOTAP;\n\t\tbreak;\n#endif\t\t\t\t/* CONFIG_IPW2100_MONITOR */\n\t}\n\n\tpriv->ieee->iw_mode = mode;\n\n#ifdef CONFIG_PM\n\t/* Indicate ipw2100_download_firmware download firmware\n\t * from disk instead of memory. */\n\tipw2100_firmware.version = 0;\n#endif\n\n\tprintk(KERN_INFO \"%s: Resetting on mode change.\\n\", priv->net_dev->name);\n\tpriv->reset_backoff = 0;\n\tschedule_reset(priv);\n\n\treturn 0;\n}\n\nstatic ssize_t show_internals(struct device *d, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tint len = 0;\n\n#define DUMP_VAR(x,y) len += sprintf(buf + len, # x \": %\" y \"\\n\", priv-> x)\n\n\tif (priv->status & STATUS_ASSOCIATED)\n\t\tlen += sprintf(buf + len, \"connected: %llu\\n\",\n\t\t\t       ktime_get_boottime_seconds() - priv->connect_start);\n\telse\n\t\tlen += sprintf(buf + len, \"not connected\\n\");\n\n\tDUMP_VAR(ieee->crypt_info.crypt[priv->ieee->crypt_info.tx_keyidx], \"p\");\n\tDUMP_VAR(status, \"08lx\");\n\tDUMP_VAR(config, \"08lx\");\n\tDUMP_VAR(capability, \"08lx\");\n\n\tlen +=\n\t    sprintf(buf + len, \"last_rtc: %lu\\n\",\n\t\t    (unsigned long)priv->last_rtc);\n\n\tDUMP_VAR(fatal_error, \"d\");\n\tDUMP_VAR(stop_hang_check, \"d\");\n\tDUMP_VAR(stop_rf_kill, \"d\");\n\tDUMP_VAR(messages_sent, \"d\");\n\n\tDUMP_VAR(tx_pend_stat.value, \"d\");\n\tDUMP_VAR(tx_pend_stat.hi, \"d\");\n\n\tDUMP_VAR(tx_free_stat.value, \"d\");\n\tDUMP_VAR(tx_free_stat.lo, \"d\");\n\n\tDUMP_VAR(msg_free_stat.value, \"d\");\n\tDUMP_VAR(msg_free_stat.lo, \"d\");\n\n\tDUMP_VAR(msg_pend_stat.value, \"d\");\n\tDUMP_VAR(msg_pend_stat.hi, \"d\");\n\n\tDUMP_VAR(fw_pend_stat.value, \"d\");\n\tDUMP_VAR(fw_pend_stat.hi, \"d\");\n\n\tDUMP_VAR(txq_stat.value, \"d\");\n\tDUMP_VAR(txq_stat.lo, \"d\");\n\n\tDUMP_VAR(ieee->scans, \"d\");\n\tDUMP_VAR(reset_backoff, \"lld\");\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR(internals, 0444, show_internals, NULL);\n\nstatic ssize_t show_bssinfo(struct device *d, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tchar essid[IW_ESSID_MAX_SIZE + 1];\n\tu8 bssid[ETH_ALEN];\n\tu32 chan = 0;\n\tchar *out = buf;\n\tunsigned int length;\n\tint ret;\n\n\tif (priv->status & STATUS_RF_KILL_MASK)\n\t\treturn 0;\n\n\tmemset(essid, 0, sizeof(essid));\n\tmemset(bssid, 0, sizeof(bssid));\n\n\tlength = IW_ESSID_MAX_SIZE;\n\tret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_SSID, essid, &length);\n\tif (ret)\n\t\tIPW_DEBUG_INFO(\"failed querying ordinals at line %d\\n\",\n\t\t\t       __LINE__);\n\n\tlength = sizeof(bssid);\n\tret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_AP_BSSID,\n\t\t\t\t  bssid, &length);\n\tif (ret)\n\t\tIPW_DEBUG_INFO(\"failed querying ordinals at line %d\\n\",\n\t\t\t       __LINE__);\n\n\tlength = sizeof(u32);\n\tret = ipw2100_get_ordinal(priv, IPW_ORD_OUR_FREQ, &chan, &length);\n\tif (ret)\n\t\tIPW_DEBUG_INFO(\"failed querying ordinals at line %d\\n\",\n\t\t\t       __LINE__);\n\n\tout += sprintf(out, \"ESSID: %s\\n\", essid);\n\tout += sprintf(out, \"BSSID:   %pM\\n\", bssid);\n\tout += sprintf(out, \"Channel: %d\\n\", chan);\n\n\treturn out - buf;\n}\n\nstatic DEVICE_ATTR(bssinfo, 0444, show_bssinfo, NULL);\n\n#ifdef CONFIG_IPW2100_DEBUG\nstatic ssize_t debug_level_show(struct device_driver *d, char *buf)\n{\n\treturn sprintf(buf, \"0x%08X\\n\", ipw2100_debug_level);\n}\n\nstatic ssize_t debug_level_store(struct device_driver *d,\n\t\t\t\t const char *buf, size_t count)\n{\n\tu32 val;\n\tint ret;\n\n\tret = kstrtou32(buf, 0, &val);\n\tif (ret)\n\t\tIPW_DEBUG_INFO(\": %s is not in hex or decimal form.\\n\", buf);\n\telse\n\t\tipw2100_debug_level = val;\n\n\treturn strnlen(buf, count);\n}\nstatic DRIVER_ATTR_RW(debug_level);\n#endif\t\t\t\t/* CONFIG_IPW2100_DEBUG */\n\nstatic ssize_t show_fatal_error(struct device *d,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tchar *out = buf;\n\tint i;\n\n\tif (priv->fatal_error)\n\t\tout += sprintf(out, \"0x%08X\\n\", priv->fatal_error);\n\telse\n\t\tout += sprintf(out, \"0\\n\");\n\n\tfor (i = 1; i <= IPW2100_ERROR_QUEUE; i++) {\n\t\tif (!priv->fatal_errors[(priv->fatal_index - i) %\n\t\t\t\t\tIPW2100_ERROR_QUEUE])\n\t\t\tcontinue;\n\n\t\tout += sprintf(out, \"%d. 0x%08X\\n\", i,\n\t\t\t       priv->fatal_errors[(priv->fatal_index - i) %\n\t\t\t\t\t\t  IPW2100_ERROR_QUEUE]);\n\t}\n\n\treturn out - buf;\n}\n\nstatic ssize_t store_fatal_error(struct device *d,\n\t\t\t\t struct device_attribute *attr, const char *buf,\n\t\t\t\t size_t count)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tschedule_reset(priv);\n\treturn count;\n}\n\nstatic DEVICE_ATTR(fatal_error, 0644, show_fatal_error, store_fatal_error);\n\nstatic ssize_t show_scan_age(struct device *d, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\treturn sprintf(buf, \"%d\\n\", priv->ieee->scan_age);\n}\n\nstatic ssize_t store_scan_age(struct device *d, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tstruct net_device *dev = priv->net_dev;\n\tunsigned long val;\n\tint ret;\n\n\t(void)dev;\t\t/* kill unused-var warning for debug-only code */\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tret = kstrtoul(buf, 0, &val);\n\tif (ret) {\n\t\tIPW_DEBUG_INFO(\"%s: user supplied invalid value.\\n\", dev->name);\n\t} else {\n\t\tpriv->ieee->scan_age = val;\n\t\tIPW_DEBUG_INFO(\"set scan_age = %u\\n\", priv->ieee->scan_age);\n\t}\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(scan_age, 0644, show_scan_age, store_scan_age);\n\nstatic ssize_t show_rf_kill(struct device *d, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\t/* 0 - RF kill not enabled\n\t   1 - SW based RF kill active (sysfs)\n\t   2 - HW based RF kill active\n\t   3 - Both HW and SW baed RF kill active */\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tint val = ((priv->status & STATUS_RF_KILL_SW) ? 0x1 : 0x0) |\n\t    (rf_kill_active(priv) ? 0x2 : 0x0);\n\treturn sprintf(buf, \"%i\\n\", val);\n}\n\nstatic int ipw_radio_kill_sw(struct ipw2100_priv *priv, int disable_radio)\n{\n\tif ((disable_radio ? 1 : 0) ==\n\t    (priv->status & STATUS_RF_KILL_SW ? 1 : 0))\n\t\treturn 0;\n\n\tIPW_DEBUG_RF_KILL(\"Manual SW RF Kill set to: RADIO  %s\\n\",\n\t\t\t  disable_radio ? \"OFF\" : \"ON\");\n\n\tmutex_lock(&priv->action_mutex);\n\n\tif (disable_radio) {\n\t\tpriv->status |= STATUS_RF_KILL_SW;\n\t\tipw2100_down(priv);\n\t} else {\n\t\tpriv->status &= ~STATUS_RF_KILL_SW;\n\t\tif (rf_kill_active(priv)) {\n\t\t\tIPW_DEBUG_RF_KILL(\"Can not turn radio back on - \"\n\t\t\t\t\t  \"disabled by HW switch\\n\");\n\t\t\t/* Make sure the RF_KILL check timer is running */\n\t\t\tpriv->stop_rf_kill = 0;\n\t\t\tmod_delayed_work(system_wq, &priv->rf_kill,\n\t\t\t\t\t round_jiffies_relative(HZ));\n\t\t} else\n\t\t\tschedule_reset(priv);\n\t}\n\n\tmutex_unlock(&priv->action_mutex);\n\treturn 1;\n}\n\nstatic ssize_t store_rf_kill(struct device *d, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tipw_radio_kill_sw(priv, buf[0] == '1');\n\treturn count;\n}\n\nstatic DEVICE_ATTR(rf_kill, 0644, show_rf_kill, store_rf_kill);\n\nstatic struct attribute *ipw2100_sysfs_entries[] = {\n\t&dev_attr_hardware.attr,\n\t&dev_attr_registers.attr,\n\t&dev_attr_ordinals.attr,\n\t&dev_attr_pci.attr,\n\t&dev_attr_stats.attr,\n\t&dev_attr_internals.attr,\n\t&dev_attr_bssinfo.attr,\n\t&dev_attr_memory.attr,\n\t&dev_attr_scan_age.attr,\n\t&dev_attr_fatal_error.attr,\n\t&dev_attr_rf_kill.attr,\n\t&dev_attr_cfg.attr,\n\t&dev_attr_status.attr,\n\t&dev_attr_capability.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ipw2100_attribute_group = {\n\t.attrs = ipw2100_sysfs_entries,\n};\n\nstatic int status_queue_allocate(struct ipw2100_priv *priv, int entries)\n{\n\tstruct ipw2100_status_queue *q = &priv->status_queue;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tq->size = entries * sizeof(struct ipw2100_status);\n\tq->drv = dma_alloc_coherent(&priv->pci_dev->dev, q->size, &q->nic,\n\t\t\t\t    GFP_KERNEL);\n\tif (!q->drv) {\n\t\tIPW_DEBUG_WARNING(\"Can not allocate status queue.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\n\treturn 0;\n}\n\nstatic void status_queue_free(struct ipw2100_priv *priv)\n{\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tif (priv->status_queue.drv) {\n\t\tdma_free_coherent(&priv->pci_dev->dev,\n\t\t\t\t  priv->status_queue.size,\n\t\t\t\t  priv->status_queue.drv,\n\t\t\t\t  priv->status_queue.nic);\n\t\tpriv->status_queue.drv = NULL;\n\t}\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n}\n\nstatic int bd_queue_allocate(struct ipw2100_priv *priv,\n\t\t\t     struct ipw2100_bd_queue *q, int entries)\n{\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tmemset(q, 0, sizeof(struct ipw2100_bd_queue));\n\n\tq->entries = entries;\n\tq->size = entries * sizeof(struct ipw2100_bd);\n\tq->drv = dma_alloc_coherent(&priv->pci_dev->dev, q->size, &q->nic,\n\t\t\t\t    GFP_KERNEL);\n\tif (!q->drv) {\n\t\tIPW_DEBUG_INFO\n\t\t    (\"can't allocate shared memory for buffer descriptors\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\n\treturn 0;\n}\n\nstatic void bd_queue_free(struct ipw2100_priv *priv, struct ipw2100_bd_queue *q)\n{\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tif (!q)\n\t\treturn;\n\n\tif (q->drv) {\n\t\tdma_free_coherent(&priv->pci_dev->dev, q->size, q->drv,\n\t\t\t\t  q->nic);\n\t\tq->drv = NULL;\n\t}\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n}\n\nstatic void bd_queue_initialize(struct ipw2100_priv *priv,\n\t\t\t\tstruct ipw2100_bd_queue *q, u32 base, u32 size,\n\t\t\t\tu32 r, u32 w)\n{\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tIPW_DEBUG_INFO(\"initializing bd queue at virt=%p, phys=%08x\\n\", q->drv,\n\t\t       (u32) q->nic);\n\n\twrite_register(priv->net_dev, base, q->nic);\n\twrite_register(priv->net_dev, size, q->entries);\n\twrite_register(priv->net_dev, r, q->oldest);\n\twrite_register(priv->net_dev, w, q->next);\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n}\n\nstatic void ipw2100_kill_works(struct ipw2100_priv *priv)\n{\n\tpriv->stop_rf_kill = 1;\n\tpriv->stop_hang_check = 1;\n\tcancel_delayed_work_sync(&priv->reset_work);\n\tcancel_delayed_work_sync(&priv->security_work);\n\tcancel_delayed_work_sync(&priv->wx_event_work);\n\tcancel_delayed_work_sync(&priv->hang_check);\n\tcancel_delayed_work_sync(&priv->rf_kill);\n\tcancel_delayed_work_sync(&priv->scan_event);\n}\n\nstatic int ipw2100_tx_allocate(struct ipw2100_priv *priv)\n{\n\tint i, j, err;\n\tvoid *v;\n\tdma_addr_t p;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\terr = bd_queue_allocate(priv, &priv->tx_queue, TX_QUEUE_LENGTH);\n\tif (err) {\n\t\tIPW_DEBUG_ERROR(\"%s: failed bd_queue_allocate\\n\",\n\t\t\t\tpriv->net_dev->name);\n\t\treturn err;\n\t}\n\n\tpriv->tx_buffers = kmalloc_array(TX_PENDED_QUEUE_LENGTH,\n\t\t\t\t\t sizeof(struct ipw2100_tx_packet),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!priv->tx_buffers) {\n\t\tbd_queue_free(priv, &priv->tx_queue);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < TX_PENDED_QUEUE_LENGTH; i++) {\n\t\tv = dma_alloc_coherent(&priv->pci_dev->dev,\n\t\t\t\t       sizeof(struct ipw2100_data_header), &p,\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!v) {\n\t\t\tprintk(KERN_ERR DRV_NAME\n\t\t\t       \": %s: PCI alloc failed for tx \" \"buffers.\\n\",\n\t\t\t       priv->net_dev->name);\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tpriv->tx_buffers[i].type = DATA;\n\t\tpriv->tx_buffers[i].info.d_struct.data =\n\t\t    (struct ipw2100_data_header *)v;\n\t\tpriv->tx_buffers[i].info.d_struct.data_phys = p;\n\t\tpriv->tx_buffers[i].info.d_struct.txb = NULL;\n\t}\n\n\tif (i == TX_PENDED_QUEUE_LENGTH)\n\t\treturn 0;\n\n\tfor (j = 0; j < i; j++) {\n\t\tdma_free_coherent(&priv->pci_dev->dev,\n\t\t\t\t  sizeof(struct ipw2100_data_header),\n\t\t\t\t  priv->tx_buffers[j].info.d_struct.data,\n\t\t\t\t  priv->tx_buffers[j].info.d_struct.data_phys);\n\t}\n\n\tkfree(priv->tx_buffers);\n\tpriv->tx_buffers = NULL;\n\n\treturn err;\n}\n\nstatic void ipw2100_tx_initialize(struct ipw2100_priv *priv)\n{\n\tint i;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\t/*\n\t * reinitialize packet info lists\n\t */\n\tINIT_LIST_HEAD(&priv->fw_pend_list);\n\tINIT_STAT(&priv->fw_pend_stat);\n\n\t/*\n\t * reinitialize lists\n\t */\n\tINIT_LIST_HEAD(&priv->tx_pend_list);\n\tINIT_LIST_HEAD(&priv->tx_free_list);\n\tINIT_STAT(&priv->tx_pend_stat);\n\tINIT_STAT(&priv->tx_free_stat);\n\n\tfor (i = 0; i < TX_PENDED_QUEUE_LENGTH; i++) {\n\t\t/* We simply drop any SKBs that have been queued for\n\t\t * transmit */\n\t\tif (priv->tx_buffers[i].info.d_struct.txb) {\n\t\t\tlibipw_txb_free(priv->tx_buffers[i].info.d_struct.\n\t\t\t\t\t   txb);\n\t\t\tpriv->tx_buffers[i].info.d_struct.txb = NULL;\n\t\t}\n\n\t\tlist_add_tail(&priv->tx_buffers[i].list, &priv->tx_free_list);\n\t}\n\n\tSET_STAT(&priv->tx_free_stat, i);\n\n\tpriv->tx_queue.oldest = 0;\n\tpriv->tx_queue.available = priv->tx_queue.entries;\n\tpriv->tx_queue.next = 0;\n\tINIT_STAT(&priv->txq_stat);\n\tSET_STAT(&priv->txq_stat, priv->tx_queue.available);\n\n\tbd_queue_initialize(priv, &priv->tx_queue,\n\t\t\t    IPW_MEM_HOST_SHARED_TX_QUEUE_BD_BASE,\n\t\t\t    IPW_MEM_HOST_SHARED_TX_QUEUE_BD_SIZE,\n\t\t\t    IPW_MEM_HOST_SHARED_TX_QUEUE_READ_INDEX,\n\t\t\t    IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX);\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\n}\n\nstatic void ipw2100_tx_free(struct ipw2100_priv *priv)\n{\n\tint i;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tbd_queue_free(priv, &priv->tx_queue);\n\n\tif (!priv->tx_buffers)\n\t\treturn;\n\n\tfor (i = 0; i < TX_PENDED_QUEUE_LENGTH; i++) {\n\t\tif (priv->tx_buffers[i].info.d_struct.txb) {\n\t\t\tlibipw_txb_free(priv->tx_buffers[i].info.d_struct.\n\t\t\t\t\t   txb);\n\t\t\tpriv->tx_buffers[i].info.d_struct.txb = NULL;\n\t\t}\n\t\tif (priv->tx_buffers[i].info.d_struct.data)\n\t\t\tdma_free_coherent(&priv->pci_dev->dev,\n\t\t\t\t\t  sizeof(struct ipw2100_data_header),\n\t\t\t\t\t  priv->tx_buffers[i].info.d_struct.data,\n\t\t\t\t\t  priv->tx_buffers[i].info.d_struct.data_phys);\n\t}\n\n\tkfree(priv->tx_buffers);\n\tpriv->tx_buffers = NULL;\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n}\n\nstatic int ipw2100_rx_allocate(struct ipw2100_priv *priv)\n{\n\tint i, j, err = -EINVAL;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\terr = bd_queue_allocate(priv, &priv->rx_queue, RX_QUEUE_LENGTH);\n\tif (err) {\n\t\tIPW_DEBUG_INFO(\"failed bd_queue_allocate\\n\");\n\t\treturn err;\n\t}\n\n\terr = status_queue_allocate(priv, RX_QUEUE_LENGTH);\n\tif (err) {\n\t\tIPW_DEBUG_INFO(\"failed status_queue_allocate\\n\");\n\t\tbd_queue_free(priv, &priv->rx_queue);\n\t\treturn err;\n\t}\n\n\t/*\n\t * allocate packets\n\t */\n\tpriv->rx_buffers = kmalloc_array(RX_QUEUE_LENGTH,\n\t\t\t\t\t sizeof(struct ipw2100_rx_packet),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!priv->rx_buffers) {\n\t\tIPW_DEBUG_INFO(\"can't allocate rx packet buffer table\\n\");\n\n\t\tbd_queue_free(priv, &priv->rx_queue);\n\n\t\tstatus_queue_free(priv);\n\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < RX_QUEUE_LENGTH; i++) {\n\t\tstruct ipw2100_rx_packet *packet = &priv->rx_buffers[i];\n\n\t\terr = ipw2100_alloc_skb(priv, packet);\n\t\tif (unlikely(err)) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* The BD holds the cache aligned address */\n\t\tpriv->rx_queue.drv[i].host_addr = packet->dma_addr;\n\t\tpriv->rx_queue.drv[i].buf_length = IPW_RX_NIC_BUFFER_LENGTH;\n\t\tpriv->status_queue.drv[i].status_fields = 0;\n\t}\n\n\tif (i == RX_QUEUE_LENGTH)\n\t\treturn 0;\n\n\tfor (j = 0; j < i; j++) {\n\t\tdma_unmap_single(&priv->pci_dev->dev,\n\t\t\t\t priv->rx_buffers[j].dma_addr,\n\t\t\t\t sizeof(struct ipw2100_rx_packet),\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tdev_kfree_skb(priv->rx_buffers[j].skb);\n\t}\n\n\tkfree(priv->rx_buffers);\n\tpriv->rx_buffers = NULL;\n\n\tbd_queue_free(priv, &priv->rx_queue);\n\n\tstatus_queue_free(priv);\n\n\treturn err;\n}\n\nstatic void ipw2100_rx_initialize(struct ipw2100_priv *priv)\n{\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tpriv->rx_queue.oldest = 0;\n\tpriv->rx_queue.available = priv->rx_queue.entries - 1;\n\tpriv->rx_queue.next = priv->rx_queue.entries - 1;\n\n\tINIT_STAT(&priv->rxq_stat);\n\tSET_STAT(&priv->rxq_stat, priv->rx_queue.available);\n\n\tbd_queue_initialize(priv, &priv->rx_queue,\n\t\t\t    IPW_MEM_HOST_SHARED_RX_BD_BASE,\n\t\t\t    IPW_MEM_HOST_SHARED_RX_BD_SIZE,\n\t\t\t    IPW_MEM_HOST_SHARED_RX_READ_INDEX,\n\t\t\t    IPW_MEM_HOST_SHARED_RX_WRITE_INDEX);\n\n\t/* set up the status queue */\n\twrite_register(priv->net_dev, IPW_MEM_HOST_SHARED_RX_STATUS_BASE,\n\t\t       priv->status_queue.nic);\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n}\n\nstatic void ipw2100_rx_free(struct ipw2100_priv *priv)\n{\n\tint i;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tbd_queue_free(priv, &priv->rx_queue);\n\tstatus_queue_free(priv);\n\n\tif (!priv->rx_buffers)\n\t\treturn;\n\n\tfor (i = 0; i < RX_QUEUE_LENGTH; i++) {\n\t\tif (priv->rx_buffers[i].rxp) {\n\t\t\tdma_unmap_single(&priv->pci_dev->dev,\n\t\t\t\t\t priv->rx_buffers[i].dma_addr,\n\t\t\t\t\t sizeof(struct ipw2100_rx),\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(priv->rx_buffers[i].skb);\n\t\t}\n\t}\n\n\tkfree(priv->rx_buffers);\n\tpriv->rx_buffers = NULL;\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n}\n\nstatic int ipw2100_read_mac_address(struct ipw2100_priv *priv)\n{\n\tu32 length = ETH_ALEN;\n\tu8 addr[ETH_ALEN];\n\n\tint err;\n\n\terr = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ADAPTER_MAC, addr, &length);\n\tif (err) {\n\t\tIPW_DEBUG_INFO(\"MAC address read failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(priv->net_dev->dev_addr, addr, ETH_ALEN);\n\tIPW_DEBUG_INFO(\"card MAC is %pM\\n\", priv->net_dev->dev_addr);\n\n\treturn 0;\n}\n\n/********************************************************************\n *\n * Firmware Commands\n *\n ********************************************************************/\n\nstatic int ipw2100_set_mac_address(struct ipw2100_priv *priv, int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = ADAPTER_ADDRESS,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = ETH_ALEN\n\t};\n\tint err;\n\n\tIPW_DEBUG_HC(\"SET_MAC_ADDRESS\\n\");\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tif (priv->config & CFG_CUSTOM_MAC) {\n\t\tmemcpy(cmd.host_command_parameters, priv->mac_addr, ETH_ALEN);\n\t\tmemcpy(priv->net_dev->dev_addr, priv->mac_addr, ETH_ALEN);\n\t} else\n\t\tmemcpy(cmd.host_command_parameters, priv->net_dev->dev_addr,\n\t\t       ETH_ALEN);\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\treturn err;\n}\n\nstatic int ipw2100_set_port_type(struct ipw2100_priv *priv, u32 port_type,\n\t\t\t\t int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = PORT_TYPE,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = sizeof(u32)\n\t};\n\tint err;\n\n\tswitch (port_type) {\n\tcase IW_MODE_INFRA:\n\t\tcmd.host_command_parameters[0] = IPW_BSS;\n\t\tbreak;\n\tcase IW_MODE_ADHOC:\n\t\tcmd.host_command_parameters[0] = IPW_IBSS;\n\t\tbreak;\n\t}\n\n\tIPW_DEBUG_HC(\"PORT_TYPE: %s\\n\",\n\t\t     port_type == IPW_IBSS ? \"Ad-Hoc\" : \"Managed\");\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR DRV_NAME\n\t\t\t       \": %s: Could not disable adapter %d\\n\",\n\t\t\t       priv->net_dev->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t/* send cmd to firmware */\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tif (!batch_mode)\n\t\tipw2100_enable_adapter(priv);\n\n\treturn err;\n}\n\nstatic int ipw2100_set_channel(struct ipw2100_priv *priv, u32 channel,\n\t\t\t       int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = CHANNEL,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = sizeof(u32)\n\t};\n\tint err;\n\n\tcmd.host_command_parameters[0] = channel;\n\n\tIPW_DEBUG_HC(\"CHANNEL: %d\\n\", channel);\n\n\t/* If BSS then we don't support channel selection */\n\tif (priv->ieee->iw_mode == IW_MODE_INFRA)\n\t\treturn 0;\n\n\tif ((channel != 0) &&\n\t    ((channel < REG_MIN_CHANNEL) || (channel > REG_MAX_CHANNEL)))\n\t\treturn -EINVAL;\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err) {\n\t\tIPW_DEBUG_INFO(\"Failed to set channel to %d\", channel);\n\t\treturn err;\n\t}\n\n\tif (channel)\n\t\tpriv->config |= CFG_STATIC_CHANNEL;\n\telse\n\t\tpriv->config &= ~CFG_STATIC_CHANNEL;\n\n\tpriv->channel = channel;\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_enable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int ipw2100_system_config(struct ipw2100_priv *priv, int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = SYSTEM_CONFIG,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 12,\n\t};\n\tu32 ibss_mask, len = sizeof(u32);\n\tint err;\n\n\t/* Set system configuration */\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC)\n\t\tcmd.host_command_parameters[0] |= IPW_CFG_IBSS_AUTO_START;\n\n\tcmd.host_command_parameters[0] |= IPW_CFG_IBSS_MASK |\n\t    IPW_CFG_BSS_MASK | IPW_CFG_802_1x_ENABLE;\n\n\tif (!(priv->config & CFG_LONG_PREAMBLE))\n\t\tcmd.host_command_parameters[0] |= IPW_CFG_PREAMBLE_AUTO;\n\n\terr = ipw2100_get_ordinal(priv,\n\t\t\t\t  IPW_ORD_EEPROM_IBSS_11B_CHANNELS,\n\t\t\t\t  &ibss_mask, &len);\n\tif (err)\n\t\tibss_mask = IPW_IBSS_11B_DEFAULT_MASK;\n\n\tcmd.host_command_parameters[1] = REG_CHANNEL_MASK;\n\tcmd.host_command_parameters[2] = REG_CHANNEL_MASK & ibss_mask;\n\n\t/* 11b only */\n\t/*cmd.host_command_parameters[0] |= DIVERSITY_ANTENNA_A; */\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err)\n\t\treturn err;\n\n/* If IPv6 is configured in the kernel then we don't want to filter out all\n * of the multicast packets as IPv6 needs some. */\n#if !defined(CONFIG_IPV6) && !defined(CONFIG_IPV6_MODULE)\n\tcmd.host_command = ADD_MULTICAST;\n\tcmd.host_command_sequence = 0;\n\tcmd.host_command_length = 0;\n\n\tipw2100_hw_send_command(priv, &cmd);\n#endif\n\tif (!batch_mode) {\n\t\terr = ipw2100_enable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int ipw2100_set_tx_rates(struct ipw2100_priv *priv, u32 rate,\n\t\t\t\tint batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = BASIC_TX_RATES,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4\n\t};\n\tint err;\n\n\tcmd.host_command_parameters[0] = rate & TX_RATE_MASK;\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* Set BASIC TX Rate first */\n\tipw2100_hw_send_command(priv, &cmd);\n\n\t/* Set TX Rate */\n\tcmd.host_command = TX_RATES;\n\tipw2100_hw_send_command(priv, &cmd);\n\n\t/* Set MSDU TX Rate */\n\tcmd.host_command = MSDU_TX_RATES;\n\tipw2100_hw_send_command(priv, &cmd);\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_enable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tpriv->tx_rates = rate;\n\n\treturn 0;\n}\n\nstatic int ipw2100_set_power_mode(struct ipw2100_priv *priv, int power_level)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = POWER_MODE,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4\n\t};\n\tint err;\n\n\tcmd.host_command_parameters[0] = power_level;\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err)\n\t\treturn err;\n\n\tif (power_level == IPW_POWER_MODE_CAM)\n\t\tpriv->power_mode = IPW_POWER_LEVEL(priv->power_mode);\n\telse\n\t\tpriv->power_mode = IPW_POWER_ENABLED | power_level;\n\n#ifdef IPW2100_TX_POWER\n\tif (priv->port_type == IBSS && priv->adhoc_power != DFTL_IBSS_TX_POWER) {\n\t\t/* Set beacon interval */\n\t\tcmd.host_command = TX_POWER_INDEX;\n\t\tcmd.host_command_parameters[0] = (u32) priv->adhoc_power;\n\n\t\terr = ipw2100_hw_send_command(priv, &cmd);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic int ipw2100_set_rts_threshold(struct ipw2100_priv *priv, u32 threshold)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = RTS_THRESHOLD,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4\n\t};\n\tint err;\n\n\tif (threshold & RTS_DISABLED)\n\t\tcmd.host_command_parameters[0] = MAX_RTS_THRESHOLD;\n\telse\n\t\tcmd.host_command_parameters[0] = threshold & ~RTS_DISABLED;\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err)\n\t\treturn err;\n\n\tpriv->rts_threshold = threshold;\n\n\treturn 0;\n}\n\n#if 0\nint ipw2100_set_fragmentation_threshold(struct ipw2100_priv *priv,\n\t\t\t\t\tu32 threshold, int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = FRAG_THRESHOLD,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4,\n\t\t.host_command_parameters[0] = 0,\n\t};\n\tint err;\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (threshold == 0)\n\t\tthreshold = DEFAULT_FRAG_THRESHOLD;\n\telse {\n\t\tthreshold = max(threshold, MIN_FRAG_THRESHOLD);\n\t\tthreshold = min(threshold, MAX_FRAG_THRESHOLD);\n\t}\n\n\tcmd.host_command_parameters[0] = threshold;\n\n\tIPW_DEBUG_HC(\"FRAG_THRESHOLD: %u\\n\", threshold);\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tif (!batch_mode)\n\t\tipw2100_enable_adapter(priv);\n\n\tif (!err)\n\t\tpriv->frag_threshold = threshold;\n\n\treturn err;\n}\n#endif\n\nstatic int ipw2100_set_short_retry(struct ipw2100_priv *priv, u32 retry)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = SHORT_RETRY_LIMIT,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4\n\t};\n\tint err;\n\n\tcmd.host_command_parameters[0] = retry;\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err)\n\t\treturn err;\n\n\tpriv->short_retry_limit = retry;\n\n\treturn 0;\n}\n\nstatic int ipw2100_set_long_retry(struct ipw2100_priv *priv, u32 retry)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = LONG_RETRY_LIMIT,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4\n\t};\n\tint err;\n\n\tcmd.host_command_parameters[0] = retry;\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err)\n\t\treturn err;\n\n\tpriv->long_retry_limit = retry;\n\n\treturn 0;\n}\n\nstatic int ipw2100_set_mandatory_bssid(struct ipw2100_priv *priv, u8 * bssid,\n\t\t\t\t       int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = MANDATORY_BSSID,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = (bssid == NULL) ? 0 : ETH_ALEN\n\t};\n\tint err;\n\n#ifdef CONFIG_IPW2100_DEBUG\n\tif (bssid != NULL)\n\t\tIPW_DEBUG_HC(\"MANDATORY_BSSID: %pM\\n\", bssid);\n\telse\n\t\tIPW_DEBUG_HC(\"MANDATORY_BSSID: <clear>\\n\");\n#endif\n\t/* if BSSID is empty then we disable mandatory bssid mode */\n\tif (bssid != NULL)\n\t\tmemcpy(cmd.host_command_parameters, bssid, ETH_ALEN);\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tif (!batch_mode)\n\t\tipw2100_enable_adapter(priv);\n\n\treturn err;\n}\n\nstatic int ipw2100_disassociate_bssid(struct ipw2100_priv *priv)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = DISASSOCIATION_BSSID,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = ETH_ALEN\n\t};\n\tint err;\n\n\tIPW_DEBUG_HC(\"DISASSOCIATION_BSSID\\n\");\n\n\t/* The Firmware currently ignores the BSSID and just disassociates from\n\t * the currently associated AP -- but in the off chance that a future\n\t * firmware does use the BSSID provided here, we go ahead and try and\n\t * set it to the currently associated AP's BSSID */\n\tmemcpy(cmd.host_command_parameters, priv->bssid, ETH_ALEN);\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\treturn err;\n}\n\nstatic int ipw2100_set_wpa_ie(struct ipw2100_priv *,\n\t\t\t      struct ipw2100_wpa_assoc_frame *, int)\n    __attribute__ ((unused));\n\nstatic int ipw2100_set_wpa_ie(struct ipw2100_priv *priv,\n\t\t\t      struct ipw2100_wpa_assoc_frame *wpa_frame,\n\t\t\t      int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = SET_WPA_IE,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = sizeof(struct ipw2100_wpa_assoc_frame),\n\t};\n\tint err;\n\n\tIPW_DEBUG_HC(\"SET_WPA_IE\\n\");\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmemcpy(cmd.host_command_parameters, wpa_frame,\n\t       sizeof(struct ipw2100_wpa_assoc_frame));\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tif (!batch_mode) {\n\t\tif (ipw2100_enable_adapter(priv))\n\t\t\terr = -EIO;\n\t}\n\n\treturn err;\n}\n\nstruct security_info_params {\n\tu32 allowed_ciphers;\n\tu16 version;\n\tu8 auth_mode;\n\tu8 replay_counters_number;\n\tu8 unicast_using_group;\n} __packed;\n\nstatic int ipw2100_set_security_information(struct ipw2100_priv *priv,\n\t\t\t\t\t    int auth_mode,\n\t\t\t\t\t    int security_level,\n\t\t\t\t\t    int unicast_using_group,\n\t\t\t\t\t    int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = SET_SECURITY_INFORMATION,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = sizeof(struct security_info_params)\n\t};\n\tstruct security_info_params *security =\n\t    (struct security_info_params *)&cmd.host_command_parameters;\n\tint err;\n\tmemset(security, 0, sizeof(*security));\n\n\t/* If shared key AP authentication is turned on, then we need to\n\t * configure the firmware to try and use it.\n\t *\n\t * Actual data encryption/decryption is handled by the host. */\n\tsecurity->auth_mode = auth_mode;\n\tsecurity->unicast_using_group = unicast_using_group;\n\n\tswitch (security_level) {\n\tdefault:\n\tcase SEC_LEVEL_0:\n\t\tsecurity->allowed_ciphers = IPW_NONE_CIPHER;\n\t\tbreak;\n\tcase SEC_LEVEL_1:\n\t\tsecurity->allowed_ciphers = IPW_WEP40_CIPHER |\n\t\t    IPW_WEP104_CIPHER;\n\t\tbreak;\n\tcase SEC_LEVEL_2:\n\t\tsecurity->allowed_ciphers = IPW_WEP40_CIPHER |\n\t\t    IPW_WEP104_CIPHER | IPW_TKIP_CIPHER;\n\t\tbreak;\n\tcase SEC_LEVEL_2_CKIP:\n\t\tsecurity->allowed_ciphers = IPW_WEP40_CIPHER |\n\t\t    IPW_WEP104_CIPHER | IPW_CKIP_CIPHER;\n\t\tbreak;\n\tcase SEC_LEVEL_3:\n\t\tsecurity->allowed_ciphers = IPW_WEP40_CIPHER |\n\t\t    IPW_WEP104_CIPHER | IPW_TKIP_CIPHER | IPW_CCMP_CIPHER;\n\t\tbreak;\n\t}\n\n\tIPW_DEBUG_HC\n\t    (\"SET_SECURITY_INFORMATION: auth:%d cipher:0x%02X (level %d)\\n\",\n\t     security->auth_mode, security->allowed_ciphers, security_level);\n\n\tsecurity->replay_counters_number = 0;\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tif (!batch_mode)\n\t\tipw2100_enable_adapter(priv);\n\n\treturn err;\n}\n\nstatic int ipw2100_set_tx_power(struct ipw2100_priv *priv, u32 tx_power)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = TX_POWER_INDEX,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4\n\t};\n\tint err = 0;\n\tu32 tmp = tx_power;\n\n\tif (tx_power != IPW_TX_POWER_DEFAULT)\n\t\ttmp = (tx_power - IPW_TX_POWER_MIN_DBM) * 16 /\n\t\t      (IPW_TX_POWER_MAX_DBM - IPW_TX_POWER_MIN_DBM);\n\n\tcmd.host_command_parameters[0] = tmp;\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC)\n\t\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (!err)\n\t\tpriv->tx_power = tx_power;\n\n\treturn 0;\n}\n\nstatic int ipw2100_set_ibss_beacon_interval(struct ipw2100_priv *priv,\n\t\t\t\t\t    u32 interval, int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = BEACON_INTERVAL,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4\n\t};\n\tint err;\n\n\tcmd.host_command_parameters[0] = interval;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\tif (!batch_mode) {\n\t\t\terr = ipw2100_disable_adapter(priv);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tipw2100_hw_send_command(priv, &cmd);\n\n\t\tif (!batch_mode) {\n\t\t\terr = ipw2100_enable_adapter(priv);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\n\treturn 0;\n}\n\nstatic void ipw2100_queues_initialize(struct ipw2100_priv *priv)\n{\n\tipw2100_tx_initialize(priv);\n\tipw2100_rx_initialize(priv);\n\tipw2100_msg_initialize(priv);\n}\n\nstatic void ipw2100_queues_free(struct ipw2100_priv *priv)\n{\n\tipw2100_tx_free(priv);\n\tipw2100_rx_free(priv);\n\tipw2100_msg_free(priv);\n}\n\nstatic int ipw2100_queues_allocate(struct ipw2100_priv *priv)\n{\n\tif (ipw2100_tx_allocate(priv) ||\n\t    ipw2100_rx_allocate(priv) || ipw2100_msg_allocate(priv))\n\t\tgoto fail;\n\n\treturn 0;\n\n      fail:\n\tipw2100_tx_free(priv);\n\tipw2100_rx_free(priv);\n\tipw2100_msg_free(priv);\n\treturn -ENOMEM;\n}\n\n#define IPW_PRIVACY_CAPABLE 0x0008\n\nstatic int ipw2100_set_wep_flags(struct ipw2100_priv *priv, u32 flags,\n\t\t\t\t int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = WEP_FLAGS,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4\n\t};\n\tint err;\n\n\tcmd.host_command_parameters[0] = flags;\n\n\tIPW_DEBUG_HC(\"WEP_FLAGS: flags = 0x%08X\\n\", flags);\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR DRV_NAME\n\t\t\t       \": %s: Could not disable adapter %d\\n\",\n\t\t\t       priv->net_dev->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t/* send cmd to firmware */\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tif (!batch_mode)\n\t\tipw2100_enable_adapter(priv);\n\n\treturn err;\n}\n\nstruct ipw2100_wep_key {\n\tu8 idx;\n\tu8 len;\n\tu8 key[13];\n};\n\n/* Macros to ease up priting WEP keys */\n#define WEP_FMT_64  \"%02X%02X%02X%02X-%02X\"\n#define WEP_FMT_128 \"%02X%02X%02X%02X-%02X%02X%02X%02X-%02X%02X%02X\"\n#define WEP_STR_64(x) x[0],x[1],x[2],x[3],x[4]\n#define WEP_STR_128(x) x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],x[9],x[10]\n\n/**\n * Set a the wep key\n *\n * @priv: struct to work on\n * @idx: index of the key we want to set\n * @key: ptr to the key data to set\n * @len: length of the buffer at @key\n * @batch_mode: FIXME perform the operation in batch mode, not\n *              disabling the device.\n *\n * @returns 0 if OK, < 0 errno code on error.\n *\n * Fill out a command structure with the new wep key, length an\n * index and send it down the wire.\n */\nstatic int ipw2100_set_key(struct ipw2100_priv *priv,\n\t\t\t   int idx, char *key, int len, int batch_mode)\n{\n\tint keylen = len ? (len <= 5 ? 5 : 13) : 0;\n\tstruct host_command cmd = {\n\t\t.host_command = WEP_KEY_INFO,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = sizeof(struct ipw2100_wep_key),\n\t};\n\tstruct ipw2100_wep_key *wep_key = (void *)cmd.host_command_parameters;\n\tint err;\n\n\tIPW_DEBUG_HC(\"WEP_KEY_INFO: index = %d, len = %d/%d\\n\",\n\t\t     idx, keylen, len);\n\n\t/* NOTE: We don't check cached values in case the firmware was reset\n\t * or some other problem is occurring.  If the user is setting the key,\n\t * then we push the change */\n\n\twep_key->idx = idx;\n\twep_key->len = keylen;\n\n\tif (keylen) {\n\t\tmemcpy(wep_key->key, key, len);\n\t\tmemset(wep_key->key + len, 0, keylen - len);\n\t}\n\n\t/* Will be optimized out on debug not being configured in */\n\tif (keylen == 0)\n\t\tIPW_DEBUG_WEP(\"%s: Clearing key %d\\n\",\n\t\t\t      priv->net_dev->name, wep_key->idx);\n\telse if (keylen == 5)\n\t\tIPW_DEBUG_WEP(\"%s: idx: %d, len: %d key: \" WEP_FMT_64 \"\\n\",\n\t\t\t      priv->net_dev->name, wep_key->idx, wep_key->len,\n\t\t\t      WEP_STR_64(wep_key->key));\n\telse\n\t\tIPW_DEBUG_WEP(\"%s: idx: %d, len: %d key: \" WEP_FMT_128\n\t\t\t      \"\\n\",\n\t\t\t      priv->net_dev->name, wep_key->idx, wep_key->len,\n\t\t\t      WEP_STR_128(wep_key->key));\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\t/* FIXME: IPG: shouldn't this prink be in _disable_adapter()? */\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR DRV_NAME\n\t\t\t       \": %s: Could not disable adapter %d\\n\",\n\t\t\t       priv->net_dev->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t/* send cmd to firmware */\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tif (!batch_mode) {\n\t\tint err2 = ipw2100_enable_adapter(priv);\n\t\tif (err == 0)\n\t\t\terr = err2;\n\t}\n\treturn err;\n}\n\nstatic int ipw2100_set_key_index(struct ipw2100_priv *priv,\n\t\t\t\t int idx, int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = WEP_KEY_INDEX,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4,\n\t\t.host_command_parameters = {idx},\n\t};\n\tint err;\n\n\tIPW_DEBUG_HC(\"WEP_KEY_INDEX: index = %d\\n\", idx);\n\n\tif (idx < 0 || idx > 3)\n\t\treturn -EINVAL;\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR DRV_NAME\n\t\t\t       \": %s: Could not disable adapter %d\\n\",\n\t\t\t       priv->net_dev->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t/* send cmd to firmware */\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tif (!batch_mode)\n\t\tipw2100_enable_adapter(priv);\n\n\treturn err;\n}\n\nstatic int ipw2100_configure_security(struct ipw2100_priv *priv, int batch_mode)\n{\n\tint i, err, auth_mode, sec_level, use_group;\n\n\tif (!(priv->status & STATUS_RUNNING))\n\t\treturn 0;\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!priv->ieee->sec.enabled) {\n\t\terr =\n\t\t    ipw2100_set_security_information(priv, IPW_AUTH_OPEN,\n\t\t\t\t\t\t     SEC_LEVEL_0, 0, 1);\n\t} else {\n\t\tauth_mode = IPW_AUTH_OPEN;\n\t\tif (priv->ieee->sec.flags & SEC_AUTH_MODE) {\n\t\t\tif (priv->ieee->sec.auth_mode == WLAN_AUTH_SHARED_KEY)\n\t\t\t\tauth_mode = IPW_AUTH_SHARED;\n\t\t\telse if (priv->ieee->sec.auth_mode == WLAN_AUTH_LEAP)\n\t\t\t\tauth_mode = IPW_AUTH_LEAP_CISCO_ID;\n\t\t}\n\n\t\tsec_level = SEC_LEVEL_0;\n\t\tif (priv->ieee->sec.flags & SEC_LEVEL)\n\t\t\tsec_level = priv->ieee->sec.level;\n\n\t\tuse_group = 0;\n\t\tif (priv->ieee->sec.flags & SEC_UNICAST_GROUP)\n\t\t\tuse_group = priv->ieee->sec.unicast_uses_group;\n\n\t\terr =\n\t\t    ipw2100_set_security_information(priv, auth_mode, sec_level,\n\t\t\t\t\t\t     use_group, 1);\n\t}\n\n\tif (err)\n\t\tgoto exit;\n\n\tif (priv->ieee->sec.enabled) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (!(priv->ieee->sec.flags & (1 << i))) {\n\t\t\t\tmemset(priv->ieee->sec.keys[i], 0, WEP_KEY_LEN);\n\t\t\t\tpriv->ieee->sec.key_sizes[i] = 0;\n\t\t\t} else {\n\t\t\t\terr = ipw2100_set_key(priv, i,\n\t\t\t\t\t\t      priv->ieee->sec.keys[i],\n\t\t\t\t\t\t      priv->ieee->sec.\n\t\t\t\t\t\t      key_sizes[i], 1);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tipw2100_set_key_index(priv, priv->ieee->crypt_info.tx_keyidx, 1);\n\t}\n\n\t/* Always enable privacy so the Host can filter WEP packets if\n\t * encrypted data is sent up */\n\terr =\n\t    ipw2100_set_wep_flags(priv,\n\t\t\t\t  priv->ieee->sec.\n\t\t\t\t  enabled ? IPW_PRIVACY_CAPABLE : 0, 1);\n\tif (err)\n\t\tgoto exit;\n\n\tpriv->status &= ~STATUS_SECURITY_UPDATED;\n\n      exit:\n\tif (!batch_mode)\n\t\tipw2100_enable_adapter(priv);\n\n\treturn err;\n}\n\nstatic void ipw2100_security_work(struct work_struct *work)\n{\n\tstruct ipw2100_priv *priv =\n\t\tcontainer_of(work, struct ipw2100_priv, security_work.work);\n\n\t/* If we happen to have reconnected before we get a chance to\n\t * process this, then update the security settings--which causes\n\t * a disassociation to occur */\n\tif (!(priv->status & STATUS_ASSOCIATED) &&\n\t    priv->status & STATUS_SECURITY_UPDATED)\n\t\tipw2100_configure_security(priv, 0);\n}\n\nstatic void shim__set_security(struct net_device *dev,\n\t\t\t       struct libipw_security *sec)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint i;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED))\n\t\tgoto done;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (sec->flags & (1 << i)) {\n\t\t\tpriv->ieee->sec.key_sizes[i] = sec->key_sizes[i];\n\t\t\tif (sec->key_sizes[i] == 0)\n\t\t\t\tpriv->ieee->sec.flags &= ~(1 << i);\n\t\t\telse\n\t\t\t\tmemcpy(priv->ieee->sec.keys[i], sec->keys[i],\n\t\t\t\t       sec->key_sizes[i]);\n\t\t\tif (sec->level == SEC_LEVEL_1) {\n\t\t\t\tpriv->ieee->sec.flags |= (1 << i);\n\t\t\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t\t\t} else\n\t\t\t\tpriv->ieee->sec.flags &= ~(1 << i);\n\t\t}\n\t}\n\n\tif ((sec->flags & SEC_ACTIVE_KEY) &&\n\t    priv->ieee->sec.active_key != sec->active_key) {\n\t\tpriv->ieee->sec.active_key = sec->active_key;\n\t\tpriv->ieee->sec.flags |= SEC_ACTIVE_KEY;\n\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t}\n\n\tif ((sec->flags & SEC_AUTH_MODE) &&\n\t    (priv->ieee->sec.auth_mode != sec->auth_mode)) {\n\t\tpriv->ieee->sec.auth_mode = sec->auth_mode;\n\t\tpriv->ieee->sec.flags |= SEC_AUTH_MODE;\n\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t}\n\n\tif (sec->flags & SEC_ENABLED && priv->ieee->sec.enabled != sec->enabled) {\n\t\tpriv->ieee->sec.flags |= SEC_ENABLED;\n\t\tpriv->ieee->sec.enabled = sec->enabled;\n\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t}\n\n\tif (sec->flags & SEC_ENCRYPT)\n\t\tpriv->ieee->sec.encrypt = sec->encrypt;\n\n\tif (sec->flags & SEC_LEVEL && priv->ieee->sec.level != sec->level) {\n\t\tpriv->ieee->sec.level = sec->level;\n\t\tpriv->ieee->sec.flags |= SEC_LEVEL;\n\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t}\n\n\tIPW_DEBUG_WEP(\"Security flags: %c %c%c%c%c %c%c%c%c\\n\",\n\t\t      priv->ieee->sec.flags & (1 << 8) ? '1' : '0',\n\t\t      priv->ieee->sec.flags & (1 << 7) ? '1' : '0',\n\t\t      priv->ieee->sec.flags & (1 << 6) ? '1' : '0',\n\t\t      priv->ieee->sec.flags & (1 << 5) ? '1' : '0',\n\t\t      priv->ieee->sec.flags & (1 << 4) ? '1' : '0',\n\t\t      priv->ieee->sec.flags & (1 << 3) ? '1' : '0',\n\t\t      priv->ieee->sec.flags & (1 << 2) ? '1' : '0',\n\t\t      priv->ieee->sec.flags & (1 << 1) ? '1' : '0',\n\t\t      priv->ieee->sec.flags & (1 << 0) ? '1' : '0');\n\n/* As a temporary work around to enable WPA until we figure out why\n * wpa_supplicant toggles the security capability of the driver, which\n * forces a disassociation with force_update...\n *\n *\tif (force_update || !(priv->status & STATUS_ASSOCIATED))*/\n\tif (!(priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING)))\n\t\tipw2100_configure_security(priv, 0);\n      done:\n\tmutex_unlock(&priv->action_mutex);\n}\n\nstatic int ipw2100_adapter_setup(struct ipw2100_priv *priv)\n{\n\tint err;\n\tint batch_mode = 1;\n\tu8 *bssid;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\terr = ipw2100_disable_adapter(priv);\n\tif (err)\n\t\treturn err;\n#ifdef CONFIG_IPW2100_MONITOR\n\tif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\n\t\terr = ipw2100_set_channel(priv, priv->channel, batch_mode);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tIPW_DEBUG_INFO(\"exit\\n\");\n\n\t\treturn 0;\n\t}\n#endif\t\t\t\t/* CONFIG_IPW2100_MONITOR */\n\n\terr = ipw2100_read_mac_address(priv);\n\tif (err)\n\t\treturn -EIO;\n\n\terr = ipw2100_set_mac_address(priv, batch_mode);\n\tif (err)\n\t\treturn err;\n\n\terr = ipw2100_set_port_type(priv, priv->ieee->iw_mode, batch_mode);\n\tif (err)\n\t\treturn err;\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\terr = ipw2100_set_channel(priv, priv->channel, batch_mode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = ipw2100_system_config(priv, batch_mode);\n\tif (err)\n\t\treturn err;\n\n\terr = ipw2100_set_tx_rates(priv, priv->tx_rates, batch_mode);\n\tif (err)\n\t\treturn err;\n\n\t/* Default to power mode OFF */\n\terr = ipw2100_set_power_mode(priv, IPW_POWER_MODE_CAM);\n\tif (err)\n\t\treturn err;\n\n\terr = ipw2100_set_rts_threshold(priv, priv->rts_threshold);\n\tif (err)\n\t\treturn err;\n\n\tif (priv->config & CFG_STATIC_BSSID)\n\t\tbssid = priv->bssid;\n\telse\n\t\tbssid = NULL;\n\terr = ipw2100_set_mandatory_bssid(priv, bssid, batch_mode);\n\tif (err)\n\t\treturn err;\n\n\tif (priv->config & CFG_STATIC_ESSID)\n\t\terr = ipw2100_set_essid(priv, priv->essid, priv->essid_len,\n\t\t\t\t\tbatch_mode);\n\telse\n\t\terr = ipw2100_set_essid(priv, NULL, 0, batch_mode);\n\tif (err)\n\t\treturn err;\n\n\terr = ipw2100_configure_security(priv, batch_mode);\n\tif (err)\n\t\treturn err;\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\terr =\n\t\t    ipw2100_set_ibss_beacon_interval(priv,\n\t\t\t\t\t\t     priv->beacon_interval,\n\t\t\t\t\t\t     batch_mode);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = ipw2100_set_tx_power(priv, priv->tx_power);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/*\n\t   err = ipw2100_set_fragmentation_threshold(\n\t   priv, priv->frag_threshold, batch_mode);\n\t   if (err)\n\t   return err;\n\t */\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\n\treturn 0;\n}\n\n/*************************************************************************\n *\n * EXTERNALLY CALLED METHODS\n *\n *************************************************************************/\n\n/* This method is called by the network layer -- not to be confused with\n * ipw2100_set_mac_address() declared above called by this driver (and this\n * method as well) to talk to the firmware */\nstatic int ipw2100_set_address(struct net_device *dev, void *p)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct sockaddr *addr = p;\n\tint err = 0;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tmutex_lock(&priv->action_mutex);\n\n\tpriv->config |= CFG_CUSTOM_MAC;\n\tmemcpy(priv->mac_addr, addr->sa_data, ETH_ALEN);\n\n\terr = ipw2100_set_mac_address(priv, 0);\n\tif (err)\n\t\tgoto done;\n\n\tpriv->reset_backoff = 0;\n\tmutex_unlock(&priv->action_mutex);\n\tipw2100_reset_adapter(&priv->reset_work.work);\n\treturn 0;\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_open(struct net_device *dev)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tunsigned long flags;\n\tIPW_DEBUG_INFO(\"dev->open\\n\");\n\n\tspin_lock_irqsave(&priv->low_lock, flags);\n\tif (priv->status & STATUS_ASSOCIATED) {\n\t\tnetif_carrier_on(dev);\n\t\tnetif_start_queue(dev);\n\t}\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\n\treturn 0;\n}\n\nstatic int ipw2100_close(struct net_device *dev)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tunsigned long flags;\n\tstruct list_head *element;\n\tstruct ipw2100_tx_packet *packet;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tspin_lock_irqsave(&priv->low_lock, flags);\n\n\tif (priv->status & STATUS_ASSOCIATED)\n\t\tnetif_carrier_off(dev);\n\tnetif_stop_queue(dev);\n\n\t/* Flush the TX queue ... */\n\twhile (!list_empty(&priv->tx_pend_list)) {\n\t\telement = priv->tx_pend_list.next;\n\t\tpacket = list_entry(element, struct ipw2100_tx_packet, list);\n\n\t\tlist_del(element);\n\t\tDEC_STAT(&priv->tx_pend_stat);\n\n\t\tlibipw_txb_free(packet->info.d_struct.txb);\n\t\tpacket->info.d_struct.txb = NULL;\n\n\t\tlist_add_tail(element, &priv->tx_free_list);\n\t\tINC_STAT(&priv->tx_free_stat);\n\t}\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\n\treturn 0;\n}\n\n/*\n * TODO:  Fix this function... its just wrong\n */\nstatic void ipw2100_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\tdev->stats.tx_errors++;\n\n#ifdef CONFIG_IPW2100_MONITOR\n\tif (priv->ieee->iw_mode == IW_MODE_MONITOR)\n\t\treturn;\n#endif\n\n\tIPW_DEBUG_INFO(\"%s: TX timed out.  Scheduling firmware restart.\\n\",\n\t\t       dev->name);\n\tschedule_reset(priv);\n}\n\nstatic int ipw2100_wpa_enable(struct ipw2100_priv *priv, int value)\n{\n\t/* This is called when wpa_supplicant loads and closes the driver\n\t * interface. */\n\tpriv->ieee->wpa_enabled = value;\n\treturn 0;\n}\n\nstatic int ipw2100_wpa_set_auth_algs(struct ipw2100_priv *priv, int value)\n{\n\n\tstruct libipw_device *ieee = priv->ieee;\n\tstruct libipw_security sec = {\n\t\t.flags = SEC_AUTH_MODE,\n\t};\n\tint ret = 0;\n\n\tif (value & IW_AUTH_ALG_SHARED_KEY) {\n\t\tsec.auth_mode = WLAN_AUTH_SHARED_KEY;\n\t\tieee->open_wep = 0;\n\t} else if (value & IW_AUTH_ALG_OPEN_SYSTEM) {\n\t\tsec.auth_mode = WLAN_AUTH_OPEN;\n\t\tieee->open_wep = 1;\n\t} else if (value & IW_AUTH_ALG_LEAP) {\n\t\tsec.auth_mode = WLAN_AUTH_LEAP;\n\t\tieee->open_wep = 1;\n\t} else\n\t\treturn -EINVAL;\n\n\tif (ieee->set_security)\n\t\tieee->set_security(ieee->dev, &sec);\n\telse\n\t\tret = -EOPNOTSUPP;\n\n\treturn ret;\n}\n\nstatic void ipw2100_wpa_assoc_frame(struct ipw2100_priv *priv,\n\t\t\t\t    char *wpa_ie, int wpa_ie_len)\n{\n\n\tstruct ipw2100_wpa_assoc_frame frame;\n\n\tframe.fixed_ie_mask = 0;\n\n\t/* copy WPA IE */\n\tmemcpy(frame.var_ie, wpa_ie, wpa_ie_len);\n\tframe.var_ie_len = wpa_ie_len;\n\n\t/* make sure WPA is enabled */\n\tipw2100_wpa_enable(priv, 1);\n\tipw2100_set_wpa_ie(priv, &frame, 0);\n}\n\nstatic void ipw_ethtool_get_drvinfo(struct net_device *dev,\n\t\t\t\t    struct ethtool_drvinfo *info)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tchar fw_ver[64], ucode_ver[64];\n\n\tstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\n\n\tipw2100_get_fwversion(priv, fw_ver, sizeof(fw_ver));\n\tipw2100_get_ucodeversion(priv, ucode_ver, sizeof(ucode_ver));\n\n\tsnprintf(info->fw_version, sizeof(info->fw_version), \"%s:%d:%s\",\n\t\t fw_ver, priv->eeprom_version, ucode_ver);\n\n\tstrlcpy(info->bus_info, pci_name(priv->pci_dev),\n\t\tsizeof(info->bus_info));\n}\n\nstatic u32 ipw2100_ethtool_get_link(struct net_device *dev)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\treturn (priv->status & STATUS_ASSOCIATED) ? 1 : 0;\n}\n\nstatic const struct ethtool_ops ipw2100_ethtool_ops = {\n\t.get_link = ipw2100_ethtool_get_link,\n\t.get_drvinfo = ipw_ethtool_get_drvinfo,\n};\n\nstatic void ipw2100_hang_check(struct work_struct *work)\n{\n\tstruct ipw2100_priv *priv =\n\t\tcontainer_of(work, struct ipw2100_priv, hang_check.work);\n\tunsigned long flags;\n\tu32 rtc = 0xa5a5a5a5;\n\tu32 len = sizeof(rtc);\n\tint restart = 0;\n\n\tspin_lock_irqsave(&priv->low_lock, flags);\n\n\tif (priv->fatal_error != 0) {\n\t\t/* If fatal_error is set then we need to restart */\n\t\tIPW_DEBUG_INFO(\"%s: Hardware fatal error detected.\\n\",\n\t\t\t       priv->net_dev->name);\n\n\t\trestart = 1;\n\t} else if (ipw2100_get_ordinal(priv, IPW_ORD_RTC_TIME, &rtc, &len) ||\n\t\t   (rtc == priv->last_rtc)) {\n\t\t/* Check if firmware is hung */\n\t\tIPW_DEBUG_INFO(\"%s: Firmware RTC stalled.\\n\",\n\t\t\t       priv->net_dev->name);\n\n\t\trestart = 1;\n\t}\n\n\tif (restart) {\n\t\t/* Kill timer */\n\t\tpriv->stop_hang_check = 1;\n\t\tpriv->hangs++;\n\n\t\t/* Restart the NIC */\n\t\tschedule_reset(priv);\n\t}\n\n\tpriv->last_rtc = rtc;\n\n\tif (!priv->stop_hang_check)\n\t\tschedule_delayed_work(&priv->hang_check, HZ / 2);\n\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n}\n\nstatic void ipw2100_rf_kill(struct work_struct *work)\n{\n\tstruct ipw2100_priv *priv =\n\t\tcontainer_of(work, struct ipw2100_priv, rf_kill.work);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->low_lock, flags);\n\n\tif (rf_kill_active(priv)) {\n\t\tIPW_DEBUG_RF_KILL(\"RF Kill active, rescheduling GPIO check\\n\");\n\t\tif (!priv->stop_rf_kill)\n\t\t\tschedule_delayed_work(&priv->rf_kill,\n\t\t\t\t\t      round_jiffies_relative(HZ));\n\t\tgoto exit_unlock;\n\t}\n\n\t/* RF Kill is now disabled, so bring the device back up */\n\n\tif (!(priv->status & STATUS_RF_KILL_MASK)) {\n\t\tIPW_DEBUG_RF_KILL(\"HW RF Kill no longer active, restarting \"\n\t\t\t\t  \"device\\n\");\n\t\tschedule_reset(priv);\n\t} else\n\t\tIPW_DEBUG_RF_KILL(\"HW RF Kill deactivated.  SW RF Kill still \"\n\t\t\t\t  \"enabled\\n\");\n\n      exit_unlock:\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n}\n\nstatic void ipw2100_irq_tasklet(struct tasklet_struct *t);\n\nstatic const struct net_device_ops ipw2100_netdev_ops = {\n\t.ndo_open\t\t= ipw2100_open,\n\t.ndo_stop\t\t= ipw2100_close,\n\t.ndo_start_xmit\t\t= libipw_xmit,\n\t.ndo_tx_timeout\t\t= ipw2100_tx_timeout,\n\t.ndo_set_mac_address\t= ipw2100_set_address,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\n/* Look into using netdev destructor to shutdown libipw? */\n\nstatic struct net_device *ipw2100_alloc_device(struct pci_dev *pci_dev,\n\t\t\t\t\t       void __iomem * ioaddr)\n{\n\tstruct ipw2100_priv *priv;\n\tstruct net_device *dev;\n\n\tdev = alloc_libipw(sizeof(struct ipw2100_priv), 0);\n\tif (!dev)\n\t\treturn NULL;\n\tpriv = libipw_priv(dev);\n\tpriv->ieee = netdev_priv(dev);\n\tpriv->pci_dev = pci_dev;\n\tpriv->net_dev = dev;\n\tpriv->ioaddr = ioaddr;\n\n\tpriv->ieee->hard_start_xmit = ipw2100_tx;\n\tpriv->ieee->set_security = shim__set_security;\n\n\tpriv->ieee->perfect_rssi = -20;\n\tpriv->ieee->worst_rssi = -85;\n\n\tdev->netdev_ops = &ipw2100_netdev_ops;\n\tdev->ethtool_ops = &ipw2100_ethtool_ops;\n\tdev->wireless_handlers = &ipw2100_wx_handler_def;\n\tpriv->wireless_data.libipw = priv->ieee;\n\tdev->wireless_data = &priv->wireless_data;\n\tdev->watchdog_timeo = 3 * HZ;\n\tdev->irq = 0;\n\tdev->min_mtu = 68;\n\tdev->max_mtu = LIBIPW_DATA_LEN;\n\n\t/* NOTE: We don't use the wireless_handlers hook\n\t * in dev as the system will start throwing WX requests\n\t * to us before we're actually initialized and it just\n\t * ends up causing problems.  So, we just handle\n\t * the WX extensions through the ipw2100_ioctl interface */\n\n\t/* memset() puts everything to 0, so we only have explicitly set\n\t * those values that need to be something else */\n\n\t/* If power management is turned on, default to AUTO mode */\n\tpriv->power_mode = IPW_POWER_AUTO;\n\n#ifdef CONFIG_IPW2100_MONITOR\n\tpriv->config |= CFG_CRC_CHECK;\n#endif\n\tpriv->ieee->wpa_enabled = 0;\n\tpriv->ieee->drop_unencrypted = 0;\n\tpriv->ieee->privacy_invoked = 0;\n\tpriv->ieee->ieee802_1x = 1;\n\n\t/* Set module parameters */\n\tswitch (network_mode) {\n\tcase 1:\n\t\tpriv->ieee->iw_mode = IW_MODE_ADHOC;\n\t\tbreak;\n#ifdef CONFIG_IPW2100_MONITOR\n\tcase 2:\n\t\tpriv->ieee->iw_mode = IW_MODE_MONITOR;\n\t\tbreak;\n#endif\n\tdefault:\n\tcase 0:\n\t\tpriv->ieee->iw_mode = IW_MODE_INFRA;\n\t\tbreak;\n\t}\n\n\tif (disable == 1)\n\t\tpriv->status |= STATUS_RF_KILL_SW;\n\n\tif (channel != 0 &&\n\t    ((channel >= REG_MIN_CHANNEL) && (channel <= REG_MAX_CHANNEL))) {\n\t\tpriv->config |= CFG_STATIC_CHANNEL;\n\t\tpriv->channel = channel;\n\t}\n\n\tif (associate)\n\t\tpriv->config |= CFG_ASSOCIATE;\n\n\tpriv->beacon_interval = DEFAULT_BEACON_INTERVAL;\n\tpriv->short_retry_limit = DEFAULT_SHORT_RETRY_LIMIT;\n\tpriv->long_retry_limit = DEFAULT_LONG_RETRY_LIMIT;\n\tpriv->rts_threshold = DEFAULT_RTS_THRESHOLD | RTS_DISABLED;\n\tpriv->frag_threshold = DEFAULT_FTS | FRAG_DISABLED;\n\tpriv->tx_power = IPW_TX_POWER_DEFAULT;\n\tpriv->tx_rates = DEFAULT_TX_RATES;\n\n\tstrcpy(priv->nick, \"ipw2100\");\n\n\tspin_lock_init(&priv->low_lock);\n\tmutex_init(&priv->action_mutex);\n\tmutex_init(&priv->adapter_mutex);\n\n\tinit_waitqueue_head(&priv->wait_command_queue);\n\n\tnetif_carrier_off(dev);\n\n\tINIT_LIST_HEAD(&priv->msg_free_list);\n\tINIT_LIST_HEAD(&priv->msg_pend_list);\n\tINIT_STAT(&priv->msg_free_stat);\n\tINIT_STAT(&priv->msg_pend_stat);\n\n\tINIT_LIST_HEAD(&priv->tx_free_list);\n\tINIT_LIST_HEAD(&priv->tx_pend_list);\n\tINIT_STAT(&priv->tx_free_stat);\n\tINIT_STAT(&priv->tx_pend_stat);\n\n\tINIT_LIST_HEAD(&priv->fw_pend_list);\n\tINIT_STAT(&priv->fw_pend_stat);\n\n\tINIT_DELAYED_WORK(&priv->reset_work, ipw2100_reset_adapter);\n\tINIT_DELAYED_WORK(&priv->security_work, ipw2100_security_work);\n\tINIT_DELAYED_WORK(&priv->wx_event_work, ipw2100_wx_event_work);\n\tINIT_DELAYED_WORK(&priv->hang_check, ipw2100_hang_check);\n\tINIT_DELAYED_WORK(&priv->rf_kill, ipw2100_rf_kill);\n\tINIT_DELAYED_WORK(&priv->scan_event, ipw2100_scan_event);\n\n\ttasklet_setup(&priv->irq_tasklet, ipw2100_irq_tasklet);\n\n\t/* NOTE:  We do not start the deferred work for status checks yet */\n\tpriv->stop_rf_kill = 1;\n\tpriv->stop_hang_check = 1;\n\n\treturn dev;\n}\n\nstatic int ipw2100_pci_init_one(struct pci_dev *pci_dev,\n\t\t\t\tconst struct pci_device_id *ent)\n{\n\tvoid __iomem *ioaddr;\n\tstruct net_device *dev = NULL;\n\tstruct ipw2100_priv *priv = NULL;\n\tint err = 0;\n\tint registered = 0;\n\tu32 val;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tif (!(pci_resource_flags(pci_dev, 0) & IORESOURCE_MEM)) {\n\t\tIPW_DEBUG_INFO(\"weird - resource type is not memory\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tioaddr = pci_iomap(pci_dev, 0, 0);\n\tif (!ioaddr) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \"Error calling ioremap.\\n\");\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\t/* allocate and initialize our net_device */\n\tdev = ipw2100_alloc_device(pci_dev, ioaddr);\n\tif (!dev) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \"Error calling ipw2100_alloc_device.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t/* set up PCI mappings for device */\n\terr = pci_enable_device(pci_dev);\n\tif (err) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \"Error calling pci_enable_device.\\n\");\n\t\treturn err;\n\t}\n\n\tpriv = libipw_priv(dev);\n\n\tpci_set_master(pci_dev);\n\tpci_set_drvdata(pci_dev, priv);\n\n\terr = dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \"Error calling pci_set_dma_mask.\\n\");\n\t\tpci_disable_device(pci_dev);\n\t\treturn err;\n\t}\n\n\terr = pci_request_regions(pci_dev, DRV_NAME);\n\tif (err) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \"Error calling pci_request_regions.\\n\");\n\t\tpci_disable_device(pci_dev);\n\t\treturn err;\n\t}\n\n\t/* We disable the RETRY_TIMEOUT register (0x41) to keep\n\t * PCI Tx retries from interfering with C3 CPU state */\n\tpci_read_config_dword(pci_dev, 0x40, &val);\n\tif ((val & 0x0000ff00) != 0)\n\t\tpci_write_config_dword(pci_dev, 0x40, val & 0xffff00ff);\n\n\tif (!ipw2100_hw_is_adapter_in_system(dev)) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \"Device not found via register read.\\n\");\n\t\terr = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tSET_NETDEV_DEV(dev, &pci_dev->dev);\n\n\t/* Force interrupts to be shut off on the device */\n\tpriv->status |= STATUS_INT_ENABLED;\n\tipw2100_disable_interrupts(priv);\n\n\t/* Allocate and initialize the Tx/Rx queues and lists */\n\tif (ipw2100_queues_allocate(priv)) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \"Error calling ipw2100_queues_allocate.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tipw2100_queues_initialize(priv);\n\n\terr = request_irq(pci_dev->irq,\n\t\t\t  ipw2100_interrupt, IRQF_SHARED, dev->name, priv);\n\tif (err) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \"Error calling request_irq: %d.\\n\", pci_dev->irq);\n\t\tgoto fail;\n\t}\n\tdev->irq = pci_dev->irq;\n\n\tIPW_DEBUG_INFO(\"Attempting to register device...\\n\");\n\n\tprintk(KERN_INFO DRV_NAME\n\t       \": Detected Intel PRO/Wireless 2100 Network Connection\\n\");\n\n\terr = ipw2100_up(priv, 1);\n\tif (err)\n\t\tgoto fail;\n\n\terr = ipw2100_wdev_init(dev);\n\tif (err)\n\t\tgoto fail;\n\tregistered = 1;\n\n\t/* Bring up the interface.  Pre 0.46, after we registered the\n\t * network device we would call ipw2100_up.  This introduced a race\n\t * condition with newer hotplug configurations (network was coming\n\t * up and making calls before the device was initialized).\n\t */\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \"Error calling register_netdev.\\n\");\n\t\tgoto fail;\n\t}\n\tregistered = 2;\n\n\tmutex_lock(&priv->action_mutex);\n\n\tIPW_DEBUG_INFO(\"%s: Bound to %s\\n\", dev->name, pci_name(pci_dev));\n\n\t/* perform this after register_netdev so that dev->name is set */\n\terr = sysfs_create_group(&pci_dev->dev.kobj, &ipw2100_attribute_group);\n\tif (err)\n\t\tgoto fail_unlock;\n\n\t/* If the RF Kill switch is disabled, go ahead and complete the\n\t * startup sequence */\n\tif (!(priv->status & STATUS_RF_KILL_MASK)) {\n\t\t/* Enable the adapter - sends HOST_COMPLETE */\n\t\tif (ipw2100_enable_adapter(priv)) {\n\t\t\tprintk(KERN_WARNING DRV_NAME\n\t\t\t       \": %s: failed in call to enable adapter.\\n\",\n\t\t\t       priv->net_dev->name);\n\t\t\tipw2100_hw_stop_adapter(priv);\n\t\t\terr = -EIO;\n\t\t\tgoto fail_unlock;\n\t\t}\n\n\t\t/* Start a scan . . . */\n\t\tipw2100_set_scan_options(priv);\n\t\tipw2100_start_scan(priv);\n\t}\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\n\tpriv->status |= STATUS_INITIALIZED;\n\n\tmutex_unlock(&priv->action_mutex);\nout:\n\treturn err;\n\n      fail_unlock:\n\tmutex_unlock(&priv->action_mutex);\n      fail:\n\tif (dev) {\n\t\tif (registered >= 2)\n\t\t\tunregister_netdev(dev);\n\n\t\tif (registered) {\n\t\t\twiphy_unregister(priv->ieee->wdev.wiphy);\n\t\t\tkfree(priv->ieee->bg_band.channels);\n\t\t}\n\n\t\tipw2100_hw_stop_adapter(priv);\n\n\t\tipw2100_disable_interrupts(priv);\n\n\t\tif (dev->irq)\n\t\t\tfree_irq(dev->irq, priv);\n\n\t\tipw2100_kill_works(priv);\n\n\t\t/* These are safe to call even if they weren't allocated */\n\t\tipw2100_queues_free(priv);\n\t\tsysfs_remove_group(&pci_dev->dev.kobj,\n\t\t\t\t   &ipw2100_attribute_group);\n\n\t\tfree_libipw(dev, 0);\n\t}\n\n\tpci_iounmap(pci_dev, ioaddr);\n\n\tpci_release_regions(pci_dev);\n\tpci_disable_device(pci_dev);\n\tgoto out;\n}\n\nstatic void ipw2100_pci_remove_one(struct pci_dev *pci_dev)\n{\n\tstruct ipw2100_priv *priv = pci_get_drvdata(pci_dev);\n\tstruct net_device *dev = priv->net_dev;\n\n\tmutex_lock(&priv->action_mutex);\n\n\tpriv->status &= ~STATUS_INITIALIZED;\n\n\tsysfs_remove_group(&pci_dev->dev.kobj, &ipw2100_attribute_group);\n\n#ifdef CONFIG_PM\n\tif (ipw2100_firmware.version)\n\t\tipw2100_release_firmware(priv, &ipw2100_firmware);\n#endif\n\t/* Take down the hardware */\n\tipw2100_down(priv);\n\n\t/* Release the mutex so that the network subsystem can\n\t * complete any needed calls into the driver... */\n\tmutex_unlock(&priv->action_mutex);\n\n\t/* Unregister the device first - this results in close()\n\t * being called if the device is open.  If we free storage\n\t * first, then close() will crash.\n\t * FIXME: remove the comment above. */\n\tunregister_netdev(dev);\n\n\tipw2100_kill_works(priv);\n\n\tipw2100_queues_free(priv);\n\n\t/* Free potential debugging firmware snapshot */\n\tipw2100_snapshot_free(priv);\n\n\tfree_irq(dev->irq, priv);\n\n\tpci_iounmap(pci_dev, priv->ioaddr);\n\n\t/* wiphy_unregister needs to be here, before free_libipw */\n\twiphy_unregister(priv->ieee->wdev.wiphy);\n\tkfree(priv->ieee->bg_band.channels);\n\tfree_libipw(dev, 0);\n\n\tpci_release_regions(pci_dev);\n\tpci_disable_device(pci_dev);\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n}\n\nstatic int __maybe_unused ipw2100_suspend(struct device *dev_d)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(dev_d);\n\tstruct net_device *dev = priv->net_dev;\n\n\tIPW_DEBUG_INFO(\"%s: Going into suspend...\\n\", dev->name);\n\n\tmutex_lock(&priv->action_mutex);\n\tif (priv->status & STATUS_INITIALIZED) {\n\t\t/* Take down the device; powers it off, etc. */\n\t\tipw2100_down(priv);\n\t}\n\n\t/* Remove the PRESENT state of the device */\n\tnetif_device_detach(dev);\n\n\tpriv->suspend_at = ktime_get_boottime_seconds();\n\n\tmutex_unlock(&priv->action_mutex);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ipw2100_resume(struct device *dev_d)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev_d);\n\tstruct ipw2100_priv *priv = pci_get_drvdata(pci_dev);\n\tstruct net_device *dev = priv->net_dev;\n\tu32 val;\n\n\tif (IPW2100_PM_DISABLED)\n\t\treturn 0;\n\n\tmutex_lock(&priv->action_mutex);\n\n\tIPW_DEBUG_INFO(\"%s: Coming out of suspend...\\n\", dev->name);\n\n\t/*\n\t * Suspend/Resume resets the PCI configuration space, so we have to\n\t * re-disable the RETRY_TIMEOUT register (0x41) to keep PCI Tx retries\n\t * from interfering with C3 CPU state. pci_restore_state won't help\n\t * here since it only restores the first 64 bytes pci config header.\n\t */\n\tpci_read_config_dword(pci_dev, 0x40, &val);\n\tif ((val & 0x0000ff00) != 0)\n\t\tpci_write_config_dword(pci_dev, 0x40, val & 0xffff00ff);\n\n\t/* Set the device back into the PRESENT state; this will also wake\n\t * the queue of needed */\n\tnetif_device_attach(dev);\n\n\tpriv->suspend_time = ktime_get_boottime_seconds() - priv->suspend_at;\n\n\t/* Bring the device back up */\n\tif (!(priv->status & STATUS_RF_KILL_SW))\n\t\tipw2100_up(priv, 0);\n\n\tmutex_unlock(&priv->action_mutex);\n\n\treturn 0;\n}\n\nstatic void ipw2100_shutdown(struct pci_dev *pci_dev)\n{\n\tstruct ipw2100_priv *priv = pci_get_drvdata(pci_dev);\n\n\t/* Take down the device; powers it off, etc. */\n\tipw2100_down(priv);\n\n\tpci_disable_device(pci_dev);\n}\n\n#define IPW2100_DEV_ID(x) { PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, x }\n\nstatic const struct pci_device_id ipw2100_pci_id_table[] = {\n\tIPW2100_DEV_ID(0x2520),\t/* IN 2100A mPCI 3A */\n\tIPW2100_DEV_ID(0x2521),\t/* IN 2100A mPCI 3B */\n\tIPW2100_DEV_ID(0x2524),\t/* IN 2100A mPCI 3B */\n\tIPW2100_DEV_ID(0x2525),\t/* IN 2100A mPCI 3B */\n\tIPW2100_DEV_ID(0x2526),\t/* IN 2100A mPCI Gen A3 */\n\tIPW2100_DEV_ID(0x2522),\t/* IN 2100 mPCI 3B */\n\tIPW2100_DEV_ID(0x2523),\t/* IN 2100 mPCI 3A */\n\tIPW2100_DEV_ID(0x2527),\t/* IN 2100 mPCI 3B */\n\tIPW2100_DEV_ID(0x2528),\t/* IN 2100 mPCI 3B */\n\tIPW2100_DEV_ID(0x2529),\t/* IN 2100 mPCI 3B */\n\tIPW2100_DEV_ID(0x252B),\t/* IN 2100 mPCI 3A */\n\tIPW2100_DEV_ID(0x252C),\t/* IN 2100 mPCI 3A */\n\tIPW2100_DEV_ID(0x252D),\t/* IN 2100 mPCI 3A */\n\n\tIPW2100_DEV_ID(0x2550),\t/* IB 2100A mPCI 3B */\n\tIPW2100_DEV_ID(0x2551),\t/* IB 2100 mPCI 3B */\n\tIPW2100_DEV_ID(0x2553),\t/* IB 2100 mPCI 3B */\n\tIPW2100_DEV_ID(0x2554),\t/* IB 2100 mPCI 3B */\n\tIPW2100_DEV_ID(0x2555),\t/* IB 2100 mPCI 3B */\n\n\tIPW2100_DEV_ID(0x2560),\t/* DE 2100A mPCI 3A */\n\tIPW2100_DEV_ID(0x2562),\t/* DE 2100A mPCI 3A */\n\tIPW2100_DEV_ID(0x2563),\t/* DE 2100A mPCI 3A */\n\tIPW2100_DEV_ID(0x2561),\t/* DE 2100 mPCI 3A */\n\tIPW2100_DEV_ID(0x2565),\t/* DE 2100 mPCI 3A */\n\tIPW2100_DEV_ID(0x2566),\t/* DE 2100 mPCI 3A */\n\tIPW2100_DEV_ID(0x2567),\t/* DE 2100 mPCI 3A */\n\n\tIPW2100_DEV_ID(0x2570),\t/* GA 2100 mPCI 3B */\n\n\tIPW2100_DEV_ID(0x2580),\t/* TO 2100A mPCI 3B */\n\tIPW2100_DEV_ID(0x2582),\t/* TO 2100A mPCI 3B */\n\tIPW2100_DEV_ID(0x2583),\t/* TO 2100A mPCI 3B */\n\tIPW2100_DEV_ID(0x2581),\t/* TO 2100 mPCI 3B */\n\tIPW2100_DEV_ID(0x2585),\t/* TO 2100 mPCI 3B */\n\tIPW2100_DEV_ID(0x2586),\t/* TO 2100 mPCI 3B */\n\tIPW2100_DEV_ID(0x2587),\t/* TO 2100 mPCI 3B */\n\n\tIPW2100_DEV_ID(0x2590),\t/* SO 2100A mPCI 3B */\n\tIPW2100_DEV_ID(0x2592),\t/* SO 2100A mPCI 3B */\n\tIPW2100_DEV_ID(0x2591),\t/* SO 2100 mPCI 3B */\n\tIPW2100_DEV_ID(0x2593),\t/* SO 2100 mPCI 3B */\n\tIPW2100_DEV_ID(0x2596),\t/* SO 2100 mPCI 3B */\n\tIPW2100_DEV_ID(0x2598),\t/* SO 2100 mPCI 3B */\n\n\tIPW2100_DEV_ID(0x25A0),\t/* HP 2100 mPCI 3B */\n\t{0,},\n};\n\nMODULE_DEVICE_TABLE(pci, ipw2100_pci_id_table);\n\nstatic SIMPLE_DEV_PM_OPS(ipw2100_pm_ops, ipw2100_suspend, ipw2100_resume);\n\nstatic struct pci_driver ipw2100_pci_driver = {\n\t.name = DRV_NAME,\n\t.id_table = ipw2100_pci_id_table,\n\t.probe = ipw2100_pci_init_one,\n\t.remove = ipw2100_pci_remove_one,\n\t.driver.pm = &ipw2100_pm_ops,\n\t.shutdown = ipw2100_shutdown,\n};\n\n/**\n * Initialize the ipw2100 driver/module\n *\n * @returns 0 if ok, < 0 errno node con error.\n *\n * Note: we cannot init the /proc stuff until the PCI driver is there,\n * or we risk an unlikely race condition on someone accessing\n * uninitialized data in the PCI dev struct through /proc.\n */\nstatic int __init ipw2100_init(void)\n{\n\tint ret;\n\n\tprintk(KERN_INFO DRV_NAME \": %s, %s\\n\", DRV_DESCRIPTION, DRV_VERSION);\n\tprintk(KERN_INFO DRV_NAME \": %s\\n\", DRV_COPYRIGHT);\n\n\tcpu_latency_qos_add_request(&ipw2100_pm_qos_req, PM_QOS_DEFAULT_VALUE);\n\n\tret = pci_register_driver(&ipw2100_pci_driver);\n\tif (ret)\n\t\tgoto out;\n\n#ifdef CONFIG_IPW2100_DEBUG\n\tipw2100_debug_level = debug;\n\tret = driver_create_file(&ipw2100_pci_driver.driver,\n\t\t\t\t &driver_attr_debug_level);\n#endif\n\nout:\n\treturn ret;\n}\n\n/**\n * Cleanup ipw2100 driver registration\n */\nstatic void __exit ipw2100_exit(void)\n{\n\t/* FIXME: IPG: check that we have no instances of the devices open */\n#ifdef CONFIG_IPW2100_DEBUG\n\tdriver_remove_file(&ipw2100_pci_driver.driver,\n\t\t\t   &driver_attr_debug_level);\n#endif\n\tpci_unregister_driver(&ipw2100_pci_driver);\n\tcpu_latency_qos_remove_request(&ipw2100_pm_qos_req);\n}\n\nmodule_init(ipw2100_init);\nmodule_exit(ipw2100_exit);\n\nstatic int ipw2100_wx_get_name(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\t/*\n\t * This can be called at any time.  No action lock required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tif (!(priv->status & STATUS_ASSOCIATED))\n\t\tstrcpy(wrqu->name, \"unassociated\");\n\telse\n\t\tsnprintf(wrqu->name, IFNAMSIZ, \"IEEE 802.11b\");\n\n\tIPW_DEBUG_WX(\"Name: %s\\n\", wrqu->name);\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_freq(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct iw_freq *fwrq = &wrqu->freq;\n\tint err = 0;\n\n\tif (priv->ieee->iw_mode == IW_MODE_INFRA)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\t/* if setting by freq convert to channel */\n\tif (fwrq->e == 1) {\n\t\tif ((fwrq->m >= (int)2.412e8 && fwrq->m <= (int)2.487e8)) {\n\t\t\tint f = fwrq->m / 100000;\n\t\t\tint c = 0;\n\n\t\t\twhile ((c < REG_MAX_CHANNEL) &&\n\t\t\t       (f != ipw2100_frequencies[c]))\n\t\t\t\tc++;\n\n\t\t\t/* hack to fall through */\n\t\t\tfwrq->e = 0;\n\t\t\tfwrq->m = c + 1;\n\t\t}\n\t}\n\n\tif (fwrq->e > 0 || fwrq->m > 1000) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\t} else {\t\t/* Set the channel */\n\t\tIPW_DEBUG_WX(\"SET Freq/Channel -> %d\\n\", fwrq->m);\n\t\terr = ipw2100_set_channel(priv, fwrq->m, 0);\n\t}\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_freq(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\t/*\n\t * This can be called at any time.  No action lock required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\twrqu->freq.e = 0;\n\n\t/* If we are associated, trying to associate, or have a statically\n\t * configured CHANNEL then return that; otherwise return ANY */\n\tif (priv->config & CFG_STATIC_CHANNEL ||\n\t    priv->status & STATUS_ASSOCIATED)\n\t\twrqu->freq.m = priv->channel;\n\telse\n\t\twrqu->freq.m = 0;\n\n\tIPW_DEBUG_WX(\"GET Freq/Channel -> %d\\n\", priv->channel);\n\treturn 0;\n\n}\n\nstatic int ipw2100_wx_set_mode(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint err = 0;\n\n\tIPW_DEBUG_WX(\"SET Mode -> %d\\n\", wrqu->mode);\n\n\tif (wrqu->mode == priv->ieee->iw_mode)\n\t\treturn 0;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tswitch (wrqu->mode) {\n#ifdef CONFIG_IPW2100_MONITOR\n\tcase IW_MODE_MONITOR:\n\t\terr = ipw2100_switch_mode(priv, IW_MODE_MONITOR);\n\t\tbreak;\n#endif\t\t\t\t/* CONFIG_IPW2100_MONITOR */\n\tcase IW_MODE_ADHOC:\n\t\terr = ipw2100_switch_mode(priv, IW_MODE_ADHOC);\n\t\tbreak;\n\tcase IW_MODE_INFRA:\n\tcase IW_MODE_AUTO:\n\tdefault:\n\t\terr = ipw2100_switch_mode(priv, IW_MODE_INFRA);\n\t\tbreak;\n\t}\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_mode(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\t/*\n\t * This can be called at any time.  No action lock required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\twrqu->mode = priv->ieee->iw_mode;\n\tIPW_DEBUG_WX(\"GET Mode -> %d\\n\", wrqu->mode);\n\n\treturn 0;\n}\n\n#define POWER_MODES 5\n\n/* Values are in microsecond */\nstatic const s32 timeout_duration[POWER_MODES] = {\n\t350000,\n\t250000,\n\t75000,\n\t37000,\n\t25000,\n};\n\nstatic const s32 period_duration[POWER_MODES] = {\n\t400000,\n\t700000,\n\t1000000,\n\t1000000,\n\t1000000\n};\n\nstatic int ipw2100_wx_get_range(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\t/*\n\t * This can be called at any time.  No action lock required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct iw_range *range = (struct iw_range *)extra;\n\tu16 val;\n\tint i, level;\n\n\twrqu->data.length = sizeof(*range);\n\tmemset(range, 0, sizeof(*range));\n\n\t/* Let's try to keep this struct in the same order as in\n\t * linux/include/wireless.h\n\t */\n\n\t/* TODO: See what values we can set, and remove the ones we can't\n\t * set, or fill them with some default data.\n\t */\n\n\t/* ~5 Mb/s real (802.11b) */\n\trange->throughput = 5 * 1000 * 1000;\n\n//      range->sensitivity;     /* signal level threshold range */\n\n\trange->max_qual.qual = 100;\n\t/* TODO: Find real max RSSI and stick here */\n\trange->max_qual.level = 0;\n\trange->max_qual.noise = 0;\n\trange->max_qual.updated = 7;\t/* Updated all three */\n\n\trange->avg_qual.qual = 70;\t/* > 8% missed beacons is 'bad' */\n\t/* TODO: Find real 'good' to 'bad' threshold value for RSSI */\n\trange->avg_qual.level = 20 + IPW2100_RSSI_TO_DBM;\n\trange->avg_qual.noise = 0;\n\trange->avg_qual.updated = 7;\t/* Updated all three */\n\n\trange->num_bitrates = RATE_COUNT;\n\n\tfor (i = 0; i < RATE_COUNT && i < IW_MAX_BITRATES; i++) {\n\t\trange->bitrate[i] = ipw2100_bg_rates[i].bitrate * 100 * 1000;\n\t}\n\n\trange->min_rts = MIN_RTS_THRESHOLD;\n\trange->max_rts = MAX_RTS_THRESHOLD;\n\trange->min_frag = MIN_FRAG_THRESHOLD;\n\trange->max_frag = MAX_FRAG_THRESHOLD;\n\n\trange->min_pmp = period_duration[0];\t/* Minimal PM period */\n\trange->max_pmp = period_duration[POWER_MODES - 1];\t/* Maximal PM period */\n\trange->min_pmt = timeout_duration[POWER_MODES - 1];\t/* Minimal PM timeout */\n\trange->max_pmt = timeout_duration[0];\t/* Maximal PM timeout */\n\n\t/* How to decode max/min PM period */\n\trange->pmp_flags = IW_POWER_PERIOD;\n\t/* How to decode max/min PM period */\n\trange->pmt_flags = IW_POWER_TIMEOUT;\n\t/* What PM options are supported */\n\trange->pm_capa = IW_POWER_TIMEOUT | IW_POWER_PERIOD;\n\n\trange->encoding_size[0] = 5;\n\trange->encoding_size[1] = 13;\t/* Different token sizes */\n\trange->num_encoding_sizes = 2;\t/* Number of entry in the list */\n\trange->max_encoding_tokens = WEP_KEYS;\t/* Max number of tokens */\n//      range->encoding_login_index;            /* token index for login token */\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\trange->txpower_capa = IW_TXPOW_DBM;\n\t\trange->num_txpower = IW_MAX_TXPOWER;\n\t\tfor (i = 0, level = (IPW_TX_POWER_MAX_DBM * 16);\n\t\t     i < IW_MAX_TXPOWER;\n\t\t     i++, level -=\n\t\t     ((IPW_TX_POWER_MAX_DBM -\n\t\t       IPW_TX_POWER_MIN_DBM) * 16) / (IW_MAX_TXPOWER - 1))\n\t\t\trange->txpower[i] = level / 16;\n\t} else {\n\t\trange->txpower_capa = 0;\n\t\trange->num_txpower = 0;\n\t}\n\n\t/* Set the Wireless Extension versions */\n\trange->we_version_compiled = WIRELESS_EXT;\n\trange->we_version_source = 18;\n\n//      range->retry_capa;      /* What retry options are supported */\n//      range->retry_flags;     /* How to decode max/min retry limit */\n//      range->r_time_flags;    /* How to decode max/min retry life */\n//      range->min_retry;       /* Minimal number of retries */\n//      range->max_retry;       /* Maximal number of retries */\n//      range->min_r_time;      /* Minimal retry lifetime */\n//      range->max_r_time;      /* Maximal retry lifetime */\n\n\trange->num_channels = FREQ_COUNT;\n\n\tval = 0;\n\tfor (i = 0; i < FREQ_COUNT; i++) {\n\t\t// TODO: Include only legal frequencies for some countries\n//              if (local->channel_mask & (1 << i)) {\n\t\trange->freq[val].i = i + 1;\n\t\trange->freq[val].m = ipw2100_frequencies[i] * 100000;\n\t\trange->freq[val].e = 1;\n\t\tval++;\n//              }\n\t\tif (val == IW_MAX_FREQUENCIES)\n\t\t\tbreak;\n\t}\n\trange->num_frequency = val;\n\n\t/* Event capability (kernel + driver) */\n\trange->event_capa[0] = (IW_EVENT_CAPA_K_0 |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWAP));\n\trange->event_capa[1] = IW_EVENT_CAPA_K_1;\n\n\trange->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |\n\t\tIW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;\n\n\tIPW_DEBUG_WX(\"GET Range\\n\");\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_wap(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint err = 0;\n\n\t// sanity checks\n\tif (wrqu->ap_addr.sa_family != ARPHRD_ETHER)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (is_broadcast_ether_addr(wrqu->ap_addr.sa_data) ||\n\t    is_zero_ether_addr(wrqu->ap_addr.sa_data)) {\n\t\t/* we disable mandatory BSSID association */\n\t\tIPW_DEBUG_WX(\"exit - disable mandatory BSSID\\n\");\n\t\tpriv->config &= ~CFG_STATIC_BSSID;\n\t\terr = ipw2100_set_mandatory_bssid(priv, NULL, 0);\n\t\tgoto done;\n\t}\n\n\tpriv->config |= CFG_STATIC_BSSID;\n\tmemcpy(priv->mandatory_bssid_mac, wrqu->ap_addr.sa_data, ETH_ALEN);\n\n\terr = ipw2100_set_mandatory_bssid(priv, wrqu->ap_addr.sa_data, 0);\n\n\tIPW_DEBUG_WX(\"SET BSSID -> %pM\\n\", wrqu->ap_addr.sa_data);\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_wap(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\t/*\n\t * This can be called at any time.  No action lock required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\t/* If we are associated, trying to associate, or have a statically\n\t * configured BSSID then return that; otherwise return ANY */\n\tif (priv->config & CFG_STATIC_BSSID || priv->status & STATUS_ASSOCIATED) {\n\t\twrqu->ap_addr.sa_family = ARPHRD_ETHER;\n\t\tmemcpy(wrqu->ap_addr.sa_data, priv->bssid, ETH_ALEN);\n\t} else\n\t\teth_zero_addr(wrqu->ap_addr.sa_data);\n\n\tIPW_DEBUG_WX(\"Getting WAP BSSID: %pM\\n\", wrqu->ap_addr.sa_data);\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_essid(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tchar *essid = \"\";\t/* ANY */\n\tint length = 0;\n\tint err = 0;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (wrqu->essid.flags && wrqu->essid.length) {\n\t\tlength = wrqu->essid.length;\n\t\tessid = extra;\n\t}\n\n\tif (length == 0) {\n\t\tIPW_DEBUG_WX(\"Setting ESSID to ANY\\n\");\n\t\tpriv->config &= ~CFG_STATIC_ESSID;\n\t\terr = ipw2100_set_essid(priv, NULL, 0, 0);\n\t\tgoto done;\n\t}\n\n\tlength = min(length, IW_ESSID_MAX_SIZE);\n\n\tpriv->config |= CFG_STATIC_ESSID;\n\n\tif (priv->essid_len == length && !memcmp(priv->essid, extra, length)) {\n\t\tIPW_DEBUG_WX(\"ESSID set to current ESSID.\\n\");\n\t\terr = 0;\n\t\tgoto done;\n\t}\n\n\tIPW_DEBUG_WX(\"Setting ESSID: '%*pE' (%d)\\n\", length, essid, length);\n\n\tpriv->essid_len = length;\n\tmemcpy(priv->essid, essid, priv->essid_len);\n\n\terr = ipw2100_set_essid(priv, essid, length, 0);\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_essid(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\t/*\n\t * This can be called at any time.  No action lock required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\t/* If we are associated, trying to associate, or have a statically\n\t * configured ESSID then return that; otherwise return ANY */\n\tif (priv->config & CFG_STATIC_ESSID || priv->status & STATUS_ASSOCIATED) {\n\t\tIPW_DEBUG_WX(\"Getting essid: '%*pE'\\n\",\n\t\t\t     priv->essid_len, priv->essid);\n\t\tmemcpy(extra, priv->essid, priv->essid_len);\n\t\twrqu->essid.length = priv->essid_len;\n\t\twrqu->essid.flags = 1;\t/* active */\n\t} else {\n\t\tIPW_DEBUG_WX(\"Getting essid: ANY\\n\");\n\t\twrqu->essid.length = 0;\n\t\twrqu->essid.flags = 0;\t/* active */\n\t}\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_nick(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\t/*\n\t * This can be called at any time.  No action lock required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\tif (wrqu->data.length > IW_ESSID_MAX_SIZE)\n\t\treturn -E2BIG;\n\n\twrqu->data.length = min_t(size_t, wrqu->data.length, sizeof(priv->nick));\n\tmemset(priv->nick, 0, sizeof(priv->nick));\n\tmemcpy(priv->nick, extra, wrqu->data.length);\n\n\tIPW_DEBUG_WX(\"SET Nickname -> %s\\n\", priv->nick);\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_get_nick(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\t/*\n\t * This can be called at any time.  No action lock required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\twrqu->data.length = strlen(priv->nick);\n\tmemcpy(extra, priv->nick, wrqu->data.length);\n\twrqu->data.flags = 1;\t/* active */\n\n\tIPW_DEBUG_WX(\"GET Nickname -> %s\\n\", extra);\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_rate(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tu32 target_rate = wrqu->bitrate.value;\n\tu32 rate;\n\tint err = 0;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\trate = 0;\n\n\tif (target_rate == 1000000 ||\n\t    (!wrqu->bitrate.fixed && target_rate > 1000000))\n\t\trate |= TX_RATE_1_MBIT;\n\tif (target_rate == 2000000 ||\n\t    (!wrqu->bitrate.fixed && target_rate > 2000000))\n\t\trate |= TX_RATE_2_MBIT;\n\tif (target_rate == 5500000 ||\n\t    (!wrqu->bitrate.fixed && target_rate > 5500000))\n\t\trate |= TX_RATE_5_5_MBIT;\n\tif (target_rate == 11000000 ||\n\t    (!wrqu->bitrate.fixed && target_rate > 11000000))\n\t\trate |= TX_RATE_11_MBIT;\n\tif (rate == 0)\n\t\trate = DEFAULT_TX_RATES;\n\n\terr = ipw2100_set_tx_rates(priv, rate, 0);\n\n\tIPW_DEBUG_WX(\"SET Rate -> %04X\\n\", rate);\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_rate(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint val;\n\tunsigned int len = sizeof(val);\n\tint err = 0;\n\n\tif (!(priv->status & STATUS_ENABLED) ||\n\t    priv->status & STATUS_RF_KILL_MASK ||\n\t    !(priv->status & STATUS_ASSOCIATED)) {\n\t\twrqu->bitrate.value = 0;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\terr = ipw2100_get_ordinal(priv, IPW_ORD_CURRENT_TX_RATE, &val, &len);\n\tif (err) {\n\t\tIPW_DEBUG_WX(\"failed querying ordinals.\\n\");\n\t\tgoto done;\n\t}\n\n\tswitch (val & TX_RATE_MASK) {\n\tcase TX_RATE_1_MBIT:\n\t\twrqu->bitrate.value = 1000000;\n\t\tbreak;\n\tcase TX_RATE_2_MBIT:\n\t\twrqu->bitrate.value = 2000000;\n\t\tbreak;\n\tcase TX_RATE_5_5_MBIT:\n\t\twrqu->bitrate.value = 5500000;\n\t\tbreak;\n\tcase TX_RATE_11_MBIT:\n\t\twrqu->bitrate.value = 11000000;\n\t\tbreak;\n\tdefault:\n\t\twrqu->bitrate.value = 0;\n\t}\n\n\tIPW_DEBUG_WX(\"GET Rate -> %d\\n\", wrqu->bitrate.value);\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_set_rts(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint value, err;\n\n\t/* Auto RTS not yet supported */\n\tif (wrqu->rts.fixed == 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (wrqu->rts.disabled)\n\t\tvalue = priv->rts_threshold | RTS_DISABLED;\n\telse {\n\t\tif (wrqu->rts.value < 1 || wrqu->rts.value > 2304) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tvalue = wrqu->rts.value;\n\t}\n\n\terr = ipw2100_set_rts_threshold(priv, value);\n\n\tIPW_DEBUG_WX(\"SET RTS Threshold -> 0x%08X\\n\", value);\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_rts(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\t/*\n\t * This can be called at any time.  No action lock required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\twrqu->rts.value = priv->rts_threshold & ~RTS_DISABLED;\n\twrqu->rts.fixed = 1;\t/* no auto select */\n\n\t/* If RTS is set to the default value, then it is disabled */\n\twrqu->rts.disabled = (priv->rts_threshold & RTS_DISABLED) ? 1 : 0;\n\n\tIPW_DEBUG_WX(\"GET RTS Threshold -> 0x%08X\\n\", wrqu->rts.value);\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_txpow(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint err = 0, value;\n\t\n\tif (ipw_radio_kill_sw(priv, wrqu->txpower.disabled))\n\t\treturn -EINPROGRESS;\n\n\tif (priv->ieee->iw_mode != IW_MODE_ADHOC)\n\t\treturn 0;\n\n\tif ((wrqu->txpower.flags & IW_TXPOW_TYPE) != IW_TXPOW_DBM)\n\t\treturn -EINVAL;\n\n\tif (wrqu->txpower.fixed == 0)\n\t\tvalue = IPW_TX_POWER_DEFAULT;\n\telse {\n\t\tif (wrqu->txpower.value < IPW_TX_POWER_MIN_DBM ||\n\t\t    wrqu->txpower.value > IPW_TX_POWER_MAX_DBM)\n\t\t\treturn -EINVAL;\n\n\t\tvalue = wrqu->txpower.value;\n\t}\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\terr = ipw2100_set_tx_power(priv, value);\n\n\tIPW_DEBUG_WX(\"SET TX Power -> %d\\n\", value);\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_txpow(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\t/*\n\t * This can be called at any time.  No action lock required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\twrqu->txpower.disabled = (priv->status & STATUS_RF_KILL_MASK) ? 1 : 0;\n\n\tif (priv->tx_power == IPW_TX_POWER_DEFAULT) {\n\t\twrqu->txpower.fixed = 0;\n\t\twrqu->txpower.value = IPW_TX_POWER_MAX_DBM;\n\t} else {\n\t\twrqu->txpower.fixed = 1;\n\t\twrqu->txpower.value = priv->tx_power;\n\t}\n\n\twrqu->txpower.flags = IW_TXPOW_DBM;\n\n\tIPW_DEBUG_WX(\"GET TX Power -> %d\\n\", wrqu->txpower.value);\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_frag(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\t/*\n\t * This can be called at any time.  No action lock required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\tif (!wrqu->frag.fixed)\n\t\treturn -EINVAL;\n\n\tif (wrqu->frag.disabled) {\n\t\tpriv->frag_threshold |= FRAG_DISABLED;\n\t\tpriv->ieee->fts = DEFAULT_FTS;\n\t} else {\n\t\tif (wrqu->frag.value < MIN_FRAG_THRESHOLD ||\n\t\t    wrqu->frag.value > MAX_FRAG_THRESHOLD)\n\t\t\treturn -EINVAL;\n\n\t\tpriv->ieee->fts = wrqu->frag.value & ~0x1;\n\t\tpriv->frag_threshold = priv->ieee->fts;\n\t}\n\n\tIPW_DEBUG_WX(\"SET Frag Threshold -> %d\\n\", priv->ieee->fts);\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_get_frag(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\t/*\n\t * This can be called at any time.  No action lock required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\twrqu->frag.value = priv->frag_threshold & ~FRAG_DISABLED;\n\twrqu->frag.fixed = 0;\t/* no auto select */\n\twrqu->frag.disabled = (priv->frag_threshold & FRAG_DISABLED) ? 1 : 0;\n\n\tIPW_DEBUG_WX(\"GET Frag Threshold -> %d\\n\", wrqu->frag.value);\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_retry(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint err = 0;\n\n\tif (wrqu->retry.flags & IW_RETRY_LIFETIME || wrqu->retry.disabled)\n\t\treturn -EINVAL;\n\n\tif (!(wrqu->retry.flags & IW_RETRY_LIMIT))\n\t\treturn 0;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (wrqu->retry.flags & IW_RETRY_SHORT) {\n\t\terr = ipw2100_set_short_retry(priv, wrqu->retry.value);\n\t\tIPW_DEBUG_WX(\"SET Short Retry Limit -> %d\\n\",\n\t\t\t     wrqu->retry.value);\n\t\tgoto done;\n\t}\n\n\tif (wrqu->retry.flags & IW_RETRY_LONG) {\n\t\terr = ipw2100_set_long_retry(priv, wrqu->retry.value);\n\t\tIPW_DEBUG_WX(\"SET Long Retry Limit -> %d\\n\",\n\t\t\t     wrqu->retry.value);\n\t\tgoto done;\n\t}\n\n\terr = ipw2100_set_short_retry(priv, wrqu->retry.value);\n\tif (!err)\n\t\terr = ipw2100_set_long_retry(priv, wrqu->retry.value);\n\n\tIPW_DEBUG_WX(\"SET Both Retry Limits -> %d\\n\", wrqu->retry.value);\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_retry(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\t/*\n\t * This can be called at any time.  No action lock required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\twrqu->retry.disabled = 0;\t/* can't be disabled */\n\n\tif ((wrqu->retry.flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME)\n\t\treturn -EINVAL;\n\n\tif (wrqu->retry.flags & IW_RETRY_LONG) {\n\t\twrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\n\t\twrqu->retry.value = priv->long_retry_limit;\n\t} else {\n\t\twrqu->retry.flags =\n\t\t    (priv->short_retry_limit !=\n\t\t     priv->long_retry_limit) ?\n\t\t    IW_RETRY_LIMIT | IW_RETRY_SHORT : IW_RETRY_LIMIT;\n\n\t\twrqu->retry.value = priv->short_retry_limit;\n\t}\n\n\tIPW_DEBUG_WX(\"GET Retry -> %d\\n\", wrqu->retry.value);\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_scan(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint err = 0;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tIPW_DEBUG_WX(\"Initiating scan...\\n\");\n\n\tpriv->user_requested_scan = 1;\n\tif (ipw2100_set_scan_options(priv) || ipw2100_start_scan(priv)) {\n\t\tIPW_DEBUG_WX(\"Start scan failed.\\n\");\n\n\t\t/* TODO: Mark a scan as pending so when hardware initialized\n\t\t *       a scan starts */\n\t}\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_scan(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\t/*\n\t * This can be called at any time.  No action lock required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\treturn libipw_wx_get_scan(priv->ieee, info, wrqu, extra);\n}\n\n/*\n * Implementation based on code in hostap-driver v0.1.3 hostap_ioctl.c\n */\nstatic int ipw2100_wx_set_encode(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *key)\n{\n\t/*\n\t * No check of STATUS_INITIALIZED required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\treturn libipw_wx_set_encode(priv->ieee, info, wrqu, key);\n}\n\nstatic int ipw2100_wx_get_encode(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *key)\n{\n\t/*\n\t * This can be called at any time.  No action lock required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\treturn libipw_wx_get_encode(priv->ieee, info, wrqu, key);\n}\n\nstatic int ipw2100_wx_set_power(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint err = 0;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (wrqu->power.disabled) {\n\t\tpriv->power_mode = IPW_POWER_LEVEL(priv->power_mode);\n\t\terr = ipw2100_set_power_mode(priv, IPW_POWER_MODE_CAM);\n\t\tIPW_DEBUG_WX(\"SET Power Management Mode -> off\\n\");\n\t\tgoto done;\n\t}\n\n\tswitch (wrqu->power.flags & IW_POWER_MODE) {\n\tcase IW_POWER_ON:\t/* If not specified */\n\tcase IW_POWER_MODE:\t/* If set all mask */\n\tcase IW_POWER_ALL_R:\t/* If explicitly state all */\n\t\tbreak;\n\tdefault:\t\t/* Otherwise we don't support it */\n\t\tIPW_DEBUG_WX(\"SET PM Mode: %X not supported.\\n\",\n\t\t\t     wrqu->power.flags);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\t}\n\n\t/* If the user hasn't specified a power management mode yet, default\n\t * to BATTERY */\n\tpriv->power_mode = IPW_POWER_ENABLED | priv->power_mode;\n\terr = ipw2100_set_power_mode(priv, IPW_POWER_LEVEL(priv->power_mode));\n\n\tIPW_DEBUG_WX(\"SET Power Management Mode -> 0x%02X\\n\", priv->power_mode);\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n\n}\n\nstatic int ipw2100_wx_get_power(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\t/*\n\t * This can be called at any time.  No action lock required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\tif (!(priv->power_mode & IPW_POWER_ENABLED))\n\t\twrqu->power.disabled = 1;\n\telse {\n\t\twrqu->power.disabled = 0;\n\t\twrqu->power.flags = 0;\n\t}\n\n\tIPW_DEBUG_WX(\"GET Power Management Mode -> %02X\\n\", priv->power_mode);\n\n\treturn 0;\n}\n\n/*\n * WE-18 WPA support\n */\n\n/* SIOCSIWGENIE */\nstatic int ipw2100_wx_set_genie(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct libipw_device *ieee = priv->ieee;\n\tu8 *buf;\n\n\tif (!ieee->wpa_enabled)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wrqu->data.length > MAX_WPA_IE_LEN ||\n\t    (wrqu->data.length && extra == NULL))\n\t\treturn -EINVAL;\n\n\tif (wrqu->data.length) {\n\t\tbuf = kmemdup(extra, wrqu->data.length, GFP_KERNEL);\n\t\tif (buf == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tkfree(ieee->wpa_ie);\n\t\tieee->wpa_ie = buf;\n\t\tieee->wpa_ie_len = wrqu->data.length;\n\t} else {\n\t\tkfree(ieee->wpa_ie);\n\t\tieee->wpa_ie = NULL;\n\t\tieee->wpa_ie_len = 0;\n\t}\n\n\tipw2100_wpa_assoc_frame(priv, ieee->wpa_ie, ieee->wpa_ie_len);\n\n\treturn 0;\n}\n\n/* SIOCGIWGENIE */\nstatic int ipw2100_wx_get_genie(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct libipw_device *ieee = priv->ieee;\n\n\tif (ieee->wpa_ie_len == 0 || ieee->wpa_ie == NULL) {\n\t\twrqu->data.length = 0;\n\t\treturn 0;\n\t}\n\n\tif (wrqu->data.length < ieee->wpa_ie_len)\n\t\treturn -E2BIG;\n\n\twrqu->data.length = ieee->wpa_ie_len;\n\tmemcpy(extra, ieee->wpa_ie, ieee->wpa_ie_len);\n\n\treturn 0;\n}\n\n/* SIOCSIWAUTH */\nstatic int ipw2100_wx_set_auth(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct libipw_device *ieee = priv->ieee;\n\tstruct iw_param *param = &wrqu->param;\n\tstruct lib80211_crypt_data *crypt;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_KEY_MGMT:\n\t\t/*\n\t\t * ipw2200 does not use these parameters\n\t\t */\n\t\tbreak;\n\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tcrypt = priv->ieee->crypt_info.crypt[priv->ieee->crypt_info.tx_keyidx];\n\t\tif (!crypt || !crypt->ops->set_flags || !crypt->ops->get_flags)\n\t\t\tbreak;\n\n\t\tflags = crypt->ops->get_flags(crypt->priv);\n\n\t\tif (param->value)\n\t\t\tflags |= IEEE80211_CRYPTO_TKIP_COUNTERMEASURES;\n\t\telse\n\t\t\tflags &= ~IEEE80211_CRYPTO_TKIP_COUNTERMEASURES;\n\n\t\tcrypt->ops->set_flags(flags, crypt->priv);\n\n\t\tbreak;\n\n\tcase IW_AUTH_DROP_UNENCRYPTED:{\n\t\t\t/* HACK:\n\t\t\t *\n\t\t\t * wpa_supplicant calls set_wpa_enabled when the driver\n\t\t\t * is loaded and unloaded, regardless of if WPA is being\n\t\t\t * used.  No other calls are made which can be used to\n\t\t\t * determine if encryption will be used or not prior to\n\t\t\t * association being expected.  If encryption is not being\n\t\t\t * used, drop_unencrypted is set to false, else true -- we\n\t\t\t * can use this to determine if the CAP_PRIVACY_ON bit should\n\t\t\t * be set.\n\t\t\t */\n\t\t\tstruct libipw_security sec = {\n\t\t\t\t.flags = SEC_ENABLED,\n\t\t\t\t.enabled = param->value,\n\t\t\t};\n\t\t\tpriv->ieee->drop_unencrypted = param->value;\n\t\t\t/* We only change SEC_LEVEL for open mode. Others\n\t\t\t * are set by ipw_wpa_set_encryption.\n\t\t\t */\n\t\t\tif (!param->value) {\n\t\t\t\tsec.flags |= SEC_LEVEL;\n\t\t\t\tsec.level = SEC_LEVEL_0;\n\t\t\t} else {\n\t\t\t\tsec.flags |= SEC_LEVEL;\n\t\t\t\tsec.level = SEC_LEVEL_1;\n\t\t\t}\n\t\t\tif (priv->ieee->set_security)\n\t\t\t\tpriv->ieee->set_security(priv->ieee->dev, &sec);\n\t\t\tbreak;\n\t\t}\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tret = ipw2100_wpa_set_auth_algs(priv, param->value);\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tret = ipw2100_wpa_enable(priv, param->value);\n\t\tbreak;\n\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\t\tieee->ieee802_1x = param->value;\n\t\tbreak;\n\n\t\t//case IW_AUTH_ROAMING_CONTROL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\t\tieee->privacy_invoked = param->value;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn ret;\n}\n\n/* SIOCGIWAUTH */\nstatic int ipw2100_wx_get_auth(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct libipw_device *ieee = priv->ieee;\n\tstruct lib80211_crypt_data *crypt;\n\tstruct iw_param *param = &wrqu->param;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_KEY_MGMT:\n\t\t/*\n\t\t * wpa_supplicant will control these internally\n\t\t */\n\t\tbreak;\n\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tcrypt = priv->ieee->crypt_info.crypt[priv->ieee->crypt_info.tx_keyidx];\n\t\tif (!crypt || !crypt->ops->get_flags) {\n\t\t\tIPW_DEBUG_WARNING(\"Can't get TKIP countermeasures: \"\n\t\t\t\t\t  \"crypt not set!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tparam->value = (crypt->ops->get_flags(crypt->priv) &\n\t\t\t\tIEEE80211_CRYPTO_TKIP_COUNTERMEASURES) ? 1 : 0;\n\n\t\tbreak;\n\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tparam->value = ieee->drop_unencrypted;\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tparam->value = priv->ieee->sec.auth_mode;\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tparam->value = ieee->wpa_enabled;\n\t\tbreak;\n\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\t\tparam->value = ieee->ieee802_1x;\n\t\tbreak;\n\n\tcase IW_AUTH_ROAMING_CONTROL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\t\tparam->value = ieee->privacy_invoked;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n/* SIOCSIWENCODEEXT */\nstatic int ipw2100_wx_set_encodeext(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\treturn libipw_wx_set_encodeext(priv->ieee, info, wrqu, extra);\n}\n\n/* SIOCGIWENCODEEXT */\nstatic int ipw2100_wx_get_encodeext(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\treturn libipw_wx_get_encodeext(priv->ieee, info, wrqu, extra);\n}\n\n/* SIOCSIWMLME */\nstatic int ipw2100_wx_set_mlme(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct iw_mlme *mlme = (struct iw_mlme *)extra;\n\n\tswitch (mlme->cmd) {\n\tcase IW_MLME_DEAUTH:\n\t\t// silently ignore\n\t\tbreak;\n\n\tcase IW_MLME_DISASSOC:\n\t\tipw2100_disassociate_bssid(priv);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n/*\n *\n * IWPRIV handlers\n *\n */\n#ifdef CONFIG_IPW2100_MONITOR\nstatic int ipw2100_wx_set_promisc(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint *parms = (int *)extra;\n\tint enable = (parms[0] > 0);\n\tint err = 0;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (enable) {\n\t\tif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\n\t\t\terr = ipw2100_set_channel(priv, parms[1], 0);\n\t\t\tgoto done;\n\t\t}\n\t\tpriv->channel = parms[1];\n\t\terr = ipw2100_switch_mode(priv, IW_MODE_MONITOR);\n\t} else {\n\t\tif (priv->ieee->iw_mode == IW_MODE_MONITOR)\n\t\t\terr = ipw2100_switch_mode(priv, priv->last_mode);\n\t}\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_reset(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tif (priv->status & STATUS_INITIALIZED)\n\t\tschedule_reset(priv);\n\treturn 0;\n}\n\n#endif\n\nstatic int ipw2100_wx_set_powermode(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint err = 0, mode = *(int *)extra;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tif ((mode < 0) || (mode > POWER_MODES))\n\t\tmode = IPW_POWER_AUTO;\n\n\tif (IPW_POWER_LEVEL(priv->power_mode) != mode)\n\t\terr = ipw2100_set_power_mode(priv, mode);\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\n#define MAX_POWER_STRING 80\nstatic int ipw2100_wx_get_powermode(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\t/*\n\t * This can be called at any time.  No action lock required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint level = IPW_POWER_LEVEL(priv->power_mode);\n\ts32 timeout, period;\n\n\tif (!(priv->power_mode & IPW_POWER_ENABLED)) {\n\t\tsnprintf(extra, MAX_POWER_STRING,\n\t\t\t \"Power save level: %d (Off)\", level);\n\t} else {\n\t\tswitch (level) {\n\t\tcase IPW_POWER_MODE_CAM:\n\t\t\tsnprintf(extra, MAX_POWER_STRING,\n\t\t\t\t \"Power save level: %d (None)\", level);\n\t\t\tbreak;\n\t\tcase IPW_POWER_AUTO:\n\t\t\tsnprintf(extra, MAX_POWER_STRING,\n\t\t\t\t \"Power save level: %d (Auto)\", level);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttimeout = timeout_duration[level - 1] / 1000;\n\t\t\tperiod = period_duration[level - 1] / 1000;\n\t\t\tsnprintf(extra, MAX_POWER_STRING,\n\t\t\t\t \"Power save level: %d \"\n\t\t\t\t \"(Timeout %dms, Period %dms)\",\n\t\t\t\t level, timeout, period);\n\t\t}\n\t}\n\n\twrqu->data.length = strlen(extra) + 1;\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_preamble(struct net_device *dev,\n\t\t\t\t   struct iw_request_info *info,\n\t\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint err, mode = *(int *)extra;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (mode == 1)\n\t\tpriv->config |= CFG_LONG_PREAMBLE;\n\telse if (mode == 0)\n\t\tpriv->config &= ~CFG_LONG_PREAMBLE;\n\telse {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\terr = ipw2100_system_config(priv, 0);\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_preamble(struct net_device *dev,\n\t\t\t\t   struct iw_request_info *info,\n\t\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\t/*\n\t * This can be called at any time.  No action lock required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\tif (priv->config & CFG_LONG_PREAMBLE)\n\t\tsnprintf(wrqu->name, IFNAMSIZ, \"long (1)\");\n\telse\n\t\tsnprintf(wrqu->name, IFNAMSIZ, \"auto (0)\");\n\n\treturn 0;\n}\n\n#ifdef CONFIG_IPW2100_MONITOR\nstatic int ipw2100_wx_set_crc_check(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint err, mode = *(int *)extra;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (mode == 1)\n\t\tpriv->config |= CFG_CRC_CHECK;\n\telse if (mode == 0)\n\t\tpriv->config &= ~CFG_CRC_CHECK;\n\telse {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\terr = 0;\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_crc_check(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\t/*\n\t * This can be called at any time.  No action lock required\n\t */\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\tif (priv->config & CFG_CRC_CHECK)\n\t\tsnprintf(wrqu->name, IFNAMSIZ, \"CRC checked (1)\");\n\telse\n\t\tsnprintf(wrqu->name, IFNAMSIZ, \"CRC ignored (0)\");\n\n\treturn 0;\n}\n#endif\t\t\t\t/* CONFIG_IPW2100_MONITOR */\n\nstatic iw_handler ipw2100_wx_handlers[] = {\n\tIW_HANDLER(SIOCGIWNAME, ipw2100_wx_get_name),\n\tIW_HANDLER(SIOCSIWFREQ, ipw2100_wx_set_freq),\n\tIW_HANDLER(SIOCGIWFREQ, ipw2100_wx_get_freq),\n\tIW_HANDLER(SIOCSIWMODE, ipw2100_wx_set_mode),\n\tIW_HANDLER(SIOCGIWMODE, ipw2100_wx_get_mode),\n\tIW_HANDLER(SIOCGIWRANGE, ipw2100_wx_get_range),\n\tIW_HANDLER(SIOCSIWAP, ipw2100_wx_set_wap),\n\tIW_HANDLER(SIOCGIWAP, ipw2100_wx_get_wap),\n\tIW_HANDLER(SIOCSIWMLME, ipw2100_wx_set_mlme),\n\tIW_HANDLER(SIOCSIWSCAN, ipw2100_wx_set_scan),\n\tIW_HANDLER(SIOCGIWSCAN, ipw2100_wx_get_scan),\n\tIW_HANDLER(SIOCSIWESSID, ipw2100_wx_set_essid),\n\tIW_HANDLER(SIOCGIWESSID, ipw2100_wx_get_essid),\n\tIW_HANDLER(SIOCSIWNICKN, ipw2100_wx_set_nick),\n\tIW_HANDLER(SIOCGIWNICKN, ipw2100_wx_get_nick),\n\tIW_HANDLER(SIOCSIWRATE, ipw2100_wx_set_rate),\n\tIW_HANDLER(SIOCGIWRATE, ipw2100_wx_get_rate),\n\tIW_HANDLER(SIOCSIWRTS, ipw2100_wx_set_rts),\n\tIW_HANDLER(SIOCGIWRTS, ipw2100_wx_get_rts),\n\tIW_HANDLER(SIOCSIWFRAG, ipw2100_wx_set_frag),\n\tIW_HANDLER(SIOCGIWFRAG, ipw2100_wx_get_frag),\n\tIW_HANDLER(SIOCSIWTXPOW, ipw2100_wx_set_txpow),\n\tIW_HANDLER(SIOCGIWTXPOW, ipw2100_wx_get_txpow),\n\tIW_HANDLER(SIOCSIWRETRY, ipw2100_wx_set_retry),\n\tIW_HANDLER(SIOCGIWRETRY, ipw2100_wx_get_retry),\n\tIW_HANDLER(SIOCSIWENCODE, ipw2100_wx_set_encode),\n\tIW_HANDLER(SIOCGIWENCODE, ipw2100_wx_get_encode),\n\tIW_HANDLER(SIOCSIWPOWER, ipw2100_wx_set_power),\n\tIW_HANDLER(SIOCGIWPOWER, ipw2100_wx_get_power),\n\tIW_HANDLER(SIOCSIWGENIE, ipw2100_wx_set_genie),\n\tIW_HANDLER(SIOCGIWGENIE, ipw2100_wx_get_genie),\n\tIW_HANDLER(SIOCSIWAUTH, ipw2100_wx_set_auth),\n\tIW_HANDLER(SIOCGIWAUTH, ipw2100_wx_get_auth),\n\tIW_HANDLER(SIOCSIWENCODEEXT, ipw2100_wx_set_encodeext),\n\tIW_HANDLER(SIOCGIWENCODEEXT, ipw2100_wx_get_encodeext),\n};\n\n#define IPW2100_PRIV_SET_MONITOR\tSIOCIWFIRSTPRIV\n#define IPW2100_PRIV_RESET\t\tSIOCIWFIRSTPRIV+1\n#define IPW2100_PRIV_SET_POWER\t\tSIOCIWFIRSTPRIV+2\n#define IPW2100_PRIV_GET_POWER\t\tSIOCIWFIRSTPRIV+3\n#define IPW2100_PRIV_SET_LONGPREAMBLE\tSIOCIWFIRSTPRIV+4\n#define IPW2100_PRIV_GET_LONGPREAMBLE\tSIOCIWFIRSTPRIV+5\n#define IPW2100_PRIV_SET_CRC_CHECK\tSIOCIWFIRSTPRIV+6\n#define IPW2100_PRIV_GET_CRC_CHECK\tSIOCIWFIRSTPRIV+7\n\nstatic const struct iw_priv_args ipw2100_private_args[] = {\n\n#ifdef CONFIG_IPW2100_MONITOR\n\t{\n\t IPW2100_PRIV_SET_MONITOR,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, \"monitor\"},\n\t{\n\t IPW2100_PRIV_RESET,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 0, 0, \"reset\"},\n#endif\t\t\t\t/* CONFIG_IPW2100_MONITOR */\n\n\t{\n\t IPW2100_PRIV_SET_POWER,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"set_power\"},\n\t{\n\t IPW2100_PRIV_GET_POWER,\n\t 0, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | MAX_POWER_STRING,\n\t \"get_power\"},\n\t{\n\t IPW2100_PRIV_SET_LONGPREAMBLE,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"set_preamble\"},\n\t{\n\t IPW2100_PRIV_GET_LONGPREAMBLE,\n\t 0, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IFNAMSIZ, \"get_preamble\"},\n#ifdef CONFIG_IPW2100_MONITOR\n\t{\n\t IPW2100_PRIV_SET_CRC_CHECK,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"set_crc_check\"},\n\t{\n\t IPW2100_PRIV_GET_CRC_CHECK,\n\t 0, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IFNAMSIZ, \"get_crc_check\"},\n#endif\t\t\t\t/* CONFIG_IPW2100_MONITOR */\n};\n\nstatic iw_handler ipw2100_private_handler[] = {\n#ifdef CONFIG_IPW2100_MONITOR\n\tipw2100_wx_set_promisc,\n\tipw2100_wx_reset,\n#else\t\t\t\t/* CONFIG_IPW2100_MONITOR */\n\tNULL,\n\tNULL,\n#endif\t\t\t\t/* CONFIG_IPW2100_MONITOR */\n\tipw2100_wx_set_powermode,\n\tipw2100_wx_get_powermode,\n\tipw2100_wx_set_preamble,\n\tipw2100_wx_get_preamble,\n#ifdef CONFIG_IPW2100_MONITOR\n\tipw2100_wx_set_crc_check,\n\tipw2100_wx_get_crc_check,\n#else\t\t\t\t/* CONFIG_IPW2100_MONITOR */\n\tNULL,\n\tNULL,\n#endif\t\t\t\t/* CONFIG_IPW2100_MONITOR */\n};\n\n/*\n * Get wireless statistics.\n * Called by /proc/net/wireless\n * Also called by SIOCGIWSTATS\n */\nstatic struct iw_statistics *ipw2100_wx_wireless_stats(struct net_device *dev)\n{\n\tenum {\n\t\tPOOR = 30,\n\t\tFAIR = 60,\n\t\tGOOD = 80,\n\t\tVERY_GOOD = 90,\n\t\tEXCELLENT = 95,\n\t\tPERFECT = 100\n\t};\n\tint rssi_qual;\n\tint tx_qual;\n\tint beacon_qual;\n\tint quality;\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct iw_statistics *wstats;\n\tu32 rssi, tx_retries, missed_beacons, tx_failures;\n\tu32 ord_len = sizeof(u32);\n\n\tif (!priv)\n\t\treturn (struct iw_statistics *)NULL;\n\n\twstats = &priv->wstats;\n\n\t/* if hw is disabled, then ipw2100_get_ordinal() can't be called.\n\t * ipw2100_wx_wireless_stats seems to be called before fw is\n\t * initialized.  STATUS_ASSOCIATED will only be set if the hw is up\n\t * and associated; if not associcated, the values are all meaningless\n\t * anyway, so set them all to NULL and INVALID */\n\tif (!(priv->status & STATUS_ASSOCIATED)) {\n\t\twstats->miss.beacon = 0;\n\t\twstats->discard.retries = 0;\n\t\twstats->qual.qual = 0;\n\t\twstats->qual.level = 0;\n\t\twstats->qual.noise = 0;\n\t\twstats->qual.updated = 7;\n\t\twstats->qual.updated |= IW_QUAL_NOISE_INVALID |\n\t\t    IW_QUAL_QUAL_INVALID | IW_QUAL_LEVEL_INVALID;\n\t\treturn wstats;\n\t}\n\n\tif (ipw2100_get_ordinal(priv, IPW_ORD_STAT_PERCENT_MISSED_BCNS,\n\t\t\t\t&missed_beacons, &ord_len))\n\t\tgoto fail_get_ordinal;\n\n\t/* If we don't have a connection the quality and level is 0 */\n\tif (!(priv->status & STATUS_ASSOCIATED)) {\n\t\twstats->qual.qual = 0;\n\t\twstats->qual.level = 0;\n\t} else {\n\t\tif (ipw2100_get_ordinal(priv, IPW_ORD_RSSI_AVG_CURR,\n\t\t\t\t\t&rssi, &ord_len))\n\t\t\tgoto fail_get_ordinal;\n\t\twstats->qual.level = rssi + IPW2100_RSSI_TO_DBM;\n\t\tif (rssi < 10)\n\t\t\trssi_qual = rssi * POOR / 10;\n\t\telse if (rssi < 15)\n\t\t\trssi_qual = (rssi - 10) * (FAIR - POOR) / 5 + POOR;\n\t\telse if (rssi < 20)\n\t\t\trssi_qual = (rssi - 15) * (GOOD - FAIR) / 5 + FAIR;\n\t\telse if (rssi < 30)\n\t\t\trssi_qual = (rssi - 20) * (VERY_GOOD - GOOD) /\n\t\t\t    10 + GOOD;\n\t\telse\n\t\t\trssi_qual = (rssi - 30) * (PERFECT - VERY_GOOD) /\n\t\t\t    10 + VERY_GOOD;\n\n\t\tif (ipw2100_get_ordinal(priv, IPW_ORD_STAT_PERCENT_RETRIES,\n\t\t\t\t\t&tx_retries, &ord_len))\n\t\t\tgoto fail_get_ordinal;\n\n\t\tif (tx_retries > 75)\n\t\t\ttx_qual = (90 - tx_retries) * POOR / 15;\n\t\telse if (tx_retries > 70)\n\t\t\ttx_qual = (75 - tx_retries) * (FAIR - POOR) / 5 + POOR;\n\t\telse if (tx_retries > 65)\n\t\t\ttx_qual = (70 - tx_retries) * (GOOD - FAIR) / 5 + FAIR;\n\t\telse if (tx_retries > 50)\n\t\t\ttx_qual = (65 - tx_retries) * (VERY_GOOD - GOOD) /\n\t\t\t    15 + GOOD;\n\t\telse\n\t\t\ttx_qual = (50 - tx_retries) *\n\t\t\t    (PERFECT - VERY_GOOD) / 50 + VERY_GOOD;\n\n\t\tif (missed_beacons > 50)\n\t\t\tbeacon_qual = (60 - missed_beacons) * POOR / 10;\n\t\telse if (missed_beacons > 40)\n\t\t\tbeacon_qual = (50 - missed_beacons) * (FAIR - POOR) /\n\t\t\t    10 + POOR;\n\t\telse if (missed_beacons > 32)\n\t\t\tbeacon_qual = (40 - missed_beacons) * (GOOD - FAIR) /\n\t\t\t    18 + FAIR;\n\t\telse if (missed_beacons > 20)\n\t\t\tbeacon_qual = (32 - missed_beacons) *\n\t\t\t    (VERY_GOOD - GOOD) / 20 + GOOD;\n\t\telse\n\t\t\tbeacon_qual = (20 - missed_beacons) *\n\t\t\t    (PERFECT - VERY_GOOD) / 20 + VERY_GOOD;\n\n\t\tquality = min(tx_qual, rssi_qual);\n\t\tquality = min(beacon_qual, quality);\n\n#ifdef CONFIG_IPW2100_DEBUG\n\t\tif (beacon_qual == quality)\n\t\t\tIPW_DEBUG_WX(\"Quality clamped by Missed Beacons\\n\");\n\t\telse if (tx_qual == quality)\n\t\t\tIPW_DEBUG_WX(\"Quality clamped by Tx Retries\\n\");\n\t\telse if (quality != 100)\n\t\t\tIPW_DEBUG_WX(\"Quality clamped by Signal Strength\\n\");\n\t\telse\n\t\t\tIPW_DEBUG_WX(\"Quality not clamped.\\n\");\n#endif\n\n\t\twstats->qual.qual = quality;\n\t\twstats->qual.level = rssi + IPW2100_RSSI_TO_DBM;\n\t}\n\n\twstats->qual.noise = 0;\n\twstats->qual.updated = 7;\n\twstats->qual.updated |= IW_QUAL_NOISE_INVALID;\n\n\t/* FIXME: this is percent and not a # */\n\twstats->miss.beacon = missed_beacons;\n\n\tif (ipw2100_get_ordinal(priv, IPW_ORD_STAT_TX_FAILURES,\n\t\t\t\t&tx_failures, &ord_len))\n\t\tgoto fail_get_ordinal;\n\twstats->discard.retries = tx_failures;\n\n\treturn wstats;\n\n      fail_get_ordinal:\n\tIPW_DEBUG_WX(\"failed querying ordinals.\\n\");\n\n\treturn (struct iw_statistics *)NULL;\n}\n\nstatic const struct iw_handler_def ipw2100_wx_handler_def = {\n\t.standard = ipw2100_wx_handlers,\n\t.num_standard = ARRAY_SIZE(ipw2100_wx_handlers),\n\t.num_private = ARRAY_SIZE(ipw2100_private_handler),\n\t.num_private_args = ARRAY_SIZE(ipw2100_private_args),\n\t.private = (iw_handler *) ipw2100_private_handler,\n\t.private_args = (struct iw_priv_args *)ipw2100_private_args,\n\t.get_wireless_stats = ipw2100_wx_wireless_stats,\n};\n\nstatic void ipw2100_wx_event_work(struct work_struct *work)\n{\n\tstruct ipw2100_priv *priv =\n\t\tcontainer_of(work, struct ipw2100_priv, wx_event_work.work);\n\tunion iwreq_data wrqu;\n\tunsigned int len = ETH_ALEN;\n\n\tif (priv->status & STATUS_STOPPING)\n\t\treturn;\n\n\tmutex_lock(&priv->action_mutex);\n\n\tIPW_DEBUG_WX(\"enter\\n\");\n\n\tmutex_unlock(&priv->action_mutex);\n\n\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\n\t/* Fetch BSSID from the hardware */\n\tif (!(priv->status & (STATUS_ASSOCIATING | STATUS_ASSOCIATED)) ||\n\t    priv->status & STATUS_RF_KILL_MASK ||\n\t    ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_AP_BSSID,\n\t\t\t\t&priv->bssid, &len)) {\n\t\teth_zero_addr(wrqu.ap_addr.sa_data);\n\t} else {\n\t\t/* We now have the BSSID, so can finish setting to the full\n\t\t * associated state */\n\t\tmemcpy(wrqu.ap_addr.sa_data, priv->bssid, ETH_ALEN);\n\t\tmemcpy(priv->ieee->bssid, priv->bssid, ETH_ALEN);\n\t\tpriv->status &= ~STATUS_ASSOCIATING;\n\t\tpriv->status |= STATUS_ASSOCIATED;\n\t\tnetif_carrier_on(priv->net_dev);\n\t\tnetif_wake_queue(priv->net_dev);\n\t}\n\n\tif (!(priv->status & STATUS_ASSOCIATED)) {\n\t\tIPW_DEBUG_WX(\"Configuring ESSID\\n\");\n\t\tmutex_lock(&priv->action_mutex);\n\t\t/* This is a disassociation event, so kick the firmware to\n\t\t * look for another AP */\n\t\tif (priv->config & CFG_STATIC_ESSID)\n\t\t\tipw2100_set_essid(priv, priv->essid, priv->essid_len,\n\t\t\t\t\t  0);\n\t\telse\n\t\t\tipw2100_set_essid(priv, NULL, 0, 0);\n\t\tmutex_unlock(&priv->action_mutex);\n\t}\n\n\twireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);\n}\n\n#define IPW2100_FW_MAJOR_VERSION 1\n#define IPW2100_FW_MINOR_VERSION 3\n\n#define IPW2100_FW_MINOR(x) ((x & 0xff) >> 8)\n#define IPW2100_FW_MAJOR(x) (x & 0xff)\n\n#define IPW2100_FW_VERSION ((IPW2100_FW_MINOR_VERSION << 8) | \\\n                             IPW2100_FW_MAJOR_VERSION)\n\n#define IPW2100_FW_PREFIX \"ipw2100-\" __stringify(IPW2100_FW_MAJOR_VERSION) \\\n\".\" __stringify(IPW2100_FW_MINOR_VERSION)\n\n#define IPW2100_FW_NAME(x) IPW2100_FW_PREFIX \"\" x \".fw\"\n\n/*\n\nBINARY FIRMWARE HEADER FORMAT\n\noffset      length   desc\n0           2        version\n2           2        mode == 0:BSS,1:IBSS,2:MONITOR\n4           4        fw_len\n8           4        uc_len\nC           fw_len   firmware data\n12 + fw_len uc_len   microcode data\n\n*/\n\nstruct ipw2100_fw_header {\n\tshort version;\n\tshort mode;\n\tunsigned int fw_size;\n\tunsigned int uc_size;\n} __packed;\n\nstatic int ipw2100_mod_firmware_load(struct ipw2100_fw *fw)\n{\n\tstruct ipw2100_fw_header *h =\n\t    (struct ipw2100_fw_header *)fw->fw_entry->data;\n\n\tif (IPW2100_FW_MAJOR(h->version) != IPW2100_FW_MAJOR_VERSION) {\n\t\tprintk(KERN_WARNING DRV_NAME \": Firmware image not compatible \"\n\t\t       \"(detected version id of %u). \"\n\t\t       \"See Documentation/networking/device_drivers/wifi/intel/ipw2100.rst\\n\",\n\t\t       h->version);\n\t\treturn 1;\n\t}\n\n\tfw->version = h->version;\n\tfw->fw.data = fw->fw_entry->data + sizeof(struct ipw2100_fw_header);\n\tfw->fw.size = h->fw_size;\n\tfw->uc.data = fw->fw.data + h->fw_size;\n\tfw->uc.size = h->uc_size;\n\n\treturn 0;\n}\n\nstatic int ipw2100_get_firmware(struct ipw2100_priv *priv,\n\t\t\t\tstruct ipw2100_fw *fw)\n{\n\tchar *fw_name;\n\tint rc;\n\n\tIPW_DEBUG_INFO(\"%s: Using hotplug firmware load.\\n\",\n\t\t       priv->net_dev->name);\n\n\tswitch (priv->ieee->iw_mode) {\n\tcase IW_MODE_ADHOC:\n\t\tfw_name = IPW2100_FW_NAME(\"-i\");\n\t\tbreak;\n#ifdef CONFIG_IPW2100_MONITOR\n\tcase IW_MODE_MONITOR:\n\t\tfw_name = IPW2100_FW_NAME(\"-p\");\n\t\tbreak;\n#endif\n\tcase IW_MODE_INFRA:\n\tdefault:\n\t\tfw_name = IPW2100_FW_NAME(\"\");\n\t\tbreak;\n\t}\n\n\trc = request_firmware(&fw->fw_entry, fw_name, &priv->pci_dev->dev);\n\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR DRV_NAME \": \"\n\t\t       \"%s: Firmware '%s' not available or load failed.\\n\",\n\t\t       priv->net_dev->name, fw_name);\n\t\treturn rc;\n\t}\n\tIPW_DEBUG_INFO(\"firmware data %p size %zd\\n\", fw->fw_entry->data,\n\t\t       fw->fw_entry->size);\n\n\tipw2100_mod_firmware_load(fw);\n\n\treturn 0;\n}\n\nMODULE_FIRMWARE(IPW2100_FW_NAME(\"-i\"));\n#ifdef CONFIG_IPW2100_MONITOR\nMODULE_FIRMWARE(IPW2100_FW_NAME(\"-p\"));\n#endif\nMODULE_FIRMWARE(IPW2100_FW_NAME(\"\"));\n\nstatic void ipw2100_release_firmware(struct ipw2100_priv *priv,\n\t\t\t\t     struct ipw2100_fw *fw)\n{\n\tfw->version = 0;\n\trelease_firmware(fw->fw_entry);\n\tfw->fw_entry = NULL;\n}\n\nstatic int ipw2100_get_fwversion(struct ipw2100_priv *priv, char *buf,\n\t\t\t\t size_t max)\n{\n\tchar ver[MAX_FW_VERSION_LEN];\n\tu32 len = MAX_FW_VERSION_LEN;\n\tu32 tmp;\n\tint i;\n\t/* firmware version is an ascii string (max len of 14) */\n\tif (ipw2100_get_ordinal(priv, IPW_ORD_STAT_FW_VER_NUM, ver, &len))\n\t\treturn -EIO;\n\ttmp = max;\n\tif (len >= max)\n\t\tlen = max - 1;\n\tfor (i = 0; i < len; i++)\n\t\tbuf[i] = ver[i];\n\tbuf[i] = '\\0';\n\treturn tmp;\n}\n\nstatic int ipw2100_get_ucodeversion(struct ipw2100_priv *priv, char *buf,\n\t\t\t\t    size_t max)\n{\n\tu32 ver;\n\tu32 len = sizeof(ver);\n\t/* microcode version is a 32 bit integer */\n\tif (ipw2100_get_ordinal(priv, IPW_ORD_UCODE_VERSION, &ver, &len))\n\t\treturn -EIO;\n\treturn snprintf(buf, max, \"%08X\", ver);\n}\n\n/*\n * On exit, the firmware will have been freed from the fw list\n */\nstatic int ipw2100_fw_download(struct ipw2100_priv *priv, struct ipw2100_fw *fw)\n{\n\t/* firmware is constructed of N contiguous entries, each entry is\n\t * structured as:\n\t *\n\t * offset    sie         desc\n\t * 0         4           address to write to\n\t * 4         2           length of data run\n\t * 6         length      data\n\t */\n\tunsigned int addr;\n\tunsigned short len;\n\n\tconst unsigned char *firmware_data = fw->fw.data;\n\tunsigned int firmware_data_left = fw->fw.size;\n\n\twhile (firmware_data_left > 0) {\n\t\taddr = *(u32 *) (firmware_data);\n\t\tfirmware_data += 4;\n\t\tfirmware_data_left -= 4;\n\n\t\tlen = *(u16 *) (firmware_data);\n\t\tfirmware_data += 2;\n\t\tfirmware_data_left -= 2;\n\n\t\tif (len > 32) {\n\t\t\tprintk(KERN_ERR DRV_NAME \": \"\n\t\t\t       \"Invalid firmware run-length of %d bytes\\n\",\n\t\t\t       len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\twrite_nic_memory(priv->net_dev, addr, len, firmware_data);\n\t\tfirmware_data += len;\n\t\tfirmware_data_left -= len;\n\t}\n\n\treturn 0;\n}\n\nstruct symbol_alive_response {\n\tu8 cmd_id;\n\tu8 seq_num;\n\tu8 ucode_rev;\n\tu8 eeprom_valid;\n\tu16 valid_flags;\n\tu8 IEEE_addr[6];\n\tu16 flags;\n\tu16 pcb_rev;\n\tu16 clock_settle_time;\t// 1us LSB\n\tu16 powerup_settle_time;\t// 1us LSB\n\tu16 hop_settle_time;\t// 1us LSB\n\tu8 date[3];\t\t// month, day, year\n\tu8 time[2];\t\t// hours, minutes\n\tu8 ucode_valid;\n};\n\nstatic int ipw2100_ucode_download(struct ipw2100_priv *priv,\n\t\t\t\t  struct ipw2100_fw *fw)\n{\n\tstruct net_device *dev = priv->net_dev;\n\tconst unsigned char *microcode_data = fw->uc.data;\n\tunsigned int microcode_data_left = fw->uc.size;\n\tvoid __iomem *reg = priv->ioaddr;\n\n\tstruct symbol_alive_response response;\n\tint i, j;\n\tu8 data;\n\n\t/* Symbol control */\n\twrite_nic_word(dev, IPW2100_CONTROL_REG, 0x703);\n\treadl(reg);\n\twrite_nic_word(dev, IPW2100_CONTROL_REG, 0x707);\n\treadl(reg);\n\n\t/* HW config */\n\twrite_nic_byte(dev, 0x210014, 0x72);\t/* fifo width =16 */\n\treadl(reg);\n\twrite_nic_byte(dev, 0x210014, 0x72);\t/* fifo width =16 */\n\treadl(reg);\n\n\t/* EN_CS_ACCESS bit to reset control store pointer */\n\twrite_nic_byte(dev, 0x210000, 0x40);\n\treadl(reg);\n\twrite_nic_byte(dev, 0x210000, 0x0);\n\treadl(reg);\n\twrite_nic_byte(dev, 0x210000, 0x40);\n\treadl(reg);\n\n\t/* copy microcode from buffer into Symbol */\n\n\twhile (microcode_data_left > 0) {\n\t\twrite_nic_byte(dev, 0x210010, *microcode_data++);\n\t\twrite_nic_byte(dev, 0x210010, *microcode_data++);\n\t\tmicrocode_data_left -= 2;\n\t}\n\n\t/* EN_CS_ACCESS bit to reset the control store pointer */\n\twrite_nic_byte(dev, 0x210000, 0x0);\n\treadl(reg);\n\n\t/* Enable System (Reg 0)\n\t * first enable causes garbage in RX FIFO */\n\twrite_nic_byte(dev, 0x210000, 0x0);\n\treadl(reg);\n\twrite_nic_byte(dev, 0x210000, 0x80);\n\treadl(reg);\n\n\t/* Reset External Baseband Reg */\n\twrite_nic_word(dev, IPW2100_CONTROL_REG, 0x703);\n\treadl(reg);\n\twrite_nic_word(dev, IPW2100_CONTROL_REG, 0x707);\n\treadl(reg);\n\n\t/* HW Config (Reg 5) */\n\twrite_nic_byte(dev, 0x210014, 0x72);\t// fifo width =16\n\treadl(reg);\n\twrite_nic_byte(dev, 0x210014, 0x72);\t// fifo width =16\n\treadl(reg);\n\n\t/* Enable System (Reg 0)\n\t * second enable should be OK */\n\twrite_nic_byte(dev, 0x210000, 0x00);\t// clear enable system\n\treadl(reg);\n\twrite_nic_byte(dev, 0x210000, 0x80);\t// set enable system\n\n\t/* check Symbol is enabled - upped this from 5 as it wasn't always\n\t * catching the update */\n\tfor (i = 0; i < 10; i++) {\n\t\tudelay(10);\n\n\t\t/* check Dino is enabled bit */\n\t\tread_nic_byte(dev, 0x210000, &data);\n\t\tif (data & 0x1)\n\t\t\tbreak;\n\t}\n\n\tif (i == 10) {\n\t\tprintk(KERN_ERR DRV_NAME \": %s: Error initializing Symbol\\n\",\n\t\t       dev->name);\n\t\treturn -EIO;\n\t}\n\n\t/* Get Symbol alive response */\n\tfor (i = 0; i < 30; i++) {\n\t\t/* Read alive response structure */\n\t\tfor (j = 0;\n\t\t     j < (sizeof(struct symbol_alive_response) >> 1); j++)\n\t\t\tread_nic_word(dev, 0x210004, ((u16 *) & response) + j);\n\n\t\tif ((response.cmd_id == 1) && (response.ucode_valid == 0x1))\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\n\tif (i == 30) {\n\t\tprintk(KERN_ERR DRV_NAME\n\t\t       \": %s: No response from Symbol - hw not alive\\n\",\n\t\t       dev->name);\n\t\tprintk_buf(IPW_DL_ERROR, (u8 *) & response, sizeof(response));\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 6781}, "message": "warn: assigning (-78) to unsigned variable 'range->avg_qual.level'"}], "macros": [], "notes": [], "path": "/src/drivers/net/wireless/intel/ipw2x00/ipw2100.c", "reportHash": "72345569babba920f622a301d2cca43a", "checkerName": "smatch.check_signed", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
