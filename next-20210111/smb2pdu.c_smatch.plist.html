<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/fs/cifs/smb2pdu.c", "content": "/*\n *   fs/cifs/smb2pdu.c\n *\n *   Copyright (C) International Business Machines  Corp., 2009, 2013\n *                 Etersoft, 2012\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *              Pavel Shilovsky (pshilovsky@samba.org) 2012\n *\n *   Contains the routines for constructing the SMB2 PDUs themselves\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n\n /* SMB2 PDU handling routines here - except for leftovers (eg session setup) */\n /* Note that there are handle based routines which must be\t\t      */\n /* treated slightly differently for reconnection purposes since we never     */\n /* want to reuse a stale file handle and only the caller knows the file info */\n\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/uaccess.h>\n#include <linux/uuid.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsacl.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"ntlmssp.h\"\n#include \"smb2status.h\"\n#include \"smb2glob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_spnego.h\"\n#include \"smbdirect.h\"\n#include \"trace.h\"\n#ifdef CONFIG_CIFS_DFS_UPCALL\n#include \"dfs_cache.h\"\n#endif\n\n/*\n *  The following table defines the expected \"StructureSize\" of SMB2 requests\n *  in order by SMB2 command.  This is similar to \"wct\" in SMB/CIFS requests.\n *\n *  Note that commands are defined in smb2pdu.h in le16 but the array below is\n *  indexed by command in host byte order.\n */\nstatic const int smb2_req_struct_sizes[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ 36,\n\t/* SMB2_SESSION_SETUP */ 25,\n\t/* SMB2_LOGOFF */ 4,\n\t/* SMB2_TREE_CONNECT */\t9,\n\t/* SMB2_TREE_DISCONNECT */ 4,\n\t/* SMB2_CREATE */ 57,\n\t/* SMB2_CLOSE */ 24,\n\t/* SMB2_FLUSH */ 24,\n\t/* SMB2_READ */\t49,\n\t/* SMB2_WRITE */ 49,\n\t/* SMB2_LOCK */\t48,\n\t/* SMB2_IOCTL */ 57,\n\t/* SMB2_CANCEL */ 4,\n\t/* SMB2_ECHO */ 4,\n\t/* SMB2_QUERY_DIRECTORY */ 33,\n\t/* SMB2_CHANGE_NOTIFY */ 32,\n\t/* SMB2_QUERY_INFO */ 41,\n\t/* SMB2_SET_INFO */ 33,\n\t/* SMB2_OPLOCK_BREAK */ 24 /* BB this is 36 for LEASE_BREAK variant */\n};\n\nint smb3_encryption_required(const struct cifs_tcon *tcon)\n{\n\tif (!tcon || !tcon->ses)\n\t\treturn 0;\n\tif ((tcon->ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA) ||\n\t    (tcon->share_flags & SHI1005_FLAGS_ENCRYPT_DATA))\n\t\treturn 1;\n\tif (tcon->seal &&\n\t    (tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void\nsmb2_hdr_assemble(struct smb2_sync_hdr *shdr, __le16 smb2_cmd,\n\t\t  const struct cifs_tcon *tcon,\n\t\t  struct TCP_Server_Info *server)\n{\n\tshdr->ProtocolId = SMB2_PROTO_NUMBER;\n\tshdr->StructureSize = cpu_to_le16(64);\n\tshdr->Command = smb2_cmd;\n\tif (server) {\n\t\tspin_lock(&server->req_lock);\n\t\t/* Request up to 10 credits but don't go over the limit. */\n\t\tif (server->credits >= server->max_credits)\n\t\t\tshdr->CreditRequest = cpu_to_le16(0);\n\t\telse\n\t\t\tshdr->CreditRequest = cpu_to_le16(\n\t\t\t\tmin_t(int, server->max_credits -\n\t\t\t\t\t\tserver->credits, 10));\n\t\tspin_unlock(&server->req_lock);\n\t} else {\n\t\tshdr->CreditRequest = cpu_to_le16(2);\n\t}\n\tshdr->ProcessId = cpu_to_le32((__u16)current->tgid);\n\n\tif (!tcon)\n\t\tgoto out;\n\n\t/* GLOBAL_CAP_LARGE_MTU will only be set if dialect > SMB2.02 */\n\t/* See sections 2.2.4 and 3.2.4.1.5 of MS-SMB2 */\n\tif (server && (server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\n\t\tshdr->CreditCharge = cpu_to_le16(1);\n\t/* else CreditCharge MBZ */\n\n\tshdr->TreeId = tcon->tid;\n\t/* Uid is not converted */\n\tif (tcon->ses)\n\t\tshdr->SessionId = tcon->ses->Suid;\n\n\t/*\n\t * If we would set SMB2_FLAGS_DFS_OPERATIONS on open we also would have\n\t * to pass the path on the Open SMB prefixed by \\\\server\\share.\n\t * Not sure when we would need to do the augmented path (if ever) and\n\t * setting this flag breaks the SMB2 open operation since it is\n\t * illegal to send an empty path name (without \\\\server\\share prefix)\n\t * when the DFS flag is set in the SMB open header. We could\n\t * consider setting the flag on all operations other than open\n\t * but it is safer to net set it for now.\n\t */\n/*\tif (tcon->share_flags & SHI1005_FLAGS_DFS)\n\t\tshdr->Flags |= SMB2_FLAGS_DFS_OPERATIONS; */\n\n\tif (server && server->sign && !smb3_encryption_required(tcon))\n\t\tshdr->Flags |= SMB2_FLAGS_SIGNED;\nout:\n\treturn;\n}\n\nstatic int\nsmb2_reconnect(__le16 smb2_command, struct cifs_tcon *tcon,\n\t       struct TCP_Server_Info *server)\n{\n\tint rc;\n\tstruct nls_table *nls_codepage;\n\tstruct cifs_ses *ses;\n\tint retries;\n\n\t/*\n\t * SMB2s NegProt, SessSetup, Logoff do not have tcon yet so\n\t * check for tcp and smb session status done differently\n\t * for those three - in the calling routine.\n\t */\n\tif (tcon == NULL)\n\t\treturn 0;\n\n\tif (smb2_command == SMB2_TREE_CONNECT)\n\t\treturn 0;\n\n\tif (tcon->tidStatus == CifsExiting) {\n\t\t/*\n\t\t * only tree disconnect, open, and write,\n\t\t * (and ulogoff which does not have tcon)\n\t\t * are allowed as we start force umount.\n\t\t */\n\t\tif ((smb2_command != SMB2_WRITE) &&\n\t\t   (smb2_command != SMB2_CREATE) &&\n\t\t   (smb2_command != SMB2_TREE_DISCONNECT)) {\n\t\t\tcifs_dbg(FYI, \"can not send cmd %d while umounting\\n\",\n\t\t\t\t smb2_command);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tif ((!tcon->ses) || (tcon->ses->status == CifsExiting) ||\n\t    (!tcon->ses->server) || !server)\n\t\treturn -EIO;\n\n\tses = tcon->ses;\n\tretries = server->nr_targets;\n\n\t/*\n\t * Give demultiplex thread up to 10 seconds to each target available for\n\t * reconnect -- should be greater than cifs socket timeout which is 7\n\t * seconds.\n\t */\n\twhile (server->tcpStatus == CifsNeedReconnect) {\n\t\t/*\n\t\t * Return to caller for TREE_DISCONNECT and LOGOFF and CLOSE\n\t\t * here since they are implicitly done when session drops.\n\t\t */\n\t\tswitch (smb2_command) {\n\t\t/*\n\t\t * BB Should we keep oplock break and add flush to exceptions?\n\t\t */\n\t\tcase SMB2_TREE_DISCONNECT:\n\t\tcase SMB2_CANCEL:\n\t\tcase SMB2_CLOSE:\n\t\tcase SMB2_OPLOCK_BREAK:\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\trc = wait_event_interruptible_timeout(server->response_q,\n\t\t\t\t\t\t      (server->tcpStatus != CifsNeedReconnect),\n\t\t\t\t\t\t      10 * HZ);\n\t\tif (rc < 0) {\n\t\t\tcifs_dbg(FYI, \"%s: aborting reconnect due to a received signal by the process\\n\",\n\t\t\t\t __func__);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\n\t\t/* are we still trying to reconnect? */\n\t\tif (server->tcpStatus != CifsNeedReconnect)\n\t\t\tbreak;\n\n\t\tif (retries && --retries)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * on \"soft\" mounts we wait once. Hard mounts keep\n\t\t * retrying until process is killed or server comes\n\t\t * back on-line\n\t\t */\n\t\tif (!tcon->retry) {\n\t\t\tcifs_dbg(FYI, \"gave up waiting on reconnect in smb_init\\n\");\n\t\t\treturn -EHOSTDOWN;\n\t\t}\n\t\tretries = server->nr_targets;\n\t}\n\n\tif (!tcon->ses->need_reconnect && !tcon->need_reconnect)\n\t\treturn 0;\n\n\tnls_codepage = load_nls_default();\n\n\t/*\n\t * need to prevent multiple threads trying to simultaneously reconnect\n\t * the same SMB session\n\t */\n\tmutex_lock(&tcon->ses->session_mutex);\n\n\t/*\n\t * Recheck after acquire mutex. If another thread is negotiating\n\t * and the server never sends an answer the socket will be closed\n\t * and tcpStatus set to reconnect.\n\t */\n\tif (server->tcpStatus == CifsNeedReconnect) {\n\t\trc = -EHOSTDOWN;\n\t\tmutex_unlock(&tcon->ses->session_mutex);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If we are reconnecting an extra channel, bind\n\t */\n\tif (server->is_channel) {\n\t\tses->binding = true;\n\t\tses->binding_chan = cifs_ses_find_chan(ses, server);\n\t}\n\n\trc = cifs_negotiate_protocol(0, tcon->ses);\n\tif (!rc && tcon->ses->need_reconnect) {\n\t\trc = cifs_setup_session(0, tcon->ses, nls_codepage);\n\t\tif ((rc == -EACCES) && !tcon->retry) {\n\t\t\trc = -EHOSTDOWN;\n\t\t\tses->binding = false;\n\t\t\tses->binding_chan = NULL;\n\t\t\tmutex_unlock(&tcon->ses->session_mutex);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\t/*\n\t * End of channel binding\n\t */\n\tses->binding = false;\n\tses->binding_chan = NULL;\n\n\tif (rc || !tcon->need_reconnect) {\n\t\tmutex_unlock(&tcon->ses->session_mutex);\n\t\tgoto out;\n\t}\n\n\tcifs_mark_open_files_invalid(tcon);\n\tif (tcon->use_persistent)\n\t\ttcon->need_reopen_files = true;\n\n\trc = cifs_tree_connect(0, tcon, nls_codepage);\n\tmutex_unlock(&tcon->ses->session_mutex);\n\n\tcifs_dbg(FYI, \"reconnect tcon rc = %d\\n\", rc);\n\tif (rc) {\n\t\t/* If sess reconnected but tcon didn't, something strange ... */\n\t\tpr_warn_once(\"reconnect tcon failed rc = %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tif (smb2_command != SMB2_INTERNAL_CMD)\n\t\tmod_delayed_work(cifsiod_wq, &server->reconnect, 0);\n\n\tatomic_inc(&tconInfoReconnectCount);\nout:\n\t/*\n\t * Check if handle based operation so we know whether we can continue\n\t * or not without returning to caller to reset file handle.\n\t */\n\t/*\n\t * BB Is flush done by server on drop of tcp session? Should we special\n\t * case it and skip above?\n\t */\n\tswitch (smb2_command) {\n\tcase SMB2_FLUSH:\n\tcase SMB2_READ:\n\tcase SMB2_WRITE:\n\tcase SMB2_LOCK:\n\tcase SMB2_IOCTL:\n\tcase SMB2_QUERY_DIRECTORY:\n\tcase SMB2_CHANGE_NOTIFY:\n\tcase SMB2_QUERY_INFO:\n\tcase SMB2_SET_INFO:\n\t\trc = -EAGAIN;\n\t}\nfailed:\n\tunload_nls(nls_codepage);\n\treturn rc;\n}\n\nstatic void\nfill_small_buf(__le16 smb2_command, struct cifs_tcon *tcon,\n\t       struct TCP_Server_Info *server,\n\t       void *buf,\n\t       unsigned int *total_len)\n{\n\tstruct smb2_sync_pdu *spdu = (struct smb2_sync_pdu *)buf;\n\t/* lookup word count ie StructureSize from table */\n\t__u16 parmsize = smb2_req_struct_sizes[le16_to_cpu(smb2_command)];\n\n\t/*\n\t * smaller than SMALL_BUFFER_SIZE but bigger than fixed area of\n\t * largest operations (Create)\n\t */\n\tmemset(buf, 0, 256);\n\n\tsmb2_hdr_assemble(&spdu->sync_hdr, smb2_command, tcon, server);\n\tspdu->StructureSize2 = cpu_to_le16(parmsize);\n\n\t*total_len = parmsize + sizeof(struct smb2_sync_hdr);\n}\n\n/*\n * Allocate and return pointer to an SMB request hdr, and set basic\n * SMB information in the SMB header. If the return code is zero, this\n * function must have filled in request_buf pointer.\n */\nstatic int __smb2_plain_req_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\t\t\t struct TCP_Server_Info *server,\n\t\t\t\t void **request_buf, unsigned int *total_len)\n{\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\tif (smb2_command == SMB2_SET_INFO)\n\t\t*request_buf = cifs_buf_get();\n\telse\n\t\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tfill_small_buf(smb2_command, tcon, server,\n\t\t       (struct smb2_sync_hdr *)(*request_buf),\n\t\t       total_len);\n\n\tif (tcon != NULL) {\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn 0;\n}\n\nstatic int smb2_plain_req_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\t\t       struct TCP_Server_Info *server,\n\t\t\t       void **request_buf, unsigned int *total_len)\n{\n\tint rc;\n\n\trc = smb2_reconnect(smb2_command, tcon, server);\n\tif (rc)\n\t\treturn rc;\n\n\treturn __smb2_plain_req_init(smb2_command, tcon, server, request_buf,\n\t\t\t\t     total_len);\n}\n\nstatic int smb2_ioctl_req_init(u32 opcode, struct cifs_tcon *tcon,\n\t\t\t       struct TCP_Server_Info *server,\n\t\t\t       void **request_buf, unsigned int *total_len)\n{\n\t/* Skip reconnect only for FSCTL_VALIDATE_NEGOTIATE_INFO IOCTLs */\n\tif (opcode == FSCTL_VALIDATE_NEGOTIATE_INFO) {\n\t\treturn __smb2_plain_req_init(SMB2_IOCTL, tcon, server,\n\t\t\t\t\t     request_buf, total_len);\n\t}\n\treturn smb2_plain_req_init(SMB2_IOCTL, tcon, server,\n\t\t\t\t   request_buf, total_len);\n}\n\n/* For explanation of negotiate contexts see MS-SMB2 section 2.2.3.1 */\n\nstatic void\nbuild_preauth_ctxt(struct smb2_preauth_neg_context *pneg_ctxt)\n{\n\tpneg_ctxt->ContextType = SMB2_PREAUTH_INTEGRITY_CAPABILITIES;\n\tpneg_ctxt->DataLength = cpu_to_le16(38);\n\tpneg_ctxt->HashAlgorithmCount = cpu_to_le16(1);\n\tpneg_ctxt->SaltLength = cpu_to_le16(SMB311_LINUX_CLIENT_SALT_SIZE);\n\tget_random_bytes(pneg_ctxt->Salt, SMB311_LINUX_CLIENT_SALT_SIZE);\n\tpneg_ctxt->HashAlgorithms = SMB2_PREAUTH_INTEGRITY_SHA512;\n}\n\nstatic void\nbuild_compression_ctxt(struct smb2_compression_capabilities_context *pneg_ctxt)\n{\n\tpneg_ctxt->ContextType = SMB2_COMPRESSION_CAPABILITIES;\n\tpneg_ctxt->DataLength =\n\t\tcpu_to_le16(sizeof(struct smb2_compression_capabilities_context)\n\t\t\t  - sizeof(struct smb2_neg_context));\n\tpneg_ctxt->CompressionAlgorithmCount = cpu_to_le16(3);\n\tpneg_ctxt->CompressionAlgorithms[0] = SMB3_COMPRESS_LZ77;\n\tpneg_ctxt->CompressionAlgorithms[1] = SMB3_COMPRESS_LZ77_HUFF;\n\tpneg_ctxt->CompressionAlgorithms[2] = SMB3_COMPRESS_LZNT1;\n}\n\nstatic void\nbuild_encrypt_ctxt(struct smb2_encryption_neg_context *pneg_ctxt)\n{\n\tpneg_ctxt->ContextType = SMB2_ENCRYPTION_CAPABILITIES;\n\tif (require_gcm_256) {\n\t\tpneg_ctxt->DataLength = cpu_to_le16(4); /* Cipher Count + 1 cipher */\n\t\tpneg_ctxt->CipherCount = cpu_to_le16(1);\n\t\tpneg_ctxt->Ciphers[0] = SMB2_ENCRYPTION_AES256_GCM;\n\t} else if (enable_gcm_256) {\n\t\tpneg_ctxt->DataLength = cpu_to_le16(8); /* Cipher Count + 3 ciphers */\n\t\tpneg_ctxt->CipherCount = cpu_to_le16(3);\n\t\tpneg_ctxt->Ciphers[0] = SMB2_ENCRYPTION_AES128_GCM;\n\t\tpneg_ctxt->Ciphers[1] = SMB2_ENCRYPTION_AES256_GCM;\n\t\tpneg_ctxt->Ciphers[2] = SMB2_ENCRYPTION_AES128_CCM;\n\t} else {\n\t\tpneg_ctxt->DataLength = cpu_to_le16(6); /* Cipher Count + 2 ciphers */\n\t\tpneg_ctxt->CipherCount = cpu_to_le16(2);\n\t\tpneg_ctxt->Ciphers[0] = SMB2_ENCRYPTION_AES128_GCM;\n\t\tpneg_ctxt->Ciphers[1] = SMB2_ENCRYPTION_AES128_CCM;\n\t}\n}\n\nstatic unsigned int\nbuild_netname_ctxt(struct smb2_netname_neg_context *pneg_ctxt, char *hostname)\n{\n\tstruct nls_table *cp = load_nls_default();\n\n\tpneg_ctxt->ContextType = SMB2_NETNAME_NEGOTIATE_CONTEXT_ID;\n\n\t/* copy up to max of first 100 bytes of server name to NetName field */\n\tpneg_ctxt->DataLength = cpu_to_le16(2 * cifs_strtoUTF16(pneg_ctxt->NetName, hostname, 100, cp));\n\t/* context size is DataLength + minimal smb2_neg_context */\n\treturn DIV_ROUND_UP(le16_to_cpu(pneg_ctxt->DataLength) +\n\t\t\tsizeof(struct smb2_neg_context), 8) * 8;\n}\n\nstatic void\nbuild_posix_ctxt(struct smb2_posix_neg_context *pneg_ctxt)\n{\n\tpneg_ctxt->ContextType = SMB2_POSIX_EXTENSIONS_AVAILABLE;\n\tpneg_ctxt->DataLength = cpu_to_le16(POSIX_CTXT_DATA_LEN);\n\t/* SMB2_CREATE_TAG_POSIX is \"0x93AD25509CB411E7B42383DE968BCD7C\" */\n\tpneg_ctxt->Name[0] = 0x93;\n\tpneg_ctxt->Name[1] = 0xAD;\n\tpneg_ctxt->Name[2] = 0x25;\n\tpneg_ctxt->Name[3] = 0x50;\n\tpneg_ctxt->Name[4] = 0x9C;\n\tpneg_ctxt->Name[5] = 0xB4;\n\tpneg_ctxt->Name[6] = 0x11;\n\tpneg_ctxt->Name[7] = 0xE7;\n\tpneg_ctxt->Name[8] = 0xB4;\n\tpneg_ctxt->Name[9] = 0x23;\n\tpneg_ctxt->Name[10] = 0x83;\n\tpneg_ctxt->Name[11] = 0xDE;\n\tpneg_ctxt->Name[12] = 0x96;\n\tpneg_ctxt->Name[13] = 0x8B;\n\tpneg_ctxt->Name[14] = 0xCD;\n\tpneg_ctxt->Name[15] = 0x7C;\n}\n\nstatic void\nassemble_neg_contexts(struct smb2_negotiate_req *req,\n\t\t      struct TCP_Server_Info *server, unsigned int *total_len)\n{\n\tchar *pneg_ctxt;\n\tunsigned int ctxt_len;\n\n\tif (*total_len > 200) {\n\t\t/* In case length corrupted don't want to overrun smb buffer */\n\t\tcifs_server_dbg(VFS, \"Bad frame length assembling neg contexts\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * round up total_len of fixed part of SMB3 negotiate request to 8\n\t * byte boundary before adding negotiate contexts\n\t */\n\t*total_len = roundup(*total_len, 8);\n\n\tpneg_ctxt = (*total_len) + (char *)req;\n\treq->NegotiateContextOffset = cpu_to_le32(*total_len);\n\n\tbuild_preauth_ctxt((struct smb2_preauth_neg_context *)pneg_ctxt);\n\tctxt_len = DIV_ROUND_UP(sizeof(struct smb2_preauth_neg_context), 8) * 8;\n\t*total_len += ctxt_len;\n\tpneg_ctxt += ctxt_len;\n\n\tbuild_encrypt_ctxt((struct smb2_encryption_neg_context *)pneg_ctxt);\n\tctxt_len = DIV_ROUND_UP(sizeof(struct smb2_encryption_neg_context), 8) * 8;\n\t*total_len += ctxt_len;\n\tpneg_ctxt += ctxt_len;\n\n\tif (server->compress_algorithm) {\n\t\tbuild_compression_ctxt((struct smb2_compression_capabilities_context *)\n\t\t\t\tpneg_ctxt);\n\t\tctxt_len = DIV_ROUND_UP(\n\t\t\tsizeof(struct smb2_compression_capabilities_context),\n\t\t\t\t8) * 8;\n\t\t*total_len += ctxt_len;\n\t\tpneg_ctxt += ctxt_len;\n\t\treq->NegotiateContextCount = cpu_to_le16(5);\n\t} else\n\t\treq->NegotiateContextCount = cpu_to_le16(4);\n\n\tctxt_len = build_netname_ctxt((struct smb2_netname_neg_context *)pneg_ctxt,\n\t\t\t\t\tserver->hostname);\n\t*total_len += ctxt_len;\n\tpneg_ctxt += ctxt_len;\n\n\tbuild_posix_ctxt((struct smb2_posix_neg_context *)pneg_ctxt);\n\t*total_len += sizeof(struct smb2_posix_neg_context);\n}\n\nstatic void decode_preauth_context(struct smb2_preauth_neg_context *ctxt)\n{\n\tunsigned int len = le16_to_cpu(ctxt->DataLength);\n\n\t/* If invalid preauth context warn but use what we requested, SHA-512 */\n\tif (len < MIN_PREAUTH_CTXT_DATA_LEN) {\n\t\tpr_warn_once(\"server sent bad preauth context\\n\");\n\t\treturn;\n\t} else if (len < MIN_PREAUTH_CTXT_DATA_LEN + le16_to_cpu(ctxt->SaltLength)) {\n\t\tpr_warn_once(\"server sent invalid SaltLength\\n\");\n\t\treturn;\n\t}\n\tif (le16_to_cpu(ctxt->HashAlgorithmCount) != 1)\n\t\tpr_warn_once(\"Invalid SMB3 hash algorithm count\\n\");\n\tif (ctxt->HashAlgorithms != SMB2_PREAUTH_INTEGRITY_SHA512)\n\t\tpr_warn_once(\"unknown SMB3 hash algorithm\\n\");\n}\n\nstatic void decode_compress_ctx(struct TCP_Server_Info *server,\n\t\t\t struct smb2_compression_capabilities_context *ctxt)\n{\n\tunsigned int len = le16_to_cpu(ctxt->DataLength);\n\n\t/* sizeof compress context is a one element compression capbility struct */\n\tif (len < 10) {\n\t\tpr_warn_once(\"server sent bad compression cntxt\\n\");\n\t\treturn;\n\t}\n\tif (le16_to_cpu(ctxt->CompressionAlgorithmCount) != 1) {\n\t\tpr_warn_once(\"Invalid SMB3 compress algorithm count\\n\");\n\t\treturn;\n\t}\n\tif (le16_to_cpu(ctxt->CompressionAlgorithms[0]) > 3) {\n\t\tpr_warn_once(\"unknown compression algorithm\\n\");\n\t\treturn;\n\t}\n\tserver->compress_algorithm = ctxt->CompressionAlgorithms[0];\n}\n\nstatic int decode_encrypt_ctx(struct TCP_Server_Info *server,\n\t\t\t      struct smb2_encryption_neg_context *ctxt)\n{\n\tunsigned int len = le16_to_cpu(ctxt->DataLength);\n\n\tcifs_dbg(FYI, \"decode SMB3.11 encryption neg context of len %d\\n\", len);\n\tif (len < MIN_ENCRYPT_CTXT_DATA_LEN) {\n\t\tpr_warn_once(\"server sent bad crypto ctxt len\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (le16_to_cpu(ctxt->CipherCount) != 1) {\n\t\tpr_warn_once(\"Invalid SMB3.11 cipher count\\n\");\n\t\treturn -EINVAL;\n\t}\n\tcifs_dbg(FYI, \"SMB311 cipher type:%d\\n\", le16_to_cpu(ctxt->Ciphers[0]));\n\tif (require_gcm_256) {\n\t\tif (ctxt->Ciphers[0] != SMB2_ENCRYPTION_AES256_GCM) {\n\t\t\tcifs_dbg(VFS, \"Server does not support requested encryption type (AES256 GCM)\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t} else if (ctxt->Ciphers[0] == 0) {\n\t\t/*\n\t\t * e.g. if server only supported AES256_CCM (very unlikely)\n\t\t * or server supported no encryption types or had all disabled.\n\t\t * Since GLOBAL_CAP_ENCRYPTION will be not set, in the case\n\t\t * in which mount requested encryption (\"seal\") checks later\n\t\t * on during tree connection will return proper rc, but if\n\t\t * seal not requested by client, since server is allowed to\n\t\t * return 0 to indicate no supported cipher, we can't fail here\n\t\t */\n\t\tserver->cipher_type = 0;\n\t\tserver->capabilities &= ~SMB2_GLOBAL_CAP_ENCRYPTION;\n\t\tpr_warn_once(\"Server does not support requested encryption types\\n\");\n\t\treturn 0;\n\t} else if ((ctxt->Ciphers[0] != SMB2_ENCRYPTION_AES128_CCM) &&\n\t\t   (ctxt->Ciphers[0] != SMB2_ENCRYPTION_AES128_GCM) &&\n\t\t   (ctxt->Ciphers[0] != SMB2_ENCRYPTION_AES256_GCM)) {\n\t\t/* server returned a cipher we didn't ask for */\n\t\tpr_warn_once(\"Invalid SMB3.11 cipher returned\\n\");\n\t\treturn -EINVAL;\n\t}\n\tserver->cipher_type = ctxt->Ciphers[0];\n\tserver->capabilities |= SMB2_GLOBAL_CAP_ENCRYPTION;\n\treturn 0;\n}\n\nstatic int smb311_decode_neg_context(struct smb2_negotiate_rsp *rsp,\n\t\t\t\t     struct TCP_Server_Info *server,\n\t\t\t\t     unsigned int len_of_smb)\n{\n\tstruct smb2_neg_context *pctx;\n\tunsigned int offset = le32_to_cpu(rsp->NegotiateContextOffset);\n\tunsigned int ctxt_cnt = le16_to_cpu(rsp->NegotiateContextCount);\n\tunsigned int len_of_ctxts, i;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"decoding %d negotiate contexts\\n\", ctxt_cnt);\n\tif (len_of_smb <= offset) {\n\t\tcifs_server_dbg(VFS, \"Invalid response: negotiate context offset\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlen_of_ctxts = len_of_smb - offset;\n\n\tfor (i = 0; i < ctxt_cnt; i++) {\n\t\tint clen;\n\t\t/* check that offset is not beyond end of SMB */\n\t\tif (len_of_ctxts == 0)\n\t\t\tbreak;\n\n\t\tif (len_of_ctxts < sizeof(struct smb2_neg_context))\n\t\t\tbreak;\n\n\t\tpctx = (struct smb2_neg_context *)(offset + (char *)rsp);\n\t\tclen = le16_to_cpu(pctx->DataLength);\n\t\tif (clen > len_of_ctxts)\n\t\t\tbreak;\n\n\t\tif (pctx->ContextType == SMB2_PREAUTH_INTEGRITY_CAPABILITIES)\n\t\t\tdecode_preauth_context(\n\t\t\t\t(struct smb2_preauth_neg_context *)pctx);\n\t\telse if (pctx->ContextType == SMB2_ENCRYPTION_CAPABILITIES)\n\t\t\trc = decode_encrypt_ctx(server,\n\t\t\t\t(struct smb2_encryption_neg_context *)pctx);\n\t\telse if (pctx->ContextType == SMB2_COMPRESSION_CAPABILITIES)\n\t\t\tdecode_compress_ctx(server,\n\t\t\t\t(struct smb2_compression_capabilities_context *)pctx);\n\t\telse if (pctx->ContextType == SMB2_POSIX_EXTENSIONS_AVAILABLE)\n\t\t\tserver->posix_ext_supported = true;\n\t\telse\n\t\t\tcifs_server_dbg(VFS, \"unknown negcontext of type %d ignored\\n\",\n\t\t\t\tle16_to_cpu(pctx->ContextType));\n\n\t\tif (rc)\n\t\t\tbreak;\n\t\t/* offsets must be 8 byte aligned */\n\t\tclen = (clen + 7) & ~0x7;\n\t\toffset += clen + sizeof(struct smb2_neg_context);\n\t\tlen_of_ctxts -= clen;\n\t}\n\treturn rc;\n}\n\nstatic struct create_posix *\ncreate_posix_buf(umode_t mode)\n{\n\tstruct create_posix *buf;\n\n\tbuf = kzalloc(sizeof(struct create_posix),\n\t\t\tGFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset =\n\t\tcpu_to_le16(offsetof(struct create_posix, Mode));\n\tbuf->ccontext.DataLength = cpu_to_le32(4);\n\tbuf->ccontext.NameOffset =\n\t\tcpu_to_le16(offsetof(struct create_posix, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(16);\n\n\t/* SMB2_CREATE_TAG_POSIX is \"0x93AD25509CB411E7B42383DE968BCD7C\" */\n\tbuf->Name[0] = 0x93;\n\tbuf->Name[1] = 0xAD;\n\tbuf->Name[2] = 0x25;\n\tbuf->Name[3] = 0x50;\n\tbuf->Name[4] = 0x9C;\n\tbuf->Name[5] = 0xB4;\n\tbuf->Name[6] = 0x11;\n\tbuf->Name[7] = 0xE7;\n\tbuf->Name[8] = 0xB4;\n\tbuf->Name[9] = 0x23;\n\tbuf->Name[10] = 0x83;\n\tbuf->Name[11] = 0xDE;\n\tbuf->Name[12] = 0x96;\n\tbuf->Name[13] = 0x8B;\n\tbuf->Name[14] = 0xCD;\n\tbuf->Name[15] = 0x7C;\n\tbuf->Mode = cpu_to_le32(mode);\n\tcifs_dbg(FYI, \"mode on posix create 0%o\\n\", mode);\n\treturn buf;\n}\n\nstatic int\nadd_posix_context(struct kvec *iov, unsigned int *num_iovec, umode_t mode)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tiov[num].iov_base = create_posix_buf(mode);\n\tif (mode == ACL_NO_MODE)\n\t\tcifs_dbg(FYI, \"Invalid mode\\n\");\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct create_posix);\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset = cpu_to_le32(\n\t\t\t\tsizeof(struct smb2_create_req) +\n\t\t\t\tiov[num - 1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength, sizeof(struct create_posix));\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\n\n/*\n *\n *\tSMB2 Worker functions follow:\n *\n *\tThe general structure of the worker functions is:\n *\t1) Call smb2_init (assembles SMB2 header)\n *\t2) Initialize SMB2 command specific fields in fixed length area of SMB\n *\t3) Call smb_sendrcv2 (sends request on socket and waits for response)\n *\t4) Decode SMB2 command specific fields in the fixed length area\n *\t5) Decode variable length data area (if any for this SMB2 command type)\n *\t6) Call free smb buffer\n *\t7) return\n *\n */\n\nint\nSMB2_negotiate(const unsigned int xid, struct cifs_ses *ses)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_negotiate_req *req;\n\tstruct smb2_negotiate_rsp *rsp;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct TCP_Server_Info *server = cifs_ses_server(ses);\n\tint blob_offset, blob_length;\n\tchar *security_blob;\n\tint flags = CIFS_NEG_OP;\n\tunsigned int total_len;\n\n\tcifs_dbg(FYI, \"Negotiate protocol\\n\");\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\trc = smb2_plain_req_init(SMB2_NEGOTIATE, NULL, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->sync_hdr.SessionId = 0;\n\n\tmemset(server->preauth_sha_hash, 0, SMB2_PREAUTH_HASH_SIZE);\n\tmemset(ses->preauth_sha_hash, 0, SMB2_PREAUTH_HASH_SIZE);\n\n\tif (strcmp(server->vals->version_string,\n\t\t   SMB3ANY_VERSION_STRING) == 0) {\n\t\treq->Dialects[0] = cpu_to_le16(SMB30_PROT_ID);\n\t\treq->Dialects[1] = cpu_to_le16(SMB302_PROT_ID);\n\t\treq->DialectCount = cpu_to_le16(2);\n\t\ttotal_len += 4;\n\t} else if (strcmp(server->vals->version_string,\n\t\t   SMBDEFAULT_VERSION_STRING) == 0) {\n\t\treq->Dialects[0] = cpu_to_le16(SMB21_PROT_ID);\n\t\treq->Dialects[1] = cpu_to_le16(SMB30_PROT_ID);\n\t\treq->Dialects[2] = cpu_to_le16(SMB302_PROT_ID);\n\t\treq->Dialects[3] = cpu_to_le16(SMB311_PROT_ID);\n\t\treq->DialectCount = cpu_to_le16(4);\n\t\ttotal_len += 8;\n\t} else {\n\t\t/* otherwise send specific dialect */\n\t\treq->Dialects[0] = cpu_to_le16(server->vals->protocol_id);\n\t\treq->DialectCount = cpu_to_le16(1);\n\t\ttotal_len += 2;\n\t}\n\n\t/* only one of SMB2 signing flags may be set in SMB2 request */\n\tif (ses->sign)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\n\telse if (global_secflags & CIFSSEC_MAY_SIGN)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\n\telse\n\t\treq->SecurityMode = 0;\n\n\treq->Capabilities = cpu_to_le32(server->vals->req_capabilities);\n\n\t/* ClientGUID must be zero for SMB2.02 dialect */\n\tif (server->vals->protocol_id == SMB20_PROT_ID)\n\t\tmemset(req->ClientGUID, 0, SMB2_CLIENT_GUID_SIZE);\n\telse {\n\t\tmemcpy(req->ClientGUID, server->client_guid,\n\t\t\tSMB2_CLIENT_GUID_SIZE);\n\t\tif ((server->vals->protocol_id == SMB311_PROT_ID) ||\n\t\t    (strcmp(server->vals->version_string,\n\t\t     SMBDEFAULT_VERSION_STRING) == 0))\n\t\t\tassemble_neg_contexts(req, server, &total_len);\n\t}\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_negotiate_rsp *)rsp_iov.iov_base;\n\t/*\n\t * No tcon so can't do\n\t * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);\n\t */\n\tif (rc == -EOPNOTSUPP) {\n\t\tcifs_server_dbg(VFS, \"Dialect not supported by server. Consider  specifying vers=1.0 or vers=2.0 on mount for accessing older servers\\n\");\n\t\tgoto neg_exit;\n\t} else if (rc != 0)\n\t\tgoto neg_exit;\n\n\tif (strcmp(server->vals->version_string,\n\t\t   SMB3ANY_VERSION_STRING) == 0) {\n\t\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID)) {\n\t\t\tcifs_server_dbg(VFS,\n\t\t\t\t\"SMB2 dialect returned but not requested\\n\");\n\t\t\treturn -EIO;\n\t\t} else if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID)) {\n\t\t\tcifs_server_dbg(VFS,\n\t\t\t\t\"SMB2.1 dialect returned but not requested\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else if (strcmp(server->vals->version_string,\n\t\t   SMBDEFAULT_VERSION_STRING) == 0) {\n\t\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID)) {\n\t\t\tcifs_server_dbg(VFS,\n\t\t\t\t\"SMB2 dialect returned but not requested\\n\");\n\t\t\treturn -EIO;\n\t\t} else if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID)) {\n\t\t\t/* ops set to 3.0 by default for default so update */\n\t\t\tserver->ops = &smb21_operations;\n\t\t\tserver->vals = &smb21_values;\n\t\t} else if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID)) {\n\t\t\tserver->ops = &smb311_operations;\n\t\t\tserver->vals = &smb311_values;\n\t\t}\n\t} else if (le16_to_cpu(rsp->DialectRevision) !=\n\t\t\t\tserver->vals->protocol_id) {\n\t\t/* if requested single dialect ensure returned dialect matched */\n\t\tcifs_server_dbg(VFS, \"Invalid 0x%x dialect returned: not requested\\n\",\n\t\t\t\tle16_to_cpu(rsp->DialectRevision));\n\t\treturn -EIO;\n\t}\n\n\tcifs_dbg(FYI, \"mode 0x%x\\n\", rsp->SecurityMode);\n\n\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.1 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB30_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB302_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.02 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.1.1 dialect\\n\");\n\telse {\n\t\tcifs_server_dbg(VFS, \"Invalid dialect returned by server 0x%x\\n\",\n\t\t\t\tle16_to_cpu(rsp->DialectRevision));\n\t\trc = -EIO;\n\t\tgoto neg_exit;\n\t}\n\tserver->dialect = le16_to_cpu(rsp->DialectRevision);\n\n\t/*\n\t * Keep a copy of the hash after negprot. This hash will be\n\t * the starting hash value for all sessions made from this\n\t * server.\n\t */\n\tmemcpy(server->preauth_sha_hash, ses->preauth_sha_hash,\n\t       SMB2_PREAUTH_HASH_SIZE);\n\n\t/* SMB2 only has an extended negflavor */\n\tserver->negflavor = CIFS_NEGFLAVOR_EXTENDED;\n\t/* set it to the maximum buffer size value we can send with 1 credit */\n\tserver->maxBuf = min_t(unsigned int, le32_to_cpu(rsp->MaxTransactSize),\n\t\t\t       SMB2_MAX_BUFFER_SIZE);\n\tserver->max_read = le32_to_cpu(rsp->MaxReadSize);\n\tserver->max_write = le32_to_cpu(rsp->MaxWriteSize);\n\tserver->sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tif ((server->sec_mode & SMB2_SEC_MODE_FLAGS_ALL) != server->sec_mode)\n\t\tcifs_dbg(FYI, \"Server returned unexpected security mode 0x%x\\n\",\n\t\t\t\tserver->sec_mode);\n\tserver->capabilities = le32_to_cpu(rsp->Capabilities);\n\t/* Internal types */\n\tserver->capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES;\n\n\tsecurity_blob = smb2_get_data_area_len(&blob_offset, &blob_length,\n\t\t\t\t\t       (struct smb2_sync_hdr *)rsp);\n\t/*\n\t * See MS-SMB2 section 2.2.4: if no blob, client picks default which\n\t * for us will be\n\t *\tses->sectype = RawNTLMSSP;\n\t * but for time being this is our only auth choice so doesn't matter.\n\t * We just found a server which sets blob length to zero expecting raw.\n\t */\n\tif (blob_length == 0) {\n\t\tcifs_dbg(FYI, \"missing security blob on negprot\\n\");\n\t\tserver->sec_ntlmssp = true;\n\t}\n\n\trc = cifs_enable_signing(server, ses->sign);\n\tif (rc)\n\t\tgoto neg_exit;\n\tif (blob_length) {\n\t\trc = decode_negTokenInit(security_blob, blob_length, server);\n\t\tif (rc == 1)\n\t\t\trc = 0;\n\t\telse if (rc == 0)\n\t\t\trc = -EIO;\n\t}\n\n\tif (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID)) {\n\t\tif (rsp->NegotiateContextCount)\n\t\t\trc = smb311_decode_neg_context(rsp, server,\n\t\t\t\t\t\t       rsp_iov.iov_len);\n\t\telse\n\t\t\tcifs_server_dbg(VFS, \"Missing expected negotiate contexts\\n\");\n\t}\nneg_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nint smb3_validate_negotiate(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tint rc;\n\tstruct validate_negotiate_info_req *pneg_inbuf;\n\tstruct validate_negotiate_info_rsp *pneg_rsp = NULL;\n\tu32 rsplen;\n\tu32 inbuflen; /* max of 4 dialects */\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\tcifs_dbg(FYI, \"validate negotiate\\n\");\n\n\t/* In SMB3.11 preauth integrity supersedes validate negotiate */\n\tif (server->dialect == SMB311_PROT_ID)\n\t\treturn 0;\n\n\t/*\n\t * validation ioctl must be signed, so no point sending this if we\n\t * can not sign it (ie are not known user).  Even if signing is not\n\t * required (enabled but not negotiated), in those cases we selectively\n\t * sign just this, the first and only signed request on a connection.\n\t * Having validation of negotiate info  helps reduce attack vectors.\n\t */\n\tif (tcon->ses->session_flags & SMB2_SESSION_FLAG_IS_GUEST)\n\t\treturn 0; /* validation requires signing */\n\n\tif (tcon->ses->user_name == NULL) {\n\t\tcifs_dbg(FYI, \"Can't validate negotiate: null user mount\\n\");\n\t\treturn 0; /* validation requires signing */\n\t}\n\n\tif (tcon->ses->session_flags & SMB2_SESSION_FLAG_IS_NULL)\n\t\tcifs_tcon_dbg(VFS, \"Unexpected null user (anonymous) auth flag sent by server\\n\");\n\n\tpneg_inbuf = kmalloc(sizeof(*pneg_inbuf), GFP_NOFS);\n\tif (!pneg_inbuf)\n\t\treturn -ENOMEM;\n\n\tpneg_inbuf->Capabilities =\n\t\t\tcpu_to_le32(server->vals->req_capabilities);\n\tmemcpy(pneg_inbuf->Guid, server->client_guid,\n\t\t\t\t\tSMB2_CLIENT_GUID_SIZE);\n\n\tif (tcon->ses->sign)\n\t\tpneg_inbuf->SecurityMode =\n\t\t\tcpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\n\telse if (global_secflags & CIFSSEC_MAY_SIGN)\n\t\tpneg_inbuf->SecurityMode =\n\t\t\tcpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\n\telse\n\t\tpneg_inbuf->SecurityMode = 0;\n\n\n\tif (strcmp(server->vals->version_string,\n\t\tSMB3ANY_VERSION_STRING) == 0) {\n\t\tpneg_inbuf->Dialects[0] = cpu_to_le16(SMB30_PROT_ID);\n\t\tpneg_inbuf->Dialects[1] = cpu_to_le16(SMB302_PROT_ID);\n\t\tpneg_inbuf->DialectCount = cpu_to_le16(2);\n\t\t/* structure is big enough for 3 dialects, sending only 2 */\n\t\tinbuflen = sizeof(*pneg_inbuf) -\n\t\t\t\t(2 * sizeof(pneg_inbuf->Dialects[0]));\n\t} else if (strcmp(server->vals->version_string,\n\t\tSMBDEFAULT_VERSION_STRING) == 0) {\n\t\tpneg_inbuf->Dialects[0] = cpu_to_le16(SMB21_PROT_ID);\n\t\tpneg_inbuf->Dialects[1] = cpu_to_le16(SMB30_PROT_ID);\n\t\tpneg_inbuf->Dialects[2] = cpu_to_le16(SMB302_PROT_ID);\n\t\tpneg_inbuf->Dialects[3] = cpu_to_le16(SMB311_PROT_ID);\n\t\tpneg_inbuf->DialectCount = cpu_to_le16(4);\n\t\t/* structure is big enough for 3 dialects */\n\t\tinbuflen = sizeof(*pneg_inbuf);\n\t} else {\n\t\t/* otherwise specific dialect was requested */\n\t\tpneg_inbuf->Dialects[0] =\n\t\t\tcpu_to_le16(server->vals->protocol_id);\n\t\tpneg_inbuf->DialectCount = cpu_to_le16(1);\n\t\t/* structure is big enough for 3 dialects, sending only 1 */\n\t\tinbuflen = sizeof(*pneg_inbuf) -\n\t\t\t\tsizeof(pneg_inbuf->Dialects[0]) * 2;\n\t}\n\n\trc = SMB2_ioctl(xid, tcon, NO_FILE_ID, NO_FILE_ID,\n\t\tFSCTL_VALIDATE_NEGOTIATE_INFO, true /* is_fsctl */,\n\t\t(char *)pneg_inbuf, inbuflen, CIFSMaxBufSize,\n\t\t(char **)&pneg_rsp, &rsplen);\n\tif (rc == -EOPNOTSUPP) {\n\t\t/*\n\t\t * Old Windows versions or Netapp SMB server can return\n\t\t * not supported error. Client should accept it.\n\t\t */\n\t\tcifs_tcon_dbg(VFS, \"Server does not support validate negotiate\\n\");\n\t\trc = 0;\n\t\tgoto out_free_inbuf;\n\t} else if (rc != 0) {\n\t\tcifs_tcon_dbg(VFS, \"validate protocol negotiate failed: %d\\n\",\n\t\t\t      rc);\n\t\trc = -EIO;\n\t\tgoto out_free_inbuf;\n\t}\n\n\trc = -EIO;\n\tif (rsplen != sizeof(*pneg_rsp)) {\n\t\tcifs_tcon_dbg(VFS, \"Invalid protocol negotiate response size: %d\\n\",\n\t\t\t      rsplen);\n\n\t\t/* relax check since Mac returns max bufsize allowed on ioctl */\n\t\tif (rsplen > CIFSMaxBufSize || rsplen < sizeof(*pneg_rsp))\n\t\t\tgoto out_free_rsp;\n\t}\n\n\t/* check validate negotiate info response matches what we got earlier */\n\tif (pneg_rsp->Dialect != cpu_to_le16(server->dialect))\n\t\tgoto vneg_out;\n\n\tif (pneg_rsp->SecurityMode != cpu_to_le16(server->sec_mode))\n\t\tgoto vneg_out;\n\n\t/* do not validate server guid because not saved at negprot time yet */\n\n\tif ((le32_to_cpu(pneg_rsp->Capabilities) | SMB2_NT_FIND |\n\t      SMB2_LARGE_FILES) != server->capabilities)\n\t\tgoto vneg_out;\n\n\t/* validate negotiate successful */\n\trc = 0;\n\tcifs_dbg(FYI, \"validate negotiate info successful\\n\");\n\tgoto out_free_rsp;\n\nvneg_out:\n\tcifs_tcon_dbg(VFS, \"protocol revalidation - security settings mismatch\\n\");\nout_free_rsp:\n\tkfree(pneg_rsp);\nout_free_inbuf:\n\tkfree(pneg_inbuf);\n\treturn rc;\n}\n\nenum securityEnum\nsmb2_select_sectype(struct TCP_Server_Info *server, enum securityEnum requested)\n{\n\tswitch (requested) {\n\tcase Kerberos:\n\tcase RawNTLMSSP:\n\t\treturn requested;\n\tcase NTLMv2:\n\t\treturn RawNTLMSSP;\n\tcase Unspecified:\n\t\tif (server->sec_ntlmssp &&\n\t\t\t(global_secflags & CIFSSEC_MAY_NTLMSSP))\n\t\t\treturn RawNTLMSSP;\n\t\tif ((server->sec_kerberos || server->sec_mskerberos) &&\n\t\t\t(global_secflags & CIFSSEC_MAY_KRB5))\n\t\t\treturn Kerberos;\n\t\tfallthrough;\n\tdefault:\n\t\treturn Unspecified;\n\t}\n}\n\nstruct SMB2_sess_data {\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct nls_table *nls_cp;\n\tvoid (*func)(struct SMB2_sess_data *);\n\tint result;\n\tu64 previous_session;\n\n\t/* we will send the SMB in three pieces:\n\t * a fixed length beginning part, an optional\n\t * SPNEGO blob (which can be zero length), and a\n\t * last part which will include the strings\n\t * and rest of bcc area. This allows us to avoid\n\t * a large buffer 17K allocation\n\t */\n\tint buf0_type;\n\tstruct kvec iov[2];\n};\n\nstatic int\nSMB2_sess_alloc_buffer(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb2_sess_setup_req *req;\n\tstruct TCP_Server_Info *server = cifs_ses_server(ses);\n\tunsigned int total_len;\n\n\trc = smb2_plain_req_init(SMB2_SESSION_SETUP, NULL, server,\n\t\t\t\t (void **) &req,\n\t\t\t\t &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (sess_data->ses->binding) {\n\t\treq->sync_hdr.SessionId = sess_data->ses->Suid;\n\t\treq->sync_hdr.Flags |= SMB2_FLAGS_SIGNED;\n\t\treq->PreviousSessionId = 0;\n\t\treq->Flags = SMB2_SESSION_REQ_FLAG_BINDING;\n\t} else {\n\t\t/* First session, not a reauthenticate */\n\t\treq->sync_hdr.SessionId = 0;\n\t\t/*\n\t\t * if reconnect, we need to send previous sess id\n\t\t * otherwise it is 0\n\t\t */\n\t\treq->PreviousSessionId = sess_data->previous_session;\n\t\treq->Flags = 0; /* MBZ */\n\t}\n\n\t/* enough to enable echos and oplocks and one max size write */\n\treq->sync_hdr.CreditRequest = cpu_to_le16(130);\n\n\t/* only one of SMB2 signing flags may be set in SMB2 request */\n\tif (server->sign)\n\t\treq->SecurityMode = SMB2_NEGOTIATE_SIGNING_REQUIRED;\n\telse if (global_secflags & CIFSSEC_MAY_SIGN) /* one flag unlike MUST_ */\n\t\treq->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED;\n\telse\n\t\treq->SecurityMode = 0;\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\treq->Capabilities = cpu_to_le32(SMB2_GLOBAL_CAP_DFS);\n#else\n\treq->Capabilities = 0;\n#endif /* DFS_UPCALL */\n\n\treq->Channel = 0; /* MBZ */\n\n\tsess_data->iov[0].iov_base = (char *)req;\n\t/* 1 for pad */\n\tsess_data->iov[0].iov_len = total_len - 1;\n\t/*\n\t * This variable will be used to clear the buffer\n\t * allocated above in case of any error in the calling function.\n\t */\n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\treturn 0;\n}\n\nstatic void\nSMB2_sess_free_buffer(struct SMB2_sess_data *sess_data)\n{\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n}\n\nstatic int\nSMB2_sess_sendreceive(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_rqst rqst;\n\tstruct smb2_sess_setup_req *req = sess_data->iov[0].iov_base;\n\tstruct kvec rsp_iov = { NULL, 0 };\n\n\t/* Testing shows that buffer offset must be at location of Buffer[0] */\n\treq->SecurityBufferOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_sess_setup_req) - 1 /* pad */);\n\treq->SecurityBufferLength = cpu_to_le16(sess_data->iov[1].iov_len);\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = sess_data->iov;\n\trqst.rq_nvec = 2;\n\n\t/* BB add code to build os and lm fields */\n\trc = cifs_send_recv(sess_data->xid, sess_data->ses,\n\t\t\t    cifs_ses_server(sess_data->ses),\n\t\t\t    &rqst,\n\t\t\t    &sess_data->buf0_type,\n\t\t\t    CIFS_LOG_ERROR | CIFS_NEG_OP, &rsp_iov);\n\tcifs_small_buf_release(sess_data->iov[0].iov_base);\n\tmemcpy(&sess_data->iov[0], &rsp_iov, sizeof(struct kvec));\n\n\treturn rc;\n}\n\nstatic int\nSMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct TCP_Server_Info *server = cifs_ses_server(ses);\n\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ops->generate_signingkey) {\n\t\trc = server->ops->generate_signingkey(ses);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI,\n\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\tmutex_unlock(&server->srv_mutex);\n\t\t\treturn rc;\n\t\t}\n\t}\n\tif (!server->session_estab) {\n\t\tserver->sequence_number = 0x2;\n\t\tserver->session_estab = true;\n\t}\n\tmutex_unlock(&server->srv_mutex);\n\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\t/* keep existing ses state if binding */\n\tif (!ses->binding) {\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tses->status = CifsGood;\n\t\tses->need_reconnect = false;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_UPCALL\nstatic void\nSMB2_auth_kerberos(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct cifs_spnego_msg *msg;\n\tstruct key *spnego_key = NULL;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\n\trc = SMB2_sess_alloc_buffer(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tspnego_key = cifs_get_spnego_key(ses);\n\tif (IS_ERR(spnego_key)) {\n\t\trc = PTR_ERR(spnego_key);\n\t\tif (rc == -ENOKEY)\n\t\t\tcifs_dbg(VFS, \"Verify user has a krb5 ticket and keyutils is installed\\n\");\n\t\tspnego_key = NULL;\n\t\tgoto out;\n\t}\n\n\tmsg = spnego_key->payload.data[0];\n\t/*\n\t * check version field to make sure that cifs.upcall is\n\t * sending us a response in an expected form\n\t */\n\tif (msg->version != CIFS_SPNEGO_UPCALL_VERSION) {\n\t\tcifs_dbg(VFS, \"bad cifs.upcall version. Expected %d got %d\\n\",\n\t\t\t CIFS_SPNEGO_UPCALL_VERSION, msg->version);\n\t\trc = -EKEYREJECTED;\n\t\tgoto out_put_spnego_key;\n\t}\n\n\t/* keep session key if binding */\n\tif (!ses->binding) {\n\t\tses->auth_key.response = kmemdup(msg->data, msg->sesskey_len,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!ses->auth_key.response) {\n\t\t\tcifs_dbg(VFS, \"Kerberos can't allocate (%u bytes) memory\\n\",\n\t\t\t\t msg->sesskey_len);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_put_spnego_key;\n\t\t}\n\t\tses->auth_key.len = msg->sesskey_len;\n\t}\n\n\tsess_data->iov[1].iov_base = msg->data + msg->sesskey_len;\n\tsess_data->iov[1].iov_len = msg->secblob_len;\n\n\trc = SMB2_sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out_put_spnego_key;\n\n\trsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;\n\t/* keep session id and flags if binding */\n\tif (!ses->binding) {\n\t\tses->Suid = rsp->sync_hdr.SessionId;\n\t\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\t}\n\n\trc = SMB2_sess_establish_session(sess_data);\nout_put_spnego_key:\n\tkey_invalidate(spnego_key);\n\tkey_put(spnego_key);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tSMB2_sess_free_buffer(sess_data);\n}\n#else\nstatic void\nSMB2_auth_kerberos(struct SMB2_sess_data *sess_data)\n{\n\tcifs_dbg(VFS, \"Kerberos negotiated but upcall support disabled!\\n\");\n\tsess_data->result = -EOPNOTSUPP;\n\tsess_data->func = NULL;\n}\n#endif\n\nstatic void\nSMB2_sess_auth_rawntlmssp_authenticate(struct SMB2_sess_data *sess_data);\n\nstatic void\nSMB2_sess_auth_rawntlmssp_negotiate(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\tchar *ntlmssp_blob = NULL;\n\tbool use_spnego = false; /* else use raw ntlmssp */\n\tu16 blob_length = 0;\n\n\t/*\n\t * If memory allocation is successful, caller of this function\n\t * frees it.\n\t */\n\tses->ntlmssp = kmalloc(sizeof(struct ntlmssp_auth), GFP_KERNEL);\n\tif (!ses->ntlmssp) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tses->ntlmssp->sesskey_per_smbsess = true;\n\n\trc = SMB2_sess_alloc_buffer(sess_data);\n\tif (rc)\n\t\tgoto out_err;\n\n\tntlmssp_blob = kmalloc(sizeof(struct _NEGOTIATE_MESSAGE),\n\t\t\t       GFP_KERNEL);\n\tif (ntlmssp_blob == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbuild_ntlmssp_negotiate_blob(ntlmssp_blob, ses);\n\tif (use_spnego) {\n\t\t/* BB eventually need to add this */\n\t\tcifs_dbg(VFS, \"spnego not supported for SMB2 yet\\n\");\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t} else {\n\t\tblob_length = sizeof(struct _NEGOTIATE_MESSAGE);\n\t\t/* with raw NTLMSSP we don't encapsulate in SPNEGO */\n\t}\n\tsess_data->iov[1].iov_base = ntlmssp_blob;\n\tsess_data->iov[1].iov_len = blob_length;\n\n\trc = SMB2_sess_sendreceive(sess_data);\n\trsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;\n\n\t/* If true, rc here is expected and not an error */\n\tif (sess_data->buf0_type != CIFS_NO_BUFFER &&\n\t\trsp->sync_hdr.Status == STATUS_MORE_PROCESSING_REQUIRED)\n\t\trc = 0;\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (offsetof(struct smb2_sess_setup_rsp, Buffer) !=\n\t\t\tle16_to_cpu(rsp->SecurityBufferOffset)) {\n\t\tcifs_dbg(VFS, \"Invalid security buffer offset %d\\n\",\n\t\t\tle16_to_cpu(rsp->SecurityBufferOffset));\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = decode_ntlmssp_challenge(rsp->Buffer,\n\t\t\tle16_to_cpu(rsp->SecurityBufferLength), ses);\n\tif (rc)\n\t\tgoto out;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup challenge phase\\n\");\n\n\t/* keep existing ses id and flags if binding */\n\tif (!ses->binding) {\n\t\tses->Suid = rsp->sync_hdr.SessionId;\n\t\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\t}\n\nout:\n\tkfree(ntlmssp_blob);\n\tSMB2_sess_free_buffer(sess_data);\n\tif (!rc) {\n\t\tsess_data->result = 0;\n\t\tsess_data->func = SMB2_sess_auth_rawntlmssp_authenticate;\n\t\treturn;\n\t}\nout_err:\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n}\n\nstatic void\nSMB2_sess_auth_rawntlmssp_authenticate(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb2_sess_setup_req *req;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\tunsigned char *ntlmssp_blob = NULL;\n\tbool use_spnego = false; /* else use raw ntlmssp */\n\tu16 blob_length = 0;\n\n\trc = SMB2_sess_alloc_buffer(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\treq = (struct smb2_sess_setup_req *) sess_data->iov[0].iov_base;\n\treq->sync_hdr.SessionId = ses->Suid;\n\n\trc = build_ntlmssp_auth_blob(&ntlmssp_blob, &blob_length, ses,\n\t\t\t\t\tsess_data->nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"build_ntlmssp_auth_blob failed %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tif (use_spnego) {\n\t\t/* BB eventually need to add this */\n\t\tcifs_dbg(VFS, \"spnego not supported for SMB2 yet\\n\");\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tsess_data->iov[1].iov_base = ntlmssp_blob;\n\tsess_data->iov[1].iov_len = blob_length;\n\n\trc = SMB2_sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\trsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;\n\n\t/* keep existing ses id and flags if binding */\n\tif (!ses->binding) {\n\t\tses->Suid = rsp->sync_hdr.SessionId;\n\t\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\t}\n\n\trc = SMB2_sess_establish_session(sess_data);\n#ifdef CONFIG_CIFS_DEBUG_DUMP_KEYS\n\tif (ses->server->dialect < SMB30_PROT_ID) {\n\t\tcifs_dbg(VFS, \"%s: dumping generated SMB2 session keys\\n\", __func__);\n\t\t/*\n\t\t * The session id is opaque in terms of endianness, so we can't\n\t\t * print it as a long long. we dump it as we got it on the wire\n\t\t */\n\t\tcifs_dbg(VFS, \"Session Id    %*ph\\n\", (int)sizeof(ses->Suid),\n\t\t\t &ses->Suid);\n\t\tcifs_dbg(VFS, \"Session Key   %*ph\\n\",\n\t\t\t SMB2_NTLMV2_SESSKEY_SIZE, ses->auth_key.response);\n\t\tcifs_dbg(VFS, \"Signing Key   %*ph\\n\",\n\t\t\t SMB3_SIGN_KEY_SIZE, ses->auth_key.response);\n\t}\n#endif\nout:\n\tkfree(ntlmssp_blob);\n\tSMB2_sess_free_buffer(sess_data);\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n}\n\nstatic int\nSMB2_select_sec(struct cifs_ses *ses, struct SMB2_sess_data *sess_data)\n{\n\tint type;\n\n\ttype = smb2_select_sectype(cifs_ses_server(ses), ses->sectype);\n\tcifs_dbg(FYI, \"sess setup type %d\\n\", type);\n\tif (type == Unspecified) {\n\t\tcifs_dbg(VFS, \"Unable to select appropriate authentication method!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase Kerberos:\n\t\tsess_data->func = SMB2_auth_kerberos;\n\t\tbreak;\n\tcase RawNTLMSSP:\n\t\tsess_data->func = SMB2_sess_auth_rawntlmssp_negotiate;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"secType %d not supported!\\n\", type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nint\nSMB2_sess_setup(const unsigned int xid, struct cifs_ses *ses,\n\t\tconst struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = cifs_ses_server(ses);\n\tstruct SMB2_sess_data *sess_data;\n\n\tcifs_dbg(FYI, \"Session Setup\\n\");\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tsess_data = kzalloc(sizeof(struct SMB2_sess_data), GFP_KERNEL);\n\tif (!sess_data)\n\t\treturn -ENOMEM;\n\n\trc = SMB2_select_sec(ses, sess_data);\n\tif (rc)\n\t\tgoto out;\n\tsess_data->xid = xid;\n\tsess_data->ses = ses;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tsess_data->nls_cp = (struct nls_table *) nls_cp;\n\tsess_data->previous_session = ses->Suid;\n\n\t/*\n\t * Initialize the session hash with the server one.\n\t */\n\tmemcpy(ses->preauth_sha_hash, server->preauth_sha_hash,\n\t       SMB2_PREAUTH_HASH_SIZE);\n\n\twhile (sess_data->func)\n\t\tsess_data->func(sess_data);\n\n\tif ((ses->session_flags & SMB2_SESSION_FLAG_IS_GUEST) && (ses->sign))\n\t\tcifs_server_dbg(VFS, \"signing requested but authenticated as guest\\n\");\n\trc = sess_data->result;\nout:\n\tkfree(sess_data);\n\treturn rc;\n}\n\nint\nSMB2_logoff(const unsigned int xid, struct cifs_ses *ses)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_logoff_req *req; /* response is also trivial struct */\n\tint rc = 0;\n\tstruct TCP_Server_Info *server;\n\tint flags = 0;\n\tunsigned int total_len;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buf_type;\n\n\tcifs_dbg(FYI, \"disconnect session %p\\n\", ses);\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\t/* no need to send SMB logoff if uid already closed due to reconnect */\n\tif (ses->need_reconnect)\n\t\tgoto smb2_session_already_dead;\n\n\trc = smb2_plain_req_init(SMB2_LOGOFF, NULL, ses->server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\t /* since no tcon, smb2_init can not do this, so do here */\n\treq->sync_hdr.SessionId = ses->Suid;\n\n\tif (ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA)\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\telse if (server->sign)\n\t\treq->sync_hdr.Flags |= SMB2_FLAGS_SIGNED;\n\n\tflags |= CIFS_NO_RSP_BUF;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, ses->server,\n\t\t\t    &rqst, &resp_buf_type, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\t/*\n\t * No tcon so can't do\n\t * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);\n\t */\n\nsmb2_session_already_dead:\n\treturn rc;\n}\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}\n\n#define MAX_SHARENAME_LENGTH (255 /* server */ + 80 /* share */ + 1 /* NULL */)\n\n/* These are similar values to what Windows uses */\nstatic inline void init_copy_chunk_defaults(struct cifs_tcon *tcon)\n{\n\ttcon->max_chunks = 256;\n\ttcon->max_bytes_chunk = 1048576;\n\ttcon->max_bytes_copy = 16777216;\n}\n\nint\nSMB2_tcon(const unsigned int xid, struct cifs_ses *ses, const char *tree,\n\t  struct cifs_tcon *tcon, const struct nls_table *cp)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_tree_connect_req *req;\n\tstruct smb2_tree_connect_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tstruct kvec rsp_iov = { NULL, 0 };\n\tint rc = 0;\n\tint resp_buftype;\n\tint unc_path_len;\n\t__le16 *unc_path = NULL;\n\tint flags = 0;\n\tunsigned int total_len;\n\tstruct TCP_Server_Info *server;\n\n\t/* always use master channel */\n\tserver = ses->server;\n\n\tcifs_dbg(FYI, \"TCON\\n\");\n\n\tif (!server || !tree)\n\t\treturn -EIO;\n\n\tunc_path = kmalloc(MAX_SHARENAME_LENGTH * 2, GFP_KERNEL);\n\tif (unc_path == NULL)\n\t\treturn -ENOMEM;\n\n\tunc_path_len = cifs_strtoUTF16(unc_path, tree, strlen(tree), cp) + 1;\n\tunc_path_len *= 2;\n\tif (unc_path_len < 2) {\n\t\tkfree(unc_path);\n\t\treturn -EINVAL;\n\t}\n\n\t/* SMB2 TREE_CONNECT request must be called with TreeId == 0 */\n\ttcon->tid = 0;\n\tatomic_set(&tcon->num_remote_opens, 0);\n\trc = smb2_plain_req_init(SMB2_TREE_CONNECT, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc) {\n\t\tkfree(unc_path);\n\t\treturn rc;\n\t}\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 1 for pad */\n\tiov[0].iov_len = total_len - 1;\n\n\t/* Testing shows that buffer offset must be at location of Buffer[0] */\n\treq->PathOffset = cpu_to_le16(sizeof(struct smb2_tree_connect_req)\n\t\t\t- 1 /* pad */);\n\treq->PathLength = cpu_to_le16(unc_path_len - 2);\n\tiov[1].iov_base = unc_path;\n\tiov[1].iov_len = unc_path_len;\n\n\t/*\n\t * 3.11 tcon req must be signed if not encrypted. See MS-SMB2 3.2.4.1.1\n\t * unless it is guest or anonymous user. See MS-SMB2 3.2.5.3.1\n\t * (Samba servers don't always set the flag so also check if null user)\n\t */\n\tif ((server->dialect == SMB311_PROT_ID) &&\n\t    !smb3_encryption_required(tcon) &&\n\t    !(ses->session_flags &\n\t\t    (SMB2_SESSION_FLAG_IS_GUEST|SMB2_SESSION_FLAG_IS_NULL)) &&\n\t    ((ses->user_name != NULL) || (ses->sectype == Kerberos)))\n\t\treq->sync_hdr.Flags |= SMB2_FLAGS_SIGNED;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 2;\n\n\t/* Need 64 for max size write so ask for more in case not there yet */\n\treq->sync_hdr.CreditRequest = cpu_to_le16(64);\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_tree_connect_rsp *)rsp_iov.iov_base;\n\ttrace_smb3_tcon(xid, tcon->tid, ses->Suid, tree, rc);\n\tif (rc != 0) {\n\t\tif (tcon) {\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_TREE_CONNECT_HE);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t\tgoto tcon_error_exit;\n\t}\n\n\tswitch (rsp->ShareType) {\n\tcase SMB2_SHARE_TYPE_DISK:\n\t\tcifs_dbg(FYI, \"connection to disk share\\n\");\n\t\tbreak;\n\tcase SMB2_SHARE_TYPE_PIPE:\n\t\ttcon->pipe = true;\n\t\tcifs_dbg(FYI, \"connection to pipe share\\n\");\n\t\tbreak;\n\tcase SMB2_SHARE_TYPE_PRINT:\n\t\ttcon->print = true;\n\t\tcifs_dbg(FYI, \"connection to printer\\n\");\n\t\tbreak;\n\tdefault:\n\t\tcifs_server_dbg(VFS, \"unknown share type %d\\n\", rsp->ShareType);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto tcon_error_exit;\n\t}\n\n\ttcon->share_flags = le32_to_cpu(rsp->ShareFlags);\n\ttcon->capabilities = rsp->Capabilities; /* we keep caps little endian */\n\ttcon->maximal_access = le32_to_cpu(rsp->MaximalAccess);\n\ttcon->tidStatus = CifsGood;\n\ttcon->need_reconnect = false;\n\ttcon->tid = rsp->sync_hdr.TreeId;\n\tstrlcpy(tcon->treeName, tree, sizeof(tcon->treeName));\n\n\tif ((rsp->Capabilities & SMB2_SHARE_CAP_DFS) &&\n\t    ((tcon->share_flags & SHI1005_FLAGS_DFS) == 0))\n\t\tcifs_tcon_dbg(VFS, \"DFS capability contradicts DFS flag\\n\");\n\n\tif (tcon->seal &&\n\t    !(server->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION))\n\t\tcifs_tcon_dbg(VFS, \"Encryption is requested but not supported\\n\");\n\n\tinit_copy_chunk_defaults(tcon);\n\tif (server->ops->validate_negotiate)\n\t\trc = server->ops->validate_negotiate(xid, tcon);\ntcon_exit:\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(unc_path);\n\treturn rc;\n\ntcon_error_exit:\n\tif (rsp && rsp->sync_hdr.Status == STATUS_BAD_NETWORK_NAME) {\n\t\tcifs_tcon_dbg(VFS, \"BAD_NETWORK_NAME: %s\\n\", tree);\n\t}\n\tgoto tcon_exit;\n}\n\nint\nSMB2_tdis(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_tree_disconnect_req *req; /* response is trivial */\n\tint rc = 0;\n\tstruct cifs_ses *ses = tcon->ses;\n\tint flags = 0;\n\tunsigned int total_len;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buf_type;\n\n\tcifs_dbg(FYI, \"Tree Disconnect\\n\");\n\n\tif (!ses || !(ses->server))\n\t\treturn -EIO;\n\n\tif ((tcon->need_reconnect) || (tcon->ses->need_reconnect))\n\t\treturn 0;\n\n\tclose_shroot_lease(&tcon->crfid);\n\n\trc = smb2_plain_req_init(SMB2_TREE_DISCONNECT, tcon, ses->server,\n\t\t\t\t (void **) &req,\n\t\t\t\t &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tflags |= CIFS_NO_RSP_BUF;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, ses->server,\n\t\t\t    &rqst, &resp_buf_type, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\tif (rc)\n\t\tcifs_stats_fail_inc(tcon, SMB2_TREE_DISCONNECT_HE);\n\n\treturn rc;\n}\n\n\nstatic struct create_durable *\ncreate_durable_buf(void)\n{\n\tstruct create_durable *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable, Data));\n\tbuf->ccontext.DataLength = cpu_to_le32(16);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t/* SMB2_CREATE_DURABLE_HANDLE_REQUEST is \"DHnQ\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = 'n';\n\tbuf->Name[3] = 'Q';\n\treturn buf;\n}\n\nstatic struct create_durable *\ncreate_reconnect_durable_buf(struct cifs_fid *fid)\n{\n\tstruct create_durable *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable, Data));\n\tbuf->ccontext.DataLength = cpu_to_le32(16);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\tbuf->Data.Fid.PersistentFileId = fid->persistent_fid;\n\tbuf->Data.Fid.VolatileFileId = fid->volatile_fid;\n\t/* SMB2_CREATE_DURABLE_HANDLE_RECONNECT is \"DHnC\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = 'n';\n\tbuf->Name[3] = 'C';\n\treturn buf;\n}\n\nstatic void\nparse_query_id_ctxt(struct create_context *cc, struct smb2_file_all_info *buf)\n{\n\tstruct create_on_disk_id *pdisk_id = (struct create_on_disk_id *)cc;\n\n\tcifs_dbg(FYI, \"parse query id context 0x%llx 0x%llx\\n\",\n\t\tpdisk_id->DiskFileId, pdisk_id->VolumeId);\n\tbuf->IndexNumber = pdisk_id->DiskFileId;\n}\n\nstatic void\nparse_posix_ctxt(struct create_context *cc, struct smb2_file_all_info *info,\n\t\t struct create_posix_rsp *posix)\n{\n\tint sid_len;\n\tu8 *beg = (u8 *)cc + le16_to_cpu(cc->DataOffset);\n\tu8 *end = beg + le32_to_cpu(cc->DataLength);\n\tu8 *sid;\n\n\tmemset(posix, 0, sizeof(*posix));\n\n\tposix->nlink = le32_to_cpu(*(__le32 *)(beg + 0));\n\tposix->reparse_tag = le32_to_cpu(*(__le32 *)(beg + 4));\n\tposix->mode = le32_to_cpu(*(__le32 *)(beg + 8));\n\n\tsid = beg + 12;\n\tsid_len = posix_info_sid_size(sid, end);\n\tif (sid_len < 0) {\n\t\tcifs_dbg(VFS, \"bad owner sid in posix create response\\n\");\n\t\treturn;\n\t}\n\tmemcpy(&posix->owner, sid, sid_len);\n\n\tsid = sid + sid_len;\n\tsid_len = posix_info_sid_size(sid, end);\n\tif (sid_len < 0) {\n\t\tcifs_dbg(VFS, \"bad group sid in posix create response\\n\");\n\t\treturn;\n\t}\n\tmemcpy(&posix->group, sid, sid_len);\n\n\tcifs_dbg(FYI, \"nlink=%d mode=%o reparse_tag=%x\\n\",\n\t\t posix->nlink, posix->mode, posix->reparse_tag);\n}\n\nvoid\nsmb2_parse_contexts(struct TCP_Server_Info *server,\n\t\t    struct smb2_create_rsp *rsp,\n\t\t    unsigned int *epoch, char *lease_key, __u8 *oplock,\n\t\t    struct smb2_file_all_info *buf,\n\t\t    struct create_posix_rsp *posix)\n{\n\tchar *data_offset;\n\tstruct create_context *cc;\n\tunsigned int next;\n\tunsigned int remaining;\n\tchar *name;\n\tstatic const char smb3_create_tag_posix[] = {\n\t\t0x93, 0xAD, 0x25, 0x50, 0x9C,\n\t\t0xB4, 0x11, 0xE7, 0xB4, 0x23, 0x83,\n\t\t0xDE, 0x96, 0x8B, 0xCD, 0x7C\n\t};\n\n\t*oplock = 0;\n\tdata_offset = (char *)rsp + le32_to_cpu(rsp->CreateContextsOffset);\n\tremaining = le32_to_cpu(rsp->CreateContextsLength);\n\tcc = (struct create_context *)data_offset;\n\n\t/* Initialize inode number to 0 in case no valid data in qfid context */\n\tif (buf)\n\t\tbuf->IndexNumber = 0;\n\n\twhile (remaining >= sizeof(struct create_context)) {\n\t\tname = le16_to_cpu(cc->NameOffset) + (char *)cc;\n\t\tif (le16_to_cpu(cc->NameLength) == 4 &&\n\t\t    strncmp(name, SMB2_CREATE_REQUEST_LEASE, 4) == 0)\n\t\t\t*oplock = server->ops->parse_lease_buf(cc, epoch,\n\t\t\t\t\t\t\t   lease_key);\n\t\telse if (buf && (le16_to_cpu(cc->NameLength) == 4) &&\n\t\t    strncmp(name, SMB2_CREATE_QUERY_ON_DISK_ID, 4) == 0)\n\t\t\tparse_query_id_ctxt(cc, buf);\n\t\telse if ((le16_to_cpu(cc->NameLength) == 16)) {\n\t\t\tif (posix &&\n\t\t\t    memcmp(name, smb3_create_tag_posix, 16) == 0)\n\t\t\t\tparse_posix_ctxt(cc, buf, posix);\n\t\t}\n\t\t/* else {\n\t\t\tcifs_dbg(FYI, \"Context not matched with len %d\\n\",\n\t\t\t\tle16_to_cpu(cc->NameLength));\n\t\t\tcifs_dump_mem(\"Cctxt name: \", name, 4);\n\t\t} */\n\n\t\tnext = le32_to_cpu(cc->Next);\n\t\tif (!next)\n\t\t\tbreak;\n\t\tremaining -= next;\n\t\tcc = (struct create_context *)((char *)cc + next);\n\t}\n\n\tif (rsp->OplockLevel != SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = rsp->OplockLevel;\n\n\treturn;\n}\n\nstatic int\nadd_lease_context(struct TCP_Server_Info *server, struct kvec *iov,\n\t\t  unsigned int *num_iovec, u8 *lease_key, __u8 *oplock)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tiov[num].iov_base = server->ops->create_lease_buf(lease_key, *oplock);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = server->vals->create_lease_size;\n\treq->RequestedOplockLevel = SMB2_OPLOCK_LEVEL_LEASE;\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset = cpu_to_le32(\n\t\t\t\tsizeof(struct smb2_create_req) +\n\t\t\t\tiov[num - 1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength,\n\t\t     server->vals->create_lease_size);\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\nstatic struct create_durable_v2 *\ncreate_durable_v2_buf(struct cifs_open_parms *oparms)\n{\n\tstruct cifs_fid *pfid = oparms->fid;\n\tstruct create_durable_v2 *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable_v2), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable_v2, dcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct durable_context_v2));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable_v2, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\n\t/*\n\t * NB: Handle timeout defaults to 0, which allows server to choose\n\t * (most servers default to 120 seconds) and most clients default to 0.\n\t * This can be overridden at mount (\"handletimeout=\") if the user wants\n\t * a different persistent (or resilient) handle timeout for all opens\n\t * opens on a particular SMB3 mount.\n\t */\n\tbuf->dcontext.Timeout = cpu_to_le32(oparms->tcon->handle_timeout);\n\tbuf->dcontext.Flags = cpu_to_le32(SMB2_DHANDLE_FLAG_PERSISTENT);\n\tgenerate_random_uuid(buf->dcontext.CreateGuid);\n\tmemcpy(pfid->create_guid, buf->dcontext.CreateGuid, 16);\n\n\t/* SMB2_CREATE_DURABLE_HANDLE_REQUEST is \"DH2Q\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = '2';\n\tbuf->Name[3] = 'Q';\n\treturn buf;\n}\n\nstatic struct create_durable_handle_reconnect_v2 *\ncreate_reconnect_durable_v2_buf(struct cifs_fid *fid)\n{\n\tstruct create_durable_handle_reconnect_v2 *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable_handle_reconnect_v2),\n\t\t\tGFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset =\n\t\tcpu_to_le16(offsetof(struct create_durable_handle_reconnect_v2,\n\t\t\t\t     dcontext));\n\tbuf->ccontext.DataLength =\n\t\tcpu_to_le32(sizeof(struct durable_reconnect_context_v2));\n\tbuf->ccontext.NameOffset =\n\t\tcpu_to_le16(offsetof(struct create_durable_handle_reconnect_v2,\n\t\t\t    Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\n\tbuf->dcontext.Fid.PersistentFileId = fid->persistent_fid;\n\tbuf->dcontext.Fid.VolatileFileId = fid->volatile_fid;\n\tbuf->dcontext.Flags = cpu_to_le32(SMB2_DHANDLE_FLAG_PERSISTENT);\n\tmemcpy(buf->dcontext.CreateGuid, fid->create_guid, 16);\n\n\t/* SMB2_CREATE_DURABLE_HANDLE_RECONNECT_V2 is \"DH2C\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = '2';\n\tbuf->Name[3] = 'C';\n\treturn buf;\n}\n\nstatic int\nadd_durable_v2_context(struct kvec *iov, unsigned int *num_iovec,\n\t\t    struct cifs_open_parms *oparms)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tiov[num].iov_base = create_durable_v2_buf(oparms);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct create_durable_v2);\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset =\n\t\t\tcpu_to_le32(sizeof(struct smb2_create_req) +\n\t\t\t\t\t\t\t\tiov[1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength, sizeof(struct create_durable_v2));\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\nstatic int\nadd_durable_reconnect_v2_context(struct kvec *iov, unsigned int *num_iovec,\n\t\t    struct cifs_open_parms *oparms)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\t/* indicate that we don't need to relock the file */\n\toparms->reconnect = false;\n\n\tiov[num].iov_base = create_reconnect_durable_v2_buf(oparms->fid);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct create_durable_handle_reconnect_v2);\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset =\n\t\t\tcpu_to_le32(sizeof(struct smb2_create_req) +\n\t\t\t\t\t\t\t\tiov[1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength,\n\t\t\tsizeof(struct create_durable_handle_reconnect_v2));\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\nstatic int\nadd_durable_context(struct kvec *iov, unsigned int *num_iovec,\n\t\t    struct cifs_open_parms *oparms, bool use_persistent)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tif (use_persistent) {\n\t\tif (oparms->reconnect)\n\t\t\treturn add_durable_reconnect_v2_context(iov, num_iovec,\n\t\t\t\t\t\t\t\toparms);\n\t\telse\n\t\t\treturn add_durable_v2_context(iov, num_iovec, oparms);\n\t}\n\n\tif (oparms->reconnect) {\n\t\tiov[num].iov_base = create_reconnect_durable_buf(oparms->fid);\n\t\t/* indicate that we don't need to relock the file */\n\t\toparms->reconnect = false;\n\t} else\n\t\tiov[num].iov_base = create_durable_buf();\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct create_durable);\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset =\n\t\t\tcpu_to_le32(sizeof(struct smb2_create_req) +\n\t\t\t\t\t\t\t\tiov[1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength, sizeof(struct create_durable));\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\n/* See MS-SMB2 2.2.13.2.7 */\nstatic struct crt_twarp_ctxt *\ncreate_twarp_buf(__u64 timewarp)\n{\n\tstruct crt_twarp_ctxt *buf;\n\n\tbuf = kzalloc(sizeof(struct crt_twarp_ctxt), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct crt_twarp_ctxt, Timestamp));\n\tbuf->ccontext.DataLength = cpu_to_le32(8);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct crt_twarp_ctxt, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t/* SMB2_CREATE_TIMEWARP_TOKEN is \"TWrp\" */\n\tbuf->Name[0] = 'T';\n\tbuf->Name[1] = 'W';\n\tbuf->Name[2] = 'r';\n\tbuf->Name[3] = 'p';\n\tbuf->Timestamp = cpu_to_le64(timewarp);\n\treturn buf;\n}\n\n/* See MS-SMB2 2.2.13.2.7 */\nstatic int\nadd_twarp_context(struct kvec *iov, unsigned int *num_iovec, __u64 timewarp)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tiov[num].iov_base = create_twarp_buf(timewarp);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct crt_twarp_ctxt);\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset = cpu_to_le32(\n\t\t\t\tsizeof(struct smb2_create_req) +\n\t\t\t\tiov[num - 1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength, sizeof(struct crt_twarp_ctxt));\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\n/* See See http://technet.microsoft.com/en-us/library/hh509017(v=ws.10).aspx */\nstatic void setup_owner_group_sids(char *buf)\n{\n\tstruct owner_group_sids *sids = (struct owner_group_sids *)buf;\n\n\t/* Populate the user ownership fields S-1-5-88-1 */\n\tsids->owner.Revision = 1;\n\tsids->owner.NumAuth = 3;\n\tsids->owner.Authority[5] = 5;\n\tsids->owner.SubAuthorities[0] = cpu_to_le32(88);\n\tsids->owner.SubAuthorities[1] = cpu_to_le32(1);\n\tsids->owner.SubAuthorities[2] = cpu_to_le32(current_fsuid().val);\n\n\t/* Populate the group ownership fields S-1-5-88-2 */\n\tsids->group.Revision = 1;\n\tsids->group.NumAuth = 3;\n\tsids->group.Authority[5] = 5;\n\tsids->group.SubAuthorities[0] = cpu_to_le32(88);\n\tsids->group.SubAuthorities[1] = cpu_to_le32(2);\n\tsids->group.SubAuthorities[2] = cpu_to_le32(current_fsgid().val);\n\n\tcifs_dbg(FYI, \"owner S-1-5-88-1-%d, group S-1-5-88-2-%d\\n\", current_fsuid().val, current_fsgid().val);\n}\n\n/* See MS-SMB2 2.2.13.2.2 and MS-DTYP 2.4.6 */\nstatic struct crt_sd_ctxt *\ncreate_sd_buf(umode_t mode, bool set_owner, unsigned int *len)\n{\n\tstruct crt_sd_ctxt *buf;\n\t__u8 *ptr, *aclptr;\n\tunsigned int acelen, acl_size, ace_count;\n\tunsigned int owner_offset = 0;\n\tunsigned int group_offset = 0;\n\tstruct smb3_acl acl;\n\n\t*len = roundup(sizeof(struct crt_sd_ctxt) + (sizeof(struct cifs_ace) * 4), 8);\n\n\tif (set_owner) {\n\t\t/* sizeof(struct owner_group_sids) is already multiple of 8 so no need to round */\n\t\t*len += sizeof(struct owner_group_sids);\n\t}\n\n\tbuf = kzalloc(*len, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn buf;\n\n\tptr = (__u8 *)&buf[1];\n\tif (set_owner) {\n\t\t/* offset fields are from beginning of security descriptor not of create context */\n\t\towner_offset = ptr - (__u8 *)&buf->sd;\n\t\tbuf->sd.OffsetOwner = cpu_to_le32(owner_offset);\n\t\tgroup_offset = owner_offset + offsetof(struct owner_group_sids, group);\n\t\tbuf->sd.OffsetGroup = cpu_to_le32(group_offset);\n\n\t\tsetup_owner_group_sids(ptr);\n\t\tptr += sizeof(struct owner_group_sids);\n\t} else {\n\t\tbuf->sd.OffsetOwner = 0;\n\t\tbuf->sd.OffsetGroup = 0;\n\t}\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof(struct crt_sd_ctxt, sd));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof(struct crt_sd_ctxt, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t/* SMB2_CREATE_SD_BUFFER_TOKEN is \"SecD\" */\n\tbuf->Name[0] = 'S';\n\tbuf->Name[1] = 'e';\n\tbuf->Name[2] = 'c';\n\tbuf->Name[3] = 'D';\n\tbuf->sd.Revision = 1;  /* Must be one see MS-DTYP 2.4.6 */\n\n\t/*\n\t * ACL is \"self relative\" ie ACL is stored in contiguous block of memory\n\t * and \"DP\" ie the DACL is present\n\t */\n\tbuf->sd.Control = cpu_to_le16(ACL_CONTROL_SR | ACL_CONTROL_DP);\n\n\t/* offset owner, group and Sbz1 and SACL are all zero */\n\tbuf->sd.OffsetDacl = cpu_to_le32(ptr - (__u8 *)&buf->sd);\n\t/* Ship the ACL for now. we will copy it into buf later. */\n\taclptr = ptr;\n\tptr += sizeof(struct cifs_acl);\n\n\t/* create one ACE to hold the mode embedded in reserved special SID */\n\tacelen = setup_special_mode_ACE((struct cifs_ace *)ptr, (__u64)mode);\n\tptr += acelen;\n\tacl_size = acelen + sizeof(struct smb3_acl);\n\tace_count = 1;\n\n\tif (set_owner) {\n\t\t/* we do not need to reallocate buffer to add the two more ACEs. plenty of space */\n\t\tacelen = setup_special_user_owner_ACE((struct cifs_ace *)ptr);\n\t\tptr += acelen;\n\t\tacl_size += acelen;\n\t\tace_count += 1;\n\t}\n\n\t/* and one more ACE to allow access for authenticated users */\n\tacelen = setup_authusers_ACE((struct cifs_ace *)ptr);\n\tptr += acelen;\n\tacl_size += acelen;\n\tace_count += 1;\n\n\tacl.AclRevision = ACL_REVISION; /* See 2.4.4.1 of MS-DTYP */\n\tacl.AclSize = cpu_to_le16(acl_size);\n\tacl.AceCount = cpu_to_le16(ace_count);\n\tmemcpy(aclptr, &acl, sizeof(struct cifs_acl));\n\n\tbuf->ccontext.DataLength = cpu_to_le32(ptr - (__u8 *)&buf->sd);\n\t*len = ptr - (__u8 *)buf;\n\n\treturn buf;\n}\n\nstatic int\nadd_sd_context(struct kvec *iov, unsigned int *num_iovec, umode_t mode, bool set_owner)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\tunsigned int len = 0;\n\n\tiov[num].iov_base = create_sd_buf(mode, set_owner, &len);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = len;\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset = cpu_to_le32(\n\t\t\t\tsizeof(struct smb2_create_req) +\n\t\t\t\tiov[num - 1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength, len);\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\nstatic struct crt_query_id_ctxt *\ncreate_query_id_buf(void)\n{\n\tstruct crt_query_id_ctxt *buf;\n\n\tbuf = kzalloc(sizeof(struct crt_query_id_ctxt), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(0);\n\tbuf->ccontext.DataLength = cpu_to_le32(0);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct crt_query_id_ctxt, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t/* SMB2_CREATE_QUERY_ON_DISK_ID is \"QFid\" */\n\tbuf->Name[0] = 'Q';\n\tbuf->Name[1] = 'F';\n\tbuf->Name[2] = 'i';\n\tbuf->Name[3] = 'd';\n\treturn buf;\n}\n\n/* See MS-SMB2 2.2.13.2.9 */\nstatic int\nadd_query_id_context(struct kvec *iov, unsigned int *num_iovec)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tiov[num].iov_base = create_query_id_buf();\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct crt_query_id_ctxt);\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset = cpu_to_le32(\n\t\t\t\tsizeof(struct smb2_create_req) +\n\t\t\t\tiov[num - 1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength, sizeof(struct crt_query_id_ctxt));\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\nstatic int\nalloc_path_with_tree_prefix(__le16 **out_path, int *out_size, int *out_len,\n\t\t\t    const char *treename, const __le16 *path)\n{\n\tint treename_len, path_len;\n\tstruct nls_table *cp;\n\tconst __le16 sep[] = {cpu_to_le16('\\\\'), cpu_to_le16(0x0000)};\n\n\t/*\n\t * skip leading \"\\\\\"\n\t */\n\ttreename_len = strlen(treename);\n\tif (treename_len < 2 || !(treename[0] == '\\\\' && treename[1] == '\\\\'))\n\t\treturn -EINVAL;\n\n\ttreename += 2;\n\ttreename_len -= 2;\n\n\tpath_len = UniStrnlen((wchar_t *)path, PATH_MAX);\n\n\t/*\n\t * make room for one path separator between the treename and\n\t * path\n\t */\n\t*out_len = treename_len + 1 + path_len;\n\n\t/*\n\t * final path needs to be null-terminated UTF16 with a\n\t * size aligned to 8\n\t */\n\n\t*out_size = roundup((*out_len+1)*2, 8);\n\t*out_path = kzalloc(*out_size, GFP_KERNEL);\n\tif (!*out_path)\n\t\treturn -ENOMEM;\n\n\tcp = load_nls_default();\n\tcifs_strtoUTF16(*out_path, treename, treename_len, cp);\n\tUniStrcat(*out_path, sep);\n\tUniStrcat(*out_path, path);\n\tunload_nls(cp);\n\n\treturn 0;\n}\n\nint smb311_posix_mkdir(const unsigned int xid, struct inode *inode,\n\t\t\t       umode_t mode, struct cifs_tcon *tcon,\n\t\t\t       const char *full_path,\n\t\t\t       struct cifs_sb_info *cifs_sb)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp = NULL;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[3]; /* make sure at least one for each open context */\n\tstruct kvec rsp_iov = {NULL, 0};\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int n_iov = 2;\n\t__u32 file_attributes = 0;\n\tchar *pc_buf = NULL;\n\tint flags = 0;\n\tunsigned int total_len;\n\t__le16 *utf16_path = NULL;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\n\tcifs_dbg(FYI, \"mkdir\\n\");\n\n\t/* resource #1: path allocation */\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\tif (!ses || !server) {\n\t\trc = -EIO;\n\t\tgoto err_free_path;\n\t}\n\n\t/* resource #2: request */\n\trc = smb2_plain_req_init(SMB2_CREATE, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\tgoto err_free_path;\n\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(FILE_WRITE_ATTRIBUTES);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(FILE_CREATE);\n\treq->CreateOptions = cpu_to_le32(CREATE_NOT_FILE);\n\n\tiov[0].iov_base = (char *)req;\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len = total_len - 1;\n\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req));\n\n\t/* [MS-SMB2] 2.2.13 NameOffset:\n\t * If SMB2_FLAGS_DFS_OPERATIONS is set in the Flags field of\n\t * the SMB2 header, the file name includes a prefix that will\n\t * be processed during DFS name normalization as specified in\n\t * section 3.3.5.9. Otherwise, the file name is relative to\n\t * the share that is identified by the TreeId in the SMB2\n\t * header.\n\t */\n\tif (tcon->share_flags & SHI1005_FLAGS_DFS) {\n\t\tint name_len;\n\n\t\treq->sync_hdr.Flags |= SMB2_FLAGS_DFS_OPERATIONS;\n\t\trc = alloc_path_with_tree_prefix(&copy_path, &copy_size,\n\t\t\t\t\t\t &name_len,\n\t\t\t\t\t\t tcon->treeName, utf16_path);\n\t\tif (rc)\n\t\t\tgoto err_free_req;\n\n\t\treq->NameLength = cpu_to_le16(name_len * 2);\n\t\tuni_path_len = copy_size;\n\t\t/* free before overwriting resource */\n\t\tkfree(utf16_path);\n\t\tutf16_path = copy_path;\n\t} else {\n\t\tuni_path_len = (2 * UniStrnlen((wchar_t *)utf16_path, PATH_MAX)) + 2;\n\t\t/* MUST set path len (NameLength) to 0 opening root of share */\n\t\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t\tif (uni_path_len % 8 != 0) {\n\t\t\tcopy_size = roundup(uni_path_len, 8);\n\t\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\t\tif (!copy_path) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto err_free_req;\n\t\t\t}\n\t\t\tmemcpy((char *)copy_path, (const char *)utf16_path,\n\t\t\t       uni_path_len);\n\t\t\tuni_path_len = copy_size;\n\t\t\t/* free before overwriting resource */\n\t\t\tkfree(utf16_path);\n\t\t\tutf16_path = copy_path;\n\t\t}\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = utf16_path;\n\treq->RequestedOplockLevel = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (tcon->posix_extensions) {\n\t\t/* resource #3: posix buf */\n\t\trc = add_posix_context(iov, &n_iov, mode);\n\t\tif (rc)\n\t\t\tgoto err_free_req;\n\t\tpc_buf = iov[n_iov-1].iov_base;\n\t}\n\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = n_iov;\n\n\t/* no need to inc num_remote_opens because we close it just below */\n\ttrace_smb3_posix_mkdir_enter(xid, tcon->tid, ses->Suid, CREATE_NOT_FILE,\n\t\t\t\t    FILE_WRITE_ATTRIBUTES);\n\t/* resource #4: response buffer */\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\ttrace_smb3_posix_mkdir_err(xid, tcon->tid, ses->Suid,\n\t\t\t\t\t   CREATE_NOT_FILE,\n\t\t\t\t\t   FILE_WRITE_ATTRIBUTES, rc);\n\t\tgoto err_free_rsp_buf;\n\t}\n\n\trsp = (struct smb2_create_rsp *)rsp_iov.iov_base;\n\ttrace_smb3_posix_mkdir_done(xid, rsp->PersistentFileId, tcon->tid,\n\t\t\t\t    ses->Suid, CREATE_NOT_FILE,\n\t\t\t\t    FILE_WRITE_ATTRIBUTES);\n\n\tSMB2_close(xid, tcon, rsp->PersistentFileId, rsp->VolatileFileId);\n\n\t/* Eventually save off posix specific response info and timestaps */\n\nerr_free_rsp_buf:\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(pc_buf);\nerr_free_req:\n\tcifs_small_buf_release(req);\nerr_free_path:\n\tkfree(utf16_path);\n\treturn rc;\n}\n\nint\nSMB2_open_init(struct cifs_tcon *tcon, struct TCP_Server_Info *server,\n\t       struct smb_rqst *rqst, __u8 *oplock,\n\t       struct cifs_open_parms *oparms, __le16 *path)\n{\n\tstruct smb2_create_req *req;\n\tunsigned int n_iov = 2;\n\t__u32 file_attributes = 0;\n\tint copy_size;\n\tint uni_path_len;\n\tunsigned int total_len;\n\tstruct kvec *iov = rqst->rq_iov;\n\t__le16 *copy_path;\n\tint rc;\n\n\trc = smb2_plain_req_init(SMB2_CREATE, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tiov[0].iov_base = (char *)req;\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len = total_len - 1;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req));\n\n\t/* [MS-SMB2] 2.2.13 NameOffset:\n\t * If SMB2_FLAGS_DFS_OPERATIONS is set in the Flags field of\n\t * the SMB2 header, the file name includes a prefix that will\n\t * be processed during DFS name normalization as specified in\n\t * section 3.3.5.9. Otherwise, the file name is relative to\n\t * the share that is identified by the TreeId in the SMB2\n\t * header.\n\t */\n\tif (tcon->share_flags & SHI1005_FLAGS_DFS) {\n\t\tint name_len;\n\n\t\treq->sync_hdr.Flags |= SMB2_FLAGS_DFS_OPERATIONS;\n\t\trc = alloc_path_with_tree_prefix(&copy_path, &copy_size,\n\t\t\t\t\t\t &name_len,\n\t\t\t\t\t\t tcon->treeName, path);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\treq->NameLength = cpu_to_le16(name_len * 2);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t} else {\n\t\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t\t/* MUST set path len (NameLength) to 0 opening root of share */\n\t\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t\tcopy_size = uni_path_len;\n\t\tif (copy_size % 8 != 0)\n\t\t\tcopy_size = roundup(copy_size, 8);\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t       uni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\n\tif ((!server->oplocks) || (tcon->no_lease))\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse if (!(server->capabilities & SMB2_GLOBAL_CAP_DIRECTORY_LEASING) &&\n\t\t  (oparms->create_options & CREATE_NOT_FILE))\n\t\treq->RequestedOplockLevel = *oplock; /* no srv lease support */\n\telse {\n\t\trc = add_lease_context(server, iov, &n_iov,\n\t\t\t\t       oparms->fid->lease_key, oplock);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[n_iov-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\n\t\trc = add_durable_context(iov, &n_iov, oparms,\n\t\t\t\t\ttcon->use_persistent);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (tcon->posix_extensions) {\n\t\tif (n_iov > 2) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[n_iov-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(iov[n_iov-1].iov_len);\n\t\t}\n\n\t\trc = add_posix_context(iov, &n_iov, oparms->mode);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (tcon->snapshot_time) {\n\t\tcifs_dbg(FYI, \"adding snapshot context\\n\");\n\t\tif (n_iov > 2) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[n_iov-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(iov[n_iov-1].iov_len);\n\t\t}\n\n\t\trc = add_twarp_context(iov, &n_iov, tcon->snapshot_time);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif ((oparms->disposition != FILE_OPEN) && (oparms->cifs_sb)) {\n\t\tbool set_mode;\n\t\tbool set_owner;\n\n\t\tif ((oparms->cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MODE_FROM_SID) &&\n\t\t    (oparms->mode != ACL_NO_MODE))\n\t\t\tset_mode = true;\n\t\telse {\n\t\t\tset_mode = false;\n\t\t\toparms->mode = ACL_NO_MODE;\n\t\t}\n\n\t\tif (oparms->cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UID_FROM_ACL)\n\t\t\tset_owner = true;\n\t\telse\n\t\t\tset_owner = false;\n\n\t\tif (set_owner | set_mode) {\n\t\t\tif (n_iov > 2) {\n\t\t\t\tstruct create_context *ccontext =\n\t\t\t\t    (struct create_context *)iov[n_iov-1].iov_base;\n\t\t\t\tccontext->Next = cpu_to_le32(iov[n_iov-1].iov_len);\n\t\t\t}\n\n\t\t\tcifs_dbg(FYI, \"add sd with mode 0x%x\\n\", oparms->mode);\n\t\t\trc = add_sd_context(iov, &n_iov, oparms->mode, set_owner);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (n_iov > 2) {\n\t\tstruct create_context *ccontext =\n\t\t\t(struct create_context *)iov[n_iov-1].iov_base;\n\t\tccontext->Next = cpu_to_le32(iov[n_iov-1].iov_len);\n\t}\n\tadd_query_id_context(iov, &n_iov);\n\n\trqst->rq_nvec = n_iov;\n\treturn 0;\n}\n\n/* rq_iov[0] is the request and is released by cifs_small_buf_release().\n * All other vectors are freed by kfree().\n */\nvoid\nSMB2_open_free(struct smb_rqst *rqst)\n{\n\tint i;\n\n\tif (rqst && rqst->rq_iov) {\n\t\tcifs_small_buf_release(rqst->rq_iov[0].iov_base);\n\t\tfor (i = 1; i < rqst->rq_nvec; i++)\n\t\t\tif (rqst->rq_iov[i].iov_base != smb2_padding)\n\t\t\t\tkfree(rqst->rq_iov[i].iov_base);\n\t}\n}\n\nint\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct create_posix_rsp *posix,\n\t  struct kvec *err_iov, int *buftype)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_create_rsp *rsp = NULL;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tstruct kvec iov[SMB2_CREATE_IOV_SIZE];\n\tstruct kvec rsp_iov = {NULL, 0};\n\tint resp_buftype = CIFS_NO_BUFFER;\n\tint rc = 0;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\tif (!ses || !server)\n\t\treturn -EIO;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\tmemset(&iov, 0, sizeof(iov));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = SMB2_CREATE_IOV_SIZE;\n\n\trc = SMB2_open_init(tcon, server,\n\t\t\t    &rqst, oplock, oparms, path);\n\tif (rc)\n\t\tgoto creat_exit;\n\n\ttrace_smb3_open_enter(xid, tcon->tid, tcon->ses->Suid,\n\t\toparms->create_options, oparms->desired_access);\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags,\n\t\t\t    &rsp_iov);\n\trsp = (struct smb2_create_rsp *)rsp_iov.iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_iov && rsp) {\n\t\t\t*err_iov = rsp_iov;\n\t\t\t*buftype = resp_buftype;\n\t\t\tresp_buftype = CIFS_NO_BUFFER;\n\t\t\trsp = NULL;\n\t\t}\n\t\ttrace_smb3_open_err(xid, tcon->tid, ses->Suid,\n\t\t\t\t    oparms->create_options, oparms->desired_access, rc);\n\t\tif (rc == -EREMCHG) {\n\t\t\tpr_warn_once(\"server share %s deleted\\n\",\n\t\t\t\t     tcon->treeName);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t\tgoto creat_exit;\n\t} else\n\t\ttrace_smb3_open_done(xid, rsp->PersistentFileId, tcon->tid,\n\t\t\t\t     ses->Suid, oparms->create_options,\n\t\t\t\t     oparms->desired_access);\n\n\tatomic_inc(&tcon->num_remote_opens);\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\toparms->fid->access = oparms->desired_access;\n#ifdef CONFIG_CIFS_DEBUG2\n\toparms->fid->mid = le64_to_cpu(rsp->sync_hdr.MessageId);\n#endif /* CIFS_DEBUG2 */\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\n\tsmb2_parse_contexts(server, rsp, &oparms->fid->epoch,\n\t\t\t    oparms->fid->lease_key, oplock, buf, posix);\ncreat_exit:\n\tSMB2_open_free(&rqst);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nint\nSMB2_ioctl_init(struct cifs_tcon *tcon, struct TCP_Server_Info *server,\n\t\tstruct smb_rqst *rqst,\n\t\tu64 persistent_fid, u64 volatile_fid, u32 opcode,\n\t\tbool is_fsctl, char *in_data, u32 indatalen,\n\t\t__u32 max_response_size)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct kvec *iov = rqst->rq_iov;\n\tunsigned int total_len;\n\tint rc;\n\tchar *in_data_buf;\n\n\trc = smb2_ioctl_req_init(opcode, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (indatalen) {\n\t\t/*\n\t\t * indatalen is usually small at a couple of bytes max, so\n\t\t * just allocate through generic pool\n\t\t */\n\t\tin_data_buf = kmemdup(in_data, indatalen, GFP_NOFS);\n\t\tif (!in_data_buf) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]).\n\t */\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer));\n\t\trqst->rq_nvec = 2;\n\t\tiov[0].iov_len = total_len - 1;\n\t\tiov[1].iov_base = in_data_buf;\n\t\tiov[1].iov_len = indatalen;\n\t} else {\n\t\trqst->rq_nvec = 1;\n\t\tiov[0].iov_len = total_len;\n\t}\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * In most cases max_response_size is set to 16K (CIFSMaxBufSize)\n\t * We Could increase default MaxOutputResponse, but that could require\n\t * more credits. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t * We can not handle more than CIFS_MAX_BUF_SIZE yet but may want\n\t * to increase this limit up in the future.\n\t * Note that for snapshot queries that servers like Azure expect that\n\t * the first query be minimal size (and just used to get the number/size\n\t * of previous versions) so response size must be specified as EXACTLY\n\t * sizeof(struct snapshot_array) which is 16 when rounded up to multiple\n\t * of eight bytes.  Currently that is the only case where we set max\n\t * response size smaller.\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(max_response_size);\n\treq->sync_hdr.CreditCharge =\n\t\tcpu_to_le16(DIV_ROUND_UP(max(indatalen, max_response_size),\n\t\t\t\t\t SMB2_MAX_BUFFER_SIZE));\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\t/* validate negotiate request must be signed - see MS-SMB2 3.2.5.5 */\n\tif (opcode == FSCTL_VALIDATE_NEGOTIATE_INFO)\n\t\treq->sync_hdr.Flags |= SMB2_FLAGS_SIGNED;\n\n\treturn 0;\n}\n\nvoid\nSMB2_ioctl_free(struct smb_rqst *rqst)\n{\n\tint i;\n\tif (rqst && rqst->rq_iov) {\n\t\tcifs_small_buf_release(rqst->rq_iov[0].iov_base); /* request */\n\t\tfor (i = 1; i < rqst->rq_nvec; i++)\n\t\t\tif (rqst->rq_iov[i].iov_base != smb2_padding)\n\t\t\t\tkfree(rqst->rq_iov[i].iov_base);\n\t}\n}\n\n\n/*\n *\tSMB2 IOCTL is used for both IOCTLs and FSCTLs\n */\nint\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl,\n\t   char *in_data, u32 indatalen, u32 max_out_data_len,\n\t   char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_ioctl_rsp *rsp = NULL;\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\tstruct kvec iov[SMB2_IOCTL_IOV_SIZE];\n\tstruct kvec rsp_iov = {NULL, 0};\n\tint resp_buftype = CIFS_NO_BUFFER;\n\tint rc = 0;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (!tcon)\n\t\treturn -EIO;\n\n\tses = tcon->ses;\n\tif (!ses)\n\t\treturn -EIO;\n\n\tserver = cifs_pick_channel(ses);\n\tif (!server)\n\t\treturn -EIO;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\tmemset(&iov, 0, sizeof(iov));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = SMB2_IOCTL_IOV_SIZE;\n\n\trc = SMB2_ioctl_init(tcon, server,\n\t\t\t     &rqst, persistent_fid, volatile_fid, opcode,\n\t\t\t     is_fsctl, in_data, indatalen, max_out_data_len);\n\tif (rc)\n\t\tgoto ioctl_exit;\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags,\n\t\t\t    &rsp_iov);\n\trsp = (struct smb2_ioctl_rsp *)rsp_iov.iov_base;\n\n\tif (rc != 0)\n\t\ttrace_smb3_fsctl_err(xid, persistent_fid, tcon->tid,\n\t\t\t\tses->Suid, 0, opcode, rc);\n\n\tif ((rc != 0) && (rc != -EINVAL) && (rc != -E2BIG)) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t} else if (rc == -E2BIG) {\n\t\tif (opcode != FSCTL_QUERY_ALLOCATED_RANGES) {\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > rsp_iov.iov_len || *plen > 0xFF00) {\n\t\tcifs_tcon_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (rsp_iov.iov_len - *plen < le32_to_cpu(rsp->OutputOffset)) {\n\t\tcifs_tcon_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmemdup((char *)rsp + le32_to_cpu(rsp->OutputOffset),\n\t\t\t    *plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\nioctl_exit:\n\tSMB2_ioctl_free(&rqst);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\n/*\n *   Individual callers to ioctl worker function follow\n */\n\nint\nSMB2_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid)\n{\n\tint rc;\n\tstruct  compress_ioctl fsctl_input;\n\tchar *ret_data = NULL;\n\n\tfsctl_input.CompressionState =\n\t\t\tcpu_to_le16(COMPRESSION_FORMAT_DEFAULT);\n\n\trc = SMB2_ioctl(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tFSCTL_SET_COMPRESSION, true /* is_fsctl */,\n\t\t\t(char *)&fsctl_input /* data input */,\n\t\t\t2 /* in data len */, CIFSMaxBufSize /* max out data */,\n\t\t\t&ret_data /* out data */, NULL);\n\n\tcifs_dbg(FYI, \"set compression rc %d\\n\", rc);\n\n\treturn rc;\n}\n\nint\nSMB2_close_init(struct cifs_tcon *tcon, struct TCP_Server_Info *server,\n\t\tstruct smb_rqst *rqst,\n\t\tu64 persistent_fid, u64 volatile_fid, bool query_attrs)\n{\n\tstruct smb2_close_req *req;\n\tstruct kvec *iov = rqst->rq_iov;\n\tunsigned int total_len;\n\tint rc;\n\n\trc = smb2_plain_req_init(SMB2_CLOSE, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\tif (query_attrs)\n\t\treq->Flags = SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB;\n\telse\n\t\treq->Flags = 0;\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\treturn 0;\n}\n\nvoid\nSMB2_close_free(struct smb_rqst *rqst)\n{\n\tif (rqst && rqst->rq_iov)\n\t\tcifs_small_buf_release(rqst->rq_iov[0].iov_base); /* request */\n}\n\nint\n__SMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t     u64 persistent_fid, u64 volatile_fid,\n\t     struct smb2_file_network_open_info *pbuf)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_close_rsp *rsp = NULL;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buftype = CIFS_NO_BUFFER;\n\tint rc = 0;\n\tint flags = 0;\n\tbool query_attrs = false;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (!ses || !server)\n\t\treturn -EIO;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\tmemset(&iov, 0, sizeof(iov));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\t/* check if need to ask server to return timestamps in close response */\n\tif (pbuf)\n\t\tquery_attrs = true;\n\n\ttrace_smb3_close_enter(xid, persistent_fid, tcon->tid, ses->Suid);\n\trc = SMB2_close_init(tcon, server,\n\t\t\t     &rqst, persistent_fid, volatile_fid,\n\t\t\t     query_attrs);\n\tif (rc)\n\t\tgoto close_exit;\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\trsp = (struct smb2_close_rsp *)rsp_iov.iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\ttrace_smb3_close_err(xid, persistent_fid, tcon->tid, ses->Suid,\n\t\t\t\t     rc);\n\t\tgoto close_exit;\n\t} else {\n\t\ttrace_smb3_close_done(xid, persistent_fid, tcon->tid,\n\t\t\t\t      ses->Suid);\n\t\t/*\n\t\t * Note that have to subtract 4 since struct network_open_info\n\t\t * has a final 4 byte pad that close response does not have\n\t\t */\n\t\tif (pbuf)\n\t\t\tmemcpy(pbuf, (char *)&rsp->CreationTime, sizeof(*pbuf) - 4);\n\t}\n\n\tatomic_dec(&tcon->num_remote_opens);\nclose_exit:\n\tSMB2_close_free(&rqst);\n\tfree_rsp_buf(resp_buftype, rsp);\n\n\t/* retry close in a worker thread if this one is interrupted */\n\tif (rc == -EINTR) {\n\t\tint tmp_rc;\n\n\t\ttmp_rc = smb2_handle_cancelled_close(tcon, persistent_fid,\n\t\t\t\t\t\t     volatile_fid);\n\t\tif (tmp_rc)\n\t\t\tcifs_dbg(VFS, \"handle cancelled close fid 0x%llx returned error %d\\n\",\n\t\t\t\t persistent_fid, tmp_rc);\n\t}\n\treturn rc;\n}\n\nint\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tu64 persistent_fid, u64 volatile_fid)\n{\n\treturn __SMB2_close(xid, tcon, persistent_fid, volatile_fid, NULL);\n}\n\nint\nsmb2_validate_iov(unsigned int offset, unsigned int buffer_length,\n\t\t  struct kvec *iov, unsigned int min_buf_size)\n{\n\tunsigned int smb_len = iov->iov_len;\n\tchar *end_of_smb = smb_len + (char *)iov->iov_base;\n\tchar *begin_of_buf = offset + (char *)iov->iov_base;\n\tchar *end_of_buf = begin_of_buf + buffer_length;\n\n\n\tif (buffer_length < min_buf_size) {\n\t\tcifs_dbg(VFS, \"buffer length %d smaller than minimum size %d\\n\",\n\t\t\t buffer_length, min_buf_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if beyond RFC1001 maximum length */\n\tif ((smb_len > 0x7FFFFF) || (buffer_length > 0x7FFFFF)) {\n\t\tcifs_dbg(VFS, \"buffer length %d or smb length %d too large\\n\",\n\t\t\t buffer_length, smb_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((begin_of_buf > end_of_smb) || (end_of_buf > end_of_smb)) {\n\t\tcifs_dbg(VFS, \"Invalid server response, bad offset to data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/*\n * If SMB buffer fields are valid, copy into temporary buffer to hold result.\n * Caller must free buffer.\n */\nint\nsmb2_validate_and_copy_iov(unsigned int offset, unsigned int buffer_length,\n\t\t\t   struct kvec *iov, unsigned int minbufsize,\n\t\t\t   char *data)\n{\n\tchar *begin_of_buf = offset + (char *)iov->iov_base;\n\tint rc;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\trc = smb2_validate_iov(offset, buffer_length, iov, minbufsize);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(data, begin_of_buf, buffer_length);\n\n\treturn 0;\n}\n\nint\nSMB2_query_info_init(struct cifs_tcon *tcon, struct TCP_Server_Info *server,\n\t\t     struct smb_rqst *rqst,\n\t\t     u64 persistent_fid, u64 volatile_fid,\n\t\t     u8 info_class, u8 info_type, u32 additional_info,\n\t\t     size_t output_len, size_t input_len, void *input)\n{\n\tstruct smb2_query_info_req *req;\n\tstruct kvec *iov = rqst->rq_iov;\n\tunsigned int total_len;\n\tint rc;\n\n\trc = smb2_plain_req_init(SMB2_QUERY_INFO, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->InfoType = info_type;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\treq->AdditionalInformation = cpu_to_le32(additional_info);\n\n\treq->OutputBufferLength = cpu_to_le32(output_len);\n\tif (input_len) {\n\t\treq->InputBufferLength = cpu_to_le32(input_len);\n\t\t/* total_len for smb query request never close to le16 max */\n\t\treq->InputBufferOffset = cpu_to_le16(total_len - 1);\n\t\tmemcpy(req->Buffer, input, input_len);\n\t}\n\n\tiov[0].iov_base = (char *)req;\n\t/* 1 for Buffer */\n\tiov[0].iov_len = total_len - 1 + input_len;\n\treturn 0;\n}\n\nvoid\nSMB2_query_info_free(struct smb_rqst *rqst)\n{\n\tif (rqst && rqst->rq_iov)\n\t\tcifs_small_buf_release(rqst->rq_iov[0].iov_base); /* request */\n}\n\nstatic int\nquery_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid, u8 info_class, u8 info_type,\n\t   u32 additional_info, size_t output_len, size_t min_len, void **data,\n\t\tu32 *dlen)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype = CIFS_NO_BUFFER;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server;\n\tint flags = 0;\n\tbool allocated = false;\n\n\tcifs_dbg(FYI, \"Query Info\\n\");\n\n\tif (!ses)\n\t\treturn -EIO;\n\tserver = cifs_pick_channel(ses);\n\tif (!server)\n\t\treturn -EIO;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\tmemset(&iov, 0, sizeof(iov));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = SMB2_query_info_init(tcon, server,\n\t\t\t\t  &rqst, persistent_fid, volatile_fid,\n\t\t\t\t  info_class, info_type, additional_info,\n\t\t\t\t  output_len, 0, NULL);\n\tif (rc)\n\t\tgoto qinf_exit;\n\n\ttrace_smb3_query_info_enter(xid, persistent_fid, tcon->tid,\n\t\t\t\t    ses->Suid, info_class, (__u32)info_type);\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\ttrace_smb3_query_info_err(xid, persistent_fid, tcon->tid,\n\t\t\t\tses->Suid, info_class, (__u32)info_type, rc);\n\t\tgoto qinf_exit;\n\t}\n\n\ttrace_smb3_query_info_done(xid, persistent_fid, tcon->tid,\n\t\t\t\tses->Suid, info_class, (__u32)info_type);\n\n\tif (dlen) {\n\t\t*dlen = le32_to_cpu(rsp->OutputBufferLength);\n\t\tif (!*data) {\n\t\t\t*data = kmalloc(*dlen, GFP_KERNEL);\n\t\t\tif (!*data) {\n\t\t\t\tcifs_tcon_dbg(VFS,\n\t\t\t\t\t\"Error %d allocating memory for acl\\n\",\n\t\t\t\t\trc);\n\t\t\t\t*dlen = 0;\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto qinf_exit;\n\t\t\t}\n\t\t\tallocated = true;\n\t\t}\n\t}\n\n\trc = smb2_validate_and_copy_iov(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t\t\tle32_to_cpu(rsp->OutputBufferLength),\n\t\t\t\t\t&rsp_iov, min_len, *data);\n\tif (rc && allocated) {\n\t\tkfree(*data);\n\t\t*data = NULL;\n\t\t*dlen = 0;\n\t}\n\nqinf_exit:\n\tSMB2_query_info_free(&rqst);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nint SMB2_query_info(const unsigned int xid, struct cifs_tcon *tcon,\n\tu64 persistent_fid, u64 volatile_fid, struct smb2_file_all_info *data)\n{\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  FILE_ALL_INFORMATION, SMB2_O_INFO_FILE, 0,\n\t\t\t  sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\n\t\t\t  sizeof(struct smb2_file_all_info), (void **)&data,\n\t\t\t  NULL);\n}\n\nint\nSMB311_posix_query_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tu64 persistent_fid, u64 volatile_fid, struct smb311_posix_qinfo *data, u32 *plen)\n{\n\tsize_t output_len = sizeof(struct smb311_posix_qinfo *) +\n\t\t\t(sizeof(struct cifs_sid) * 2) + (PATH_MAX * 2);\n\t*plen = 0;\n\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  SMB_FIND_FILE_POSIX_INFO, SMB2_O_INFO_FILE, 0,\n\t\t\t  output_len, sizeof(struct smb311_posix_qinfo), (void **)&data, plen);\n}\n\nint\nSMB2_query_acl(const unsigned int xid, struct cifs_tcon *tcon,\n\t       u64 persistent_fid, u64 volatile_fid,\n\t       void **data, u32 *plen, u32 extra_info)\n{\n\t__u32 additional_info = OWNER_SECINFO | GROUP_SECINFO | DACL_SECINFO |\n\t\t\t\textra_info;\n\t*plen = 0;\n\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  0, SMB2_O_INFO_SECURITY, additional_info,\n\t\t\t  SMB2_MAX_BUFFER_SIZE, MIN_SEC_DESC_LEN, data, plen);\n}\n\nint\nSMB2_get_srv_num(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t u64 persistent_fid, u64 volatile_fid, __le64 *uniqueid)\n{\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  FILE_INTERNAL_INFORMATION, SMB2_O_INFO_FILE, 0,\n\t\t\t  sizeof(struct smb2_file_internal_info),\n\t\t\t  sizeof(struct smb2_file_internal_info),\n\t\t\t  (void **)&uniqueid, NULL);\n}\n\n/*\n * CHANGE_NOTIFY Request is sent to get notifications on changes to a directory\n * See MS-SMB2 2.2.35 and 2.2.36\n */\n\nstatic int\nSMB2_notify_init(const unsigned int xid, struct smb_rqst *rqst,\n\t\t struct cifs_tcon *tcon, struct TCP_Server_Info *server,\n\t\t u64 persistent_fid, u64 volatile_fid,\n\t\t u32 completion_filter, bool watch_tree)\n{\n\tstruct smb2_change_notify_req *req;\n\tstruct kvec *iov = rqst->rq_iov;\n\tunsigned int total_len;\n\tint rc;\n\n\trc = smb2_plain_req_init(SMB2_CHANGE_NOTIFY, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t/* See note 354 of MS-SMB2, 64K max */\n\treq->OutputBufferLength =\n\t\tcpu_to_le32(SMB2_MAX_BUFFER_SIZE - MAX_SMB2_HDR_SIZE);\n\treq->CompletionFilter = cpu_to_le32(completion_filter);\n\tif (watch_tree)\n\t\treq->Flags = cpu_to_le16(SMB2_WATCH_TREE);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\treturn 0;\n}\n\nint\nSMB2_change_notify(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tu64 persistent_fid, u64 volatile_fid, bool watch_tree,\n\t\tu32 completion_filter)\n{\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tstruct smb_rqst rqst;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov = {NULL, 0};\n\tint resp_buftype = CIFS_NO_BUFFER;\n\tint flags = 0;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"change notify\\n\");\n\tif (!ses || !server)\n\t\treturn -EIO;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\tmemset(&iov, 0, sizeof(iov));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = SMB2_notify_init(xid, &rqst, tcon, server,\n\t\t\t      persistent_fid, volatile_fid,\n\t\t\t      completion_filter, watch_tree);\n\tif (rc)\n\t\tgoto cnotify_exit;\n\n\ttrace_smb3_notify_enter(xid, persistent_fid, tcon->tid, ses->Suid,\n\t\t\t\t(u8)watch_tree, completion_filter);\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CHANGE_NOTIFY_HE);\n\t\ttrace_smb3_notify_err(xid, persistent_fid, tcon->tid, ses->Suid,\n\t\t\t\t(u8)watch_tree, completion_filter, rc);\n\t} else\n\t\ttrace_smb3_notify_done(xid, persistent_fid, tcon->tid,\n\t\t\t\tses->Suid, (u8)watch_tree, completion_filter);\n\n cnotify_exit:\n\tif (rqst.rq_iov)\n\t\tcifs_small_buf_release(rqst.rq_iov[0].iov_base); /* request */\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}\n\n\n\n/*\n * This is a no-op for now. We're not really interested in the reply, but\n * rather in the fact that the server sent one and that server->lstrp\n * gets updated.\n *\n * FIXME: maybe we should consider checking that the reply matches request?\n */\nstatic void\nsmb2_echo_callback(struct mid_q_entry *mid)\n{\n\tstruct TCP_Server_Info *server = mid->callback_data;\n\tstruct smb2_echo_rsp *rsp = (struct smb2_echo_rsp *)mid->resp_buf;\n\tstruct cifs_credits credits = { .value = 0, .instance = 0 };\n\n\tif (mid->mid_state == MID_RESPONSE_RECEIVED\n\t    || mid->mid_state == MID_RESPONSE_MALFORMED) {\n\t\tcredits.value = le16_to_cpu(rsp->sync_hdr.CreditRequest);\n\t\tcredits.instance = server->reconnect_instance;\n\t}\n\n\tDeleteMidQEntry(mid);\n\tadd_credits(server, &credits, CIFS_ECHO_OP);\n}\n\nvoid smb2_reconnect_server(struct work_struct *work)\n{\n\tstruct TCP_Server_Info *server = container_of(work,\n\t\t\t\t\tstruct TCP_Server_Info, reconnect.work);\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon, *tcon2;\n\tstruct list_head tmp_list;\n\tint tcon_exist = false;\n\tint rc;\n\tint resched = false;\n\n\n\t/* Prevent simultaneous reconnects that can corrupt tcon->rlist list */\n\tmutex_lock(&server->reconnect_mutex);\n\n\tINIT_LIST_HEAD(&tmp_list);\n\tcifs_dbg(FYI, \"Need negotiate, reconnecting tcons\\n\");\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\tlist_for_each_entry(tcon, &ses->tcon_list, tcon_list) {\n\t\t\tif (tcon->need_reconnect || tcon->need_reopen_files) {\n\t\t\t\ttcon->tc_count++;\n\t\t\t\tlist_add_tail(&tcon->rlist, &tmp_list);\n\t\t\t\ttcon_exist = true;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * IPC has the same lifetime as its session and uses its\n\t\t * refcount.\n\t\t */\n\t\tif (ses->tcon_ipc && ses->tcon_ipc->need_reconnect) {\n\t\t\tlist_add_tail(&ses->tcon_ipc->rlist, &tmp_list);\n\t\t\ttcon_exist = true;\n\t\t\tses->ses_count++;\n\t\t}\n\t}\n\t/*\n\t * Get the reference to server struct to be sure that the last call of\n\t * cifs_put_tcon() in the loop below won't release the server pointer.\n\t */\n\tif (tcon_exist)\n\t\tserver->srv_count++;\n\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tlist_for_each_entry_safe(tcon, tcon2, &tmp_list, rlist) {\n\t\trc = smb2_reconnect(SMB2_INTERNAL_CMD, tcon, server);\n\t\tif (!rc)\n\t\t\tcifs_reopen_persistent_handles(tcon);\n\t\telse\n\t\t\tresched = true;\n\t\tlist_del_init(&tcon->rlist);\n\t\tif (tcon->ipc)\n\t\t\tcifs_put_smb_ses(tcon->ses);\n\t\telse\n\t\t\tcifs_put_tcon(tcon);\n\t}\n\n\tcifs_dbg(FYI, \"Reconnecting tcons finished\\n\");\n\tif (resched)\n\t\tqueue_delayed_work(cifsiod_wq, &server->reconnect, 2 * HZ);\n\tmutex_unlock(&server->reconnect_mutex);\n\n\t/* now we can safely release srv struct */\n\tif (tcon_exist)\n\t\tcifs_put_tcp_session(server, 1);\n}\n\nint\nSMB2_echo(struct TCP_Server_Info *server)\n{\n\tstruct smb2_echo_req *req;\n\tint rc = 0;\n\tstruct kvec iov[1];\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = 1 };\n\tunsigned int total_len;\n\n\tcifs_dbg(FYI, \"In echo request\\n\");\n\n\tif (server->tcpStatus == CifsNeedNegotiate) {\n\t\t/* No need to send echo on newly established connections */\n\t\tmod_delayed_work(cifsiod_wq, &server->reconnect, 0);\n\t\treturn rc;\n\t}\n\n\trc = smb2_plain_req_init(SMB2_ECHO, NULL, server,\n\t\t\t\t (void **)&req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->sync_hdr.CreditRequest = cpu_to_le16(1);\n\n\tiov[0].iov_len = total_len;\n\tiov[0].iov_base = (char *)req;\n\n\trc = cifs_call_async(server, &rqst, NULL, smb2_echo_callback, NULL,\n\t\t\t     server, CIFS_ECHO_OP, NULL);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Echo request failed: %d\\n\", rc);\n\n\tcifs_small_buf_release(req);\n\treturn rc;\n}\n\nvoid\nSMB2_flush_free(struct smb_rqst *rqst)\n{\n\tif (rqst && rqst->rq_iov)\n\t\tcifs_small_buf_release(rqst->rq_iov[0].iov_base); /* request */\n}\n\nint\nSMB2_flush_init(const unsigned int xid, struct smb_rqst *rqst,\n\t\tstruct cifs_tcon *tcon, struct TCP_Server_Info *server,\n\t\tu64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_flush_req *req;\n\tstruct kvec *iov = rqst->rq_iov;\n\tunsigned int total_len;\n\tint rc;\n\n\trc = smb2_plain_req_init(SMB2_FLUSH, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\treturn 0;\n}\n\nint\nSMB2_flush(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid)\n{\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct smb_rqst rqst;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov = {NULL, 0};\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tint resp_buftype = CIFS_NO_BUFFER;\n\tint flags = 0;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"flush\\n\");\n\tif (!ses || !(ses->server))\n\t\treturn -EIO;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\tmemset(&iov, 0, sizeof(iov));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = SMB2_flush_init(xid, &rqst, tcon, server,\n\t\t\t     persistent_fid, volatile_fid);\n\tif (rc)\n\t\tgoto flush_exit;\n\n\ttrace_smb3_flush_enter(xid, persistent_fid, tcon->tid, ses->Suid);\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_FLUSH_HE);\n\t\ttrace_smb3_flush_err(xid, persistent_fid, tcon->tid, ses->Suid,\n\t\t\t\t     rc);\n\t} else\n\t\ttrace_smb3_flush_done(xid, persistent_fid, tcon->tid,\n\t\t\t\t      ses->Suid);\n\n flush_exit:\n\tSMB2_flush_free(&rqst);\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}\n\n/*\n * To form a chain of read requests, any read requests after the first should\n * have the end_of_chain boolean set to true.\n */\nstatic int\nsmb2_new_read_req(void **buf, unsigned int *total_len,\n\tstruct cifs_io_parms *io_parms, struct cifs_readdata *rdata,\n\tunsigned int remaining_bytes, int request_type)\n{\n\tint rc = -EACCES;\n\tstruct smb2_read_plain_req *req = NULL;\n\tstruct smb2_sync_hdr *shdr;\n\tstruct TCP_Server_Info *server = io_parms->server;\n\n\trc = smb2_plain_req_init(SMB2_READ, io_parms->tcon, server,\n\t\t\t\t (void **) &req, total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tshdr = &req->sync_hdr;\n\tshdr->ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->ReadChannelInfoOffset = 0; /* reserved */\n\treq->ReadChannelInfoLength = 0; /* reserved */\n\treq->Channel = 0; /* reserved */\n\treq->MinimumCount = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\n\ttrace_smb3_read_enter(0 /* xid */,\n\t\t\tio_parms->persistent_fid,\n\t\t\tio_parms->tcon->tid, io_parms->tcon->ses->Suid,\n\t\t\tio_parms->offset, io_parms->length);\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\t/*\n\t * If we want to do a RDMA write, fill in and append\n\t * smbd_buffer_descriptor_v1 to the end of read request\n\t */\n\tif (server->rdma && rdata && !server->sign &&\n\t\trdata->bytes >= server->smbd_conn->rdma_readwrite_threshold) {\n\n\t\tstruct smbd_buffer_descriptor_v1 *v1;\n\t\tbool need_invalidate = server->dialect == SMB30_PROT_ID;\n\n\t\trdata->mr = smbd_register_mr(\n\t\t\t\tserver->smbd_conn, rdata->pages,\n\t\t\t\trdata->nr_pages, rdata->page_offset,\n\t\t\t\trdata->tailsz, true, need_invalidate);\n\t\tif (!rdata->mr)\n\t\t\treturn -EAGAIN;\n\n\t\treq->Channel = SMB2_CHANNEL_RDMA_V1_INVALIDATE;\n\t\tif (need_invalidate)\n\t\t\treq->Channel = SMB2_CHANNEL_RDMA_V1;\n\t\treq->ReadChannelInfoOffset =\n\t\t\tcpu_to_le16(offsetof(struct smb2_read_plain_req, Buffer));\n\t\treq->ReadChannelInfoLength =\n\t\t\tcpu_to_le16(sizeof(struct smbd_buffer_descriptor_v1));\n\t\tv1 = (struct smbd_buffer_descriptor_v1 *) &req->Buffer[0];\n\t\tv1->offset = cpu_to_le64(rdata->mr->mr->iova);\n\t\tv1->token = cpu_to_le32(rdata->mr->mr->rkey);\n\t\tv1->length = cpu_to_le32(rdata->mr->mr->length);\n\n\t\t*total_len += sizeof(*v1) - 1;\n\t}\n#endif\n\tif (request_type & CHAINED_REQUEST) {\n\t\tif (!(request_type & END_OF_CHAIN)) {\n\t\t\t/* next 8-byte aligned request */\n\t\t\t*total_len = DIV_ROUND_UP(*total_len, 8) * 8;\n\t\t\tshdr->NextCommand = cpu_to_le32(*total_len);\n\t\t} else /* END_OF_CHAIN */\n\t\t\tshdr->NextCommand = 0;\n\t\tif (request_type & RELATED_REQUEST) {\n\t\t\tshdr->Flags |= SMB2_FLAGS_RELATED_OPERATIONS;\n\t\t\t/*\n\t\t\t * Related requests use info from previous read request\n\t\t\t * in chain.\n\t\t\t */\n\t\t\tshdr->SessionId = 0xFFFFFFFF;\n\t\t\tshdr->TreeId = 0xFFFFFFFF;\n\t\t\treq->PersistentFileId = 0xFFFFFFFF;\n\t\t\treq->VolatileFileId = 0xFFFFFFFF;\n\t\t}\n\t}\n\tif (remaining_bytes > io_parms->length)\n\t\treq->RemainingBytes = cpu_to_le32(remaining_bytes);\n\telse\n\t\treq->RemainingBytes = 0;\n\n\t*buf = req;\n\treturn rc;\n}\n\nstatic void\nsmb2_readv_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_readdata *rdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(rdata->cfile->tlink);\n\tstruct TCP_Server_Info *server = rdata->server;\n\tstruct smb2_sync_hdr *shdr =\n\t\t\t\t(struct smb2_sync_hdr *)rdata->iov[0].iov_base;\n\tstruct cifs_credits credits = { .value = 0, .instance = 0 };\n\tstruct smb_rqst rqst = { .rq_iov = &rdata->iov[1],\n\t\t\t\t .rq_nvec = 1,\n\t\t\t\t .rq_pages = rdata->pages,\n\t\t\t\t .rq_offset = rdata->page_offset,\n\t\t\t\t .rq_npages = rdata->nr_pages,\n\t\t\t\t .rq_pagesz = rdata->pagesz,\n\t\t\t\t .rq_tailsz = rdata->tailsz };\n\n\tWARN_ONCE(rdata->server != mid->server,\n\t\t  \"rdata server %p != mid server %p\",\n\t\t  rdata->server, mid->server);\n\n\tcifs_dbg(FYI, \"%s: mid=%llu state=%d result=%d bytes=%u\\n\",\n\t\t __func__, mid->mid, mid->mid_state, rdata->result,\n\t\t rdata->bytes);\n\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tcredits.value = le16_to_cpu(shdr->CreditRequest);\n\t\tcredits.instance = server->reconnect_instance;\n\t\t/* result already set, check signature */\n\t\tif (server->sign && !mid->decrypted) {\n\t\t\tint rc;\n\n\t\t\trc = smb2_verify_signature(&rqst, server);\n\t\t\tif (rc)\n\t\t\t\tcifs_tcon_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t\t rc);\n\t\t}\n\t\t/* FIXME: should this be counted toward the initiating task? */\n\t\ttask_io_account_read(rdata->got_bytes);\n\t\tcifs_stats_bytes_read(tcon, rdata->got_bytes);\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\trdata->result = -EAGAIN;\n\t\tif (server->sign && rdata->got_bytes)\n\t\t\t/* reset bytes number since we can not check a sign */\n\t\t\trdata->got_bytes = 0;\n\t\t/* FIXME: should this be counted toward the initiating task? */\n\t\ttask_io_account_read(rdata->got_bytes);\n\t\tcifs_stats_bytes_read(tcon, rdata->got_bytes);\n\t\tbreak;\n\tcase MID_RESPONSE_MALFORMED:\n\t\tcredits.value = le16_to_cpu(shdr->CreditRequest);\n\t\tcredits.instance = server->reconnect_instance;\n\t\tfallthrough;\n\tdefault:\n\t\trdata->result = -EIO;\n\t}\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\t/*\n\t * If this rdata has a memmory registered, the MR can be freed\n\t * MR needs to be freed as soon as I/O finishes to prevent deadlock\n\t * because they have limited number and are used for future I/Os\n\t */\n\tif (rdata->mr) {\n\t\tsmbd_deregister_mr(rdata->mr);\n\t\trdata->mr = NULL;\n\t}\n#endif\n\tif (rdata->result && rdata->result != -ENODATA) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_READ_HE);\n\t\ttrace_smb3_read_err(0 /* xid */,\n\t\t\t\t    rdata->cfile->fid.persistent_fid,\n\t\t\t\t    tcon->tid, tcon->ses->Suid, rdata->offset,\n\t\t\t\t    rdata->bytes, rdata->result);\n\t} else\n\t\ttrace_smb3_read_done(0 /* xid */,\n\t\t\t\t     rdata->cfile->fid.persistent_fid,\n\t\t\t\t     tcon->tid, tcon->ses->Suid,\n\t\t\t\t     rdata->offset, rdata->got_bytes);\n\n\tqueue_work(cifsiod_wq, &rdata->work);\n\tDeleteMidQEntry(mid);\n\tadd_credits(server, &credits, 0);\n}\n\n/* smb2_async_readv - send an async read, and set up mid to handle result */\nint\nsmb2_async_readv(struct cifs_readdata *rdata)\n{\n\tint rc, flags = 0;\n\tchar *buf;\n\tstruct smb2_sync_hdr *shdr;\n\tstruct cifs_io_parms io_parms;\n\tstruct smb_rqst rqst = { .rq_iov = rdata->iov,\n\t\t\t\t .rq_nvec = 1 };\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = tlink_tcon(rdata->cfile->tlink);\n\tunsigned int total_len;\n\n\tcifs_dbg(FYI, \"%s: offset=%llu bytes=%u\\n\",\n\t\t __func__, rdata->offset, rdata->bytes);\n\n\tif (!rdata->server)\n\t\trdata->server = cifs_pick_channel(tcon->ses);\n\n\tio_parms.tcon = tlink_tcon(rdata->cfile->tlink);\n\tio_parms.server = server = rdata->server;\n\tio_parms.offset = rdata->offset;\n\tio_parms.length = rdata->bytes;\n\tio_parms.persistent_fid = rdata->cfile->fid.persistent_fid;\n\tio_parms.volatile_fid = rdata->cfile->fid.volatile_fid;\n\tio_parms.pid = rdata->pid;\n\n\trc = smb2_new_read_req(\n\t\t(void **) &buf, &total_len, &io_parms, rdata, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(io_parms.tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\trdata->iov[0].iov_base = buf;\n\trdata->iov[0].iov_len = total_len;\n\n\tshdr = (struct smb2_sync_hdr *)buf;\n\n\tif (rdata->credits.value > 0) {\n\t\tshdr->CreditCharge = cpu_to_le16(DIV_ROUND_UP(rdata->bytes,\n\t\t\t\t\t\tSMB2_MAX_BUFFER_SIZE));\n\t\tshdr->CreditRequest =\n\t\t\tcpu_to_le16(le16_to_cpu(shdr->CreditCharge) + 1);\n\n\t\trc = adjust_credits(server, &rdata->credits, rdata->bytes);\n\t\tif (rc)\n\t\t\tgoto async_readv_out;\n\n\t\tflags |= CIFS_HAS_CREDITS;\n\t}\n\n\tkref_get(&rdata->refcount);\n\trc = cifs_call_async(server, &rqst,\n\t\t\t     cifs_readv_receive, smb2_readv_callback,\n\t\t\t     smb3_handle_read_data, rdata, flags,\n\t\t\t     &rdata->credits);\n\tif (rc) {\n\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\t\tcifs_stats_fail_inc(io_parms.tcon, SMB2_READ_HE);\n\t\ttrace_smb3_read_err(0 /* xid */, io_parms.persistent_fid,\n\t\t\t\t    io_parms.tcon->tid,\n\t\t\t\t    io_parms.tcon->ses->Suid,\n\t\t\t\t    io_parms.offset, io_parms.length, rc);\n\t}\n\nasync_readv_out:\n\tcifs_small_buf_release(buf);\n\treturn rc;\n}\n\nint\nSMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t  unsigned int *nbytes, char **buf, int *buf_type)\n{\n\tstruct smb_rqst rqst;\n\tint resp_buftype, rc;\n\tstruct smb2_read_plain_req *req = NULL;\n\tstruct smb2_read_rsp *rsp = NULL;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tunsigned int total_len;\n\tint flags = CIFS_LOG_ERROR;\n\tstruct cifs_ses *ses = io_parms->tcon->ses;\n\n\tif (!io_parms->server)\n\t\tio_parms->server = cifs_pick_channel(io_parms->tcon->ses);\n\n\t*nbytes = 0;\n\trc = smb2_new_read_req((void **)&req, &total_len, io_parms, NULL, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, io_parms->server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\trsp = (struct smb2_read_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\tif (rc != -ENODATA) {\n\t\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\n\t\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t\t\ttrace_smb3_read_err(xid, req->PersistentFileId,\n\t\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t\t    io_parms->offset, io_parms->length,\n\t\t\t\t\t    rc);\n\t\t} else\n\t\t\ttrace_smb3_read_done(xid, req->PersistentFileId,\n\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t    io_parms->offset, 0);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t\tcifs_small_buf_release(req);\n\t\treturn rc == -ENODATA ? 0 : rc;\n\t} else\n\t\ttrace_smb3_read_done(xid, req->PersistentFileId,\n\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t    io_parms->offset, io_parms->length);\n\n\tcifs_small_buf_release(req);\n\n\t*nbytes = le32_to_cpu(rsp->DataLength);\n\tif ((*nbytes > CIFS_MAX_MSGSIZE) ||\n\t    (*nbytes > io_parms->length)) {\n\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t *nbytes, io_parms->length);\n\t\trc = -EIO;\n\t\t*nbytes = 0;\n\t}\n\n\tif (*buf) {\n\t\tmemcpy(*buf, (char *)rsp + rsp->DataOffset, *nbytes);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t} else if (resp_buftype != CIFS_NO_BUFFER) {\n\t\t*buf = rsp_iov.iov_base;\n\t\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\t\t*buf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\t\t*buf_type = CIFS_LARGE_BUFFER;\n\t}\n\treturn rc;\n}\n\n/*\n * Check the mid_state and signature on received buffer (if any), and queue the\n * workqueue completion task.\n */\nstatic void\nsmb2_writev_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_writedata *wdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tstruct TCP_Server_Info *server = wdata->server;\n\tunsigned int written;\n\tstruct smb2_write_rsp *rsp = (struct smb2_write_rsp *)mid->resp_buf;\n\tstruct cifs_credits credits = { .value = 0, .instance = 0 };\n\n\tWARN_ONCE(wdata->server != mid->server,\n\t\t  \"wdata server %p != mid server %p\",\n\t\t  wdata->server, mid->server);\n\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tcredits.value = le16_to_cpu(rsp->sync_hdr.CreditRequest);\n\t\tcredits.instance = server->reconnect_instance;\n\t\twdata->result = smb2_check_receive(mid, server, 0);\n\t\tif (wdata->result != 0)\n\t\t\tbreak;\n\n\t\twritten = le32_to_cpu(rsp->DataLength);\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned\n\t\t * by the server is greater than bytes requested by the\n\t\t * client. OS/2 servers are known to set incorrect\n\t\t * CountHigh values.\n\t\t */\n\t\tif (written > wdata->bytes)\n\t\t\twritten &= 0xFFFF;\n\n\t\tif (written < wdata->bytes)\n\t\t\twdata->result = -ENOSPC;\n\t\telse\n\t\t\twdata->bytes = written;\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\twdata->result = -EAGAIN;\n\t\tbreak;\n\tcase MID_RESPONSE_MALFORMED:\n\t\tcredits.value = le16_to_cpu(rsp->sync_hdr.CreditRequest);\n\t\tcredits.instance = server->reconnect_instance;\n\t\tfallthrough;\n\tdefault:\n\t\twdata->result = -EIO;\n\t\tbreak;\n\t}\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\t/*\n\t * If this wdata has a memory registered, the MR can be freed\n\t * The number of MRs available is limited, it's important to recover\n\t * used MR as soon as I/O is finished. Hold MR longer in the later\n\t * I/O process can possibly result in I/O deadlock due to lack of MR\n\t * to send request on I/O retry\n\t */\n\tif (wdata->mr) {\n\t\tsmbd_deregister_mr(wdata->mr);\n\t\twdata->mr = NULL;\n\t}\n#endif\n\tif (wdata->result) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_WRITE_HE);\n\t\ttrace_smb3_write_err(0 /* no xid */,\n\t\t\t\t     wdata->cfile->fid.persistent_fid,\n\t\t\t\t     tcon->tid, tcon->ses->Suid, wdata->offset,\n\t\t\t\t     wdata->bytes, wdata->result);\n\t\tif (wdata->result == -ENOSPC)\n\t\t\tpr_warn_once(\"Out of space writing to %s\\n\",\n\t\t\t\t     tcon->treeName);\n\t} else\n\t\ttrace_smb3_write_done(0 /* no xid */,\n\t\t\t\t      wdata->cfile->fid.persistent_fid,\n\t\t\t\t      tcon->tid, tcon->ses->Suid,\n\t\t\t\t      wdata->offset, wdata->bytes);\n\n\tqueue_work(cifsiod_wq, &wdata->work);\n\tDeleteMidQEntry(mid);\n\tadd_credits(server, &credits, 0);\n}\n\n/* smb2_async_writev - send an async write, and set up mid to handle result */\nint\nsmb2_async_writev(struct cifs_writedata *wdata,\n\t\t  void (*release)(struct kref *kref))\n{\n\tint rc = -EACCES, flags = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_sync_hdr *shdr;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tstruct TCP_Server_Info *server = wdata->server;\n\tstruct kvec iov[1];\n\tstruct smb_rqst rqst = { };\n\tunsigned int total_len;\n\n\tif (!wdata->server)\n\t\tserver = wdata->server = cifs_pick_channel(tcon->ses);\n\n\trc = smb2_plain_req_init(SMB2_WRITE, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tshdr = (struct smb2_sync_hdr *)req;\n\tshdr->ProcessId = cpu_to_le32(wdata->cfile->pid);\n\n\treq->PersistentFileId = wdata->cfile->fid.persistent_fid;\n\treq->VolatileFileId = wdata->cfile->fid.volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Offset = cpu_to_le64(wdata->offset);\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer));\n\treq->RemainingBytes = 0;\n\n\ttrace_smb3_write_enter(0 /* xid */, wdata->cfile->fid.persistent_fid,\n\t\ttcon->tid, tcon->ses->Suid, wdata->offset, wdata->bytes);\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\t/*\n\t * If we want to do a server RDMA read, fill in and append\n\t * smbd_buffer_descriptor_v1 to the end of write request\n\t */\n\tif (server->rdma && !server->sign && wdata->bytes >=\n\t\tserver->smbd_conn->rdma_readwrite_threshold) {\n\n\t\tstruct smbd_buffer_descriptor_v1 *v1;\n\t\tbool need_invalidate = server->dialect == SMB30_PROT_ID;\n\n\t\twdata->mr = smbd_register_mr(\n\t\t\t\tserver->smbd_conn, wdata->pages,\n\t\t\t\twdata->nr_pages, wdata->page_offset,\n\t\t\t\twdata->tailsz, false, need_invalidate);\n\t\tif (!wdata->mr) {\n\t\t\trc = -EAGAIN;\n\t\t\tgoto async_writev_out;\n\t\t}\n\t\treq->Length = 0;\n\t\treq->DataOffset = 0;\n\t\tif (wdata->nr_pages > 1)\n\t\t\treq->RemainingBytes =\n\t\t\t\tcpu_to_le32(\n\t\t\t\t\t(wdata->nr_pages - 1) * wdata->pagesz -\n\t\t\t\t\twdata->page_offset + wdata->tailsz\n\t\t\t\t);\n\t\telse\n\t\t\treq->RemainingBytes = cpu_to_le32(wdata->tailsz);\n\t\treq->Channel = SMB2_CHANNEL_RDMA_V1_INVALIDATE;\n\t\tif (need_invalidate)\n\t\t\treq->Channel = SMB2_CHANNEL_RDMA_V1;\n\t\treq->WriteChannelInfoOffset =\n\t\t\tcpu_to_le16(offsetof(struct smb2_write_req, Buffer));\n\t\treq->WriteChannelInfoLength =\n\t\t\tcpu_to_le16(sizeof(struct smbd_buffer_descriptor_v1));\n\t\tv1 = (struct smbd_buffer_descriptor_v1 *) &req->Buffer[0];\n\t\tv1->offset = cpu_to_le64(wdata->mr->mr->iova);\n\t\tv1->token = cpu_to_le32(wdata->mr->mr->rkey);\n\t\tv1->length = cpu_to_le32(wdata->mr->mr->length);\n\t}\n#endif\n\tiov[0].iov_len = total_len - 1;\n\tiov[0].iov_base = (char *)req;\n\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\trqst.rq_pages = wdata->pages;\n\trqst.rq_offset = wdata->page_offset;\n\trqst.rq_npages = wdata->nr_pages;\n\trqst.rq_pagesz = wdata->pagesz;\n\trqst.rq_tailsz = wdata->tailsz;\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\tif (wdata->mr) {\n\t\tiov[0].iov_len += sizeof(struct smbd_buffer_descriptor_v1);\n\t\trqst.rq_npages = 0;\n\t}\n#endif\n\tcifs_dbg(FYI, \"async write at %llu %u bytes\\n\",\n\t\t wdata->offset, wdata->bytes);\n\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\t/* For RDMA read, I/O size is in RemainingBytes not in Length */\n\tif (!wdata->mr)\n\t\treq->Length = cpu_to_le32(wdata->bytes);\n#else\n\treq->Length = cpu_to_le32(wdata->bytes);\n#endif\n\n\tif (wdata->credits.value > 0) {\n\t\tshdr->CreditCharge = cpu_to_le16(DIV_ROUND_UP(wdata->bytes,\n\t\t\t\t\t\t    SMB2_MAX_BUFFER_SIZE));\n\t\tshdr->CreditRequest =\n\t\t\tcpu_to_le16(le16_to_cpu(shdr->CreditCharge) + 1);\n\n\t\trc = adjust_credits(server, &wdata->credits, wdata->bytes);\n\t\tif (rc)\n\t\t\tgoto async_writev_out;\n\n\t\tflags |= CIFS_HAS_CREDITS;\n\t}\n\n\tkref_get(&wdata->refcount);\n\trc = cifs_call_async(server, &rqst, NULL, smb2_writev_callback, NULL,\n\t\t\t     wdata, flags, &wdata->credits);\n\n\tif (rc) {\n\t\ttrace_smb3_write_err(0 /* no xid */, req->PersistentFileId,\n\t\t\t\t     tcon->tid, tcon->ses->Suid, wdata->offset,\n\t\t\t\t     wdata->bytes, rc);\n\t\tkref_put(&wdata->refcount, release);\n\t\tcifs_stats_fail_inc(tcon, SMB2_WRITE_HE);\n\t}\n\nasync_writev_out:\n\tcifs_small_buf_release(req);\n\treturn rc;\n}\n\n/*\n * SMB2_write function gets iov pointer to kvec array with n_vec as a length.\n * The length field from io_parms must be at least 1 and indicates a number of\n * elements with data to write that begins with position 1 in iov array. All\n * data length is specified by count.\n */\nint\nSMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t   unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tstruct smb_rqst rqst;\n\tint rc = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_write_rsp *rsp = NULL;\n\tint resp_buftype;\n\tstruct kvec rsp_iov;\n\tint flags = 0;\n\tunsigned int total_len;\n\tstruct TCP_Server_Info *server;\n\n\t*nbytes = 0;\n\n\tif (n_vec < 1)\n\t\treturn rc;\n\n\tif (!io_parms->server)\n\t\tio_parms->server = cifs_pick_channel(io_parms->tcon->ses);\n\tserver = io_parms->server;\n\tif (server == NULL)\n\t\treturn -ECONNABORTED;\n\n\trc = smb2_plain_req_init(SMB2_WRITE, io_parms->tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->sync_hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer));\n\treq->RemainingBytes = 0;\n\n\ttrace_smb3_write_enter(xid, io_parms->persistent_fid,\n\t\tio_parms->tcon->tid, io_parms->tcon->ses->Suid,\n\t\tio_parms->offset, io_parms->length);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 1 for Buffer */\n\tiov[0].iov_len = total_len - 1;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = n_vec + 1;\n\n\trc = cifs_send_recv(xid, io_parms->tcon->ses, server,\n\t\t\t    &rqst,\n\t\t\t    &resp_buftype, flags, &rsp_iov);\n\trsp = (struct smb2_write_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\ttrace_smb3_write_err(xid, req->PersistentFileId,\n\t\t\t\t     io_parms->tcon->tid,\n\t\t\t\t     io_parms->tcon->ses->Suid,\n\t\t\t\t     io_parms->offset, io_parms->length, rc);\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_WRITE_HE);\n\t\tcifs_dbg(VFS, \"Send error in write = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\t\ttrace_smb3_write_done(xid, req->PersistentFileId,\n\t\t\t\t     io_parms->tcon->tid,\n\t\t\t\t     io_parms->tcon->ses->Suid,\n\t\t\t\t     io_parms->offset, *nbytes);\n\t}\n\n\tcifs_small_buf_release(req);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nint posix_info_sid_size(const void *beg, const void *end)\n{\n\tsize_t subauth;\n\tint total;\n\n\tif (beg + 1 > end)\n\t\treturn -1;\n\n\tsubauth = *(u8 *)(beg+1);\n\tif (subauth < 1 || subauth > 15)\n\t\treturn -1;\n\n\ttotal = 1 + 1 + 6 + 4*subauth;\n\tif (beg + total > end)\n\t\treturn -1;\n\n\treturn total;\n}\n\nint posix_info_parse(const void *beg, const void *end,\n\t\t     struct smb2_posix_info_parsed *out)\n\n{\n\tint total_len = 0;\n\tint sid_len;\n\tint name_len;\n\tconst void *owner_sid;\n\tconst void *group_sid;\n\tconst void *name;\n\n\t/* if no end bound given, assume payload to be correct */\n\tif (!end) {\n\t\tconst struct smb2_posix_info *p = beg;\n\n\t\tend = beg + le32_to_cpu(p->NextEntryOffset);\n\t\t/* last element will have a 0 offset, pick a sensible bound */\n\t\tif (end == beg)\n\t\t\tend += 0xFFFF;\n\t}\n\n\t/* check base buf */\n\tif (beg + sizeof(struct smb2_posix_info) > end)\n\t\treturn -1;\n\ttotal_len = sizeof(struct smb2_posix_info);\n\n\t/* check owner sid */\n\towner_sid = beg + total_len;\n\tsid_len = posix_info_sid_size(owner_sid, end);\n\tif (sid_len < 0)\n\t\treturn -1;\n\ttotal_len += sid_len;\n\n\t/* check group sid */\n\tgroup_sid = beg + total_len;\n\tsid_len = posix_info_sid_size(group_sid, end);\n\tif (sid_len < 0)\n\t\treturn -1;\n\ttotal_len += sid_len;\n\n\t/* check name len */\n\tif (beg + total_len + 4 > end)\n\t\treturn -1;\n\tname_len = le32_to_cpu(*(__le32 *)(beg + total_len));\n\tif (name_len < 1 || name_len > 0xFFFF)\n\t\treturn -1;\n\ttotal_len += 4;\n\n\t/* check name */\n\tname = beg + total_len;\n\tif (name + name_len > end)\n\t\treturn -1;\n\ttotal_len += name_len;\n\n\tif (out) {\n\t\tout->base = beg;\n\t\tout->size = total_len;\n\t\tout->name_len = name_len;\n\t\tout->name = name;\n\t\tmemcpy(&out->owner, owner_sid,\n\t\t       posix_info_sid_size(owner_sid, end));\n\t\tmemcpy(&out->group, group_sid,\n\t\t       posix_info_sid_size(group_sid, end));\n\t}\n\treturn total_len;\n}\n\nstatic int posix_info_extra_size(const void *beg, const void *end)\n{\n\tint len = posix_info_parse(beg, end, NULL);\n\n\tif (len < 0)\n\t\treturn -1;\n\treturn len - sizeof(struct smb2_posix_info);\n}\n\nstatic unsigned int\nnum_entries(int infotype, char *bufstart, char *end_of_buf, char **lastentry,\n\t    size_t size)\n{\n\tint len;\n\tunsigned int entrycount = 0;\n\tunsigned int next_offset = 0;\n\tchar *entryptr;\n\tFILE_DIRECTORY_INFO *dir_info;\n\n\tif (bufstart == NULL)\n\t\treturn 0;\n\n\tentryptr = bufstart;\n\n\twhile (1) {\n\t\tif (entryptr + next_offset < entryptr ||\n\t\t    entryptr + next_offset > end_of_buf ||\n\t\t    entryptr + next_offset + size > end_of_buf) {\n\t\t\tcifs_dbg(VFS, \"malformed search entry would overflow\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tentryptr = entryptr + next_offset;\n\t\tdir_info = (FILE_DIRECTORY_INFO *)entryptr;\n\n\t\tif (infotype == SMB_FIND_FILE_POSIX_INFO)\n\t\t\tlen = posix_info_extra_size(entryptr, end_of_buf);\n\t\telse\n\t\t\tlen = le32_to_cpu(dir_info->FileNameLength);\n\n\t\tif (len < 0 ||\n\t\t    entryptr + len < entryptr ||\n\t\t    entryptr + len > end_of_buf ||\n\t\t    entryptr + len + size > end_of_buf) {\n\t\t\tcifs_dbg(VFS, \"directory entry name would overflow frame end of buf %p\\n\",\n\t\t\t\t end_of_buf);\n\t\t\tbreak;\n\t\t}\n\n\t\t*lastentry = entryptr;\n\t\tentrycount++;\n\n\t\tnext_offset = le32_to_cpu(dir_info->NextEntryOffset);\n\t\tif (!next_offset)\n\t\t\tbreak;\n\t}\n\n\treturn entrycount;\n}\n\n/*\n * Readdir/FindFirst\n */\nint SMB2_query_directory_init(const unsigned int xid,\n\t\t\t      struct cifs_tcon *tcon,\n\t\t\t      struct TCP_Server_Info *server,\n\t\t\t      struct smb_rqst *rqst,\n\t\t\t      u64 persistent_fid, u64 volatile_fid,\n\t\t\t      int index, int info_level)\n{\n\tstruct smb2_query_directory_req *req;\n\tunsigned char *bufptr;\n\t__le16 asteriks = cpu_to_le16('*');\n\tunsigned int output_size = CIFSMaxBufSize -\n\t\tMAX_SMB2_CREATE_RESPONSE_SIZE -\n\t\tMAX_SMB2_CLOSE_RESPONSE_SIZE;\n\tunsigned int total_len;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint len, rc;\n\n\trc = smb2_plain_req_init(SMB2_QUERY_DIRECTORY, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (info_level) {\n\tcase SMB_FIND_FILE_DIRECTORY_INFO:\n\t\treq->FileInformationClass = FILE_DIRECTORY_INFORMATION;\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\treq->FileInformationClass = FILEID_FULL_DIRECTORY_INFORMATION;\n\t\tbreak;\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t\treq->FileInformationClass = SMB_FIND_FILE_POSIX_INFO;\n\t\tbreak;\n\tdefault:\n\t\tcifs_tcon_dbg(VFS, \"info level %u isn't supported\\n\",\n\t\t\tinfo_level);\n\t\treturn -EINVAL;\n\t}\n\n\treq->FileIndex = cpu_to_le32(index);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tlen = 0x2;\n\tbufptr = req->Buffer;\n\tmemcpy(bufptr, &asteriks, len);\n\n\treq->FileNameOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_query_directory_req) - 1);\n\treq->FileNameLength = cpu_to_le16(len);\n\t/*\n\t * BB could be 30 bytes or so longer if we used SMB2 specific\n\t * buffer lengths, but this is safe and close enough.\n\t */\n\toutput_size = min_t(unsigned int, output_size, server->maxBuf);\n\toutput_size = min_t(unsigned int, output_size, 2 << 15);\n\treq->OutputBufferLength = cpu_to_le32(output_size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 1 for Buffer */\n\tiov[0].iov_len = total_len - 1;\n\n\tiov[1].iov_base = (char *)(req->Buffer);\n\tiov[1].iov_len = len;\n\n\ttrace_smb3_query_dir_enter(xid, persistent_fid, tcon->tid,\n\t\t\ttcon->ses->Suid, index, output_size);\n\n\treturn 0;\n}\n\nvoid SMB2_query_directory_free(struct smb_rqst *rqst)\n{\n\tif (rqst && rqst->rq_iov) {\n\t\tcifs_small_buf_release(rqst->rq_iov[0].iov_base); /* request */\n\t}\n}\n\nint\nsmb2_parse_query_directory(struct cifs_tcon *tcon,\n\t\t\t   struct kvec *rsp_iov,\n\t\t\t   int resp_buftype,\n\t\t\t   struct cifs_search_info *srch_inf)\n{\n\tstruct smb2_query_directory_rsp *rsp;\n\tsize_t info_buf_size;\n\tchar *end_of_smb;\n\tint rc;\n\n\trsp = (struct smb2_query_directory_rsp *)rsp_iov->iov_base;\n\n\tswitch (srch_inf->info_level) {\n\tcase SMB_FIND_FILE_DIRECTORY_INFO:\n\t\tinfo_buf_size = sizeof(FILE_DIRECTORY_INFO) - 1;\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\tinfo_buf_size = sizeof(SEARCH_ID_FULL_DIR_INFO) - 1;\n\t\tbreak;\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t\t/* note that posix payload are variable size */\n\t\tinfo_buf_size = sizeof(struct smb2_posix_info);\n\t\tbreak;\n\tdefault:\n\t\tcifs_tcon_dbg(VFS, \"info level %u isn't supported\\n\",\n\t\t\t srch_inf->info_level);\n\t\treturn -EINVAL;\n\t}\n\n\trc = smb2_validate_iov(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t       le32_to_cpu(rsp->OutputBufferLength), rsp_iov,\n\t\t\t       info_buf_size);\n\tif (rc) {\n\t\tcifs_tcon_dbg(VFS, \"bad info payload\");\n\t\treturn rc;\n\t}\n\n\tsrch_inf->unicode = true;\n\n\tif (srch_inf->ntwrk_buf_start) {\n\t\tif (srch_inf->smallBuf)\n\t\t\tcifs_small_buf_release(srch_inf->ntwrk_buf_start);\n\t\telse\n\t\t\tcifs_buf_release(srch_inf->ntwrk_buf_start);\n\t}\n\tsrch_inf->ntwrk_buf_start = (char *)rsp;\n\tsrch_inf->srch_entries_start = srch_inf->last_entry =\n\t\t(char *)rsp + le16_to_cpu(rsp->OutputBufferOffset);\n\tend_of_smb = rsp_iov->iov_len + (char *)rsp;\n\n\tsrch_inf->entries_in_buffer = num_entries(\n\t\tsrch_inf->info_level,\n\t\tsrch_inf->srch_entries_start,\n\t\tend_of_smb,\n\t\t&srch_inf->last_entry,\n\t\tinfo_buf_size);\n\n\tsrch_inf->index_of_last_entry += srch_inf->entries_in_buffer;\n\tcifs_dbg(FYI, \"num entries %d last_index %lld srch start %p srch end %p\\n\",\n\t\t srch_inf->entries_in_buffer, srch_inf->index_of_last_entry,\n\t\t srch_inf->srch_entries_start, srch_inf->last_entry);\n\tif (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tsrch_inf->smallBuf = false;\n\telse if (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tsrch_inf->smallBuf = true;\n\telse\n\t\tcifs_tcon_dbg(VFS, \"Invalid search buffer type\\n\");\n\n\treturn 0;\n}\n\nint\nSMB2_query_directory(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid, int index,\n\t\t     struct cifs_search_info *srch_inf)\n{\n\tstruct smb_rqst rqst;\n\tstruct kvec iov[SMB2_QUERY_DIRECTORY_IOV_SIZE];\n\tstruct smb2_query_directory_rsp *rsp = NULL;\n\tint resp_buftype = CIFS_NO_BUFFER;\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tint flags = 0;\n\n\tif (!ses || !(ses->server))\n\t\treturn -EIO;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\tmemset(&iov, 0, sizeof(iov));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = SMB2_QUERY_DIRECTORY_IOV_SIZE;\n\n\trc = SMB2_query_directory_init(xid, tcon, server,\n\t\t\t\t       &rqst, persistent_fid,\n\t\t\t\t       volatile_fid, index,\n\t\t\t\t       srch_inf->info_level);\n\tif (rc)\n\t\tgoto qdir_exit;\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\trsp = (struct smb2_query_directory_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\tif (rc == -ENODATA &&\n\t\t    rsp->sync_hdr.Status == STATUS_NO_MORE_FILES) {\n\t\t\ttrace_smb3_query_dir_done(xid, persistent_fid,\n\t\t\t\ttcon->tid, tcon->ses->Suid, index, 0);\n\t\t\tsrch_inf->endOfSearch = true;\n\t\t\trc = 0;\n\t\t} else {\n\t\t\ttrace_smb3_query_dir_err(xid, persistent_fid, tcon->tid,\n\t\t\t\ttcon->ses->Suid, index, 0, rc);\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_DIRECTORY_HE);\n\t\t}\n\t\tgoto qdir_exit;\n\t}\n\n\trc = smb2_parse_query_directory(tcon, &rsp_iov,\tresp_buftype,\n\t\t\t\t\tsrch_inf);\n\tif (rc) {\n\t\ttrace_smb3_query_dir_err(xid, persistent_fid, tcon->tid,\n\t\t\ttcon->ses->Suid, index, 0, rc);\n\t\tgoto qdir_exit;\n\t}\n\tresp_buftype = CIFS_NO_BUFFER;\n\n\ttrace_smb3_query_dir_done(xid, persistent_fid, tcon->tid,\n\t\t\ttcon->ses->Suid, index, srch_inf->entries_in_buffer);\n\nqdir_exit:\n\tSMB2_query_directory_free(&rqst);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nint\nSMB2_set_info_init(struct cifs_tcon *tcon, struct TCP_Server_Info *server,\n\t\t   struct smb_rqst *rqst,\n\t\t   u64 persistent_fid, u64 volatile_fid, u32 pid,\n\t\t   u8 info_class, u8 info_type, u32 additional_info,\n\t\t   void **data, unsigned int *size)\n{\n\tstruct smb2_set_info_req *req;\n\tstruct kvec *iov = rqst->rq_iov;\n\tunsigned int i, total_len;\n\tint rc;\n\n\trc = smb2_plain_req_init(SMB2_SET_INFO, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->sync_hdr.ProcessId = cpu_to_le32(pid);\n\treq->InfoType = info_type;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\treq->AdditionalInformation = cpu_to_le32(additional_info);\n\n\treq->BufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_set_info_req) - 1);\n\treq->BufferLength = cpu_to_le32(*size);\n\n\tmemcpy(req->Buffer, *data, *size);\n\ttotal_len += *size;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 1 for Buffer */\n\tiov[0].iov_len = total_len - 1;\n\n\tfor (i = 1; i < rqst->rq_nvec; i++) {\n\t\tle32_add_cpu(&req->BufferLength, size[i]);\n\t\tiov[i].iov_base = (char *)data[i];\n\t\tiov[i].iov_len = size[i];\n\t}\n\n\treturn 0;\n}\n\nvoid\nSMB2_set_info_free(struct smb_rqst *rqst)\n{\n\tif (rqst && rqst->rq_iov)\n\t\tcifs_buf_release(rqst->rq_iov[0].iov_base); /* request */\n}\n\nstatic int\nsend_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t       u64 persistent_fid, u64 volatile_fid, u32 pid, u8 info_class,\n\t       u8 info_type, u32 additional_info, unsigned int num,\n\t\tvoid **data, unsigned int *size)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_set_info_rsp *rsp = NULL;\n\tstruct kvec *iov;\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tint flags = 0;\n\n\tif (!ses || !server)\n\t\treturn -EIO;\n\n\tif (!num)\n\t\treturn -EINVAL;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tiov = kmalloc_array(num, sizeof(struct kvec), GFP_KERNEL);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = num;\n\n\trc = SMB2_set_info_init(tcon, server,\n\t\t\t\t&rqst, persistent_fid, volatile_fid, pid,\n\t\t\t\tinfo_class, info_type, additional_info,\n\t\t\t\tdata, size);\n\tif (rc) {\n\t\tkfree(iov);\n\t\treturn rc;\n\t}\n\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags,\n\t\t\t    &rsp_iov);\n\tSMB2_set_info_free(&rqst);\n\trsp = (struct smb2_set_info_rsp *)rsp_iov.iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_SET_INFO_HE);\n\t\ttrace_smb3_set_info_err(xid, persistent_fid, tcon->tid,\n\t\t\t\tses->Suid, info_class, (__u32)info_type, rc);\n\t}\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(iov);\n\treturn rc;\n}\n\nint\nSMB2_set_eof(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t     u64 volatile_fid, u32 pid, __le64 *eof)\n{\n\tstruct smb2_file_eof_info info;\n\tvoid *data;\n\tunsigned int size;\n\n\tinfo.EndOfFile = *eof;\n\n\tdata = &info;\n\tsize = sizeof(struct smb2_file_eof_info);\n\n\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_END_OF_FILE_INFORMATION, SMB2_O_INFO_FILE,\n\t\t\t0, 1, &data, &size);\n}\n\nint\nSMB2_set_acl(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tu64 persistent_fid, u64 volatile_fid,\n\t\tstruct cifs_ntsd *pnntsd, int pacllen, int aclflag)\n{\n\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tcurrent->tgid, 0, SMB2_O_INFO_SECURITY, aclflag,\n\t\t\t1, (void **)&pnntsd, &pacllen);\n}\n\nint\nSMB2_set_ea(const unsigned int xid, struct cifs_tcon *tcon,\n\t    u64 persistent_fid, u64 volatile_fid,\n\t    struct smb2_file_full_ea_info *buf, int len)\n{\n\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\tcurrent->tgid, FILE_FULL_EA_INFORMATION, SMB2_O_INFO_FILE,\n\t\t0, 1, (void **)&buf, &len);\n}\n\nint\nSMB2_oplock_break(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  const u64 persistent_fid, const u64 volatile_fid,\n\t\t  __u8 oplock_level)\n{\n\tstruct smb_rqst rqst;\n\tint rc;\n\tstruct smb2_oplock_break *req = NULL;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tint flags = CIFS_OBREAK_OP;\n\tunsigned int total_len;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buf_type;\n\n\tcifs_dbg(FYI, \"SMB2_oplock_break\\n\");\n\trc = smb2_plain_req_init(SMB2_OPLOCK_BREAK, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->VolatileFid = volatile_fid;\n\treq->PersistentFid = persistent_fid;\n\treq->OplockLevel = oplock_level;\n\treq->sync_hdr.CreditRequest = cpu_to_le16(1);\n\n\tflags |= CIFS_NO_RSP_BUF;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buf_type, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\n\t\tcifs_dbg(FYI, \"Send error in Oplock Break = %d\\n\", rc);\n\t}\n\n\treturn rc;\n}\n\nvoid\nsmb2_copy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\n\t\t\t     struct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\n\t\t\t  le32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\n\tkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\n\tkst->f_bfree  = kst->f_bavail =\n\t\t\tle64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\n\treturn;\n}\n\nstatic void\ncopy_posix_fs_info_to_kstatfs(FILE_SYSTEM_POSIX_INFO *response_data,\n\t\t\tstruct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(response_data->BlockSize);\n\tkst->f_blocks = le64_to_cpu(response_data->TotalBlocks);\n\tkst->f_bfree =  le64_to_cpu(response_data->BlocksAvail);\n\tif (response_data->UserBlocksAvail == cpu_to_le64(-1))\n\t\tkst->f_bavail = kst->f_bfree;\n\telse\n\t\tkst->f_bavail = le64_to_cpu(response_data->UserBlocksAvail);\n\tif (response_data->TotalFileNodes != cpu_to_le64(-1))\n\t\tkst->f_files = le64_to_cpu(response_data->TotalFileNodes);\n\tif (response_data->FreeFileNodes != cpu_to_le64(-1))\n\t\tkst->f_ffree = le64_to_cpu(response_data->FreeFileNodes);\n\n\treturn;\n}\n\nstatic int\nbuild_qfs_info_req(struct kvec *iov, struct cifs_tcon *tcon,\n\t\t   struct TCP_Server_Info *server,\n\t\t   int level, int outbuf_len, u64 persistent_fid,\n\t\t   u64 volatile_fid)\n{\n\tint rc;\n\tstruct smb2_query_info_req *req;\n\tunsigned int total_len;\n\n\tcifs_dbg(FYI, \"Query FSInfo level %d\\n\", level);\n\n\tif ((tcon->ses == NULL) || server == NULL)\n\t\treturn -EIO;\n\n\trc = smb2_plain_req_init(SMB2_QUERY_INFO, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->InfoType = SMB2_O_INFO_FILESYSTEM;\n\treq->FileInfoClass = level;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t/* 1 for pad */\n\treq->InputBufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_query_info_req) - 1);\n\treq->OutputBufferLength = cpu_to_le32(\n\t\toutbuf_len + sizeof(struct smb2_query_info_rsp) - 1);\n\n\tiov->iov_base = (char *)req;\n\tiov->iov_len = total_len;\n\treturn 0;\n}\n\nint\nSMB311_posix_qfs_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, struct kstatfs *fsdata)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tFILE_SYSTEM_POSIX_INFO *info = NULL;\n\tint flags = 0;\n\n\trc = build_qfs_info_req(&iov, tcon, server,\n\t\t\t\tFS_POSIX_INFORMATION,\n\t\t\t\tsizeof(FILE_SYSTEM_POSIX_INFO),\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = &iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(iov.iov_base);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto posix_qfsinf_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\n\tinfo = (FILE_SYSTEM_POSIX_INFO *)(\n\t\tle16_to_cpu(rsp->OutputBufferOffset) + (char *)rsp);\n\trc = smb2_validate_iov(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t       le32_to_cpu(rsp->OutputBufferLength), &rsp_iov,\n\t\t\t       sizeof(FILE_SYSTEM_POSIX_INFO));\n\tif (!rc)\n\t\tcopy_posix_fs_info_to_kstatfs(info, fsdata);\n\nposix_qfsinf_exit:\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}\n\nint\nSMB2_QFS_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, struct kstatfs *fsdata)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tstruct smb2_fs_full_size_info *info = NULL;\n\tint flags = 0;\n\n\trc = build_qfs_info_req(&iov, tcon, server,\n\t\t\t\tFS_FULL_SIZE_INFORMATION,\n\t\t\t\tsizeof(struct smb2_fs_full_size_info),\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = &iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(iov.iov_base);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qfsinf_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\n\tinfo = (struct smb2_fs_full_size_info *)(\n\t\tle16_to_cpu(rsp->OutputBufferOffset) + (char *)rsp);\n\trc = smb2_validate_iov(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t       le32_to_cpu(rsp->OutputBufferLength), &rsp_iov,\n\t\t\t       sizeof(struct smb2_fs_full_size_info));\n\tif (!rc)\n\t\tsmb2_copy_fs_info_to_kstatfs(info, fsdata);\n\nqfsinf_exit:\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}\n\nint\nSMB2_QFS_attr(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, int level)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype, max_len, min_len;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tunsigned int rsp_len, offset;\n\tint flags = 0;\n\n\tif (level == FS_DEVICE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t\tmin_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t} else if (level == FS_ATTRIBUTE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_ATTRIBUTE_INFO);\n\t\tmin_len = MIN_FS_ATTR_INFO_SIZE;\n\t} else if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tmax_len = sizeof(struct smb3_fs_ss_info);\n\t\tmin_len = sizeof(struct smb3_fs_ss_info);\n\t} else if (level == FS_VOLUME_INFORMATION) {\n\t\tmax_len = sizeof(struct smb3_fs_vol_info) + MAX_VOL_LABEL_LEN;\n\t\tmin_len = sizeof(struct smb3_fs_vol_info);\n\t} else {\n\t\tcifs_dbg(FYI, \"Invalid qfsinfo level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\trc = build_qfs_info_req(&iov, tcon, server,\n\t\t\t\tlevel, max_len,\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = &iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(iov.iov_base);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qfsattr_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\n\trsp_len = le32_to_cpu(rsp->OutputBufferLength);\n\toffset = le16_to_cpu(rsp->OutputBufferOffset);\n\trc = smb2_validate_iov(offset, rsp_len, &rsp_iov, min_len);\n\tif (rc)\n\t\tgoto qfsattr_exit;\n\n\tif (level == FS_ATTRIBUTE_INFORMATION)\n\t\tmemcpy(&tcon->fsAttrInfo, offset\n\t\t\t+ (char *)rsp, min_t(unsigned int,\n\t\t\trsp_len, max_len));\n\telse if (level == FS_DEVICE_INFORMATION)\n\t\tmemcpy(&tcon->fsDevInfo, offset\n\t\t\t+ (char *)rsp, sizeof(FILE_SYSTEM_DEVICE_INFO));\n\telse if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tstruct smb3_fs_ss_info *ss_info = (struct smb3_fs_ss_info *)\n\t\t\t(offset + (char *)rsp);\n\t\ttcon->ss_flags = le32_to_cpu(ss_info->Flags);\n\t\ttcon->perf_sector_size =\n\t\t\tle32_to_cpu(ss_info->PhysicalBytesPerSectorForPerf);\n\t} else if (level == FS_VOLUME_INFORMATION) {\n\t\tstruct smb3_fs_vol_info *vol_info = (struct smb3_fs_vol_info *)\n\t\t\t(offset + (char *)rsp);\n\t\ttcon->vol_serial_number = vol_info->VolumeSerialNumber;\n\t\ttcon->vol_create_time = vol_info->VolumeCreationTime;\n\t}\n\nqfsattr_exit:\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}\n\nint\nsmb2_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t   const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t   const __u32 num_lock, struct smb2_lock_element *buf)\n{\n\tstruct smb_rqst rqst;\n\tint rc = 0;\n\tstruct smb2_lock_req *req = NULL;\n\tstruct kvec iov[2];\n\tstruct kvec rsp_iov;\n\tint resp_buf_type;\n\tunsigned int count;\n\tint flags = CIFS_NO_RSP_BUF;\n\tunsigned int total_len;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(tcon->ses);\n\n\tcifs_dbg(FYI, \"smb2_lockv num lock %d\\n\", num_lock);\n\n\trc = smb2_plain_req_init(SMB2_LOCK, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->sync_hdr.ProcessId = cpu_to_le32(pid);\n\treq->LockCount = cpu_to_le16(num_lock);\n\n\treq->PersistentFileId = persist_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tcount = num_lock * sizeof(struct smb2_lock_element);\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len - sizeof(struct smb2_lock_element);\n\tiov[1].iov_base = (char *)buf;\n\tiov[1].iov_len = count;\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 2;\n\n\trc = cifs_send_recv(xid, tcon->ses, server,\n\t\t\t    &rqst, &resp_buf_type, flags,\n\t\t\t    &rsp_iov);\n\tcifs_small_buf_release(req);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in smb2_lockv = %d\\n\", rc);\n\t\tcifs_stats_fail_inc(tcon, SMB2_LOCK_HE);\n\t\ttrace_smb3_lock_err(xid, persist_fid, tcon->tid,\n\t\t\t\t    tcon->ses->Suid, rc);\n\t}\n\n\treturn rc;\n}\n\nint\nSMB2_lock(const unsigned int xid, struct cifs_tcon *tcon,\n\t  const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t  const __u64 length, const __u64 offset, const __u32 lock_flags,\n\t  const bool wait)\n{\n\tstruct smb2_lock_element lock;\n\n\tlock.Offset = cpu_to_le64(offset);\n\tlock.Length = cpu_to_le64(length);\n\tlock.Flags = cpu_to_le32(lock_flags);\n\tif (!wait && lock_flags != SMB2_LOCKFLAG_UNLOCK)\n\t\tlock.Flags |= cpu_to_le32(SMB2_LOCKFLAG_FAIL_IMMEDIATELY);\n\n\treturn smb2_lockv(xid, tcon, persist_fid, volatile_fid, pid, 1, &lock);\n}\n\nint\nSMB2_lease_break(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t __u8 *lease_key, const __le32 lease_state)\n{\n\tstruct smb_rqst rqst;\n\tint rc;\n\tstruct smb2_lease_ack *req = NULL;\n\tstruct cifs_ses *ses = tcon->ses;\n\tint flags = CIFS_OBREAK_OP;\n\tunsigned int total_len;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buf_type;\n\t__u64 *please_key_high;\n\t__u64 *please_key_low;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(tcon->ses);\n\n\tcifs_dbg(FYI, \"SMB2_lease_break\\n\");\n\trc = smb2_plain_req_init(SMB2_OPLOCK_BREAK, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->sync_hdr.CreditRequest = cpu_to_le16(1);\n\treq->StructureSize = cpu_to_le16(36);\n\ttotal_len += 12;\n\n\tmemcpy(req->LeaseKey, lease_key, 16);\n\treq->LeaseState = lease_state;\n\n\tflags |= CIFS_NO_RSP_BUF;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buf_type, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\n\tplease_key_low = (__u64 *)lease_key;\n\tplease_key_high = (__u64 *)(lease_key+8);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\n\t\ttrace_smb3_lease_err(le32_to_cpu(lease_state), tcon->tid,\n\t\t\tses->Suid, *please_key_low, *please_key_high, rc);\n\t\tcifs_dbg(FYI, \"Send error in Lease Break = %d\\n\", rc);\n\t} else\n\t\ttrace_smb3_lease_done(le32_to_cpu(lease_state), tcon->tid,\n\t\t\tses->Suid, *please_key_low, *please_key_high);\n\n\treturn rc;\n}\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 1774}, "message": "warn: variable dereferenced before check 'tcon' (see line 1726)"}], "macros": [], "notes": [], "path": "/src/fs/cifs/smb2pdu.c", "reportHash": "10f82e6273f18d513b9511238799955b", "checkerName": "smatch.check_deref_check", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4652}, "message": "error: memcpy() 'bufptr' too small (1 vs 2)"}], "macros": [], "notes": [], "path": "/src/fs/cifs/smb2pdu.c", "reportHash": "0108042a51768275b90df985530a9fbf", "checkerName": "smatch.check_memcpy_overflow", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
