<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/kernel/bpf/verifier.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/* Copyright (c) 2011-2014 PLUMgrid, http://plumgrid.com\n * Copyright (c) 2016 Facebook\n * Copyright (c) 2018 Covalent IO, Inc. http://covalent.io\n */\n#include <uapi/linux/btf.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/bpf.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/filter.h>\n#include <net/netlink.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/stringify.h>\n#include <linux/bsearch.h>\n#include <linux/sort.h>\n#include <linux/perf_event.h>\n#include <linux/ctype.h>\n#include <linux/error-injection.h>\n#include <linux/bpf_lsm.h>\n#include <linux/btf_ids.h>\n\n#include \"disasm.h\"\n\nstatic const struct bpf_verifier_ops * const bpf_verifier_ops[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\t[_id] = & _name ## _verifier_ops,\n#define BPF_MAP_TYPE(_id, _ops)\n#define BPF_LINK_TYPE(_id, _name)\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_MAP_TYPE\n#undef BPF_LINK_TYPE\n};\n\n/* bpf_check() is a static code analyzer that walks eBPF program\n * instruction by instruction and updates register/stack state.\n * All paths of conditional branches are analyzed until 'bpf_exit' insn.\n *\n * The first pass is depth-first-search to check that the program is a DAG.\n * It rejects the following programs:\n * - larger than BPF_MAXINSNS insns\n * - if loop is present (detected via back-edge)\n * - unreachable insns exist (shouldn't be a forest. program = one function)\n * - out of bounds or malformed jumps\n * The second pass is all possible path descent from the 1st insn.\n * Since it's analyzing all pathes through the program, the length of the\n * analysis is limited to 64k insn, which may be hit even if total number of\n * insn is less then 4K, but there are too many branches that change stack/regs.\n * Number of 'branches to be analyzed' is limited to 1k\n *\n * On entry to each instruction, each register has a type, and the instruction\n * changes the types of the registers depending on instruction semantics.\n * If instruction is BPF_MOV64_REG(BPF_REG_1, BPF_REG_5), then type of R5 is\n * copied to R1.\n *\n * All registers are 64-bit.\n * R0 - return register\n * R1-R5 argument passing registers\n * R6-R9 callee saved registers\n * R10 - frame pointer read-only\n *\n * At the start of BPF program the register R1 contains a pointer to bpf_context\n * and has type PTR_TO_CTX.\n *\n * Verifier tracks arithmetic operations on pointers in case:\n *    BPF_MOV64_REG(BPF_REG_1, BPF_REG_10),\n *    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, -20),\n * 1st insn copies R10 (which has FRAME_PTR) type into R1\n * and 2nd arithmetic instruction is pattern matched to recognize\n * that it wants to construct a pointer to some element within stack.\n * So after 2nd insn, the register R1 has type PTR_TO_STACK\n * (and -20 constant is saved for further stack bounds checking).\n * Meaning that this reg is a pointer to stack plus known immediate constant.\n *\n * Most of the time the registers have SCALAR_VALUE type, which\n * means the register has some value, but it's not a valid pointer.\n * (like pointer plus pointer becomes SCALAR_VALUE type)\n *\n * When verifier sees load or store instructions the type of base register\n * can be: PTR_TO_MAP_VALUE, PTR_TO_CTX, PTR_TO_STACK, PTR_TO_SOCKET. These are\n * four pointer types recognized by check_mem_access() function.\n *\n * PTR_TO_MAP_VALUE means that this register is pointing to 'map element value'\n * and the range of [ptr, ptr + map's value_size) is accessible.\n *\n * registers used to pass values to function calls are checked against\n * function argument constraints.\n *\n * ARG_PTR_TO_MAP_KEY is one of such argument constraints.\n * It means that the register type passed to this function must be\n * PTR_TO_STACK and it will be used inside the function as\n * 'pointer to map element key'\n *\n * For example the argument constraints for bpf_map_lookup_elem():\n *   .ret_type = RET_PTR_TO_MAP_VALUE_OR_NULL,\n *   .arg1_type = ARG_CONST_MAP_PTR,\n *   .arg2_type = ARG_PTR_TO_MAP_KEY,\n *\n * ret_type says that this function returns 'pointer to map elem value or null'\n * function expects 1st argument to be a const pointer to 'struct bpf_map' and\n * 2nd argument should be a pointer to stack, which will be used inside\n * the helper function as a pointer to map element key.\n *\n * On the kernel side the helper function looks like:\n * u64 bpf_map_lookup_elem(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)\n * {\n *    struct bpf_map *map = (struct bpf_map *) (unsigned long) r1;\n *    void *key = (void *) (unsigned long) r2;\n *    void *value;\n *\n *    here kernel can access 'key' and 'map' pointers safely, knowing that\n *    [key, key + map->key_size) bytes are valid and were initialized on\n *    the stack of eBPF program.\n * }\n *\n * Corresponding eBPF program may look like:\n *    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),  // after this insn R2 type is FRAME_PTR\n *    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), // after this insn R2 type is PTR_TO_STACK\n *    BPF_LD_MAP_FD(BPF_REG_1, map_fd),      // after this insn R1 type is CONST_PTR_TO_MAP\n *    BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n * here verifier looks at prototype of map_lookup_elem() and sees:\n * .arg1_type == ARG_CONST_MAP_PTR and R1->type == CONST_PTR_TO_MAP, which is ok,\n * Now verifier knows that this map has key of R1->map_ptr->key_size bytes\n *\n * Then .arg2_type == ARG_PTR_TO_MAP_KEY and R2->type == PTR_TO_STACK, ok so far,\n * Now verifier checks that [R2, R2 + map's key_size) are within stack limits\n * and were initialized prior to this call.\n * If it's ok, then verifier allows this BPF_CALL insn and looks at\n * .ret_type which is RET_PTR_TO_MAP_VALUE_OR_NULL, so it sets\n * R0->type = PTR_TO_MAP_VALUE_OR_NULL which means bpf_map_lookup_elem() function\n * returns ether pointer to map value or NULL.\n *\n * When type PTR_TO_MAP_VALUE_OR_NULL passes through 'if (reg != 0) goto +off'\n * insn, the register holding that pointer in the true branch changes state to\n * PTR_TO_MAP_VALUE and the same register changes state to CONST_IMM in the false\n * branch. See check_cond_jmp_op().\n *\n * After the call R0 is set to return type of the function and registers R1-R5\n * are set to NOT_INIT to indicate that they are no longer readable.\n *\n * The following reference types represent a potential reference to a kernel\n * resource which, after first being allocated, must be checked and freed by\n * the BPF program:\n * - PTR_TO_SOCKET_OR_NULL, PTR_TO_SOCKET\n *\n * When the verifier sees a helper call return a reference type, it allocates a\n * pointer id for the reference and stores it in the current function state.\n * Similar to the way that PTR_TO_MAP_VALUE_OR_NULL is converted into\n * PTR_TO_MAP_VALUE, PTR_TO_SOCKET_OR_NULL becomes PTR_TO_SOCKET when the type\n * passes through a NULL-check conditional. For the branch wherein the state is\n * changed to CONST_IMM, the verifier releases the reference.\n *\n * For each helper function that allocates a reference, such as\n * bpf_sk_lookup_tcp(), there is a corresponding release function, such as\n * bpf_sk_release(). When a reference type passes into the release function,\n * the verifier also releases the reference. If any unchecked or unreleased\n * reference remains at the end of the program, the verifier rejects it.\n */\n\n/* verifier_state + insn_idx are pushed to stack when branch is encountered */\nstruct bpf_verifier_stack_elem {\n\t/* verifer state is 'st'\n\t * before processing instruction 'insn_idx'\n\t * and after processing instruction 'prev_insn_idx'\n\t */\n\tstruct bpf_verifier_state st;\n\tint insn_idx;\n\tint prev_insn_idx;\n\tstruct bpf_verifier_stack_elem *next;\n\t/* length of verifier log at the time this state was pushed on stack */\n\tu32 log_pos;\n};\n\n#define BPF_COMPLEXITY_LIMIT_JMP_SEQ\t8192\n#define BPF_COMPLEXITY_LIMIT_STATES\t64\n\n#define BPF_MAP_KEY_POISON\t(1ULL << 63)\n#define BPF_MAP_KEY_SEEN\t(1ULL << 62)\n\n#define BPF_MAP_PTR_UNPRIV\t1UL\n#define BPF_MAP_PTR_POISON\t((void *)((0xeB9FUL << 1) +\t\\\n\t\t\t\t\t  POISON_POINTER_DELTA))\n#define BPF_MAP_PTR(X)\t\t((struct bpf_map *)((X) & ~BPF_MAP_PTR_UNPRIV))\n\nstatic bool bpf_map_ptr_poisoned(const struct bpf_insn_aux_data *aux)\n{\n\treturn BPF_MAP_PTR(aux->map_ptr_state) == BPF_MAP_PTR_POISON;\n}\n\nstatic bool bpf_map_ptr_unpriv(const struct bpf_insn_aux_data *aux)\n{\n\treturn aux->map_ptr_state & BPF_MAP_PTR_UNPRIV;\n}\n\nstatic void bpf_map_ptr_store(struct bpf_insn_aux_data *aux,\n\t\t\t      const struct bpf_map *map, bool unpriv)\n{\n\tBUILD_BUG_ON((unsigned long)BPF_MAP_PTR_POISON & BPF_MAP_PTR_UNPRIV);\n\tunpriv |= bpf_map_ptr_unpriv(aux);\n\taux->map_ptr_state = (unsigned long)map |\n\t\t\t     (unpriv ? BPF_MAP_PTR_UNPRIV : 0UL);\n}\n\nstatic bool bpf_map_key_poisoned(const struct bpf_insn_aux_data *aux)\n{\n\treturn aux->map_key_state & BPF_MAP_KEY_POISON;\n}\n\nstatic bool bpf_map_key_unseen(const struct bpf_insn_aux_data *aux)\n{\n\treturn !(aux->map_key_state & BPF_MAP_KEY_SEEN);\n}\n\nstatic u64 bpf_map_key_immediate(const struct bpf_insn_aux_data *aux)\n{\n\treturn aux->map_key_state & ~(BPF_MAP_KEY_SEEN | BPF_MAP_KEY_POISON);\n}\n\nstatic void bpf_map_key_store(struct bpf_insn_aux_data *aux, u64 state)\n{\n\tbool poisoned = bpf_map_key_poisoned(aux);\n\n\taux->map_key_state = state | BPF_MAP_KEY_SEEN |\n\t\t\t     (poisoned ? BPF_MAP_KEY_POISON : 0ULL);\n}\n\nstatic bool bpf_pseudo_call(const struct bpf_insn *insn)\n{\n\treturn insn->code == (BPF_JMP | BPF_CALL) &&\n\t       insn->src_reg == BPF_PSEUDO_CALL;\n}\n\nstatic bool bpf_pseudo_func(const struct bpf_insn *insn)\n{\n\treturn insn->code == (BPF_LD | BPF_IMM | BPF_DW) &&\n\t       insn->src_reg == BPF_PSEUDO_FUNC;\n}\n\nstruct bpf_call_arg_meta {\n\tstruct bpf_map *map_ptr;\n\tbool raw_mode;\n\tbool pkt_access;\n\tint regno;\n\tint access_size;\n\tint mem_size;\n\tu64 msize_max_value;\n\tint ref_obj_id;\n\tint func_id;\n\tstruct btf *btf;\n\tu32 btf_id;\n\tstruct btf *ret_btf;\n\tu32 ret_btf_id;\n\tu32 subprogno;\n};\n\nstruct btf *btf_vmlinux;\n\nstatic DEFINE_MUTEX(bpf_verifier_lock);\n\nstatic const struct bpf_line_info *\nfind_linfo(const struct bpf_verifier_env *env, u32 insn_off)\n{\n\tconst struct bpf_line_info *linfo;\n\tconst struct bpf_prog *prog;\n\tu32 i, nr_linfo;\n\n\tprog = env->prog;\n\tnr_linfo = prog->aux->nr_linfo;\n\n\tif (!nr_linfo || insn_off >= prog->len)\n\t\treturn NULL;\n\n\tlinfo = prog->aux->linfo;\n\tfor (i = 1; i < nr_linfo; i++)\n\t\tif (insn_off < linfo[i].insn_off)\n\t\t\tbreak;\n\n\treturn &linfo[i - 1];\n}\n\nvoid bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tunsigned int n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tWARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,\n\t\t  \"verifier log line truncated - local buffer too short\\n\");\n\n\tn = min(log->len_total - log->len_used - 1, n);\n\tlog->kbuf[n] = '\\0';\n\n\tif (log->level == BPF_LOG_KERNEL) {\n\t\tpr_err(\"BPF:%s\\n\", log->kbuf);\n\t\treturn;\n\t}\n\tif (!copy_to_user(log->ubuf + log->len_used, log->kbuf, n + 1))\n\t\tlog->len_used += n;\n\telse\n\t\tlog->ubuf = NULL;\n}\n\nstatic void bpf_vlog_reset(struct bpf_verifier_log *log, u32 new_pos)\n{\n\tchar zero = 0;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tlog->len_used = new_pos;\n\tif (put_user(zero, log->ubuf + new_pos))\n\t\tlog->ubuf = NULL;\n}\n\n/* log_level controls verbosity level of eBPF verifier.\n * bpf_verifier_log_write() is used to dump the verification trace to the log,\n * so the user can figure out what's wrong with the program\n */\n__printf(2, 3) void bpf_verifier_log_write(struct bpf_verifier_env *env,\n\t\t\t\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(&env->log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(&env->log, fmt, args);\n\tva_end(args);\n}\nEXPORT_SYMBOL_GPL(bpf_verifier_log_write);\n\n__printf(2, 3) static void verbose(void *private_data, const char *fmt, ...)\n{\n\tstruct bpf_verifier_env *env = private_data;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(&env->log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(&env->log, fmt, args);\n\tva_end(args);\n}\n\n__printf(2, 3) void bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}\n\nstatic const char *ltrim(const char *s)\n{\n\twhile (isspace(*s))\n\t\ts++;\n\n\treturn s;\n}\n\n__printf(3, 4) static void verbose_linfo(struct bpf_verifier_env *env,\n\t\t\t\t\t u32 insn_off,\n\t\t\t\t\t const char *prefix_fmt, ...)\n{\n\tconst struct bpf_line_info *linfo;\n\n\tif (!bpf_verifier_log_needed(&env->log))\n\t\treturn;\n\n\tlinfo = find_linfo(env, insn_off);\n\tif (!linfo || linfo == env->prev_linfo)\n\t\treturn;\n\n\tif (prefix_fmt) {\n\t\tva_list args;\n\n\t\tva_start(args, prefix_fmt);\n\t\tbpf_verifier_vlog(&env->log, prefix_fmt, args);\n\t\tva_end(args);\n\t}\n\n\tverbose(env, \"%s\\n\",\n\t\tltrim(btf_name_by_offset(env->prog->aux->btf,\n\t\t\t\t\t linfo->line_off)));\n\n\tenv->prev_linfo = linfo;\n}\n\nstatic void verbose_invalid_scalar(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_reg_state *reg,\n\t\t\t\t   struct tnum *range, const char *ctx,\n\t\t\t\t   const char *reg_name)\n{\n\tchar tn_buf[48];\n\n\tverbose(env, \"At %s the register %s \", ctx, reg_name);\n\tif (!tnum_is_unknown(reg->var_off)) {\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\tverbose(env, \"has value %s\", tn_buf);\n\t} else {\n\t\tverbose(env, \"has unknown scalar value\");\n\t}\n\ttnum_strn(tn_buf, sizeof(tn_buf), *range);\n\tverbose(env, \" should have been in %s\\n\", tn_buf);\n}\n\nstatic bool type_is_pkt_pointer(enum bpf_reg_type type)\n{\n\treturn type == PTR_TO_PACKET ||\n\t       type == PTR_TO_PACKET_META;\n}\n\nstatic bool type_is_sk_pointer(enum bpf_reg_type type)\n{\n\treturn type == PTR_TO_SOCKET ||\n\t\ttype == PTR_TO_SOCK_COMMON ||\n\t\ttype == PTR_TO_TCP_SOCK ||\n\t\ttype == PTR_TO_XDP_SOCK;\n}\n\nstatic bool reg_type_not_null(enum bpf_reg_type type)\n{\n\treturn type == PTR_TO_SOCKET ||\n\t\ttype == PTR_TO_TCP_SOCK ||\n\t\ttype == PTR_TO_MAP_VALUE ||\n\t\ttype == PTR_TO_MAP_KEY ||\n\t\ttype == PTR_TO_SOCK_COMMON;\n}\n\nstatic bool reg_type_may_be_null(enum bpf_reg_type type)\n{\n\treturn type == PTR_TO_MAP_VALUE_OR_NULL ||\n\t       type == PTR_TO_SOCKET_OR_NULL ||\n\t       type == PTR_TO_SOCK_COMMON_OR_NULL ||\n\t       type == PTR_TO_TCP_SOCK_OR_NULL ||\n\t       type == PTR_TO_BTF_ID_OR_NULL ||\n\t       type == PTR_TO_MEM_OR_NULL ||\n\t       type == PTR_TO_RDONLY_BUF_OR_NULL ||\n\t       type == PTR_TO_RDWR_BUF_OR_NULL;\n}\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}\n\nstatic bool reg_type_may_be_refcounted_or_null(enum bpf_reg_type type)\n{\n\treturn type == PTR_TO_SOCKET ||\n\t\ttype == PTR_TO_SOCKET_OR_NULL ||\n\t\ttype == PTR_TO_TCP_SOCK ||\n\t\ttype == PTR_TO_TCP_SOCK_OR_NULL ||\n\t\ttype == PTR_TO_MEM ||\n\t\ttype == PTR_TO_MEM_OR_NULL;\n}\n\nstatic bool arg_type_may_be_refcounted(enum bpf_arg_type type)\n{\n\treturn type == ARG_PTR_TO_SOCK_COMMON;\n}\n\nstatic bool arg_type_may_be_null(enum bpf_arg_type type)\n{\n\treturn type == ARG_PTR_TO_MAP_VALUE_OR_NULL ||\n\t       type == ARG_PTR_TO_MEM_OR_NULL ||\n\t       type == ARG_PTR_TO_CTX_OR_NULL ||\n\t       type == ARG_PTR_TO_SOCKET_OR_NULL ||\n\t       type == ARG_PTR_TO_ALLOC_MEM_OR_NULL ||\n\t       type == ARG_PTR_TO_STACK_OR_NULL;\n}\n\n/* Determine whether the function releases some resources allocated by another\n * function call. The first reference type argument will be assumed to be\n * released by release_reference().\n */\nstatic bool is_release_function(enum bpf_func_id func_id)\n{\n\treturn func_id == BPF_FUNC_sk_release ||\n\t       func_id == BPF_FUNC_ringbuf_submit ||\n\t       func_id == BPF_FUNC_ringbuf_discard;\n}\n\nstatic bool may_be_acquire_function(enum bpf_func_id func_id)\n{\n\treturn func_id == BPF_FUNC_sk_lookup_tcp ||\n\t\tfunc_id == BPF_FUNC_sk_lookup_udp ||\n\t\tfunc_id == BPF_FUNC_skc_lookup_tcp ||\n\t\tfunc_id == BPF_FUNC_map_lookup_elem ||\n\t        func_id == BPF_FUNC_ringbuf_reserve;\n}\n\nstatic bool is_acquire_function(enum bpf_func_id func_id,\n\t\t\t\tconst struct bpf_map *map)\n{\n\tenum bpf_map_type map_type = map ? map->map_type : BPF_MAP_TYPE_UNSPEC;\n\n\tif (func_id == BPF_FUNC_sk_lookup_tcp ||\n\t    func_id == BPF_FUNC_sk_lookup_udp ||\n\t    func_id == BPF_FUNC_skc_lookup_tcp ||\n\t    func_id == BPF_FUNC_ringbuf_reserve)\n\t\treturn true;\n\n\tif (func_id == BPF_FUNC_map_lookup_elem &&\n\t    (map_type == BPF_MAP_TYPE_SOCKMAP ||\n\t     map_type == BPF_MAP_TYPE_SOCKHASH))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool is_ptr_cast_function(enum bpf_func_id func_id)\n{\n\treturn func_id == BPF_FUNC_tcp_sock ||\n\t\tfunc_id == BPF_FUNC_sk_fullsock ||\n\t\tfunc_id == BPF_FUNC_skc_to_tcp_sock ||\n\t\tfunc_id == BPF_FUNC_skc_to_tcp6_sock ||\n\t\tfunc_id == BPF_FUNC_skc_to_udp6_sock ||\n\t\tfunc_id == BPF_FUNC_skc_to_tcp_timewait_sock ||\n\t\tfunc_id == BPF_FUNC_skc_to_tcp_request_sock;\n}\n\nstatic bool is_cmpxchg_insn(const struct bpf_insn *insn)\n{\n\treturn BPF_CLASS(insn->code) == BPF_STX &&\n\t       BPF_MODE(insn->code) == BPF_ATOMIC &&\n\t       insn->imm == BPF_CMPXCHG;\n}\n\n/* string representation of 'enum bpf_reg_type' */\nstatic const char * const reg_type_str[] = {\n\t[NOT_INIT]\t\t= \"?\",\n\t[SCALAR_VALUE]\t\t= \"inv\",\n\t[PTR_TO_CTX]\t\t= \"ctx\",\n\t[CONST_PTR_TO_MAP]\t= \"map_ptr\",\n\t[PTR_TO_MAP_VALUE]\t= \"map_value\",\n\t[PTR_TO_MAP_VALUE_OR_NULL] = \"map_value_or_null\",\n\t[PTR_TO_STACK]\t\t= \"fp\",\n\t[PTR_TO_PACKET]\t\t= \"pkt\",\n\t[PTR_TO_PACKET_META]\t= \"pkt_meta\",\n\t[PTR_TO_PACKET_END]\t= \"pkt_end\",\n\t[PTR_TO_FLOW_KEYS]\t= \"flow_keys\",\n\t[PTR_TO_SOCKET]\t\t= \"sock\",\n\t[PTR_TO_SOCKET_OR_NULL] = \"sock_or_null\",\n\t[PTR_TO_SOCK_COMMON]\t= \"sock_common\",\n\t[PTR_TO_SOCK_COMMON_OR_NULL] = \"sock_common_or_null\",\n\t[PTR_TO_TCP_SOCK]\t= \"tcp_sock\",\n\t[PTR_TO_TCP_SOCK_OR_NULL] = \"tcp_sock_or_null\",\n\t[PTR_TO_TP_BUFFER]\t= \"tp_buffer\",\n\t[PTR_TO_XDP_SOCK]\t= \"xdp_sock\",\n\t[PTR_TO_BTF_ID]\t\t= \"ptr_\",\n\t[PTR_TO_BTF_ID_OR_NULL]\t= \"ptr_or_null_\",\n\t[PTR_TO_PERCPU_BTF_ID]\t= \"percpu_ptr_\",\n\t[PTR_TO_MEM]\t\t= \"mem\",\n\t[PTR_TO_MEM_OR_NULL]\t= \"mem_or_null\",\n\t[PTR_TO_RDONLY_BUF]\t= \"rdonly_buf\",\n\t[PTR_TO_RDONLY_BUF_OR_NULL] = \"rdonly_buf_or_null\",\n\t[PTR_TO_RDWR_BUF]\t= \"rdwr_buf\",\n\t[PTR_TO_RDWR_BUF_OR_NULL] = \"rdwr_buf_or_null\",\n\t[PTR_TO_FUNC]\t\t= \"func\",\n\t[PTR_TO_MAP_KEY]\t= \"map_key\",\n};\n\nstatic char slot_type_char[] = {\n\t[STACK_INVALID]\t= '?',\n\t[STACK_SPILL]\t= 'r',\n\t[STACK_MISC]\t= 'm',\n\t[STACK_ZERO]\t= '0',\n};\n\nstatic void print_liveness(struct bpf_verifier_env *env,\n\t\t\t   enum bpf_reg_liveness live)\n{\n\tif (live & (REG_LIVE_READ | REG_LIVE_WRITTEN | REG_LIVE_DONE))\n\t    verbose(env, \"_\");\n\tif (live & REG_LIVE_READ)\n\t\tverbose(env, \"r\");\n\tif (live & REG_LIVE_WRITTEN)\n\t\tverbose(env, \"w\");\n\tif (live & REG_LIVE_DONE)\n\t\tverbose(env, \"D\");\n}\n\nstatic struct bpf_func_state *func(struct bpf_verifier_env *env,\n\t\t\t\t   const struct bpf_reg_state *reg)\n{\n\tstruct bpf_verifier_state *cur = env->cur_state;\n\n\treturn cur->frame[reg->frameno];\n}\n\nstatic const char *kernel_type_name(const struct btf* btf, u32 id)\n{\n\treturn btf_name_by_offset(btf, btf_type_by_id(btf, id)->name_off);\n}\n\nstatic void print_verifier_state(struct bpf_verifier_env *env,\n\t\t\t\t const struct bpf_func_state *state)\n{\n\tconst struct bpf_reg_state *reg;\n\tenum bpf_reg_type t;\n\tint i;\n\n\tif (state->frameno)\n\t\tverbose(env, \" frame%d:\", state->frameno);\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\treg = &state->regs[i];\n\t\tt = reg->type;\n\t\tif (t == NOT_INIT)\n\t\t\tcontinue;\n\t\tverbose(env, \" R%d\", i);\n\t\tprint_liveness(env, reg->live);\n\t\tverbose(env, \"=%s\", reg_type_str[t]);\n\t\tif (t == SCALAR_VALUE && reg->precise)\n\t\t\tverbose(env, \"P\");\n\t\tif ((t == SCALAR_VALUE || t == PTR_TO_STACK) &&\n\t\t    tnum_is_const(reg->var_off)) {\n\t\t\t/* reg->off should be 0 for SCALAR_VALUE */\n\t\t\tverbose(env, \"%lld\", reg->var_off.value + reg->off);\n\t\t} else {\n\t\t\tif (t == PTR_TO_BTF_ID ||\n\t\t\t    t == PTR_TO_BTF_ID_OR_NULL ||\n\t\t\t    t == PTR_TO_PERCPU_BTF_ID)\n\t\t\t\tverbose(env, \"%s\", kernel_type_name(reg->btf, reg->btf_id));\n\t\t\tverbose(env, \"(id=%d\", reg->id);\n\t\t\tif (reg_type_may_be_refcounted_or_null(t))\n\t\t\t\tverbose(env, \",ref_obj_id=%d\", reg->ref_obj_id);\n\t\t\tif (t != SCALAR_VALUE)\n\t\t\t\tverbose(env, \",off=%d\", reg->off);\n\t\t\tif (type_is_pkt_pointer(t))\n\t\t\t\tverbose(env, \",r=%d\", reg->range);\n\t\t\telse if (t == CONST_PTR_TO_MAP ||\n\t\t\t\t t == PTR_TO_MAP_KEY ||\n\t\t\t\t t == PTR_TO_MAP_VALUE ||\n\t\t\t\t t == PTR_TO_MAP_VALUE_OR_NULL)\n\t\t\t\tverbose(env, \",ks=%d,vs=%d\",\n\t\t\t\t\treg->map_ptr->key_size,\n\t\t\t\t\treg->map_ptr->value_size);\n\t\t\tif (tnum_is_const(reg->var_off)) {\n\t\t\t\t/* Typically an immediate SCALAR_VALUE, but\n\t\t\t\t * could be a pointer whose offset is too big\n\t\t\t\t * for reg->off\n\t\t\t\t */\n\t\t\t\tverbose(env, \",imm=%llx\", reg->var_off.value);\n\t\t\t} else {\n\t\t\t\tif (reg->smin_value != reg->umin_value &&\n\t\t\t\t    reg->smin_value != S64_MIN)\n\t\t\t\t\tverbose(env, \",smin_value=%lld\",\n\t\t\t\t\t\t(long long)reg->smin_value);\n\t\t\t\tif (reg->smax_value != reg->umax_value &&\n\t\t\t\t    reg->smax_value != S64_MAX)\n\t\t\t\t\tverbose(env, \",smax_value=%lld\",\n\t\t\t\t\t\t(long long)reg->smax_value);\n\t\t\t\tif (reg->umin_value != 0)\n\t\t\t\t\tverbose(env, \",umin_value=%llu\",\n\t\t\t\t\t\t(unsigned long long)reg->umin_value);\n\t\t\t\tif (reg->umax_value != U64_MAX)\n\t\t\t\t\tverbose(env, \",umax_value=%llu\",\n\t\t\t\t\t\t(unsigned long long)reg->umax_value);\n\t\t\t\tif (!tnum_is_unknown(reg->var_off)) {\n\t\t\t\t\tchar tn_buf[48];\n\n\t\t\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\t\t\tverbose(env, \",var_off=%s\", tn_buf);\n\t\t\t\t}\n\t\t\t\tif (reg->s32_min_value != reg->smin_value &&\n\t\t\t\t    reg->s32_min_value != S32_MIN)\n\t\t\t\t\tverbose(env, \",s32_min_value=%d\",\n\t\t\t\t\t\t(int)(reg->s32_min_value));\n\t\t\t\tif (reg->s32_max_value != reg->smax_value &&\n\t\t\t\t    reg->s32_max_value != S32_MAX)\n\t\t\t\t\tverbose(env, \",s32_max_value=%d\",\n\t\t\t\t\t\t(int)(reg->s32_max_value));\n\t\t\t\tif (reg->u32_min_value != reg->umin_value &&\n\t\t\t\t    reg->u32_min_value != U32_MIN)\n\t\t\t\t\tverbose(env, \",u32_min_value=%d\",\n\t\t\t\t\t\t(int)(reg->u32_min_value));\n\t\t\t\tif (reg->u32_max_value != reg->umax_value &&\n\t\t\t\t    reg->u32_max_value != U32_MAX)\n\t\t\t\t\tverbose(env, \",u32_max_value=%d\",\n\t\t\t\t\t\t(int)(reg->u32_max_value));\n\t\t\t}\n\t\t\tverbose(env, \")\");\n\t\t}\n\t}\n\tfor (i = 0; i < state->allocated_stack / BPF_REG_SIZE; i++) {\n\t\tchar types_buf[BPF_REG_SIZE + 1];\n\t\tbool valid = false;\n\t\tint j;\n\n\t\tfor (j = 0; j < BPF_REG_SIZE; j++) {\n\t\t\tif (state->stack[i].slot_type[j] != STACK_INVALID)\n\t\t\t\tvalid = true;\n\t\t\ttypes_buf[j] = slot_type_char[\n\t\t\t\t\tstate->stack[i].slot_type[j]];\n\t\t}\n\t\ttypes_buf[BPF_REG_SIZE] = 0;\n\t\tif (!valid)\n\t\t\tcontinue;\n\t\tverbose(env, \" fp%d\", (-i - 1) * BPF_REG_SIZE);\n\t\tprint_liveness(env, state->stack[i].spilled_ptr.live);\n\t\tif (state->stack[i].slot_type[0] == STACK_SPILL) {\n\t\t\treg = &state->stack[i].spilled_ptr;\n\t\t\tt = reg->type;\n\t\t\tverbose(env, \"=%s\", reg_type_str[t]);\n\t\t\tif (t == SCALAR_VALUE && reg->precise)\n\t\t\t\tverbose(env, \"P\");\n\t\t\tif (t == SCALAR_VALUE && tnum_is_const(reg->var_off))\n\t\t\t\tverbose(env, \"%lld\", reg->var_off.value + reg->off);\n\t\t} else {\n\t\t\tverbose(env, \"=%s\", types_buf);\n\t\t}\n\t}\n\tif (state->acquired_refs && state->refs[0].id) {\n\t\tverbose(env, \" refs=%d\", state->refs[0].id);\n\t\tfor (i = 1; i < state->acquired_refs; i++)\n\t\t\tif (state->refs[i].id)\n\t\t\t\tverbose(env, \",%d\", state->refs[i].id);\n\t}\n\tverbose(env, \"\\n\");\n}\n\n#define COPY_STATE_FN(NAME, COUNT, FIELD, SIZE)\t\t\t\t\\\nstatic int copy_##NAME##_state(struct bpf_func_state *dst,\t\t\\\n\t\t\t       const struct bpf_func_state *src)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (!src->FIELD)\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\\\n\tif (WARN_ON_ONCE(dst->COUNT < src->COUNT)) {\t\t\t\\\n\t\t/* internal bug, make state invalid to reject the program */ \\\n\t\tmemset(dst, 0, sizeof(*dst));\t\t\t\t\\\n\t\treturn -EFAULT;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tmemcpy(dst->FIELD, src->FIELD,\t\t\t\t\t\\\n\t       sizeof(*src->FIELD) * (src->COUNT / SIZE));\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\n/* copy_reference_state() */\nCOPY_STATE_FN(reference, acquired_refs, refs, 1)\n/* copy_stack_state() */\nCOPY_STATE_FN(stack, allocated_stack, stack, BPF_REG_SIZE)\n#undef COPY_STATE_FN\n\n#define REALLOC_STATE_FN(NAME, COUNT, FIELD, SIZE)\t\t\t\\\nstatic int realloc_##NAME##_state(struct bpf_func_state *state, int size, \\\n\t\t\t\t  bool copy_old)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tu32 old_size = state->COUNT;\t\t\t\t\t\\\n\tstruct bpf_##NAME##_state *new_##FIELD;\t\t\t\t\\\n\tint slot = size / SIZE;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (size <= old_size || !size) {\t\t\t\t\\\n\t\tif (copy_old)\t\t\t\t\t\t\\\n\t\t\treturn 0;\t\t\t\t\t\\\n\t\tstate->COUNT = slot * SIZE;\t\t\t\t\\\n\t\tif (!size && old_size) {\t\t\t\t\\\n\t\t\tkfree(state->FIELD);\t\t\t\t\\\n\t\t\tstate->FIELD = NULL;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tnew_##FIELD = kmalloc_array(slot, sizeof(struct bpf_##NAME##_state), \\\n\t\t\t\t    GFP_KERNEL);\t\t\t\\\n\tif (!new_##FIELD)\t\t\t\t\t\t\\\n\t\treturn -ENOMEM;\t\t\t\t\t\t\\\n\tif (copy_old) {\t\t\t\t\t\t\t\\\n\t\tif (state->FIELD)\t\t\t\t\t\\\n\t\t\tmemcpy(new_##FIELD, state->FIELD,\t\t\\\n\t\t\t       sizeof(*new_##FIELD) * (old_size / SIZE)); \\\n\t\tmemset(new_##FIELD + old_size / SIZE, 0,\t\t\\\n\t\t       sizeof(*new_##FIELD) * (size - old_size) / SIZE); \\\n\t}\t\t\t\t\t\t\t\t\\\n\tstate->COUNT = slot * SIZE;\t\t\t\t\t\\\n\tkfree(state->FIELD);\t\t\t\t\t\t\\\n\tstate->FIELD = new_##FIELD;\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\n/* realloc_reference_state() */\nREALLOC_STATE_FN(reference, acquired_refs, refs, 1)\n/* realloc_stack_state() */\nREALLOC_STATE_FN(stack, allocated_stack, stack, BPF_REG_SIZE)\n#undef REALLOC_STATE_FN\n\n/* do_check() starts with zero-sized stack in struct bpf_verifier_state to\n * make it consume minimal amount of memory. check_stack_write() access from\n * the program calls into realloc_func_state() to grow the stack size.\n * Note there is a non-zero 'parent' pointer inside bpf_verifier_state\n * which realloc_stack_state() copies over. It points to previous\n * bpf_verifier_state which is never reallocated.\n */\nstatic int realloc_func_state(struct bpf_func_state *state, int stack_size,\n\t\t\t      int refs_size, bool copy_old)\n{\n\tint err = realloc_reference_state(state, refs_size, copy_old);\n\tif (err)\n\t\treturn err;\n\treturn realloc_stack_state(state, stack_size, copy_old);\n}\n\n/* Acquire a pointer id from the env and update the state->refs to include\n * this new pointer reference.\n * On success, returns a valid pointer id to associate with the register\n * On failure, returns a negative errno.\n */\nstatic int acquire_reference_state(struct bpf_verifier_env *env, int insn_idx)\n{\n\tstruct bpf_func_state *state = cur_func(env);\n\tint new_ofs = state->acquired_refs;\n\tint id, err;\n\n\terr = realloc_reference_state(state, state->acquired_refs + 1, true);\n\tif (err)\n\t\treturn err;\n\tid = ++env->id_gen;\n\tstate->refs[new_ofs].id = id;\n\tstate->refs[new_ofs].insn_idx = insn_idx;\n\n\treturn id;\n}\n\n/* release function corresponding to acquire_reference_state(). Idempotent. */\nstatic int release_reference_state(struct bpf_func_state *state, int ptr_id)\n{\n\tint i, last_idx;\n\n\tlast_idx = state->acquired_refs - 1;\n\tfor (i = 0; i < state->acquired_refs; i++) {\n\t\tif (state->refs[i].id == ptr_id) {\n\t\t\tif (last_idx && i != last_idx)\n\t\t\t\tmemcpy(&state->refs[i], &state->refs[last_idx],\n\t\t\t\t       sizeof(*state->refs));\n\t\t\tmemset(&state->refs[last_idx], 0, sizeof(*state->refs));\n\t\t\tstate->acquired_refs--;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int transfer_reference_state(struct bpf_func_state *dst,\n\t\t\t\t    struct bpf_func_state *src)\n{\n\tint err = realloc_reference_state(dst, src->acquired_refs, false);\n\tif (err)\n\t\treturn err;\n\terr = copy_reference_state(dst, src);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic void free_func_state(struct bpf_func_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tkfree(state->refs);\n\tkfree(state->stack);\n\tkfree(state);\n}\n\nstatic void clear_jmp_history(struct bpf_verifier_state *state)\n{\n\tkfree(state->jmp_history);\n\tstate->jmp_history = NULL;\n\tstate->jmp_history_cnt = 0;\n}\n\nstatic void free_verifier_state(struct bpf_verifier_state *state,\n\t\t\t\tbool free_self)\n{\n\tint i;\n\n\tfor (i = 0; i <= state->curframe; i++) {\n\t\tfree_func_state(state->frame[i]);\n\t\tstate->frame[i] = NULL;\n\t}\n\tclear_jmp_history(state);\n\tif (free_self)\n\t\tkfree(state);\n}\n\n/* copy verifier state from src to dst growing dst stack space\n * when necessary to accommodate larger src stack\n */\nstatic int copy_func_state(struct bpf_func_state *dst,\n\t\t\t   const struct bpf_func_state *src)\n{\n\tint err;\n\n\terr = realloc_func_state(dst, src->allocated_stack, src->acquired_refs,\n\t\t\t\t false);\n\tif (err)\n\t\treturn err;\n\tmemcpy(dst, src, offsetof(struct bpf_func_state, acquired_refs));\n\terr = copy_reference_state(dst, src);\n\tif (err)\n\t\treturn err;\n\treturn copy_stack_state(dst, src);\n}\n\nstatic int copy_verifier_state(struct bpf_verifier_state *dst_state,\n\t\t\t       const struct bpf_verifier_state *src)\n{\n\tstruct bpf_func_state *dst;\n\tu32 jmp_sz = sizeof(struct bpf_idx_pair) * src->jmp_history_cnt;\n\tint i, err;\n\n\tif (dst_state->jmp_history_cnt < src->jmp_history_cnt) {\n\t\tkfree(dst_state->jmp_history);\n\t\tdst_state->jmp_history = kmalloc(jmp_sz, GFP_USER);\n\t\tif (!dst_state->jmp_history)\n\t\t\treturn -ENOMEM;\n\t}\n\tmemcpy(dst_state->jmp_history, src->jmp_history, jmp_sz);\n\tdst_state->jmp_history_cnt = src->jmp_history_cnt;\n\n\t/* if dst has more stack frames then src frame, free them */\n\tfor (i = src->curframe + 1; i <= dst_state->curframe; i++) {\n\t\tfree_func_state(dst_state->frame[i]);\n\t\tdst_state->frame[i] = NULL;\n\t}\n\tdst_state->speculative = src->speculative;\n\tdst_state->curframe = src->curframe;\n\tdst_state->active_spin_lock = src->active_spin_lock;\n\tdst_state->branches = src->branches;\n\tdst_state->parent = src->parent;\n\tdst_state->first_insn_idx = src->first_insn_idx;\n\tdst_state->last_insn_idx = src->last_insn_idx;\n\tfor (i = 0; i <= src->curframe; i++) {\n\t\tdst = dst_state->frame[i];\n\t\tif (!dst) {\n\t\t\tdst = kzalloc(sizeof(*dst), GFP_KERNEL);\n\t\t\tif (!dst)\n\t\t\t\treturn -ENOMEM;\n\t\t\tdst_state->frame[i] = dst;\n\t\t}\n\t\terr = copy_func_state(dst, src->frame[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void update_branch_counts(struct bpf_verifier_env *env, struct bpf_verifier_state *st)\n{\n\twhile (st) {\n\t\tu32 br = --st->branches;\n\n\t\t/* WARN_ON(br > 1) technically makes sense here,\n\t\t * but see comment in push_stack(), hence:\n\t\t */\n\t\tWARN_ONCE((int)br < 0,\n\t\t\t  \"BUG update_branch_counts:branches_to_explore=%d\\n\",\n\t\t\t  br);\n\t\tif (br)\n\t\t\tbreak;\n\t\tst = st->parent;\n\t}\n}\n\nstatic int pop_stack(struct bpf_verifier_env *env, int *prev_insn_idx,\n\t\t     int *insn_idx, bool pop_log)\n{\n\tstruct bpf_verifier_state *cur = env->cur_state;\n\tstruct bpf_verifier_stack_elem *elem, *head = env->head;\n\tint err;\n\n\tif (env->head == NULL)\n\t\treturn -ENOENT;\n\n\tif (cur) {\n\t\terr = copy_verifier_state(cur, &head->st);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (pop_log)\n\t\tbpf_vlog_reset(&env->log, head->log_pos);\n\tif (insn_idx)\n\t\t*insn_idx = head->insn_idx;\n\tif (prev_insn_idx)\n\t\t*prev_insn_idx = head->prev_insn_idx;\n\telem = head->next;\n\tfree_verifier_state(&head->st, false);\n\tkfree(head);\n\tenv->head = elem;\n\tenv->stack_size--;\n\treturn 0;\n}\n\nstatic struct bpf_verifier_state *push_stack(struct bpf_verifier_env *env,\n\t\t\t\t\t     int insn_idx, int prev_insn_idx,\n\t\t\t\t\t     bool speculative)\n{\n\tstruct bpf_verifier_state *cur = env->cur_state;\n\tstruct bpf_verifier_stack_elem *elem;\n\tint err;\n\n\telem = kzalloc(sizeof(struct bpf_verifier_stack_elem), GFP_KERNEL);\n\tif (!elem)\n\t\tgoto err;\n\n\telem->insn_idx = insn_idx;\n\telem->prev_insn_idx = prev_insn_idx;\n\telem->next = env->head;\n\telem->log_pos = env->log.len_used;\n\tenv->head = elem;\n\tenv->stack_size++;\n\terr = copy_verifier_state(&elem->st, cur);\n\tif (err)\n\t\tgoto err;\n\telem->st.speculative |= speculative;\n\tif (env->stack_size > BPF_COMPLEXITY_LIMIT_JMP_SEQ) {\n\t\tverbose(env, \"The sequence of %d jumps is too complex.\\n\",\n\t\t\tenv->stack_size);\n\t\tgoto err;\n\t}\n\tif (elem->st.parent) {\n\t\t++elem->st.parent->branches;\n\t\t/* WARN_ON(branches > 2) technically makes sense here,\n\t\t * but\n\t\t * 1. speculative states will bump 'branches' for non-branch\n\t\t * instructions\n\t\t * 2. is_state_visited() heuristics may decide not to create\n\t\t * a new state for a sequence of branches and all such current\n\t\t * and cloned states will be pointing to a single parent state\n\t\t * which might have large 'branches' count.\n\t\t */\n\t}\n\treturn &elem->st;\nerr:\n\tfree_verifier_state(env->cur_state, true);\n\tenv->cur_state = NULL;\n\t/* pop all elements and return */\n\twhile (!pop_stack(env, NULL, NULL, false));\n\treturn NULL;\n}\n\n#define CALLER_SAVED_REGS 6\nstatic const int caller_saved[CALLER_SAVED_REGS] = {\n\tBPF_REG_0, BPF_REG_1, BPF_REG_2, BPF_REG_3, BPF_REG_4, BPF_REG_5\n};\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\n/* This helper doesn't clear reg->id */\nstatic void ___mark_reg_known(struct bpf_reg_state *reg, u64 imm)\n{\n\treg->var_off = tnum_const(imm);\n\treg->smin_value = (s64)imm;\n\treg->smax_value = (s64)imm;\n\treg->umin_value = imm;\n\treg->umax_value = imm;\n\n\treg->s32_min_value = (s32)imm;\n\treg->s32_max_value = (s32)imm;\n\treg->u32_min_value = (u32)imm;\n\treg->u32_max_value = (u32)imm;\n}\n\n/* Mark the unknown part of a register (variable offset or scalar value) as\n * known to have the value @imm.\n */\nstatic void __mark_reg_known(struct bpf_reg_state *reg, u64 imm)\n{\n\t/* Clear id, off, and union(map_ptr, range) */\n\tmemset(((u8 *)reg) + sizeof(reg->type), 0,\n\t       offsetof(struct bpf_reg_state, var_off) - sizeof(reg->type));\n\t___mark_reg_known(reg, imm);\n}\n\nstatic void __mark_reg32_known(struct bpf_reg_state *reg, u64 imm)\n{\n\treg->var_off = tnum_const_subreg(reg->var_off, imm);\n\treg->s32_min_value = (s32)imm;\n\treg->s32_max_value = (s32)imm;\n\treg->u32_min_value = (u32)imm;\n\treg->u32_max_value = (u32)imm;\n}\n\n/* Mark the 'variable offset' part of a register as zero.  This should be\n * used only on registers holding a pointer type.\n */\nstatic void __mark_reg_known_zero(struct bpf_reg_state *reg)\n{\n\t__mark_reg_known(reg, 0);\n}\n\nstatic void __mark_reg_const_zero(struct bpf_reg_state *reg)\n{\n\t__mark_reg_known(reg, 0);\n\treg->type = SCALAR_VALUE;\n}\n\nstatic void mark_reg_known_zero(struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *regs, u32 regno)\n{\n\tif (WARN_ON(regno >= MAX_BPF_REG)) {\n\t\tverbose(env, \"mark_reg_known_zero(regs, %u)\\n\", regno);\n\t\t/* Something bad happened, let's kill all regs */\n\t\tfor (regno = 0; regno < MAX_BPF_REG; regno++)\n\t\t\t__mark_reg_not_init(env, regs + regno);\n\t\treturn;\n\t}\n\t__mark_reg_known_zero(regs + regno);\n}\n\nstatic void mark_ptr_not_null_reg(struct bpf_reg_state *reg)\n{\n\tswitch (reg->type) {\n\tcase PTR_TO_MAP_VALUE_OR_NULL: {\n\t\tconst struct bpf_map *map = reg->map_ptr;\n\n\t\tif (map->inner_map_meta) {\n\t\t\treg->type = CONST_PTR_TO_MAP;\n\t\t\treg->map_ptr = map->inner_map_meta;\n\t\t} else if (map->map_type == BPF_MAP_TYPE_XSKMAP) {\n\t\t\treg->type = PTR_TO_XDP_SOCK;\n\t\t} else if (map->map_type == BPF_MAP_TYPE_SOCKMAP ||\n\t\t\t   map->map_type == BPF_MAP_TYPE_SOCKHASH) {\n\t\t\treg->type = PTR_TO_SOCKET;\n\t\t} else {\n\t\t\treg->type = PTR_TO_MAP_VALUE;\n\t\t}\n\t\tbreak;\n\t}\n\tcase PTR_TO_SOCKET_OR_NULL:\n\t\treg->type = PTR_TO_SOCKET;\n\t\tbreak;\n\tcase PTR_TO_SOCK_COMMON_OR_NULL:\n\t\treg->type = PTR_TO_SOCK_COMMON;\n\t\tbreak;\n\tcase PTR_TO_TCP_SOCK_OR_NULL:\n\t\treg->type = PTR_TO_TCP_SOCK;\n\t\tbreak;\n\tcase PTR_TO_BTF_ID_OR_NULL:\n\t\treg->type = PTR_TO_BTF_ID;\n\t\tbreak;\n\tcase PTR_TO_MEM_OR_NULL:\n\t\treg->type = PTR_TO_MEM;\n\t\tbreak;\n\tcase PTR_TO_RDONLY_BUF_OR_NULL:\n\t\treg->type = PTR_TO_RDONLY_BUF;\n\t\tbreak;\n\tcase PTR_TO_RDWR_BUF_OR_NULL:\n\t\treg->type = PTR_TO_RDWR_BUF;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"unknown nullable register type\");\n\t}\n}\n\nstatic bool reg_is_pkt_pointer(const struct bpf_reg_state *reg)\n{\n\treturn type_is_pkt_pointer(reg->type);\n}\n\nstatic bool reg_is_pkt_pointer_any(const struct bpf_reg_state *reg)\n{\n\treturn reg_is_pkt_pointer(reg) ||\n\t       reg->type == PTR_TO_PACKET_END;\n}\n\n/* Unmodified PTR_TO_PACKET[_META,_END] register from ctx access. */\nstatic bool reg_is_init_pkt_pointer(const struct bpf_reg_state *reg,\n\t\t\t\t    enum bpf_reg_type which)\n{\n\t/* The register can already have a range from prior markings.\n\t * This is fine as long as it hasn't been advanced from its\n\t * origin.\n\t */\n\treturn reg->type == which &&\n\t       reg->id == 0 &&\n\t       reg->off == 0 &&\n\t       tnum_equals_const(reg->var_off, 0);\n}\n\n/* Reset the min/max bounds of a register */\nstatic void __mark_reg_unbounded(struct bpf_reg_state *reg)\n{\n\treg->smin_value = S64_MIN;\n\treg->smax_value = S64_MAX;\n\treg->umin_value = 0;\n\treg->umax_value = U64_MAX;\n\n\treg->s32_min_value = S32_MIN;\n\treg->s32_max_value = S32_MAX;\n\treg->u32_min_value = 0;\n\treg->u32_max_value = U32_MAX;\n}\n\nstatic void __mark_reg64_unbounded(struct bpf_reg_state *reg)\n{\n\treg->smin_value = S64_MIN;\n\treg->smax_value = S64_MAX;\n\treg->umin_value = 0;\n\treg->umax_value = U64_MAX;\n}\n\nstatic void __mark_reg32_unbounded(struct bpf_reg_state *reg)\n{\n\treg->s32_min_value = S32_MIN;\n\treg->s32_max_value = S32_MAX;\n\treg->u32_min_value = 0;\n\treg->u32_max_value = U32_MAX;\n}\n\nstatic void __update_reg32_bounds(struct bpf_reg_state *reg)\n{\n\tstruct tnum var32_off = tnum_subreg(reg->var_off);\n\n\t/* min signed is max(sign bit) | min(other bits) */\n\treg->s32_min_value = max_t(s32, reg->s32_min_value,\n\t\t\tvar32_off.value | (var32_off.mask & S32_MIN));\n\t/* max signed is min(sign bit) | max(other bits) */\n\treg->s32_max_value = min_t(s32, reg->s32_max_value,\n\t\t\tvar32_off.value | (var32_off.mask & S32_MAX));\n\treg->u32_min_value = max_t(u32, reg->u32_min_value, (u32)var32_off.value);\n\treg->u32_max_value = min(reg->u32_max_value,\n\t\t\t\t (u32)(var32_off.value | var32_off.mask));\n}\n\nstatic void __update_reg64_bounds(struct bpf_reg_state *reg)\n{\n\t/* min signed is max(sign bit) | min(other bits) */\n\treg->smin_value = max_t(s64, reg->smin_value,\n\t\t\t\treg->var_off.value | (reg->var_off.mask & S64_MIN));\n\t/* max signed is min(sign bit) | max(other bits) */\n\treg->smax_value = min_t(s64, reg->smax_value,\n\t\t\t\treg->var_off.value | (reg->var_off.mask & S64_MAX));\n\treg->umin_value = max(reg->umin_value, reg->var_off.value);\n\treg->umax_value = min(reg->umax_value,\n\t\t\t      reg->var_off.value | reg->var_off.mask);\n}\n\nstatic void __update_reg_bounds(struct bpf_reg_state *reg)\n{\n\t__update_reg32_bounds(reg);\n\t__update_reg64_bounds(reg);\n}\n\n/* Uses signed min/max values to inform unsigned, and vice-versa */\nstatic void __reg32_deduce_bounds(struct bpf_reg_state *reg)\n{\n\t/* Learn sign from signed bounds.\n\t * If we cannot cross the sign boundary, then signed and unsigned bounds\n\t * are the same, so combine.  This works even in the negative case, e.g.\n\t * -3 s<= x s<= -1 implies 0xf...fd u<= x u<= 0xf...ff.\n\t */\n\tif (reg->s32_min_value >= 0 || reg->s32_max_value < 0) {\n\t\treg->s32_min_value = reg->u32_min_value =\n\t\t\tmax_t(u32, reg->s32_min_value, reg->u32_min_value);\n\t\treg->s32_max_value = reg->u32_max_value =\n\t\t\tmin_t(u32, reg->s32_max_value, reg->u32_max_value);\n\t\treturn;\n\t}\n\t/* Learn sign from unsigned bounds.  Signed bounds cross the sign\n\t * boundary, so we must be careful.\n\t */\n\tif ((s32)reg->u32_max_value >= 0) {\n\t\t/* Positive.  We can't learn anything from the smin, but smax\n\t\t * is positive, hence safe.\n\t\t */\n\t\treg->s32_min_value = reg->u32_min_value;\n\t\treg->s32_max_value = reg->u32_max_value =\n\t\t\tmin_t(u32, reg->s32_max_value, reg->u32_max_value);\n\t} else if ((s32)reg->u32_min_value < 0) {\n\t\t/* Negative.  We can't learn anything from the smax, but smin\n\t\t * is negative, hence safe.\n\t\t */\n\t\treg->s32_min_value = reg->u32_min_value =\n\t\t\tmax_t(u32, reg->s32_min_value, reg->u32_min_value);\n\t\treg->s32_max_value = reg->u32_max_value;\n\t}\n}\n\nstatic void __reg64_deduce_bounds(struct bpf_reg_state *reg)\n{\n\t/* Learn sign from signed bounds.\n\t * If we cannot cross the sign boundary, then signed and unsigned bounds\n\t * are the same, so combine.  This works even in the negative case, e.g.\n\t * -3 s<= x s<= -1 implies 0xf...fd u<= x u<= 0xf...ff.\n\t */\n\tif (reg->smin_value >= 0 || reg->smax_value < 0) {\n\t\treg->smin_value = reg->umin_value = max_t(u64, reg->smin_value,\n\t\t\t\t\t\t\t  reg->umin_value);\n\t\treg->smax_value = reg->umax_value = min_t(u64, reg->smax_value,\n\t\t\t\t\t\t\t  reg->umax_value);\n\t\treturn;\n\t}\n\t/* Learn sign from unsigned bounds.  Signed bounds cross the sign\n\t * boundary, so we must be careful.\n\t */\n\tif ((s64)reg->umax_value >= 0) {\n\t\t/* Positive.  We can't learn anything from the smin, but smax\n\t\t * is positive, hence safe.\n\t\t */\n\t\treg->smin_value = reg->umin_value;\n\t\treg->smax_value = reg->umax_value = min_t(u64, reg->smax_value,\n\t\t\t\t\t\t\t  reg->umax_value);\n\t} else if ((s64)reg->umin_value < 0) {\n\t\t/* Negative.  We can't learn anything from the smax, but smin\n\t\t * is negative, hence safe.\n\t\t */\n\t\treg->smin_value = reg->umin_value = max_t(u64, reg->smin_value,\n\t\t\t\t\t\t\t  reg->umin_value);\n\t\treg->smax_value = reg->umax_value;\n\t}\n}\n\nstatic void __reg_deduce_bounds(struct bpf_reg_state *reg)\n{\n\t__reg32_deduce_bounds(reg);\n\t__reg64_deduce_bounds(reg);\n}\n\n/* Attempts to improve var_off based on unsigned min/max information */\nstatic void __reg_bound_offset(struct bpf_reg_state *reg)\n{\n\tstruct tnum var64_off = tnum_intersect(reg->var_off,\n\t\t\t\t\t       tnum_range(reg->umin_value,\n\t\t\t\t\t\t\t  reg->umax_value));\n\tstruct tnum var32_off = tnum_intersect(tnum_subreg(reg->var_off),\n\t\t\t\t\t\ttnum_range(reg->u32_min_value,\n\t\t\t\t\t\t\t   reg->u32_max_value));\n\n\treg->var_off = tnum_or(tnum_clear_subreg(var64_off), var32_off);\n}\n\nstatic void __reg_assign_32_into_64(struct bpf_reg_state *reg)\n{\n\treg->umin_value = reg->u32_min_value;\n\treg->umax_value = reg->u32_max_value;\n\t/* Attempt to pull 32-bit signed bounds into 64-bit bounds\n\t * but must be positive otherwise set to worse case bounds\n\t * and refine later from tnum.\n\t */\n\tif (reg->s32_min_value >= 0 && reg->s32_max_value >= 0)\n\t\treg->smax_value = reg->s32_max_value;\n\telse\n\t\treg->smax_value = U32_MAX;\n\tif (reg->s32_min_value >= 0)\n\t\treg->smin_value = reg->s32_min_value;\n\telse\n\t\treg->smin_value = 0;\n}\n\nstatic void __reg_combine_32_into_64(struct bpf_reg_state *reg)\n{\n\t/* special case when 64-bit register has upper 32-bit register\n\t * zeroed. Typically happens after zext or <<32, >>32 sequence\n\t * allowing us to use 32-bit bounds directly,\n\t */\n\tif (tnum_equals_const(tnum_clear_subreg(reg->var_off), 0)) {\n\t\t__reg_assign_32_into_64(reg);\n\t} else {\n\t\t/* Otherwise the best we can do is push lower 32bit known and\n\t\t * unknown bits into register (var_off set from jmp logic)\n\t\t * then learn as much as possible from the 64-bit tnum\n\t\t * known and unknown bits. The previous smin/smax bounds are\n\t\t * invalid here because of jmp32 compare so mark them unknown\n\t\t * so they do not impact tnum bounds calculation.\n\t\t */\n\t\t__mark_reg64_unbounded(reg);\n\t\t__update_reg_bounds(reg);\n\t}\n\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__reg_deduce_bounds(reg);\n\t__reg_bound_offset(reg);\n\t__update_reg_bounds(reg);\n}\n\nstatic bool __reg64_bound_s32(s64 a)\n{\n\treturn a > S32_MIN && a < S32_MAX;\n}\n\nstatic bool __reg64_bound_u32(u64 a)\n{\n\tif (a > U32_MIN && a < U32_MAX)\n\t\treturn true;\n\treturn false;\n}\n\nstatic void __reg_combine_64_into_32(struct bpf_reg_state *reg)\n{\n\t__mark_reg32_unbounded(reg);\n\n\tif (__reg64_bound_s32(reg->smin_value) && __reg64_bound_s32(reg->smax_value)) {\n\t\treg->s32_min_value = (s32)reg->smin_value;\n\t\treg->s32_max_value = (s32)reg->smax_value;\n\t}\n\tif (__reg64_bound_u32(reg->umin_value))\n\t\treg->u32_min_value = (u32)reg->umin_value;\n\tif (__reg64_bound_u32(reg->umax_value))\n\t\treg->u32_max_value = (u32)reg->umax_value;\n\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__reg_deduce_bounds(reg);\n\t__reg_bound_offset(reg);\n\t__update_reg_bounds(reg);\n}\n\n/* Mark a register as having a completely unknown (scalar) value. */\nstatic void __mark_reg_unknown(const struct bpf_verifier_env *env,\n\t\t\t       struct bpf_reg_state *reg)\n{\n\t/*\n\t * Clear type, id, off, and union(map_ptr, range) and\n\t * padding between 'type' and union\n\t */\n\tmemset(reg, 0, offsetof(struct bpf_reg_state, var_off));\n\treg->type = SCALAR_VALUE;\n\treg->var_off = tnum_unknown;\n\treg->frameno = 0;\n\treg->precise = env->subprog_cnt > 1 || !env->bpf_capable;\n\t__mark_reg_unbounded(reg);\n}\n\nstatic void mark_reg_unknown(struct bpf_verifier_env *env,\n\t\t\t     struct bpf_reg_state *regs, u32 regno)\n{\n\tif (WARN_ON(regno >= MAX_BPF_REG)) {\n\t\tverbose(env, \"mark_reg_unknown(regs, %u)\\n\", regno);\n\t\t/* Something bad happened, let's kill all regs except FP */\n\t\tfor (regno = 0; regno < BPF_REG_FP; regno++)\n\t\t\t__mark_reg_not_init(env, regs + regno);\n\t\treturn;\n\t}\n\t__mark_reg_unknown(env, regs + regno);\n}\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg)\n{\n\t__mark_reg_unknown(env, reg);\n\treg->type = NOT_INIT;\n}\n\nstatic void mark_reg_not_init(struct bpf_verifier_env *env,\n\t\t\t      struct bpf_reg_state *regs, u32 regno)\n{\n\tif (WARN_ON(regno >= MAX_BPF_REG)) {\n\t\tverbose(env, \"mark_reg_not_init(regs, %u)\\n\", regno);\n\t\t/* Something bad happened, let's kill all regs except FP */\n\t\tfor (regno = 0; regno < BPF_REG_FP; regno++)\n\t\t\t__mark_reg_not_init(env, regs + regno);\n\t\treturn;\n\t}\n\t__mark_reg_not_init(env, regs + regno);\n}\n\nstatic void mark_btf_ld_reg(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_reg_state *regs, u32 regno,\n\t\t\t    enum bpf_reg_type reg_type,\n\t\t\t    struct btf *btf, u32 btf_id)\n{\n\tif (reg_type == SCALAR_VALUE) {\n\t\tmark_reg_unknown(env, regs, regno);\n\t\treturn;\n\t}\n\tmark_reg_known_zero(env, regs, regno);\n\tregs[regno].type = PTR_TO_BTF_ID;\n\tregs[regno].btf = btf;\n\tregs[regno].btf_id = btf_id;\n}\n\n#define DEF_NOT_SUBREG\t(0)\nstatic void init_reg_state(struct bpf_verifier_env *env,\n\t\t\t   struct bpf_func_state *state)\n{\n\tstruct bpf_reg_state *regs = state->regs;\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\tmark_reg_not_init(env, regs, i);\n\t\tregs[i].live = REG_LIVE_NONE;\n\t\tregs[i].parent = NULL;\n\t\tregs[i].subreg_def = DEF_NOT_SUBREG;\n\t}\n\n\t/* frame pointer */\n\tregs[BPF_REG_FP].type = PTR_TO_STACK;\n\tmark_reg_known_zero(env, regs, BPF_REG_FP);\n\tregs[BPF_REG_FP].frameno = state->frameno;\n}\n\n#define BPF_MAIN_FUNC (-1)\nstatic void init_func_state(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_func_state *state,\n\t\t\t    int callsite, int frameno, int subprogno)\n{\n\tstate->callsite = callsite;\n\tstate->frameno = frameno;\n\tstate->subprogno = subprogno;\n\tinit_reg_state(env, state);\n}\n\nenum reg_arg_type {\n\tSRC_OP,\t\t/* register is used as source operand */\n\tDST_OP,\t\t/* register is used as destination operand */\n\tDST_OP_NO_MARK\t/* same as above, check only, don't mark */\n};\n\nstatic int cmp_subprogs(const void *a, const void *b)\n{\n\treturn ((struct bpf_subprog_info *)a)->start -\n\t       ((struct bpf_subprog_info *)b)->start;\n}\n\nstatic int find_subprog(struct bpf_verifier_env *env, int off)\n{\n\tstruct bpf_subprog_info *p;\n\n\tp = bsearch(&off, env->subprog_info, env->subprog_cnt,\n\t\t    sizeof(env->subprog_info[0]), cmp_subprogs);\n\tif (!p)\n\t\treturn -ENOENT;\n\treturn p - env->subprog_info;\n\n}\n\nstatic int add_subprog(struct bpf_verifier_env *env, int off)\n{\n\tint insn_cnt = env->prog->len;\n\tint ret;\n\n\tif (off >= insn_cnt || off < 0) {\n\t\tverbose(env, \"call to invalid destination\\n\");\n\t\treturn -EINVAL;\n\t}\n\tret = find_subprog(env, off);\n\tif (ret >= 0)\n\t\treturn ret;\n\tif (env->subprog_cnt >= BPF_MAX_SUBPROGS) {\n\t\tverbose(env, \"too many subprograms\\n\");\n\t\treturn -E2BIG;\n\t}\n\tenv->subprog_info[env->subprog_cnt++].start = off;\n\tsort(env->subprog_info, env->subprog_cnt,\n\t     sizeof(env->subprog_info[0]), cmp_subprogs, NULL);\n\treturn env->subprog_cnt - 1;\n}\n\nstatic int check_subprogs(struct bpf_verifier_env *env)\n{\n\tint i, ret, subprog_start, subprog_end, off, cur_subprog = 0;\n\tstruct bpf_subprog_info *subprog = env->subprog_info;\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\n\t/* Add entry function. */\n\tret = add_subprog(env, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* determine subprog starts. The end is one before the next starts */\n\tfor (i = 0; i < insn_cnt; i++) {\n\t\tif (bpf_pseudo_func(insn + i)) {\n\t\t\tif (!env->bpf_capable) {\n\t\t\t\tverbose(env,\n\t\t\t\t\t\"function pointers are allowed for CAP_BPF and CAP_SYS_ADMIN\\n\");\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t\tret = add_subprog(env, i + insn[i].imm + 1);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t/* remember subprog */\n\t\t\tinsn[i + 1].imm = ret;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!bpf_pseudo_call(insn + i))\n\t\t\tcontinue;\n\t\tif (!env->bpf_capable) {\n\t\t\tverbose(env,\n\t\t\t\t\"function calls to other bpf functions are allowed for CAP_BPF and CAP_SYS_ADMIN\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tret = add_subprog(env, i + insn[i].imm + 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Add a fake 'exit' subprog which could simplify subprog iteration\n\t * logic. 'subprog_cnt' should not be increased.\n\t */\n\tsubprog[env->subprog_cnt].start = insn_cnt;\n\n\tif (env->log.level & BPF_LOG_LEVEL2)\n\t\tfor (i = 0; i < env->subprog_cnt; i++)\n\t\t\tverbose(env, \"func#%d @%d\\n\", i, subprog[i].start);\n\n\t/* now check that all jumps are within the same subprog */\n\tsubprog_start = subprog[cur_subprog].start;\n\tsubprog_end = subprog[cur_subprog + 1].start;\n\tfor (i = 0; i < insn_cnt; i++) {\n\t\tu8 code = insn[i].code;\n\n\t\tif (code == (BPF_JMP | BPF_CALL) &&\n\t\t    insn[i].imm == BPF_FUNC_tail_call &&\n\t\t    insn[i].src_reg != BPF_PSEUDO_CALL)\n\t\t\tsubprog[cur_subprog].has_tail_call = true;\n\t\tif (BPF_CLASS(code) == BPF_LD &&\n\t\t    (BPF_MODE(code) == BPF_ABS || BPF_MODE(code) == BPF_IND))\n\t\t\tsubprog[cur_subprog].has_ld_abs = true;\n\t\tif (BPF_CLASS(code) != BPF_JMP && BPF_CLASS(code) != BPF_JMP32)\n\t\t\tgoto next;\n\t\tif (BPF_OP(code) == BPF_EXIT || BPF_OP(code) == BPF_CALL)\n\t\t\tgoto next;\n\t\toff = i + insn[i].off + 1;\n\t\tif (off < subprog_start || off >= subprog_end) {\n\t\t\tverbose(env, \"jump out of range from insn %d to %d\\n\", i, off);\n\t\t\treturn -EINVAL;\n\t\t}\nnext:\n\t\tif (i == subprog_end - 1) {\n\t\t\t/* to avoid fall-through from one subprog into another\n\t\t\t * the last insn of the subprog should be either exit\n\t\t\t * or unconditional jump back\n\t\t\t */\n\t\t\tif (code != (BPF_JMP | BPF_EXIT) &&\n\t\t\t    code != (BPF_JMP | BPF_JA)) {\n\t\t\t\tverbose(env, \"last insn is not an exit or jmp\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsubprog_start = subprog_end;\n\t\t\tcur_subprog++;\n\t\t\tif (cur_subprog < env->subprog_cnt)\n\t\t\t\tsubprog_end = subprog[cur_subprog + 1].start;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* Parentage chain of this register (or stack slot) should take care of all\n * issues like callee-saved registers, stack slot allocation time, etc.\n */\nstatic int mark_reg_read(struct bpf_verifier_env *env,\n\t\t\t const struct bpf_reg_state *state,\n\t\t\t struct bpf_reg_state *parent, u8 flag)\n{\n\tbool writes = parent == state->parent; /* Observe write marks */\n\tint cnt = 0;\n\n\twhile (parent) {\n\t\t/* if read wasn't screened by an earlier write ... */\n\t\tif (writes && state->live & REG_LIVE_WRITTEN)\n\t\t\tbreak;\n\t\tif (parent->live & REG_LIVE_DONE) {\n\t\t\tverbose(env, \"verifier BUG type %s var_off %lld off %d\\n\",\n\t\t\t\treg_type_str[parent->type],\n\t\t\t\tparent->var_off.value, parent->off);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\t/* The first condition is more likely to be true than the\n\t\t * second, checked it first.\n\t\t */\n\t\tif ((parent->live & REG_LIVE_READ) == flag ||\n\t\t    parent->live & REG_LIVE_READ64)\n\t\t\t/* The parentage chain never changes and\n\t\t\t * this parent was already marked as LIVE_READ.\n\t\t\t * There is no need to keep walking the chain again and\n\t\t\t * keep re-marking all parents as LIVE_READ.\n\t\t\t * This case happens when the same register is read\n\t\t\t * multiple times without writes into it in-between.\n\t\t\t * Also, if parent has the stronger REG_LIVE_READ64 set,\n\t\t\t * then no need to set the weak REG_LIVE_READ32.\n\t\t\t */\n\t\t\tbreak;\n\t\t/* ... then we depend on parent's value */\n\t\tparent->live |= flag;\n\t\t/* REG_LIVE_READ64 overrides REG_LIVE_READ32. */\n\t\tif (flag == REG_LIVE_READ64)\n\t\t\tparent->live &= ~REG_LIVE_READ32;\n\t\tstate = parent;\n\t\tparent = state->parent;\n\t\twrites = true;\n\t\tcnt++;\n\t}\n\n\tif (env->longest_mark_read_walk < cnt)\n\t\tenv->longest_mark_read_walk = cnt;\n\treturn 0;\n}\n\n/* This function is supposed to be used by the following 32-bit optimization\n * code only. It returns TRUE if the source or destination register operates\n * on 64-bit, otherwise return FALSE.\n */\nstatic bool is_reg64(struct bpf_verifier_env *env, struct bpf_insn *insn,\n\t\t     u32 regno, struct bpf_reg_state *reg, enum reg_arg_type t)\n{\n\tu8 code, class, op;\n\n\tcode = insn->code;\n\tclass = BPF_CLASS(code);\n\top = BPF_OP(code);\n\tif (class == BPF_JMP) {\n\t\t/* BPF_EXIT for \"main\" will reach here. Return TRUE\n\t\t * conservatively.\n\t\t */\n\t\tif (op == BPF_EXIT)\n\t\t\treturn true;\n\t\tif (op == BPF_CALL) {\n\t\t\t/* BPF to BPF call will reach here because of marking\n\t\t\t * caller saved clobber with DST_OP_NO_MARK for which we\n\t\t\t * don't care the register def because they are anyway\n\t\t\t * marked as NOT_INIT already.\n\t\t\t */\n\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\t\treturn false;\n\t\t\t/* Helper call will reach here because of arg type\n\t\t\t * check, conservatively return TRUE.\n\t\t\t */\n\t\t\tif (t == SRC_OP)\n\t\t\t\treturn true;\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (class == BPF_ALU64 || class == BPF_JMP ||\n\t    /* BPF_END always use BPF_ALU class. */\n\t    (class == BPF_ALU && op == BPF_END && insn->imm == 64))\n\t\treturn true;\n\n\tif (class == BPF_ALU || class == BPF_JMP32)\n\t\treturn false;\n\n\tif (class == BPF_LDX) {\n\t\tif (t != SRC_OP)\n\t\t\treturn BPF_SIZE(code) == BPF_DW;\n\t\t/* LDX source must be ptr. */\n\t\treturn true;\n\t}\n\n\tif (class == BPF_STX) {\n\t\t/* BPF_STX (including atomic variants) has multiple source\n\t\t * operands, one of which is a ptr. Check whether the caller is\n\t\t * asking about it.\n\t\t */\n\t\tif (t == SRC_OP && reg->type != SCALAR_VALUE)\n\t\t\treturn true;\n\t\treturn BPF_SIZE(code) == BPF_DW;\n\t}\n\n\tif (class == BPF_LD) {\n\t\tu8 mode = BPF_MODE(code);\n\n\t\t/* LD_IMM64 */\n\t\tif (mode == BPF_IMM)\n\t\t\treturn true;\n\n\t\t/* Both LD_IND and LD_ABS return 32-bit data. */\n\t\tif (t != SRC_OP)\n\t\t\treturn  false;\n\n\t\t/* Implicit ctx ptr. */\n\t\tif (regno == BPF_REG_6)\n\t\t\treturn true;\n\n\t\t/* Explicit source could be any width. */\n\t\treturn true;\n\t}\n\n\tif (class == BPF_ST)\n\t\t/* The only source register for BPF_ST is a ptr. */\n\t\treturn true;\n\n\t/* Conservatively return true at default. */\n\treturn true;\n}\n\n/* Return the regno defined by the insn, or -1. */\nstatic int insn_def_regno(const struct bpf_insn *insn)\n{\n\tswitch (BPF_CLASS(insn->code)) {\n\tcase BPF_JMP:\n\tcase BPF_JMP32:\n\tcase BPF_ST:\n\t\treturn -1;\n\tcase BPF_STX:\n\t\tif (BPF_MODE(insn->code) == BPF_ATOMIC &&\n\t\t    (insn->imm & BPF_FETCH)) {\n\t\t\tif (insn->imm == BPF_CMPXCHG)\n\t\t\t\treturn BPF_REG_0;\n\t\t\telse\n\t\t\t\treturn insn->src_reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\tdefault:\n\t\treturn insn->dst_reg;\n\t}\n}\n\n/* Return TRUE if INSN has defined any 32-bit value explicitly. */\nstatic bool insn_has_def32(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tint dst_reg = insn_def_regno(insn);\n\n\tif (dst_reg == -1)\n\t\treturn false;\n\n\treturn !is_reg64(env, insn, dst_reg, NULL, DST_OP);\n}\n\nstatic void mark_insn_zext(struct bpf_verifier_env *env,\n\t\t\t   struct bpf_reg_state *reg)\n{\n\ts32 def_idx = reg->subreg_def;\n\n\tif (def_idx == DEF_NOT_SUBREG)\n\t\treturn;\n\n\tenv->insn_aux_data[def_idx - 1].zext_dst = true;\n\t/* The dst will be zero extended, so won't be sub-register anymore. */\n\treg->subreg_def = DEF_NOT_SUBREG;\n}\n\nstatic int check_reg_arg(struct bpf_verifier_env *env, u32 regno,\n\t\t\t enum reg_arg_type t)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tstruct bpf_insn *insn = env->prog->insnsi + env->insn_idx;\n\tstruct bpf_reg_state *reg, *regs = state->regs;\n\tbool rw64;\n\n\tif (regno >= MAX_BPF_REG) {\n\t\tverbose(env, \"R%d is invalid\\n\", regno);\n\t\treturn -EINVAL;\n\t}\n\n\treg = &regs[regno];\n\trw64 = is_reg64(env, insn, regno, reg, t);\n\tif (t == SRC_OP) {\n\t\t/* check whether register used as source operand can be read */\n\t\tif (reg->type == NOT_INIT) {\n\t\t\tverbose(env, \"R%d !read_ok\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* We don't need to worry about FP liveness because it's read-only */\n\t\tif (regno == BPF_REG_FP)\n\t\t\treturn 0;\n\n\t\tif (rw64)\n\t\t\tmark_insn_zext(env, reg);\n\n\t\treturn mark_reg_read(env, reg, reg->parent,\n\t\t\t\t     rw64 ? REG_LIVE_READ64 : REG_LIVE_READ32);\n\t} else {\n\t\t/* check whether register used as dest operand can be written to */\n\t\tif (regno == BPF_REG_FP) {\n\t\t\tverbose(env, \"frame pointer is read only\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\treg->live |= REG_LIVE_WRITTEN;\n\t\treg->subreg_def = rw64 ? DEF_NOT_SUBREG : env->insn_idx + 1;\n\t\tif (t == DST_OP)\n\t\t\tmark_reg_unknown(env, regs, regno);\n\t}\n\treturn 0;\n}\n\n/* for any branch, call, exit record the history of jmps in the given state */\nstatic int push_jmp_history(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_verifier_state *cur)\n{\n\tu32 cnt = cur->jmp_history_cnt;\n\tstruct bpf_idx_pair *p;\n\n\tcnt++;\n\tp = krealloc(cur->jmp_history, cnt * sizeof(*p), GFP_USER);\n\tif (!p)\n\t\treturn -ENOMEM;\n\tp[cnt - 1].idx = env->insn_idx;\n\tp[cnt - 1].prev_idx = env->prev_insn_idx;\n\tcur->jmp_history = p;\n\tcur->jmp_history_cnt = cnt;\n\treturn 0;\n}\n\n/* Backtrack one insn at a time. If idx is not at the top of recorded\n * history then previous instruction came from straight line execution.\n */\nstatic int get_prev_insn_idx(struct bpf_verifier_state *st, int i,\n\t\t\t     u32 *history)\n{\n\tu32 cnt = *history;\n\n\tif (cnt && st->jmp_history[cnt - 1].idx == i) {\n\t\ti = st->jmp_history[cnt - 1].prev_idx;\n\t\t(*history)--;\n\t} else {\n\t\ti--;\n\t}\n\treturn i;\n}\n\n/* For given verifier state backtrack_insn() is called from the last insn to\n * the first insn. Its purpose is to compute a bitmask of registers and\n * stack slots that needs precision in the parent verifier state.\n */\nstatic int backtrack_insn(struct bpf_verifier_env *env, int idx,\n\t\t\t  u32 *reg_mask, u64 *stack_mask)\n{\n\tconst struct bpf_insn_cbs cbs = {\n\t\t.cb_print\t= verbose,\n\t\t.private_data\t= env,\n\t};\n\tstruct bpf_insn *insn = env->prog->insnsi + idx;\n\tu8 class = BPF_CLASS(insn->code);\n\tu8 opcode = BPF_OP(insn->code);\n\tu8 mode = BPF_MODE(insn->code);\n\tu32 dreg = 1u << insn->dst_reg;\n\tu32 sreg = 1u << insn->src_reg;\n\tu32 spi;\n\n\tif (insn->code == 0)\n\t\treturn 0;\n\tif (env->log.level & BPF_LOG_LEVEL) {\n\t\tverbose(env, \"regs=%x stack=%llx before \", *reg_mask, *stack_mask);\n\t\tverbose(env, \"%d: \", idx);\n\t\tprint_bpf_insn(&cbs, insn, env->allow_ptr_leaks);\n\t}\n\n\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\tif (!(*reg_mask & dreg))\n\t\t\treturn 0;\n\t\tif (opcode == BPF_MOV) {\n\t\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\t\t/* dreg = sreg\n\t\t\t\t * dreg needs precision after this insn\n\t\t\t\t * sreg needs precision before this insn\n\t\t\t\t */\n\t\t\t\t*reg_mask &= ~dreg;\n\t\t\t\t*reg_mask |= sreg;\n\t\t\t} else {\n\t\t\t\t/* dreg = K\n\t\t\t\t * dreg needs precision after this insn.\n\t\t\t\t * Corresponding register is already marked\n\t\t\t\t * as precise=true in this verifier state.\n\t\t\t\t * No further markings in parent are necessary\n\t\t\t\t */\n\t\t\t\t*reg_mask &= ~dreg;\n\t\t\t}\n\t\t} else {\n\t\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\t\t/* dreg += sreg\n\t\t\t\t * both dreg and sreg need precision\n\t\t\t\t * before this insn\n\t\t\t\t */\n\t\t\t\t*reg_mask |= sreg;\n\t\t\t} /* else dreg += K\n\t\t\t   * dreg still needs precision before this insn\n\t\t\t   */\n\t\t}\n\t} else if (class == BPF_LDX) {\n\t\tif (!(*reg_mask & dreg))\n\t\t\treturn 0;\n\t\t*reg_mask &= ~dreg;\n\n\t\t/* scalars can only be spilled into stack w/o losing precision.\n\t\t * Load from any other memory can be zero extended.\n\t\t * The desire to keep that precision is already indicated\n\t\t * by 'precise' mark in corresponding register of this state.\n\t\t * No further tracking necessary.\n\t\t */\n\t\tif (insn->src_reg != BPF_REG_FP)\n\t\t\treturn 0;\n\t\tif (BPF_SIZE(insn->code) != BPF_DW)\n\t\t\treturn 0;\n\n\t\t/* dreg = *(u64 *)[fp - off] was a fill from the stack.\n\t\t * that [fp - off] slot contains scalar that needs to be\n\t\t * tracked with precision\n\t\t */\n\t\tspi = (-insn->off - 1) / BPF_REG_SIZE;\n\t\tif (spi >= 64) {\n\t\t\tverbose(env, \"BUG spi %d\\n\", spi);\n\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\t*stack_mask |= 1ull << spi;\n\t} else if (class == BPF_STX || class == BPF_ST) {\n\t\tif (*reg_mask & dreg)\n\t\t\t/* stx & st shouldn't be using _scalar_ dst_reg\n\t\t\t * to access memory. It means backtracking\n\t\t\t * encountered a case of pointer subtraction.\n\t\t\t */\n\t\t\treturn -ENOTSUPP;\n\t\t/* scalars can only be spilled into stack */\n\t\tif (insn->dst_reg != BPF_REG_FP)\n\t\t\treturn 0;\n\t\tif (BPF_SIZE(insn->code) != BPF_DW)\n\t\t\treturn 0;\n\t\tspi = (-insn->off - 1) / BPF_REG_SIZE;\n\t\tif (spi >= 64) {\n\t\t\tverbose(env, \"BUG spi %d\\n\", spi);\n\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (!(*stack_mask & (1ull << spi)))\n\t\t\treturn 0;\n\t\t*stack_mask &= ~(1ull << spi);\n\t\tif (class == BPF_STX)\n\t\t\t*reg_mask |= sreg;\n\t} else if (class == BPF_JMP || class == BPF_JMP32) {\n\t\tif (opcode == BPF_CALL) {\n\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t/* regular helper call sets R0 */\n\t\t\t*reg_mask &= ~1;\n\t\t\tif (*reg_mask & 0x3f) {\n\t\t\t\t/* if backtracing was looking for registers R1-R5\n\t\t\t\t * they should have been found already.\n\t\t\t\t */\n\t\t\t\tverbose(env, \"BUG regs %x\\n\", *reg_mask);\n\t\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else if (opcode == BPF_EXIT) {\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t} else if (class == BPF_LD) {\n\t\tif (!(*reg_mask & dreg))\n\t\t\treturn 0;\n\t\t*reg_mask &= ~dreg;\n\t\t/* It's ld_imm64 or ld_abs or ld_ind.\n\t\t * For ld_imm64 no further tracking of precision\n\t\t * into parent is necessary\n\t\t */\n\t\tif (mode == BPF_IND || mode == BPF_ABS)\n\t\t\t/* to be analyzed */\n\t\t\treturn -ENOTSUPP;\n\t}\n\treturn 0;\n}\n\n/* the scalar precision tracking algorithm:\n * . at the start all registers have precise=false.\n * . scalar ranges are tracked as normal through alu and jmp insns.\n * . once precise value of the scalar register is used in:\n *   .  ptr + scalar alu\n *   . if (scalar cond K|scalar)\n *   .  helper_call(.., scalar, ...) where ARG_CONST is expected\n *   backtrack through the verifier states and mark all registers and\n *   stack slots with spilled constants that these scalar regisers\n *   should be precise.\n * . during state pruning two registers (or spilled stack slots)\n *   are equivalent if both are not precise.\n *\n * Note the verifier cannot simply walk register parentage chain,\n * since many different registers and stack slots could have been\n * used to compute single precise scalar.\n *\n * The approach of starting with precise=true for all registers and then\n * backtrack to mark a register as not precise when the verifier detects\n * that program doesn't care about specific value (e.g., when helper\n * takes register as ARG_ANYTHING parameter) is not safe.\n *\n * It's ok to walk single parentage chain of the verifier states.\n * It's possible that this backtracking will go all the way till 1st insn.\n * All other branches will be explored for needing precision later.\n *\n * The backtracking needs to deal with cases like:\n *   R8=map_value(id=0,off=0,ks=4,vs=1952,imm=0) R9_w=map_value(id=0,off=40,ks=4,vs=1952,imm=0)\n * r9 -= r8\n * r5 = r9\n * if r5 > 0x79f goto pc+7\n *    R5_w=inv(id=0,umax_value=1951,var_off=(0x0; 0x7ff))\n * r5 += 1\n * ...\n * call bpf_perf_event_output#25\n *   where .arg5_type = ARG_CONST_SIZE_OR_ZERO\n *\n * and this case:\n * r6 = 1\n * call foo // uses callee's r6 inside to compute r0\n * r0 += r6\n * if r0 == 0 goto\n *\n * to track above reg_mask/stack_mask needs to be independent for each frame.\n *\n * Also if parent's curframe > frame where backtracking started,\n * the verifier need to mark registers in both frames, otherwise callees\n * may incorrectly prune callers. This is similar to\n * commit 7640ead93924 (\"bpf: verifier: make sure callees don't prune with caller differences\")\n *\n * For now backtracking falls back into conservative marking.\n */\nstatic void mark_all_scalars_precise(struct bpf_verifier_env *env,\n\t\t\t\t     struct bpf_verifier_state *st)\n{\n\tstruct bpf_func_state *func;\n\tstruct bpf_reg_state *reg;\n\tint i, j;\n\n\t/* big hammer: mark all scalars precise in this path.\n\t * pop_stack may still get !precise scalars.\n\t */\n\tfor (; st; st = st->parent)\n\t\tfor (i = 0; i <= st->curframe; i++) {\n\t\t\tfunc = st->frame[i];\n\t\t\tfor (j = 0; j < BPF_REG_FP; j++) {\n\t\t\t\treg = &func->regs[j];\n\t\t\t\tif (reg->type != SCALAR_VALUE)\n\t\t\t\t\tcontinue;\n\t\t\t\treg->precise = true;\n\t\t\t}\n\t\t\tfor (j = 0; j < func->allocated_stack / BPF_REG_SIZE; j++) {\n\t\t\t\tif (func->stack[j].slot_type[0] != STACK_SPILL)\n\t\t\t\t\tcontinue;\n\t\t\t\treg = &func->stack[j].spilled_ptr;\n\t\t\t\tif (reg->type != SCALAR_VALUE)\n\t\t\t\t\tcontinue;\n\t\t\t\treg->precise = true;\n\t\t\t}\n\t\t}\n}\n\nstatic int __mark_chain_precision(struct bpf_verifier_env *env, int regno,\n\t\t\t\t  int spi)\n{\n\tstruct bpf_verifier_state *st = env->cur_state;\n\tint first_idx = st->first_insn_idx;\n\tint last_idx = env->insn_idx;\n\tstruct bpf_func_state *func;\n\tstruct bpf_reg_state *reg;\n\tu32 reg_mask = regno >= 0 ? 1u << regno : 0;\n\tu64 stack_mask = spi >= 0 ? 1ull << spi : 0;\n\tbool skip_first = true;\n\tbool new_marks = false;\n\tint i, err;\n\n\tif (!env->bpf_capable)\n\t\treturn 0;\n\n\tfunc = st->frame[st->curframe];\n\tif (regno >= 0) {\n\t\treg = &func->regs[regno];\n\t\tif (reg->type != SCALAR_VALUE) {\n\t\t\tWARN_ONCE(1, \"backtracing misuse\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (!reg->precise)\n\t\t\tnew_marks = true;\n\t\telse\n\t\t\treg_mask = 0;\n\t\treg->precise = true;\n\t}\n\n\twhile (spi >= 0) {\n\t\tif (func->stack[spi].slot_type[0] != STACK_SPILL) {\n\t\t\tstack_mask = 0;\n\t\t\tbreak;\n\t\t}\n\t\treg = &func->stack[spi].spilled_ptr;\n\t\tif (reg->type != SCALAR_VALUE) {\n\t\t\tstack_mask = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!reg->precise)\n\t\t\tnew_marks = true;\n\t\telse\n\t\t\tstack_mask = 0;\n\t\treg->precise = true;\n\t\tbreak;\n\t}\n\n\tif (!new_marks)\n\t\treturn 0;\n\tif (!reg_mask && !stack_mask)\n\t\treturn 0;\n\tfor (;;) {\n\t\tDECLARE_BITMAP(mask, 64);\n\t\tu32 history = st->jmp_history_cnt;\n\n\t\tif (env->log.level & BPF_LOG_LEVEL)\n\t\t\tverbose(env, \"last_idx %d first_idx %d\\n\", last_idx, first_idx);\n\t\tfor (i = last_idx;;) {\n\t\t\tif (skip_first) {\n\t\t\t\terr = 0;\n\t\t\t\tskip_first = false;\n\t\t\t} else {\n\t\t\t\terr = backtrack_insn(env, i, &reg_mask, &stack_mask);\n\t\t\t}\n\t\t\tif (err == -ENOTSUPP) {\n\t\t\t\tmark_all_scalars_precise(env, st);\n\t\t\t\treturn 0;\n\t\t\t} else if (err) {\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (!reg_mask && !stack_mask)\n\t\t\t\t/* Found assignment(s) into tracked register in this state.\n\t\t\t\t * Since this state is already marked, just return.\n\t\t\t\t * Nothing to be tracked further in the parent state.\n\t\t\t\t */\n\t\t\t\treturn 0;\n\t\t\tif (i == first_idx)\n\t\t\t\tbreak;\n\t\t\ti = get_prev_insn_idx(st, i, &history);\n\t\t\tif (i >= env->prog->len) {\n\t\t\t\t/* This can happen if backtracking reached insn 0\n\t\t\t\t * and there are still reg_mask or stack_mask\n\t\t\t\t * to backtrack.\n\t\t\t\t * It means the backtracking missed the spot where\n\t\t\t\t * particular register was initialized with a constant.\n\t\t\t\t */\n\t\t\t\tverbose(env, \"BUG backtracking idx %d\\n\", i);\n\t\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\t\tst = st->parent;\n\t\tif (!st)\n\t\t\tbreak;\n\n\t\tnew_marks = false;\n\t\tfunc = st->frame[st->curframe];\n\t\tbitmap_from_u64(mask, reg_mask);\n\t\tfor_each_set_bit(i, mask, 32) {\n\t\t\treg = &func->regs[i];\n\t\t\tif (reg->type != SCALAR_VALUE) {\n\t\t\t\treg_mask &= ~(1u << i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!reg->precise)\n\t\t\t\tnew_marks = true;\n\t\t\treg->precise = true;\n\t\t}\n\n\t\tbitmap_from_u64(mask, stack_mask);\n\t\tfor_each_set_bit(i, mask, 64) {\n\t\t\tif (i >= func->allocated_stack / BPF_REG_SIZE) {\n\t\t\t\t/* the sequence of instructions:\n\t\t\t\t * 2: (bf) r3 = r10\n\t\t\t\t * 3: (7b) *(u64 *)(r3 -8) = r0\n\t\t\t\t * 4: (79) r4 = *(u64 *)(r10 -8)\n\t\t\t\t * doesn't contain jmps. It's backtracked\n\t\t\t\t * as a single block.\n\t\t\t\t * During backtracking insn 3 is not recognized as\n\t\t\t\t * stack access, so at the end of backtracking\n\t\t\t\t * stack slot fp-8 is still marked in stack_mask.\n\t\t\t\t * However the parent state may not have accessed\n\t\t\t\t * fp-8 and it's \"unallocated\" stack space.\n\t\t\t\t * In such case fallback to conservative.\n\t\t\t\t */\n\t\t\t\tmark_all_scalars_precise(env, st);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (func->stack[i].slot_type[0] != STACK_SPILL) {\n\t\t\t\tstack_mask &= ~(1ull << i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treg = &func->stack[i].spilled_ptr;\n\t\t\tif (reg->type != SCALAR_VALUE) {\n\t\t\t\tstack_mask &= ~(1ull << i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!reg->precise)\n\t\t\t\tnew_marks = true;\n\t\t\treg->precise = true;\n\t\t}\n\t\tif (env->log.level & BPF_LOG_LEVEL) {\n\t\t\tprint_verifier_state(env, func);\n\t\t\tverbose(env, \"parent %s regs=%x stack=%llx marks\\n\",\n\t\t\t\tnew_marks ? \"didn't have\" : \"already had\",\n\t\t\t\treg_mask, stack_mask);\n\t\t}\n\n\t\tif (!reg_mask && !stack_mask)\n\t\t\tbreak;\n\t\tif (!new_marks)\n\t\t\tbreak;\n\n\t\tlast_idx = st->last_insn_idx;\n\t\tfirst_idx = st->first_insn_idx;\n\t}\n\treturn 0;\n}\n\nstatic int mark_chain_precision(struct bpf_verifier_env *env, int regno)\n{\n\treturn __mark_chain_precision(env, regno, -1);\n}\n\nstatic int mark_chain_precision_stack(struct bpf_verifier_env *env, int spi)\n{\n\treturn __mark_chain_precision(env, -1, spi);\n}\n\nstatic bool is_spillable_regtype(enum bpf_reg_type type)\n{\n\tswitch (type) {\n\tcase PTR_TO_MAP_VALUE:\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\tcase PTR_TO_STACK:\n\tcase PTR_TO_CTX:\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\tcase PTR_TO_PACKET_END:\n\tcase PTR_TO_FLOW_KEYS:\n\tcase CONST_PTR_TO_MAP:\n\tcase PTR_TO_SOCKET:\n\tcase PTR_TO_SOCKET_OR_NULL:\n\tcase PTR_TO_SOCK_COMMON:\n\tcase PTR_TO_SOCK_COMMON_OR_NULL:\n\tcase PTR_TO_TCP_SOCK:\n\tcase PTR_TO_TCP_SOCK_OR_NULL:\n\tcase PTR_TO_XDP_SOCK:\n\tcase PTR_TO_BTF_ID:\n\tcase PTR_TO_BTF_ID_OR_NULL:\n\tcase PTR_TO_RDONLY_BUF:\n\tcase PTR_TO_RDONLY_BUF_OR_NULL:\n\tcase PTR_TO_RDWR_BUF:\n\tcase PTR_TO_RDWR_BUF_OR_NULL:\n\tcase PTR_TO_PERCPU_BTF_ID:\n\tcase PTR_TO_MEM:\n\tcase PTR_TO_MEM_OR_NULL:\n\tcase PTR_TO_FUNC:\n\tcase PTR_TO_MAP_KEY:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n/* Does this register contain a constant zero? */\nstatic bool register_is_null(struct bpf_reg_state *reg)\n{\n\treturn reg->type == SCALAR_VALUE && tnum_equals_const(reg->var_off, 0);\n}\n\nstatic bool register_is_const(struct bpf_reg_state *reg)\n{\n\treturn reg->type == SCALAR_VALUE && tnum_is_const(reg->var_off);\n}\n\nstatic bool __is_scalar_unbounded(struct bpf_reg_state *reg)\n{\n\treturn tnum_is_unknown(reg->var_off) &&\n\t       reg->smin_value == S64_MIN && reg->smax_value == S64_MAX &&\n\t       reg->umin_value == 0 && reg->umax_value == U64_MAX &&\n\t       reg->s32_min_value == S32_MIN && reg->s32_max_value == S32_MAX &&\n\t       reg->u32_min_value == 0 && reg->u32_max_value == U32_MAX;\n}\n\nstatic bool register_is_bounded(struct bpf_reg_state *reg)\n{\n\treturn reg->type == SCALAR_VALUE && !__is_scalar_unbounded(reg);\n}\n\nstatic bool __is_pointer_value(bool allow_ptr_leaks,\n\t\t\t       const struct bpf_reg_state *reg)\n{\n\tif (allow_ptr_leaks)\n\t\treturn false;\n\n\treturn reg->type != SCALAR_VALUE;\n}\n\nstatic void save_register_state(struct bpf_func_state *state,\n\t\t\t\tint spi, struct bpf_reg_state *reg)\n{\n\tint i;\n\n\tstate->stack[spi].spilled_ptr = *reg;\n\tstate->stack[spi].spilled_ptr.live |= REG_LIVE_WRITTEN;\n\n\tfor (i = 0; i < BPF_REG_SIZE; i++)\n\t\tstate->stack[spi].slot_type[i] = STACK_SPILL;\n}\n\n/* check_stack_{read,write}_fixed_off functions track spill/fill of registers,\n * stack boundary and alignment are checked in check_mem_access()\n */\nstatic int check_stack_write_fixed_off(struct bpf_verifier_env *env,\n\t\t\t\t       /* stack frame we're writing to */\n\t\t\t\t       struct bpf_func_state *state,\n\t\t\t\t       int off, int size, int value_regno,\n\t\t\t\t       int insn_idx)\n{\n\tstruct bpf_func_state *cur; /* state of the current function */\n\tint i, slot = -off - 1, spi = slot / BPF_REG_SIZE, err;\n\tu32 dst_reg = env->prog->insnsi[insn_idx].dst_reg;\n\tstruct bpf_reg_state *reg = NULL;\n\n\terr = realloc_func_state(state, round_up(slot + 1, BPF_REG_SIZE),\n\t\t\t\t state->acquired_refs, true);\n\tif (err)\n\t\treturn err;\n\t/* caller checked that off % size == 0 and -MAX_BPF_STACK <= off < 0,\n\t * so it's aligned access and [off, off + size) are within stack limits\n\t */\n\tif (!env->allow_ptr_leaks &&\n\t    state->stack[spi].slot_type[0] == STACK_SPILL &&\n\t    size != BPF_REG_SIZE) {\n\t\tverbose(env, \"attempt to corrupt spilled pointer on stack\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tcur = env->cur_state->frame[env->cur_state->curframe];\n\tif (value_regno >= 0)\n\t\treg = &cur->regs[value_regno];\n\n\tif (reg && size == BPF_REG_SIZE && register_is_bounded(reg) &&\n\t    !register_is_null(reg) && env->bpf_capable) {\n\t\tif (dst_reg != BPF_REG_FP) {\n\t\t\t/* The backtracking logic can only recognize explicit\n\t\t\t * stack slot address like [fp - 8]. Other spill of\n\t\t\t * scalar via different register has to be conervative.\n\t\t\t * Backtrack from here and mark all registers as precise\n\t\t\t * that contributed into 'reg' being a constant.\n\t\t\t */\n\t\t\terr = mark_chain_precision(env, value_regno);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tsave_register_state(state, spi, reg);\n\t} else if (reg && is_spillable_regtype(reg->type)) {\n\t\t/* register containing pointer is being spilled into stack */\n\t\tif (size != BPF_REG_SIZE) {\n\t\t\tverbose_linfo(env, insn_idx, \"; \");\n\t\t\tverbose(env, \"invalid size of register spill\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (state != cur && reg->type == PTR_TO_STACK) {\n\t\t\tverbose(env, \"cannot spill pointers to stack into stack frame of the caller\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!env->bypass_spec_v4) {\n\t\t\tbool sanitize = false;\n\n\t\t\tif (state->stack[spi].slot_type[0] == STACK_SPILL &&\n\t\t\t    register_is_const(&state->stack[spi].spilled_ptr))\n\t\t\t\tsanitize = true;\n\t\t\tfor (i = 0; i < BPF_REG_SIZE; i++)\n\t\t\t\tif (state->stack[spi].slot_type[i] == STACK_MISC) {\n\t\t\t\t\tsanitize = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (sanitize) {\n\t\t\t\tint *poff = &env->insn_aux_data[insn_idx].sanitize_stack_off;\n\t\t\t\tint soff = (-spi - 1) * BPF_REG_SIZE;\n\n\t\t\t\t/* detected reuse of integer stack slot with a pointer\n\t\t\t\t * which means either llvm is reusing stack slot or\n\t\t\t\t * an attacker is trying to exploit CVE-2018-3639\n\t\t\t\t * (speculative store bypass)\n\t\t\t\t * Have to sanitize that slot with preemptive\n\t\t\t\t * store of zero.\n\t\t\t\t */\n\t\t\t\tif (*poff && *poff != soff) {\n\t\t\t\t\t/* disallow programs where single insn stores\n\t\t\t\t\t * into two different stack slots, since verifier\n\t\t\t\t\t * cannot sanitize them\n\t\t\t\t\t */\n\t\t\t\t\tverbose(env,\n\t\t\t\t\t\t\"insn %d cannot access two stack slots fp%d and fp%d\",\n\t\t\t\t\t\tinsn_idx, *poff, soff);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\t*poff = soff;\n\t\t\t}\n\t\t}\n\t\tsave_register_state(state, spi, reg);\n\t} else {\n\t\tu8 type = STACK_MISC;\n\n\t\t/* regular write of data into stack destroys any spilled ptr */\n\t\tstate->stack[spi].spilled_ptr.type = NOT_INIT;\n\t\t/* Mark slots as STACK_MISC if they belonged to spilled ptr. */\n\t\tif (state->stack[spi].slot_type[0] == STACK_SPILL)\n\t\t\tfor (i = 0; i < BPF_REG_SIZE; i++)\n\t\t\t\tstate->stack[spi].slot_type[i] = STACK_MISC;\n\n\t\t/* only mark the slot as written if all 8 bytes were written\n\t\t * otherwise read propagation may incorrectly stop too soon\n\t\t * when stack slots are partially written.\n\t\t * This heuristic means that read propagation will be\n\t\t * conservative, since it will add reg_live_read marks\n\t\t * to stack slots all the way to first state when programs\n\t\t * writes+reads less than 8 bytes\n\t\t */\n\t\tif (size == BPF_REG_SIZE)\n\t\t\tstate->stack[spi].spilled_ptr.live |= REG_LIVE_WRITTEN;\n\n\t\t/* when we zero initialize stack slots mark them as such */\n\t\tif (reg && register_is_null(reg)) {\n\t\t\t/* backtracking doesn't work for STACK_ZERO yet. */\n\t\t\terr = mark_chain_precision(env, value_regno);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\ttype = STACK_ZERO;\n\t\t}\n\n\t\t/* Mark slots affected by this stack write. */\n\t\tfor (i = 0; i < size; i++)\n\t\t\tstate->stack[spi].slot_type[(slot - i) % BPF_REG_SIZE] =\n\t\t\t\ttype;\n\t}\n\treturn 0;\n}\n\n/* Write the stack: 'stack[ptr_regno + off] = value_regno'. 'ptr_regno' is\n * known to contain a variable offset.\n * This function checks whether the write is permitted and conservatively\n * tracks the effects of the write, considering that each stack slot in the\n * dynamic range is potentially written to.\n *\n * 'off' includes 'regno->off'.\n * 'value_regno' can be -1, meaning that an unknown value is being written to\n * the stack.\n *\n * Spilled pointers in range are not marked as written because we don't know\n * what's going to be actually written. This means that read propagation for\n * future reads cannot be terminated by this write.\n *\n * For privileged programs, uninitialized stack slots are considered\n * initialized by this write (even though we don't know exactly what offsets\n * are going to be written to). The idea is that we don't want the verifier to\n * reject future reads that access slots written to through variable offsets.\n */\nstatic int check_stack_write_var_off(struct bpf_verifier_env *env,\n\t\t\t\t     /* func where register points to */\n\t\t\t\t     struct bpf_func_state *state,\n\t\t\t\t     int ptr_regno, int off, int size,\n\t\t\t\t     int value_regno, int insn_idx)\n{\n\tstruct bpf_func_state *cur; /* state of the current function */\n\tint min_off, max_off;\n\tint i, err;\n\tstruct bpf_reg_state *ptr_reg = NULL, *value_reg = NULL;\n\tbool writing_zero = false;\n\t/* set if the fact that we're writing a zero is used to let any\n\t * stack slots remain STACK_ZERO\n\t */\n\tbool zero_used = false;\n\n\tcur = env->cur_state->frame[env->cur_state->curframe];\n\tptr_reg = &cur->regs[ptr_regno];\n\tmin_off = ptr_reg->smin_value + off;\n\tmax_off = ptr_reg->smax_value + off + size;\n\tif (value_regno >= 0)\n\t\tvalue_reg = &cur->regs[value_regno];\n\tif (value_reg && register_is_null(value_reg))\n\t\twriting_zero = true;\n\n\terr = realloc_func_state(state, round_up(-min_off, BPF_REG_SIZE),\n\t\t\t\t state->acquired_refs, true);\n\tif (err)\n\t\treturn err;\n\n\n\t/* Variable offset writes destroy any spilled pointers in range. */\n\tfor (i = min_off; i < max_off; i++) {\n\t\tu8 new_type, *stype;\n\t\tint slot, spi;\n\n\t\tslot = -i - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tstype = &state->stack[spi].slot_type[slot % BPF_REG_SIZE];\n\n\t\tif (!env->allow_ptr_leaks\n\t\t\t\t&& *stype != NOT_INIT\n\t\t\t\t&& *stype != SCALAR_VALUE) {\n\t\t\t/* Reject the write if there's are spilled pointers in\n\t\t\t * range. If we didn't reject here, the ptr status\n\t\t\t * would be erased below (even though not all slots are\n\t\t\t * actually overwritten), possibly opening the door to\n\t\t\t * leaks.\n\t\t\t */\n\t\t\tverbose(env, \"spilled ptr in range of var-offset stack write; insn %d, ptr off: %d\",\n\t\t\t\tinsn_idx, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Erase all spilled pointers. */\n\t\tstate->stack[spi].spilled_ptr.type = NOT_INIT;\n\n\t\t/* Update the slot type. */\n\t\tnew_type = STACK_MISC;\n\t\tif (writing_zero && *stype == STACK_ZERO) {\n\t\t\tnew_type = STACK_ZERO;\n\t\t\tzero_used = true;\n\t\t}\n\t\t/* If the slot is STACK_INVALID, we check whether it's OK to\n\t\t * pretend that it will be initialized by this write. The slot\n\t\t * might not actually be written to, and so if we mark it as\n\t\t * initialized future reads might leak uninitialized memory.\n\t\t * For privileged programs, we will accept such reads to slots\n\t\t * that may or may not be written because, if we're reject\n\t\t * them, the error would be too confusing.\n\t\t */\n\t\tif (*stype == STACK_INVALID && !env->allow_uninit_stack) {\n\t\t\tverbose(env, \"uninit stack in range of var-offset write prohibited for !root; insn %d, off: %d\",\n\t\t\t\t\tinsn_idx, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*stype = new_type;\n\t}\n\tif (zero_used) {\n\t\t/* backtracking doesn't work for STACK_ZERO yet. */\n\t\terr = mark_chain_precision(env, value_regno);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n/* When register 'dst_regno' is assigned some values from stack[min_off,\n * max_off), we set the register's type according to the types of the\n * respective stack slots. If all the stack values are known to be zeros, then\n * so is the destination reg. Otherwise, the register is considered to be\n * SCALAR. This function does not deal with register filling; the caller must\n * ensure that all spilled registers in the stack range have been marked as\n * read.\n */\nstatic void mark_reg_stack_read(struct bpf_verifier_env *env,\n\t\t\t\t/* func where src register points to */\n\t\t\t\tstruct bpf_func_state *ptr_state,\n\t\t\t\tint min_off, int max_off, int dst_regno)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tint i, slot, spi;\n\tu8 *stype;\n\tint zeros = 0;\n\n\tfor (i = min_off; i < max_off; i++) {\n\t\tslot = -i - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tstype = ptr_state->stack[spi].slot_type;\n\t\tif (stype[slot % BPF_REG_SIZE] != STACK_ZERO)\n\t\t\tbreak;\n\t\tzeros++;\n\t}\n\tif (zeros == max_off - min_off) {\n\t\t/* any access_size read into register is zero extended,\n\t\t * so the whole register == const_zero\n\t\t */\n\t\t__mark_reg_const_zero(&state->regs[dst_regno]);\n\t\t/* backtracking doesn't support STACK_ZERO yet,\n\t\t * so mark it precise here, so that later\n\t\t * backtracking can stop here.\n\t\t * Backtracking may not need this if this register\n\t\t * doesn't participate in pointer adjustment.\n\t\t * Forward propagation of precise flag is not\n\t\t * necessary either. This mark is only to stop\n\t\t * backtracking. Any register that contributed\n\t\t * to const 0 was marked precise before spill.\n\t\t */\n\t\tstate->regs[dst_regno].precise = true;\n\t} else {\n\t\t/* have read misc data from the stack */\n\t\tmark_reg_unknown(env, state->regs, dst_regno);\n\t}\n\tstate->regs[dst_regno].live |= REG_LIVE_WRITTEN;\n}\n\n/* Read the stack at 'off' and put the results into the register indicated by\n * 'dst_regno'. It handles reg filling if the addressed stack slot is a\n * spilled reg.\n *\n * 'dst_regno' can be -1, meaning that the read value is not going to a\n * register.\n *\n * The access is assumed to be within the current stack bounds.\n */\nstatic int check_stack_read_fixed_off(struct bpf_verifier_env *env,\n\t\t\t\t      /* func where src register points to */\n\t\t\t\t      struct bpf_func_state *reg_state,\n\t\t\t\t      int off, int size, int dst_regno)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tint i, slot = -off - 1, spi = slot / BPF_REG_SIZE;\n\tstruct bpf_reg_state *reg;\n\tu8 *stype;\n\n\tstype = reg_state->stack[spi].slot_type;\n\treg = &reg_state->stack[spi].spilled_ptr;\n\n\tif (stype[0] == STACK_SPILL) {\n\t\tif (size != BPF_REG_SIZE) {\n\t\t\tif (reg->type != SCALAR_VALUE) {\n\t\t\t\tverbose_linfo(env, env->insn_idx, \"; \");\n\t\t\t\tverbose(env, \"invalid size of register fill\\n\");\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tif (dst_regno >= 0) {\n\t\t\t\tmark_reg_unknown(env, state->regs, dst_regno);\n\t\t\t\tstate->regs[dst_regno].live |= REG_LIVE_WRITTEN;\n\t\t\t}\n\t\t\tmark_reg_read(env, reg, reg->parent, REG_LIVE_READ64);\n\t\t\treturn 0;\n\t\t}\n\t\tfor (i = 1; i < BPF_REG_SIZE; i++) {\n\t\t\tif (stype[(slot - i) % BPF_REG_SIZE] != STACK_SPILL) {\n\t\t\t\tverbose(env, \"corrupted spill memory\\n\");\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t}\n\n\t\tif (dst_regno >= 0) {\n\t\t\t/* restore register state from stack */\n\t\t\tstate->regs[dst_regno] = *reg;\n\t\t\t/* mark reg as written since spilled pointer state likely\n\t\t\t * has its liveness marks cleared by is_state_visited()\n\t\t\t * which resets stack/reg liveness for state transitions\n\t\t\t */\n\t\t\tstate->regs[dst_regno].live |= REG_LIVE_WRITTEN;\n\t\t} else if (__is_pointer_value(env->allow_ptr_leaks, reg)) {\n\t\t\t/* If dst_regno==-1, the caller is asking us whether\n\t\t\t * it is acceptable to use this value as a SCALAR_VALUE\n\t\t\t * (e.g. for XADD).\n\t\t\t * We must not allow unprivileged callers to do that\n\t\t\t * with spilled pointers.\n\t\t\t */\n\t\t\tverbose(env, \"leaking pointer from stack off %d\\n\",\n\t\t\t\toff);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmark_reg_read(env, reg, reg->parent, REG_LIVE_READ64);\n\t} else {\n\t\tu8 type;\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\ttype = stype[(slot - i) % BPF_REG_SIZE];\n\t\t\tif (type == STACK_MISC)\n\t\t\t\tcontinue;\n\t\t\tif (type == STACK_ZERO)\n\t\t\t\tcontinue;\n\t\t\tverbose(env, \"invalid read from stack off %d+%d size %d\\n\",\n\t\t\t\toff, i, size);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmark_reg_read(env, reg, reg->parent, REG_LIVE_READ64);\n\t\tif (dst_regno >= 0)\n\t\t\tmark_reg_stack_read(env, reg_state, off, off + size, dst_regno);\n\t}\n\treturn 0;\n}\n\nenum stack_access_src {\n\tACCESS_DIRECT = 1,  /* the access is performed by an instruction */\n\tACCESS_HELPER = 2,  /* the access is performed by a helper */\n};\n\nstatic int check_stack_range_initialized(struct bpf_verifier_env *env,\n\t\t\t\t\t int regno, int off, int access_size,\n\t\t\t\t\t bool zero_size_allowed,\n\t\t\t\t\t enum stack_access_src type,\n\t\t\t\t\t struct bpf_call_arg_meta *meta);\n\nstatic struct bpf_reg_state *reg_state(struct bpf_verifier_env *env, int regno)\n{\n\treturn cur_regs(env) + regno;\n}\n\n/* Read the stack at 'ptr_regno + off' and put the result into the register\n * 'dst_regno'.\n * 'off' includes the pointer register's fixed offset(i.e. 'ptr_regno.off'),\n * but not its variable offset.\n * 'size' is assumed to be <= reg size and the access is assumed to be aligned.\n *\n * As opposed to check_stack_read_fixed_off, this function doesn't deal with\n * filling registers (i.e. reads of spilled register cannot be detected when\n * the offset is not fixed). We conservatively mark 'dst_regno' as containing\n * SCALAR_VALUE. That's why we assert that the 'ptr_regno' has a variable\n * offset; for a fixed offset check_stack_read_fixed_off should be used\n * instead.\n */\nstatic int check_stack_read_var_off(struct bpf_verifier_env *env,\n\t\t\t\t    int ptr_regno, int off, int size, int dst_regno)\n{\n\t/* The state of the source register. */\n\tstruct bpf_reg_state *reg = reg_state(env, ptr_regno);\n\tstruct bpf_func_state *ptr_state = func(env, reg);\n\tint err;\n\tint min_off, max_off;\n\n\t/* Note that we pass a NULL meta, so raw access will not be permitted.\n\t */\n\terr = check_stack_range_initialized(env, ptr_regno, off, size,\n\t\t\t\t\t    false, ACCESS_DIRECT, NULL);\n\tif (err)\n\t\treturn err;\n\n\tmin_off = reg->smin_value + off;\n\tmax_off = reg->smax_value + off;\n\tmark_reg_stack_read(env, ptr_state, min_off, max_off + size, dst_regno);\n\treturn 0;\n}\n\n/* check_stack_read dispatches to check_stack_read_fixed_off or\n * check_stack_read_var_off.\n *\n * The caller must ensure that the offset falls within the allocated stack\n * bounds.\n *\n * 'dst_regno' is a register which will receive the value from the stack. It\n * can be -1, meaning that the read value is not going to a register.\n */\nstatic int check_stack_read(struct bpf_verifier_env *env,\n\t\t\t    int ptr_regno, int off, int size,\n\t\t\t    int dst_regno)\n{\n\tstruct bpf_reg_state *reg = reg_state(env, ptr_regno);\n\tstruct bpf_func_state *state = func(env, reg);\n\tint err;\n\t/* Some accesses are only permitted with a static offset. */\n\tbool var_off = !tnum_is_const(reg->var_off);\n\n\t/* The offset is required to be static when reads don't go to a\n\t * register, in order to not leak pointers (see\n\t * check_stack_read_fixed_off).\n\t */\n\tif (dst_regno < 0 && var_off) {\n\t\tchar tn_buf[48];\n\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\tverbose(env, \"variable offset stack pointer cannot be passed into helper function; var_off=%s off=%d size=%d\\n\",\n\t\t\ttn_buf, off, size);\n\t\treturn -EACCES;\n\t}\n\t/* Variable offset is prohibited for unprivileged mode for simplicity\n\t * since it requires corresponding support in Spectre masking for stack\n\t * ALU. See also retrieve_ptr_limit().\n\t */\n\tif (!env->bypass_spec_v1 && var_off) {\n\t\tchar tn_buf[48];\n\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\tverbose(env, \"R%d variable offset stack access prohibited for !root, var_off=%s\\n\",\n\t\t\t\tptr_regno, tn_buf);\n\t\treturn -EACCES;\n\t}\n\n\tif (!var_off) {\n\t\toff += reg->var_off.value;\n\t\terr = check_stack_read_fixed_off(env, state, off, size,\n\t\t\t\t\t\t dst_regno);\n\t} else {\n\t\t/* Variable offset stack reads need more conservative handling\n\t\t * than fixed offset ones. Note that dst_regno >= 0 on this\n\t\t * branch.\n\t\t */\n\t\terr = check_stack_read_var_off(env, ptr_regno, off, size,\n\t\t\t\t\t       dst_regno);\n\t}\n\treturn err;\n}\n\n\n/* check_stack_write dispatches to check_stack_write_fixed_off or\n * check_stack_write_var_off.\n *\n * 'ptr_regno' is the register used as a pointer into the stack.\n * 'off' includes 'ptr_regno->off', but not its variable offset (if any).\n * 'value_regno' is the register whose value we're writing to the stack. It can\n * be -1, meaning that we're not writing from a register.\n *\n * The caller must ensure that the offset falls within the maximum stack size.\n */\nstatic int check_stack_write(struct bpf_verifier_env *env,\n\t\t\t     int ptr_regno, int off, int size,\n\t\t\t     int value_regno, int insn_idx)\n{\n\tstruct bpf_reg_state *reg = reg_state(env, ptr_regno);\n\tstruct bpf_func_state *state = func(env, reg);\n\tint err;\n\n\tif (tnum_is_const(reg->var_off)) {\n\t\toff += reg->var_off.value;\n\t\terr = check_stack_write_fixed_off(env, state, off, size,\n\t\t\t\t\t\t  value_regno, insn_idx);\n\t} else {\n\t\t/* Variable offset stack reads need more conservative handling\n\t\t * than fixed offset ones.\n\t\t */\n\t\terr = check_stack_write_var_off(env, state,\n\t\t\t\t\t\tptr_regno, off, size,\n\t\t\t\t\t\tvalue_regno, insn_idx);\n\t}\n\treturn err;\n}\n\nstatic int check_map_access_type(struct bpf_verifier_env *env, u32 regno,\n\t\t\t\t int off, int size, enum bpf_access_type type)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_map *map = regs[regno].map_ptr;\n\tu32 cap = bpf_map_flags_to_cap(map);\n\n\tif (type == BPF_WRITE && !(cap & BPF_MAP_CAN_WRITE)) {\n\t\tverbose(env, \"write into map forbidden, value_size=%d off=%d size=%d\\n\",\n\t\t\tmap->value_size, off, size);\n\t\treturn -EACCES;\n\t}\n\n\tif (type == BPF_READ && !(cap & BPF_MAP_CAN_READ)) {\n\t\tverbose(env, \"read from map forbidden, value_size=%d off=%d size=%d\\n\",\n\t\t\tmap->value_size, off, size);\n\t\treturn -EACCES;\n\t}\n\n\treturn 0;\n}\n\n/* check read/write into memory region (e.g., map value, ringbuf sample, etc) */\nstatic int __check_mem_access(struct bpf_verifier_env *env, int regno,\n\t\t\t      int off, int size, u32 mem_size,\n\t\t\t      bool zero_size_allowed)\n{\n\tbool size_ok = size > 0 || (size == 0 && zero_size_allowed);\n\tstruct bpf_reg_state *reg;\n\n\tif (off >= 0 && size_ok && (u64)off + size <= mem_size)\n\t\treturn 0;\n\n\treg = &cur_regs(env)[regno];\n\tswitch (reg->type) {\n\tcase PTR_TO_MAP_KEY:\n\t\tverbose(env, \"invalid access to map key, key_size=%d off=%d size=%d\\n\",\n\t\t\tmem_size, off, size);\n\t\tbreak;\n\tcase PTR_TO_MAP_VALUE:\n\t\tverbose(env, \"invalid access to map value, value_size=%d off=%d size=%d\\n\",\n\t\t\tmem_size, off, size);\n\t\tbreak;\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\tcase PTR_TO_PACKET_END:\n\t\tverbose(env, \"invalid access to packet, off=%d size=%d, R%d(id=%d,off=%d,r=%d)\\n\",\n\t\t\toff, size, regno, reg->id, off, mem_size);\n\t\tbreak;\n\tcase PTR_TO_MEM:\n\tdefault:\n\t\tverbose(env, \"invalid access to memory, mem_size=%u off=%d size=%d\\n\",\n\t\t\tmem_size, off, size);\n\t}\n\n\treturn -EACCES;\n}\n\n/* check read/write into a memory region with possible variable offset */\nstatic int check_mem_region_access(struct bpf_verifier_env *env, u32 regno,\n\t\t\t\t   int off, int size, u32 mem_size,\n\t\t\t\t   bool zero_size_allowed)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tstruct bpf_reg_state *reg = &state->regs[regno];\n\tint err;\n\n\t/* We may have adjusted the register pointing to memory region, so we\n\t * need to try adding each of min_value and max_value to off\n\t * to make sure our theoretical access will be safe.\n\t */\n\tif (env->log.level & BPF_LOG_LEVEL)\n\t\tprint_verifier_state(env, state);\n\n\t/* The minimum value is only important with signed\n\t * comparisons where we can't assume the floor of a\n\t * value is 0.  If we are using signed variables for our\n\t * index'es we need to make sure that whatever we use\n\t * will have a set floor within our range.\n\t */\n\tif (reg->smin_value < 0 &&\n\t    (reg->smin_value == S64_MIN ||\n\t     (off + reg->smin_value != (s64)(s32)(off + reg->smin_value)) ||\n\t      reg->smin_value + off < 0)) {\n\t\tverbose(env, \"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",\n\t\t\tregno);\n\t\treturn -EACCES;\n\t}\n\terr = __check_mem_access(env, regno, reg->smin_value + off, size,\n\t\t\t\t mem_size, zero_size_allowed);\n\tif (err) {\n\t\tverbose(env, \"R%d min value is outside of the allowed memory range\\n\",\n\t\t\tregno);\n\t\treturn err;\n\t}\n\n\t/* If we haven't set a max value then we need to bail since we can't be\n\t * sure we won't do bad things.\n\t * If reg->umax_value + off could overflow, treat that as unbounded too.\n\t */\n\tif (reg->umax_value >= BPF_MAX_VAR_OFF) {\n\t\tverbose(env, \"R%d unbounded memory access, make sure to bounds check any such access\\n\",\n\t\t\tregno);\n\t\treturn -EACCES;\n\t}\n\terr = __check_mem_access(env, regno, reg->umax_value + off, size,\n\t\t\t\t mem_size, zero_size_allowed);\n\tif (err) {\n\t\tverbose(env, \"R%d max value is outside of the allowed memory range\\n\",\n\t\t\tregno);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n/* check read/write into a map element with possible variable offset */\nstatic int check_map_access(struct bpf_verifier_env *env, u32 regno,\n\t\t\t    int off, int size, bool zero_size_allowed)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tstruct bpf_reg_state *reg = &state->regs[regno];\n\tstruct bpf_map *map = reg->map_ptr;\n\tint err;\n\n\terr = check_mem_region_access(env, regno, off, size, map->value_size,\n\t\t\t\t      zero_size_allowed);\n\tif (err)\n\t\treturn err;\n\n\tif (map_value_has_spin_lock(map)) {\n\t\tu32 lock = map->spin_lock_off;\n\n\t\t/* if any part of struct bpf_spin_lock can be touched by\n\t\t * load/store reject this program.\n\t\t * To check that [x1, x2) overlaps with [y1, y2)\n\t\t * it is sufficient to check x1 < y2 && y1 < x2.\n\t\t */\n\t\tif (reg->smin_value + off < lock + sizeof(struct bpf_spin_lock) &&\n\t\t     lock < reg->umax_value + off + size) {\n\t\t\tverbose(env, \"bpf_spin_lock cannot be accessed directly by load/store\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn err;\n}\n\n#define MAX_PACKET_OFF 0xffff\n\nstatic enum bpf_prog_type resolve_prog_type(struct bpf_prog *prog)\n{\n\treturn prog->aux->dst_prog ? prog->aux->dst_prog->type : prog->type;\n}\n\nstatic bool may_access_direct_pkt_data(struct bpf_verifier_env *env,\n\t\t\t\t       const struct bpf_call_arg_meta *meta,\n\t\t\t\t       enum bpf_access_type t)\n{\n\tenum bpf_prog_type prog_type = resolve_prog_type(env->prog);\n\n\tswitch (prog_type) {\n\t/* Program types only with direct read access go here! */\n\tcase BPF_PROG_TYPE_LWT_IN:\n\tcase BPF_PROG_TYPE_LWT_OUT:\n\tcase BPF_PROG_TYPE_LWT_SEG6LOCAL:\n\tcase BPF_PROG_TYPE_SK_REUSEPORT:\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\t\tif (t == BPF_WRITE)\n\t\t\treturn false;\n\t\tfallthrough;\n\n\t/* Program types with direct read + write access go here! */\n\tcase BPF_PROG_TYPE_SCHED_CLS:\n\tcase BPF_PROG_TYPE_SCHED_ACT:\n\tcase BPF_PROG_TYPE_XDP:\n\tcase BPF_PROG_TYPE_LWT_XMIT:\n\tcase BPF_PROG_TYPE_SK_SKB:\n\tcase BPF_PROG_TYPE_SK_MSG:\n\t\tif (meta)\n\t\t\treturn meta->pkt_access;\n\n\t\tenv->seen_direct_write = true;\n\t\treturn true;\n\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\t\tif (t == BPF_WRITE)\n\t\t\tenv->seen_direct_write = true;\n\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int check_packet_access(struct bpf_verifier_env *env, u32 regno, int off,\n\t\t\t       int size, bool zero_size_allowed)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = &regs[regno];\n\tint err;\n\n\t/* We may have added a variable offset to the packet pointer; but any\n\t * reg->range we have comes after that.  We are only checking the fixed\n\t * offset.\n\t */\n\n\t/* We don't allow negative numbers, because we aren't tracking enough\n\t * detail to prove they're safe.\n\t */\n\tif (reg->smin_value < 0) {\n\t\tverbose(env, \"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",\n\t\t\tregno);\n\t\treturn -EACCES;\n\t}\n\n\terr = reg->range < 0 ? -EINVAL :\n\t      __check_mem_access(env, regno, off, size, reg->range,\n\t\t\t\t zero_size_allowed);\n\tif (err) {\n\t\tverbose(env, \"R%d offset is outside of the packet\\n\", regno);\n\t\treturn err;\n\t}\n\n\t/* __check_mem_access has made sure \"off + size - 1\" is within u16.\n\t * reg->umax_value can't be bigger than MAX_PACKET_OFF which is 0xffff,\n\t * otherwise find_good_pkt_pointers would have refused to set range info\n\t * that __check_mem_access would have rejected this pkt access.\n\t * Therefore, \"off + reg->umax_value + size - 1\" won't overflow u32.\n\t */\n\tenv->prog->aux->max_pkt_offset =\n\t\tmax_t(u32, env->prog->aux->max_pkt_offset,\n\t\t      off + reg->umax_value + size - 1);\n\n\treturn err;\n}\n\n/* check access to 'struct bpf_context' fields.  Supports fixed offsets only */\nstatic int check_ctx_access(struct bpf_verifier_env *env, int insn_idx, int off, int size,\n\t\t\t    enum bpf_access_type t, enum bpf_reg_type *reg_type,\n\t\t\t    struct btf **btf, u32 *btf_id)\n{\n\tstruct bpf_insn_access_aux info = {\n\t\t.reg_type = *reg_type,\n\t\t.log = &env->log,\n\t};\n\n\tif (env->ops->is_valid_access &&\n\t    env->ops->is_valid_access(off, size, t, env->prog, &info)) {\n\t\t/* A non zero info.ctx_field_size indicates that this field is a\n\t\t * candidate for later verifier transformation to load the whole\n\t\t * field and then apply a mask when accessed with a narrower\n\t\t * access than actual ctx access size. A zero info.ctx_field_size\n\t\t * will only allow for whole field access and rejects any other\n\t\t * type of narrower access.\n\t\t */\n\t\t*reg_type = info.reg_type;\n\n\t\tif (*reg_type == PTR_TO_BTF_ID || *reg_type == PTR_TO_BTF_ID_OR_NULL) {\n\t\t\t*btf = info.btf;\n\t\t\t*btf_id = info.btf_id;\n\t\t} else {\n\t\t\tenv->insn_aux_data[insn_idx].ctx_field_size = info.ctx_field_size;\n\t\t}\n\t\t/* remember the offset of last byte accessed in ctx */\n\t\tif (env->prog->aux->max_ctx_offset < off + size)\n\t\t\tenv->prog->aux->max_ctx_offset = off + size;\n\t\treturn 0;\n\t}\n\n\tverbose(env, \"invalid bpf_context access off=%d size=%d\\n\", off, size);\n\treturn -EACCES;\n}\n\nstatic int check_flow_keys_access(struct bpf_verifier_env *env, int off,\n\t\t\t\t  int size)\n{\n\tif (size < 0 || off < 0 ||\n\t    (u64)off + size > sizeof(struct bpf_flow_keys)) {\n\t\tverbose(env, \"invalid access to flow keys off=%d size=%d\\n\",\n\t\t\toff, size);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}\n\nstatic int check_sock_access(struct bpf_verifier_env *env, int insn_idx,\n\t\t\t     u32 regno, int off, int size,\n\t\t\t     enum bpf_access_type t)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = &regs[regno];\n\tstruct bpf_insn_access_aux info = {};\n\tbool valid;\n\n\tif (reg->smin_value < 0) {\n\t\tverbose(env, \"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",\n\t\t\tregno);\n\t\treturn -EACCES;\n\t}\n\n\tswitch (reg->type) {\n\tcase PTR_TO_SOCK_COMMON:\n\t\tvalid = bpf_sock_common_is_valid_access(off, size, t, &info);\n\t\tbreak;\n\tcase PTR_TO_SOCKET:\n\t\tvalid = bpf_sock_is_valid_access(off, size, t, &info);\n\t\tbreak;\n\tcase PTR_TO_TCP_SOCK:\n\t\tvalid = bpf_tcp_sock_is_valid_access(off, size, t, &info);\n\t\tbreak;\n\tcase PTR_TO_XDP_SOCK:\n\t\tvalid = bpf_xdp_sock_is_valid_access(off, size, t, &info);\n\t\tbreak;\n\tdefault:\n\t\tvalid = false;\n\t}\n\n\n\tif (valid) {\n\t\tenv->insn_aux_data[insn_idx].ctx_field_size =\n\t\t\tinfo.ctx_field_size;\n\t\treturn 0;\n\t}\n\n\tverbose(env, \"R%d invalid %s access off=%d size=%d\\n\",\n\t\tregno, reg_type_str[reg->type], off, size);\n\n\treturn -EACCES;\n}\n\nstatic bool is_pointer_value(struct bpf_verifier_env *env, int regno)\n{\n\treturn __is_pointer_value(env->allow_ptr_leaks, reg_state(env, regno));\n}\n\nstatic bool is_ctx_reg(struct bpf_verifier_env *env, int regno)\n{\n\tconst struct bpf_reg_state *reg = reg_state(env, regno);\n\n\treturn reg->type == PTR_TO_CTX;\n}\n\nstatic bool is_sk_reg(struct bpf_verifier_env *env, int regno)\n{\n\tconst struct bpf_reg_state *reg = reg_state(env, regno);\n\n\treturn type_is_sk_pointer(reg->type);\n}\n\nstatic bool is_pkt_reg(struct bpf_verifier_env *env, int regno)\n{\n\tconst struct bpf_reg_state *reg = reg_state(env, regno);\n\n\treturn type_is_pkt_pointer(reg->type);\n}\n\nstatic bool is_flow_key_reg(struct bpf_verifier_env *env, int regno)\n{\n\tconst struct bpf_reg_state *reg = reg_state(env, regno);\n\n\t/* Separate to is_ctx_reg() since we still want to allow BPF_ST here. */\n\treturn reg->type == PTR_TO_FLOW_KEYS;\n}\n\nstatic int check_pkt_ptr_alignment(struct bpf_verifier_env *env,\n\t\t\t\t   const struct bpf_reg_state *reg,\n\t\t\t\t   int off, int size, bool strict)\n{\n\tstruct tnum reg_off;\n\tint ip_align;\n\n\t/* Byte size accesses are always allowed. */\n\tif (!strict || size == 1)\n\t\treturn 0;\n\n\t/* For platforms that do not have a Kconfig enabling\n\t * CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS the value of\n\t * NET_IP_ALIGN is universally set to '2'.  And on platforms\n\t * that do set CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS, we get\n\t * to this code only in strict mode where we want to emulate\n\t * the NET_IP_ALIGN==2 checking.  Therefore use an\n\t * unconditional IP align value of '2'.\n\t */\n\tip_align = 2;\n\n\treg_off = tnum_add(reg->var_off, tnum_const(ip_align + reg->off + off));\n\tif (!tnum_is_aligned(reg_off, size)) {\n\t\tchar tn_buf[48];\n\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\tverbose(env,\n\t\t\t\"misaligned packet access off %d+%s+%d+%d size %d\\n\",\n\t\t\tip_align, tn_buf, reg->off, off, size);\n\t\treturn -EACCES;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_generic_ptr_alignment(struct bpf_verifier_env *env,\n\t\t\t\t       const struct bpf_reg_state *reg,\n\t\t\t\t       const char *pointer_desc,\n\t\t\t\t       int off, int size, bool strict)\n{\n\tstruct tnum reg_off;\n\n\t/* Byte size accesses are always allowed. */\n\tif (!strict || size == 1)\n\t\treturn 0;\n\n\treg_off = tnum_add(reg->var_off, tnum_const(reg->off + off));\n\tif (!tnum_is_aligned(reg_off, size)) {\n\t\tchar tn_buf[48];\n\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\tverbose(env, \"misaligned %saccess off %s+%d+%d size %d\\n\",\n\t\t\tpointer_desc, tn_buf, reg->off, off, size);\n\t\treturn -EACCES;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_ptr_alignment(struct bpf_verifier_env *env,\n\t\t\t       const struct bpf_reg_state *reg, int off,\n\t\t\t       int size, bool strict_alignment_once)\n{\n\tbool strict = env->strict_alignment || strict_alignment_once;\n\tconst char *pointer_desc = \"\";\n\n\tswitch (reg->type) {\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\t\t/* Special case, because of NET_IP_ALIGN. Given metadata sits\n\t\t * right in front, treat it the very same way.\n\t\t */\n\t\treturn check_pkt_ptr_alignment(env, reg, off, size, strict);\n\tcase PTR_TO_FLOW_KEYS:\n\t\tpointer_desc = \"flow keys \";\n\t\tbreak;\n\tcase PTR_TO_MAP_KEY:\n\t\tpointer_desc = \"key \";\n\t\tbreak;\n\tcase PTR_TO_MAP_VALUE:\n\t\tpointer_desc = \"value \";\n\t\tbreak;\n\tcase PTR_TO_CTX:\n\t\tpointer_desc = \"context \";\n\t\tbreak;\n\tcase PTR_TO_STACK:\n\t\tpointer_desc = \"stack \";\n\t\t/* The stack spill tracking logic in check_stack_write_fixed_off()\n\t\t * and check_stack_read_fixed_off() relies on stack accesses being\n\t\t * aligned.\n\t\t */\n\t\tstrict = true;\n\t\tbreak;\n\tcase PTR_TO_SOCKET:\n\t\tpointer_desc = \"sock \";\n\t\tbreak;\n\tcase PTR_TO_SOCK_COMMON:\n\t\tpointer_desc = \"sock_common \";\n\t\tbreak;\n\tcase PTR_TO_TCP_SOCK:\n\t\tpointer_desc = \"tcp_sock \";\n\t\tbreak;\n\tcase PTR_TO_XDP_SOCK:\n\t\tpointer_desc = \"xdp_sock \";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn check_generic_ptr_alignment(env, reg, pointer_desc, off, size,\n\t\t\t\t\t   strict);\n}\n\nstatic int update_stack_depth(struct bpf_verifier_env *env,\n\t\t\t      const struct bpf_func_state *func,\n\t\t\t      int off)\n{\n\tu16 stack = env->subprog_info[func->subprogno].stack_depth;\n\n\tif (stack >= -off)\n\t\treturn 0;\n\n\t/* update known max for given subprogram */\n\tenv->subprog_info[func->subprogno].stack_depth = -off;\n\treturn 0;\n}\n\n/* starting from main bpf function walk all instructions of the function\n * and recursively walk all callees that given function can call.\n * Ignore jump and exit insns.\n * Since recursion is prevented by check_cfg() this algorithm\n * only needs a local stack of MAX_CALL_FRAMES to remember callsites\n */\nstatic int check_max_stack_depth(struct bpf_verifier_env *env)\n{\n\tint depth = 0, frame = 0, idx = 0, i = 0, subprog_end;\n\tstruct bpf_subprog_info *subprog = env->subprog_info;\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tbool tail_call_reachable = false;\n\tint ret_insn[MAX_CALL_FRAMES];\n\tint ret_prog[MAX_CALL_FRAMES];\n\tint j;\n\nprocess_func:\n\t/* protect against potential stack overflow that might happen when\n\t * bpf2bpf calls get combined with tailcalls. Limit the caller's stack\n\t * depth for such case down to 256 so that the worst case scenario\n\t * would result in 8k stack size (32 which is tailcall limit * 256 =\n\t * 8k).\n\t *\n\t * To get the idea what might happen, see an example:\n\t * func1 -> sub rsp, 128\n\t *  subfunc1 -> sub rsp, 256\n\t *  tailcall1 -> add rsp, 256\n\t *   func2 -> sub rsp, 192 (total stack size = 128 + 192 = 320)\n\t *   subfunc2 -> sub rsp, 64\n\t *   subfunc22 -> sub rsp, 128\n\t *   tailcall2 -> add rsp, 128\n\t *    func3 -> sub rsp, 32 (total stack size 128 + 192 + 64 + 32 = 416)\n\t *\n\t * tailcall will unwind the current stack frame but it will not get rid\n\t * of caller's stack as shown on the example above.\n\t */\n\tif (idx && subprog[idx].has_tail_call && depth >= 256) {\n\t\tverbose(env,\n\t\t\t\"tail_calls are not allowed when call stack of previous frames is %d bytes. Too large\\n\",\n\t\t\tdepth);\n\t\treturn -EACCES;\n\t}\n\t/* round up to 32-bytes, since this is granularity\n\t * of interpreter stack size\n\t */\n\tdepth += round_up(max_t(u32, subprog[idx].stack_depth, 1), 32);\n\tif (depth > MAX_BPF_STACK) {\n\t\tverbose(env, \"combined stack size of %d calls is %d. Too large\\n\",\n\t\t\tframe + 1, depth);\n\t\treturn -EACCES;\n\t}\ncontinue_func:\n\tsubprog_end = subprog[idx + 1].start;\n\tfor (; i < subprog_end; i++) {\n\t\tif (!bpf_pseudo_call(insn + i) && !bpf_pseudo_func(insn + i))\n\t\t\tcontinue;\n\t\t/* remember insn and function to return to */\n\t\tret_insn[frame] = i + 1;\n\t\tret_prog[frame] = idx;\n\n\t\t/* find the callee */\n\t\ti = i + insn[i].imm + 1;\n\t\tidx = find_subprog(env, i);\n\t\tif (idx < 0) {\n\t\t\tWARN_ONCE(1, \"verifier bug. No program starts at insn %d\\n\",\n\t\t\t\t  i);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (subprog[idx].has_tail_call)\n\t\t\ttail_call_reachable = true;\n\n\t\tframe++;\n\t\tif (frame >= MAX_CALL_FRAMES) {\n\t\t\tverbose(env, \"the call stack of %d frames is too deep !\\n\",\n\t\t\t\tframe);\n\t\t\treturn -E2BIG;\n\t\t}\n\t\tgoto process_func;\n\t}\n\t/* if tail call got detected across bpf2bpf calls then mark each of the\n\t * currently present subprog frames as tail call reachable subprogs;\n\t * this info will be utilized by JIT so that we will be preserving the\n\t * tail call counter throughout bpf2bpf calls combined with tailcalls\n\t */\n\tif (tail_call_reachable)\n\t\tfor (j = 0; j < frame; j++)\n\t\t\tsubprog[ret_prog[j]].tail_call_reachable = true;\n\n\t/* end of for() loop means the last insn of the 'subprog'\n\t * was reached. Doesn't matter whether it was JA or EXIT\n\t */\n\tif (frame == 0)\n\t\treturn 0;\n\tdepth -= round_up(max_t(u32, subprog[idx].stack_depth, 1), 32);\n\tframe--;\n\ti = ret_insn[frame];\n\tidx = ret_prog[frame];\n\tgoto continue_func;\n}\n\n#ifndef CONFIG_BPF_JIT_ALWAYS_ON\nstatic int get_callee_stack_depth(struct bpf_verifier_env *env,\n\t\t\t\t  const struct bpf_insn *insn, int idx)\n{\n\tint start = idx + insn->imm + 1, subprog;\n\n\tsubprog = find_subprog(env, start);\n\tif (subprog < 0) {\n\t\tWARN_ONCE(1, \"verifier bug. No program starts at insn %d\\n\",\n\t\t\t  start);\n\t\treturn -EFAULT;\n\t}\n\treturn env->subprog_info[subprog].stack_depth;\n}\n#endif\n\nint check_ctx_reg(struct bpf_verifier_env *env,\n\t\t  const struct bpf_reg_state *reg, int regno)\n{\n\t/* Access to ctx or passing it to a helper is only allowed in\n\t * its original, unmodified form.\n\t */\n\n\tif (reg->off) {\n\t\tverbose(env, \"dereference of modified ctx ptr R%d off=%d disallowed\\n\",\n\t\t\tregno, reg->off);\n\t\treturn -EACCES;\n\t}\n\n\tif (!tnum_is_const(reg->var_off) || reg->var_off.value) {\n\t\tchar tn_buf[48];\n\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\tverbose(env, \"variable ctx access var_off=%s disallowed\\n\", tn_buf);\n\t\treturn -EACCES;\n\t}\n\n\treturn 0;\n}\n\nstatic int __check_buffer_access(struct bpf_verifier_env *env,\n\t\t\t\t const char *buf_info,\n\t\t\t\t const struct bpf_reg_state *reg,\n\t\t\t\t int regno, int off, int size)\n{\n\tif (off < 0) {\n\t\tverbose(env,\n\t\t\t\"R%d invalid %s buffer access: off=%d, size=%d\\n\",\n\t\t\tregno, buf_info, off, size);\n\t\treturn -EACCES;\n\t}\n\tif (!tnum_is_const(reg->var_off) || reg->var_off.value) {\n\t\tchar tn_buf[48];\n\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\tverbose(env,\n\t\t\t\"R%d invalid variable buffer offset: off=%d, var_off=%s\\n\",\n\t\t\tregno, off, tn_buf);\n\t\treturn -EACCES;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_tp_buffer_access(struct bpf_verifier_env *env,\n\t\t\t\t  const struct bpf_reg_state *reg,\n\t\t\t\t  int regno, int off, int size)\n{\n\tint err;\n\n\terr = __check_buffer_access(env, \"tracepoint\", reg, regno, off, size);\n\tif (err)\n\t\treturn err;\n\n\tif (off + size > env->prog->aux->max_tp_access)\n\t\tenv->prog->aux->max_tp_access = off + size;\n\n\treturn 0;\n}\n\nstatic int check_buffer_access(struct bpf_verifier_env *env,\n\t\t\t       const struct bpf_reg_state *reg,\n\t\t\t       int regno, int off, int size,\n\t\t\t       bool zero_size_allowed,\n\t\t\t       const char *buf_info,\n\t\t\t       u32 *max_access)\n{\n\tint err;\n\n\terr = __check_buffer_access(env, buf_info, reg, regno, off, size);\n\tif (err)\n\t\treturn err;\n\n\tif (off + size > *max_access)\n\t\t*max_access = off + size;\n\n\treturn 0;\n}\n\n/* BPF architecture zero extends alu32 ops into 64-bit registesr */\nstatic void zext_32_to_64(struct bpf_reg_state *reg)\n{\n\treg->var_off = tnum_subreg(reg->var_off);\n\t__reg_assign_32_into_64(reg);\n}\n\n/* truncate register to smaller size (in bytes)\n * must be called with size < BPF_REG_SIZE\n */\nstatic void coerce_reg_to_size(struct bpf_reg_state *reg, int size)\n{\n\tu64 mask;\n\n\t/* clear high bits in bit representation */\n\treg->var_off = tnum_cast(reg->var_off, size);\n\n\t/* fix arithmetic bounds */\n\tmask = ((u64)1 << (size * 8)) - 1;\n\tif ((reg->umin_value & ~mask) == (reg->umax_value & ~mask)) {\n\t\treg->umin_value &= mask;\n\t\treg->umax_value &= mask;\n\t} else {\n\t\treg->umin_value = 0;\n\t\treg->umax_value = mask;\n\t}\n\treg->smin_value = reg->umin_value;\n\treg->smax_value = reg->umax_value;\n\n\t/* If size is smaller than 32bit register the 32bit register\n\t * values are also truncated so we push 64-bit bounds into\n\t * 32-bit bounds. Above were truncated < 32-bits already.\n\t */\n\tif (size >= 4)\n\t\treturn;\n\t__reg_combine_64_into_32(reg);\n}\n\nstatic bool bpf_map_is_rdonly(const struct bpf_map *map)\n{\n\treturn (map->map_flags & BPF_F_RDONLY_PROG) && map->frozen;\n}\n\nstatic int bpf_map_direct_read(struct bpf_map *map, int off, int size, u64 *val)\n{\n\tvoid *ptr;\n\tu64 addr;\n\tint err;\n\n\terr = map->ops->map_direct_value_addr(map, &addr, off);\n\tif (err)\n\t\treturn err;\n\tptr = (void *)(long)addr + off;\n\n\tswitch (size) {\n\tcase sizeof(u8):\n\t\t*val = (u64)*(u8 *)ptr;\n\t\tbreak;\n\tcase sizeof(u16):\n\t\t*val = (u64)*(u16 *)ptr;\n\t\tbreak;\n\tcase sizeof(u32):\n\t\t*val = (u64)*(u32 *)ptr;\n\t\tbreak;\n\tcase sizeof(u64):\n\t\t*val = *(u64 *)ptr;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int check_ptr_to_btf_access(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_reg_state *regs,\n\t\t\t\t   int regno, int off, int size,\n\t\t\t\t   enum bpf_access_type atype,\n\t\t\t\t   int value_regno)\n{\n\tstruct bpf_reg_state *reg = regs + regno;\n\tconst struct btf_type *t = btf_type_by_id(reg->btf, reg->btf_id);\n\tconst char *tname = btf_name_by_offset(reg->btf, t->name_off);\n\tu32 btf_id;\n\tint ret;\n\n\tif (off < 0) {\n\t\tverbose(env,\n\t\t\t\"R%d is ptr_%s invalid negative access: off=%d\\n\",\n\t\t\tregno, tname, off);\n\t\treturn -EACCES;\n\t}\n\tif (!tnum_is_const(reg->var_off) || reg->var_off.value) {\n\t\tchar tn_buf[48];\n\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\tverbose(env,\n\t\t\t\"R%d is ptr_%s invalid variable offset: off=%d, var_off=%s\\n\",\n\t\t\tregno, tname, off, tn_buf);\n\t\treturn -EACCES;\n\t}\n\n\tif (env->ops->btf_struct_access) {\n\t\tret = env->ops->btf_struct_access(&env->log, reg->btf, t,\n\t\t\t\t\t\t  off, size, atype, &btf_id);\n\t} else {\n\t\tif (atype != BPF_READ) {\n\t\t\tverbose(env, \"only read is supported\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tret = btf_struct_access(&env->log, reg->btf, t, off, size,\n\t\t\t\t\tatype, &btf_id);\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (atype == BPF_READ && value_regno >= 0)\n\t\tmark_btf_ld_reg(env, regs, value_regno, ret, reg->btf, btf_id);\n\n\treturn 0;\n}\n\nstatic int check_ptr_to_map_access(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_reg_state *regs,\n\t\t\t\t   int regno, int off, int size,\n\t\t\t\t   enum bpf_access_type atype,\n\t\t\t\t   int value_regno)\n{\n\tstruct bpf_reg_state *reg = regs + regno;\n\tstruct bpf_map *map = reg->map_ptr;\n\tconst struct btf_type *t;\n\tconst char *tname;\n\tu32 btf_id;\n\tint ret;\n\n\tif (!btf_vmlinux) {\n\t\tverbose(env, \"map_ptr access not supported without CONFIG_DEBUG_INFO_BTF\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (!map->ops->map_btf_id || !*map->ops->map_btf_id) {\n\t\tverbose(env, \"map_ptr access not supported for map type %d\\n\",\n\t\t\tmap->map_type);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tt = btf_type_by_id(btf_vmlinux, *map->ops->map_btf_id);\n\ttname = btf_name_by_offset(btf_vmlinux, t->name_off);\n\n\tif (!env->allow_ptr_to_map_access) {\n\t\tverbose(env,\n\t\t\t\"%s access is allowed only to CAP_PERFMON and CAP_SYS_ADMIN\\n\",\n\t\t\ttname);\n\t\treturn -EPERM;\n\t}\n\n\tif (off < 0) {\n\t\tverbose(env, \"R%d is %s invalid negative access: off=%d\\n\",\n\t\t\tregno, tname, off);\n\t\treturn -EACCES;\n\t}\n\n\tif (atype != BPF_READ) {\n\t\tverbose(env, \"only read from %s is supported\\n\", tname);\n\t\treturn -EACCES;\n\t}\n\n\tret = btf_struct_access(&env->log, btf_vmlinux, t, off, size, atype, &btf_id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (value_regno >= 0)\n\t\tmark_btf_ld_reg(env, regs, value_regno, ret, btf_vmlinux, btf_id);\n\n\treturn 0;\n}\n\n/* Check that the stack access at the given offset is within bounds. The\n * maximum valid offset is -1.\n *\n * The minimum valid offset is -MAX_BPF_STACK for writes, and\n * -state->allocated_stack for reads.\n */\nstatic int check_stack_slot_within_bounds(int off,\n\t\t\t\t\t  struct bpf_func_state *state,\n\t\t\t\t\t  enum bpf_access_type t)\n{\n\tint min_valid_off;\n\n\tif (t == BPF_WRITE)\n\t\tmin_valid_off = -MAX_BPF_STACK;\n\telse\n\t\tmin_valid_off = -state->allocated_stack;\n\n\tif (off < min_valid_off || off > -1)\n\t\treturn -EACCES;\n\treturn 0;\n}\n\n/* Check that the stack access at 'regno + off' falls within the maximum stack\n * bounds.\n *\n * 'off' includes `regno->offset`, but not its dynamic part (if any).\n */\nstatic int check_stack_access_within_bounds(\n\t\tstruct bpf_verifier_env *env,\n\t\tint regno, int off, int access_size,\n\t\tenum stack_access_src src, enum bpf_access_type type)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = regs + regno;\n\tstruct bpf_func_state *state = func(env, reg);\n\tint min_off, max_off;\n\tint err;\n\tchar *err_extra;\n\n\tif (src == ACCESS_HELPER)\n\t\t/* We don't know if helpers are reading or writing (or both). */\n\t\terr_extra = \" indirect access to\";\n\telse if (type == BPF_READ)\n\t\terr_extra = \" read from\";\n\telse\n\t\terr_extra = \" write to\";\n\n\tif (tnum_is_const(reg->var_off)) {\n\t\tmin_off = reg->var_off.value + off;\n\t\tif (access_size > 0)\n\t\t\tmax_off = min_off + access_size - 1;\n\t\telse\n\t\t\tmax_off = min_off;\n\t} else {\n\t\tif (reg->smax_value >= BPF_MAX_VAR_OFF ||\n\t\t    reg->smin_value <= -BPF_MAX_VAR_OFF) {\n\t\t\tverbose(env, \"invalid unbounded variable-offset%s stack R%d\\n\",\n\t\t\t\terr_extra, regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmin_off = reg->smin_value + off;\n\t\tif (access_size > 0)\n\t\t\tmax_off = reg->smax_value + off + access_size - 1;\n\t\telse\n\t\t\tmax_off = min_off;\n\t}\n\n\terr = check_stack_slot_within_bounds(min_off, state, type);\n\tif (!err)\n\t\terr = check_stack_slot_within_bounds(max_off, state, type);\n\n\tif (err) {\n\t\tif (tnum_is_const(reg->var_off)) {\n\t\t\tverbose(env, \"invalid%s stack R%d off=%d size=%d\\n\",\n\t\t\t\terr_extra, regno, off, access_size);\n\t\t} else {\n\t\t\tchar tn_buf[48];\n\n\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\tverbose(env, \"invalid variable-offset%s stack R%d var_off=%s size=%d\\n\",\n\t\t\t\terr_extra, regno, tn_buf, access_size);\n\t\t}\n\t}\n\treturn err;\n}\n\n/* check whether memory at (regno + off) is accessible for t = (read | write)\n * if t==write, value_regno is a register which value is stored into memory\n * if t==read, value_regno is a register which will receive the value from memory\n * if t==write && value_regno==-1, some unknown value is stored into memory\n * if t==read && value_regno==-1, don't care what we read from memory\n */\nstatic int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regno,\n\t\t\t    int off, int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno, bool strict_alignment_once)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = regs + regno;\n\tstruct bpf_func_state *state;\n\tint size, err = 0;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\t/* alignment checks will add in reg->off themselves */\n\terr = check_ptr_alignment(env, reg, off, size, strict_alignment_once);\n\tif (err)\n\t\treturn err;\n\n\t/* for access checks, reg->off is just part of off */\n\toff += reg->off;\n\n\tif (reg->type == PTR_TO_MAP_KEY) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"write to change key R%d not allowed\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->map_ptr->key_size, false);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_MAP_VALUE) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_map_access_type(env, regno, off, size, t);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = check_map_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\tstruct bpf_map *map = reg->map_ptr;\n\n\t\t\t/* if map is read-only, track its contents as scalars */\n\t\t\tif (tnum_is_const(reg->var_off) &&\n\t\t\t    bpf_map_is_rdonly(map) &&\n\t\t\t    map->ops->map_direct_value_addr) {\n\t\t\t\tint map_off = off + reg->var_off.value;\n\t\t\t\tu64 val = 0;\n\n\t\t\t\terr = bpf_map_direct_read(map, map_off, size,\n\t\t\t\t\t\t\t  &val);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tregs[value_regno].type = SCALAR_VALUE;\n\t\t\t\t__mark_reg_known(&regs[value_regno], val);\n\t\t\t} else {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t}\n\t\t}\n\t} else if (reg->type == PTR_TO_MEM) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into mem\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->mem_size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_CTX) {\n\t\tenum bpf_reg_type reg_type = SCALAR_VALUE;\n\t\tstruct btf *btf = NULL;\n\t\tu32 btf_id = 0;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_ctx_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = check_ctx_access(env, insn_idx, off, size, t, &reg_type, &btf, &btf_id);\n\t\tif (err)\n\t\t\tverbose_linfo(env, insn_idx, \"; \");\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\t/* ctx access returns either a scalar, or a\n\t\t\t * PTR_TO_PACKET[_META,_END]. In the latter\n\t\t\t * case, we know the offset is zero.\n\t\t\t */\n\t\t\tif (reg_type == SCALAR_VALUE) {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t} else {\n\t\t\t\tmark_reg_known_zero(env, regs,\n\t\t\t\t\t\t    value_regno);\n\t\t\t\tif (reg_type_may_be_null(reg_type))\n\t\t\t\t\tregs[value_regno].id = ++env->id_gen;\n\t\t\t\t/* A load of ctx field could have different\n\t\t\t\t * actual load size with the one encoded in the\n\t\t\t\t * insn. When the dst is PTR, it is for sure not\n\t\t\t\t * a sub-register.\n\t\t\t\t */\n\t\t\t\tregs[value_regno].subreg_def = DEF_NOT_SUBREG;\n\t\t\t\tif (reg_type == PTR_TO_BTF_ID ||\n\t\t\t\t    reg_type == PTR_TO_BTF_ID_OR_NULL) {\n\t\t\t\t\tregs[value_regno].btf = btf;\n\t\t\t\t\tregs[value_regno].btf_id = btf_id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tregs[value_regno].type = reg_type;\n\t\t}\n\n\t} else if (reg->type == PTR_TO_STACK) {\n\t\t/* Basic bounds checks. */\n\t\terr = check_stack_access_within_bounds(env, regno, off, size, ACCESS_DIRECT, t);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstate = func(env, reg);\n\t\terr = update_stack_depth(env, state, off);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (t == BPF_READ)\n\t\t\terr = check_stack_read(env, regno, off, size,\n\t\t\t\t\t       value_regno);\n\t\telse\n\t\t\terr = check_stack_write(env, regno, off, size,\n\t\t\t\t\t\tvalue_regno, insn_idx);\n\t} else if (reg_is_pkt_pointer(reg)) {\n\t\tif (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {\n\t\t\tverbose(env, \"cannot write into packet\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into packet\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_packet_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_FLOW_KEYS) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into flow keys\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_flow_keys_access(env, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (type_is_sk_pointer(reg->type)) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str[reg->type]);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_sock_access(env, insn_idx, regno, off, size, t);\n\t\tif (!err && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_TP_BUFFER) {\n\t\terr = check_tp_buffer_access(env, reg, regno, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_BTF_ID) {\n\t\terr = check_ptr_to_btf_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (reg->type == CONST_PTR_TO_MAP) {\n\t\terr = check_ptr_to_map_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (reg->type == PTR_TO_RDONLY_BUF) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str[reg->type]);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_buffer_access(env, reg, regno, off, size, false,\n\t\t\t\t\t  \"rdonly\",\n\t\t\t\t\t  &env->prog->aux->max_rdonly_access);\n\t\tif (!err && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_RDWR_BUF) {\n\t\terr = check_buffer_access(env, reg, regno, off, size, false,\n\t\t\t\t\t  \"rdwr\",\n\t\t\t\t\t  &env->prog->aux->max_rdwr_access);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else {\n\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\treg_type_str[reg->type]);\n\t\treturn -EACCES;\n\t}\n\n\tif (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&\n\t    regs[value_regno].type == SCALAR_VALUE) {\n\t\t/* b/h/w load zero-extends, mark upper bits as known 0 */\n\t\tcoerce_reg_to_size(&regs[value_regno], size);\n\t}\n\treturn err;\n}\n\nstatic int check_atomic(struct bpf_verifier_env *env, int insn_idx, struct bpf_insn *insn)\n{\n\tint load_reg;\n\tint err;\n\n\tswitch (insn->imm) {\n\tcase BPF_ADD:\n\tcase BPF_ADD | BPF_FETCH:\n\tcase BPF_AND:\n\tcase BPF_AND | BPF_FETCH:\n\tcase BPF_OR:\n\tcase BPF_OR | BPF_FETCH:\n\tcase BPF_XOR:\n\tcase BPF_XOR | BPF_FETCH:\n\tcase BPF_XCHG:\n\tcase BPF_CMPXCHG:\n\t\tbreak;\n\tdefault:\n\t\tverbose(env, \"BPF_ATOMIC uses invalid atomic opcode %02x\\n\", insn->imm);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BPF_SIZE(insn->code) != BPF_W && BPF_SIZE(insn->code) != BPF_DW) {\n\t\tverbose(env, \"invalid atomic operand size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check src1 operand */\n\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\t/* check src2 operand */\n\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (insn->imm == BPF_CMPXCHG) {\n\t\t/* Check comparison of R0 with memory location */\n\t\terr = check_reg_arg(env, BPF_REG_0, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (is_pointer_value(env, insn->src_reg)) {\n\t\tverbose(env, \"R%d leaks addr into mem\\n\", insn->src_reg);\n\t\treturn -EACCES;\n\t}\n\n\tif (is_ctx_reg(env, insn->dst_reg) ||\n\t    is_pkt_reg(env, insn->dst_reg) ||\n\t    is_flow_key_reg(env, insn->dst_reg) ||\n\t    is_sk_reg(env, insn->dst_reg)) {\n\t\tverbose(env, \"BPF_ATOMIC stores into R%d %s is not allowed\\n\",\n\t\t\tinsn->dst_reg,\n\t\t\treg_type_str[reg_state(env, insn->dst_reg)->type]);\n\t\treturn -EACCES;\n\t}\n\n\tif (insn->imm & BPF_FETCH) {\n\t\tif (insn->imm == BPF_CMPXCHG)\n\t\t\tload_reg = BPF_REG_0;\n\t\telse\n\t\t\tload_reg = insn->src_reg;\n\n\t\t/* check and record load of old value */\n\t\terr = check_reg_arg(env, load_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\t/* This instruction accesses a memory location but doesn't\n\t\t * actually load it into a register.\n\t\t */\n\t\tload_reg = -1;\n\t}\n\n\t/* check whether we can read the memory */\n\terr = check_mem_access(env, insn_idx, insn->dst_reg, insn->off,\n\t\t\t       BPF_SIZE(insn->code), BPF_READ, load_reg, true);\n\tif (err)\n\t\treturn err;\n\n\t/* check whether we can write into the same memory */\n\terr = check_mem_access(env, insn_idx, insn->dst_reg, insn->off,\n\t\t\t       BPF_SIZE(insn->code), BPF_WRITE, -1, true);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n/* When register 'regno' is used to read the stack (either directly or through\n * a helper function) make sure that it's within stack boundary and, depending\n * on the access type, that all elements of the stack are initialized.\n *\n * 'off' includes 'regno->off', but not its dynamic part (if any).\n *\n * All registers that have been spilled on the stack in the slots within the\n * read offsets are marked as read.\n */\nstatic int check_stack_range_initialized(\n\t\tstruct bpf_verifier_env *env, int regno, int off,\n\t\tint access_size, bool zero_size_allowed,\n\t\tenum stack_access_src type, struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *reg = reg_state(env, regno);\n\tstruct bpf_func_state *state = func(env, reg);\n\tint err, min_off, max_off, i, j, slot, spi;\n\tchar *err_extra = type == ACCESS_HELPER ? \" indirect\" : \"\";\n\tenum bpf_access_type bounds_check_type;\n\t/* Some accesses can write anything into the stack, others are\n\t * read-only.\n\t */\n\tbool clobber = false;\n\n\tif (access_size == 0 && !zero_size_allowed) {\n\t\tverbose(env, \"invalid zero-sized read\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (type == ACCESS_HELPER) {\n\t\t/* The bounds checks for writes are more permissive than for\n\t\t * reads. However, if raw_mode is not set, we'll do extra\n\t\t * checks below.\n\t\t */\n\t\tbounds_check_type = BPF_WRITE;\n\t\tclobber = true;\n\t} else {\n\t\tbounds_check_type = BPF_READ;\n\t}\n\terr = check_stack_access_within_bounds(env, regno, off, access_size,\n\t\t\t\t\t       type, bounds_check_type);\n\tif (err)\n\t\treturn err;\n\n\n\tif (tnum_is_const(reg->var_off)) {\n\t\tmin_off = max_off = reg->var_off.value + off;\n\t} else {\n\t\t/* Variable offset is prohibited for unprivileged mode for\n\t\t * simplicity since it requires corresponding support in\n\t\t * Spectre masking for stack ALU.\n\t\t * See also retrieve_ptr_limit().\n\t\t */\n\t\tif (!env->bypass_spec_v1) {\n\t\t\tchar tn_buf[48];\n\n\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\tverbose(env, \"R%d%s variable offset stack access prohibited for !root, var_off=%s\\n\",\n\t\t\t\tregno, err_extra, tn_buf);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* Only initialized buffer on stack is allowed to be accessed\n\t\t * with variable offset. With uninitialized buffer it's hard to\n\t\t * guarantee that whole memory is marked as initialized on\n\t\t * helper return since specific bounds are unknown what may\n\t\t * cause uninitialized stack leaking.\n\t\t */\n\t\tif (meta && meta->raw_mode)\n\t\t\tmeta = NULL;\n\n\t\tmin_off = reg->smin_value + off;\n\t\tmax_off = reg->smax_value + off;\n\t}\n\n\tif (meta && meta->raw_mode) {\n\t\tmeta->access_size = access_size;\n\t\tmeta->regno = regno;\n\t\treturn 0;\n\t}\n\n\tfor (i = min_off; i < max_off + access_size; i++) {\n\t\tu8 *stype;\n\n\t\tslot = -i - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tif (state->allocated_stack <= slot)\n\t\t\tgoto err;\n\t\tstype = &state->stack[spi].slot_type[slot % BPF_REG_SIZE];\n\t\tif (*stype == STACK_MISC)\n\t\t\tgoto mark;\n\t\tif (*stype == STACK_ZERO) {\n\t\t\tif (clobber) {\n\t\t\t\t/* helper can write anything into the stack */\n\t\t\t\t*stype = STACK_MISC;\n\t\t\t}\n\t\t\tgoto mark;\n\t\t}\n\n\t\tif (state->stack[spi].slot_type[0] == STACK_SPILL &&\n\t\t    state->stack[spi].spilled_ptr.type == PTR_TO_BTF_ID)\n\t\t\tgoto mark;\n\n\t\tif (state->stack[spi].slot_type[0] == STACK_SPILL &&\n\t\t    (state->stack[spi].spilled_ptr.type == SCALAR_VALUE ||\n\t\t     env->allow_ptr_leaks)) {\n\t\t\tif (clobber) {\n\t\t\t\t__mark_reg_unknown(env, &state->stack[spi].spilled_ptr);\n\t\t\t\tfor (j = 0; j < BPF_REG_SIZE; j++)\n\t\t\t\t\tstate->stack[spi].slot_type[j] = STACK_MISC;\n\t\t\t}\n\t\t\tgoto mark;\n\t\t}\n\nerr:\n\t\tif (tnum_is_const(reg->var_off)) {\n\t\t\tverbose(env, \"invalid%s read from stack R%d off %d+%d size %d\\n\",\n\t\t\t\terr_extra, regno, min_off, i - min_off, access_size);\n\t\t} else {\n\t\t\tchar tn_buf[48];\n\n\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\tverbose(env, \"invalid%s read from stack R%d var_off %s+%d size %d\\n\",\n\t\t\t\terr_extra, regno, tn_buf, i - min_off, access_size);\n\t\t}\n\t\treturn -EACCES;\nmark:\n\t\t/* reading any byte out of 8-byte 'spill_slot' will cause\n\t\t * the whole slot to be marked as 'read'\n\t\t */\n\t\tmark_reg_read(env, &state->stack[spi].spilled_ptr,\n\t\t\t      state->stack[spi].spilled_ptr.parent,\n\t\t\t      REG_LIVE_READ64);\n\t}\n\treturn update_stack_depth(env, state, min_off);\n}\n\nstatic int check_helper_mem_access(struct bpf_verifier_env *env, int regno,\n\t\t\t\t   int access_size, bool zero_size_allowed,\n\t\t\t\t   struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\n\tswitch (reg->type) {\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\t\treturn check_packet_access(env, regno, reg->off, access_size,\n\t\t\t\t\t   zero_size_allowed);\n\tcase PTR_TO_MAP_KEY:\n\t\treturn check_mem_region_access(env, regno, reg->off, access_size,\n\t\t\t\t\t       reg->map_ptr->key_size, false);\n\tcase PTR_TO_MAP_VALUE:\n\t\tif (check_map_access_type(env, regno, reg->off, access_size,\n\t\t\t\t\t  meta && meta->raw_mode ? BPF_WRITE :\n\t\t\t\t\t  BPF_READ))\n\t\t\treturn -EACCES;\n\t\treturn check_map_access(env, regno, reg->off, access_size,\n\t\t\t\t\tzero_size_allowed);\n\tcase PTR_TO_MEM:\n\t\treturn check_mem_region_access(env, regno, reg->off,\n\t\t\t\t\t       access_size, reg->mem_size,\n\t\t\t\t\t       zero_size_allowed);\n\tcase PTR_TO_RDONLY_BUF:\n\t\tif (meta && meta->raw_mode)\n\t\t\treturn -EACCES;\n\t\treturn check_buffer_access(env, reg, regno, reg->off,\n\t\t\t\t\t   access_size, zero_size_allowed,\n\t\t\t\t\t   \"rdonly\",\n\t\t\t\t\t   &env->prog->aux->max_rdonly_access);\n\tcase PTR_TO_RDWR_BUF:\n\t\treturn check_buffer_access(env, reg, regno, reg->off,\n\t\t\t\t\t   access_size, zero_size_allowed,\n\t\t\t\t\t   \"rdwr\",\n\t\t\t\t\t   &env->prog->aux->max_rdwr_access);\n\tcase PTR_TO_STACK:\n\t\treturn check_stack_range_initialized(\n\t\t\t\tenv,\n\t\t\t\tregno, reg->off, access_size,\n\t\t\t\tzero_size_allowed, ACCESS_HELPER, meta);\n\tdefault: /* scalar_value or invalid ptr */\n\t\t/* Allow zero-byte read from NULL, regardless of pointer type */\n\t\tif (zero_size_allowed && access_size == 0 &&\n\t\t    register_is_null(reg))\n\t\t\treturn 0;\n\n\t\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\t\treg_type_str[reg->type],\n\t\t\treg_type_str[PTR_TO_STACK]);\n\t\treturn -EACCES;\n\t}\n}\n\nint check_mem_reg(struct bpf_verifier_env *env, struct bpf_reg_state *reg,\n\t\t   u32 regno, u32 mem_size)\n{\n\tif (register_is_null(reg))\n\t\treturn 0;\n\n\tif (reg_type_may_be_null(reg->type)) {\n\t\t/* Assuming that the register contains a value check if the memory\n\t\t * access is safe. Temporarily save and restore the register's state as\n\t\t * the conversion shouldn't be visible to a caller.\n\t\t */\n\t\tconst struct bpf_reg_state saved_reg = *reg;\n\t\tint rv;\n\n\t\tmark_ptr_not_null_reg(reg);\n\t\trv = check_helper_mem_access(env, regno, mem_size, true, NULL);\n\t\t*reg = saved_reg;\n\t\treturn rv;\n\t}\n\n\treturn check_helper_mem_access(env, regno, mem_size, true, NULL);\n}\n\n/* Implementation details:\n * bpf_map_lookup returns PTR_TO_MAP_VALUE_OR_NULL\n * Two bpf_map_lookups (even with the same key) will have different reg->id.\n * For traditional PTR_TO_MAP_VALUE the verifier clears reg->id after\n * value_or_null->value transition, since the verifier only cares about\n * the range of access to valid map value pointer and doesn't care about actual\n * address of the map element.\n * For maps with 'struct bpf_spin_lock' inside map value the verifier keeps\n * reg->id > 0 after value_or_null->value transition. By doing so\n * two bpf_map_lookups will be considered two different pointers that\n * point to different bpf_spin_locks.\n * The verifier allows taking only one bpf_spin_lock at a time to avoid\n * dead-locks.\n * Since only one bpf_spin_lock is allowed the checks are simpler than\n * reg_is_refcounted() logic. The verifier needs to remember only\n * one spin_lock instead of array of acquired_refs.\n * cur_state->active_spin_lock remembers which map value element got locked\n * and clears it after bpf_spin_unlock.\n */\nstatic int process_spin_lock(struct bpf_verifier_env *env, int regno,\n\t\t\t     bool is_lock)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tstruct bpf_verifier_state *cur = env->cur_state;\n\tbool is_const = tnum_is_const(reg->var_off);\n\tstruct bpf_map *map = reg->map_ptr;\n\tu64 val = reg->var_off.value;\n\n\tif (!is_const) {\n\t\tverbose(env,\n\t\t\t\"R%d doesn't have constant offset. bpf_spin_lock has to be at the constant offset\\n\",\n\t\t\tregno);\n\t\treturn -EINVAL;\n\t}\n\tif (!map->btf) {\n\t\tverbose(env,\n\t\t\t\"map '%s' has to have BTF in order to use bpf_spin_lock\\n\",\n\t\t\tmap->name);\n\t\treturn -EINVAL;\n\t}\n\tif (!map_value_has_spin_lock(map)) {\n\t\tif (map->spin_lock_off == -E2BIG)\n\t\t\tverbose(env,\n\t\t\t\t\"map '%s' has more than one 'struct bpf_spin_lock'\\n\",\n\t\t\t\tmap->name);\n\t\telse if (map->spin_lock_off == -ENOENT)\n\t\t\tverbose(env,\n\t\t\t\t\"map '%s' doesn't have 'struct bpf_spin_lock'\\n\",\n\t\t\t\tmap->name);\n\t\telse\n\t\t\tverbose(env,\n\t\t\t\t\"map '%s' is not a struct type or bpf_spin_lock is mangled\\n\",\n\t\t\t\tmap->name);\n\t\treturn -EINVAL;\n\t}\n\tif (map->spin_lock_off != val + reg->off) {\n\t\tverbose(env, \"off %lld doesn't point to 'struct bpf_spin_lock'\\n\",\n\t\t\tval + reg->off);\n\t\treturn -EINVAL;\n\t}\n\tif (is_lock) {\n\t\tif (cur->active_spin_lock) {\n\t\t\tverbose(env,\n\t\t\t\t\"Locking two bpf_spin_locks are not allowed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur->active_spin_lock = reg->id;\n\t} else {\n\t\tif (!cur->active_spin_lock) {\n\t\t\tverbose(env, \"bpf_spin_unlock without taking a lock\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (cur->active_spin_lock != reg->id) {\n\t\t\tverbose(env, \"bpf_spin_unlock of different lock\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur->active_spin_lock = 0;\n\t}\n\treturn 0;\n}\n\nstatic bool arg_type_is_mem_ptr(enum bpf_arg_type type)\n{\n\treturn type == ARG_PTR_TO_MEM ||\n\t       type == ARG_PTR_TO_MEM_OR_NULL ||\n\t       type == ARG_PTR_TO_UNINIT_MEM;\n}\n\nstatic bool arg_type_is_mem_size(enum bpf_arg_type type)\n{\n\treturn type == ARG_CONST_SIZE ||\n\t       type == ARG_CONST_SIZE_OR_ZERO;\n}\n\nstatic bool arg_type_is_alloc_size(enum bpf_arg_type type)\n{\n\treturn type == ARG_CONST_ALLOC_SIZE_OR_ZERO;\n}\n\nstatic bool arg_type_is_int_ptr(enum bpf_arg_type type)\n{\n\treturn type == ARG_PTR_TO_INT ||\n\t       type == ARG_PTR_TO_LONG;\n}\n\nstatic int int_ptr_type_to_size(enum bpf_arg_type type)\n{\n\tif (type == ARG_PTR_TO_INT)\n\t\treturn sizeof(u32);\n\telse if (type == ARG_PTR_TO_LONG)\n\t\treturn sizeof(u64);\n\n\treturn -EINVAL;\n}\n\nstatic int resolve_map_arg_type(struct bpf_verifier_env *env,\n\t\t\t\t const struct bpf_call_arg_meta *meta,\n\t\t\t\t enum bpf_arg_type *arg_type)\n{\n\tif (!meta->map_ptr) {\n\t\t/* kernel subsystem misconfigured verifier */\n\t\tverbose(env, \"invalid map_ptr to access map->type\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tswitch (meta->map_ptr->map_type) {\n\tcase BPF_MAP_TYPE_SOCKMAP:\n\tcase BPF_MAP_TYPE_SOCKHASH:\n\t\tif (*arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\t\t*arg_type = ARG_PTR_TO_BTF_ID_SOCK_COMMON;\n\t\t} else {\n\t\t\tverbose(env, \"invalid arg_type for sockmap/sockhash\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstruct bpf_reg_types {\n\tconst enum bpf_reg_type types[10];\n\tu32 *btf_id;\n};\n\nstatic const struct bpf_reg_types map_key_value_types = {\n\t.types = {\n\t\tPTR_TO_STACK,\n\t\tPTR_TO_PACKET,\n\t\tPTR_TO_PACKET_META,\n\t\tPTR_TO_MAP_KEY,\n\t\tPTR_TO_MAP_VALUE,\n\t},\n};\n\nstatic const struct bpf_reg_types sock_types = {\n\t.types = {\n\t\tPTR_TO_SOCK_COMMON,\n\t\tPTR_TO_SOCKET,\n\t\tPTR_TO_TCP_SOCK,\n\t\tPTR_TO_XDP_SOCK,\n\t},\n};\n\n#ifdef CONFIG_NET\nstatic const struct bpf_reg_types btf_id_sock_common_types = {\n\t.types = {\n\t\tPTR_TO_SOCK_COMMON,\n\t\tPTR_TO_SOCKET,\n\t\tPTR_TO_TCP_SOCK,\n\t\tPTR_TO_XDP_SOCK,\n\t\tPTR_TO_BTF_ID,\n\t},\n\t.btf_id = &btf_sock_ids[BTF_SOCK_TYPE_SOCK_COMMON],\n};\n#endif\n\nstatic const struct bpf_reg_types mem_types = {\n\t.types = {\n\t\tPTR_TO_STACK,\n\t\tPTR_TO_PACKET,\n\t\tPTR_TO_PACKET_META,\n\t\tPTR_TO_MAP_KEY,\n\t\tPTR_TO_MAP_VALUE,\n\t\tPTR_TO_MEM,\n\t\tPTR_TO_RDONLY_BUF,\n\t\tPTR_TO_RDWR_BUF,\n\t},\n};\n\nstatic const struct bpf_reg_types int_ptr_types = {\n\t.types = {\n\t\tPTR_TO_STACK,\n\t\tPTR_TO_PACKET,\n\t\tPTR_TO_PACKET_META,\n\t\tPTR_TO_MAP_KEY,\n\t\tPTR_TO_MAP_VALUE,\n\t},\n};\n\nstatic const struct bpf_reg_types fullsock_types = { .types = { PTR_TO_SOCKET } };\nstatic const struct bpf_reg_types scalar_types = { .types = { SCALAR_VALUE } };\nstatic const struct bpf_reg_types context_types = { .types = { PTR_TO_CTX } };\nstatic const struct bpf_reg_types alloc_mem_types = { .types = { PTR_TO_MEM } };\nstatic const struct bpf_reg_types const_map_ptr_types = { .types = { CONST_PTR_TO_MAP } };\nstatic const struct bpf_reg_types btf_ptr_types = { .types = { PTR_TO_BTF_ID } };\nstatic const struct bpf_reg_types spin_lock_types = { .types = { PTR_TO_MAP_VALUE } };\nstatic const struct bpf_reg_types percpu_btf_ptr_types = { .types = { PTR_TO_PERCPU_BTF_ID } };\nstatic const struct bpf_reg_types func_ptr_types = { .types = { PTR_TO_FUNC } };\nstatic const struct bpf_reg_types stack_ptr_types = { .types = { PTR_TO_STACK } };\n\nstatic const struct bpf_reg_types *compatible_reg_types[__BPF_ARG_TYPE_MAX] = {\n\t[ARG_PTR_TO_MAP_KEY]\t\t= &map_key_value_types,\n\t[ARG_PTR_TO_MAP_VALUE]\t\t= &map_key_value_types,\n\t[ARG_PTR_TO_UNINIT_MAP_VALUE]\t= &map_key_value_types,\n\t[ARG_PTR_TO_MAP_VALUE_OR_NULL]\t= &map_key_value_types,\n\t[ARG_CONST_SIZE]\t\t= &scalar_types,\n\t[ARG_CONST_SIZE_OR_ZERO]\t= &scalar_types,\n\t[ARG_CONST_ALLOC_SIZE_OR_ZERO]\t= &scalar_types,\n\t[ARG_CONST_MAP_PTR]\t\t= &const_map_ptr_types,\n\t[ARG_PTR_TO_CTX]\t\t= &context_types,\n\t[ARG_PTR_TO_CTX_OR_NULL]\t= &context_types,\n\t[ARG_PTR_TO_SOCK_COMMON]\t= &sock_types,\n#ifdef CONFIG_NET\n\t[ARG_PTR_TO_BTF_ID_SOCK_COMMON]\t= &btf_id_sock_common_types,\n#endif\n\t[ARG_PTR_TO_SOCKET]\t\t= &fullsock_types,\n\t[ARG_PTR_TO_SOCKET_OR_NULL]\t= &fullsock_types,\n\t[ARG_PTR_TO_BTF_ID]\t\t= &btf_ptr_types,\n\t[ARG_PTR_TO_SPIN_LOCK]\t\t= &spin_lock_types,\n\t[ARG_PTR_TO_MEM]\t\t= &mem_types,\n\t[ARG_PTR_TO_MEM_OR_NULL]\t= &mem_types,\n\t[ARG_PTR_TO_UNINIT_MEM]\t\t= &mem_types,\n\t[ARG_PTR_TO_ALLOC_MEM]\t\t= &alloc_mem_types,\n\t[ARG_PTR_TO_ALLOC_MEM_OR_NULL]\t= &alloc_mem_types,\n\t[ARG_PTR_TO_INT]\t\t= &int_ptr_types,\n\t[ARG_PTR_TO_LONG]\t\t= &int_ptr_types,\n\t[ARG_PTR_TO_PERCPU_BTF_ID]\t= &percpu_btf_ptr_types,\n\t[ARG_PTR_TO_FUNC]\t\t= &func_ptr_types,\n\t[ARG_PTR_TO_STACK_OR_NULL]\t= &stack_ptr_types,\n};\n\nstatic int check_reg_type(struct bpf_verifier_env *env, u32 regno,\n\t\t\t  enum bpf_arg_type arg_type,\n\t\t\t  const u32 *arg_btf_id)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_reg_type expected, type = reg->type;\n\tconst struct bpf_reg_types *compatible;\n\tint i, j;\n\n\tcompatible = compatible_reg_types[arg_type];\n\tif (!compatible) {\n\t\tverbose(env, \"verifier internal error: unsupported arg type %d\\n\", arg_type);\n\t\treturn -EFAULT;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(compatible->types); i++) {\n\t\texpected = compatible->types[i];\n\t\tif (expected == NOT_INIT)\n\t\t\tbreak;\n\n\t\tif (type == expected)\n\t\t\tgoto found;\n\t}\n\n\tverbose(env, \"R%d type=%s expected=\", regno, reg_type_str[type]);\n\tfor (j = 0; j + 1 < i; j++)\n\t\tverbose(env, \"%s, \", reg_type_str[compatible->types[j]]);\n\tverbose(env, \"%s\\n\", reg_type_str[compatible->types[j]]);\n\treturn -EACCES;\n\nfound:\n\tif (type == PTR_TO_BTF_ID) {\n\t\tif (!arg_btf_id) {\n\t\t\tif (!compatible->btf_id) {\n\t\t\t\tverbose(env, \"verifier internal error: missing arg compatible BTF ID\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\targ_btf_id = compatible->btf_id;\n\t\t}\n\n\t\tif (!btf_struct_ids_match(&env->log, reg->btf, reg->btf_id, reg->off,\n\t\t\t\t\t  btf_vmlinux, *arg_btf_id)) {\n\t\t\tverbose(env, \"R%d is of type %s but %s is expected\\n\",\n\t\t\t\tregno, kernel_type_name(reg->btf, reg->btf_id),\n\t\t\t\tkernel_type_name(btf_vmlinux, *arg_btf_id));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (!tnum_is_const(reg->var_off) || reg->var_off.value) {\n\t\t\tverbose(env, \"R%d is a pointer to in-kernel struct with non-zero offset\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int check_func_arg(struct bpf_verifier_env *env, u32 arg,\n\t\t\t  struct bpf_call_arg_meta *meta,\n\t\t\t  const struct bpf_func_proto *fn)\n{\n\tu32 regno = BPF_REG_1 + arg;\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_arg_type arg_type = fn->arg_type[arg];\n\tenum bpf_reg_type type = reg->type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\terr = check_reg_arg(env, regno, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into helper function\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (type_is_pkt_pointer(type) &&\n\t    !may_access_direct_pkt_data(env, meta, BPF_READ)) {\n\t\tverbose(env, \"helper access to the packet is not allowed\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_PTR_TO_MAP_VALUE ||\n\t    arg_type == ARG_PTR_TO_UNINIT_MAP_VALUE ||\n\t    arg_type == ARG_PTR_TO_MAP_VALUE_OR_NULL) {\n\t\terr = resolve_map_arg_type(env, meta, &arg_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (register_is_null(reg) && arg_type_may_be_null(arg_type))\n\t\t/* A NULL register has a SCALAR_VALUE type, so skip\n\t\t * type checking.\n\t\t */\n\t\tgoto skip_type_check;\n\n\terr = check_reg_type(env, regno, arg_type, fn->arg_btf_id[arg]);\n\tif (err)\n\t\treturn err;\n\n\tif (type == PTR_TO_CTX) {\n\t\terr = check_ctx_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\nskip_type_check:\n\tif (reg->ref_obj_id) {\n\t\tif (meta->ref_obj_id) {\n\t\t\tverbose(env, \"verifier internal error: more than one arg with ref_obj_id R%d %u %u\\n\",\n\t\t\t\tregno, reg->ref_obj_id,\n\t\t\t\tmeta->ref_obj_id);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tmeta->ref_obj_id = reg->ref_obj_id;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\tmeta->map_ptr = reg->map_ptr;\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(env, \"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->key_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type == ARG_PTR_TO_MAP_VALUE ||\n\t\t   (arg_type == ARG_PTR_TO_MAP_VALUE_OR_NULL &&\n\t\t    !register_is_null(reg)) ||\n\t\t   arg_type == ARG_PTR_TO_UNINIT_MAP_VALUE) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(env, \"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmeta->raw_mode = (arg_type == ARG_PTR_TO_UNINIT_MAP_VALUE);\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->value_size, false,\n\t\t\t\t\t      meta);\n\t} else if (arg_type == ARG_PTR_TO_PERCPU_BTF_ID) {\n\t\tif (!reg->btf_id) {\n\t\t\tverbose(env, \"Helper has invalid btf_id in R%d\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmeta->ret_btf = reg->btf;\n\t\tmeta->ret_btf_id = reg->btf_id;\n\t} else if (arg_type == ARG_PTR_TO_SPIN_LOCK) {\n\t\tif (meta->func_id == BPF_FUNC_spin_lock) {\n\t\t\tif (process_spin_lock(env, regno, true))\n\t\t\t\treturn -EACCES;\n\t\t} else if (meta->func_id == BPF_FUNC_spin_unlock) {\n\t\t\tif (process_spin_lock(env, regno, false))\n\t\t\t\treturn -EACCES;\n\t\t} else {\n\t\t\tverbose(env, \"verifier internal error\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (arg_type == ARG_PTR_TO_FUNC) {\n\t\tmeta->subprogno = reg->subprogno;\n\t} else if (arg_type_is_mem_ptr(arg_type)) {\n\t\t/* The access to this pointer is only checked when we hit the\n\t\t * next is_mem_size argument below.\n\t\t */\n\t\tmeta->raw_mode = (arg_type == ARG_PTR_TO_UNINIT_MEM);\n\t} else if (arg_type_is_mem_size(arg_type)) {\n\t\tbool zero_size_allowed = (arg_type == ARG_CONST_SIZE_OR_ZERO);\n\n\t\t/* This is used to refine r0 return value bounds for helpers\n\t\t * that enforce this value as an upper bound on return values.\n\t\t * See do_refine_retval_range() for helpers that can refine\n\t\t * the return value. C type of helper is u32 so we pull register\n\t\t * bound from umax_value however, if negative verifier errors\n\t\t * out. Only upper bounds can be learned because retval is an\n\t\t * int type and negative retvals are allowed.\n\t\t */\n\t\tmeta->msize_max_value = reg->umax_value;\n\n\t\t/* The register is SCALAR_VALUE; the access check\n\t\t * happens using its boundaries.\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off))\n\t\t\t/* For unprivileged variable accesses, disable raw\n\t\t\t * mode so that the program is required to\n\t\t\t * initialize all the memory that the helper could\n\t\t\t * just partially fill up.\n\t\t\t */\n\t\t\tmeta = NULL;\n\n\t\tif (reg->smin_value < 0) {\n\t\t\tverbose(env, \"R%d min value is negative, either use unsigned or 'var &= const'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (reg->umin_value == 0) {\n\t\t\terr = check_helper_mem_access(env, regno - 1, 0,\n\t\t\t\t\t\t      zero_size_allowed,\n\t\t\t\t\t\t      meta);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (reg->umax_value >= BPF_MAX_VAR_SIZ) {\n\t\t\tverbose(env, \"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno - 1,\n\t\t\t\t\t      reg->umax_value,\n\t\t\t\t\t      zero_size_allowed, meta);\n\t\tif (!err)\n\t\t\terr = mark_chain_precision(env, regno);\n\t} else if (arg_type_is_alloc_size(arg_type)) {\n\t\tif (!tnum_is_const(reg->var_off)) {\n\t\t\tverbose(env, \"R%d is not a known constant'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmeta->mem_size = reg->var_off.value;\n\t} else if (arg_type_is_int_ptr(arg_type)) {\n\t\tint size = int_ptr_type_to_size(arg_type);\n\n\t\terr = check_helper_mem_access(env, regno, size, false, meta);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = check_ptr_alignment(env, reg, 0, size, true);\n\t}\n\n\treturn err;\n}\n\nstatic bool may_update_sockmap(struct bpf_verifier_env *env, int func_id)\n{\n\tenum bpf_attach_type eatype = env->prog->expected_attach_type;\n\tenum bpf_prog_type type = resolve_prog_type(env->prog);\n\n\tif (func_id != BPF_FUNC_map_update_elem)\n\t\treturn false;\n\n\t/* It's not possible to get access to a locked struct sock in these\n\t * contexts, so updating is safe.\n\t */\n\tswitch (type) {\n\tcase BPF_PROG_TYPE_TRACING:\n\t\tif (eatype == BPF_TRACE_ITER)\n\t\t\treturn true;\n\t\tbreak;\n\tcase BPF_PROG_TYPE_SOCKET_FILTER:\n\tcase BPF_PROG_TYPE_SCHED_CLS:\n\tcase BPF_PROG_TYPE_SCHED_ACT:\n\tcase BPF_PROG_TYPE_XDP:\n\tcase BPF_PROG_TYPE_SK_REUSEPORT:\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\tcase BPF_PROG_TYPE_SK_LOOKUP:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tverbose(env, \"cannot update sockmap in this context\\n\");\n\treturn false;\n}\n\nstatic bool allow_tail_call_in_subprogs(struct bpf_verifier_env *env)\n{\n\treturn env->prog->jit_requested && IS_ENABLED(CONFIG_X86_64);\n}\n\nstatic int check_map_func_compatibility(struct bpf_verifier_env *env,\n\t\t\t\t\tstruct bpf_map *map, int func_id)\n{\n\tif (!map)\n\t\treturn 0;\n\n\t/* We need a two way check, first is from map perspective ... */\n\tswitch (map->map_type) {\n\tcase BPF_MAP_TYPE_PROG_ARRAY:\n\t\tif (func_id != BPF_FUNC_tail_call)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_PERF_EVENT_ARRAY:\n\t\tif (func_id != BPF_FUNC_perf_event_read &&\n\t\t    func_id != BPF_FUNC_perf_event_output &&\n\t\t    func_id != BPF_FUNC_skb_output &&\n\t\t    func_id != BPF_FUNC_perf_event_read_value &&\n\t\t    func_id != BPF_FUNC_xdp_output)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_RINGBUF:\n\t\tif (func_id != BPF_FUNC_ringbuf_output &&\n\t\t    func_id != BPF_FUNC_ringbuf_reserve &&\n\t\t    func_id != BPF_FUNC_ringbuf_submit &&\n\t\t    func_id != BPF_FUNC_ringbuf_discard &&\n\t\t    func_id != BPF_FUNC_ringbuf_query)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_STACK_TRACE:\n\t\tif (func_id != BPF_FUNC_get_stackid)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_CGROUP_ARRAY:\n\t\tif (func_id != BPF_FUNC_skb_under_cgroup &&\n\t\t    func_id != BPF_FUNC_current_task_under_cgroup)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_CGROUP_STORAGE:\n\tcase BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE:\n\t\tif (func_id != BPF_FUNC_get_local_storage)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_DEVMAP:\n\tcase BPF_MAP_TYPE_DEVMAP_HASH:\n\t\tif (func_id != BPF_FUNC_redirect_map &&\n\t\t    func_id != BPF_FUNC_map_lookup_elem)\n\t\t\tgoto error;\n\t\tbreak;\n\t/* Restrict bpf side of cpumap and xskmap, open when use-cases\n\t * appear.\n\t */\n\tcase BPF_MAP_TYPE_CPUMAP:\n\t\tif (func_id != BPF_FUNC_redirect_map)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_XSKMAP:\n\t\tif (func_id != BPF_FUNC_redirect_map &&\n\t\t    func_id != BPF_FUNC_map_lookup_elem)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_ARRAY_OF_MAPS:\n\tcase BPF_MAP_TYPE_HASH_OF_MAPS:\n\t\tif (func_id != BPF_FUNC_map_lookup_elem)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_SOCKMAP:\n\t\tif (func_id != BPF_FUNC_sk_redirect_map &&\n\t\t    func_id != BPF_FUNC_sock_map_update &&\n\t\t    func_id != BPF_FUNC_map_delete_elem &&\n\t\t    func_id != BPF_FUNC_msg_redirect_map &&\n\t\t    func_id != BPF_FUNC_sk_select_reuseport &&\n\t\t    func_id != BPF_FUNC_map_lookup_elem &&\n\t\t    !may_update_sockmap(env, func_id))\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_SOCKHASH:\n\t\tif (func_id != BPF_FUNC_sk_redirect_hash &&\n\t\t    func_id != BPF_FUNC_sock_hash_update &&\n\t\t    func_id != BPF_FUNC_map_delete_elem &&\n\t\t    func_id != BPF_FUNC_msg_redirect_hash &&\n\t\t    func_id != BPF_FUNC_sk_select_reuseport &&\n\t\t    func_id != BPF_FUNC_map_lookup_elem &&\n\t\t    !may_update_sockmap(env, func_id))\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_REUSEPORT_SOCKARRAY:\n\t\tif (func_id != BPF_FUNC_sk_select_reuseport)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_QUEUE:\n\tcase BPF_MAP_TYPE_STACK:\n\t\tif (func_id != BPF_FUNC_map_peek_elem &&\n\t\t    func_id != BPF_FUNC_map_pop_elem &&\n\t\t    func_id != BPF_FUNC_map_push_elem)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_SK_STORAGE:\n\t\tif (func_id != BPF_FUNC_sk_storage_get &&\n\t\t    func_id != BPF_FUNC_sk_storage_delete)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_INODE_STORAGE:\n\t\tif (func_id != BPF_FUNC_inode_storage_get &&\n\t\t    func_id != BPF_FUNC_inode_storage_delete)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_TASK_STORAGE:\n\t\tif (func_id != BPF_FUNC_task_storage_get &&\n\t\t    func_id != BPF_FUNC_task_storage_delete)\n\t\t\tgoto error;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* ... and second from the function itself. */\n\tswitch (func_id) {\n\tcase BPF_FUNC_tail_call:\n\t\tif (map->map_type != BPF_MAP_TYPE_PROG_ARRAY)\n\t\t\tgoto error;\n\t\tif (env->subprog_cnt > 1 && !allow_tail_call_in_subprogs(env)) {\n\t\t\tverbose(env, \"tail_calls are not allowed in non-JITed programs with bpf-to-bpf calls\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase BPF_FUNC_perf_event_read:\n\tcase BPF_FUNC_perf_event_output:\n\tcase BPF_FUNC_perf_event_read_value:\n\tcase BPF_FUNC_skb_output:\n\tcase BPF_FUNC_xdp_output:\n\t\tif (map->map_type != BPF_MAP_TYPE_PERF_EVENT_ARRAY)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_FUNC_get_stackid:\n\t\tif (map->map_type != BPF_MAP_TYPE_STACK_TRACE)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_FUNC_current_task_under_cgroup:\n\tcase BPF_FUNC_skb_under_cgroup:\n\t\tif (map->map_type != BPF_MAP_TYPE_CGROUP_ARRAY)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_FUNC_redirect_map:\n\t\tif (map->map_type != BPF_MAP_TYPE_DEVMAP &&\n\t\t    map->map_type != BPF_MAP_TYPE_DEVMAP_HASH &&\n\t\t    map->map_type != BPF_MAP_TYPE_CPUMAP &&\n\t\t    map->map_type != BPF_MAP_TYPE_XSKMAP)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_FUNC_sk_redirect_map:\n\tcase BPF_FUNC_msg_redirect_map:\n\tcase BPF_FUNC_sock_map_update:\n\t\tif (map->map_type != BPF_MAP_TYPE_SOCKMAP)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_FUNC_sk_redirect_hash:\n\tcase BPF_FUNC_msg_redirect_hash:\n\tcase BPF_FUNC_sock_hash_update:\n\t\tif (map->map_type != BPF_MAP_TYPE_SOCKHASH)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_FUNC_get_local_storage:\n\t\tif (map->map_type != BPF_MAP_TYPE_CGROUP_STORAGE &&\n\t\t    map->map_type != BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_FUNC_sk_select_reuseport:\n\t\tif (map->map_type != BPF_MAP_TYPE_REUSEPORT_SOCKARRAY &&\n\t\t    map->map_type != BPF_MAP_TYPE_SOCKMAP &&\n\t\t    map->map_type != BPF_MAP_TYPE_SOCKHASH)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_FUNC_map_peek_elem:\n\tcase BPF_FUNC_map_pop_elem:\n\tcase BPF_FUNC_map_push_elem:\n\t\tif (map->map_type != BPF_MAP_TYPE_QUEUE &&\n\t\t    map->map_type != BPF_MAP_TYPE_STACK)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_FUNC_sk_storage_get:\n\tcase BPF_FUNC_sk_storage_delete:\n\t\tif (map->map_type != BPF_MAP_TYPE_SK_STORAGE)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_FUNC_inode_storage_get:\n\tcase BPF_FUNC_inode_storage_delete:\n\t\tif (map->map_type != BPF_MAP_TYPE_INODE_STORAGE)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_FUNC_task_storage_get:\n\tcase BPF_FUNC_task_storage_delete:\n\t\tif (map->map_type != BPF_MAP_TYPE_TASK_STORAGE)\n\t\t\tgoto error;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\nerror:\n\tverbose(env, \"cannot pass map_type %d into func %s#%d\\n\",\n\t\tmap->map_type, func_id_name(func_id), func_id);\n\treturn -EINVAL;\n}\n\nstatic bool check_raw_mode_ok(const struct bpf_func_proto *fn)\n{\n\tint count = 0;\n\n\tif (fn->arg1_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg2_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg3_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg4_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg5_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\n\t/* We only support one arg being in raw mode at the moment,\n\t * which is sufficient for the helper functions we have\n\t * right now.\n\t */\n\treturn count <= 1;\n}\n\nstatic bool check_args_pair_invalid(enum bpf_arg_type arg_curr,\n\t\t\t\t    enum bpf_arg_type arg_next)\n{\n\treturn (arg_type_is_mem_ptr(arg_curr) &&\n\t        !arg_type_is_mem_size(arg_next)) ||\n\t       (!arg_type_is_mem_ptr(arg_curr) &&\n\t\targ_type_is_mem_size(arg_next));\n}\n\nstatic bool check_arg_pair_ok(const struct bpf_func_proto *fn)\n{\n\t/* bpf_xxx(..., buf, len) call will access 'len'\n\t * bytes from memory 'buf'. Both arg types need\n\t * to be paired, so make sure there's no buggy\n\t * helper function specification.\n\t */\n\tif (arg_type_is_mem_size(fn->arg1_type) ||\n\t    arg_type_is_mem_ptr(fn->arg5_type)  ||\n\t    check_args_pair_invalid(fn->arg1_type, fn->arg2_type) ||\n\t    check_args_pair_invalid(fn->arg2_type, fn->arg3_type) ||\n\t    check_args_pair_invalid(fn->arg3_type, fn->arg4_type) ||\n\t    check_args_pair_invalid(fn->arg4_type, fn->arg5_type))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool check_refcount_ok(const struct bpf_func_proto *fn, int func_id)\n{\n\tint count = 0;\n\n\tif (arg_type_may_be_refcounted(fn->arg1_type))\n\t\tcount++;\n\tif (arg_type_may_be_refcounted(fn->arg2_type))\n\t\tcount++;\n\tif (arg_type_may_be_refcounted(fn->arg3_type))\n\t\tcount++;\n\tif (arg_type_may_be_refcounted(fn->arg4_type))\n\t\tcount++;\n\tif (arg_type_may_be_refcounted(fn->arg5_type))\n\t\tcount++;\n\n\t/* A reference acquiring function cannot acquire\n\t * another refcounted ptr.\n\t */\n\tif (may_be_acquire_function(func_id) && count)\n\t\treturn false;\n\n\t/* We only support one arg being unreferenced at the moment,\n\t * which is sufficient for the helper functions we have right now.\n\t */\n\treturn count <= 1;\n}\n\nstatic bool check_btf_id_ok(const struct bpf_func_proto *fn)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fn->arg_type); i++) {\n\t\tif (fn->arg_type[i] == ARG_PTR_TO_BTF_ID && !fn->arg_btf_id[i])\n\t\t\treturn false;\n\n\t\tif (fn->arg_type[i] != ARG_PTR_TO_BTF_ID && fn->arg_btf_id[i])\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int check_func_proto(const struct bpf_func_proto *fn, int func_id)\n{\n\treturn check_raw_mode_ok(fn) &&\n\t       check_arg_pair_ok(fn) &&\n\t       check_btf_id_ok(fn) &&\n\t       check_refcount_ok(fn, func_id) ? 0 : -EINVAL;\n}\n\n/* Packet data might have moved, any old PTR_TO_PACKET[_META,_END]\n * are now invalid, so turn them into unknown SCALAR_VALUE.\n */\nstatic void __clear_all_pkt_pointers(struct bpf_verifier_env *env,\n\t\t\t\t     struct bpf_func_state *state)\n{\n\tstruct bpf_reg_state *regs = state->regs, *reg;\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++)\n\t\tif (reg_is_pkt_pointer_any(&regs[i]))\n\t\t\tmark_reg_unknown(env, regs, i);\n\n\tbpf_for_each_spilled_reg(i, state, reg) {\n\t\tif (!reg)\n\t\t\tcontinue;\n\t\tif (reg_is_pkt_pointer_any(reg))\n\t\t\t__mark_reg_unknown(env, reg);\n\t}\n}\n\nstatic void clear_all_pkt_pointers(struct bpf_verifier_env *env)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tint i;\n\n\tfor (i = 0; i <= vstate->curframe; i++)\n\t\t__clear_all_pkt_pointers(env, vstate->frame[i]);\n}\n\nenum {\n\tAT_PKT_END = -1,\n\tBEYOND_PKT_END = -2,\n};\n\nstatic void mark_pkt_end(struct bpf_verifier_state *vstate, int regn, bool range_open)\n{\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tstruct bpf_reg_state *reg = &state->regs[regn];\n\n\tif (reg->type != PTR_TO_PACKET)\n\t\t/* PTR_TO_PACKET_META is not supported yet */\n\t\treturn;\n\n\t/* The 'reg' is pkt > pkt_end or pkt >= pkt_end.\n\t * How far beyond pkt_end it goes is unknown.\n\t * if (!range_open) it's the case of pkt >= pkt_end\n\t * if (range_open) it's the case of pkt > pkt_end\n\t * hence this pointer is at least 1 byte bigger than pkt_end\n\t */\n\tif (range_open)\n\t\treg->range = BEYOND_PKT_END;\n\telse\n\t\treg->range = AT_PKT_END;\n}\n\nstatic void release_reg_references(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_func_state *state,\n\t\t\t\t   int ref_obj_id)\n{\n\tstruct bpf_reg_state *regs = state->regs, *reg;\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++)\n\t\tif (regs[i].ref_obj_id == ref_obj_id)\n\t\t\tmark_reg_unknown(env, regs, i);\n\n\tbpf_for_each_spilled_reg(i, state, reg) {\n\t\tif (!reg)\n\t\t\tcontinue;\n\t\tif (reg->ref_obj_id == ref_obj_id)\n\t\t\t__mark_reg_unknown(env, reg);\n\t}\n}\n\n/* The pointer with the specified id has released its reference to kernel\n * resources. Identify all copies of the same pointer and clear the reference.\n */\nstatic int release_reference(struct bpf_verifier_env *env,\n\t\t\t     int ref_obj_id)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tint err;\n\tint i;\n\n\terr = release_reference_state(cur_func(env), ref_obj_id);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i <= vstate->curframe; i++)\n\t\trelease_reg_references(env, vstate->frame[i], ref_obj_id);\n\n\treturn 0;\n}\n\nstatic void clear_caller_saved_regs(struct bpf_verifier_env *env,\n\t\t\t\t    struct bpf_reg_state *regs)\n{\n\tint i;\n\n\t/* after the call registers r0 - r5 were scratched */\n\tfor (i = 0; i < CALLER_SAVED_REGS; i++) {\n\t\tmark_reg_not_init(env, regs, caller_saved[i]);\n\t\tcheck_reg_arg(env, caller_saved[i], DST_OP_NO_MARK);\n\t}\n}\n\ntypedef int (*set_callee_state_fn)(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_func_state *caller,\n\t\t\t\t   struct bpf_func_state *callee,\n\t\t\t\t   int insn_idx);\n\nstatic int __check_func_call(struct bpf_verifier_env *env, struct bpf_insn *insn,\n\t\t\t     int *insn_idx, int subprog,\n\t\t\t     set_callee_state_fn set_callee_state_cb)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_func_info_aux *func_info_aux;\n\tstruct bpf_func_state *caller, *callee;\n\tint err;\n\tbool is_global = false;\n\n\tif (state->curframe + 1 >= MAX_CALL_FRAMES) {\n\t\tverbose(env, \"the call stack of %d frames is too deep\\n\",\n\t\t\tstate->curframe + 2);\n\t\treturn -E2BIG;\n\t}\n\n\tcaller = state->frame[state->curframe];\n\tif (state->frame[state->curframe + 1]) {\n\t\tverbose(env, \"verifier bug. Frame %d already allocated\\n\",\n\t\t\tstate->curframe + 1);\n\t\treturn -EFAULT;\n\t}\n\n\tfunc_info_aux = env->prog->aux->func_info_aux;\n\tif (func_info_aux)\n\t\tis_global = func_info_aux[subprog].linkage == BTF_FUNC_GLOBAL;\n\terr = btf_check_func_arg_match(env, subprog, caller->regs);\n\tif (err == -EFAULT)\n\t\treturn err;\n\tif (is_global) {\n\t\tif (err) {\n\t\t\tverbose(env, \"Caller passes invalid args into func#%d\\n\",\n\t\t\t\tsubprog);\n\t\t\treturn err;\n\t\t} else {\n\t\t\tif (env->log.level & BPF_LOG_LEVEL)\n\t\t\t\tverbose(env,\n\t\t\t\t\t\"Func#%d is global and valid. Skipping.\\n\",\n\t\t\t\t\tsubprog);\n\t\t\tclear_caller_saved_regs(env, caller->regs);\n\n\t\t\t/* All global functions return a 64-bit SCALAR_VALUE */\n\t\t\tmark_reg_unknown(env, caller->regs, BPF_REG_0);\n\t\t\tcaller->regs[BPF_REG_0].subreg_def = DEF_NOT_SUBREG;\n\n\t\t\t/* continue with next insn after call */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcallee = kzalloc(sizeof(*callee), GFP_KERNEL);\n\tif (!callee)\n\t\treturn -ENOMEM;\n\tstate->frame[state->curframe + 1] = callee;\n\n\t/* callee cannot access r0, r6 - r9 for reading and has to write\n\t * into its own stack before reading from it.\n\t * callee can read/write into caller's stack\n\t */\n\tinit_func_state(env, callee,\n\t\t\t/* remember the callsite, it will be used by bpf_exit */\n\t\t\t*insn_idx /* callsite */,\n\t\t\tstate->curframe + 1 /* frameno within this callchain */,\n\t\t\tsubprog /* subprog number within this prog */);\n\n\t/* Transfer references to the callee */\n\terr = transfer_reference_state(callee, caller);\n\tif (err)\n\t\treturn err;\n\n\terr = set_callee_state_cb(env, caller, callee, *insn_idx);\n\tif (err)\n\t\treturn err;\n\n\tclear_caller_saved_regs(env, caller->regs);\n\n\t/* only increment it after check_reg_arg() finished */\n\tstate->curframe++;\n\n\t/* and go analyze first insn of the callee */\n\t*insn_idx = env->subprog_info[subprog].start - 1;\n\n\tif (env->log.level & BPF_LOG_LEVEL) {\n\t\tverbose(env, \"caller:\\n\");\n\t\tprint_verifier_state(env, caller);\n\t\tverbose(env, \"callee:\\n\");\n\t\tprint_verifier_state(env, callee);\n\t}\n\treturn 0;\n}\n\nint map_set_for_each_callback_args(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_func_state *caller,\n\t\t\t\t   struct bpf_func_state *callee)\n{\n\t/* bpf_for_each_map_elem(struct bpf_map *map, void *callback_fn,\n\t *      void *callback_ctx, u64 flags);\n\t * callback_fn(struct bpf_map *map, void *key, void *value,\n\t *      void *callback_ctx);\n\t */\n\tcallee->regs[BPF_REG_1] = caller->regs[BPF_REG_1];\n\n\tcallee->regs[BPF_REG_2].type = PTR_TO_MAP_KEY;\n\t__mark_reg_known_zero(&callee->regs[BPF_REG_2]);\n\tcallee->regs[BPF_REG_2].map_ptr = caller->regs[BPF_REG_1].map_ptr;\n\n\tcallee->regs[BPF_REG_3].type = PTR_TO_MAP_VALUE;\n\t__mark_reg_known_zero(&callee->regs[BPF_REG_3]);\n\tcallee->regs[BPF_REG_3].map_ptr = caller->regs[BPF_REG_1].map_ptr;\n\n\t/* pointer to stack or null */\n\tcallee->regs[BPF_REG_4] = caller->regs[BPF_REG_3];\n\n\t/* unused */\n\t__mark_reg_not_init(env, &callee->regs[BPF_REG_5]);\n\treturn 0;\n}\n\nstatic int set_callee_state(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_func_state *caller,\n\t\t\t    struct bpf_func_state *callee, int insn_idx)\n{\n\tint i;\n\n\t/* copy r1 - r5 args that callee can access.  The copy includes parent\n\t * pointers, which connects us up to the liveness chain\n\t */\n\tfor (i = BPF_REG_1; i <= BPF_REG_5; i++)\n\t\tcallee->regs[i] = caller->regs[i];\n\treturn 0;\n}\n\nstatic int check_func_call(struct bpf_verifier_env *env, struct bpf_insn *insn,\n\t\t\t   int *insn_idx)\n{\n\tint subprog, target_insn;\n\n\ttarget_insn = *insn_idx + insn->imm + 1;\n\tsubprog = find_subprog(env, target_insn);\n\tif (subprog < 0) {\n\t\tverbose(env, \"verifier bug. No program starts at insn %d\\n\",\n\t\t\ttarget_insn);\n\t\treturn -EFAULT;\n\t}\n\n\treturn __check_func_call(env, insn, insn_idx, subprog, set_callee_state);\n}\n\nstatic int set_map_elem_callback_state(struct bpf_verifier_env *env,\n\t\t\t\t       struct bpf_func_state *caller,\n\t\t\t\t       struct bpf_func_state *callee,\n\t\t\t\t       int insn_idx)\n{\n\tstruct bpf_insn_aux_data *insn_aux = &env->insn_aux_data[insn_idx];\n\tstruct bpf_map *map;\n\tint err;\n\n\tif (bpf_map_ptr_poisoned(insn_aux)) {\n\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmap = BPF_MAP_PTR(insn_aux->map_ptr_state);\n\tif (!map->ops->map_set_for_each_callback_args ||\n\t    !map->ops->map_for_each_callback) {\n\t\tverbose(env, \"callback function not allowed for map\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\terr = map->ops->map_set_for_each_callback_args(env, caller, callee);\n\tif (err)\n\t\treturn err;\n\n\tcallee->in_callback_fn = true;\n\treturn 0;\n}\n\nstatic int prepare_func_exit(struct bpf_verifier_env *env, int *insn_idx)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_func_state *caller, *callee;\n\tstruct bpf_reg_state *r0;\n\tint err;\n\n\tcallee = state->frame[state->curframe];\n\tr0 = &callee->regs[BPF_REG_0];\n\tif (r0->type == PTR_TO_STACK) {\n\t\t/* technically it's ok to return caller's stack pointer\n\t\t * (or caller's caller's pointer) back to the caller,\n\t\t * since these pointers are valid. Only current stack\n\t\t * pointer will be invalid as soon as function exits,\n\t\t * but let's be conservative\n\t\t */\n\t\tverbose(env, \"cannot return stack pointer to the caller\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstate->curframe--;\n\tcaller = state->frame[state->curframe];\n\tif (callee->in_callback_fn) {\n\t\t/* enforce R0 return value range [0, 1]. */\n\t\tstruct tnum range = tnum_range(0, 1);\n\n\t\tif (r0->type != SCALAR_VALUE) {\n\t\t\tverbose(env, \"R0 not a scalar value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (!tnum_in(range, r0->var_off)) {\n\t\t\tverbose_invalid_scalar(env, r0, &range, \"callback return\", \"R0\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t/* return to the caller whatever r0 had in the callee */\n\t\tcaller->regs[BPF_REG_0] = *r0;\n\t}\n\n\t/* Transfer references to the caller */\n\terr = transfer_reference_state(caller, callee);\n\tif (err)\n\t\treturn err;\n\n\t*insn_idx = callee->callsite + 1;\n\tif (env->log.level & BPF_LOG_LEVEL) {\n\t\tverbose(env, \"returning from callee:\\n\");\n\t\tprint_verifier_state(env, callee);\n\t\tverbose(env, \"to caller at %d:\\n\", *insn_idx);\n\t\tprint_verifier_state(env, caller);\n\t}\n\t/* clear everything in the callee */\n\tfree_func_state(callee);\n\tstate->frame[state->curframe + 1] = NULL;\n\treturn 0;\n}\n\nstatic void do_refine_retval_range(struct bpf_reg_state *regs, int ret_type,\n\t\t\t\t   int func_id,\n\t\t\t\t   struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *ret_reg = &regs[BPF_REG_0];\n\n\tif (ret_type != RET_INTEGER ||\n\t    (func_id != BPF_FUNC_get_stack &&\n\t     func_id != BPF_FUNC_probe_read_str &&\n\t     func_id != BPF_FUNC_probe_read_kernel_str &&\n\t     func_id != BPF_FUNC_probe_read_user_str))\n\t\treturn;\n\n\tret_reg->smax_value = meta->msize_max_value;\n\tret_reg->s32_max_value = meta->msize_max_value;\n\tret_reg->smin_value = -MAX_ERRNO;\n\tret_reg->s32_min_value = -MAX_ERRNO;\n\t__reg_deduce_bounds(ret_reg);\n\t__reg_bound_offset(ret_reg);\n\t__update_reg_bounds(ret_reg);\n}\n\nstatic int\nrecord_func_map(struct bpf_verifier_env *env, struct bpf_call_arg_meta *meta,\n\t\tint func_id, int insn_idx)\n{\n\tstruct bpf_insn_aux_data *aux = &env->insn_aux_data[insn_idx];\n\tstruct bpf_map *map = meta->map_ptr;\n\n\tif (func_id != BPF_FUNC_tail_call &&\n\t    func_id != BPF_FUNC_map_lookup_elem &&\n\t    func_id != BPF_FUNC_map_update_elem &&\n\t    func_id != BPF_FUNC_map_delete_elem &&\n\t    func_id != BPF_FUNC_map_push_elem &&\n\t    func_id != BPF_FUNC_map_pop_elem &&\n\t    func_id != BPF_FUNC_map_peek_elem &&\n\t    func_id != BPF_FUNC_for_each_map_elem &&\n\t    func_id != BPF_FUNC_redirect_map)\n\t\treturn 0;\n\n\tif (map == NULL) {\n\t\tverbose(env, \"kernel subsystem misconfigured verifier\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* In case of read-only, some additional restrictions\n\t * need to be applied in order to prevent altering the\n\t * state of the map from program side.\n\t */\n\tif ((map->map_flags & BPF_F_RDONLY_PROG) &&\n\t    (func_id == BPF_FUNC_map_delete_elem ||\n\t     func_id == BPF_FUNC_map_update_elem ||\n\t     func_id == BPF_FUNC_map_push_elem ||\n\t     func_id == BPF_FUNC_map_pop_elem)) {\n\t\tverbose(env, \"write into map forbidden\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (!BPF_MAP_PTR(aux->map_ptr_state))\n\t\tbpf_map_ptr_store(aux, meta->map_ptr,\n\t\t\t\t  !meta->map_ptr->bypass_spec_v1);\n\telse if (BPF_MAP_PTR(aux->map_ptr_state) != meta->map_ptr)\n\t\tbpf_map_ptr_store(aux, BPF_MAP_PTR_POISON,\n\t\t\t\t  !meta->map_ptr->bypass_spec_v1);\n\treturn 0;\n}\n\nstatic int\nrecord_func_key(struct bpf_verifier_env *env, struct bpf_call_arg_meta *meta,\n\t\tint func_id, int insn_idx)\n{\n\tstruct bpf_insn_aux_data *aux = &env->insn_aux_data[insn_idx];\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg;\n\tstruct bpf_map *map = meta->map_ptr;\n\tstruct tnum range;\n\tu64 val;\n\tint err;\n\n\tif (func_id != BPF_FUNC_tail_call)\n\t\treturn 0;\n\tif (!map || map->map_type != BPF_MAP_TYPE_PROG_ARRAY) {\n\t\tverbose(env, \"kernel subsystem misconfigured verifier\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trange = tnum_range(0, map->max_entries - 1);\n\treg = &regs[BPF_REG_3];\n\n\tif (!register_is_const(reg) || !tnum_in(range, reg->var_off)) {\n\t\tbpf_map_key_store(aux, BPF_MAP_KEY_POISON);\n\t\treturn 0;\n\t}\n\n\terr = mark_chain_precision(env, BPF_REG_3);\n\tif (err)\n\t\treturn err;\n\n\tval = reg->var_off.value;\n\tif (bpf_map_key_unseen(aux))\n\t\tbpf_map_key_store(aux, val);\n\telse if (!bpf_map_key_poisoned(aux) &&\n\t\t  bpf_map_key_immediate(aux) != val)\n\t\tbpf_map_key_store(aux, BPF_MAP_KEY_POISON);\n\treturn 0;\n}\n\nstatic int check_reference_leak(struct bpf_verifier_env *env)\n{\n\tstruct bpf_func_state *state = cur_func(env);\n\tint i;\n\n\tfor (i = 0; i < state->acquired_refs; i++) {\n\t\tverbose(env, \"Unreleased reference id=%d alloc_insn=%d\\n\",\n\t\t\tstate->refs[i].id, state->refs[i].insn_idx);\n\t}\n\treturn state->acquired_refs ? -EINVAL : 0;\n}\n\nstatic int check_helper_call(struct bpf_verifier_env *env, struct bpf_insn *insn,\n\t\t\t     int *insn_idx_p)\n{\n\tconst struct bpf_func_proto *fn = NULL;\n\tstruct bpf_reg_state *regs;\n\tstruct bpf_call_arg_meta meta;\n\tint insn_idx = *insn_idx_p;\n\tbool changes_data;\n\tint i, err, func_id;\n\n\t/* find function prototype */\n\tfunc_id = insn->imm;\n\tif (func_id < 0 || func_id >= __BPF_FUNC_MAX_ID) {\n\t\tverbose(env, \"invalid func %s#%d\\n\", func_id_name(func_id),\n\t\t\tfunc_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (env->ops->get_func_proto)\n\t\tfn = env->ops->get_func_proto(func_id, env->prog);\n\tif (!fn) {\n\t\tverbose(env, \"unknown func %s#%d\\n\", func_id_name(func_id),\n\t\t\tfunc_id);\n\t\treturn -EINVAL;\n\t}\n\n\t/* eBPF programs must be GPL compatible to use GPL-ed functions */\n\tif (!env->prog->gpl_compatible && fn->gpl_only) {\n\t\tverbose(env, \"cannot call GPL-restricted function from non-GPL compatible program\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (fn->allowed && !fn->allowed(env->prog)) {\n\t\tverbose(env, \"helper call is not allowed in probe\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* With LD_ABS/IND some JITs save/restore skb from r1. */\n\tchanges_data = bpf_helper_changes_pkt_data(fn->func);\n\tif (changes_data && fn->arg1_type != ARG_PTR_TO_CTX) {\n\t\tverbose(env, \"kernel subsystem misconfigured func %s#%d: r1 != ctx\\n\",\n\t\t\tfunc_id_name(func_id), func_id);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&meta, 0, sizeof(meta));\n\tmeta.pkt_access = fn->pkt_access;\n\n\terr = check_func_proto(fn, func_id);\n\tif (err) {\n\t\tverbose(env, \"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\tfunc_id_name(func_id), func_id);\n\t\treturn err;\n\t}\n\n\tmeta.func_id = func_id;\n\t/* check args */\n\tfor (i = 0; i < MAX_BPF_FUNC_REG_ARGS; i++) {\n\t\terr = check_func_arg(env, i, &meta, fn);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = record_func_map(env, &meta, func_id, insn_idx);\n\tif (err)\n\t\treturn err;\n\n\terr = record_func_key(env, &meta, func_id, insn_idx);\n\tif (err)\n\t\treturn err;\n\n\t/* Mark slots with STACK_MISC in case of raw mode, stack offset\n\t * is inferred from register state.\n\t */\n\tfor (i = 0; i < meta.access_size; i++) {\n\t\terr = check_mem_access(env, insn_idx, meta.regno, i, BPF_B,\n\t\t\t\t       BPF_WRITE, -1, false);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (func_id == BPF_FUNC_tail_call) {\n\t\terr = check_reference_leak(env);\n\t\tif (err) {\n\t\t\tverbose(env, \"tail_call would lead to reference leak\\n\");\n\t\t\treturn err;\n\t\t}\n\t} else if (is_release_function(func_id)) {\n\t\terr = release_reference(env, meta.ref_obj_id);\n\t\tif (err) {\n\t\t\tverbose(env, \"func %s#%d reference has not been acquired before\\n\",\n\t\t\t\tfunc_id_name(func_id), func_id);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tregs = cur_regs(env);\n\n\t/* check that flags argument in get_local_storage(map, flags) is 0,\n\t * this is required because get_local_storage() can't return an error.\n\t */\n\tif (func_id == BPF_FUNC_get_local_storage &&\n\t    !register_is_null(&regs[BPF_REG_2])) {\n\t\tverbose(env, \"get_local_storage() doesn't support non-zero flags\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (func_id == BPF_FUNC_for_each_map_elem) {\n\t\terr = __check_func_call(env, insn, insn_idx_p, meta.subprogno,\n\t\t\t\t\tset_map_elem_callback_state);\n\t\tif (err < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* reset caller saved regs */\n\tfor (i = 0; i < CALLER_SAVED_REGS; i++) {\n\t\tmark_reg_not_init(env, regs, caller_saved[i]);\n\t\tcheck_reg_arg(env, caller_saved[i], DST_OP_NO_MARK);\n\t}\n\n\t/* helper call returns 64-bit value. */\n\tregs[BPF_REG_0].subreg_def = DEF_NOT_SUBREG;\n\n\t/* update return register (already marked as written above) */\n\tif (fn->ret_type == RET_INTEGER) {\n\t\t/* sets type to SCALAR_VALUE */\n\t\tmark_reg_unknown(env, regs, BPF_REG_0);\n\t} else if (fn->ret_type == RET_VOID) {\n\t\tregs[BPF_REG_0].type = NOT_INIT;\n\t} else if (fn->ret_type == RET_PTR_TO_MAP_VALUE_OR_NULL ||\n\t\t   fn->ret_type == RET_PTR_TO_MAP_VALUE) {\n\t\t/* There is no offset yet applied, variable or fixed */\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\t/* remember map_ptr, so that check_map_access()\n\t\t * can check 'value_size' boundary of memory access\n\t\t * to map element returned from bpf_map_lookup_elem()\n\t\t */\n\t\tif (meta.map_ptr == NULL) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured verifier\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tregs[BPF_REG_0].map_ptr = meta.map_ptr;\n\t\tif (fn->ret_type == RET_PTR_TO_MAP_VALUE) {\n\t\t\tregs[BPF_REG_0].type = PTR_TO_MAP_VALUE;\n\t\t\tif (map_value_has_spin_lock(meta.map_ptr))\n\t\t\t\tregs[BPF_REG_0].id = ++env->id_gen;\n\t\t} else {\n\t\t\tregs[BPF_REG_0].type = PTR_TO_MAP_VALUE_OR_NULL;\n\t\t}\n\t} else if (fn->ret_type == RET_PTR_TO_SOCKET_OR_NULL) {\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\tregs[BPF_REG_0].type = PTR_TO_SOCKET_OR_NULL;\n\t} else if (fn->ret_type == RET_PTR_TO_SOCK_COMMON_OR_NULL) {\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\tregs[BPF_REG_0].type = PTR_TO_SOCK_COMMON_OR_NULL;\n\t} else if (fn->ret_type == RET_PTR_TO_TCP_SOCK_OR_NULL) {\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\tregs[BPF_REG_0].type = PTR_TO_TCP_SOCK_OR_NULL;\n\t} else if (fn->ret_type == RET_PTR_TO_ALLOC_MEM_OR_NULL) {\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\tregs[BPF_REG_0].type = PTR_TO_MEM_OR_NULL;\n\t\tregs[BPF_REG_0].mem_size = meta.mem_size;\n\t} else if (fn->ret_type == RET_PTR_TO_MEM_OR_BTF_ID_OR_NULL ||\n\t\t   fn->ret_type == RET_PTR_TO_MEM_OR_BTF_ID) {\n\t\tconst struct btf_type *t;\n\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\tt = btf_type_skip_modifiers(meta.ret_btf, meta.ret_btf_id, NULL);\n\t\tif (!btf_type_is_struct(t)) {\n\t\t\tu32 tsize;\n\t\t\tconst struct btf_type *ret;\n\t\t\tconst char *tname;\n\n\t\t\t/* resolve the type size of ksym. */\n\t\t\tret = btf_resolve_size(meta.ret_btf, t, &tsize);\n\t\t\tif (IS_ERR(ret)) {\n\t\t\t\ttname = btf_name_by_offset(meta.ret_btf, t->name_off);\n\t\t\t\tverbose(env, \"unable to resolve the size of type '%s': %ld\\n\",\n\t\t\t\t\ttname, PTR_ERR(ret));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tregs[BPF_REG_0].type =\n\t\t\t\tfn->ret_type == RET_PTR_TO_MEM_OR_BTF_ID ?\n\t\t\t\tPTR_TO_MEM : PTR_TO_MEM_OR_NULL;\n\t\t\tregs[BPF_REG_0].mem_size = tsize;\n\t\t} else {\n\t\t\tregs[BPF_REG_0].type =\n\t\t\t\tfn->ret_type == RET_PTR_TO_MEM_OR_BTF_ID ?\n\t\t\t\tPTR_TO_BTF_ID : PTR_TO_BTF_ID_OR_NULL;\n\t\t\tregs[BPF_REG_0].btf = meta.ret_btf;\n\t\t\tregs[BPF_REG_0].btf_id = meta.ret_btf_id;\n\t\t}\n\t} else if (fn->ret_type == RET_PTR_TO_BTF_ID_OR_NULL ||\n\t\t   fn->ret_type == RET_PTR_TO_BTF_ID) {\n\t\tint ret_btf_id;\n\n\t\tmark_reg_known_zero(env, regs, BPF_REG_0);\n\t\tregs[BPF_REG_0].type = fn->ret_type == RET_PTR_TO_BTF_ID ?\n\t\t\t\t\t\t     PTR_TO_BTF_ID :\n\t\t\t\t\t\t     PTR_TO_BTF_ID_OR_NULL;\n\t\tret_btf_id = *fn->ret_btf_id;\n\t\tif (ret_btf_id == 0) {\n\t\t\tverbose(env, \"invalid return type %d of func %s#%d\\n\",\n\t\t\t\tfn->ret_type, func_id_name(func_id), func_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* current BPF helper definitions are only coming from\n\t\t * built-in code with type IDs from  vmlinux BTF\n\t\t */\n\t\tregs[BPF_REG_0].btf = btf_vmlinux;\n\t\tregs[BPF_REG_0].btf_id = ret_btf_id;\n\t} else {\n\t\tverbose(env, \"unknown return type %d of func %s#%d\\n\",\n\t\t\tfn->ret_type, func_id_name(func_id), func_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (reg_type_may_be_null(regs[BPF_REG_0].type))\n\t\tregs[BPF_REG_0].id = ++env->id_gen;\n\n\tif (is_ptr_cast_function(func_id)) {\n\t\t/* For release_reference() */\n\t\tregs[BPF_REG_0].ref_obj_id = meta.ref_obj_id;\n\t} else if (is_acquire_function(func_id, meta.map_ptr)) {\n\t\tint id = acquire_reference_state(env, insn_idx);\n\n\t\tif (id < 0)\n\t\t\treturn id;\n\t\t/* For mark_ptr_or_null_reg() */\n\t\tregs[BPF_REG_0].id = id;\n\t\t/* For release_reference() */\n\t\tregs[BPF_REG_0].ref_obj_id = id;\n\t}\n\n\tdo_refine_retval_range(regs, fn->ret_type, func_id, &meta);\n\n\terr = check_map_func_compatibility(env, meta.map_ptr, func_id);\n\tif (err)\n\t\treturn err;\n\n\tif ((func_id == BPF_FUNC_get_stack ||\n\t     func_id == BPF_FUNC_get_task_stack) &&\n\t    !env->prog->has_callchain_buf) {\n\t\tconst char *err_str;\n\n#ifdef CONFIG_PERF_EVENTS\n\t\terr = get_callchain_buffers(sysctl_perf_event_max_stack);\n\t\terr_str = \"cannot get callchain buffer for func %s#%d\\n\";\n#else\n\t\terr = -ENOTSUPP;\n\t\terr_str = \"func %s#%d not supported without CONFIG_PERF_EVENTS\\n\";\n#endif\n\t\tif (err) {\n\t\t\tverbose(env, err_str, func_id_name(func_id), func_id);\n\t\t\treturn err;\n\t\t}\n\n\t\tenv->prog->has_callchain_buf = true;\n\t}\n\n\tif (func_id == BPF_FUNC_get_stackid || func_id == BPF_FUNC_get_stack)\n\t\tenv->prog->call_get_stack = true;\n\n\tif (changes_data)\n\t\tclear_all_pkt_pointers(env);\n\treturn 0;\n}\n\nstatic bool signed_add_overflows(s64 a, s64 b)\n{\n\t/* Do the add in u64, where overflow is well-defined */\n\ts64 res = (s64)((u64)a + (u64)b);\n\n\tif (b < 0)\n\t\treturn res > a;\n\treturn res < a;\n}\n\nstatic bool signed_add32_overflows(s32 a, s32 b)\n{\n\t/* Do the add in u32, where overflow is well-defined */\n\ts32 res = (s32)((u32)a + (u32)b);\n\n\tif (b < 0)\n\t\treturn res > a;\n\treturn res < a;\n}\n\nstatic bool signed_sub_overflows(s64 a, s64 b)\n{\n\t/* Do the sub in u64, where overflow is well-defined */\n\ts64 res = (s64)((u64)a - (u64)b);\n\n\tif (b < 0)\n\t\treturn res < a;\n\treturn res > a;\n}\n\nstatic bool signed_sub32_overflows(s32 a, s32 b)\n{\n\t/* Do the sub in u32, where overflow is well-defined */\n\ts32 res = (s32)((u32)a - (u32)b);\n\n\tif (b < 0)\n\t\treturn res < a;\n\treturn res > a;\n}\n\nstatic bool check_reg_sane_offset(struct bpf_verifier_env *env,\n\t\t\t\t  const struct bpf_reg_state *reg,\n\t\t\t\t  enum bpf_reg_type type)\n{\n\tbool known = tnum_is_const(reg->var_off);\n\ts64 val = reg->var_off.value;\n\ts64 smin = reg->smin_value;\n\n\tif (known && (val >= BPF_MAX_VAR_OFF || val <= -BPF_MAX_VAR_OFF)) {\n\t\tverbose(env, \"math between %s pointer and %lld is not allowed\\n\",\n\t\t\treg_type_str[type], val);\n\t\treturn false;\n\t}\n\n\tif (reg->off >= BPF_MAX_VAR_OFF || reg->off <= -BPF_MAX_VAR_OFF) {\n\t\tverbose(env, \"%s pointer offset %d is not allowed\\n\",\n\t\t\treg_type_str[type], reg->off);\n\t\treturn false;\n\t}\n\n\tif (smin == S64_MIN) {\n\t\tverbose(env, \"math between %s pointer and register with unbounded min value is not allowed\\n\",\n\t\t\treg_type_str[type]);\n\t\treturn false;\n\t}\n\n\tif (smin >= BPF_MAX_VAR_OFF || smin <= -BPF_MAX_VAR_OFF) {\n\t\tverbose(env, \"value %lld makes %s pointer be out of bounds\\n\",\n\t\t\tsmin, reg_type_str[type]);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic struct bpf_insn_aux_data *cur_aux(struct bpf_verifier_env *env)\n{\n\treturn &env->insn_aux_data[env->insn_idx];\n}\n\nstatic int retrieve_ptr_limit(const struct bpf_reg_state *ptr_reg,\n\t\t\t      u32 *ptr_limit, u8 opcode, bool off_is_neg)\n{\n\tbool mask_to_left = (opcode == BPF_ADD &&  off_is_neg) ||\n\t\t\t    (opcode == BPF_SUB && !off_is_neg);\n\tu32 off;\n\n\tswitch (ptr_reg->type) {\n\tcase PTR_TO_STACK:\n\t\t/* Indirect variable offset stack access is prohibited in\n\t\t * unprivileged mode so it's not handled here.\n\t\t */\n\t\toff = ptr_reg->off + ptr_reg->var_off.value;\n\t\tif (mask_to_left)\n\t\t\t*ptr_limit = MAX_BPF_STACK + off;\n\t\telse\n\t\t\t*ptr_limit = -off;\n\t\treturn 0;\n\tcase PTR_TO_MAP_KEY:\n\t\t/* Currently, this code is not exercised as the only use\n\t\t * is bpf_for_each_map_elem() helper which requires\n\t\t * bpf_capble. The code has been tested manually for\n\t\t * future use.\n\t\t */\n\t\tif (mask_to_left) {\n\t\t\t*ptr_limit = ptr_reg->umax_value + ptr_reg->off;\n\t\t} else {\n\t\t\toff = ptr_reg->smin_value + ptr_reg->off;\n\t\t\t*ptr_limit = ptr_reg->map_ptr->key_size - off;\n\t\t}\n\t\treturn 0;\n\tcase PTR_TO_MAP_VALUE:\n\t\tif (mask_to_left) {\n\t\t\t*ptr_limit = ptr_reg->umax_value + ptr_reg->off;\n\t\t} else {\n\t\t\toff = ptr_reg->smin_value + ptr_reg->off;\n\t\t\t*ptr_limit = ptr_reg->map_ptr->value_size - off;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic bool can_skip_alu_sanitation(const struct bpf_verifier_env *env,\n\t\t\t\t    const struct bpf_insn *insn)\n{\n\treturn env->bypass_spec_v1 || BPF_SRC(insn->code) == BPF_K;\n}\n\nstatic int update_alu_sanitation_state(struct bpf_insn_aux_data *aux,\n\t\t\t\t       u32 alu_state, u32 alu_limit)\n{\n\t/* If we arrived here from different branches with different\n\t * state or limits to sanitize, then this won't work.\n\t */\n\tif (aux->alu_state &&\n\t    (aux->alu_state != alu_state ||\n\t     aux->alu_limit != alu_limit))\n\t\treturn -EACCES;\n\n\t/* Corresponding fixup done in do_misc_fixups(). */\n\taux->alu_state = alu_state;\n\taux->alu_limit = alu_limit;\n\treturn 0;\n}\n\nstatic int sanitize_val_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn)\n{\n\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n\n\tif (can_skip_alu_sanitation(env, insn))\n\t\treturn 0;\n\n\treturn update_alu_sanitation_state(aux, BPF_ALU_NON_POINTER, 0);\n}\n\nstatic int sanitize_ptr_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn,\n\t\t\t    const struct bpf_reg_state *ptr_reg,\n\t\t\t    struct bpf_reg_state *dst_reg,\n\t\t\t    bool off_is_neg)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n\tbool ptr_is_dst_reg = ptr_reg == dst_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\tu32 alu_state, alu_limit;\n\tstruct bpf_reg_state tmp;\n\tbool ret;\n\n\tif (can_skip_alu_sanitation(env, insn))\n\t\treturn 0;\n\n\t/* We already marked aux for masking from non-speculative\n\t * paths, thus we got here in the first place. We only care\n\t * to explore bad access from here.\n\t */\n\tif (vstate->speculative)\n\t\tgoto do_sim;\n\n\talu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;\n\talu_state |= ptr_is_dst_reg ?\n\t\t     BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;\n\n\tif (retrieve_ptr_limit(ptr_reg, &alu_limit, opcode, off_is_neg))\n\t\treturn 0;\n\tif (update_alu_sanitation_state(aux, alu_state, alu_limit))\n\t\treturn -EACCES;\ndo_sim:\n\t/* Simulate and find potential out-of-bounds access under\n\t * speculative execution from truncation as a result of\n\t * masking when off was not within expected range. If off\n\t * sits in dst, then we temporarily need to move ptr there\n\t * to simulate dst (== 0) +/-= ptr. Needed, for example,\n\t * for cases where we use K-based arithmetic in one direction\n\t * and truncated reg-based in the other in order to explore\n\t * bad access.\n\t */\n\tif (!ptr_is_dst_reg) {\n\t\ttmp = *dst_reg;\n\t\t*dst_reg = *ptr_reg;\n\t}\n\tret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);\n\tif (!ptr_is_dst_reg && ret)\n\t\t*dst_reg = tmp;\n\treturn !ret ? -EFAULT : 0;\n}\n\n/* check that stack access falls within stack limits and that 'reg' doesn't\n * have a variable offset.\n *\n * Variable offset is prohibited for unprivileged mode for simplicity since it\n * requires corresponding support in Spectre masking for stack ALU.  See also\n * retrieve_ptr_limit().\n *\n *\n * 'off' includes 'reg->off'.\n */\nstatic int check_stack_access_for_ptr_arithmetic(\n\t\t\t\tstruct bpf_verifier_env *env,\n\t\t\t\tint regno,\n\t\t\t\tconst struct bpf_reg_state *reg,\n\t\t\t\tint off)\n{\n\tif (!tnum_is_const(reg->var_off)) {\n\t\tchar tn_buf[48];\n\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\tverbose(env, \"R%d variable stack access prohibited for !root, var_off=%s off=%d\\n\",\n\t\t\tregno, tn_buf, off);\n\t\treturn -EACCES;\n\t}\n\n\tif (off >= 0 || off < -MAX_BPF_STACK) {\n\t\tverbose(env, \"R%d stack pointer arithmetic goes out of range, \"\n\t\t\t\"prohibited for !root; off=%d\\n\", regno, off);\n\t\treturn -EACCES;\n\t}\n\n\treturn 0;\n}\n\n\n/* Handles arithmetic on a pointer and a scalar: computes new min/max and var_off.\n * Caller should also handle BPF_MOV case separately.\n * If we return -EACCES, caller may want to try again treating pointer as a\n * scalar.  So we only emit a diagnostic if !env->allow_ptr_leaks.\n */\nstatic int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_insn *insn,\n\t\t\t\t   const struct bpf_reg_state *ptr_reg,\n\t\t\t\t   const struct bpf_reg_state *off_reg)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tstruct bpf_reg_state *regs = state->regs, *dst_reg;\n\tbool known = tnum_is_const(off_reg->var_off);\n\ts64 smin_val = off_reg->smin_value, smax_val = off_reg->smax_value,\n\t    smin_ptr = ptr_reg->smin_value, smax_ptr = ptr_reg->smax_value;\n\tu64 umin_val = off_reg->umin_value, umax_val = off_reg->umax_value,\n\t    umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value;\n\tu32 dst = insn->dst_reg, src = insn->src_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\tint ret;\n\n\tdst_reg = &regs[dst];\n\n\tif ((known && (smin_val != smax_val || umin_val != umax_val)) ||\n\t    smin_val > smax_val || umin_val > umax_val) {\n\t\t/* Taint dst register if offset had invalid bounds derived from\n\t\t * e.g. dead branches.\n\t\t */\n\t\t__mark_reg_unknown(env, dst_reg);\n\t\treturn 0;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops on pointers produce (meaningless) scalars */\n\t\tif (opcode == BPF_SUB && env->allow_ptr_leaks) {\n\t\t\t__mark_reg_unknown(env, dst_reg);\n\t\t\treturn 0;\n\t\t}\n\n\t\tverbose(env,\n\t\t\t\"R%d 32-bit pointer arithmetic prohibited\\n\",\n\t\t\tdst);\n\t\treturn -EACCES;\n\t}\n\n\tswitch (ptr_reg->type) {\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\t\tverbose(env, \"R%d pointer arithmetic on %s prohibited, null-check it first\\n\",\n\t\t\tdst, reg_type_str[ptr_reg->type]);\n\t\treturn -EACCES;\n\tcase CONST_PTR_TO_MAP:\n\t\t/* smin_val represents the known value */\n\t\tif (known && smin_val == 0 && opcode == BPF_ADD)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase PTR_TO_PACKET_END:\n\tcase PTR_TO_SOCKET:\n\tcase PTR_TO_SOCKET_OR_NULL:\n\tcase PTR_TO_SOCK_COMMON:\n\tcase PTR_TO_SOCK_COMMON_OR_NULL:\n\tcase PTR_TO_TCP_SOCK:\n\tcase PTR_TO_TCP_SOCK_OR_NULL:\n\tcase PTR_TO_XDP_SOCK:\n\t\tverbose(env, \"R%d pointer arithmetic on %s prohibited\\n\",\n\t\t\tdst, reg_type_str[ptr_reg->type]);\n\t\treturn -EACCES;\n\tcase PTR_TO_MAP_KEY:\n\tcase PTR_TO_MAP_VALUE:\n\t\tif (!env->allow_ptr_leaks && !known && (smin_val < 0) != (smax_val < 0)) {\n\t\t\tverbose(env, \"R%d has unknown scalar with mixed signed bounds, pointer arithmetic with it prohibited for !root\\n\",\n\t\t\t\toff_reg == dst_reg ? dst : src);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* In case of 'scalar += pointer', dst_reg inherits pointer type and id.\n\t * The id may be overwritten later if we create a new variable offset.\n\t */\n\tdst_reg->type = ptr_reg->type;\n\tdst_reg->id = ptr_reg->id;\n\n\tif (!check_reg_sane_offset(env, off_reg, ptr_reg->type) ||\n\t    !check_reg_sane_offset(env, ptr_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\n\t/* pointer types do not carry 32-bit bounds at the moment. */\n\t__mark_reg32_unbounded(dst_reg);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tret = sanitize_ptr_alu(env, insn, ptr_reg, dst_reg, smin_val < 0);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"R%d tried to add from different maps or paths\\n\", dst);\n\t\t\treturn ret;\n\t\t}\n\t\t/* We can take a fixed offset as long as it doesn't overflow\n\t\t * the s32 'off' field\n\t\t */\n\t\tif (known && (ptr_reg->off + smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off + smin_val))) {\n\t\t\t/* pointer += K.  Accumulate it into fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->off = ptr_reg->off + smin_val;\n\t\t\tdst_reg->raw = ptr_reg->raw;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  Note that off_reg->off\n\t\t * == 0, since it's a scalar.\n\t\t * dst_reg gets the pointer type and since some positive\n\t\t * integer value was added to the pointer, give it a new 'id'\n\t\t * if it's a PTR_TO_PACKET.\n\t\t * this creates a new 'base' pointer, off_reg (variable) gets\n\t\t * added into the variable offset, and we copy the fixed offset\n\t\t * from ptr_reg.\n\t\t */\n\t\tif (signed_add_overflows(smin_ptr, smin_val) ||\n\t\t    signed_add_overflows(smax_ptr, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr + smin_val;\n\t\t\tdst_reg->smax_value = smax_ptr + smax_val;\n\t\t}\n\t\tif (umin_ptr + umin_val < umin_ptr ||\n\t\t    umax_ptr + umax_val < umax_ptr) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value = umin_ptr + umin_val;\n\t\t\tdst_reg->umax_value = umax_ptr + umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tdst_reg->raw = ptr_reg->raw;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tmemset(&dst_reg->raw, 0, sizeof(dst_reg->raw));\n\t\t}\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tret = sanitize_ptr_alu(env, insn, ptr_reg, dst_reg, smin_val < 0);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"R%d tried to sub from different maps or paths\\n\", dst);\n\t\t\treturn ret;\n\t\t}\n\t\tif (dst_reg == off_reg) {\n\t\t\t/* scalar -= pointer.  Creates an unknown scalar */\n\t\t\tverbose(env, \"R%d tried to subtract pointer from scalar\\n\",\n\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* We don't allow subtraction from FP, because (according to\n\t\t * test_verifier.c test \"invalid fp arithmetic\", JITs might not\n\t\t * be able to deal with it.\n\t\t */\n\t\tif (ptr_reg->type == PTR_TO_STACK) {\n\t\t\tverbose(env, \"R%d subtraction from stack pointer prohibited\\n\",\n\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (known && (ptr_reg->off - smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off - smin_val))) {\n\t\t\t/* pointer -= K.  Subtract it from fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->id = ptr_reg->id;\n\t\t\tdst_reg->off = ptr_reg->off - smin_val;\n\t\t\tdst_reg->raw = ptr_reg->raw;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  If the subtrahend is known\n\t\t * nonnegative, then any reg->range we had before is still good.\n\t\t */\n\t\tif (signed_sub_overflows(smin_ptr, smax_val) ||\n\t\t    signed_sub_overflows(smax_ptr, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr - smax_val;\n\t\t\tdst_reg->smax_value = smax_ptr - smin_val;\n\t\t}\n\t\tif (umin_ptr < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value = umin_ptr - umax_val;\n\t\t\tdst_reg->umax_value = umax_ptr - umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tdst_reg->raw = ptr_reg->raw;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tif (smin_val < 0)\n\t\t\t\tmemset(&dst_reg->raw, 0, sizeof(dst_reg->raw));\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\tcase BPF_OR:\n\tcase BPF_XOR:\n\t\t/* bitwise ops on pointers are troublesome, prohibit. */\n\t\tverbose(env, \"R%d bitwise operator %s on pointer prohibited\\n\",\n\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\tdefault:\n\t\t/* other operators (e.g. MUL,LSH) produce non-pointer results */\n\t\tverbose(env, \"R%d pointer arithmetic with %s operator prohibited\\n\",\n\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\t}\n\n\tif (!check_reg_sane_offset(env, dst_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\n\t__update_reg_bounds(dst_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\n\t/* For unprivileged we require that resulting offset must be in bounds\n\t * in order to be able to sanitize access later on.\n\t */\n\tif (!env->bypass_spec_v1) {\n\t\tif (dst_reg->type == PTR_TO_MAP_VALUE &&\n\t\t    check_map_access(env, dst, dst_reg->off, 1, false)) {\n\t\t\tverbose(env, \"R%d pointer arithmetic of map value goes out of range, \"\n\t\t\t\t\"prohibited for !root\\n\", dst);\n\t\t\treturn -EACCES;\n\t\t} else if (dst_reg->type == PTR_TO_STACK &&\n\t\t\t   check_stack_access_for_ptr_arithmetic(\n\t\t\t\t   env, dst, dst_reg, dst_reg->off +\n\t\t\t\t   dst_reg->var_off.value)) {\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void scalar32_min_max_add(struct bpf_reg_state *dst_reg,\n\t\t\t\t struct bpf_reg_state *src_reg)\n{\n\ts32 smin_val = src_reg->s32_min_value;\n\ts32 smax_val = src_reg->s32_max_value;\n\tu32 umin_val = src_reg->u32_min_value;\n\tu32 umax_val = src_reg->u32_max_value;\n\n\tif (signed_add32_overflows(dst_reg->s32_min_value, smin_val) ||\n\t    signed_add32_overflows(dst_reg->s32_max_value, smax_val)) {\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\tdst_reg->s32_min_value += smin_val;\n\t\tdst_reg->s32_max_value += smax_val;\n\t}\n\tif (dst_reg->u32_min_value + umin_val < umin_val ||\n\t    dst_reg->u32_max_value + umax_val < umax_val) {\n\t\tdst_reg->u32_min_value = 0;\n\t\tdst_reg->u32_max_value = U32_MAX;\n\t} else {\n\t\tdst_reg->u32_min_value += umin_val;\n\t\tdst_reg->u32_max_value += umax_val;\n\t}\n}\n\nstatic void scalar_min_max_add(struct bpf_reg_state *dst_reg,\n\t\t\t       struct bpf_reg_state *src_reg)\n{\n\ts64 smin_val = src_reg->smin_value;\n\ts64 smax_val = src_reg->smax_value;\n\tu64 umin_val = src_reg->umin_value;\n\tu64 umax_val = src_reg->umax_value;\n\n\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t} else {\n\t\tdst_reg->smin_value += smin_val;\n\t\tdst_reg->smax_value += smax_val;\n\t}\n\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\tdst_reg->umin_value = 0;\n\t\tdst_reg->umax_value = U64_MAX;\n\t} else {\n\t\tdst_reg->umin_value += umin_val;\n\t\tdst_reg->umax_value += umax_val;\n\t}\n}\n\nstatic void scalar32_min_max_sub(struct bpf_reg_state *dst_reg,\n\t\t\t\t struct bpf_reg_state *src_reg)\n{\n\ts32 smin_val = src_reg->s32_min_value;\n\ts32 smax_val = src_reg->s32_max_value;\n\tu32 umin_val = src_reg->u32_min_value;\n\tu32 umax_val = src_reg->u32_max_value;\n\n\tif (signed_sub32_overflows(dst_reg->s32_min_value, smax_val) ||\n\t    signed_sub32_overflows(dst_reg->s32_max_value, smin_val)) {\n\t\t/* Overflow possible, we know nothing */\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\tdst_reg->s32_min_value -= smax_val;\n\t\tdst_reg->s32_max_value -= smin_val;\n\t}\n\tif (dst_reg->u32_min_value < umax_val) {\n\t\t/* Overflow possible, we know nothing */\n\t\tdst_reg->u32_min_value = 0;\n\t\tdst_reg->u32_max_value = U32_MAX;\n\t} else {\n\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\tdst_reg->u32_min_value -= umax_val;\n\t\tdst_reg->u32_max_value -= umin_val;\n\t}\n}\n\nstatic void scalar_min_max_sub(struct bpf_reg_state *dst_reg,\n\t\t\t       struct bpf_reg_state *src_reg)\n{\n\ts64 smin_val = src_reg->smin_value;\n\ts64 smax_val = src_reg->smax_value;\n\tu64 umin_val = src_reg->umin_value;\n\tu64 umax_val = src_reg->umax_value;\n\n\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t/* Overflow possible, we know nothing */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t} else {\n\t\tdst_reg->smin_value -= smax_val;\n\t\tdst_reg->smax_value -= smin_val;\n\t}\n\tif (dst_reg->umin_value < umax_val) {\n\t\t/* Overflow possible, we know nothing */\n\t\tdst_reg->umin_value = 0;\n\t\tdst_reg->umax_value = U64_MAX;\n\t} else {\n\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\tdst_reg->umin_value -= umax_val;\n\t\tdst_reg->umax_value -= umin_val;\n\t}\n}\n\nstatic void scalar32_min_max_mul(struct bpf_reg_state *dst_reg,\n\t\t\t\t struct bpf_reg_state *src_reg)\n{\n\ts32 smin_val = src_reg->s32_min_value;\n\tu32 umin_val = src_reg->u32_min_value;\n\tu32 umax_val = src_reg->u32_max_value;\n\n\tif (smin_val < 0 || dst_reg->s32_min_value < 0) {\n\t\t/* Ain't nobody got time to multiply that sign */\n\t\t__mark_reg32_unbounded(dst_reg);\n\t\treturn;\n\t}\n\t/* Both values are positive, so we can work with unsigned and\n\t * copy the result to signed (unless it exceeds S32_MAX).\n\t */\n\tif (umax_val > U16_MAX || dst_reg->u32_max_value > U16_MAX) {\n\t\t/* Potential overflow, we know nothing */\n\t\t__mark_reg32_unbounded(dst_reg);\n\t\treturn;\n\t}\n\tdst_reg->u32_min_value *= umin_val;\n\tdst_reg->u32_max_value *= umax_val;\n\tif (dst_reg->u32_max_value > S32_MAX) {\n\t\t/* Overflow possible, we know nothing */\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\tdst_reg->s32_min_value = dst_reg->u32_min_value;\n\t\tdst_reg->s32_max_value = dst_reg->u32_max_value;\n\t}\n}\n\nstatic void scalar_min_max_mul(struct bpf_reg_state *dst_reg,\n\t\t\t       struct bpf_reg_state *src_reg)\n{\n\ts64 smin_val = src_reg->smin_value;\n\tu64 umin_val = src_reg->umin_value;\n\tu64 umax_val = src_reg->umax_value;\n\n\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t/* Ain't nobody got time to multiply that sign */\n\t\t__mark_reg64_unbounded(dst_reg);\n\t\treturn;\n\t}\n\t/* Both values are positive, so we can work with unsigned and\n\t * copy the result to signed (unless it exceeds S64_MAX).\n\t */\n\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t/* Potential overflow, we know nothing */\n\t\t__mark_reg64_unbounded(dst_reg);\n\t\treturn;\n\t}\n\tdst_reg->umin_value *= umin_val;\n\tdst_reg->umax_value *= umax_val;\n\tif (dst_reg->umax_value > S64_MAX) {\n\t\t/* Overflow possible, we know nothing */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t} else {\n\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t}\n}\n\nstatic void scalar32_min_max_and(struct bpf_reg_state *dst_reg,\n\t\t\t\t struct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->s32_min_value;\n\tu32 umax_val = src_reg->u32_max_value;\n\n\t/* Assuming scalar64_min_max_and will be called so its safe\n\t * to skip updating register for known 32-bit case.\n\t */\n\tif (src_known && dst_known)\n\t\treturn;\n\n\t/* We get our minimum from the var_off, since that's inherently\n\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t */\n\tdst_reg->u32_min_value = var32_off.value;\n\tdst_reg->u32_max_value = min(dst_reg->u32_max_value, umax_val);\n\tif (dst_reg->s32_min_value < 0 || smin_val < 0) {\n\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t * ain't nobody got time for that.\n\t\t */\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\t/* ANDing two positives gives a positive, so safe to\n\t\t * cast result into s64.\n\t\t */\n\t\tdst_reg->s32_min_value = dst_reg->u32_min_value;\n\t\tdst_reg->s32_max_value = dst_reg->u32_max_value;\n\t}\n\n}\n\nstatic void scalar_min_max_and(struct bpf_reg_state *dst_reg,\n\t\t\t       struct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_is_const(src_reg->var_off);\n\tbool dst_known = tnum_is_const(dst_reg->var_off);\n\ts64 smin_val = src_reg->smin_value;\n\tu64 umax_val = src_reg->umax_value;\n\n\tif (src_known && dst_known) {\n\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value);\n\t\treturn;\n\t}\n\n\t/* We get our minimum from the var_off, since that's inherently\n\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t */\n\tdst_reg->umin_value = dst_reg->var_off.value;\n\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t * ain't nobody got time for that.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t} else {\n\t\t/* ANDing two positives gives a positive, so safe to\n\t\t * cast result into s64.\n\t\t */\n\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t}\n\t/* We may learn something more from the var_off */\n\t__update_reg_bounds(dst_reg);\n}\n\nstatic void scalar32_min_max_or(struct bpf_reg_state *dst_reg,\n\t\t\t\tstruct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->s32_min_value;\n\tu32 umin_val = src_reg->u32_min_value;\n\n\t/* Assuming scalar64_min_max_or will be called so it is safe\n\t * to skip updating register for known case.\n\t */\n\tif (src_known && dst_known)\n\t\treturn;\n\n\t/* We get our maximum from the var_off, and our minimum is the\n\t * maximum of the operands' minima\n\t */\n\tdst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);\n\tdst_reg->u32_max_value = var32_off.value | var32_off.mask;\n\tif (dst_reg->s32_min_value < 0 || smin_val < 0) {\n\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t * ain't nobody got time for that.\n\t\t */\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\t/* ORing two positives gives a positive, so safe to\n\t\t * cast result into s64.\n\t\t */\n\t\tdst_reg->s32_min_value = dst_reg->u32_min_value;\n\t\tdst_reg->s32_max_value = dst_reg->u32_max_value;\n\t}\n}\n\nstatic void scalar_min_max_or(struct bpf_reg_state *dst_reg,\n\t\t\t      struct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_is_const(src_reg->var_off);\n\tbool dst_known = tnum_is_const(dst_reg->var_off);\n\ts64 smin_val = src_reg->smin_value;\n\tu64 umin_val = src_reg->umin_value;\n\n\tif (src_known && dst_known) {\n\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value);\n\t\treturn;\n\t}\n\n\t/* We get our maximum from the var_off, and our minimum is the\n\t * maximum of the operands' minima\n\t */\n\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\tdst_reg->umax_value = dst_reg->var_off.value | dst_reg->var_off.mask;\n\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t * ain't nobody got time for that.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t} else {\n\t\t/* ORing two positives gives a positive, so safe to\n\t\t * cast result into s64.\n\t\t */\n\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t}\n\t/* We may learn something more from the var_off */\n\t__update_reg_bounds(dst_reg);\n}\n\nstatic void scalar32_min_max_xor(struct bpf_reg_state *dst_reg,\n\t\t\t\t struct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->s32_min_value;\n\n\t/* Assuming scalar64_min_max_xor will be called so it is safe\n\t * to skip updating register for known case.\n\t */\n\tif (src_known && dst_known)\n\t\treturn;\n\n\t/* We get both minimum and maximum from the var32_off. */\n\tdst_reg->u32_min_value = var32_off.value;\n\tdst_reg->u32_max_value = var32_off.value | var32_off.mask;\n\n\tif (dst_reg->s32_min_value >= 0 && smin_val >= 0) {\n\t\t/* XORing two positive sign numbers gives a positive,\n\t\t * so safe to cast u32 result into s32.\n\t\t */\n\t\tdst_reg->s32_min_value = dst_reg->u32_min_value;\n\t\tdst_reg->s32_max_value = dst_reg->u32_max_value;\n\t} else {\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t}\n}\n\nstatic void scalar_min_max_xor(struct bpf_reg_state *dst_reg,\n\t\t\t       struct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_is_const(src_reg->var_off);\n\tbool dst_known = tnum_is_const(dst_reg->var_off);\n\ts64 smin_val = src_reg->smin_value;\n\n\tif (src_known && dst_known) {\n\t\t/* dst_reg->var_off.value has been updated earlier */\n\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value);\n\t\treturn;\n\t}\n\n\t/* We get both minimum and maximum from the var_off. */\n\tdst_reg->umin_value = dst_reg->var_off.value;\n\tdst_reg->umax_value = dst_reg->var_off.value | dst_reg->var_off.mask;\n\n\tif (dst_reg->smin_value >= 0 && smin_val >= 0) {\n\t\t/* XORing two positive sign numbers gives a positive,\n\t\t * so safe to cast u64 result into s64.\n\t\t */\n\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t} else {\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t}\n\n\t__update_reg_bounds(dst_reg);\n}\n\nstatic void __scalar32_min_max_lsh(struct bpf_reg_state *dst_reg,\n\t\t\t\t   u64 umin_val, u64 umax_val)\n{\n\t/* We lose all sign bit information (except what we can pick\n\t * up from var_off)\n\t */\n\tdst_reg->s32_min_value = S32_MIN;\n\tdst_reg->s32_max_value = S32_MAX;\n\t/* If we might shift our top bit out, then we know nothing */\n\tif (umax_val > 31 || dst_reg->u32_max_value > 1ULL << (31 - umax_val)) {\n\t\tdst_reg->u32_min_value = 0;\n\t\tdst_reg->u32_max_value = U32_MAX;\n\t} else {\n\t\tdst_reg->u32_min_value <<= umin_val;\n\t\tdst_reg->u32_max_value <<= umax_val;\n\t}\n}\n\nstatic void scalar32_min_max_lsh(struct bpf_reg_state *dst_reg,\n\t\t\t\t struct bpf_reg_state *src_reg)\n{\n\tu32 umax_val = src_reg->u32_max_value;\n\tu32 umin_val = src_reg->u32_min_value;\n\t/* u32 alu operation will zext upper bits */\n\tstruct tnum subreg = tnum_subreg(dst_reg->var_off);\n\n\t__scalar32_min_max_lsh(dst_reg, umin_val, umax_val);\n\tdst_reg->var_off = tnum_subreg(tnum_lshift(subreg, umin_val));\n\t/* Not required but being careful mark reg64 bounds as unknown so\n\t * that we are forced to pick them up from tnum and zext later and\n\t * if some path skips this step we are still safe.\n\t */\n\t__mark_reg64_unbounded(dst_reg);\n\t__update_reg32_bounds(dst_reg);\n}\n\nstatic void __scalar64_min_max_lsh(struct bpf_reg_state *dst_reg,\n\t\t\t\t   u64 umin_val, u64 umax_val)\n{\n\t/* Special case <<32 because it is a common compiler pattern to sign\n\t * extend subreg by doing <<32 s>>32. In this case if 32bit bounds are\n\t * positive we know this shift will also be positive so we can track\n\t * bounds correctly. Otherwise we lose all sign bit information except\n\t * what we can pick up from var_off. Perhaps we can generalize this\n\t * later to shifts of any length.\n\t */\n\tif (umin_val == 32 && umax_val == 32 && dst_reg->s32_max_value >= 0)\n\t\tdst_reg->smax_value = (s64)dst_reg->s32_max_value << 32;\n\telse\n\t\tdst_reg->smax_value = S64_MAX;\n\n\tif (umin_val == 32 && umax_val == 32 && dst_reg->s32_min_value >= 0)\n\t\tdst_reg->smin_value = (s64)dst_reg->s32_min_value << 32;\n\telse\n\t\tdst_reg->smin_value = S64_MIN;\n\n\t/* If we might shift our top bit out, then we know nothing */\n\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\tdst_reg->umin_value = 0;\n\t\tdst_reg->umax_value = U64_MAX;\n\t} else {\n\t\tdst_reg->umin_value <<= umin_val;\n\t\tdst_reg->umax_value <<= umax_val;\n\t}\n}\n\nstatic void scalar_min_max_lsh(struct bpf_reg_state *dst_reg,\n\t\t\t       struct bpf_reg_state *src_reg)\n{\n\tu64 umax_val = src_reg->umax_value;\n\tu64 umin_val = src_reg->umin_value;\n\n\t/* scalar64 calc uses 32bit unshifted bounds so must be called first */\n\t__scalar64_min_max_lsh(dst_reg, umin_val, umax_val);\n\t__scalar32_min_max_lsh(dst_reg, umin_val, umax_val);\n\n\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t/* We may learn something more from the var_off */\n\t__update_reg_bounds(dst_reg);\n}\n\nstatic void scalar32_min_max_rsh(struct bpf_reg_state *dst_reg,\n\t\t\t\t struct bpf_reg_state *src_reg)\n{\n\tstruct tnum subreg = tnum_subreg(dst_reg->var_off);\n\tu32 umax_val = src_reg->u32_max_value;\n\tu32 umin_val = src_reg->u32_min_value;\n\n\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t * be negative, then either:\n\t * 1) src_reg might be zero, so the sign bit of the result is\n\t *    unknown, so we lose our signed bounds\n\t * 2) it's known negative, thus the unsigned bounds capture the\n\t *    signed bounds\n\t * 3) the signed bounds cross zero, so they tell us nothing\n\t *    about the result\n\t * If the value in dst_reg is known nonnegative, then again the\n\t * unsigned bounds capture the signed bounds.\n\t * Thus, in all cases it suffices to blow away our signed bounds\n\t * and rely on inferring new ones from the unsigned bounds and\n\t * var_off of the result.\n\t */\n\tdst_reg->s32_min_value = S32_MIN;\n\tdst_reg->s32_max_value = S32_MAX;\n\n\tdst_reg->var_off = tnum_rshift(subreg, umin_val);\n\tdst_reg->u32_min_value >>= umax_val;\n\tdst_reg->u32_max_value >>= umin_val;\n\n\t__mark_reg64_unbounded(dst_reg);\n\t__update_reg32_bounds(dst_reg);\n}\n\nstatic void scalar_min_max_rsh(struct bpf_reg_state *dst_reg,\n\t\t\t       struct bpf_reg_state *src_reg)\n{\n\tu64 umax_val = src_reg->umax_value;\n\tu64 umin_val = src_reg->umin_value;\n\n\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t * be negative, then either:\n\t * 1) src_reg might be zero, so the sign bit of the result is\n\t *    unknown, so we lose our signed bounds\n\t * 2) it's known negative, thus the unsigned bounds capture the\n\t *    signed bounds\n\t * 3) the signed bounds cross zero, so they tell us nothing\n\t *    about the result\n\t * If the value in dst_reg is known nonnegative, then again the\n\t * unsigned bounds capture the signed bounds.\n\t * Thus, in all cases it suffices to blow away our signed bounds\n\t * and rely on inferring new ones from the unsigned bounds and\n\t * var_off of the result.\n\t */\n\tdst_reg->smin_value = S64_MIN;\n\tdst_reg->smax_value = S64_MAX;\n\tdst_reg->var_off = tnum_rshift(dst_reg->var_off, umin_val);\n\tdst_reg->umin_value >>= umax_val;\n\tdst_reg->umax_value >>= umin_val;\n\n\t/* Its not easy to operate on alu32 bounds here because it depends\n\t * on bits being shifted in. Take easy way out and mark unbounded\n\t * so we can recalculate later from tnum.\n\t */\n\t__mark_reg32_unbounded(dst_reg);\n\t__update_reg_bounds(dst_reg);\n}\n\nstatic void scalar32_min_max_arsh(struct bpf_reg_state *dst_reg,\n\t\t\t\t  struct bpf_reg_state *src_reg)\n{\n\tu64 umin_val = src_reg->u32_min_value;\n\n\t/* Upon reaching here, src_known is true and\n\t * umax_val is equal to umin_val.\n\t */\n\tdst_reg->s32_min_value = (u32)(((s32)dst_reg->s32_min_value) >> umin_val);\n\tdst_reg->s32_max_value = (u32)(((s32)dst_reg->s32_max_value) >> umin_val);\n\n\tdst_reg->var_off = tnum_arshift(tnum_subreg(dst_reg->var_off), umin_val, 32);\n\n\t/* blow away the dst_reg umin_value/umax_value and rely on\n\t * dst_reg var_off to refine the result.\n\t */\n\tdst_reg->u32_min_value = 0;\n\tdst_reg->u32_max_value = U32_MAX;\n\n\t__mark_reg64_unbounded(dst_reg);\n\t__update_reg32_bounds(dst_reg);\n}\n\nstatic void scalar_min_max_arsh(struct bpf_reg_state *dst_reg,\n\t\t\t\tstruct bpf_reg_state *src_reg)\n{\n\tu64 umin_val = src_reg->umin_value;\n\n\t/* Upon reaching here, src_known is true and umax_val is equal\n\t * to umin_val.\n\t */\n\tdst_reg->smin_value >>= umin_val;\n\tdst_reg->smax_value >>= umin_val;\n\n\tdst_reg->var_off = tnum_arshift(dst_reg->var_off, umin_val, 64);\n\n\t/* blow away the dst_reg umin_value/umax_value and rely on\n\t * dst_reg var_off to refine the result.\n\t */\n\tdst_reg->umin_value = 0;\n\tdst_reg->umax_value = U64_MAX;\n\n\t/* Its not easy to operate on alu32 bounds here because it depends\n\t * on bits being shifted in from upper 32-bits. Take easy way out\n\t * and mark unbounded so we can recalculate later from tnum.\n\t */\n\t__mark_reg32_unbounded(dst_reg);\n\t__update_reg_bounds(dst_reg);\n}\n\n/* WARNING: This function does calculations on 64-bit values, but the actual\n * execution may occur on 32-bit values. Therefore, things like bitshifts\n * need extra checks in the 32-bit case.\n */\nstatic int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\ts32 s32_min_val, s32_max_val;\n\tu32 u32_min_val, u32_max_val;\n\tu64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;\n\tu32 dst = insn->dst_reg;\n\tint ret;\n\tbool alu32 = (BPF_CLASS(insn->code) != BPF_ALU64);\n\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\n\ts32_min_val = src_reg.s32_min_value;\n\ts32_max_val = src_reg.s32_max_value;\n\tu32_min_val = src_reg.u32_min_value;\n\tu32_max_val = src_reg.u32_max_value;\n\n\tif (alu32) {\n\t\tsrc_known = tnum_subreg_is_const(src_reg.var_off);\n\t\tif ((src_known &&\n\t\t     (s32_min_val != s32_max_val || u32_min_val != u32_max_val)) ||\n\t\t    s32_min_val > s32_max_val || u32_min_val > u32_max_val) {\n\t\t\t/* Taint dst register if offset had invalid bounds\n\t\t\t * derived from e.g. dead branches.\n\t\t\t */\n\t\t\t__mark_reg_unknown(env, dst_reg);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tsrc_known = tnum_is_const(src_reg.var_off);\n\t\tif ((src_known &&\n\t\t     (smin_val != smax_val || umin_val != umax_val)) ||\n\t\t    smin_val > smax_val || umin_val > umax_val) {\n\t\t\t/* Taint dst register if offset had invalid bounds\n\t\t\t * derived from e.g. dead branches.\n\t\t\t */\n\t\t\t__mark_reg_unknown(env, dst_reg);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!src_known &&\n\t    opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND) {\n\t\t__mark_reg_unknown(env, dst_reg);\n\t\treturn 0;\n\t}\n\n\t/* Calculate sign/unsigned bounds and tnum for alu32 and alu64 bit ops.\n\t * There are two classes of instructions: The first class we track both\n\t * alu32 and alu64 sign/unsigned bounds independently this provides the\n\t * greatest amount of precision when alu operations are mixed with jmp32\n\t * operations. These operations are BPF_ADD, BPF_SUB, BPF_MUL, BPF_ADD,\n\t * and BPF_OR. This is possible because these ops have fairly easy to\n\t * understand and calculate behavior in both 32-bit and 64-bit alu ops.\n\t * See alu32 verifier tests for examples. The second class of\n\t * operations, BPF_LSH, BPF_RSH, and BPF_ARSH, however are not so easy\n\t * with regards to tracking sign/unsigned bounds because the bits may\n\t * cross subreg boundaries in the alu64 case. When this happens we mark\n\t * the reg unbounded in the subreg bound space and use the resulting\n\t * tnum to calculate an approximation of the sign/unsigned bounds.\n\t */\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tret = sanitize_val_alu(env, insn);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"R%d tried to add from different pointers or scalars\\n\", dst);\n\t\t\treturn ret;\n\t\t}\n\t\tscalar32_min_max_add(dst_reg, &src_reg);\n\t\tscalar_min_max_add(dst_reg, &src_reg);\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tret = sanitize_val_alu(env, insn);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"R%d tried to sub from different pointers or scalars\\n\", dst);\n\t\t\treturn ret;\n\t\t}\n\t\tscalar32_min_max_sub(dst_reg, &src_reg);\n\t\tscalar_min_max_sub(dst_reg, &src_reg);\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tscalar32_min_max_mul(dst_reg, &src_reg);\n\t\tscalar_min_max_mul(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_AND:\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tscalar32_min_max_and(dst_reg, &src_reg);\n\t\tscalar_min_max_and(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tscalar32_min_max_or(dst_reg, &src_reg);\n\t\tscalar_min_max_or(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_XOR:\n\t\tdst_reg->var_off = tnum_xor(dst_reg->var_off, src_reg.var_off);\n\t\tscalar32_min_max_xor(dst_reg, &src_reg);\n\t\tscalar_min_max_xor(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tif (alu32)\n\t\t\tscalar32_min_max_lsh(dst_reg, &src_reg);\n\t\telse\n\t\t\tscalar_min_max_lsh(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tif (alu32)\n\t\t\tscalar32_min_max_rsh(dst_reg, &src_reg);\n\t\telse\n\t\t\tscalar_min_max_rsh(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_ARSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tif (alu32)\n\t\t\tscalar32_min_max_arsh(dst_reg, &src_reg);\n\t\telse\n\t\t\tscalar_min_max_arsh(dst_reg, &src_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\t/* ALU32 ops are zero extended into 64bit register */\n\tif (alu32)\n\t\tzext_32_to_64(dst_reg);\n\n\t__update_reg_bounds(dst_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}\n\n/* Handles ALU ops other than BPF_END, BPF_NEG and BPF_MOV: computes new min/max\n * and var_off.\n */\nstatic int adjust_reg_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_insn *insn)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tstruct bpf_reg_state *regs = state->regs, *dst_reg, *src_reg;\n\tstruct bpf_reg_state *ptr_reg = NULL, off_reg = {0};\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tdst_reg = &regs[insn->dst_reg];\n\tsrc_reg = NULL;\n\tif (dst_reg->type != SCALAR_VALUE)\n\t\tptr_reg = dst_reg;\n\telse\n\t\t/* Make sure ID is cleared otherwise dst_reg min/max could be\n\t\t * incorrectly propagated into other registers by find_equal_scalars()\n\t\t */\n\t\tdst_reg->id = 0;\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tsrc_reg = &regs[insn->src_reg];\n\t\tif (src_reg->type != SCALAR_VALUE) {\n\t\t\tif (dst_reg->type != SCALAR_VALUE) {\n\t\t\t\t/* Combining two pointers by any ALU op yields\n\t\t\t\t * an arbitrary scalar. Disallow all math except\n\t\t\t\t * pointer subtraction\n\t\t\t\t */\n\t\t\t\tif (opcode == BPF_SUB && env->allow_ptr_leaks) {\n\t\t\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tverbose(env, \"R%d pointer %s pointer prohibited\\n\",\n\t\t\t\t\tinsn->dst_reg,\n\t\t\t\t\tbpf_alu_string[opcode >> 4]);\n\t\t\t\treturn -EACCES;\n\t\t\t} else {\n\t\t\t\t/* scalar += pointer\n\t\t\t\t * This is legal, but we have to reverse our\n\t\t\t\t * src/dest handling in computing the range\n\t\t\t\t */\n\t\t\t\terr = mark_chain_precision(env, insn->dst_reg);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\treturn adjust_ptr_min_max_vals(env, insn,\n\t\t\t\t\t\t\t       src_reg, dst_reg);\n\t\t\t}\n\t\t} else if (ptr_reg) {\n\t\t\t/* pointer += scalar */\n\t\t\terr = mark_chain_precision(env, insn->src_reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\treturn adjust_ptr_min_max_vals(env, insn,\n\t\t\t\t\t\t       dst_reg, src_reg);\n\t\t}\n\t} else {\n\t\t/* Pretend the src is a reg with a known value, since we only\n\t\t * need to be able to read from this state.\n\t\t */\n\t\toff_reg.type = SCALAR_VALUE;\n\t\t__mark_reg_known(&off_reg, insn->imm);\n\t\tsrc_reg = &off_reg;\n\t\tif (ptr_reg) /* pointer += K */\n\t\t\treturn adjust_ptr_min_max_vals(env, insn,\n\t\t\t\t\t\t       ptr_reg, src_reg);\n\t}\n\n\t/* Got here implies adding two SCALAR_VALUEs */\n\tif (WARN_ON_ONCE(ptr_reg)) {\n\t\tprint_verifier_state(env, state);\n\t\tverbose(env, \"verifier internal error: unexpected ptr_reg\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (WARN_ON(!src_reg)) {\n\t\tprint_verifier_state(env, state);\n\t\tverbose(env, \"verifier internal error: no src_reg\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn adjust_scalar_min_max_vals(env, insn, dst_reg, *src_reg);\n}\n\n/* check validity of 32-bit and 64-bit arithmetic operations */\nstatic int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode == BPF_END || opcode == BPF_NEG) {\n\t\tif (opcode == BPF_NEG) {\n\t\t\tif (BPF_SRC(insn->code) != 0 ||\n\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t    insn->off != 0 || insn->imm != 0) {\n\t\t\t\tverbose(env, \"BPF_NEG uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0 ||\n\t\t\t    (insn->imm != 16 && insn->imm != 32 && insn->imm != 64) ||\n\t\t\t    BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\tverbose(env, \"BPF_END uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(env, \"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t} else if (opcode == BPF_MOV) {\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand, mark as required later */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tstruct bpf_reg_state *src_reg = regs + insn->src_reg;\n\t\t\tstruct bpf_reg_state *dst_reg = regs + insn->dst_reg;\n\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t/* case: R1 = R2\n\t\t\t\t * copy register state to dest reg\n\t\t\t\t */\n\t\t\t\tif (src_reg->type == SCALAR_VALUE && !src_reg->id)\n\t\t\t\t\t/* Assign src and dst registers the same ID\n\t\t\t\t\t * that will be used by find_equal_scalars()\n\t\t\t\t\t * to propagate min/max range.\n\t\t\t\t\t */\n\t\t\t\t\tsrc_reg->id = ++env->id_gen;\n\t\t\t\t*dst_reg = *src_reg;\n\t\t\t\tdst_reg->live |= REG_LIVE_WRITTEN;\n\t\t\t\tdst_reg->subreg_def = DEF_NOT_SUBREG;\n\t\t\t} else {\n\t\t\t\t/* R1 = (u32) R2 */\n\t\t\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\t\t\tverbose(env,\n\t\t\t\t\t\t\"R%d partial copy of pointer\\n\",\n\t\t\t\t\t\tinsn->src_reg);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t} else if (src_reg->type == SCALAR_VALUE) {\n\t\t\t\t\t*dst_reg = *src_reg;\n\t\t\t\t\t/* Make sure ID is cleared otherwise\n\t\t\t\t\t * dst_reg min/max could be incorrectly\n\t\t\t\t\t * propagated into src_reg by find_equal_scalars()\n\t\t\t\t\t */\n\t\t\t\t\tdst_reg->id = 0;\n\t\t\t\t\tdst_reg->live |= REG_LIVE_WRITTEN;\n\t\t\t\t\tdst_reg->subreg_def = env->insn_idx + 1;\n\t\t\t\t} else {\n\t\t\t\t\tmark_reg_unknown(env, regs,\n\t\t\t\t\t\t\t insn->dst_reg);\n\t\t\t\t}\n\t\t\t\tzext_32_to_64(dst_reg);\n\t\t\t}\n\t\t} else {\n\t\t\t/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t */\n\t\t\t/* clear any state __mark_reg_known doesn't set */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tregs[insn->dst_reg].type = SCALAR_VALUE;\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t insn->imm);\n\t\t\t} else {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t (u32)insn->imm);\n\t\t\t}\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(env, \"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\n\t} else {\t/* all other ALU ops: and, sub, xor, add, ... */\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src2 operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((opcode == BPF_MOD || opcode == BPF_DIV) &&\n\t\t    BPF_SRC(insn->code) == BPF_K && insn->imm == 0) {\n\t\t\tverbose(env, \"div by zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((opcode == BPF_LSH || opcode == BPF_RSH ||\n\t\t     opcode == BPF_ARSH) && BPF_SRC(insn->code) == BPF_K) {\n\t\t\tint size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32;\n\n\t\t\tif (insn->imm < 0 || insn->imm >= size) {\n\t\t\t\tverbose(env, \"invalid shift %d\\n\", insn->imm);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn adjust_reg_min_max_vals(env, insn);\n\t}\n\n\treturn 0;\n}\n\nstatic void __find_good_pkt_pointers(struct bpf_func_state *state,\n\t\t\t\t     struct bpf_reg_state *dst_reg,\n\t\t\t\t     enum bpf_reg_type type, int new_range)\n{\n\tstruct bpf_reg_state *reg;\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\treg = &state->regs[i];\n\t\tif (reg->type == type && reg->id == dst_reg->id)\n\t\t\t/* keep the maximum range already checked */\n\t\t\treg->range = max(reg->range, new_range);\n\t}\n\n\tbpf_for_each_spilled_reg(i, state, reg) {\n\t\tif (!reg)\n\t\t\tcontinue;\n\t\tif (reg->type == type && reg->id == dst_reg->id)\n\t\t\treg->range = max(reg->range, new_range);\n\t}\n}\n\nstatic void find_good_pkt_pointers(struct bpf_verifier_state *vstate,\n\t\t\t\t   struct bpf_reg_state *dst_reg,\n\t\t\t\t   enum bpf_reg_type type,\n\t\t\t\t   bool range_right_open)\n{\n\tint new_range, i;\n\n\tif (dst_reg->off < 0 ||\n\t    (dst_reg->off == 0 && range_right_open))\n\t\t/* This doesn't give us any range */\n\t\treturn;\n\n\tif (dst_reg->umax_value > MAX_PACKET_OFF ||\n\t    dst_reg->umax_value + dst_reg->off > MAX_PACKET_OFF)\n\t\t/* Risk of overflow.  For instance, ptr + (1<<63) may be less\n\t\t * than pkt_end, but that's because it's also less than pkt.\n\t\t */\n\t\treturn;\n\n\tnew_range = dst_reg->off;\n\tif (range_right_open)\n\t\tnew_range--;\n\n\t/* Examples for register markings:\n\t *\n\t * pkt_data in dst register:\n\t *\n\t *   r2 = r3;\n\t *   r2 += 8;\n\t *   if (r2 > pkt_end) goto <handle exception>\n\t *   <access okay>\n\t *\n\t *   r2 = r3;\n\t *   r2 += 8;\n\t *   if (r2 < pkt_end) goto <access okay>\n\t *   <handle exception>\n\t *\n\t *   Where:\n\t *     r2 == dst_reg, pkt_end == src_reg\n\t *     r2=pkt(id=n,off=8,r=0)\n\t *     r3=pkt(id=n,off=0,r=0)\n\t *\n\t * pkt_data in src register:\n\t *\n\t *   r2 = r3;\n\t *   r2 += 8;\n\t *   if (pkt_end >= r2) goto <access okay>\n\t *   <handle exception>\n\t *\n\t *   r2 = r3;\n\t *   r2 += 8;\n\t *   if (pkt_end <= r2) goto <handle exception>\n\t *   <access okay>\n\t *\n\t *   Where:\n\t *     pkt_end == dst_reg, r2 == src_reg\n\t *     r2=pkt(id=n,off=8,r=0)\n\t *     r3=pkt(id=n,off=0,r=0)\n\t *\n\t * Find register r3 and mark its range as r3=pkt(id=n,off=0,r=8)\n\t * or r3=pkt(id=n,off=0,r=8-1), so that range of bytes [r3, r3 + 8)\n\t * and [r3, r3 + 8-1) respectively is safe to access depending on\n\t * the check.\n\t */\n\n\t/* If our ids match, then we must have the same max_value.  And we\n\t * don't care about the other reg's fixed offset, since if it's too big\n\t * the range won't allow anything.\n\t * dst_reg->off is known < MAX_PACKET_OFF, therefore it fits in a u16.\n\t */\n\tfor (i = 0; i <= vstate->curframe; i++)\n\t\t__find_good_pkt_pointers(vstate->frame[i], dst_reg, type,\n\t\t\t\t\t new_range);\n}\n\nstatic int is_branch32_taken(struct bpf_reg_state *reg, u32 val, u8 opcode)\n{\n\tstruct tnum subreg = tnum_subreg(reg->var_off);\n\ts32 sval = (s32)val;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\t\tif (tnum_is_const(subreg))\n\t\t\treturn !!tnum_equals_const(subreg, val);\n\t\tbreak;\n\tcase BPF_JNE:\n\t\tif (tnum_is_const(subreg))\n\t\t\treturn !tnum_equals_const(subreg, val);\n\t\tbreak;\n\tcase BPF_JSET:\n\t\tif ((~subreg.mask & subreg.value) & val)\n\t\t\treturn 1;\n\t\tif (!((subreg.mask | subreg.value) & val))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JGT:\n\t\tif (reg->u32_min_value > val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_max_value <= val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSGT:\n\t\tif (reg->s32_min_value > sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_max_value <= sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JLT:\n\t\tif (reg->u32_max_value < val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_min_value >= val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSLT:\n\t\tif (reg->s32_max_value < sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_min_value >= sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JGE:\n\t\tif (reg->u32_min_value >= val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_max_value < val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSGE:\n\t\tif (reg->s32_min_value >= sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_max_value < sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JLE:\n\t\tif (reg->u32_max_value <= val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_min_value > val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSLE:\n\t\tif (reg->s32_max_value <= sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_min_value > sval)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\treturn -1;\n}\n\n\nstatic int is_branch64_taken(struct bpf_reg_state *reg, u64 val, u8 opcode)\n{\n\ts64 sval = (s64)val;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\t\tif (tnum_is_const(reg->var_off))\n\t\t\treturn !!tnum_equals_const(reg->var_off, val);\n\t\tbreak;\n\tcase BPF_JNE:\n\t\tif (tnum_is_const(reg->var_off))\n\t\t\treturn !tnum_equals_const(reg->var_off, val);\n\t\tbreak;\n\tcase BPF_JSET:\n\t\tif ((~reg->var_off.mask & reg->var_off.value) & val)\n\t\t\treturn 1;\n\t\tif (!((reg->var_off.mask | reg->var_off.value) & val))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JGT:\n\t\tif (reg->umin_value > val)\n\t\t\treturn 1;\n\t\telse if (reg->umax_value <= val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSGT:\n\t\tif (reg->smin_value > sval)\n\t\t\treturn 1;\n\t\telse if (reg->smax_value <= sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JLT:\n\t\tif (reg->umax_value < val)\n\t\t\treturn 1;\n\t\telse if (reg->umin_value >= val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSLT:\n\t\tif (reg->smax_value < sval)\n\t\t\treturn 1;\n\t\telse if (reg->smin_value >= sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JGE:\n\t\tif (reg->umin_value >= val)\n\t\t\treturn 1;\n\t\telse if (reg->umax_value < val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSGE:\n\t\tif (reg->smin_value >= sval)\n\t\t\treturn 1;\n\t\telse if (reg->smax_value < sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JLE:\n\t\tif (reg->umax_value <= val)\n\t\t\treturn 1;\n\t\telse if (reg->umin_value > val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSLE:\n\t\tif (reg->smax_value <= sval)\n\t\t\treturn 1;\n\t\telse if (reg->smin_value > sval)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\treturn -1;\n}\n\n/* compute branch direction of the expression \"if (reg opcode val) goto target;\"\n * and return:\n *  1 - branch will be taken and \"goto target\" will be executed\n *  0 - branch will not be taken and fall-through to next insn\n * -1 - unknown. Example: \"if (reg < 5)\" is unknown when register value\n *      range [0,10]\n */\nstatic int is_branch_taken(struct bpf_reg_state *reg, u64 val, u8 opcode,\n\t\t\t   bool is_jmp32)\n{\n\tif (__is_pointer_value(false, reg)) {\n\t\tif (!reg_type_not_null(reg->type))\n\t\t\treturn -1;\n\n\t\t/* If pointer is valid tests against zero will fail so we can\n\t\t * use this to direct branch taken.\n\t\t */\n\t\tif (val != 0)\n\t\t\treturn -1;\n\n\t\tswitch (opcode) {\n\t\tcase BPF_JEQ:\n\t\t\treturn 0;\n\t\tcase BPF_JNE:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (is_jmp32)\n\t\treturn is_branch32_taken(reg, val, opcode);\n\treturn is_branch64_taken(reg, val, opcode);\n}\n\nstatic int flip_opcode(u32 opcode)\n{\n\t/* How can we transform \"a <op> b\" into \"b <op> a\"? */\n\tstatic const u8 opcode_flip[16] = {\n\t\t/* these stay the same */\n\t\t[BPF_JEQ  >> 4] = BPF_JEQ,\n\t\t[BPF_JNE  >> 4] = BPF_JNE,\n\t\t[BPF_JSET >> 4] = BPF_JSET,\n\t\t/* these swap \"lesser\" and \"greater\" (L and G in the opcodes) */\n\t\t[BPF_JGE  >> 4] = BPF_JLE,\n\t\t[BPF_JGT  >> 4] = BPF_JLT,\n\t\t[BPF_JLE  >> 4] = BPF_JGE,\n\t\t[BPF_JLT  >> 4] = BPF_JGT,\n\t\t[BPF_JSGE >> 4] = BPF_JSLE,\n\t\t[BPF_JSGT >> 4] = BPF_JSLT,\n\t\t[BPF_JSLE >> 4] = BPF_JSGE,\n\t\t[BPF_JSLT >> 4] = BPF_JSGT\n\t};\n\treturn opcode_flip[opcode >> 4];\n}\n\nstatic int is_pkt_ptr_branch_taken(struct bpf_reg_state *dst_reg,\n\t\t\t\t   struct bpf_reg_state *src_reg,\n\t\t\t\t   u8 opcode)\n{\n\tstruct bpf_reg_state *pkt;\n\n\tif (src_reg->type == PTR_TO_PACKET_END) {\n\t\tpkt = dst_reg;\n\t} else if (dst_reg->type == PTR_TO_PACKET_END) {\n\t\tpkt = src_reg;\n\t\topcode = flip_opcode(opcode);\n\t} else {\n\t\treturn -1;\n\t}\n\n\tif (pkt->range >= 0)\n\t\treturn -1;\n\n\tswitch (opcode) {\n\tcase BPF_JLE:\n\t\t/* pkt <= pkt_end */\n\t\tfallthrough;\n\tcase BPF_JGT:\n\t\t/* pkt > pkt_end */\n\t\tif (pkt->range == BEYOND_PKT_END)\n\t\t\t/* pkt has at last one extra byte beyond pkt_end */\n\t\t\treturn opcode == BPF_JGT;\n\t\tbreak;\n\tcase BPF_JLT:\n\t\t/* pkt < pkt_end */\n\t\tfallthrough;\n\tcase BPF_JGE:\n\t\t/* pkt >= pkt_end */\n\t\tif (pkt->range == BEYOND_PKT_END || pkt->range == AT_PKT_END)\n\t\t\treturn opcode == BPF_JGE;\n\t\tbreak;\n\t}\n\treturn -1;\n}\n\n/* Adjusts the register min/max values in the case that the dst_reg is the\n * variable register that we are working on, and src_reg is a constant or we're\n * simply doing a BPF_K check.\n * In JEQ/JNE cases we also adjust the var_off values.\n */\nstatic void reg_set_min_max(struct bpf_reg_state *true_reg,\n\t\t\t    struct bpf_reg_state *false_reg,\n\t\t\t    u64 val, u32 val32,\n\t\t\t    u8 opcode, bool is_jmp32)\n{\n\tstruct tnum false_32off = tnum_subreg(false_reg->var_off);\n\tstruct tnum false_64off = false_reg->var_off;\n\tstruct tnum true_32off = tnum_subreg(true_reg->var_off);\n\tstruct tnum true_64off = true_reg->var_off;\n\ts64 sval = (s64)val;\n\ts32 sval32 = (s32)val32;\n\n\t/* If the dst_reg is a pointer, we can't learn anything about its\n\t * variable offset from the compare (unless src_reg were a pointer into\n\t * the same object, but we don't bother with that.\n\t * Since false_reg and true_reg have the same type by construction, we\n\t * only need to check one of them for pointerness.\n\t */\n\tif (__is_pointer_value(false, false_reg))\n\t\treturn;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\tcase BPF_JNE:\n\t{\n\t\tstruct bpf_reg_state *reg =\n\t\t\topcode == BPF_JEQ ? true_reg : false_reg;\n\n\t\t/* JEQ/JNE comparison doesn't change the register equivalence.\n\t\t * r1 = r2;\n\t\t * if (r1 == 42) goto label;\n\t\t * ...\n\t\t * label: // here both r1 and r2 are known to be 42.\n\t\t *\n\t\t * Hence when marking register as known preserve it's ID.\n\t\t */\n\t\tif (is_jmp32)\n\t\t\t__mark_reg32_known(reg, val32);\n\t\telse\n\t\t\t___mark_reg_known(reg, val);\n\t\tbreak;\n\t}\n\tcase BPF_JSET:\n\t\tif (is_jmp32) {\n\t\t\tfalse_32off = tnum_and(false_32off, tnum_const(~val32));\n\t\t\tif (is_power_of_2(val32))\n\t\t\t\ttrue_32off = tnum_or(true_32off,\n\t\t\t\t\t\t     tnum_const(val32));\n\t\t} else {\n\t\t\tfalse_64off = tnum_and(false_64off, tnum_const(~val));\n\t\t\tif (is_power_of_2(val))\n\t\t\t\ttrue_64off = tnum_or(true_64off,\n\t\t\t\t\t\t     tnum_const(val));\n\t\t}\n\t\tbreak;\n\tcase BPF_JGE:\n\tcase BPF_JGT:\n\t{\n\t\tif (is_jmp32) {\n\t\t\tu32 false_umax = opcode == BPF_JGT ? val32  : val32 - 1;\n\t\t\tu32 true_umin = opcode == BPF_JGT ? val32 + 1 : val32;\n\n\t\t\tfalse_reg->u32_max_value = min(false_reg->u32_max_value,\n\t\t\t\t\t\t       false_umax);\n\t\t\ttrue_reg->u32_min_value = max(true_reg->u32_min_value,\n\t\t\t\t\t\t      true_umin);\n\t\t} else {\n\t\t\tu64 false_umax = opcode == BPF_JGT ? val    : val - 1;\n\t\t\tu64 true_umin = opcode == BPF_JGT ? val + 1 : val;\n\n\t\t\tfalse_reg->umax_value = min(false_reg->umax_value, false_umax);\n\t\t\ttrue_reg->umin_value = max(true_reg->umin_value, true_umin);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JSGE:\n\tcase BPF_JSGT:\n\t{\n\t\tif (is_jmp32) {\n\t\t\ts32 false_smax = opcode == BPF_JSGT ? sval32    : sval32 - 1;\n\t\t\ts32 true_smin = opcode == BPF_JSGT ? sval32 + 1 : sval32;\n\n\t\t\tfalse_reg->s32_max_value = min(false_reg->s32_max_value, false_smax);\n\t\t\ttrue_reg->s32_min_value = max(true_reg->s32_min_value, true_smin);\n\t\t} else {\n\t\t\ts64 false_smax = opcode == BPF_JSGT ? sval    : sval - 1;\n\t\t\ts64 true_smin = opcode == BPF_JSGT ? sval + 1 : sval;\n\n\t\t\tfalse_reg->smax_value = min(false_reg->smax_value, false_smax);\n\t\t\ttrue_reg->smin_value = max(true_reg->smin_value, true_smin);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JLE:\n\tcase BPF_JLT:\n\t{\n\t\tif (is_jmp32) {\n\t\t\tu32 false_umin = opcode == BPF_JLT ? val32  : val32 + 1;\n\t\t\tu32 true_umax = opcode == BPF_JLT ? val32 - 1 : val32;\n\n\t\t\tfalse_reg->u32_min_value = max(false_reg->u32_min_value,\n\t\t\t\t\t\t       false_umin);\n\t\t\ttrue_reg->u32_max_value = min(true_reg->u32_max_value,\n\t\t\t\t\t\t      true_umax);\n\t\t} else {\n\t\t\tu64 false_umin = opcode == BPF_JLT ? val    : val + 1;\n\t\t\tu64 true_umax = opcode == BPF_JLT ? val - 1 : val;\n\n\t\t\tfalse_reg->umin_value = max(false_reg->umin_value, false_umin);\n\t\t\ttrue_reg->umax_value = min(true_reg->umax_value, true_umax);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JSLE:\n\tcase BPF_JSLT:\n\t{\n\t\tif (is_jmp32) {\n\t\t\ts32 false_smin = opcode == BPF_JSLT ? sval32    : sval32 + 1;\n\t\t\ts32 true_smax = opcode == BPF_JSLT ? sval32 - 1 : sval32;\n\n\t\t\tfalse_reg->s32_min_value = max(false_reg->s32_min_value, false_smin);\n\t\t\ttrue_reg->s32_max_value = min(true_reg->s32_max_value, true_smax);\n\t\t} else {\n\t\t\ts64 false_smin = opcode == BPF_JSLT ? sval    : sval + 1;\n\t\t\ts64 true_smax = opcode == BPF_JSLT ? sval - 1 : sval;\n\n\t\t\tfalse_reg->smin_value = max(false_reg->smin_value, false_smin);\n\t\t\ttrue_reg->smax_value = min(true_reg->smax_value, true_smax);\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (is_jmp32) {\n\t\tfalse_reg->var_off = tnum_or(tnum_clear_subreg(false_64off),\n\t\t\t\t\t     tnum_subreg(false_32off));\n\t\ttrue_reg->var_off = tnum_or(tnum_clear_subreg(true_64off),\n\t\t\t\t\t    tnum_subreg(true_32off));\n\t\t__reg_combine_32_into_64(false_reg);\n\t\t__reg_combine_32_into_64(true_reg);\n\t} else {\n\t\tfalse_reg->var_off = false_64off;\n\t\ttrue_reg->var_off = true_64off;\n\t\t__reg_combine_64_into_32(false_reg);\n\t\t__reg_combine_64_into_32(true_reg);\n\t}\n}\n\n/* Same as above, but for the case that dst_reg holds a constant and src_reg is\n * the variable reg.\n */\nstatic void reg_set_min_max_inv(struct bpf_reg_state *true_reg,\n\t\t\t\tstruct bpf_reg_state *false_reg,\n\t\t\t\tu64 val, u32 val32,\n\t\t\t\tu8 opcode, bool is_jmp32)\n{\n\topcode = flip_opcode(opcode);\n\t/* This uses zero as \"not present in table\"; luckily the zero opcode,\n\t * BPF_JA, can't get here.\n\t */\n\tif (opcode)\n\t\treg_set_min_max(true_reg, false_reg, val, val32, opcode, is_jmp32);\n}\n\n/* Regs are known to be equal, so intersect their min/max/var_off */\nstatic void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t/* We might have learned new bounds from the var_off. */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t/* We might have learned something about the sign bit. */\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}\n\nstatic void reg_combine_min_max(struct bpf_reg_state *true_src,\n\t\t\t\tstruct bpf_reg_state *true_dst,\n\t\t\t\tstruct bpf_reg_state *false_src,\n\t\t\t\tstruct bpf_reg_state *false_dst,\n\t\t\t\tu8 opcode)\n{\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\t\t__reg_combine_min_max(true_src, true_dst);\n\t\tbreak;\n\tcase BPF_JNE:\n\t\t__reg_combine_min_max(false_src, false_dst);\n\t\tbreak;\n\t}\n}\n\nstatic void mark_ptr_or_null_reg(struct bpf_func_state *state,\n\t\t\t\t struct bpf_reg_state *reg, u32 id,\n\t\t\t\t bool is_null)\n{\n\tif (reg_type_may_be_null(reg->type) && reg->id == id &&\n\t    !WARN_ON_ONCE(!reg->id)) {\n\t\t/* Old offset (both fixed and variable parts) should\n\t\t * have been known-zero, because we don't allow pointer\n\t\t * arithmetic on pointers that might be NULL.\n\t\t */\n\t\tif (WARN_ON_ONCE(reg->smin_value || reg->smax_value ||\n\t\t\t\t !tnum_equals_const(reg->var_off, 0) ||\n\t\t\t\t reg->off)) {\n\t\t\t__mark_reg_known_zero(reg);\n\t\t\treg->off = 0;\n\t\t}\n\t\tif (is_null) {\n\t\t\treg->type = SCALAR_VALUE;\n\t\t\t/* We don't need id and ref_obj_id from this point\n\t\t\t * onwards anymore, thus we should better reset it,\n\t\t\t * so that state pruning has chances to take effect.\n\t\t\t */\n\t\t\treg->id = 0;\n\t\t\treg->ref_obj_id = 0;\n\n\t\t\treturn;\n\t\t}\n\n\t\tmark_ptr_not_null_reg(reg);\n\n\t\tif (!reg_may_point_to_spin_lock(reg)) {\n\t\t\t/* For not-NULL ptr, reg->ref_obj_id will be reset\n\t\t\t * in release_reg_references().\n\t\t\t *\n\t\t\t * reg->id is still used by spin_lock ptr. Other\n\t\t\t * than spin_lock ptr type, reg->id can be reset.\n\t\t\t */\n\t\t\treg->id = 0;\n\t\t}\n\t}\n}\n\nstatic void __mark_ptr_or_null_regs(struct bpf_func_state *state, u32 id,\n\t\t\t\t    bool is_null)\n{\n\tstruct bpf_reg_state *reg;\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++)\n\t\tmark_ptr_or_null_reg(state, &state->regs[i], id, is_null);\n\n\tbpf_for_each_spilled_reg(i, state, reg) {\n\t\tif (!reg)\n\t\t\tcontinue;\n\t\tmark_ptr_or_null_reg(state, reg, id, is_null);\n\t}\n}\n\n/* The logic is similar to find_good_pkt_pointers(), both could eventually\n * be folded together at some point.\n */\nstatic void mark_ptr_or_null_regs(struct bpf_verifier_state *vstate, u32 regno,\n\t\t\t\t  bool is_null)\n{\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tstruct bpf_reg_state *regs = state->regs;\n\tu32 ref_obj_id = regs[regno].ref_obj_id;\n\tu32 id = regs[regno].id;\n\tint i;\n\n\tif (ref_obj_id && ref_obj_id == id && is_null)\n\t\t/* regs[regno] is in the \" == NULL\" branch.\n\t\t * No one could have freed the reference state before\n\t\t * doing the NULL check.\n\t\t */\n\t\tWARN_ON_ONCE(release_reference_state(state, id));\n\n\tfor (i = 0; i <= vstate->curframe; i++)\n\t\t__mark_ptr_or_null_regs(vstate->frame[i], id, is_null);\n}\n\nstatic bool try_match_pkt_pointers(const struct bpf_insn *insn,\n\t\t\t\t   struct bpf_reg_state *dst_reg,\n\t\t\t\t   struct bpf_reg_state *src_reg,\n\t\t\t\t   struct bpf_verifier_state *this_branch,\n\t\t\t\t   struct bpf_verifier_state *other_branch)\n{\n\tif (BPF_SRC(insn->code) != BPF_X)\n\t\treturn false;\n\n\t/* Pointers are always 64-bit. */\n\tif (BPF_CLASS(insn->code) == BPF_JMP32)\n\t\treturn false;\n\n\tswitch (BPF_OP(insn->code)) {\n\tcase BPF_JGT:\n\t\tif ((dst_reg->type == PTR_TO_PACKET &&\n\t\t     src_reg->type == PTR_TO_PACKET_END) ||\n\t\t    (dst_reg->type == PTR_TO_PACKET_META &&\n\t\t     reg_is_init_pkt_pointer(src_reg, PTR_TO_PACKET))) {\n\t\t\t/* pkt_data' > pkt_end, pkt_meta' > pkt_data */\n\t\t\tfind_good_pkt_pointers(this_branch, dst_reg,\n\t\t\t\t\t       dst_reg->type, false);\n\t\t\tmark_pkt_end(other_branch, insn->dst_reg, true);\n\t\t} else if ((dst_reg->type == PTR_TO_PACKET_END &&\n\t\t\t    src_reg->type == PTR_TO_PACKET) ||\n\t\t\t   (reg_is_init_pkt_pointer(dst_reg, PTR_TO_PACKET) &&\n\t\t\t    src_reg->type == PTR_TO_PACKET_META)) {\n\t\t\t/* pkt_end > pkt_data', pkt_data > pkt_meta' */\n\t\t\tfind_good_pkt_pointers(other_branch, src_reg,\n\t\t\t\t\t       src_reg->type, true);\n\t\t\tmark_pkt_end(this_branch, insn->src_reg, false);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase BPF_JLT:\n\t\tif ((dst_reg->type == PTR_TO_PACKET &&\n\t\t     src_reg->type == PTR_TO_PACKET_END) ||\n\t\t    (dst_reg->type == PTR_TO_PACKET_META &&\n\t\t     reg_is_init_pkt_pointer(src_reg, PTR_TO_PACKET))) {\n\t\t\t/* pkt_data' < pkt_end, pkt_meta' < pkt_data */\n\t\t\tfind_good_pkt_pointers(other_branch, dst_reg,\n\t\t\t\t\t       dst_reg->type, true);\n\t\t\tmark_pkt_end(this_branch, insn->dst_reg, false);\n\t\t} else if ((dst_reg->type == PTR_TO_PACKET_END &&\n\t\t\t    src_reg->type == PTR_TO_PACKET) ||\n\t\t\t   (reg_is_init_pkt_pointer(dst_reg, PTR_TO_PACKET) &&\n\t\t\t    src_reg->type == PTR_TO_PACKET_META)) {\n\t\t\t/* pkt_end < pkt_data', pkt_data > pkt_meta' */\n\t\t\tfind_good_pkt_pointers(this_branch, src_reg,\n\t\t\t\t\t       src_reg->type, false);\n\t\t\tmark_pkt_end(other_branch, insn->src_reg, true);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase BPF_JGE:\n\t\tif ((dst_reg->type == PTR_TO_PACKET &&\n\t\t     src_reg->type == PTR_TO_PACKET_END) ||\n\t\t    (dst_reg->type == PTR_TO_PACKET_META &&\n\t\t     reg_is_init_pkt_pointer(src_reg, PTR_TO_PACKET))) {\n\t\t\t/* pkt_data' >= pkt_end, pkt_meta' >= pkt_data */\n\t\t\tfind_good_pkt_pointers(this_branch, dst_reg,\n\t\t\t\t\t       dst_reg->type, true);\n\t\t\tmark_pkt_end(other_branch, insn->dst_reg, false);\n\t\t} else if ((dst_reg->type == PTR_TO_PACKET_END &&\n\t\t\t    src_reg->type == PTR_TO_PACKET) ||\n\t\t\t   (reg_is_init_pkt_pointer(dst_reg, PTR_TO_PACKET) &&\n\t\t\t    src_reg->type == PTR_TO_PACKET_META)) {\n\t\t\t/* pkt_end >= pkt_data', pkt_data >= pkt_meta' */\n\t\t\tfind_good_pkt_pointers(other_branch, src_reg,\n\t\t\t\t\t       src_reg->type, false);\n\t\t\tmark_pkt_end(this_branch, insn->src_reg, true);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase BPF_JLE:\n\t\tif ((dst_reg->type == PTR_TO_PACKET &&\n\t\t     src_reg->type == PTR_TO_PACKET_END) ||\n\t\t    (dst_reg->type == PTR_TO_PACKET_META &&\n\t\t     reg_is_init_pkt_pointer(src_reg, PTR_TO_PACKET))) {\n\t\t\t/* pkt_data' <= pkt_end, pkt_meta' <= pkt_data */\n\t\t\tfind_good_pkt_pointers(other_branch, dst_reg,\n\t\t\t\t\t       dst_reg->type, false);\n\t\t\tmark_pkt_end(this_branch, insn->dst_reg, true);\n\t\t} else if ((dst_reg->type == PTR_TO_PACKET_END &&\n\t\t\t    src_reg->type == PTR_TO_PACKET) ||\n\t\t\t   (reg_is_init_pkt_pointer(dst_reg, PTR_TO_PACKET) &&\n\t\t\t    src_reg->type == PTR_TO_PACKET_META)) {\n\t\t\t/* pkt_end <= pkt_data', pkt_data <= pkt_meta' */\n\t\t\tfind_good_pkt_pointers(this_branch, src_reg,\n\t\t\t\t\t       src_reg->type, true);\n\t\t\tmark_pkt_end(other_branch, insn->src_reg, false);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void find_equal_scalars(struct bpf_verifier_state *vstate,\n\t\t\t       struct bpf_reg_state *known_reg)\n{\n\tstruct bpf_func_state *state;\n\tstruct bpf_reg_state *reg;\n\tint i, j;\n\n\tfor (i = 0; i <= vstate->curframe; i++) {\n\t\tstate = vstate->frame[i];\n\t\tfor (j = 0; j < MAX_BPF_REG; j++) {\n\t\t\treg = &state->regs[j];\n\t\t\tif (reg->type == SCALAR_VALUE && reg->id == known_reg->id)\n\t\t\t\t*reg = *known_reg;\n\t\t}\n\n\t\tbpf_for_each_spilled_reg(j, state, reg) {\n\t\t\tif (!reg)\n\t\t\t\tcontinue;\n\t\t\tif (reg->type == SCALAR_VALUE && reg->id == known_reg->id)\n\t\t\t\t*reg = *known_reg;\n\t\t}\n\t}\n}\n\nstatic int check_cond_jmp_op(struct bpf_verifier_env *env,\n\t\t\t     struct bpf_insn *insn, int *insn_idx)\n{\n\tstruct bpf_verifier_state *this_branch = env->cur_state;\n\tstruct bpf_verifier_state *other_branch;\n\tstruct bpf_reg_state *regs = this_branch->frame[this_branch->curframe]->regs;\n\tstruct bpf_reg_state *dst_reg, *other_branch_regs, *src_reg = NULL;\n\tu8 opcode = BPF_OP(insn->code);\n\tbool is_jmp32;\n\tint pred = -1;\n\tint err;\n\n\t/* Only conditional jumps are expected to reach here. */\n\tif (opcode == BPF_JA || opcode > BPF_JSLE) {\n\t\tverbose(env, \"invalid BPF_JMP/JMP32 opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tif (insn->imm != 0) {\n\t\t\tverbose(env, \"BPF_JMP/JMP32 uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* check src1 operand */\n\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\tverbose(env, \"R%d pointer comparison prohibited\\n\",\n\t\t\t\tinsn->src_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tsrc_reg = &regs[insn->src_reg];\n\t} else {\n\t\tif (insn->src_reg != BPF_REG_0) {\n\t\t\tverbose(env, \"BPF_JMP/JMP32 uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* check src2 operand */\n\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tdst_reg = &regs[insn->dst_reg];\n\tis_jmp32 = BPF_CLASS(insn->code) == BPF_JMP32;\n\n\tif (BPF_SRC(insn->code) == BPF_K) {\n\t\tpred = is_branch_taken(dst_reg, insn->imm, opcode, is_jmp32);\n\t} else if (src_reg->type == SCALAR_VALUE &&\n\t\t   is_jmp32 && tnum_is_const(tnum_subreg(src_reg->var_off))) {\n\t\tpred = is_branch_taken(dst_reg,\n\t\t\t\t       tnum_subreg(src_reg->var_off).value,\n\t\t\t\t       opcode,\n\t\t\t\t       is_jmp32);\n\t} else if (src_reg->type == SCALAR_VALUE &&\n\t\t   !is_jmp32 && tnum_is_const(src_reg->var_off)) {\n\t\tpred = is_branch_taken(dst_reg,\n\t\t\t\t       src_reg->var_off.value,\n\t\t\t\t       opcode,\n\t\t\t\t       is_jmp32);\n\t} else if (reg_is_pkt_pointer_any(dst_reg) &&\n\t\t   reg_is_pkt_pointer_any(src_reg) &&\n\t\t   !is_jmp32) {\n\t\tpred = is_pkt_ptr_branch_taken(dst_reg, src_reg, opcode);\n\t}\n\n\tif (pred >= 0) {\n\t\t/* If we get here with a dst_reg pointer type it is because\n\t\t * above is_branch_taken() special cased the 0 comparison.\n\t\t */\n\t\tif (!__is_pointer_value(false, dst_reg))\n\t\t\terr = mark_chain_precision(env, insn->dst_reg);\n\t\tif (BPF_SRC(insn->code) == BPF_X && !err &&\n\t\t    !__is_pointer_value(false, src_reg))\n\t\t\terr = mark_chain_precision(env, insn->src_reg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (pred == 1) {\n\t\t/* only follow the goto, ignore fall-through */\n\t\t*insn_idx += insn->off;\n\t\treturn 0;\n\t} else if (pred == 0) {\n\t\t/* only follow fall-through branch, since\n\t\t * that's where the program will go\n\t\t */\n\t\treturn 0;\n\t}\n\n\tother_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx,\n\t\t\t\t  false);\n\tif (!other_branch)\n\t\treturn -EFAULT;\n\tother_branch_regs = other_branch->frame[other_branch->curframe]->regs;\n\n\t/* detect if we are comparing against a constant value so we can adjust\n\t * our min/max values for our dst register.\n\t * this is only legit if both are scalars (or pointers to the same\n\t * object, I suppose, but we don't support that right now), because\n\t * otherwise the different base pointers mean the offsets aren't\n\t * comparable.\n\t */\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tstruct bpf_reg_state *src_reg = &regs[insn->src_reg];\n\n\t\tif (dst_reg->type == SCALAR_VALUE &&\n\t\t    src_reg->type == SCALAR_VALUE) {\n\t\t\tif (tnum_is_const(src_reg->var_off) ||\n\t\t\t    (is_jmp32 &&\n\t\t\t     tnum_is_const(tnum_subreg(src_reg->var_off))))\n\t\t\t\treg_set_min_max(&other_branch_regs[insn->dst_reg],\n\t\t\t\t\t\tdst_reg,\n\t\t\t\t\t\tsrc_reg->var_off.value,\n\t\t\t\t\t\ttnum_subreg(src_reg->var_off).value,\n\t\t\t\t\t\topcode, is_jmp32);\n\t\t\telse if (tnum_is_const(dst_reg->var_off) ||\n\t\t\t\t (is_jmp32 &&\n\t\t\t\t  tnum_is_const(tnum_subreg(dst_reg->var_off))))\n\t\t\t\treg_set_min_max_inv(&other_branch_regs[insn->src_reg],\n\t\t\t\t\t\t    src_reg,\n\t\t\t\t\t\t    dst_reg->var_off.value,\n\t\t\t\t\t\t    tnum_subreg(dst_reg->var_off).value,\n\t\t\t\t\t\t    opcode, is_jmp32);\n\t\t\telse if (!is_jmp32 &&\n\t\t\t\t (opcode == BPF_JEQ || opcode == BPF_JNE))\n\t\t\t\t/* Comparing for equality, we can combine knowledge */\n\t\t\t\treg_combine_min_max(&other_branch_regs[insn->src_reg],\n\t\t\t\t\t\t    &other_branch_regs[insn->dst_reg],\n\t\t\t\t\t\t    src_reg, dst_reg, opcode);\n\t\t\tif (src_reg->id &&\n\t\t\t    !WARN_ON_ONCE(src_reg->id != other_branch_regs[insn->src_reg].id)) {\n\t\t\t\tfind_equal_scalars(this_branch, src_reg);\n\t\t\t\tfind_equal_scalars(other_branch, &other_branch_regs[insn->src_reg]);\n\t\t\t}\n\n\t\t}\n\t} else if (dst_reg->type == SCALAR_VALUE) {\n\t\treg_set_min_max(&other_branch_regs[insn->dst_reg],\n\t\t\t\t\tdst_reg, insn->imm, (u32)insn->imm,\n\t\t\t\t\topcode, is_jmp32);\n\t}\n\n\tif (dst_reg->type == SCALAR_VALUE && dst_reg->id &&\n\t    !WARN_ON_ONCE(dst_reg->id != other_branch_regs[insn->dst_reg].id)) {\n\t\tfind_equal_scalars(this_branch, dst_reg);\n\t\tfind_equal_scalars(other_branch, &other_branch_regs[insn->dst_reg]);\n\t}\n\n\t/* detect if R == 0 where R is returned from bpf_map_lookup_elem().\n\t * NOTE: these optimizations below are related with pointer comparison\n\t *       which will never be JMP32.\n\t */\n\tif (!is_jmp32 && BPF_SRC(insn->code) == BPF_K &&\n\t    insn->imm == 0 && (opcode == BPF_JEQ || opcode == BPF_JNE) &&\n\t    reg_type_may_be_null(dst_reg->type)) {\n\t\t/* Mark all identical registers in each branch as either\n\t\t * safe or unknown depending R == 0 or R != 0 conditional.\n\t\t */\n\t\tmark_ptr_or_null_regs(this_branch, insn->dst_reg,\n\t\t\t\t      opcode == BPF_JNE);\n\t\tmark_ptr_or_null_regs(other_branch, insn->dst_reg,\n\t\t\t\t      opcode == BPF_JEQ);\n\t} else if (!try_match_pkt_pointers(insn, dst_reg, &regs[insn->src_reg],\n\t\t\t\t\t   this_branch, other_branch) &&\n\t\t   is_pointer_value(env, insn->dst_reg)) {\n\t\tverbose(env, \"R%d pointer comparison prohibited\\n\",\n\t\t\tinsn->dst_reg);\n\t\treturn -EACCES;\n\t}\n\tif (env->log.level & BPF_LOG_LEVEL)\n\t\tprint_verifier_state(env, this_branch->frame[this_branch->curframe]);\n\treturn 0;\n}\n\n/* verify BPF_LD_IMM64 instruction */\nstatic int check_ld_imm(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *dst_reg;\n\tstruct bpf_map *map;\n\tint err;\n\n\tif (BPF_SIZE(insn->code) != BPF_DW) {\n\t\tverbose(env, \"invalid BPF_LD_IMM insn\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (insn->off != 0) {\n\t\tverbose(env, \"BPF_LD_IMM64 uses reserved fields\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\tif (err)\n\t\treturn err;\n\n\tdst_reg = &regs[insn->dst_reg];\n\tif (insn->src_reg == 0) {\n\t\tu64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;\n\n\t\tdst_reg->type = SCALAR_VALUE;\n\t\t__mark_reg_known(&regs[insn->dst_reg], imm);\n\t\treturn 0;\n\t}\n\n\tif (insn->src_reg == BPF_PSEUDO_BTF_ID) {\n\t\tmark_reg_known_zero(env, regs, insn->dst_reg);\n\n\t\tdst_reg->type = aux->btf_var.reg_type;\n\t\tswitch (dst_reg->type) {\n\t\tcase PTR_TO_MEM:\n\t\t\tdst_reg->mem_size = aux->btf_var.mem_size;\n\t\t\tbreak;\n\t\tcase PTR_TO_BTF_ID:\n\t\tcase PTR_TO_PERCPU_BTF_ID:\n\t\t\tdst_reg->btf = aux->btf_var.btf;\n\t\t\tdst_reg->btf_id = aux->btf_var.btf_id;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (insn->src_reg == BPF_PSEUDO_FUNC) {\n\t\tstruct bpf_prog_aux *aux = env->prog->aux;\n\t\tu32 subprogno = insn[1].imm;\n\n\t\tif (!aux->func_info) {\n\t\t\tverbose(env, \"missing btf func_info\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (aux->func_info_aux[subprogno].linkage != BTF_FUNC_STATIC) {\n\t\t\tverbose(env, \"callback function not static\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdst_reg->type = PTR_TO_FUNC;\n\t\tdst_reg->subprogno = subprogno;\n\t\treturn 0;\n\t}\n\n\tmap = env->used_maps[aux->map_index];\n\tmark_reg_known_zero(env, regs, insn->dst_reg);\n\tdst_reg->map_ptr = map;\n\n\tif (insn->src_reg == BPF_PSEUDO_MAP_VALUE) {\n\t\tdst_reg->type = PTR_TO_MAP_VALUE;\n\t\tdst_reg->off = aux->map_off;\n\t\tif (map_value_has_spin_lock(map))\n\t\t\tdst_reg->id = ++env->id_gen;\n\t} else if (insn->src_reg == BPF_PSEUDO_MAP_FD) {\n\t\tdst_reg->type = CONST_PTR_TO_MAP;\n\t} else {\n\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic bool may_access_skb(enum bpf_prog_type type)\n{\n\tswitch (type) {\n\tcase BPF_PROG_TYPE_SOCKET_FILTER:\n\tcase BPF_PROG_TYPE_SCHED_CLS:\n\tcase BPF_PROG_TYPE_SCHED_ACT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n/* verify safety of LD_ABS|LD_IND instructions:\n * - they can only appear in the programs where ctx == skb\n * - since they are wrappers of function calls, they scratch R1-R5 registers,\n *   preserve R6-R9, and store return value into R0\n *\n * Implicit input:\n *   ctx == skb == R6 == CTX\n *\n * Explicit input:\n *   SRC == any register\n *   IMM == 32-bit immediate\n *\n * Output:\n *   R0 - 8/16/32-bit skb data converted to cpu endianness\n */\nstatic int check_ld_abs(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstatic const int ctx_reg = BPF_REG_6;\n\tu8 mode = BPF_MODE(insn->code);\n\tint i, err;\n\n\tif (!may_access_skb(resolve_prog_type(env->prog))) {\n\t\tverbose(env, \"BPF_LD_[ABS|IND] instructions not allowed for this program type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env->ops->gen_ld_abs) {\n\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (insn->dst_reg != BPF_REG_0 || insn->off != 0 ||\n\t    BPF_SIZE(insn->code) == BPF_DW ||\n\t    (mode == BPF_ABS && insn->src_reg != BPF_REG_0)) {\n\t\tverbose(env, \"BPF_LD_[ABS|IND] uses reserved fields\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check whether implicit source operand (register R6) is readable */\n\terr = check_reg_arg(env, ctx_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\t/* Disallow usage of BPF_LD_[ABS|IND] with reference tracking, as\n\t * gen_ld_abs() may terminate the program at runtime, leading to\n\t * reference leak.\n\t */\n\terr = check_reference_leak(env);\n\tif (err) {\n\t\tverbose(env, \"BPF_LD_[ABS|IND] cannot be mixed with socket references\\n\");\n\t\treturn err;\n\t}\n\n\tif (env->cur_state->active_spin_lock) {\n\t\tverbose(env, \"BPF_LD_[ABS|IND] cannot be used inside bpf_spin_lock-ed region\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (regs[ctx_reg].type != PTR_TO_CTX) {\n\t\tverbose(env,\n\t\t\t\"at the time of BPF_LD_ABS|IND R6 != pointer to skb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mode == BPF_IND) {\n\t\t/* check explicit source operand */\n\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = check_ctx_reg(env, &regs[ctx_reg], ctx_reg);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* reset caller saved regs to unreadable */\n\tfor (i = 0; i < CALLER_SAVED_REGS; i++) {\n\t\tmark_reg_not_init(env, regs, caller_saved[i]);\n\t\tcheck_reg_arg(env, caller_saved[i], DST_OP_NO_MARK);\n\t}\n\n\t/* mark destination R0 register as readable, since it contains\n\t * the value fetched from the packet.\n\t * Already marked as written above.\n\t */\n\tmark_reg_unknown(env, regs, BPF_REG_0);\n\t/* ld_abs load up to 32-bit skb data. */\n\tregs[BPF_REG_0].subreg_def = env->insn_idx + 1;\n\treturn 0;\n}\n\nstatic int check_return_code(struct bpf_verifier_env *env)\n{\n\tstruct tnum enforce_attach_type_range = tnum_unknown;\n\tconst struct bpf_prog *prog = env->prog;\n\tstruct bpf_reg_state *reg;\n\tstruct tnum range = tnum_range(0, 1);\n\tenum bpf_prog_type prog_type = resolve_prog_type(env->prog);\n\tint err;\n\tconst bool is_subprog = env->cur_state->frame[0]->subprogno;\n\n\t/* LSM and struct_ops func-ptr's return type could be \"void\" */\n\tif (!is_subprog &&\n\t    (prog_type == BPF_PROG_TYPE_STRUCT_OPS ||\n\t     prog_type == BPF_PROG_TYPE_LSM) &&\n\t    !prog->aux->attach_func_proto->type)\n\t\treturn 0;\n\n\t/* eBPF calling convetion is such that R0 is used\n\t * to return the value from eBPF program.\n\t * Make sure that it's readable at this time\n\t * of bpf_exit, which means that program wrote\n\t * something into it earlier\n\t */\n\terr = check_reg_arg(env, BPF_REG_0, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (is_pointer_value(env, BPF_REG_0)) {\n\t\tverbose(env, \"R0 leaks addr as return value\\n\");\n\t\treturn -EACCES;\n\t}\n\n\treg = cur_regs(env) + BPF_REG_0;\n\tif (is_subprog) {\n\t\tif (reg->type != SCALAR_VALUE) {\n\t\t\tverbose(env, \"At subprogram exit the register R0 is not a scalar value (%s)\\n\",\n\t\t\t\treg_type_str[reg->type]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tswitch (prog_type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\t\tif (env->prog->expected_attach_type == BPF_CGROUP_UDP4_RECVMSG ||\n\t\t    env->prog->expected_attach_type == BPF_CGROUP_UDP6_RECVMSG ||\n\t\t    env->prog->expected_attach_type == BPF_CGROUP_INET4_GETPEERNAME ||\n\t\t    env->prog->expected_attach_type == BPF_CGROUP_INET6_GETPEERNAME ||\n\t\t    env->prog->expected_attach_type == BPF_CGROUP_INET4_GETSOCKNAME ||\n\t\t    env->prog->expected_attach_type == BPF_CGROUP_INET6_GETSOCKNAME)\n\t\t\trange = tnum_range(1, 1);\n\t\tif (env->prog->expected_attach_type == BPF_CGROUP_INET4_BIND ||\n\t\t    env->prog->expected_attach_type == BPF_CGROUP_INET6_BIND)\n\t\t\trange = tnum_range(0, 3);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\t\tif (env->prog->expected_attach_type == BPF_CGROUP_INET_EGRESS) {\n\t\t\trange = tnum_range(0, 3);\n\t\t\tenforce_attach_type_range = tnum_range(2, 3);\n\t\t}\n\t\tbreak;\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_SOCK_OPS:\n\tcase BPF_PROG_TYPE_CGROUP_DEVICE:\n\tcase BPF_PROG_TYPE_CGROUP_SYSCTL:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\t\tbreak;\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT:\n\t\tif (!env->prog->aux->attach_btf_id)\n\t\t\treturn 0;\n\t\trange = tnum_const(0);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_TRACING:\n\t\tswitch (env->prog->expected_attach_type) {\n\t\tcase BPF_TRACE_FENTRY:\n\t\tcase BPF_TRACE_FEXIT:\n\t\t\trange = tnum_const(0);\n\t\t\tbreak;\n\t\tcase BPF_TRACE_RAW_TP:\n\t\tcase BPF_MODIFY_RETURN:\n\t\t\treturn 0;\n\t\tcase BPF_TRACE_ITER:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase BPF_PROG_TYPE_SK_LOOKUP:\n\t\trange = tnum_range(SK_DROP, SK_PASS);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_EXT:\n\t\t/* freplace program can return anything as its return value\n\t\t * depends on the to-be-replaced kernel func or bpf program.\n\t\t */\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (reg->type != SCALAR_VALUE) {\n\t\tverbose(env, \"At program exit the register R0 is not a known value (%s)\\n\",\n\t\t\treg_type_str[reg->type]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!tnum_in(range, reg->var_off)) {\n\t\tverbose_invalid_scalar(env, reg, &range, \"program exit\", \"R0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!tnum_is_unknown(enforce_attach_type_range) &&\n\t    tnum_in(enforce_attach_type_range, reg->var_off))\n\t\tenv->prog->enforce_expected_attach_type = 1;\n\treturn 0;\n}\n\n/* non-recursive DFS pseudo code\n * 1  procedure DFS-iterative(G,v):\n * 2      label v as discovered\n * 3      let S be a stack\n * 4      S.push(v)\n * 5      while S is not empty\n * 6            t <- S.pop()\n * 7            if t is what we're looking for:\n * 8                return t\n * 9            for all edges e in G.adjacentEdges(t) do\n * 10               if edge e is already labelled\n * 11                   continue with the next edge\n * 12               w <- G.adjacentVertex(t,e)\n * 13               if vertex w is not discovered and not explored\n * 14                   label e as tree-edge\n * 15                   label w as discovered\n * 16                   S.push(w)\n * 17                   continue at 5\n * 18               else if vertex w is discovered\n * 19                   label e as back-edge\n * 20               else\n * 21                   // vertex w is explored\n * 22                   label e as forward- or cross-edge\n * 23           label t as explored\n * 24           S.pop()\n *\n * convention:\n * 0x10 - discovered\n * 0x11 - discovered and fall-through edge labelled\n * 0x12 - discovered and fall-through and branch edges labelled\n * 0x20 - explored\n */\n\nenum {\n\tDISCOVERED = 0x10,\n\tEXPLORED = 0x20,\n\tFALLTHROUGH = 1,\n\tBRANCH = 2,\n};\n\nstatic u32 state_htab_size(struct bpf_verifier_env *env)\n{\n\treturn env->prog->len;\n}\n\nstatic struct bpf_verifier_state_list **explored_state(\n\t\t\t\t\tstruct bpf_verifier_env *env,\n\t\t\t\t\tint idx)\n{\n\tstruct bpf_verifier_state *cur = env->cur_state;\n\tstruct bpf_func_state *state = cur->frame[cur->curframe];\n\n\treturn &env->explored_states[(idx ^ state->callsite) % state_htab_size(env)];\n}\n\nstatic void init_explored_state(struct bpf_verifier_env *env, int idx)\n{\n\tenv->insn_aux_data[idx].prune_point = true;\n}\n\nenum {\n\tDONE_EXPLORING = 0,\n\tKEEP_EXPLORING = 1,\n};\n\n/* t, w, e - match pseudo-code above:\n * t - index of current instruction\n * w - next instruction\n * e - edge\n */\nstatic int push_insn(int t, int w, int e, struct bpf_verifier_env *env,\n\t\t     bool loop_ok)\n{\n\tint *insn_stack = env->cfg.insn_stack;\n\tint *insn_state = env->cfg.insn_state;\n\n\tif (e == FALLTHROUGH && insn_state[t] >= (DISCOVERED | FALLTHROUGH))\n\t\treturn DONE_EXPLORING;\n\n\tif (e == BRANCH && insn_state[t] >= (DISCOVERED | BRANCH))\n\t\treturn DONE_EXPLORING;\n\n\tif (w < 0 || w >= env->prog->len) {\n\t\tverbose_linfo(env, t, \"%d: \", t);\n\t\tverbose(env, \"jump out of range from insn %d to %d\\n\", t, w);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e == BRANCH)\n\t\t/* mark branch target for state pruning */\n\t\tinit_explored_state(env, w);\n\n\tif (insn_state[w] == 0) {\n\t\t/* tree-edge */\n\t\tinsn_state[t] = DISCOVERED | e;\n\t\tinsn_state[w] = DISCOVERED;\n\t\tif (env->cfg.cur_stack >= env->prog->len)\n\t\t\treturn -E2BIG;\n\t\tinsn_stack[env->cfg.cur_stack++] = w;\n\t\treturn KEEP_EXPLORING;\n\t} else if ((insn_state[w] & 0xF0) == DISCOVERED) {\n\t\tif (loop_ok && env->bpf_capable)\n\t\t\treturn DONE_EXPLORING;\n\t\tverbose_linfo(env, t, \"%d: \", t);\n\t\tverbose_linfo(env, w, \"%d: \", w);\n\t\tverbose(env, \"back-edge from insn %d to %d\\n\", t, w);\n\t\treturn -EINVAL;\n\t} else if (insn_state[w] == EXPLORED) {\n\t\t/* forward- or cross-edge */\n\t\tinsn_state[t] = DISCOVERED | e;\n\t} else {\n\t\tverbose(env, \"insn state internal bug\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn DONE_EXPLORING;\n}\n\nstatic int visit_func_call_insn(int t, int insn_cnt,\n\t\t\t\tstruct bpf_insn *insns,\n\t\t\t\tstruct bpf_verifier_env *env,\n\t\t\t\tbool visit_callee)\n{\n\tint ret;\n\n\tret = push_insn(t, t + 1, FALLTHROUGH, env, false);\n\tif (ret)\n\t\treturn ret;\n\n\tif (t + 1 < insn_cnt)\n\t\tinit_explored_state(env, t + 1);\n\tif (visit_callee) {\n\t\tinit_explored_state(env, t);\n\t\tret = push_insn(t, t + insns[t].imm + 1, BRANCH,\n\t\t\t\tenv, false);\n\t}\n\treturn ret;\n}\n\n/* Visits the instruction at index t and returns one of the following:\n *  < 0 - an error occurred\n *  DONE_EXPLORING - the instruction was fully explored\n *  KEEP_EXPLORING - there is still work to be done before it is fully explored\n */\nstatic int visit_insn(int t, int insn_cnt, struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn *insns = env->prog->insnsi;\n\tint ret;\n\n\tif (bpf_pseudo_func(insns + t))\n\t\treturn visit_func_call_insn(t, insn_cnt, insns, env, true);\n\n\t/* All non-branch instructions have a single fall-through edge. */\n\tif (BPF_CLASS(insns[t].code) != BPF_JMP &&\n\t    BPF_CLASS(insns[t].code) != BPF_JMP32)\n\t\treturn push_insn(t, t + 1, FALLTHROUGH, env, false);\n\n\tswitch (BPF_OP(insns[t].code)) {\n\tcase BPF_EXIT:\n\t\treturn DONE_EXPLORING;\n\n\tcase BPF_CALL:\n\t\treturn visit_func_call_insn(t, insn_cnt, insns, env,\n\t\t\t\t\t    insns[t].src_reg == BPF_PSEUDO_CALL);\n\n\tcase BPF_JA:\n\t\tif (BPF_SRC(insns[t].code) != BPF_K)\n\t\t\treturn -EINVAL;\n\n\t\t/* unconditional jump with single edge */\n\t\tret = push_insn(t, t + insns[t].off + 1, FALLTHROUGH, env,\n\t\t\t\ttrue);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* unconditional jmp is not a good pruning point,\n\t\t * but it's marked, since backtracking needs\n\t\t * to record jmp history in is_state_visited().\n\t\t */\n\t\tinit_explored_state(env, t + insns[t].off + 1);\n\t\t/* tell verifier to check for equivalent states\n\t\t * after every call and jump\n\t\t */\n\t\tif (t + 1 < insn_cnt)\n\t\t\tinit_explored_state(env, t + 1);\n\n\t\treturn ret;\n\n\tdefault:\n\t\t/* conditional jump with two edges */\n\t\tinit_explored_state(env, t);\n\t\tret = push_insn(t, t + 1, FALLTHROUGH, env, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn push_insn(t, t + insns[t].off + 1, BRANCH, env, true);\n\t}\n}\n\n/* non-recursive depth-first-search to detect loops in BPF program\n * loop == back-edge in directed graph\n */\nstatic int check_cfg(struct bpf_verifier_env *env)\n{\n\tint insn_cnt = env->prog->len;\n\tint *insn_stack, *insn_state;\n\tint ret = 0;\n\tint i;\n\n\tinsn_state = env->cfg.insn_state = kvcalloc(insn_cnt, sizeof(int), GFP_KERNEL);\n\tif (!insn_state)\n\t\treturn -ENOMEM;\n\n\tinsn_stack = env->cfg.insn_stack = kvcalloc(insn_cnt, sizeof(int), GFP_KERNEL);\n\tif (!insn_stack) {\n\t\tkvfree(insn_state);\n\t\treturn -ENOMEM;\n\t}\n\n\tinsn_state[0] = DISCOVERED; /* mark 1st insn as discovered */\n\tinsn_stack[0] = 0; /* 0 is the first instruction */\n\tenv->cfg.cur_stack = 1;\n\n\twhile (env->cfg.cur_stack > 0) {\n\t\tint t = insn_stack[env->cfg.cur_stack - 1];\n\n\t\tret = visit_insn(t, insn_cnt, env);\n\t\tswitch (ret) {\n\t\tcase DONE_EXPLORING:\n\t\t\tinsn_state[t] = EXPLORED;\n\t\t\tenv->cfg.cur_stack--;\n\t\t\tbreak;\n\t\tcase KEEP_EXPLORING:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ret > 0) {\n\t\t\t\tverbose(env, \"visit_insn internal bug\\n\");\n\t\t\t\tret = -EFAULT;\n\t\t\t}\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\n\tif (env->cfg.cur_stack < 0) {\n\t\tverbose(env, \"pop stack internal bug\\n\");\n\t\tret = -EFAULT;\n\t\tgoto err_free;\n\t}\n\n\tfor (i = 0; i < insn_cnt; i++) {\n\t\tif (insn_state[i] != EXPLORED) {\n\t\t\tverbose(env, \"unreachable insn %d\\n\", i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\tret = 0; /* cfg looks good */\n\nerr_free:\n\tkvfree(insn_state);\n\tkvfree(insn_stack);\n\tenv->cfg.insn_state = env->cfg.insn_stack = NULL;\n\treturn ret;\n}\n\nstatic int check_abnormal_return(struct bpf_verifier_env *env)\n{\n\tint i;\n\n\tfor (i = 1; i < env->subprog_cnt; i++) {\n\t\tif (env->subprog_info[i].has_ld_abs) {\n\t\t\tverbose(env, \"LD_ABS is not allowed in subprogs without BTF\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (env->subprog_info[i].has_tail_call) {\n\t\t\tverbose(env, \"tail_call is not allowed in subprogs without BTF\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* The minimum supported BTF func info size */\n#define MIN_BPF_FUNCINFO_SIZE\t8\n#define MAX_FUNCINFO_REC_SIZE\t252\n\nstatic int check_btf_func(struct bpf_verifier_env *env,\n\t\t\t  const union bpf_attr *attr,\n\t\t\t  union bpf_attr __user *uattr)\n{\n\tconst struct btf_type *type, *func_proto, *ret_type;\n\tu32 i, nfuncs, urec_size, min_size;\n\tu32 krec_size = sizeof(struct bpf_func_info);\n\tstruct bpf_func_info *krecord;\n\tstruct bpf_func_info_aux *info_aux = NULL;\n\tstruct bpf_prog *prog;\n\tconst struct btf *btf;\n\tvoid __user *urecord;\n\tu32 prev_offset = 0;\n\tbool scalar_return;\n\tint ret = -ENOMEM;\n\n\tnfuncs = attr->func_info_cnt;\n\tif (!nfuncs) {\n\t\tif (check_abnormal_return(env))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\tif (nfuncs != env->subprog_cnt) {\n\t\tverbose(env, \"number of funcs in func_info doesn't match number of subprogs\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\turec_size = attr->func_info_rec_size;\n\tif (urec_size < MIN_BPF_FUNCINFO_SIZE ||\n\t    urec_size > MAX_FUNCINFO_REC_SIZE ||\n\t    urec_size % sizeof(u32)) {\n\t\tverbose(env, \"invalid func info rec size %u\\n\", urec_size);\n\t\treturn -EINVAL;\n\t}\n\n\tprog = env->prog;\n\tbtf = prog->aux->btf;\n\n\turecord = u64_to_user_ptr(attr->func_info);\n\tmin_size = min_t(u32, krec_size, urec_size);\n\n\tkrecord = kvcalloc(nfuncs, krec_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!krecord)\n\t\treturn -ENOMEM;\n\tinfo_aux = kcalloc(nfuncs, sizeof(*info_aux), GFP_KERNEL | __GFP_NOWARN);\n\tif (!info_aux)\n\t\tgoto err_free;\n\n\tfor (i = 0; i < nfuncs; i++) {\n\t\tret = bpf_check_uarg_tail_zero(urecord, krec_size, urec_size);\n\t\tif (ret) {\n\t\t\tif (ret == -E2BIG) {\n\t\t\t\tverbose(env, \"nonzero tailing record in func info\");\n\t\t\t\t/* set the size kernel expects so loader can zero\n\t\t\t\t * out the rest of the record.\n\t\t\t\t */\n\t\t\t\tif (put_user(min_size, &uattr->func_info_rec_size))\n\t\t\t\t\tret = -EFAULT;\n\t\t\t}\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (copy_from_user(&krecord[i], urecord, min_size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* check insn_off */\n\t\tret = -EINVAL;\n\t\tif (i == 0) {\n\t\t\tif (krecord[i].insn_off) {\n\t\t\t\tverbose(env,\n\t\t\t\t\t\"nonzero insn_off %u for the first func info record\",\n\t\t\t\t\tkrecord[i].insn_off);\n\t\t\t\tgoto err_free;\n\t\t\t}\n\t\t} else if (krecord[i].insn_off <= prev_offset) {\n\t\t\tverbose(env,\n\t\t\t\t\"same or smaller insn offset (%u) than previous func info record (%u)\",\n\t\t\t\tkrecord[i].insn_off, prev_offset);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (env->subprog_info[i].start != krecord[i].insn_off) {\n\t\t\tverbose(env, \"func_info BTF section doesn't match subprog layout in BPF program\\n\");\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* check type_id */\n\t\ttype = btf_type_by_id(btf, krecord[i].type_id);\n\t\tif (!type || !btf_type_is_func(type)) {\n\t\t\tverbose(env, \"invalid type id %d in func info\",\n\t\t\t\tkrecord[i].type_id);\n\t\t\tgoto err_free;\n\t\t}\n\t\tinfo_aux[i].linkage = BTF_INFO_VLEN(type->info);\n\n\t\tfunc_proto = btf_type_by_id(btf, type->type);\n\t\tif (unlikely(!func_proto || !btf_type_is_func_proto(func_proto)))\n\t\t\t/* btf_func_check() already verified it during BTF load */\n\t\t\tgoto err_free;\n\t\tret_type = btf_type_skip_modifiers(btf, func_proto->type, NULL);\n\t\tscalar_return =\n\t\t\tbtf_type_is_small_int(ret_type) || btf_type_is_enum(ret_type);\n\t\tif (i && !scalar_return && env->subprog_info[i].has_ld_abs) {\n\t\t\tverbose(env, \"LD_ABS is only allowed in functions that return 'int'.\\n\");\n\t\t\tgoto err_free;\n\t\t}\n\t\tif (i && !scalar_return && env->subprog_info[i].has_tail_call) {\n\t\t\tverbose(env, \"tail_call is only allowed in functions that return 'int'.\\n\");\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tprev_offset = krecord[i].insn_off;\n\t\turecord += urec_size;\n\t}\n\n\tprog->aux->func_info = krecord;\n\tprog->aux->func_info_cnt = nfuncs;\n\tprog->aux->func_info_aux = info_aux;\n\treturn 0;\n\nerr_free:\n\tkvfree(krecord);\n\tkfree(info_aux);\n\treturn ret;\n}\n\nstatic void adjust_btf_func(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog_aux *aux = env->prog->aux;\n\tint i;\n\n\tif (!aux->func_info)\n\t\treturn;\n\n\tfor (i = 0; i < env->subprog_cnt; i++)\n\t\taux->func_info[i].insn_off = env->subprog_info[i].start;\n}\n\n#define MIN_BPF_LINEINFO_SIZE\t(offsetof(struct bpf_line_info, line_col) + \\\n\t\tsizeof(((struct bpf_line_info *)(0))->line_col))\n#define MAX_LINEINFO_REC_SIZE\tMAX_FUNCINFO_REC_SIZE\n\nstatic int check_btf_line(struct bpf_verifier_env *env,\n\t\t\t  const union bpf_attr *attr,\n\t\t\t  union bpf_attr __user *uattr)\n{\n\tu32 i, s, nr_linfo, ncopy, expected_size, rec_size, prev_offset = 0;\n\tstruct bpf_subprog_info *sub;\n\tstruct bpf_line_info *linfo;\n\tstruct bpf_prog *prog;\n\tconst struct btf *btf;\n\tvoid __user *ulinfo;\n\tint err;\n\n\tnr_linfo = attr->line_info_cnt;\n\tif (!nr_linfo)\n\t\treturn 0;\n\n\trec_size = attr->line_info_rec_size;\n\tif (rec_size < MIN_BPF_LINEINFO_SIZE ||\n\t    rec_size > MAX_LINEINFO_REC_SIZE ||\n\t    rec_size & (sizeof(u32) - 1))\n\t\treturn -EINVAL;\n\n\t/* Need to zero it in case the userspace may\n\t * pass in a smaller bpf_line_info object.\n\t */\n\tlinfo = kvcalloc(nr_linfo, sizeof(struct bpf_line_info),\n\t\t\t GFP_KERNEL | __GFP_NOWARN);\n\tif (!linfo)\n\t\treturn -ENOMEM;\n\n\tprog = env->prog;\n\tbtf = prog->aux->btf;\n\n\ts = 0;\n\tsub = env->subprog_info;\n\tulinfo = u64_to_user_ptr(attr->line_info);\n\texpected_size = sizeof(struct bpf_line_info);\n\tncopy = min_t(u32, expected_size, rec_size);\n\tfor (i = 0; i < nr_linfo; i++) {\n\t\terr = bpf_check_uarg_tail_zero(ulinfo, expected_size, rec_size);\n\t\tif (err) {\n\t\t\tif (err == -E2BIG) {\n\t\t\t\tverbose(env, \"nonzero tailing record in line_info\");\n\t\t\t\tif (put_user(expected_size,\n\t\t\t\t\t     &uattr->line_info_rec_size))\n\t\t\t\t\terr = -EFAULT;\n\t\t\t}\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (copy_from_user(&linfo[i], ulinfo, ncopy)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/*\n\t\t * Check insn_off to ensure\n\t\t * 1) strictly increasing AND\n\t\t * 2) bounded by prog->len\n\t\t *\n\t\t * The linfo[0].insn_off == 0 check logically falls into\n\t\t * the later \"missing bpf_line_info for func...\" case\n\t\t * because the first linfo[0].insn_off must be the\n\t\t * first sub also and the first sub must have\n\t\t * subprog_info[0].start == 0.\n\t\t */\n\t\tif ((i && linfo[i].insn_off <= prev_offset) ||\n\t\t    linfo[i].insn_off >= prog->len) {\n\t\t\tverbose(env, \"Invalid line_info[%u].insn_off:%u (prev_offset:%u prog->len:%u)\\n\",\n\t\t\t\ti, linfo[i].insn_off, prev_offset,\n\t\t\t\tprog->len);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (!prog->insnsi[linfo[i].insn_off].code) {\n\t\t\tverbose(env,\n\t\t\t\t\"Invalid insn code at line_info[%u].insn_off\\n\",\n\t\t\t\ti);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (!btf_name_by_offset(btf, linfo[i].line_off) ||\n\t\t    !btf_name_by_offset(btf, linfo[i].file_name_off)) {\n\t\t\tverbose(env, \"Invalid line_info[%u].line_off or .file_name_off\\n\", i);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (s != env->subprog_cnt) {\n\t\t\tif (linfo[i].insn_off == sub[s].start) {\n\t\t\t\tsub[s].linfo_idx = i;\n\t\t\t\ts++;\n\t\t\t} else if (sub[s].start < linfo[i].insn_off) {\n\t\t\t\tverbose(env, \"missing bpf_line_info for func#%u\\n\", s);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_free;\n\t\t\t}\n\t\t}\n\n\t\tprev_offset = linfo[i].insn_off;\n\t\tulinfo += rec_size;\n\t}\n\n\tif (s != env->subprog_cnt) {\n\t\tverbose(env, \"missing bpf_line_info for %u funcs starting from func#%u\\n\",\n\t\t\tenv->subprog_cnt - s, s);\n\t\terr = -EINVAL;\n\t\tgoto err_free;\n\t}\n\n\tprog->aux->linfo = linfo;\n\tprog->aux->nr_linfo = nr_linfo;\n\n\treturn 0;\n\nerr_free:\n\tkvfree(linfo);\n\treturn err;\n}\n\nstatic int check_btf_info(struct bpf_verifier_env *env,\n\t\t\t  const union bpf_attr *attr,\n\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct btf *btf;\n\tint err;\n\n\tif (!attr->func_info_cnt && !attr->line_info_cnt) {\n\t\tif (check_abnormal_return(env))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\tbtf = btf_get_by_fd(attr->prog_btf_fd);\n\tif (IS_ERR(btf))\n\t\treturn PTR_ERR(btf);\n\tif (btf_is_kernel(btf)) {\n\t\tbtf_put(btf);\n\t\treturn -EACCES;\n\t}\n\tenv->prog->aux->btf = btf;\n\n\terr = check_btf_func(env, attr, uattr);\n\tif (err)\n\t\treturn err;\n\n\terr = check_btf_line(env, attr, uattr);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n/* check %cur's range satisfies %old's */\nstatic bool range_within(struct bpf_reg_state *old,\n\t\t\t struct bpf_reg_state *cur)\n{\n\treturn old->umin_value <= cur->umin_value &&\n\t       old->umax_value >= cur->umax_value &&\n\t       old->smin_value <= cur->smin_value &&\n\t       old->smax_value >= cur->smax_value &&\n\t       old->u32_min_value <= cur->u32_min_value &&\n\t       old->u32_max_value >= cur->u32_max_value &&\n\t       old->s32_min_value <= cur->s32_min_value &&\n\t       old->s32_max_value >= cur->s32_max_value;\n}\n\n/* Maximum number of register states that can exist at once */\n#define ID_MAP_SIZE\t(MAX_BPF_REG + MAX_BPF_STACK / BPF_REG_SIZE)\nstruct idpair {\n\tu32 old;\n\tu32 cur;\n};\n\n/* If in the old state two registers had the same id, then they need to have\n * the same id in the new state as well.  But that id could be different from\n * the old state, so we need to track the mapping from old to new ids.\n * Once we have seen that, say, a reg with old id 5 had new id 9, any subsequent\n * regs with old id 5 must also have new id 9 for the new state to be safe.  But\n * regs with a different old id could still have new id 9, we don't care about\n * that.\n * So we look through our idmap to see if this old id has been seen before.  If\n * so, we require the new id to match; otherwise, we add the id pair to the map.\n */\nstatic bool check_ids(u32 old_id, u32 cur_id, struct idpair *idmap)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ID_MAP_SIZE; i++) {\n\t\tif (!idmap[i].old) {\n\t\t\t/* Reached an empty slot; haven't seen this id before */\n\t\t\tidmap[i].old = old_id;\n\t\t\tidmap[i].cur = cur_id;\n\t\t\treturn true;\n\t\t}\n\t\tif (idmap[i].old == old_id)\n\t\t\treturn idmap[i].cur == cur_id;\n\t}\n\t/* We ran out of idmap slots, which should be impossible */\n\tWARN_ON_ONCE(1);\n\treturn false;\n}\n\nstatic void clean_func_state(struct bpf_verifier_env *env,\n\t\t\t     struct bpf_func_state *st)\n{\n\tenum bpf_reg_liveness live;\n\tint i, j;\n\n\tfor (i = 0; i < BPF_REG_FP; i++) {\n\t\tlive = st->regs[i].live;\n\t\t/* liveness must not touch this register anymore */\n\t\tst->regs[i].live |= REG_LIVE_DONE;\n\t\tif (!(live & REG_LIVE_READ))\n\t\t\t/* since the register is unused, clear its state\n\t\t\t * to make further comparison simpler\n\t\t\t */\n\t\t\t__mark_reg_not_init(env, &st->regs[i]);\n\t}\n\n\tfor (i = 0; i < st->allocated_stack / BPF_REG_SIZE; i++) {\n\t\tlive = st->stack[i].spilled_ptr.live;\n\t\t/* liveness must not touch this stack slot anymore */\n\t\tst->stack[i].spilled_ptr.live |= REG_LIVE_DONE;\n\t\tif (!(live & REG_LIVE_READ)) {\n\t\t\t__mark_reg_not_init(env, &st->stack[i].spilled_ptr);\n\t\t\tfor (j = 0; j < BPF_REG_SIZE; j++)\n\t\t\t\tst->stack[i].slot_type[j] = STACK_INVALID;\n\t\t}\n\t}\n}\n\nstatic void clean_verifier_state(struct bpf_verifier_env *env,\n\t\t\t\t struct bpf_verifier_state *st)\n{\n\tint i;\n\n\tif (st->frame[0]->regs[0].live & REG_LIVE_DONE)\n\t\t/* all regs in this state in all frames were already marked */\n\t\treturn;\n\n\tfor (i = 0; i <= st->curframe; i++)\n\t\tclean_func_state(env, st->frame[i]);\n}\n\n/* the parentage chains form a tree.\n * the verifier states are added to state lists at given insn and\n * pushed into state stack for future exploration.\n * when the verifier reaches bpf_exit insn some of the verifer states\n * stored in the state lists have their final liveness state already,\n * but a lot of states will get revised from liveness point of view when\n * the verifier explores other branches.\n * Example:\n * 1: r0 = 1\n * 2: if r1 == 100 goto pc+1\n * 3: r0 = 2\n * 4: exit\n * when the verifier reaches exit insn the register r0 in the state list of\n * insn 2 will be seen as !REG_LIVE_READ. Then the verifier pops the other_branch\n * of insn 2 and goes exploring further. At the insn 4 it will walk the\n * parentage chain from insn 4 into insn 2 and will mark r0 as REG_LIVE_READ.\n *\n * Since the verifier pushes the branch states as it sees them while exploring\n * the program the condition of walking the branch instruction for the second\n * time means that all states below this branch were already explored and\n * their final liveness markes are already propagated.\n * Hence when the verifier completes the search of state list in is_state_visited()\n * we can call this clean_live_states() function to mark all liveness states\n * as REG_LIVE_DONE to indicate that 'parent' pointers of 'struct bpf_reg_state'\n * will not be used.\n * This function also clears the registers and stack for states that !READ\n * to simplify state merging.\n *\n * Important note here that walking the same branch instruction in the callee\n * doesn't meant that the states are DONE. The verifier has to compare\n * the callsites\n */\nstatic void clean_live_states(struct bpf_verifier_env *env, int insn,\n\t\t\t      struct bpf_verifier_state *cur)\n{\n\tstruct bpf_verifier_state_list *sl;\n\tint i;\n\n\tsl = *explored_state(env, insn);\n\twhile (sl) {\n\t\tif (sl->state.branches)\n\t\t\tgoto next;\n\t\tif (sl->state.insn_idx != insn ||\n\t\t    sl->state.curframe != cur->curframe)\n\t\t\tgoto next;\n\t\tfor (i = 0; i <= cur->curframe; i++)\n\t\t\tif (sl->state.frame[i]->callsite != cur->frame[i]->callsite)\n\t\t\t\tgoto next;\n\t\tclean_verifier_state(env, &sl->state);\nnext:\n\t\tsl = sl->next;\n\t}\n}\n\n/* Returns true if (rold safe implies rcur safe) */\nstatic bool regsafe(struct bpf_reg_state *rold, struct bpf_reg_state *rcur,\n\t\t    struct idpair *idmap)\n{\n\tbool equal;\n\n\tif (!(rold->live & REG_LIVE_READ))\n\t\t/* explored state didn't use this */\n\t\treturn true;\n\n\tequal = memcmp(rold, rcur, offsetof(struct bpf_reg_state, parent)) == 0;\n\n\tif (rold->type == PTR_TO_STACK)\n\t\t/* two stack pointers are equal only if they're pointing to\n\t\t * the same stack frame, since fp-8 in foo != fp-8 in bar\n\t\t */\n\t\treturn equal && rold->frameno == rcur->frameno;\n\n\tif (equal)\n\t\treturn true;\n\n\tif (rold->type == NOT_INIT)\n\t\t/* explored state can't have used this */\n\t\treturn true;\n\tif (rcur->type == NOT_INIT)\n\t\treturn false;\n\tswitch (rold->type) {\n\tcase SCALAR_VALUE:\n\t\tif (rcur->type == SCALAR_VALUE) {\n\t\t\tif (!rold->precise && !rcur->precise)\n\t\t\t\treturn true;\n\t\t\t/* new val must satisfy old val knowledge */\n\t\t\treturn range_within(rold, rcur) &&\n\t\t\t       tnum_in(rold->var_off, rcur->var_off);\n\t\t} else {\n\t\t\t/* We're trying to use a pointer in place of a scalar.\n\t\t\t * Even if the scalar was unbounded, this could lead to\n\t\t\t * pointer leaks because scalars are allowed to leak\n\t\t\t * while pointers are not. We could make this safe in\n\t\t\t * special cases if root is calling us, but it's\n\t\t\t * probably not worth the hassle.\n\t\t\t */\n\t\t\treturn false;\n\t\t}\n\tcase PTR_TO_MAP_KEY:\n\tcase PTR_TO_MAP_VALUE:\n\t\t/* If the new min/max/var_off satisfy the old ones and\n\t\t * everything else matches, we are OK.\n\t\t * 'id' is not compared, since it's only used for maps with\n\t\t * bpf_spin_lock inside map element and in such cases if\n\t\t * the rest of the prog is valid for one map element then\n\t\t * it's valid for all map elements regardless of the key\n\t\t * used in bpf_map_lookup()\n\t\t */\n\t\treturn memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0 &&\n\t\t       range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\t\t/* a PTR_TO_MAP_VALUE could be safe to use as a\n\t\t * PTR_TO_MAP_VALUE_OR_NULL into the same map.\n\t\t * However, if the old PTR_TO_MAP_VALUE_OR_NULL then got NULL-\n\t\t * checked, doing so could have affected others with the same\n\t\t * id, and we can't check for that because we lost the id when\n\t\t * we converted to a PTR_TO_MAP_VALUE.\n\t\t */\n\t\tif (rcur->type != PTR_TO_MAP_VALUE_OR_NULL)\n\t\t\treturn false;\n\t\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))\n\t\t\treturn false;\n\t\t/* Check our ids match any regs they're supposed to */\n\t\treturn check_ids(rold->id, rcur->id, idmap);\n\tcase PTR_TO_PACKET_META:\n\tcase PTR_TO_PACKET:\n\t\tif (rcur->type != rold->type)\n\t\t\treturn false;\n\t\t/* We must have at least as much range as the old ptr\n\t\t * did, so that any accesses which were safe before are\n\t\t * still safe.  This is true even if old range < old off,\n\t\t * since someone could have accessed through (ptr - k), or\n\t\t * even done ptr -= k in a register, to get a safe access.\n\t\t */\n\t\tif (rold->range > rcur->range)\n\t\t\treturn false;\n\t\t/* If the offsets don't match, we can't trust our alignment;\n\t\t * nor can we be sure that we won't fall out of range.\n\t\t */\n\t\tif (rold->off != rcur->off)\n\t\t\treturn false;\n\t\t/* id relations must be preserved */\n\t\tif (rold->id && !check_ids(rold->id, rcur->id, idmap))\n\t\t\treturn false;\n\t\t/* new val must satisfy old val knowledge */\n\t\treturn range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_CTX:\n\tcase CONST_PTR_TO_MAP:\n\tcase PTR_TO_PACKET_END:\n\tcase PTR_TO_FLOW_KEYS:\n\tcase PTR_TO_SOCKET:\n\tcase PTR_TO_SOCKET_OR_NULL:\n\tcase PTR_TO_SOCK_COMMON:\n\tcase PTR_TO_SOCK_COMMON_OR_NULL:\n\tcase PTR_TO_TCP_SOCK:\n\tcase PTR_TO_TCP_SOCK_OR_NULL:\n\tcase PTR_TO_XDP_SOCK:\n\t\t/* Only valid matches are exact, which memcmp() above\n\t\t * would have accepted\n\t\t */\n\tdefault:\n\t\t/* Don't know what's going on, just say it's not safe */\n\t\treturn false;\n\t}\n\n\t/* Shouldn't get here; if we do, say it's not safe */\n\tWARN_ON_ONCE(1);\n\treturn false;\n}\n\nstatic bool stacksafe(struct bpf_func_state *old,\n\t\t      struct bpf_func_state *cur,\n\t\t      struct idpair *idmap)\n{\n\tint i, spi;\n\n\t/* walk slots of the explored stack and ignore any additional\n\t * slots in the current stack, since explored(safe) state\n\t * didn't use them\n\t */\n\tfor (i = 0; i < old->allocated_stack; i++) {\n\t\tspi = i / BPF_REG_SIZE;\n\n\t\tif (!(old->stack[spi].spilled_ptr.live & REG_LIVE_READ)) {\n\t\t\ti += BPF_REG_SIZE - 1;\n\t\t\t/* explored state didn't use this */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (old->stack[spi].slot_type[i % BPF_REG_SIZE] == STACK_INVALID)\n\t\t\tcontinue;\n\n\t\t/* explored stack has more populated slots than current stack\n\t\t * and these slots were used\n\t\t */\n\t\tif (i >= cur->allocated_stack)\n\t\t\treturn false;\n\n\t\t/* if old state was safe with misc data in the stack\n\t\t * it will be safe with zero-initialized stack.\n\t\t * The opposite is not true\n\t\t */\n\t\tif (old->stack[spi].slot_type[i % BPF_REG_SIZE] == STACK_MISC &&\n\t\t    cur->stack[spi].slot_type[i % BPF_REG_SIZE] == STACK_ZERO)\n\t\t\tcontinue;\n\t\tif (old->stack[spi].slot_type[i % BPF_REG_SIZE] !=\n\t\t    cur->stack[spi].slot_type[i % BPF_REG_SIZE])\n\t\t\t/* Ex: old explored (safe) state has STACK_SPILL in\n\t\t\t * this stack slot, but current has STACK_MISC ->\n\t\t\t * this verifier states are not equivalent,\n\t\t\t * return false to continue verification of this path\n\t\t\t */\n\t\t\treturn false;\n\t\tif (i % BPF_REG_SIZE)\n\t\t\tcontinue;\n\t\tif (old->stack[spi].slot_type[0] != STACK_SPILL)\n\t\t\tcontinue;\n\t\tif (!regsafe(&old->stack[spi].spilled_ptr,\n\t\t\t     &cur->stack[spi].spilled_ptr,\n\t\t\t     idmap))\n\t\t\t/* when explored and current stack slot are both storing\n\t\t\t * spilled registers, check that stored pointers types\n\t\t\t * are the same as well.\n\t\t\t * Ex: explored safe path could have stored\n\t\t\t * (bpf_reg_state) {.type = PTR_TO_STACK, .off = -8}\n\t\t\t * but current path has stored:\n\t\t\t * (bpf_reg_state) {.type = PTR_TO_STACK, .off = -16}\n\t\t\t * such verifier states are not equivalent.\n\t\t\t * return false to continue verification of this path\n\t\t\t */\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool refsafe(struct bpf_func_state *old, struct bpf_func_state *cur)\n{\n\tif (old->acquired_refs != cur->acquired_refs)\n\t\treturn false;\n\treturn !memcmp(old->refs, cur->refs,\n\t\t       sizeof(*old->refs) * old->acquired_refs);\n}\n\n/* compare two verifier states\n *\n * all states stored in state_list are known to be valid, since\n * verifier reached 'bpf_exit' instruction through them\n *\n * this function is called when verifier exploring different branches of\n * execution popped from the state stack. If it sees an old state that has\n * more strict register state and more strict stack state then this execution\n * branch doesn't need to be explored further, since verifier already\n * concluded that more strict state leads to valid finish.\n *\n * Therefore two states are equivalent if register state is more conservative\n * and explored stack state is more conservative than the current one.\n * Example:\n *       explored                   current\n * (slot1=INV slot2=MISC) == (slot1=MISC slot2=MISC)\n * (slot1=MISC slot2=MISC) != (slot1=INV slot2=MISC)\n *\n * In other words if current stack state (one being explored) has more\n * valid slots than old one that already passed validation, it means\n * the verifier can stop exploring and conclude that current state is valid too\n *\n * Similarly with registers. If explored state has register type as invalid\n * whereas register type in current state is meaningful, it means that\n * the current state will reach 'bpf_exit' instruction safely\n */\nstatic bool func_states_equal(struct bpf_func_state *old,\n\t\t\t      struct bpf_func_state *cur)\n{\n\tstruct idpair *idmap;\n\tbool ret = false;\n\tint i;\n\n\tidmap = kcalloc(ID_MAP_SIZE, sizeof(struct idpair), GFP_KERNEL);\n\t/* If we failed to allocate the idmap, just say it's not safe */\n\tif (!idmap)\n\t\treturn false;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\tif (!regsafe(&old->regs[i], &cur->regs[i], idmap))\n\t\t\tgoto out_free;\n\t}\n\n\tif (!stacksafe(old, cur, idmap))\n\t\tgoto out_free;\n\n\tif (!refsafe(old, cur))\n\t\tgoto out_free;\n\tret = true;\nout_free:\n\tkfree(idmap);\n\treturn ret;\n}\n\nstatic bool states_equal(struct bpf_verifier_env *env,\n\t\t\t struct bpf_verifier_state *old,\n\t\t\t struct bpf_verifier_state *cur)\n{\n\tint i;\n\n\tif (old->curframe != cur->curframe)\n\t\treturn false;\n\n\t/* Verification state from speculative execution simulation\n\t * must never prune a non-speculative execution one.\n\t */\n\tif (old->speculative && !cur->speculative)\n\t\treturn false;\n\n\tif (old->active_spin_lock != cur->active_spin_lock)\n\t\treturn false;\n\n\t/* for states to be equal callsites have to be the same\n\t * and all frame states need to be equivalent\n\t */\n\tfor (i = 0; i <= old->curframe; i++) {\n\t\tif (old->frame[i]->callsite != cur->frame[i]->callsite)\n\t\t\treturn false;\n\t\tif (!func_states_equal(old->frame[i], cur->frame[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n/* Return 0 if no propagation happened. Return negative error code if error\n * happened. Otherwise, return the propagated bit.\n */\nstatic int propagate_liveness_reg(struct bpf_verifier_env *env,\n\t\t\t\t  struct bpf_reg_state *reg,\n\t\t\t\t  struct bpf_reg_state *parent_reg)\n{\n\tu8 parent_flag = parent_reg->live & REG_LIVE_READ;\n\tu8 flag = reg->live & REG_LIVE_READ;\n\tint err;\n\n\t/* When comes here, read flags of PARENT_REG or REG could be any of\n\t * REG_LIVE_READ64, REG_LIVE_READ32, REG_LIVE_NONE. There is no need\n\t * of propagation if PARENT_REG has strongest REG_LIVE_READ64.\n\t */\n\tif (parent_flag == REG_LIVE_READ64 ||\n\t    /* Or if there is no read flag from REG. */\n\t    !flag ||\n\t    /* Or if the read flag from REG is the same as PARENT_REG. */\n\t    parent_flag == flag)\n\t\treturn 0;\n\n\terr = mark_reg_read(env, reg, parent_reg, flag);\n\tif (err)\n\t\treturn err;\n\n\treturn flag;\n}\n\n/* A write screens off any subsequent reads; but write marks come from the\n * straight-line code between a state and its parent.  When we arrive at an\n * equivalent state (jump target or such) we didn't arrive by the straight-line\n * code, so read marks in the state must propagate to the parent regardless\n * of the state's write marks. That's what 'parent == state->parent' comparison\n * in mark_reg_read() is for.\n */\nstatic int propagate_liveness(struct bpf_verifier_env *env,\n\t\t\t      const struct bpf_verifier_state *vstate,\n\t\t\t      struct bpf_verifier_state *vparent)\n{\n\tstruct bpf_reg_state *state_reg, *parent_reg;\n\tstruct bpf_func_state *state, *parent;\n\tint i, frame, err = 0;\n\n\tif (vparent->curframe != vstate->curframe) {\n\t\tWARN(1, \"propagate_live: parent frame %d current frame %d\\n\",\n\t\t     vparent->curframe, vstate->curframe);\n\t\treturn -EFAULT;\n\t}\n\t/* Propagate read liveness of registers... */\n\tBUILD_BUG_ON(BPF_REG_FP + 1 != MAX_BPF_REG);\n\tfor (frame = 0; frame <= vstate->curframe; frame++) {\n\t\tparent = vparent->frame[frame];\n\t\tstate = vstate->frame[frame];\n\t\tparent_reg = parent->regs;\n\t\tstate_reg = state->regs;\n\t\t/* We don't need to worry about FP liveness, it's read-only */\n\t\tfor (i = frame < vstate->curframe ? BPF_REG_6 : 0; i < BPF_REG_FP; i++) {\n\t\t\terr = propagate_liveness_reg(env, &state_reg[i],\n\t\t\t\t\t\t     &parent_reg[i]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err == REG_LIVE_READ64)\n\t\t\t\tmark_insn_zext(env, &parent_reg[i]);\n\t\t}\n\n\t\t/* Propagate stack slots. */\n\t\tfor (i = 0; i < state->allocated_stack / BPF_REG_SIZE &&\n\t\t\t    i < parent->allocated_stack / BPF_REG_SIZE; i++) {\n\t\t\tparent_reg = &parent->stack[i].spilled_ptr;\n\t\t\tstate_reg = &state->stack[i].spilled_ptr;\n\t\t\terr = propagate_liveness_reg(env, state_reg,\n\t\t\t\t\t\t     parent_reg);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* find precise scalars in the previous equivalent state and\n * propagate them into the current state\n */\nstatic int propagate_precision(struct bpf_verifier_env *env,\n\t\t\t       const struct bpf_verifier_state *old)\n{\n\tstruct bpf_reg_state *state_reg;\n\tstruct bpf_func_state *state;\n\tint i, err = 0;\n\n\tstate = old->frame[old->curframe];\n\tstate_reg = state->regs;\n\tfor (i = 0; i < BPF_REG_FP; i++, state_reg++) {\n\t\tif (state_reg->type != SCALAR_VALUE ||\n\t\t    !state_reg->precise)\n\t\t\tcontinue;\n\t\tif (env->log.level & BPF_LOG_LEVEL2)\n\t\t\tverbose(env, \"propagating r%d\\n\", i);\n\t\terr = mark_chain_precision(env, i);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < state->allocated_stack / BPF_REG_SIZE; i++) {\n\t\tif (state->stack[i].slot_type[0] != STACK_SPILL)\n\t\t\tcontinue;\n\t\tstate_reg = &state->stack[i].spilled_ptr;\n\t\tif (state_reg->type != SCALAR_VALUE ||\n\t\t    !state_reg->precise)\n\t\t\tcontinue;\n\t\tif (env->log.level & BPF_LOG_LEVEL2)\n\t\t\tverbose(env, \"propagating fp%d\\n\",\n\t\t\t\t(-i - 1) * BPF_REG_SIZE);\n\t\terr = mark_chain_precision_stack(env, i);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic bool states_maybe_looping(struct bpf_verifier_state *old,\n\t\t\t\t struct bpf_verifier_state *cur)\n{\n\tstruct bpf_func_state *fold, *fcur;\n\tint i, fr = cur->curframe;\n\n\tif (old->curframe != fr)\n\t\treturn false;\n\n\tfold = old->frame[fr];\n\tfcur = cur->frame[fr];\n\tfor (i = 0; i < MAX_BPF_REG; i++)\n\t\tif (memcmp(&fold->regs[i], &fcur->regs[i],\n\t\t\t   offsetof(struct bpf_reg_state, parent)))\n\t\t\treturn false;\n\treturn true;\n}\n\n\nstatic int is_state_visited(struct bpf_verifier_env *env, int insn_idx)\n{\n\tstruct bpf_verifier_state_list *new_sl;\n\tstruct bpf_verifier_state_list *sl, **pprev;\n\tstruct bpf_verifier_state *cur = env->cur_state, *new;\n\tint i, j, err, states_cnt = 0;\n\tbool add_new_state = env->test_state_freq ? true : false;\n\n\tcur->last_insn_idx = env->prev_insn_idx;\n\tif (!env->insn_aux_data[insn_idx].prune_point)\n\t\t/* this 'insn_idx' instruction wasn't marked, so we will not\n\t\t * be doing state search here\n\t\t */\n\t\treturn 0;\n\n\t/* bpf progs typically have pruning point every 4 instructions\n\t * http://vger.kernel.org/bpfconf2019.html#session-1\n\t * Do not add new state for future pruning if the verifier hasn't seen\n\t * at least 2 jumps and at least 8 instructions.\n\t * This heuristics helps decrease 'total_states' and 'peak_states' metric.\n\t * In tests that amounts to up to 50% reduction into total verifier\n\t * memory consumption and 20% verifier time speedup.\n\t */\n\tif (env->jmps_processed - env->prev_jmps_processed >= 2 &&\n\t    env->insn_processed - env->prev_insn_processed >= 8)\n\t\tadd_new_state = true;\n\n\tpprev = explored_state(env, insn_idx);\n\tsl = *pprev;\n\n\tclean_live_states(env, insn_idx, cur);\n\n\twhile (sl) {\n\t\tstates_cnt++;\n\t\tif (sl->state.insn_idx != insn_idx)\n\t\t\tgoto next;\n\t\tif (sl->state.branches) {\n\t\t\tif (states_maybe_looping(&sl->state, cur) &&\n\t\t\t    states_equal(env, &sl->state, cur)) {\n\t\t\t\tverbose_linfo(env, insn_idx, \"; \");\n\t\t\t\tverbose(env, \"infinite loop detected at insn %d\\n\", insn_idx);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* if the verifier is processing a loop, avoid adding new state\n\t\t\t * too often, since different loop iterations have distinct\n\t\t\t * states and may not help future pruning.\n\t\t\t * This threshold shouldn't be too low to make sure that\n\t\t\t * a loop with large bound will be rejected quickly.\n\t\t\t * The most abusive loop will be:\n\t\t\t * r1 += 1\n\t\t\t * if r1 < 1000000 goto pc-2\n\t\t\t * 1M insn_procssed limit / 100 == 10k peak states.\n\t\t\t * This threshold shouldn't be too high either, since states\n\t\t\t * at the end of the loop are likely to be useful in pruning.\n\t\t\t */\n\t\t\tif (env->jmps_processed - env->prev_jmps_processed < 20 &&\n\t\t\t    env->insn_processed - env->prev_insn_processed < 100)\n\t\t\t\tadd_new_state = false;\n\t\t\tgoto miss;\n\t\t}\n\t\tif (states_equal(env, &sl->state, cur)) {\n\t\t\tsl->hit_cnt++;\n\t\t\t/* reached equivalent register/stack state,\n\t\t\t * prune the search.\n\t\t\t * Registers read by the continuation are read by us.\n\t\t\t * If we have any write marks in env->cur_state, they\n\t\t\t * will prevent corresponding reads in the continuation\n\t\t\t * from reaching our parent (an explored_state).  Our\n\t\t\t * own state will get the read marks recorded, but\n\t\t\t * they'll be immediately forgotten as we're pruning\n\t\t\t * this state and will pop a new one.\n\t\t\t */\n\t\t\terr = propagate_liveness(env, &sl->state, cur);\n\n\t\t\t/* if previous state reached the exit with precision and\n\t\t\t * current state is equivalent to it (except precsion marks)\n\t\t\t * the precision needs to be propagated back in\n\t\t\t * the current state.\n\t\t\t */\n\t\t\terr = err ? : push_jmp_history(env, cur);\n\t\t\terr = err ? : propagate_precision(env, &sl->state);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\treturn 1;\n\t\t}\nmiss:\n\t\t/* when new state is not going to be added do not increase miss count.\n\t\t * Otherwise several loop iterations will remove the state\n\t\t * recorded earlier. The goal of these heuristics is to have\n\t\t * states from some iterations of the loop (some in the beginning\n\t\t * and some at the end) to help pruning.\n\t\t */\n\t\tif (add_new_state)\n\t\t\tsl->miss_cnt++;\n\t\t/* heuristic to determine whether this state is beneficial\n\t\t * to keep checking from state equivalence point of view.\n\t\t * Higher numbers increase max_states_per_insn and verification time,\n\t\t * but do not meaningfully decrease insn_processed.\n\t\t */\n\t\tif (sl->miss_cnt > sl->hit_cnt * 3 + 3) {\n\t\t\t/* the state is unlikely to be useful. Remove it to\n\t\t\t * speed up verification\n\t\t\t */\n\t\t\t*pprev = sl->next;\n\t\t\tif (sl->state.frame[0]->regs[0].live & REG_LIVE_DONE) {\n\t\t\t\tu32 br = sl->state.branches;\n\n\t\t\t\tWARN_ONCE(br,\n\t\t\t\t\t  \"BUG live_done but branches_to_explore %d\\n\",\n\t\t\t\t\t  br);\n\t\t\t\tfree_verifier_state(&sl->state, false);\n\t\t\t\tkfree(sl);\n\t\t\t\tenv->peak_states--;\n\t\t\t} else {\n\t\t\t\t/* cannot free this state, since parentage chain may\n\t\t\t\t * walk it later. Add it for free_list instead to\n\t\t\t\t * be freed at the end of verification\n\t\t\t\t */\n\t\t\t\tsl->next = env->free_list;\n\t\t\t\tenv->free_list = sl;\n\t\t\t}\n\t\t\tsl = *pprev;\n\t\t\tcontinue;\n\t\t}\nnext:\n\t\tpprev = &sl->next;\n\t\tsl = *pprev;\n\t}\n\n\tif (env->max_states_per_insn < states_cnt)\n\t\tenv->max_states_per_insn = states_cnt;\n\n\tif (!env->bpf_capable && states_cnt > BPF_COMPLEXITY_LIMIT_STATES)\n\t\treturn push_jmp_history(env, cur);\n\n\tif (!add_new_state)\n\t\treturn push_jmp_history(env, cur);\n\n\t/* There were no equivalent states, remember the current one.\n\t * Technically the current state is not proven to be safe yet,\n\t * but it will either reach outer most bpf_exit (which means it's safe)\n\t * or it will be rejected. When there are no loops the verifier won't be\n\t * seeing this tuple (frame[0].callsite, frame[1].callsite, .. insn_idx)\n\t * again on the way to bpf_exit.\n\t * When looping the sl->state.branches will be > 0 and this state\n\t * will not be considered for equivalence until branches == 0.\n\t */\n\tnew_sl = kzalloc(sizeof(struct bpf_verifier_state_list), GFP_KERNEL);\n\tif (!new_sl)\n\t\treturn -ENOMEM;\n\tenv->total_states++;\n\tenv->peak_states++;\n\tenv->prev_jmps_processed = env->jmps_processed;\n\tenv->prev_insn_processed = env->insn_processed;\n\n\t/* add new state to the head of linked list */\n\tnew = &new_sl->state;\n\terr = copy_verifier_state(new, cur);\n\tif (err) {\n\t\tfree_verifier_state(new, false);\n\t\tkfree(new_sl);\n\t\treturn err;\n\t}\n\tnew->insn_idx = insn_idx;\n\tWARN_ONCE(new->branches != 1,\n\t\t  \"BUG is_state_visited:branches_to_explore=%d insn %d\\n\", new->branches, insn_idx);\n\n\tcur->parent = new;\n\tcur->first_insn_idx = insn_idx;\n\tclear_jmp_history(cur);\n\tnew_sl->next = *explored_state(env, insn_idx);\n\t*explored_state(env, insn_idx) = new_sl;\n\t/* connect new state to parentage chain. Current frame needs all\n\t * registers connected. Only r6 - r9 of the callers are alive (pushed\n\t * to the stack implicitly by JITs) so in callers' frames connect just\n\t * r6 - r9 as an optimization. Callers will have r1 - r5 connected to\n\t * the state of the call instruction (with WRITTEN set), and r0 comes\n\t * from callee with its full parentage chain, anyway.\n\t */\n\t/* clear write marks in current state: the writes we did are not writes\n\t * our child did, so they don't screen off its reads from us.\n\t * (There are no read marks in current state, because reads always mark\n\t * their parent and current state never has children yet.  Only\n\t * explored_states can get read marks.)\n\t */\n\tfor (j = 0; j <= cur->curframe; j++) {\n\t\tfor (i = j < cur->curframe ? BPF_REG_6 : 0; i < BPF_REG_FP; i++)\n\t\t\tcur->frame[j]->regs[i].parent = &new->frame[j]->regs[i];\n\t\tfor (i = 0; i < BPF_REG_FP; i++)\n\t\t\tcur->frame[j]->regs[i].live = REG_LIVE_NONE;\n\t}\n\n\t/* all stack frames are accessible from callee, clear them all */\n\tfor (j = 0; j <= cur->curframe; j++) {\n\t\tstruct bpf_func_state *frame = cur->frame[j];\n\t\tstruct bpf_func_state *newframe = new->frame[j];\n\n\t\tfor (i = 0; i < frame->allocated_stack / BPF_REG_SIZE; i++) {\n\t\t\tframe->stack[i].spilled_ptr.live = REG_LIVE_NONE;\n\t\t\tframe->stack[i].spilled_ptr.parent =\n\t\t\t\t\t\t&newframe->stack[i].spilled_ptr;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* Return true if it's OK to have the same insn return a different type. */\nstatic bool reg_type_mismatch_ok(enum bpf_reg_type type)\n{\n\tswitch (type) {\n\tcase PTR_TO_CTX:\n\tcase PTR_TO_SOCKET:\n\tcase PTR_TO_SOCKET_OR_NULL:\n\tcase PTR_TO_SOCK_COMMON:\n\tcase PTR_TO_SOCK_COMMON_OR_NULL:\n\tcase PTR_TO_TCP_SOCK:\n\tcase PTR_TO_TCP_SOCK_OR_NULL:\n\tcase PTR_TO_XDP_SOCK:\n\tcase PTR_TO_BTF_ID:\n\tcase PTR_TO_BTF_ID_OR_NULL:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\n/* If an instruction was previously used with particular pointer types, then we\n * need to be careful to avoid cases such as the below, where it may be ok\n * for one branch accessing the pointer, but not ok for the other branch:\n *\n * R1 = sock_ptr\n * goto X;\n * ...\n * R1 = some_other_valid_ptr;\n * goto X;\n * ...\n * R2 = *(u32 *)(R1 + 0);\n */\nstatic bool reg_type_mismatch(enum bpf_reg_type src, enum bpf_reg_type prev)\n{\n\treturn src != prev && (!reg_type_mismatch_ok(src) ||\n\t\t\t       !reg_type_mismatch_ok(prev));\n}\n\nstatic int do_check(struct bpf_verifier_env *env)\n{\n\tbool pop_log = !(env->log.level & BPF_LOG_LEVEL2);\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_insn *insns = env->prog->insnsi;\n\tstruct bpf_reg_state *regs;\n\tint insn_cnt = env->prog->len;\n\tbool do_print_state = false;\n\tint prev_insn_idx = -1;\n\n\tfor (;;) {\n\t\tstruct bpf_insn *insn;\n\t\tu8 class;\n\t\tint err;\n\n\t\tenv->prev_insn_idx = prev_insn_idx;\n\t\tif (env->insn_idx >= insn_cnt) {\n\t\t\tverbose(env, \"invalid insn idx %d insn_cnt %d\\n\",\n\t\t\t\tenv->insn_idx, insn_cnt);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tinsn = &insns[env->insn_idx];\n\t\tclass = BPF_CLASS(insn->code);\n\n\t\tif (++env->insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {\n\t\t\tverbose(env,\n\t\t\t\t\"BPF program is too large. Processed %d insn\\n\",\n\t\t\t\tenv->insn_processed);\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\terr = is_state_visited(env, env->insn_idx);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (err == 1) {\n\t\t\t/* found equivalent state, can prune the search */\n\t\t\tif (env->log.level & BPF_LOG_LEVEL) {\n\t\t\t\tif (do_print_state)\n\t\t\t\t\tverbose(env, \"\\nfrom %d to %d%s: safe\\n\",\n\t\t\t\t\t\tenv->prev_insn_idx, env->insn_idx,\n\t\t\t\t\t\tenv->cur_state->speculative ?\n\t\t\t\t\t\t\" (speculative execution)\" : \"\");\n\t\t\t\telse\n\t\t\t\t\tverbose(env, \"%d: safe\\n\", env->insn_idx);\n\t\t\t}\n\t\t\tgoto process_bpf_exit;\n\t\t}\n\n\t\tif (signal_pending(current))\n\t\t\treturn -EAGAIN;\n\n\t\tif (need_resched())\n\t\t\tcond_resched();\n\n\t\tif (env->log.level & BPF_LOG_LEVEL2 ||\n\t\t    (env->log.level & BPF_LOG_LEVEL && do_print_state)) {\n\t\t\tif (env->log.level & BPF_LOG_LEVEL2)\n\t\t\t\tverbose(env, \"%d:\", env->insn_idx);\n\t\t\telse\n\t\t\t\tverbose(env, \"\\nfrom %d to %d%s:\",\n\t\t\t\t\tenv->prev_insn_idx, env->insn_idx,\n\t\t\t\t\tenv->cur_state->speculative ?\n\t\t\t\t\t\" (speculative execution)\" : \"\");\n\t\t\tprint_verifier_state(env, state->frame[state->curframe]);\n\t\t\tdo_print_state = false;\n\t\t}\n\n\t\tif (env->log.level & BPF_LOG_LEVEL) {\n\t\t\tconst struct bpf_insn_cbs cbs = {\n\t\t\t\t.cb_print\t= verbose,\n\t\t\t\t.private_data\t= env,\n\t\t\t};\n\n\t\t\tverbose_linfo(env, env->insn_idx, \"; \");\n\t\t\tverbose(env, \"%d: \", env->insn_idx);\n\t\t\tprint_bpf_insn(&cbs, insn, env->allow_ptr_leaks);\n\t\t}\n\n\t\tif (bpf_prog_is_dev_bound(env->prog->aux)) {\n\t\t\terr = bpf_prog_offload_verify_insn(env, env->insn_idx,\n\t\t\t\t\t\t\t   env->prev_insn_idx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tregs = cur_regs(env);\n\t\tenv->insn_aux_data[env->insn_idx].seen = env->pass_cnt;\n\t\tprev_insn_idx = env->insn_idx;\n\n\t\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\t\terr = check_alu_op(env, insn);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_LDX) {\n\t\t\tenum bpf_reg_type *prev_src_type, src_reg_type;\n\n\t\t\t/* check for reserved fields is already done */\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tsrc_reg_type = regs[insn->src_reg].type;\n\n\t\t\t/* check that memory (src_reg + off) is readable,\n\t\t\t * the state of dst_reg will be updated by this func\n\t\t\t */\n\t\t\terr = check_mem_access(env, env->insn_idx, insn->src_reg,\n\t\t\t\t\t       insn->off, BPF_SIZE(insn->code),\n\t\t\t\t\t       BPF_READ, insn->dst_reg, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tprev_src_type = &env->insn_aux_data[env->insn_idx].ptr_type;\n\n\t\t\tif (*prev_src_type == NOT_INIT) {\n\t\t\t\t/* saw a valid insn\n\t\t\t\t * dst_reg = *(u32 *)(src_reg + off)\n\t\t\t\t * save type to validate intersecting paths\n\t\t\t\t */\n\t\t\t\t*prev_src_type = src_reg_type;\n\n\t\t\t} else if (reg_type_mismatch(src_reg_type, *prev_src_type)) {\n\t\t\t\t/* ABuser program is trying to use the same insn\n\t\t\t\t * dst_reg = *(u32*) (src_reg + off)\n\t\t\t\t * with different pointer types:\n\t\t\t\t * src_reg == ctx in one branch and\n\t\t\t\t * src_reg == stack|map in some other branch.\n\t\t\t\t * Reject it.\n\t\t\t\t */\n\t\t\t\tverbose(env, \"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_STX) {\n\t\t\tenum bpf_reg_type *prev_dst_type, dst_reg_type;\n\n\t\t\tif (BPF_MODE(insn->code) == BPF_ATOMIC) {\n\t\t\t\terr = check_atomic(env, env->insn_idx, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tenv->insn_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (BPF_MODE(insn->code) != BPF_MEM || insn->imm != 0) {\n\t\t\t\tverbose(env, \"BPF_STX uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t/* check src2 operand */\n\t\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tdst_reg_type = regs[insn->dst_reg].type;\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, env->insn_idx, insn->dst_reg,\n\t\t\t\t\t       insn->off, BPF_SIZE(insn->code),\n\t\t\t\t\t       BPF_WRITE, insn->src_reg, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tprev_dst_type = &env->insn_aux_data[env->insn_idx].ptr_type;\n\n\t\t\tif (*prev_dst_type == NOT_INIT) {\n\t\t\t\t*prev_dst_type = dst_reg_type;\n\t\t\t} else if (reg_type_mismatch(dst_reg_type, *prev_dst_type)) {\n\t\t\t\tverbose(env, \"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_ST) {\n\t\t\tif (BPF_MODE(insn->code) != BPF_MEM ||\n\t\t\t    insn->src_reg != BPF_REG_0) {\n\t\t\t\tverbose(env, \"BPF_ST uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (is_ctx_reg(env, insn->dst_reg)) {\n\t\t\t\tverbose(env, \"BPF_ST stores into R%d %s is not allowed\\n\",\n\t\t\t\t\tinsn->dst_reg,\n\t\t\t\t\treg_type_str[reg_state(env, insn->dst_reg)->type]);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, env->insn_idx, insn->dst_reg,\n\t\t\t\t\t       insn->off, BPF_SIZE(insn->code),\n\t\t\t\t\t       BPF_WRITE, -1, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_JMP || class == BPF_JMP32) {\n\t\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\t\tenv->jmps_processed++;\n\t\t\tif (opcode == BPF_CALL) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->off != 0 ||\n\t\t\t\t    (insn->src_reg != BPF_REG_0 &&\n\t\t\t\t     insn->src_reg != BPF_PSEUDO_CALL) ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0 ||\n\t\t\t\t    class == BPF_JMP32) {\n\t\t\t\t\tverbose(env, \"BPF_CALL uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tif (env->cur_state->active_spin_lock &&\n\t\t\t\t    (insn->src_reg == BPF_PSEUDO_CALL ||\n\t\t\t\t     insn->imm != BPF_FUNC_spin_unlock)) {\n\t\t\t\t\tverbose(env, \"function calls are not allowed while holding a lock\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\t\t\terr = check_func_call(env, insn, &env->insn_idx);\n\t\t\t\telse\n\t\t\t\t\terr = check_helper_call(env, insn, &env->insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else if (opcode == BPF_JA) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0 ||\n\t\t\t\t    class == BPF_JMP32) {\n\t\t\t\t\tverbose(env, \"BPF_JA uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tenv->insn_idx += insn->off + 1;\n\t\t\t\tcontinue;\n\n\t\t\t} else if (opcode == BPF_EXIT) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0 ||\n\t\t\t\t    class == BPF_JMP32) {\n\t\t\t\t\tverbose(env, \"BPF_EXIT uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tif (env->cur_state->active_spin_lock) {\n\t\t\t\t\tverbose(env, \"bpf_spin_unlock is missing\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tif (state->curframe) {\n\t\t\t\t\t/* exit from nested function */\n\t\t\t\t\terr = prepare_func_exit(env, &env->insn_idx);\n\t\t\t\t\tif (err)\n\t\t\t\t\t\treturn err;\n\t\t\t\t\tdo_print_state = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\terr = check_reference_leak(env);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\terr = check_return_code(env);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\nprocess_bpf_exit:\n\t\t\t\tupdate_branch_counts(env, env->cur_state);\n\t\t\t\terr = pop_stack(env, &prev_insn_idx,\n\t\t\t\t\t\t&env->insn_idx, pop_log);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\tif (err != -ENOENT)\n\t\t\t\t\t\treturn err;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tdo_print_state = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = check_cond_jmp_op(env, insn, &env->insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (class == BPF_LD) {\n\t\t\tu8 mode = BPF_MODE(insn->code);\n\n\t\t\tif (mode == BPF_ABS || mode == BPF_IND) {\n\t\t\t\terr = check_ld_abs(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (mode == BPF_IMM) {\n\t\t\t\terr = check_ld_imm(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tenv->insn_idx++;\n\t\t\t\tenv->insn_aux_data[env->insn_idx].seen = env->pass_cnt;\n\t\t\t} else {\n\t\t\t\tverbose(env, \"invalid BPF_LD mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tverbose(env, \"unknown insn class %d\\n\", class);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tenv->insn_idx++;\n\t}\n\n\treturn 0;\n}\n\nstatic int find_btf_percpu_datasec(struct btf *btf)\n{\n\tconst struct btf_type *t;\n\tconst char *tname;\n\tint i, n;\n\n\t/*\n\t * Both vmlinux and module each have their own \".data..percpu\"\n\t * DATASECs in BTF. So for module's case, we need to skip vmlinux BTF\n\t * types to look at only module's own BTF types.\n\t */\n\tn = btf_nr_types(btf);\n\tif (btf_is_module(btf))\n\t\ti = btf_nr_types(btf_vmlinux);\n\telse\n\t\ti = 1;\n\n\tfor(; i < n; i++) {\n\t\tt = btf_type_by_id(btf, i);\n\t\tif (BTF_INFO_KIND(t->info) != BTF_KIND_DATASEC)\n\t\t\tcontinue;\n\n\t\ttname = btf_name_by_offset(btf, t->name_off);\n\t\tif (!strcmp(tname, \".data..percpu\"))\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}\n\n/* replace pseudo btf_id with kernel symbol address */\nstatic int check_pseudo_btf_id(struct bpf_verifier_env *env,\n\t\t\t       struct bpf_insn *insn,\n\t\t\t       struct bpf_insn_aux_data *aux)\n{\n\tconst struct btf_var_secinfo *vsi;\n\tconst struct btf_type *datasec;\n\tstruct btf_mod_pair *btf_mod;\n\tconst struct btf_type *t;\n\tconst char *sym_name;\n\tbool percpu = false;\n\tu32 type, id = insn->imm;\n\tstruct btf *btf;\n\ts32 datasec_id;\n\tu64 addr;\n\tint i, btf_fd, err;\n\n\tbtf_fd = insn[1].imm;\n\tif (btf_fd) {\n\t\tbtf = btf_get_by_fd(btf_fd);\n\t\tif (IS_ERR(btf)) {\n\t\t\tverbose(env, \"invalid module BTF object FD specified.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (!btf_vmlinux) {\n\t\t\tverbose(env, \"kernel is missing BTF, make sure CONFIG_DEBUG_INFO_BTF=y is specified in Kconfig.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbtf = btf_vmlinux;\n\t\tbtf_get(btf);\n\t}\n\n\tt = btf_type_by_id(btf, id);\n\tif (!t) {\n\t\tverbose(env, \"ldimm64 insn specifies invalid btf_id %d.\\n\", id);\n\t\terr = -ENOENT;\n\t\tgoto err_put;\n\t}\n\n\tif (!btf_type_is_var(t)) {\n\t\tverbose(env, \"pseudo btf_id %d in ldimm64 isn't KIND_VAR.\\n\", id);\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tsym_name = btf_name_by_offset(btf, t->name_off);\n\taddr = kallsyms_lookup_name(sym_name);\n\tif (!addr) {\n\t\tverbose(env, \"ldimm64 failed to find the address for kernel symbol '%s'.\\n\",\n\t\t\tsym_name);\n\t\terr = -ENOENT;\n\t\tgoto err_put;\n\t}\n\n\tdatasec_id = find_btf_percpu_datasec(btf);\n\tif (datasec_id > 0) {\n\t\tdatasec = btf_type_by_id(btf, datasec_id);\n\t\tfor_each_vsi(i, datasec, vsi) {\n\t\t\tif (vsi->type == id) {\n\t\t\t\tpercpu = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tinsn[0].imm = (u32)addr;\n\tinsn[1].imm = addr >> 32;\n\n\ttype = t->type;\n\tt = btf_type_skip_modifiers(btf, type, NULL);\n\tif (percpu) {\n\t\taux->btf_var.reg_type = PTR_TO_PERCPU_BTF_ID;\n\t\taux->btf_var.btf = btf;\n\t\taux->btf_var.btf_id = type;\n\t} else if (!btf_type_is_struct(t)) {\n\t\tconst struct btf_type *ret;\n\t\tconst char *tname;\n\t\tu32 tsize;\n\n\t\t/* resolve the type size of ksym. */\n\t\tret = btf_resolve_size(btf, t, &tsize);\n\t\tif (IS_ERR(ret)) {\n\t\t\ttname = btf_name_by_offset(btf, t->name_off);\n\t\t\tverbose(env, \"ldimm64 unable to resolve the size of type '%s': %ld\\n\",\n\t\t\t\ttname, PTR_ERR(ret));\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_put;\n\t\t}\n\t\taux->btf_var.reg_type = PTR_TO_MEM;\n\t\taux->btf_var.mem_size = tsize;\n\t} else {\n\t\taux->btf_var.reg_type = PTR_TO_BTF_ID;\n\t\taux->btf_var.btf = btf;\n\t\taux->btf_var.btf_id = type;\n\t}\n\n\t/* check whether we recorded this BTF (and maybe module) already */\n\tfor (i = 0; i < env->used_btf_cnt; i++) {\n\t\tif (env->used_btfs[i].btf == btf) {\n\t\t\tbtf_put(btf);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (env->used_btf_cnt >= MAX_USED_BTFS) {\n\t\terr = -E2BIG;\n\t\tgoto err_put;\n\t}\n\n\tbtf_mod = &env->used_btfs[env->used_btf_cnt];\n\tbtf_mod->btf = btf;\n\tbtf_mod->module = NULL;\n\n\t/* if we reference variables from kernel module, bump its refcount */\n\tif (btf_is_module(btf)) {\n\t\tbtf_mod->module = btf_try_get_module(btf);\n\t\tif (!btf_mod->module) {\n\t\t\terr = -ENXIO;\n\t\t\tgoto err_put;\n\t\t}\n\t}\n\n\tenv->used_btf_cnt++;\n\n\treturn 0;\nerr_put:\n\tbtf_put(btf);\n\treturn err;\n}\n\nstatic int check_map_prealloc(struct bpf_map *map)\n{\n\treturn (map->map_type != BPF_MAP_TYPE_HASH &&\n\t\tmap->map_type != BPF_MAP_TYPE_PERCPU_HASH &&\n\t\tmap->map_type != BPF_MAP_TYPE_HASH_OF_MAPS) ||\n\t\t!(map->map_flags & BPF_F_NO_PREALLOC);\n}\n\nstatic bool is_tracing_prog_type(enum bpf_prog_type type)\n{\n\tswitch (type) {\n\tcase BPF_PROG_TYPE_KPROBE:\n\tcase BPF_PROG_TYPE_TRACEPOINT:\n\tcase BPF_PROG_TYPE_PERF_EVENT:\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool is_preallocated_map(struct bpf_map *map)\n{\n\tif (!check_map_prealloc(map))\n\t\treturn false;\n\tif (map->inner_map_meta && !check_map_prealloc(map->inner_map_meta))\n\t\treturn false;\n\treturn true;\n}\n\nstatic int check_map_prog_compatibility(struct bpf_verifier_env *env,\n\t\t\t\t\tstruct bpf_map *map,\n\t\t\t\t\tstruct bpf_prog *prog)\n\n{\n\tenum bpf_prog_type prog_type = resolve_prog_type(prog);\n\t/*\n\t * Validate that trace type programs use preallocated hash maps.\n\t *\n\t * For programs attached to PERF events this is mandatory as the\n\t * perf NMI can hit any arbitrary code sequence.\n\t *\n\t * All other trace types using preallocated hash maps are unsafe as\n\t * well because tracepoint or kprobes can be inside locked regions\n\t * of the memory allocator or at a place where a recursion into the\n\t * memory allocator would see inconsistent state.\n\t *\n\t * On RT enabled kernels run-time allocation of all trace type\n\t * programs is strictly prohibited due to lock type constraints. On\n\t * !RT kernels it is allowed for backwards compatibility reasons for\n\t * now, but warnings are emitted so developers are made aware of\n\t * the unsafety and can fix their programs before this is enforced.\n\t */\n\tif (is_tracing_prog_type(prog_type) && !is_preallocated_map(map)) {\n\t\tif (prog_type == BPF_PROG_TYPE_PERF_EVENT) {\n\t\t\tverbose(env, \"perf_event programs can only use preallocated hash map\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\t\tverbose(env, \"trace type programs can only use preallocated hash map\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tWARN_ONCE(1, \"trace type BPF program uses run-time allocation\\n\");\n\t\tverbose(env, \"trace type programs with run-time allocated hash maps are unsafe. Switch to preallocated hash maps.\\n\");\n\t}\n\n\tif (map_value_has_spin_lock(map)) {\n\t\tif (prog_type == BPF_PROG_TYPE_SOCKET_FILTER) {\n\t\t\tverbose(env, \"socket filter progs cannot use bpf_spin_lock yet\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (is_tracing_prog_type(prog_type)) {\n\t\t\tverbose(env, \"tracing progs cannot use bpf_spin_lock yet\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (prog->aux->sleepable) {\n\t\t\tverbose(env, \"sleepable progs cannot use bpf_spin_lock yet\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif ((bpf_prog_is_dev_bound(prog->aux) || bpf_map_is_dev_bound(map)) &&\n\t    !bpf_offload_prog_map_match(prog, map)) {\n\t\tverbose(env, \"offload device mismatch between prog and map\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {\n\t\tverbose(env, \"bpf_struct_ops map cannot be used in prog\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (prog->aux->sleepable)\n\t\tswitch (map->map_type) {\n\t\tcase BPF_MAP_TYPE_HASH:\n\t\tcase BPF_MAP_TYPE_LRU_HASH:\n\t\tcase BPF_MAP_TYPE_ARRAY:\n\t\tcase BPF_MAP_TYPE_PERCPU_HASH:\n\t\tcase BPF_MAP_TYPE_PERCPU_ARRAY:\n\t\tcase BPF_MAP_TYPE_LRU_PERCPU_HASH:\n\t\tcase BPF_MAP_TYPE_ARRAY_OF_MAPS:\n\t\tcase BPF_MAP_TYPE_HASH_OF_MAPS:\n\t\t\tif (!is_preallocated_map(map)) {\n\t\t\t\tverbose(env,\n\t\t\t\t\t\"Sleepable programs can only use preallocated maps\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_MAP_TYPE_RINGBUF:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tverbose(env,\n\t\t\t\t\"Sleepable programs can only use array, hash, and ringbuf maps\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\treturn 0;\n}\n\nstatic bool bpf_map_is_cgroup_storage(struct bpf_map *map)\n{\n\treturn (map->map_type == BPF_MAP_TYPE_CGROUP_STORAGE ||\n\t\tmap->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE);\n}\n\n/* find and rewrite pseudo imm in ld_imm64 instructions:\n *\n * 1. if it accesses map FD, replace it with actual map pointer.\n * 2. if it accesses btf_id of a VAR, replace it with pointer to the var.\n *\n * NOTE: btf_vmlinux is required for converting pseudo btf_id.\n */\nstatic int resolve_pseudo_ldimm64(struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint i, j, err;\n\n\terr = bpf_prog_calc_tag(env->prog);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) == BPF_LDX &&\n\t\t    (BPF_MODE(insn->code) != BPF_MEM || insn->imm != 0)) {\n\t\t\tverbose(env, \"BPF_LDX uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) {\n\t\t\tstruct bpf_insn_aux_data *aux;\n\t\t\tstruct bpf_map *map;\n\t\t\tstruct fd f;\n\t\t\tu64 addr;\n\n\t\t\tif (i == insn_cnt - 1 || insn[1].code != 0 ||\n\t\t\t    insn[1].dst_reg != 0 || insn[1].src_reg != 0 ||\n\t\t\t    insn[1].off != 0) {\n\t\t\t\tverbose(env, \"invalid bpf_ld_imm64 insn\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (insn[0].src_reg == 0)\n\t\t\t\t/* valid generic load 64-bit imm */\n\t\t\t\tgoto next_insn;\n\n\t\t\tif (insn[0].src_reg == BPF_PSEUDO_BTF_ID) {\n\t\t\t\taux = &env->insn_aux_data[i];\n\t\t\t\terr = check_pseudo_btf_id(env, insn, aux);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tgoto next_insn;\n\t\t\t}\n\n\t\t\tif (insn[0].src_reg == BPF_PSEUDO_FUNC) {\n\t\t\t\taux = &env->insn_aux_data[i];\n\t\t\t\taux->ptr_type = PTR_TO_FUNC;\n\t\t\t\tgoto next_insn;\n\t\t\t}\n\n\t\t\t/* In final convert_pseudo_ld_imm64() step, this is\n\t\t\t * converted into regular 64-bit imm load insn.\n\t\t\t */\n\t\t\tif ((insn[0].src_reg != BPF_PSEUDO_MAP_FD &&\n\t\t\t     insn[0].src_reg != BPF_PSEUDO_MAP_VALUE) ||\n\t\t\t    (insn[0].src_reg == BPF_PSEUDO_MAP_FD &&\n\t\t\t     insn[1].imm != 0)) {\n\t\t\t\tverbose(env,\n\t\t\t\t\t\"unrecognized bpf_ld_imm64 insn\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tf = fdget(insn[0].imm);\n\t\t\tmap = __bpf_map_get(f);\n\t\t\tif (IS_ERR(map)) {\n\t\t\t\tverbose(env, \"fd %d is not pointing to valid bpf_map\\n\",\n\t\t\t\t\tinsn[0].imm);\n\t\t\t\treturn PTR_ERR(map);\n\t\t\t}\n\n\t\t\terr = check_map_prog_compatibility(env, map, env->prog);\n\t\t\tif (err) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\taux = &env->insn_aux_data[i];\n\t\t\tif (insn->src_reg == BPF_PSEUDO_MAP_FD) {\n\t\t\t\taddr = (unsigned long)map;\n\t\t\t} else {\n\t\t\t\tu32 off = insn[1].imm;\n\n\t\t\t\tif (off >= BPF_MAX_VAR_OFF) {\n\t\t\t\t\tverbose(env, \"direct value offset of %u is not allowed\\n\", off);\n\t\t\t\t\tfdput(f);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tif (!map->ops->map_direct_value_addr) {\n\t\t\t\t\tverbose(env, \"no direct value access support for this map type\\n\");\n\t\t\t\t\tfdput(f);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\terr = map->ops->map_direct_value_addr(map, &addr, off);\n\t\t\t\tif (err) {\n\t\t\t\t\tverbose(env, \"invalid access to map value pointer, value_size=%u off=%u\\n\",\n\t\t\t\t\t\tmap->value_size, off);\n\t\t\t\t\tfdput(f);\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\n\t\t\t\taux->map_off = off;\n\t\t\t\taddr += off;\n\t\t\t}\n\n\t\t\tinsn[0].imm = (u32)addr;\n\t\t\tinsn[1].imm = addr >> 32;\n\n\t\t\t/* check whether we recorded this map already */\n\t\t\tfor (j = 0; j < env->used_map_cnt; j++) {\n\t\t\t\tif (env->used_maps[j] == map) {\n\t\t\t\t\taux->map_index = j;\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tgoto next_insn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (env->used_map_cnt >= MAX_USED_MAPS) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\n\t\t\t/* hold the map. If the program is rejected by verifier,\n\t\t\t * the map will be released by release_maps() or it\n\t\t\t * will be used by the valid program until it's unloaded\n\t\t\t * and all maps are released in free_used_maps()\n\t\t\t */\n\t\t\tbpf_map_inc(map);\n\n\t\t\taux->map_index = env->used_map_cnt;\n\t\t\tenv->used_maps[env->used_map_cnt++] = map;\n\n\t\t\tif (bpf_map_is_cgroup_storage(map) &&\n\t\t\t    bpf_cgroup_storage_assign(env->prog->aux, map)) {\n\t\t\t\tverbose(env, \"only one cgroup storage of each type is allowed\\n\");\n\t\t\t\tfdput(f);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\n\t\t\tfdput(f);\nnext_insn:\n\t\t\tinsn++;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Basic sanity check before we invest more work here. */\n\t\tif (!bpf_opcode_in_insntable(insn->code)) {\n\t\t\tverbose(env, \"unknown opcode %02x\\n\", insn->code);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* now all pseudo BPF_LD_IMM64 instructions load valid\n\t * 'struct bpf_map *' into a register instead of user map_fd.\n\t * These pointers will be used later by verifier to validate map access.\n\t */\n\treturn 0;\n}\n\n/* drop refcnt of maps used by the rejected program */\nstatic void release_maps(struct bpf_verifier_env *env)\n{\n\t__bpf_free_used_maps(env->prog->aux, env->used_maps,\n\t\t\t     env->used_map_cnt);\n}\n\n/* drop refcnt of maps used by the rejected program */\nstatic void release_btfs(struct bpf_verifier_env *env)\n{\n\t__bpf_free_used_btfs(env->prog->aux, env->used_btfs,\n\t\t\t     env->used_btf_cnt);\n}\n\n/* convert pseudo BPF_LD_IMM64 into generic BPF_LD_IMM64 */\nstatic void convert_pseudo_ld_imm64(struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint i;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code != (BPF_LD | BPF_IMM | BPF_DW))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_FUNC)\n\t\t\tcontinue;\n\t\tinsn->src_reg = 0;\n\t}\n}\n\n/* single env->prog->insni[off] instruction was replaced with the range\n * insni[off, off + cnt).  Adjust corresponding insn_aux_data by copying\n * [0, off) and [off, end) to new locations, so the patched range stays zero\n */\nstatic int adjust_insn_aux_data(struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_prog *new_prog, u32 off, u32 cnt)\n{\n\tstruct bpf_insn_aux_data *new_data, *old_data = env->insn_aux_data;\n\tstruct bpf_insn *insn = new_prog->insnsi;\n\tu32 prog_len;\n\tint i;\n\n\t/* aux info at OFF always needs adjustment, no matter fast path\n\t * (cnt == 1) is taken or not. There is no guarantee INSN at OFF is the\n\t * original insn at old prog.\n\t */\n\told_data[off].zext_dst = insn_has_def32(env, insn + off + cnt - 1);\n\n\tif (cnt == 1)\n\t\treturn 0;\n\tprog_len = new_prog->len;\n\tnew_data = vzalloc(array_size(prog_len,\n\t\t\t\t      sizeof(struct bpf_insn_aux_data)));\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\tmemcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off);\n\tmemcpy(new_data + off + cnt - 1, old_data + off,\n\t       sizeof(struct bpf_insn_aux_data) * (prog_len - off - cnt + 1));\n\tfor (i = off; i < off + cnt - 1; i++) {\n\t\tnew_data[i].seen = env->pass_cnt;\n\t\tnew_data[i].zext_dst = insn_has_def32(env, insn + i);\n\t}\n\tenv->insn_aux_data = new_data;\n\tvfree(old_data);\n\treturn 0;\n}\n\nstatic void adjust_subprog_starts(struct bpf_verifier_env *env, u32 off, u32 len)\n{\n\tint i;\n\n\tif (len == 1)\n\t\treturn;\n\t/* NOTE: fake 'exit' subprog should be updated as well. */\n\tfor (i = 0; i <= env->subprog_cnt; i++) {\n\t\tif (env->subprog_info[i].start <= off)\n\t\t\tcontinue;\n\t\tenv->subprog_info[i].start += len - 1;\n\t}\n}\n\nstatic void adjust_poke_descs(struct bpf_prog *prog, u32 len)\n{\n\tstruct bpf_jit_poke_descriptor *tab = prog->aux->poke_tab;\n\tint i, sz = prog->aux->size_poke_tab;\n\tstruct bpf_jit_poke_descriptor *desc;\n\n\tfor (i = 0; i < sz; i++) {\n\t\tdesc = &tab[i];\n\t\tdesc->insn_idx += len - 1;\n\t}\n}\n\nstatic struct bpf_prog *bpf_patch_insn_data(struct bpf_verifier_env *env, u32 off,\n\t\t\t\t\t    const struct bpf_insn *patch, u32 len)\n{\n\tstruct bpf_prog *new_prog;\n\n\tnew_prog = bpf_patch_insn_single(env->prog, off, patch, len);\n\tif (IS_ERR(new_prog)) {\n\t\tif (PTR_ERR(new_prog) == -ERANGE)\n\t\t\tverbose(env,\n\t\t\t\t\"insn %d cannot be patched due to 16-bit range\\n\",\n\t\t\t\tenv->insn_aux_data[off].orig_idx);\n\t\treturn NULL;\n\t}\n\tif (adjust_insn_aux_data(env, new_prog, off, len))\n\t\treturn NULL;\n\tadjust_subprog_starts(env, off, len);\n\tadjust_poke_descs(new_prog, len);\n\treturn new_prog;\n}\n\nstatic int adjust_subprog_starts_after_remove(struct bpf_verifier_env *env,\n\t\t\t\t\t      u32 off, u32 cnt)\n{\n\tint i, j;\n\n\t/* find first prog starting at or after off (first to remove) */\n\tfor (i = 0; i < env->subprog_cnt; i++)\n\t\tif (env->subprog_info[i].start >= off)\n\t\t\tbreak;\n\t/* find first prog starting at or after off + cnt (first to stay) */\n\tfor (j = i; j < env->subprog_cnt; j++)\n\t\tif (env->subprog_info[j].start >= off + cnt)\n\t\t\tbreak;\n\t/* if j doesn't start exactly at off + cnt, we are just removing\n\t * the front of previous prog\n\t */\n\tif (env->subprog_info[j].start != off + cnt)\n\t\tj--;\n\n\tif (j > i) {\n\t\tstruct bpf_prog_aux *aux = env->prog->aux;\n\t\tint move;\n\n\t\t/* move fake 'exit' subprog as well */\n\t\tmove = env->subprog_cnt + 1 - j;\n\n\t\tmemmove(env->subprog_info + i,\n\t\t\tenv->subprog_info + j,\n\t\t\tsizeof(*env->subprog_info) * move);\n\t\tenv->subprog_cnt -= j - i;\n\n\t\t/* remove func_info */\n\t\tif (aux->func_info) {\n\t\t\tmove = aux->func_info_cnt - j;\n\n\t\t\tmemmove(aux->func_info + i,\n\t\t\t\taux->func_info + j,\n\t\t\t\tsizeof(*aux->func_info) * move);\n\t\t\taux->func_info_cnt -= j - i;\n\t\t\t/* func_info->insn_off is set after all code rewrites,\n\t\t\t * in adjust_btf_func() - no need to adjust\n\t\t\t */\n\t\t}\n\t} else {\n\t\t/* convert i from \"first prog to remove\" to \"first to adjust\" */\n\t\tif (env->subprog_info[i].start == off)\n\t\t\ti++;\n\t}\n\n\t/* update fake 'exit' subprog as well */\n\tfor (; i <= env->subprog_cnt; i++)\n\t\tenv->subprog_info[i].start -= cnt;\n\n\treturn 0;\n}\n\nstatic int bpf_adj_linfo_after_remove(struct bpf_verifier_env *env, u32 off,\n\t\t\t\t      u32 cnt)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tu32 i, l_off, l_cnt, nr_linfo;\n\tstruct bpf_line_info *linfo;\n\n\tnr_linfo = prog->aux->nr_linfo;\n\tif (!nr_linfo)\n\t\treturn 0;\n\n\tlinfo = prog->aux->linfo;\n\n\t/* find first line info to remove, count lines to be removed */\n\tfor (i = 0; i < nr_linfo; i++)\n\t\tif (linfo[i].insn_off >= off)\n\t\t\tbreak;\n\n\tl_off = i;\n\tl_cnt = 0;\n\tfor (; i < nr_linfo; i++)\n\t\tif (linfo[i].insn_off < off + cnt)\n\t\t\tl_cnt++;\n\t\telse\n\t\t\tbreak;\n\n\t/* First live insn doesn't match first live linfo, it needs to \"inherit\"\n\t * last removed linfo.  prog is already modified, so prog->len == off\n\t * means no live instructions after (tail of the program was removed).\n\t */\n\tif (prog->len != off && l_cnt &&\n\t    (i == nr_linfo || linfo[i].insn_off != off + cnt)) {\n\t\tl_cnt--;\n\t\tlinfo[--i].insn_off = off + cnt;\n\t}\n\n\t/* remove the line info which refer to the removed instructions */\n\tif (l_cnt) {\n\t\tmemmove(linfo + l_off, linfo + i,\n\t\t\tsizeof(*linfo) * (nr_linfo - i));\n\n\t\tprog->aux->nr_linfo -= l_cnt;\n\t\tnr_linfo = prog->aux->nr_linfo;\n\t}\n\n\t/* pull all linfo[i].insn_off >= off + cnt in by cnt */\n\tfor (i = l_off; i < nr_linfo; i++)\n\t\tlinfo[i].insn_off -= cnt;\n\n\t/* fix up all subprogs (incl. 'exit') which start >= off */\n\tfor (i = 0; i <= env->subprog_cnt; i++)\n\t\tif (env->subprog_info[i].linfo_idx > l_off) {\n\t\t\t/* program may have started in the removed region but\n\t\t\t * may not be fully removed\n\t\t\t */\n\t\t\tif (env->subprog_info[i].linfo_idx >= l_off + l_cnt)\n\t\t\t\tenv->subprog_info[i].linfo_idx -= l_cnt;\n\t\t\telse\n\t\t\t\tenv->subprog_info[i].linfo_idx = l_off;\n\t\t}\n\n\treturn 0;\n}\n\nstatic int verifier_remove_insns(struct bpf_verifier_env *env, u32 off, u32 cnt)\n{\n\tstruct bpf_insn_aux_data *aux_data = env->insn_aux_data;\n\tunsigned int orig_prog_len = env->prog->len;\n\tint err;\n\n\tif (bpf_prog_is_dev_bound(env->prog->aux))\n\t\tbpf_prog_offload_remove_insns(env, off, cnt);\n\n\terr = bpf_remove_insns(env->prog, off, cnt);\n\tif (err)\n\t\treturn err;\n\n\terr = adjust_subprog_starts_after_remove(env, off, cnt);\n\tif (err)\n\t\treturn err;\n\n\terr = bpf_adj_linfo_after_remove(env, off, cnt);\n\tif (err)\n\t\treturn err;\n\n\tmemmove(aux_data + off,\taux_data + off + cnt,\n\t\tsizeof(*aux_data) * (orig_prog_len - off - cnt));\n\n\treturn 0;\n}\n\n/* The verifier does more data flow analysis than llvm and will not\n * explore branches that are dead at run time. Malicious programs can\n * have dead code too. Therefore replace all dead at-run-time code\n * with 'ja -1'.\n *\n * Just nops are not optimal, e.g. if they would sit at the end of the\n * program and through another bug we would manage to jump there, then\n * we'd execute beyond program memory otherwise. Returning exception\n * code also wouldn't work since we can have subprogs where the dead\n * code could be located.\n */\nstatic void sanitize_dead_code(struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn_aux_data *aux_data = env->insn_aux_data;\n\tstruct bpf_insn trap = BPF_JMP_IMM(BPF_JA, 0, 0, -1);\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tconst int insn_cnt = env->prog->len;\n\tint i;\n\n\tfor (i = 0; i < insn_cnt; i++) {\n\t\tif (aux_data[i].seen)\n\t\t\tcontinue;\n\t\tmemcpy(insn + i, &trap, sizeof(trap));\n\t}\n}\n\nstatic bool insn_is_cond_jump(u8 code)\n{\n\tu8 op;\n\n\tif (BPF_CLASS(code) == BPF_JMP32)\n\t\treturn true;\n\n\tif (BPF_CLASS(code) != BPF_JMP)\n\t\treturn false;\n\n\top = BPF_OP(code);\n\treturn op != BPF_JA && op != BPF_EXIT && op != BPF_CALL;\n}\n\nstatic void opt_hard_wire_dead_code_branches(struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn_aux_data *aux_data = env->insn_aux_data;\n\tstruct bpf_insn ja = BPF_JMP_IMM(BPF_JA, 0, 0, 0);\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tconst int insn_cnt = env->prog->len;\n\tint i;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (!insn_is_cond_jump(insn->code))\n\t\t\tcontinue;\n\n\t\tif (!aux_data[i + 1].seen)\n\t\t\tja.off = insn->off;\n\t\telse if (!aux_data[i + 1 + insn->off].seen)\n\t\t\tja.off = 0;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (bpf_prog_is_dev_bound(env->prog->aux))\n\t\t\tbpf_prog_offload_replace_insn(env, i, &ja);\n\n\t\tmemcpy(insn, &ja, sizeof(ja));\n\t}\n}\n\nstatic int opt_remove_dead_code(struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn_aux_data *aux_data = env->insn_aux_data;\n\tint insn_cnt = env->prog->len;\n\tint i, err;\n\n\tfor (i = 0; i < insn_cnt; i++) {\n\t\tint j;\n\n\t\tj = 0;\n\t\twhile (i + j < insn_cnt && !aux_data[i + j].seen)\n\t\t\tj++;\n\t\tif (!j)\n\t\t\tcontinue;\n\n\t\terr = verifier_remove_insns(env, i, j);\n\t\tif (err)\n\t\t\treturn err;\n\t\tinsn_cnt = env->prog->len;\n\t}\n\n\treturn 0;\n}\n\nstatic int opt_remove_nops(struct bpf_verifier_env *env)\n{\n\tconst struct bpf_insn ja = BPF_JMP_IMM(BPF_JA, 0, 0, 0);\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint i, err;\n\n\tfor (i = 0; i < insn_cnt; i++) {\n\t\tif (memcmp(&insn[i], &ja, sizeof(ja)))\n\t\t\tcontinue;\n\n\t\terr = verifier_remove_insns(env, i, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tinsn_cnt--;\n\t\ti--;\n\t}\n\n\treturn 0;\n}\n\nstatic int opt_subreg_zext_lo32_rnd_hi32(struct bpf_verifier_env *env,\n\t\t\t\t\t const union bpf_attr *attr)\n{\n\tstruct bpf_insn *patch, zext_patch[2], rnd_hi32_patch[4];\n\tstruct bpf_insn_aux_data *aux = env->insn_aux_data;\n\tint i, patch_len, delta = 0, len = env->prog->len;\n\tstruct bpf_insn *insns = env->prog->insnsi;\n\tstruct bpf_prog *new_prog;\n\tbool rnd_hi32;\n\n\trnd_hi32 = attr->prog_flags & BPF_F_TEST_RND_HI32;\n\tzext_patch[1] = BPF_ZEXT_REG(0);\n\trnd_hi32_patch[1] = BPF_ALU64_IMM(BPF_MOV, BPF_REG_AX, 0);\n\trnd_hi32_patch[2] = BPF_ALU64_IMM(BPF_LSH, BPF_REG_AX, 32);\n\trnd_hi32_patch[3] = BPF_ALU64_REG(BPF_OR, 0, BPF_REG_AX);\n\tfor (i = 0; i < len; i++) {\n\t\tint adj_idx = i + delta;\n\t\tstruct bpf_insn insn;\n\t\tint load_reg;\n\n\t\tinsn = insns[adj_idx];\n\t\tload_reg = insn_def_regno(&insn);\n\t\tif (!aux[adj_idx].zext_dst) {\n\t\t\tu8 code, class;\n\t\t\tu32 imm_rnd;\n\n\t\t\tif (!rnd_hi32)\n\t\t\t\tcontinue;\n\n\t\t\tcode = insn.code;\n\t\t\tclass = BPF_CLASS(code);\n\t\t\tif (load_reg == -1)\n\t\t\t\tcontinue;\n\n\t\t\t/* NOTE: arg \"reg\" (the fourth one) is only used for\n\t\t\t *       BPF_STX + SRC_OP, so it is safe to pass NULL\n\t\t\t *       here.\n\t\t\t */\n\t\t\tif (is_reg64(env, &insn, load_reg, NULL, DST_OP)) {\n\t\t\t\tif (class == BPF_LD &&\n\t\t\t\t    BPF_MODE(code) == BPF_IMM)\n\t\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* ctx load could be transformed into wider load. */\n\t\t\tif (class == BPF_LDX &&\n\t\t\t    aux[adj_idx].ptr_type == PTR_TO_CTX)\n\t\t\t\tcontinue;\n\n\t\t\timm_rnd = get_random_int();\n\t\t\trnd_hi32_patch[0] = insn;\n\t\t\trnd_hi32_patch[1].imm = imm_rnd;\n\t\t\trnd_hi32_patch[3].dst_reg = load_reg;\n\t\t\tpatch = rnd_hi32_patch;\n\t\t\tpatch_len = 4;\n\t\t\tgoto apply_patch_buffer;\n\t\t}\n\n\t\t/* Add in an zero-extend instruction if a) the JIT has requested\n\t\t * it or b) it's a CMPXCHG.\n\t\t *\n\t\t * The latter is because: BPF_CMPXCHG always loads a value into\n\t\t * R0, therefore always zero-extends. However some archs'\n\t\t * equivalent instruction only does this load when the\n\t\t * comparison is successful. This detail of CMPXCHG is\n\t\t * orthogonal to the general zero-extension behaviour of the\n\t\t * CPU, so it's treated independently of bpf_jit_needs_zext.\n\t\t */\n\t\tif (!bpf_jit_needs_zext() && !is_cmpxchg_insn(&insn))\n\t\t\tcontinue;\n\n\t\tif (WARN_ON(load_reg == -1)) {\n\t\t\tverbose(env, \"verifier bug. zext_dst is set, but no reg is defined\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tzext_patch[0] = insn;\n\t\tzext_patch[1].dst_reg = load_reg;\n\t\tzext_patch[1].src_reg = load_reg;\n\t\tpatch = zext_patch;\n\t\tpatch_len = 2;\napply_patch_buffer:\n\t\tnew_prog = bpf_patch_insn_data(env, adj_idx, patch, patch_len);\n\t\tif (!new_prog)\n\t\t\treturn -ENOMEM;\n\t\tenv->prog = new_prog;\n\t\tinsns = new_prog->insnsi;\n\t\taux = env->insn_aux_data;\n\t\tdelta += patch_len - 1;\n\t}\n\n\treturn 0;\n}\n\n/* convert load instructions that access fields of a context type into a\n * sequence of instructions that access fields of the underlying structure:\n *     struct __sk_buff    -> struct sk_buff\n *     struct bpf_sock_ops -> struct sock\n */\nstatic int convert_ctx_accesses(struct bpf_verifier_env *env)\n{\n\tconst struct bpf_verifier_ops *ops = env->ops;\n\tint i, cnt, size, ctx_field_size, delta = 0;\n\tconst int insn_cnt = env->prog->len;\n\tstruct bpf_insn insn_buf[16], *insn;\n\tu32 target_size, size_default, off;\n\tstruct bpf_prog *new_prog;\n\tenum bpf_access_type type;\n\tbool is_narrower_load;\n\n\tif (ops->gen_prologue || env->seen_direct_write) {\n\t\tif (!ops->gen_prologue) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcnt = ops->gen_prologue(insn_buf, env->seen_direct_write,\n\t\t\t\t\tenv->prog);\n\t\tif (cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else if (cnt) {\n\t\t\tnew_prog = bpf_patch_insn_data(env, 0, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tenv->prog = new_prog;\n\t\t\tdelta += cnt - 1;\n\t\t}\n\t}\n\n\tif (bpf_prog_is_dev_bound(env->prog->aux))\n\t\treturn 0;\n\n\tinsn = env->prog->insnsi + delta;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tbpf_convert_ctx_access_t convert_ctx_access;\n\n\t\tif (insn->code == (BPF_LDX | BPF_MEM | BPF_B) ||\n\t\t    insn->code == (BPF_LDX | BPF_MEM | BPF_H) ||\n\t\t    insn->code == (BPF_LDX | BPF_MEM | BPF_W) ||\n\t\t    insn->code == (BPF_LDX | BPF_MEM | BPF_DW))\n\t\t\ttype = BPF_READ;\n\t\telse if (insn->code == (BPF_STX | BPF_MEM | BPF_B) ||\n\t\t\t insn->code == (BPF_STX | BPF_MEM | BPF_H) ||\n\t\t\t insn->code == (BPF_STX | BPF_MEM | BPF_W) ||\n\t\t\t insn->code == (BPF_STX | BPF_MEM | BPF_DW))\n\t\t\ttype = BPF_WRITE;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (type == BPF_WRITE &&\n\t\t    env->insn_aux_data[i + delta].sanitize_stack_off) {\n\t\t\tstruct bpf_insn patch[] = {\n\t\t\t\t/* Sanitize suspicious stack slot with zero.\n\t\t\t\t * There are no memory dependencies for this store,\n\t\t\t\t * since it's only using frame pointer and immediate\n\t\t\t\t * constant of zero\n\t\t\t\t */\n\t\t\t\tBPF_ST_MEM(BPF_DW, BPF_REG_FP,\n\t\t\t\t\t   env->insn_aux_data[i + delta].sanitize_stack_off,\n\t\t\t\t\t   0),\n\t\t\t\t/* the original STX instruction will immediately\n\t\t\t\t * overwrite the same stack slot with appropriate value\n\t\t\t\t */\n\t\t\t\t*insn,\n\t\t\t};\n\n\t\t\tcnt = ARRAY_SIZE(patch);\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patch, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (env->insn_aux_data[i + delta].ptr_type) {\n\t\tcase PTR_TO_CTX:\n\t\t\tif (!ops->convert_ctx_access)\n\t\t\t\tcontinue;\n\t\t\tconvert_ctx_access = ops->convert_ctx_access;\n\t\t\tbreak;\n\t\tcase PTR_TO_SOCKET:\n\t\tcase PTR_TO_SOCK_COMMON:\n\t\t\tconvert_ctx_access = bpf_sock_convert_ctx_access;\n\t\t\tbreak;\n\t\tcase PTR_TO_TCP_SOCK:\n\t\t\tconvert_ctx_access = bpf_tcp_sock_convert_ctx_access;\n\t\t\tbreak;\n\t\tcase PTR_TO_XDP_SOCK:\n\t\t\tconvert_ctx_access = bpf_xdp_sock_convert_ctx_access;\n\t\t\tbreak;\n\t\tcase PTR_TO_BTF_ID:\n\t\t\tif (type == BPF_READ) {\n\t\t\t\tinsn->code = BPF_LDX | BPF_PROBE_MEM |\n\t\t\t\t\tBPF_SIZE((insn)->code);\n\t\t\t\tenv->prog->aux->num_exentries++;\n\t\t\t} else if (resolve_prog_type(env->prog) != BPF_PROG_TYPE_STRUCT_OPS) {\n\t\t\t\tverbose(env, \"Writes through BTF pointers are not allowed\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tctx_field_size = env->insn_aux_data[i + delta].ctx_field_size;\n\t\tsize = BPF_LDST_BYTES(insn);\n\n\t\t/* If the read access is a narrower load of the field,\n\t\t * convert to a 4/8-byte load, to minimum program type specific\n\t\t * convert_ctx_access changes. If conversion is successful,\n\t\t * we will apply proper mask to the result.\n\t\t */\n\t\tis_narrower_load = size < ctx_field_size;\n\t\tsize_default = bpf_ctx_off_adjust_machine(ctx_field_size);\n\t\toff = insn->off;\n\t\tif (is_narrower_load) {\n\t\t\tu8 size_code;\n\n\t\t\tif (type == BPF_WRITE) {\n\t\t\t\tverbose(env, \"bpf verifier narrow ctx access misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tsize_code = BPF_H;\n\t\t\tif (ctx_field_size == 4)\n\t\t\t\tsize_code = BPF_W;\n\t\t\telse if (ctx_field_size == 8)\n\t\t\t\tsize_code = BPF_DW;\n\n\t\t\tinsn->off = off & ~(size_default - 1);\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | size_code;\n\t\t}\n\n\t\ttarget_size = 0;\n\t\tcnt = convert_ctx_access(type, insn, insn_buf, env->prog,\n\t\t\t\t\t &target_size);\n\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf) ||\n\t\t    (ctx_field_size && !target_size)) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (is_narrower_load && size < target_size) {\n\t\t\tu8 shift = bpf_ctx_narrow_access_offset(\n\t\t\t\toff, size, size_default) * 8;\n\t\t\tif (ctx_field_size <= 4) {\n\t\t\t\tif (shift)\n\t\t\t\t\tinsn_buf[cnt++] = BPF_ALU32_IMM(BPF_RSH,\n\t\t\t\t\t\t\t\t\tinsn->dst_reg,\n\t\t\t\t\t\t\t\t\tshift);\n\t\t\t\tinsn_buf[cnt++] = BPF_ALU32_IMM(BPF_AND, insn->dst_reg,\n\t\t\t\t\t\t\t\t(1 << size * 8) - 1);\n\t\t\t} else {\n\t\t\t\tif (shift)\n\t\t\t\t\tinsn_buf[cnt++] = BPF_ALU64_IMM(BPF_RSH,\n\t\t\t\t\t\t\t\t\tinsn->dst_reg,\n\t\t\t\t\t\t\t\t\tshift);\n\t\t\t\tinsn_buf[cnt++] = BPF_ALU64_IMM(BPF_AND, insn->dst_reg,\n\t\t\t\t\t\t\t\t(1ULL << size * 8) - 1);\n\t\t\t}\n\t\t}\n\n\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\tif (!new_prog)\n\t\t\treturn -ENOMEM;\n\n\t\tdelta += cnt - 1;\n\n\t\t/* keep walking new program and skip insns we just inserted */\n\t\tenv->prog = new_prog;\n\t\tinsn      = new_prog->insnsi + i + delta;\n\t}\n\n\treturn 0;\n}\n\nstatic int jit_subprogs(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog, **func, *tmp;\n\tint i, j, subprog_start, subprog_end = 0, len, subprog;\n\tstruct bpf_map *map_ptr;\n\tstruct bpf_insn *insn;\n\tvoid *old_bpf_func;\n\tint err, num_exentries;\n\n\tif (env->subprog_cnt <= 1)\n\t\treturn 0;\n\n\tfor (i = 0, insn = prog->insnsi; i < prog->len; i++, insn++) {\n\t\tif (bpf_pseudo_func(insn)) {\n\t\t\tenv->insn_aux_data[i].call_imm = insn->imm;\n\t\t\t/* subprog is encoded in insn[1].imm */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!bpf_pseudo_call(insn))\n\t\t\tcontinue;\n\t\t/* Upon error here we cannot fall back to interpreter but\n\t\t * need a hard reject of the program. Thus -EFAULT is\n\t\t * propagated in any case.\n\t\t */\n\t\tsubprog = find_subprog(env, i + insn->imm + 1);\n\t\tif (subprog < 0) {\n\t\t\tWARN_ONCE(1, \"verifier bug. No program starts at insn %d\\n\",\n\t\t\t\t  i + insn->imm + 1);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\t/* temporarily remember subprog id inside insn instead of\n\t\t * aux_data, since next loop will split up all insns into funcs\n\t\t */\n\t\tinsn->off = subprog;\n\t\t/* remember original imm in case JIT fails and fallback\n\t\t * to interpreter will be needed\n\t\t */\n\t\tenv->insn_aux_data[i].call_imm = insn->imm;\n\t\t/* point imm to __bpf_call_base+1 from JITs point of view */\n\t\tinsn->imm = 1;\n\t}\n\n\terr = bpf_prog_alloc_jited_linfo(prog);\n\tif (err)\n\t\tgoto out_undo_insn;\n\n\terr = -ENOMEM;\n\tfunc = kcalloc(env->subprog_cnt, sizeof(prog), GFP_KERNEL);\n\tif (!func)\n\t\tgoto out_undo_insn;\n\n\tfor (i = 0; i < env->subprog_cnt; i++) {\n\t\tsubprog_start = subprog_end;\n\t\tsubprog_end = env->subprog_info[i + 1].start;\n\n\t\tlen = subprog_end - subprog_start;\n\t\t/* BPF_PROG_RUN doesn't call subprogs directly,\n\t\t * hence main prog stats include the runtime of subprogs.\n\t\t * subprogs don't have IDs and not reachable via prog_get_next_id\n\t\t * func[i]->stats will never be accessed and stays NULL\n\t\t */\n\t\tfunc[i] = bpf_prog_alloc_no_stats(bpf_prog_size(len), GFP_USER);\n\t\tif (!func[i])\n\t\t\tgoto out_free;\n\t\tmemcpy(func[i]->insnsi, &prog->insnsi[subprog_start],\n\t\t       len * sizeof(struct bpf_insn));\n\t\tfunc[i]->type = prog->type;\n\t\tfunc[i]->len = len;\n\t\tif (bpf_prog_calc_tag(func[i]))\n\t\t\tgoto out_free;\n\t\tfunc[i]->is_func = 1;\n\t\tfunc[i]->aux->func_idx = i;\n\t\t/* the btf and func_info will be freed only at prog->aux */\n\t\tfunc[i]->aux->btf = prog->aux->btf;\n\t\tfunc[i]->aux->func_info = prog->aux->func_info;\n\n\t\tfor (j = 0; j < prog->aux->size_poke_tab; j++) {\n\t\t\tu32 insn_idx = prog->aux->poke_tab[j].insn_idx;\n\t\t\tint ret;\n\n\t\t\tif (!(insn_idx >= subprog_start &&\n\t\t\t      insn_idx <= subprog_end))\n\t\t\t\tcontinue;\n\n\t\t\tret = bpf_jit_add_poke_descriptor(func[i],\n\t\t\t\t\t\t\t  &prog->aux->poke_tab[j]);\n\t\t\tif (ret < 0) {\n\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tfunc[i]->insnsi[insn_idx - subprog_start].imm = ret + 1;\n\n\t\t\tmap_ptr = func[i]->aux->poke_tab[ret].tail_call.map;\n\t\t\tret = map_ptr->ops->map_poke_track(map_ptr, func[i]->aux);\n\t\t\tif (ret < 0) {\n\t\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t}\n\n\t\t/* Use bpf_prog_F_tag to indicate functions in stack traces.\n\t\t * Long term would need debug info to populate names\n\t\t */\n\t\tfunc[i]->aux->name[0] = 'F';\n\t\tfunc[i]->aux->stack_depth = env->subprog_info[i].stack_depth;\n\t\tfunc[i]->jit_requested = 1;\n\t\tfunc[i]->aux->linfo = prog->aux->linfo;\n\t\tfunc[i]->aux->nr_linfo = prog->aux->nr_linfo;\n\t\tfunc[i]->aux->jited_linfo = prog->aux->jited_linfo;\n\t\tfunc[i]->aux->linfo_idx = env->subprog_info[i].linfo_idx;\n\t\tnum_exentries = 0;\n\t\tinsn = func[i]->insnsi;\n\t\tfor (j = 0; j < func[i]->len; j++, insn++) {\n\t\t\tif (BPF_CLASS(insn->code) == BPF_LDX &&\n\t\t\t    BPF_MODE(insn->code) == BPF_PROBE_MEM)\n\t\t\t\tnum_exentries++;\n\t\t}\n\t\tfunc[i]->aux->num_exentries = num_exentries;\n\t\tfunc[i]->aux->tail_call_reachable = env->subprog_info[i].tail_call_reachable;\n\t\tfunc[i] = bpf_int_jit_compile(func[i]);\n\t\tif (!func[i]->jited) {\n\t\t\terr = -ENOTSUPP;\n\t\t\tgoto out_free;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\t/* Untrack main program's aux structs so that during map_poke_run()\n\t * we will not stumble upon the unfilled poke descriptors; each\n\t * of the main program's poke descs got distributed across subprogs\n\t * and got tracked onto map, so we are sure that none of them will\n\t * be missed after the operation below\n\t */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\n\t\tmap_ptr->ops->map_poke_untrack(map_ptr, prog->aux);\n\t}\n\n\t/* at this point all bpf functions were successfully JITed\n\t * now populate all bpf_calls with correct addresses and\n\t * run last pass of JIT\n\t */\n\tfor (i = 0; i < env->subprog_cnt; i++) {\n\t\tinsn = func[i]->insnsi;\n\t\tfor (j = 0; j < func[i]->len; j++, insn++) {\n\t\t\tif (bpf_pseudo_func(insn)) {\n\t\t\t\tsubprog = insn[1].imm;\n\t\t\t\tinsn[0].imm = (u32)(long)func[subprog]->bpf_func;\n\t\t\t\tinsn[1].imm = ((u64)(long)func[subprog]->bpf_func) >> 32;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!bpf_pseudo_call(insn))\n\t\t\t\tcontinue;\n\t\t\tsubprog = insn->off;\n\t\t\tinsn->imm = BPF_CAST_CALL(func[subprog]->bpf_func) -\n\t\t\t\t    __bpf_call_base;\n\t\t}\n\n\t\t/* we use the aux data to keep a list of the start addresses\n\t\t * of the JITed images for each function in the program\n\t\t *\n\t\t * for some architectures, such as powerpc64, the imm field\n\t\t * might not be large enough to hold the offset of the start\n\t\t * address of the callee's JITed image from __bpf_call_base\n\t\t *\n\t\t * in such cases, we can lookup the start address of a callee\n\t\t * by using its subprog id, available from the off field of\n\t\t * the call instruction, as an index for this list\n\t\t */\n\t\tfunc[i]->aux->func = func;\n\t\tfunc[i]->aux->func_cnt = env->subprog_cnt;\n\t}\n\tfor (i = 0; i < env->subprog_cnt; i++) {\n\t\told_bpf_func = func[i]->bpf_func;\n\t\ttmp = bpf_int_jit_compile(func[i]);\n\t\tif (tmp != func[i] || func[i]->bpf_func != old_bpf_func) {\n\t\t\tverbose(env, \"JIT doesn't support bpf-to-bpf calls\\n\");\n\t\t\terr = -ENOTSUPP;\n\t\t\tgoto out_free;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\t/* finally lock prog and jit images for all functions and\n\t * populate kallsysm\n\t */\n\tfor (i = 0; i < env->subprog_cnt; i++) {\n\t\tbpf_prog_lock_ro(func[i]);\n\t\tbpf_prog_kallsyms_add(func[i]);\n\t}\n\n\t/* Last step: make now unused interpreter insns from main\n\t * prog consistent for later dump requests, so they can\n\t * later look the same as if they were interpreted only.\n\t */\n\tfor (i = 0, insn = prog->insnsi; i < prog->len; i++, insn++) {\n\t\tif (bpf_pseudo_func(insn)) {\n\t\t\tinsn[0].imm = env->insn_aux_data[i].call_imm;\n\t\t\tinsn[1].imm = find_subprog(env, i + insn[0].imm + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!bpf_pseudo_call(insn))\n\t\t\tcontinue;\n\t\tinsn->off = env->insn_aux_data[i].call_imm;\n\t\tsubprog = find_subprog(env, i + insn->off + 1);\n\t\tinsn->imm = subprog;\n\t}\n\n\tprog->jited = 1;\n\tprog->bpf_func = func[0]->bpf_func;\n\tprog->aux->func = func;\n\tprog->aux->func_cnt = env->subprog_cnt;\n\tbpf_prog_free_unused_jited_linfo(prog);\n\treturn 0;\nout_free:\n\tfor (i = 0; i < env->subprog_cnt; i++) {\n\t\tif (!func[i])\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < func[i]->aux->size_poke_tab; j++) {\n\t\t\tmap_ptr = func[i]->aux->poke_tab[j].tail_call.map;\n\t\t\tmap_ptr->ops->map_poke_untrack(map_ptr, func[i]->aux);\n\t\t}\n\t\tbpf_jit_free(func[i]);\n\t}\n\tkfree(func);\nout_undo_insn:\n\t/* cleanup main prog to be interpreted */\n\tprog->jit_requested = 0;\n\tfor (i = 0, insn = prog->insnsi; i < prog->len; i++, insn++) {\n\t\tif (!bpf_pseudo_call(insn))\n\t\t\tcontinue;\n\t\tinsn->off = 0;\n\t\tinsn->imm = env->insn_aux_data[i].call_imm;\n\t}\n\tbpf_prog_free_jited_linfo(prog);\n\treturn err;\n}\n\nstatic int fixup_call_args(struct bpf_verifier_env *env)\n{\n#ifndef CONFIG_BPF_JIT_ALWAYS_ON\n\tstruct bpf_prog *prog = env->prog;\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint i, depth;\n#endif\n\tint err = 0;\n\n\tif (env->prog->jit_requested &&\n\t    !bpf_prog_is_dev_bound(env->prog->aux)) {\n\t\terr = jit_subprogs(env);\n\t\tif (err == 0)\n\t\t\treturn 0;\n\t\tif (err == -EFAULT)\n\t\t\treturn err;\n\t}\n#ifndef CONFIG_BPF_JIT_ALWAYS_ON\n\tif (env->subprog_cnt > 1 && env->prog->aux->tail_call_reachable) {\n\t\t/* When JIT fails the progs with bpf2bpf calls and tail_calls\n\t\t * have to be rejected, since interpreter doesn't support them yet.\n\t\t */\n\t\tverbose(env, \"tail_calls are not allowed in non-JITed programs with bpf-to-bpf calls\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < prog->len; i++, insn++) {\n\t\tif (bpf_pseudo_func(insn)) {\n\t\t\t/* When JIT fails the progs with callback calls\n\t\t\t * have to be rejected, since interpreter doesn't support them yet.\n\t\t\t */\n\t\t\tverbose(env, \"callbacks are not allowed in non-JITed programs\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!bpf_pseudo_call(insn))\n\t\t\tcontinue;\n\t\tdepth = get_callee_stack_depth(env, insn, i);\n\t\tif (depth < 0)\n\t\t\treturn depth;\n\t\tbpf_patch_call_args(insn, depth);\n\t}\n\terr = 0;\n#endif\n\treturn err;\n}\n\n/* Do various post-verification rewrites in a single program pass.\n * These rewrites simplify JIT and interpreter implementations.\n */\nstatic int do_misc_fixups(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\t/* Make divide-by-zero exceptions impossible. */\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* [R,W]x div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* [R,W]x mod 0 -> [R,W]x */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1 + (is64 ? 0 : 1), 0),\n\t\t\t\t*insn,\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\tBPF_MOV32_REG(insn->dst_reg, insn->dst_reg),\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod) - (is64 ? 2 : 0);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Implement LD_ABS and LD_IND with a rewrite, if supported by the program type. */\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Rewrite pointer arithmetic to mitigate speculation attacks. */\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem   ||\n\t\t     insn->imm == BPF_FUNC_redirect_map)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_redirect,\n\t\t\t\t     (int (*)(struct bpf_map *map, u32 ifindex, u64 flags))NULL));\n\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_redirect_map:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_redirect) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\t/* Implement bpf_jiffies64 inline. */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void free_states(struct bpf_verifier_env *env)\n{\n\tstruct bpf_verifier_state_list *sl, *sln;\n\tint i;\n\n\tsl = env->free_list;\n\twhile (sl) {\n\t\tsln = sl->next;\n\t\tfree_verifier_state(&sl->state, false);\n\t\tkfree(sl);\n\t\tsl = sln;\n\t}\n\tenv->free_list = NULL;\n\n\tif (!env->explored_states)\n\t\treturn;\n\n\tfor (i = 0; i < state_htab_size(env); i++) {\n\t\tsl = env->explored_states[i];\n\n\t\twhile (sl) {\n\t\t\tsln = sl->next;\n\t\t\tfree_verifier_state(&sl->state, false);\n\t\t\tkfree(sl);\n\t\t\tsl = sln;\n\t\t}\n\t\tenv->explored_states[i] = NULL;\n\t}\n}\n\n/* The verifier is using insn_aux_data[] to store temporary data during\n * verification and to store information for passes that run after the\n * verification like dead code sanitization. do_check_common() for subprogram N\n * may analyze many other subprograms. sanitize_insn_aux_data() clears all\n * temporary data after do_check_common() finds that subprogram N cannot be\n * verified independently. pass_cnt counts the number of times\n * do_check_common() was run and insn->aux->seen tells the pass number\n * insn_aux_data was touched. These variables are compared to clear temporary\n * data from failed pass. For testing and experiments do_check_common() can be\n * run multiple times even when prior attempt to verify is unsuccessful.\n */\nstatic void sanitize_insn_aux_data(struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tstruct bpf_insn_aux_data *aux;\n\tint i, class;\n\n\tfor (i = 0; i < env->prog->len; i++) {\n\t\tclass = BPF_CLASS(insn[i].code);\n\t\tif (class != BPF_LDX && class != BPF_STX)\n\t\t\tcontinue;\n\t\taux = &env->insn_aux_data[i];\n\t\tif (aux->seen != env->pass_cnt)\n\t\t\tcontinue;\n\t\tmemset(aux, 0, offsetof(typeof(*aux), orig_idx));\n\t}\n}\n\nstatic int do_check_common(struct bpf_verifier_env *env, int subprog)\n{\n\tbool pop_log = !(env->log.level & BPF_LOG_LEVEL2);\n\tstruct bpf_verifier_state *state;\n\tstruct bpf_reg_state *regs;\n\tint ret, i;\n\n\tenv->prev_linfo = NULL;\n\tenv->pass_cnt++;\n\n\tstate = kzalloc(sizeof(struct bpf_verifier_state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\tstate->curframe = 0;\n\tstate->speculative = false;\n\tstate->branches = 1;\n\tstate->frame[0] = kzalloc(sizeof(struct bpf_func_state), GFP_KERNEL);\n\tif (!state->frame[0]) {\n\t\tkfree(state);\n\t\treturn -ENOMEM;\n\t}\n\tenv->cur_state = state;\n\tinit_func_state(env, state->frame[0],\n\t\t\tBPF_MAIN_FUNC /* callsite */,\n\t\t\t0 /* frameno */,\n\t\t\tsubprog);\n\n\tregs = state->frame[state->curframe]->regs;\n\tif (subprog || env->prog->type == BPF_PROG_TYPE_EXT) {\n\t\tret = btf_prepare_func_args(env, subprog, regs);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tfor (i = BPF_REG_1; i <= BPF_REG_5; i++) {\n\t\t\tif (regs[i].type == PTR_TO_CTX)\n\t\t\t\tmark_reg_known_zero(env, regs, i);\n\t\t\telse if (regs[i].type == SCALAR_VALUE)\n\t\t\t\tmark_reg_unknown(env, regs, i);\n\t\t\telse if (regs[i].type == PTR_TO_MEM_OR_NULL) {\n\t\t\t\tconst u32 mem_size = regs[i].mem_size;\n\n\t\t\t\tmark_reg_known_zero(env, regs, i);\n\t\t\t\tregs[i].mem_size = mem_size;\n\t\t\t\tregs[i].id = ++env->id_gen;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* 1st arg to a function */\n\t\tregs[BPF_REG_1].type = PTR_TO_CTX;\n\t\tmark_reg_known_zero(env, regs, BPF_REG_1);\n\t\tret = btf_check_func_arg_match(env, subprog, regs);\n\t\tif (ret == -EFAULT)\n\t\t\t/* unlikely verifier bug. abort.\n\t\t\t * ret == 0 and ret < 0 are sadly acceptable for\n\t\t\t * main() function due to backward compatibility.\n\t\t\t * Like socket filter program may be written as:\n\t\t\t * int bpf_prog(struct pt_regs *ctx)\n\t\t\t * and never dereference that ctx in the program.\n\t\t\t * 'struct pt_regs' is a type mismatch for socket\n\t\t\t * filter that should be using 'struct __sk_buff'.\n\t\t\t */\n\t\t\tgoto out;\n\t}\n\n\tret = do_check(env);\nout:\n\t/* check for NULL is necessary, since cur_state can be freed inside\n\t * do_check() under memory pressure.\n\t */\n\tif (env->cur_state) {\n\t\tfree_verifier_state(env->cur_state, true);\n\t\tenv->cur_state = NULL;\n\t}\n\twhile (!pop_stack(env, NULL, NULL, false));\n\tif (!ret && pop_log)\n\t\tbpf_vlog_reset(&env->log, 0);\n\tfree_states(env);\n\tif (ret)\n\t\t/* clean aux data in case subprog was rejected */\n\t\tsanitize_insn_aux_data(env);\n\treturn ret;\n}\n\n/* Verify all global functions in a BPF program one by one based on their BTF.\n * All global functions must pass verification. Otherwise the whole program is rejected.\n * Consider:\n * int bar(int);\n * int foo(int f)\n * {\n *    return bar(f);\n * }\n * int bar(int b)\n * {\n *    ...\n * }\n * foo() will be verified first for R1=any_scalar_value. During verification it\n * will be assumed that bar() already verified successfully and call to bar()\n * from foo() will be checked for type match only. Later bar() will be verified\n * independently to check that it's safe for R1=any_scalar_value.\n */\nstatic int do_check_subprogs(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog_aux *aux = env->prog->aux;\n\tint i, ret;\n\n\tif (!aux->func_info)\n\t\treturn 0;\n\n\tfor (i = 1; i < env->subprog_cnt; i++) {\n\t\tif (aux->func_info_aux[i].linkage != BTF_FUNC_GLOBAL)\n\t\t\tcontinue;\n\t\tenv->insn_idx = env->subprog_info[i].start;\n\t\tWARN_ON_ONCE(env->insn_idx == 0);\n\t\tret = do_check_common(env, i);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t} else if (env->log.level & BPF_LOG_LEVEL) {\n\t\t\tverbose(env,\n\t\t\t\t\"Func#%d is safe for any args that match its prototype\\n\",\n\t\t\t\ti);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int do_check_main(struct bpf_verifier_env *env)\n{\n\tint ret;\n\n\tenv->insn_idx = 0;\n\tret = do_check_common(env, 0);\n\tif (!ret)\n\t\tenv->prog->aux->stack_depth = env->subprog_info[0].stack_depth;\n\treturn ret;\n}\n\n\nstatic void print_verification_stats(struct bpf_verifier_env *env)\n{\n\tint i;\n\n\tif (env->log.level & BPF_LOG_STATS) {\n\t\tverbose(env, \"verification time %lld usec\\n\",\n\t\t\tdiv_u64(env->verification_time, 1000));\n\t\tverbose(env, \"stack depth \");\n\t\tfor (i = 0; i < env->subprog_cnt; i++) {\n\t\t\tu32 depth = env->subprog_info[i].stack_depth;\n\n\t\t\tverbose(env, \"%d\", depth);\n\t\t\tif (i + 1 < env->subprog_cnt)\n\t\t\t\tverbose(env, \"+\");\n\t\t}\n\t\tverbose(env, \"\\n\");\n\t}\n\tverbose(env, \"processed %d insns (limit %d) max_states_per_insn %d \"\n\t\t\"total_states %d peak_states %d mark_read %d\\n\",\n\t\tenv->insn_processed, BPF_COMPLEXITY_LIMIT_INSNS,\n\t\tenv->max_states_per_insn, env->total_states,\n\t\tenv->peak_states, env->longest_mark_read_walk);\n}\n\nstatic int check_struct_ops_btf_id(struct bpf_verifier_env *env)\n{\n\tconst struct btf_type *t, *func_proto;\n\tconst struct bpf_struct_ops *st_ops;\n\tconst struct btf_member *member;\n\tstruct bpf_prog *prog = env->prog;\n\tu32 btf_id, member_idx;\n\tconst char *mname;\n\n\tbtf_id = prog->aux->attach_btf_id;\n\tst_ops = bpf_struct_ops_find(btf_id);\n\tif (!st_ops) {\n\t\tverbose(env, \"attach_btf_id %u is not a supported struct\\n\",\n\t\t\tbtf_id);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tt = st_ops->type;\n\tmember_idx = prog->expected_attach_type;\n\tif (member_idx >= btf_type_vlen(t)) {\n\t\tverbose(env, \"attach to invalid member idx %u of struct %s\\n\",\n\t\t\tmember_idx, st_ops->name);\n\t\treturn -EINVAL;\n\t}\n\n\tmember = &btf_type_member(t)[member_idx];\n\tmname = btf_name_by_offset(btf_vmlinux, member->name_off);\n\tfunc_proto = btf_type_resolve_func_ptr(btf_vmlinux, member->type,\n\t\t\t\t\t       NULL);\n\tif (!func_proto) {\n\t\tverbose(env, \"attach to invalid member %s(@idx %u) of struct %s\\n\",\n\t\t\tmname, member_idx, st_ops->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (st_ops->check_member) {\n\t\tint err = st_ops->check_member(t, member);\n\n\t\tif (err) {\n\t\t\tverbose(env, \"attach to unsupported member %s of struct %s\\n\",\n\t\t\t\tmname, st_ops->name);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tprog->aux->attach_func_proto = func_proto;\n\tprog->aux->attach_func_name = mname;\n\tenv->ops = st_ops->verifier_ops;\n\n\treturn 0;\n}\n#define SECURITY_PREFIX \"security_\"\n\nstatic int check_attach_modify_return(unsigned long addr, const char *func_name)\n{\n\tif (within_error_injection_list(addr) ||\n\t    !strncmp(SECURITY_PREFIX, func_name, sizeof(SECURITY_PREFIX) - 1))\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\n/* list of non-sleepable functions that are otherwise on\n * ALLOW_ERROR_INJECTION list\n */\nBTF_SET_START(btf_non_sleepable_error_inject)\n/* Three functions below can be called from sleepable and non-sleepable context.\n * Assume non-sleepable from bpf safety point of view.\n */\nBTF_ID(func, __add_to_page_cache_locked)\nBTF_ID(func, should_fail_alloc_page)\nBTF_ID(func, should_failslab)\nBTF_SET_END(btf_non_sleepable_error_inject)\n\nstatic int check_non_sleepable_error_inject(u32 btf_id)\n{\n\treturn btf_id_set_contains(&btf_non_sleepable_error_inject, btf_id);\n}\n\nint bpf_check_attach_target(struct bpf_verifier_log *log,\n\t\t\t    const struct bpf_prog *prog,\n\t\t\t    const struct bpf_prog *tgt_prog,\n\t\t\t    u32 btf_id,\n\t\t\t    struct bpf_attach_target_info *tgt_info)\n{\n\tbool prog_extension = prog->type == BPF_PROG_TYPE_EXT;\n\tconst char prefix[] = \"btf_trace_\";\n\tint ret = 0, subprog = -1, i;\n\tconst struct btf_type *t;\n\tbool conservative = true;\n\tconst char *tname;\n\tstruct btf *btf;\n\tlong addr = 0;\n\n\tif (!btf_id) {\n\t\tbpf_log(log, \"Tracing programs must provide btf_id\\n\");\n\t\treturn -EINVAL;\n\t}\n\tbtf = tgt_prog ? tgt_prog->aux->btf : prog->aux->attach_btf;\n\tif (!btf) {\n\t\tbpf_log(log,\n\t\t\t\"FENTRY/FEXIT program can only be attached to another program annotated with BTF\\n\");\n\t\treturn -EINVAL;\n\t}\n\tt = btf_type_by_id(btf, btf_id);\n\tif (!t) {\n\t\tbpf_log(log, \"attach_btf_id %u is invalid\\n\", btf_id);\n\t\treturn -EINVAL;\n\t}\n\ttname = btf_name_by_offset(btf, t->name_off);\n\tif (!tname) {\n\t\tbpf_log(log, \"attach_btf_id %u doesn't have a name\\n\", btf_id);\n\t\treturn -EINVAL;\n\t}\n\tif (tgt_prog) {\n\t\tstruct bpf_prog_aux *aux = tgt_prog->aux;\n\n\t\tfor (i = 0; i < aux->func_info_cnt; i++)\n\t\t\tif (aux->func_info[i].type_id == btf_id) {\n\t\t\t\tsubprog = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (subprog == -1) {\n\t\t\tbpf_log(log, \"Subprog %s doesn't exist\\n\", tname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tconservative = aux->func_info_aux[subprog].unreliable;\n\t\tif (prog_extension) {\n\t\t\tif (conservative) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"Cannot replace static functions\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (!prog->jit_requested) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"Extension programs should be JITed\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (!tgt_prog->jited) {\n\t\t\tbpf_log(log, \"Can attach to only JITed progs\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tgt_prog->type == prog->type) {\n\t\t\t/* Cannot fentry/fexit another fentry/fexit program.\n\t\t\t * Cannot attach program extension to another extension.\n\t\t\t * It's ok to attach fentry/fexit to extension program.\n\t\t\t */\n\t\t\tbpf_log(log, \"Cannot recursively attach\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tgt_prog->type == BPF_PROG_TYPE_TRACING &&\n\t\t    prog_extension &&\n\t\t    (tgt_prog->expected_attach_type == BPF_TRACE_FENTRY ||\n\t\t     tgt_prog->expected_attach_type == BPF_TRACE_FEXIT)) {\n\t\t\t/* Program extensions can extend all program types\n\t\t\t * except fentry/fexit. The reason is the following.\n\t\t\t * The fentry/fexit programs are used for performance\n\t\t\t * analysis, stats and can be attached to any program\n\t\t\t * type except themselves. When extension program is\n\t\t\t * replacing XDP function it is necessary to allow\n\t\t\t * performance analysis of all functions. Both original\n\t\t\t * XDP program and its program extension. Hence\n\t\t\t * attaching fentry/fexit to BPF_PROG_TYPE_EXT is\n\t\t\t * allowed. If extending of fentry/fexit was allowed it\n\t\t\t * would be possible to create long call chain\n\t\t\t * fentry->extension->fentry->extension beyond\n\t\t\t * reasonable stack size. Hence extending fentry is not\n\t\t\t * allowed.\n\t\t\t */\n\t\t\tbpf_log(log, \"Cannot extend fentry/fexit\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (prog_extension) {\n\t\t\tbpf_log(log, \"Cannot replace kernel functions\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (prog->expected_attach_type) {\n\tcase BPF_TRACE_RAW_TP:\n\t\tif (tgt_prog) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"Only FENTRY/FEXIT progs are attachable to another BPF prog\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!btf_type_is_typedef(t)) {\n\t\t\tbpf_log(log, \"attach_btf_id %u is not a typedef\\n\",\n\t\t\t\tbtf_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (strncmp(prefix, tname, sizeof(prefix) - 1)) {\n\t\t\tbpf_log(log, \"attach_btf_id %u points to wrong type name %s\\n\",\n\t\t\t\tbtf_id, tname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttname += sizeof(prefix) - 1;\n\t\tt = btf_type_by_id(btf, t->type);\n\t\tif (!btf_type_is_ptr(t))\n\t\t\t/* should never happen in valid vmlinux build */\n\t\t\treturn -EINVAL;\n\t\tt = btf_type_by_id(btf, t->type);\n\t\tif (!btf_type_is_func_proto(t))\n\t\t\t/* should never happen in valid vmlinux build */\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\tcase BPF_TRACE_ITER:\n\t\tif (!btf_type_is_func(t)) {\n\t\t\tbpf_log(log, \"attach_btf_id %u is not a function\\n\",\n\t\t\t\tbtf_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tt = btf_type_by_id(btf, t->type);\n\t\tif (!btf_type_is_func_proto(t))\n\t\t\treturn -EINVAL;\n\t\tret = btf_distill_func_proto(log, btf, t, tname, &tgt_info->fmodel);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tif (!prog_extension)\n\t\t\treturn -EINVAL;\n\t\tfallthrough;\n\tcase BPF_MODIFY_RETURN:\n\tcase BPF_LSM_MAC:\n\tcase BPF_TRACE_FENTRY:\n\tcase BPF_TRACE_FEXIT:\n\t\tif (!btf_type_is_func(t)) {\n\t\t\tbpf_log(log, \"attach_btf_id %u is not a function\\n\",\n\t\t\t\tbtf_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (prog_extension &&\n\t\t    btf_check_type_match(log, prog, btf, t))\n\t\t\treturn -EINVAL;\n\t\tt = btf_type_by_id(btf, t->type);\n\t\tif (!btf_type_is_func_proto(t))\n\t\t\treturn -EINVAL;\n\n\t\tif ((prog->aux->saved_dst_prog_type || prog->aux->saved_dst_attach_type) &&\n\t\t    (!tgt_prog || prog->aux->saved_dst_prog_type != tgt_prog->type ||\n\t\t     prog->aux->saved_dst_attach_type != tgt_prog->expected_attach_type))\n\t\t\treturn -EINVAL;\n\n\t\tif (tgt_prog && conservative)\n\t\t\tt = NULL;\n\n\t\tret = btf_distill_func_proto(log, btf, t, tname, &tgt_info->fmodel);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (tgt_prog) {\n\t\t\tif (subprog == 0)\n\t\t\t\taddr = (long) tgt_prog->bpf_func;\n\t\t\telse\n\t\t\t\taddr = (long) tgt_prog->aux->func[subprog]->bpf_func;\n\t\t} else {\n\t\t\taddr = kallsyms_lookup_name(tname);\n\t\t\tif (!addr) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"The address of function %s cannot be found\\n\",\n\t\t\t\t\ttname);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t}\n\n\t\tif (prog->aux->sleepable) {\n\t\t\tret = -EINVAL;\n\t\t\tswitch (prog->type) {\n\t\t\tcase BPF_PROG_TYPE_TRACING:\n\t\t\t\t/* fentry/fexit/fmod_ret progs can be sleepable only if they are\n\t\t\t\t * attached to ALLOW_ERROR_INJECTION and are not in denylist.\n\t\t\t\t */\n\t\t\t\tif (!check_non_sleepable_error_inject(btf_id) &&\n\t\t\t\t    within_error_injection_list(addr))\n\t\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\tcase BPF_PROG_TYPE_LSM:\n\t\t\t\t/* LSM progs check that they are attached to bpf_lsm_*() funcs.\n\t\t\t\t * Only some of them are sleepable.\n\t\t\t\t */\n\t\t\t\tif (bpf_lsm_is_sleepable_hook(btf_id))\n\t\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\tbpf_log(log, \"%s is not sleepable\\n\", tname);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else if (prog->expected_attach_type == BPF_MODIFY_RETURN) {\n\t\t\tif (tgt_prog) {\n\t\t\t\tbpf_log(log, \"can't modify return codes of BPF programs\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tret = check_attach_modify_return(addr, tname);\n\t\t\tif (ret) {\n\t\t\t\tbpf_log(log, \"%s() is not modifiable\\n\", tname);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\ttgt_info->tgt_addr = addr;\n\ttgt_info->tgt_name = tname;\n\ttgt_info->tgt_type = t;\n\treturn 0;\n}\n\nstatic int check_attach_btf_id(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tstruct bpf_prog *tgt_prog = prog->aux->dst_prog;\n\tstruct bpf_attach_target_info tgt_info = {};\n\tu32 btf_id = prog->aux->attach_btf_id;\n\tstruct bpf_trampoline *tr;\n\tint ret;\n\tu64 key;\n\n\tif (prog->aux->sleepable && prog->type != BPF_PROG_TYPE_TRACING &&\n\t    prog->type != BPF_PROG_TYPE_LSM) {\n\t\tverbose(env, \"Only fentry/fexit/fmod_ret and lsm programs can be sleepable\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (prog->type == BPF_PROG_TYPE_STRUCT_OPS)\n\t\treturn check_struct_ops_btf_id(env);\n\n\tif (prog->type != BPF_PROG_TYPE_TRACING &&\n\t    prog->type != BPF_PROG_TYPE_LSM &&\n\t    prog->type != BPF_PROG_TYPE_EXT)\n\t\treturn 0;\n\n\tret = bpf_check_attach_target(&env->log, prog, tgt_prog, btf_id, &tgt_info);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tgt_prog && prog->type == BPF_PROG_TYPE_EXT) {\n\t\t/* to make freplace equivalent to their targets, they need to\n\t\t * inherit env->ops and expected_attach_type for the rest of the\n\t\t * verification\n\t\t */\n\t\tenv->ops = bpf_verifier_ops[tgt_prog->type];\n\t\tprog->expected_attach_type = tgt_prog->expected_attach_type;\n\t}\n\n\t/* store info about the attachment target that will be used later */\n\tprog->aux->attach_func_proto = tgt_info.tgt_type;\n\tprog->aux->attach_func_name = tgt_info.tgt_name;\n\n\tif (tgt_prog) {\n\t\tprog->aux->saved_dst_prog_type = tgt_prog->type;\n\t\tprog->aux->saved_dst_attach_type = tgt_prog->expected_attach_type;\n\t}\n\n\tif (prog->expected_attach_type == BPF_TRACE_RAW_TP) {\n\t\tprog->aux->attach_btf_trace = true;\n\t\treturn 0;\n\t} else if (prog->expected_attach_type == BPF_TRACE_ITER) {\n\t\tif (!bpf_iter_prog_supported(prog))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\tif (prog->type == BPF_PROG_TYPE_LSM) {\n\t\tret = bpf_lsm_verify_prog(&env->log, prog);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tkey = bpf_trampoline_compute_key(tgt_prog, prog->aux->attach_btf, btf_id);\n\ttr = bpf_trampoline_get(key, &tgt_info);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\tprog->aux->dst_trampoline = tr;\n\treturn 0;\n}\n\nstruct btf *bpf_get_btf_vmlinux(void)\n{\n\tif (!btf_vmlinux && IS_ENABLED(CONFIG_DEBUG_INFO_BTF)) {\n\t\tmutex_lock(&bpf_verifier_lock);\n\t\tif (!btf_vmlinux)\n\t\t\tbtf_vmlinux = btf_parse_vmlinux();\n\t\tmutex_unlock(&bpf_verifier_lock);\n\t}\n\treturn btf_vmlinux;\n}\n\nint bpf_check(struct bpf_prog **prog, union bpf_attr *attr,\n\t      union bpf_attr __user *uattr)\n{\n\tu64 start_time = ktime_get_ns();\n\tstruct bpf_verifier_env *env;\n\tstruct bpf_verifier_log *log;\n\tint i, len, ret = -EINVAL;\n\tbool is_priv;\n\n\t/* no program is valid */\n\tif (ARRAY_SIZE(bpf_verifier_ops) == 0)\n\t\treturn -EINVAL;\n\n\t/* 'struct bpf_verifier_env' can be global, but since it's not small,\n\t * allocate/free it every time bpf_check() is called\n\t */\n\tenv = kzalloc(sizeof(struct bpf_verifier_env), GFP_KERNEL);\n\tif (!env)\n\t\treturn -ENOMEM;\n\tlog = &env->log;\n\n\tlen = (*prog)->len;\n\tenv->insn_aux_data =\n\t\tvzalloc(array_size(sizeof(struct bpf_insn_aux_data), len));\n\tret = -ENOMEM;\n\tif (!env->insn_aux_data)\n\t\tgoto err_free_env;\n\tfor (i = 0; i < len; i++)\n\t\tenv->insn_aux_data[i].orig_idx = i;\n\tenv->prog = *prog;\n\tenv->ops = bpf_verifier_ops[env->prog->type];\n\tis_priv = bpf_capable();\n\n\tbpf_get_btf_vmlinux();\n\n\t/* grab the mutex to protect few globals used by verifier */\n\tif (!is_priv)\n\t\tmutex_lock(&bpf_verifier_lock);\n\n\tif (attr->log_level || attr->log_buf || attr->log_size) {\n\t\t/* user requested verbose verifier output\n\t\t * and supplied buffer to store the verification trace\n\t\t */\n\t\tlog->level = attr->log_level;\n\t\tlog->ubuf = (char __user *) (unsigned long) attr->log_buf;\n\t\tlog->len_total = attr->log_size;\n\n\t\tret = -EINVAL;\n\t\t/* log attributes have to be sane */\n\t\tif (log->len_total < 128 || log->len_total > UINT_MAX >> 2 ||\n\t\t    !log->level || !log->ubuf || log->level & ~BPF_LOG_MASK)\n\t\t\tgoto err_unlock;\n\t}\n\n\tif (IS_ERR(btf_vmlinux)) {\n\t\t/* Either gcc or pahole or kernel are broken. */\n\t\tverbose(env, \"in-kernel BTF is malformed\\n\");\n\t\tret = PTR_ERR(btf_vmlinux);\n\t\tgoto skip_full_check;\n\t}\n\n\tenv->strict_alignment = !!(attr->prog_flags & BPF_F_STRICT_ALIGNMENT);\n\tif (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS))\n\t\tenv->strict_alignment = true;\n\tif (attr->prog_flags & BPF_F_ANY_ALIGNMENT)\n\t\tenv->strict_alignment = false;\n\n\tenv->allow_ptr_leaks = bpf_allow_ptr_leaks();\n\tenv->allow_uninit_stack = bpf_allow_uninit_stack();\n\tenv->allow_ptr_to_map_access = bpf_allow_ptr_to_map_access();\n\tenv->bypass_spec_v1 = bpf_bypass_spec_v1();\n\tenv->bypass_spec_v4 = bpf_bypass_spec_v4();\n\tenv->bpf_capable = bpf_capable();\n\n\tif (is_priv)\n\t\tenv->test_state_freq = attr->prog_flags & BPF_F_TEST_STATE_FREQ;\n\n\tif (bpf_prog_is_dev_bound(env->prog->aux)) {\n\t\tret = bpf_prog_offload_verifier_prep(env->prog);\n\t\tif (ret)\n\t\t\tgoto skip_full_check;\n\t}\n\n\tenv->explored_states = kvcalloc(state_htab_size(env),\n\t\t\t\t       sizeof(struct bpf_verifier_state_list *),\n\t\t\t\t       GFP_USER);\n\tret = -ENOMEM;\n\tif (!env->explored_states)\n\t\tgoto skip_full_check;\n\n\tret = check_subprogs(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tret = check_btf_info(env, attr, uattr);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tret = check_attach_btf_id(env);\n\tif (ret)\n\t\tgoto skip_full_check;\n\n\tret = resolve_pseudo_ldimm64(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tret = check_cfg(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tret = do_check_subprogs(env);\n\tret = ret ?: do_check_main(env);\n\n\tif (ret == 0 && bpf_prog_is_dev_bound(env->prog->aux))\n\t\tret = bpf_prog_offload_finalize(env);\n\nskip_full_check:\n\tkvfree(env->explored_states);\n\n\tif (ret == 0)\n\t\tret = check_max_stack_depth(env);\n\n\t/* instruction rewrites happen after this point */\n\tif (is_priv) {\n\t\tif (ret == 0)\n\t\t\topt_hard_wire_dead_code_branches(env);\n\t\tif (ret == 0)\n\t\t\tret = opt_remove_dead_code(env);\n\t\tif (ret == 0)\n\t\t\tret = opt_remove_nops(env);\n\t} else {\n\t\tif (ret == 0)\n\t\t\tsanitize_dead_code(env);\n\t}\n\n\tif (ret == 0)\n\t\t/* program is valid, convert *(u32*)(ctx + off) accesses */\n\t\tret = convert_ctx_accesses(env);\n\n\tif (ret == 0)\n\t\tret = do_misc_fixups(env);\n\n\t/* do 32-bit optimization after insn patching has done so those patched\n\t * insns could be handled correctly.\n\t */\n\tif (ret == 0 && !bpf_prog_is_dev_bound(env->prog->aux)) {\n\t\tret = opt_subreg_zext_lo32_rnd_hi32(env, attr);\n\t\tenv->prog->aux->verifier_zext = bpf_jit_needs_zext() ? !ret\n\t\t\t\t\t\t\t\t     : false;\n\t}\n\n\tif (ret == 0)\n\t\tret = fixup_call_args(env);\n\n\tenv->verification_time = ktime_get_ns() - start_time;\n\tprint_verification_stats(env);\n\n\tif (log->level && bpf_verifier_log_full(log))\n\t\tret = -ENOSPC;\n\tif (log->level && !log->ubuf) {\n\t\tret = -EFAULT;\n\t\tgoto err_release_maps;\n\t}\n\n\tif (ret)\n\t\tgoto err_release_maps;\n\n\tif (env->used_map_cnt) {\n\t\t/* if program passed verifier, update used_maps in bpf_prog_info */\n\t\tenv->prog->aux->used_maps = kmalloc_array(env->used_map_cnt,\n\t\t\t\t\t\t\t  sizeof(env->used_maps[0]),\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\n\t\tif (!env->prog->aux->used_maps) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_release_maps;\n\t\t}\n\n\t\tmemcpy(env->prog->aux->used_maps, env->used_maps,\n\t\t       sizeof(env->used_maps[0]) * env->used_map_cnt);\n\t\tenv->prog->aux->used_map_cnt = env->used_map_cnt;\n\t}\n\tif (env->used_btf_cnt) {\n\t\t/* if program passed verifier, update used_btfs in bpf_prog_aux */\n\t\tenv->prog->aux->used_btfs = kmalloc_array(env->used_btf_cnt,\n\t\t\t\t\t\t\t  sizeof(env->used_btfs[0]),\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!env->prog->aux->used_btfs) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_release_maps;\n\t\t}\n\n\t\tmemcpy(env->prog->aux->used_btfs, env->used_btfs,\n\t\t       sizeof(env->used_btfs[0]) * env->used_btf_cnt);\n\t\tenv->prog->aux->used_btf_cnt = env->used_btf_cnt;\n\t}\n\tif (env->used_map_cnt || env->used_btf_cnt) {\n\t\t/* program is valid. Convert pseudo bpf_ld_imm64 into generic\n\t\t * bpf_ld_imm64 instructions\n\t\t */\n\t\tconvert_pseudo_ld_imm64(env);\n\t}\n\n\tadjust_btf_func(env);\n\nerr_release_maps:\n\tif (!env->prog->aux->used_maps)\n\t\t/* if we didn't copy map pointers into bpf_prog_info, release\n\t\t * them now. Otherwise free_used_maps() will release them.\n\t\t */\n\t\trelease_maps(env);\n\tif (!env->prog->aux->used_btfs)\n\t\trelease_btfs(env);\n\n\t/* extension progs temporarily inherit the attach_type of their targets\n\t   for verification purposes, so set it back to zero before returning\n\t */\n\tif (env->prog->type == BPF_PROG_TYPE_EXT)\n\t\tenv->prog->expected_attach_type = 0;\n\n\t*prog = env->prog;\nerr_unlock:\n\tif (!is_priv)\n\t\tmutex_unlock(&bpf_verifier_lock);\n\tvfree(env->insn_aux_data);\nerr_free_env:\n\tkfree(env);\n\treturn ret;\n}\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 9556}, "message": "warn: ignoring unreachable code."}], "macros": [], "notes": [], "path": "/src/kernel/bpf/verifier.c", "reportHash": "38cbdc40ab93bac53eadcc09579ef82f", "checkerName": "smatch.check_unreachable", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 12128}, "message": "warn: ignoring unreachable code."}], "macros": [], "notes": [], "path": "/src/kernel/bpf/verifier.c", "reportHash": "2134700078cf9c99a1f87d5fc8d4e42b", "checkerName": "smatch.check_unreachable", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
