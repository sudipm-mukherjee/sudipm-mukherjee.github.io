<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/block/drbd/drbd_receiver.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n   drbd_receiver.c\n\n   This file is part of DRBD by Philipp Reisner and Lars Ellenberg.\n\n   Copyright (C) 2001-2008, LINBIT Information Technologies GmbH.\n   Copyright (C) 1999-2008, Philipp Reisner <philipp.reisner@linbit.com>.\n   Copyright (C) 2002-2008, Lars Ellenberg <lars.ellenberg@linbit.com>.\n\n */\n\n\n#include <linux/module.h>\n\n#include <linux/uaccess.h>\n#include <net/sock.h>\n\n#include <linux/drbd.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/in.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/mm_inline.h>\n#include <linux/slab.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/pkt_sched.h>\n#define __KERNEL_SYSCALLS__\n#include <linux/unistd.h>\n#include <linux/vmalloc.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/scatterlist.h>\n#include <linux/part_stat.h>\n#include \"drbd_int.h\"\n#include \"drbd_protocol.h\"\n#include \"drbd_req.h\"\n#include \"drbd_vli.h\"\n\n#define PRO_FEATURES (DRBD_FF_TRIM|DRBD_FF_THIN_RESYNC|DRBD_FF_WSAME|DRBD_FF_WZEROES)\n\nstruct packet_info {\n\tenum drbd_packet cmd;\n\tunsigned int size;\n\tunsigned int vnr;\n\tvoid *data;\n};\n\nenum finish_epoch {\n\tFE_STILL_LIVE,\n\tFE_DESTROYED,\n\tFE_RECYCLED,\n};\n\nstatic int drbd_do_features(struct drbd_connection *connection);\nstatic int drbd_do_auth(struct drbd_connection *connection);\nstatic int drbd_disconnected(struct drbd_peer_device *);\nstatic void conn_wait_active_ee_empty(struct drbd_connection *connection);\nstatic enum finish_epoch drbd_may_finish_epoch(struct drbd_connection *, struct drbd_epoch *, enum epoch_event);\nstatic int e_end_block(struct drbd_work *, int);\n\n\n#define GFP_TRY\t(__GFP_HIGHMEM | __GFP_NOWARN)\n\n/*\n * some helper functions to deal with single linked page lists,\n * page->private being our \"next\" pointer.\n */\n\n/* If at least n pages are linked at head, get n pages off.\n * Otherwise, don't modify head, and return NULL.\n * Locking is the responsibility of the caller.\n */\nstatic struct page *page_chain_del(struct page **head, int n)\n{\n\tstruct page *page;\n\tstruct page *tmp;\n\n\tBUG_ON(!n);\n\tBUG_ON(!head);\n\n\tpage = *head;\n\n\tif (!page)\n\t\treturn NULL;\n\n\twhile (page) {\n\t\ttmp = page_chain_next(page);\n\t\tif (--n == 0)\n\t\t\tbreak; /* found sufficient pages */\n\t\tif (tmp == NULL)\n\t\t\t/* insufficient pages, don't use any of them. */\n\t\t\treturn NULL;\n\t\tpage = tmp;\n\t}\n\n\t/* add end of list marker for the returned list */\n\tset_page_private(page, 0);\n\t/* actual return value, and adjustment of head */\n\tpage = *head;\n\t*head = tmp;\n\treturn page;\n}\n\n/* may be used outside of locks to find the tail of a (usually short)\n * \"private\" page chain, before adding it back to a global chain head\n * with page_chain_add() under a spinlock. */\nstatic struct page *page_chain_tail(struct page *page, int *len)\n{\n\tstruct page *tmp;\n\tint i = 1;\n\twhile ((tmp = page_chain_next(page)))\n\t\t++i, page = tmp;\n\tif (len)\n\t\t*len = i;\n\treturn page;\n}\n\nstatic int page_chain_free(struct page *page)\n{\n\tstruct page *tmp;\n\tint i = 0;\n\tpage_chain_for_each_safe(page, tmp) {\n\t\tput_page(page);\n\t\t++i;\n\t}\n\treturn i;\n}\n\nstatic void page_chain_add(struct page **head,\n\t\tstruct page *chain_first, struct page *chain_last)\n{\n#if 1\n\tstruct page *tmp;\n\ttmp = page_chain_tail(chain_first, NULL);\n\tBUG_ON(tmp != chain_last);\n#endif\n\n\t/* add chain to head */\n\tset_page_private(chain_last, (unsigned long)*head);\n\t*head = chain_first;\n}\n\nstatic struct page *__drbd_alloc_pages(struct drbd_device *device,\n\t\t\t\t       unsigned int number)\n{\n\tstruct page *page = NULL;\n\tstruct page *tmp = NULL;\n\tunsigned int i = 0;\n\n\t/* Yes, testing drbd_pp_vacant outside the lock is racy.\n\t * So what. It saves a spin_lock. */\n\tif (drbd_pp_vacant >= number) {\n\t\tspin_lock(&drbd_pp_lock);\n\t\tpage = page_chain_del(&drbd_pp_pool, number);\n\t\tif (page)\n\t\t\tdrbd_pp_vacant -= number;\n\t\tspin_unlock(&drbd_pp_lock);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\n\t/* GFP_TRY, because we must not cause arbitrary write-out: in a DRBD\n\t * \"criss-cross\" setup, that might cause write-out on some other DRBD,\n\t * which in turn might block on the other node at this very place.  */\n\tfor (i = 0; i < number; i++) {\n\t\ttmp = alloc_page(GFP_TRY);\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tset_page_private(tmp, (unsigned long)page);\n\t\tpage = tmp;\n\t}\n\n\tif (i == number)\n\t\treturn page;\n\n\t/* Not enough pages immediately available this time.\n\t * No need to jump around here, drbd_alloc_pages will retry this\n\t * function \"soon\". */\n\tif (page) {\n\t\ttmp = page_chain_tail(page, NULL);\n\t\tspin_lock(&drbd_pp_lock);\n\t\tpage_chain_add(&drbd_pp_pool, page, tmp);\n\t\tdrbd_pp_vacant += i;\n\t\tspin_unlock(&drbd_pp_lock);\n\t}\n\treturn NULL;\n}\n\nstatic void reclaim_finished_net_peer_reqs(struct drbd_device *device,\n\t\t\t\t\t   struct list_head *to_be_freed)\n{\n\tstruct drbd_peer_request *peer_req, *tmp;\n\n\t/* The EEs are always appended to the end of the list. Since\n\t   they are sent in order over the wire, they have to finish\n\t   in order. As soon as we see the first not finished we can\n\t   stop to examine the list... */\n\n\tlist_for_each_entry_safe(peer_req, tmp, &device->net_ee, w.list) {\n\t\tif (drbd_peer_req_has_active_page(peer_req))\n\t\t\tbreak;\n\t\tlist_move(&peer_req->w.list, to_be_freed);\n\t}\n}\n\nstatic void drbd_reclaim_net_peer_reqs(struct drbd_device *device)\n{\n\tLIST_HEAD(reclaimed);\n\tstruct drbd_peer_request *peer_req, *t;\n\n\tspin_lock_irq(&device->resource->req_lock);\n\treclaim_finished_net_peer_reqs(device, &reclaimed);\n\tspin_unlock_irq(&device->resource->req_lock);\n\tlist_for_each_entry_safe(peer_req, t, &reclaimed, w.list)\n\t\tdrbd_free_net_peer_req(device, peer_req);\n}\n\nstatic void conn_reclaim_net_peer_reqs(struct drbd_connection *connection)\n{\n\tstruct drbd_peer_device *peer_device;\n\tint vnr;\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\t\tif (!atomic_read(&device->pp_in_use_by_net))\n\t\t\tcontinue;\n\n\t\tkref_get(&device->kref);\n\t\trcu_read_unlock();\n\t\tdrbd_reclaim_net_peer_reqs(device);\n\t\tkref_put(&device->kref, drbd_destroy_device);\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\n}\n\n/**\n * drbd_alloc_pages() - Returns @number pages, retries forever (or until signalled)\n * @device:\tDRBD device.\n * @number:\tnumber of pages requested\n * @retry:\twhether to retry, if not enough pages are available right now\n *\n * Tries to allocate number pages, first from our own page pool, then from\n * the kernel.\n * Possibly retry until DRBD frees sufficient pages somewhere else.\n *\n * If this allocation would exceed the max_buffers setting, we throttle\n * allocation (schedule_timeout) to give the system some room to breathe.\n *\n * We do not use max-buffers as hard limit, because it could lead to\n * congestion and further to a distributed deadlock during online-verify or\n * (checksum based) resync, if the max-buffers, socket buffer sizes and\n * resync-rate settings are mis-configured.\n *\n * Returns a page chain linked via page->private.\n */\nstruct page *drbd_alloc_pages(struct drbd_peer_device *peer_device, unsigned int number,\n\t\t\t      bool retry)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tstruct page *page = NULL;\n\tstruct net_conf *nc;\n\tDEFINE_WAIT(wait);\n\tunsigned int mxb;\n\n\trcu_read_lock();\n\tnc = rcu_dereference(peer_device->connection->net_conf);\n\tmxb = nc ? nc->max_buffers : 1000000;\n\trcu_read_unlock();\n\n\tif (atomic_read(&device->pp_in_use) < mxb)\n\t\tpage = __drbd_alloc_pages(device, number);\n\n\t/* Try to keep the fast path fast, but occasionally we need\n\t * to reclaim the pages we lended to the network stack. */\n\tif (page && atomic_read(&device->pp_in_use_by_net) > 512)\n\t\tdrbd_reclaim_net_peer_reqs(device);\n\n\twhile (page == NULL) {\n\t\tprepare_to_wait(&drbd_pp_wait, &wait, TASK_INTERRUPTIBLE);\n\n\t\tdrbd_reclaim_net_peer_reqs(device);\n\n\t\tif (atomic_read(&device->pp_in_use) < mxb) {\n\t\t\tpage = __drbd_alloc_pages(device, number);\n\t\t\tif (page)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!retry)\n\t\t\tbreak;\n\n\t\tif (signal_pending(current)) {\n\t\t\tdrbd_warn(device, \"drbd_alloc_pages interrupted!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (schedule_timeout(HZ/10) == 0)\n\t\t\tmxb = UINT_MAX;\n\t}\n\tfinish_wait(&drbd_pp_wait, &wait);\n\n\tif (page)\n\t\tatomic_add(number, &device->pp_in_use);\n\treturn page;\n}\n\n/* Must not be used from irq, as that may deadlock: see drbd_alloc_pages.\n * Is also used from inside an other spin_lock_irq(&resource->req_lock);\n * Either links the page chain back to the global pool,\n * or returns all pages to the system. */\nstatic void drbd_free_pages(struct drbd_device *device, struct page *page, int is_net)\n{\n\tatomic_t *a = is_net ? &device->pp_in_use_by_net : &device->pp_in_use;\n\tint i;\n\n\tif (page == NULL)\n\t\treturn;\n\n\tif (drbd_pp_vacant > (DRBD_MAX_BIO_SIZE/PAGE_SIZE) * drbd_minor_count)\n\t\ti = page_chain_free(page);\n\telse {\n\t\tstruct page *tmp;\n\t\ttmp = page_chain_tail(page, &i);\n\t\tspin_lock(&drbd_pp_lock);\n\t\tpage_chain_add(&drbd_pp_pool, page, tmp);\n\t\tdrbd_pp_vacant += i;\n\t\tspin_unlock(&drbd_pp_lock);\n\t}\n\ti = atomic_sub_return(i, a);\n\tif (i < 0)\n\t\tdrbd_warn(device, \"ASSERTION FAILED: %s: %d < 0\\n\",\n\t\t\tis_net ? \"pp_in_use_by_net\" : \"pp_in_use\", i);\n\twake_up(&drbd_pp_wait);\n}\n\n/*\nYou need to hold the req_lock:\n _drbd_wait_ee_list_empty()\n\nYou must not have the req_lock:\n drbd_free_peer_req()\n drbd_alloc_peer_req()\n drbd_free_peer_reqs()\n drbd_ee_fix_bhs()\n drbd_finish_peer_reqs()\n drbd_clear_done_ee()\n drbd_wait_ee_list_empty()\n*/\n\n/* normal: payload_size == request size (bi_size)\n * w_same: payload_size == logical_block_size\n * trim: payload_size == 0 */\nstruct drbd_peer_request *\ndrbd_alloc_peer_req(struct drbd_peer_device *peer_device, u64 id, sector_t sector,\n\t\t    unsigned int request_size, unsigned int payload_size, gfp_t gfp_mask) __must_hold(local)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tstruct drbd_peer_request *peer_req;\n\tstruct page *page = NULL;\n\tunsigned nr_pages = (payload_size + PAGE_SIZE -1) >> PAGE_SHIFT;\n\n\tif (drbd_insert_fault(device, DRBD_FAULT_AL_EE))\n\t\treturn NULL;\n\n\tpeer_req = mempool_alloc(&drbd_ee_mempool, gfp_mask & ~__GFP_HIGHMEM);\n\tif (!peer_req) {\n\t\tif (!(gfp_mask & __GFP_NOWARN))\n\t\t\tdrbd_err(device, \"%s: allocation failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (nr_pages) {\n\t\tpage = drbd_alloc_pages(peer_device, nr_pages,\n\t\t\t\t\tgfpflags_allow_blocking(gfp_mask));\n\t\tif (!page)\n\t\t\tgoto fail;\n\t}\n\n\tmemset(peer_req, 0, sizeof(*peer_req));\n\tINIT_LIST_HEAD(&peer_req->w.list);\n\tdrbd_clear_interval(&peer_req->i);\n\tpeer_req->i.size = request_size;\n\tpeer_req->i.sector = sector;\n\tpeer_req->submit_jif = jiffies;\n\tpeer_req->peer_device = peer_device;\n\tpeer_req->pages = page;\n\t/*\n\t * The block_id is opaque to the receiver.  It is not endianness\n\t * converted, and sent back to the sender unchanged.\n\t */\n\tpeer_req->block_id = id;\n\n\treturn peer_req;\n\n fail:\n\tmempool_free(peer_req, &drbd_ee_mempool);\n\treturn NULL;\n}\n\nvoid __drbd_free_peer_req(struct drbd_device *device, struct drbd_peer_request *peer_req,\n\t\t       int is_net)\n{\n\tmight_sleep();\n\tif (peer_req->flags & EE_HAS_DIGEST)\n\t\tkfree(peer_req->digest);\n\tdrbd_free_pages(device, peer_req->pages, is_net);\n\tD_ASSERT(device, atomic_read(&peer_req->pending_bios) == 0);\n\tD_ASSERT(device, drbd_interval_empty(&peer_req->i));\n\tif (!expect(!(peer_req->flags & EE_CALL_AL_COMPLETE_IO))) {\n\t\tpeer_req->flags &= ~EE_CALL_AL_COMPLETE_IO;\n\t\tdrbd_al_complete_io(device, &peer_req->i);\n\t}\n\tmempool_free(peer_req, &drbd_ee_mempool);\n}\n\nint drbd_free_peer_reqs(struct drbd_device *device, struct list_head *list)\n{\n\tLIST_HEAD(work_list);\n\tstruct drbd_peer_request *peer_req, *t;\n\tint count = 0;\n\tint is_net = list == &device->net_ee;\n\n\tspin_lock_irq(&device->resource->req_lock);\n\tlist_splice_init(list, &work_list);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\tlist_for_each_entry_safe(peer_req, t, &work_list, w.list) {\n\t\t__drbd_free_peer_req(device, peer_req, is_net);\n\t\tcount++;\n\t}\n\treturn count;\n}\n\n/*\n * See also comments in _req_mod(,BARRIER_ACKED) and receive_Barrier.\n */\nstatic int drbd_finish_peer_reqs(struct drbd_device *device)\n{\n\tLIST_HEAD(work_list);\n\tLIST_HEAD(reclaimed);\n\tstruct drbd_peer_request *peer_req, *t;\n\tint err = 0;\n\n\tspin_lock_irq(&device->resource->req_lock);\n\treclaim_finished_net_peer_reqs(device, &reclaimed);\n\tlist_splice_init(&device->done_ee, &work_list);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\tlist_for_each_entry_safe(peer_req, t, &reclaimed, w.list)\n\t\tdrbd_free_net_peer_req(device, peer_req);\n\n\t/* possible callbacks here:\n\t * e_end_block, and e_end_resync_block, e_send_superseded.\n\t * all ignore the last argument.\n\t */\n\tlist_for_each_entry_safe(peer_req, t, &work_list, w.list) {\n\t\tint err2;\n\n\t\t/* list_del not necessary, next/prev members not touched */\n\t\terr2 = peer_req->w.cb(&peer_req->w, !!err);\n\t\tif (!err)\n\t\t\terr = err2;\n\t\tdrbd_free_peer_req(device, peer_req);\n\t}\n\twake_up(&device->ee_wait);\n\n\treturn err;\n}\n\nstatic void _drbd_wait_ee_list_empty(struct drbd_device *device,\n\t\t\t\t     struct list_head *head)\n{\n\tDEFINE_WAIT(wait);\n\n\t/* avoids spin_lock/unlock\n\t * and calling prepare_to_wait in the fast path */\n\twhile (!list_empty(head)) {\n\t\tprepare_to_wait(&device->ee_wait, &wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock_irq(&device->resource->req_lock);\n\t\tio_schedule();\n\t\tfinish_wait(&device->ee_wait, &wait);\n\t\tspin_lock_irq(&device->resource->req_lock);\n\t}\n}\n\nstatic void drbd_wait_ee_list_empty(struct drbd_device *device,\n\t\t\t\t    struct list_head *head)\n{\n\tspin_lock_irq(&device->resource->req_lock);\n\t_drbd_wait_ee_list_empty(device, head);\n\tspin_unlock_irq(&device->resource->req_lock);\n}\n\nstatic int drbd_recv_short(struct socket *sock, void *buf, size_t size, int flags)\n{\n\tstruct kvec iov = {\n\t\t.iov_base = buf,\n\t\t.iov_len = size,\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_flags = (flags ? flags : MSG_WAITALL | MSG_NOSIGNAL)\n\t};\n\tiov_iter_kvec(&msg.msg_iter, READ, &iov, 1, size);\n\treturn sock_recvmsg(sock, &msg, msg.msg_flags);\n}\n\nstatic int drbd_recv(struct drbd_connection *connection, void *buf, size_t size)\n{\n\tint rv;\n\n\trv = drbd_recv_short(connection->data.socket, buf, size, 0);\n\n\tif (rv < 0) {\n\t\tif (rv == -ECONNRESET)\n\t\t\tdrbd_info(connection, \"sock was reset by peer\\n\");\n\t\telse if (rv != -ERESTARTSYS)\n\t\t\tdrbd_err(connection, \"sock_recvmsg returned %d\\n\", rv);\n\t} else if (rv == 0) {\n\t\tif (test_bit(DISCONNECT_SENT, &connection->flags)) {\n\t\t\tlong t;\n\t\t\trcu_read_lock();\n\t\t\tt = rcu_dereference(connection->net_conf)->ping_timeo * HZ/10;\n\t\t\trcu_read_unlock();\n\n\t\t\tt = wait_event_timeout(connection->ping_wait, connection->cstate < C_WF_REPORT_PARAMS, t);\n\n\t\t\tif (t)\n\t\t\t\tgoto out;\n\t\t}\n\t\tdrbd_info(connection, \"sock was shut down by peer\\n\");\n\t}\n\n\tif (rv != size)\n\t\tconn_request_state(connection, NS(conn, C_BROKEN_PIPE), CS_HARD);\n\nout:\n\treturn rv;\n}\n\nstatic int drbd_recv_all(struct drbd_connection *connection, void *buf, size_t size)\n{\n\tint err;\n\n\terr = drbd_recv(connection, buf, size);\n\tif (err != size) {\n\t\tif (err >= 0)\n\t\t\terr = -EIO;\n\t} else\n\t\terr = 0;\n\treturn err;\n}\n\nstatic int drbd_recv_all_warn(struct drbd_connection *connection, void *buf, size_t size)\n{\n\tint err;\n\n\terr = drbd_recv_all(connection, buf, size);\n\tif (err && !signal_pending(current))\n\t\tdrbd_warn(connection, \"short read (expected size %d)\\n\", (int)size);\n\treturn err;\n}\n\n/* quoting tcp(7):\n *   On individual connections, the socket buffer size must be set prior to the\n *   listen(2) or connect(2) calls in order to have it take effect.\n * This is our wrapper to do so.\n */\nstatic void drbd_setbufsize(struct socket *sock, unsigned int snd,\n\t\tunsigned int rcv)\n{\n\t/* open coded SO_SNDBUF, SO_RCVBUF */\n\tif (snd) {\n\t\tsock->sk->sk_sndbuf = snd;\n\t\tsock->sk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t}\n\tif (rcv) {\n\t\tsock->sk->sk_rcvbuf = rcv;\n\t\tsock->sk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t}\n}\n\nstatic struct socket *drbd_try_connect(struct drbd_connection *connection)\n{\n\tconst char *what;\n\tstruct socket *sock;\n\tstruct sockaddr_in6 src_in6;\n\tstruct sockaddr_in6 peer_in6;\n\tstruct net_conf *nc;\n\tint err, peer_addr_len, my_addr_len;\n\tint sndbuf_size, rcvbuf_size, connect_int;\n\tint disconnect_on_error = 1;\n\n\trcu_read_lock();\n\tnc = rcu_dereference(connection->net_conf);\n\tif (!nc) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\tsndbuf_size = nc->sndbuf_size;\n\trcvbuf_size = nc->rcvbuf_size;\n\tconnect_int = nc->connect_int;\n\trcu_read_unlock();\n\n\tmy_addr_len = min_t(int, connection->my_addr_len, sizeof(src_in6));\n\tmemcpy(&src_in6, &connection->my_addr, my_addr_len);\n\n\tif (((struct sockaddr *)&connection->my_addr)->sa_family == AF_INET6)\n\t\tsrc_in6.sin6_port = 0;\n\telse\n\t\t((struct sockaddr_in *)&src_in6)->sin_port = 0; /* AF_INET & AF_SCI */\n\n\tpeer_addr_len = min_t(int, connection->peer_addr_len, sizeof(src_in6));\n\tmemcpy(&peer_in6, &connection->peer_addr, peer_addr_len);\n\n\twhat = \"sock_create_kern\";\n\terr = sock_create_kern(&init_net, ((struct sockaddr *)&src_in6)->sa_family,\n\t\t\t       SOCK_STREAM, IPPROTO_TCP, &sock);\n\tif (err < 0) {\n\t\tsock = NULL;\n\t\tgoto out;\n\t}\n\n\tsock->sk->sk_rcvtimeo =\n\tsock->sk->sk_sndtimeo = connect_int * HZ;\n\tdrbd_setbufsize(sock, sndbuf_size, rcvbuf_size);\n\n       /* explicitly bind to the configured IP as source IP\n\t*  for the outgoing connections.\n\t*  This is needed for multihomed hosts and to be\n\t*  able to use lo: interfaces for drbd.\n\t* Make sure to use 0 as port number, so linux selects\n\t*  a free one dynamically.\n\t*/\n\twhat = \"bind before connect\";\n\terr = sock->ops->bind(sock, (struct sockaddr *) &src_in6, my_addr_len);\n\tif (err < 0)\n\t\tgoto out;\n\n\t/* connect may fail, peer not yet available.\n\t * stay C_WF_CONNECTION, don't go Disconnecting! */\n\tdisconnect_on_error = 0;\n\twhat = \"connect\";\n\terr = sock->ops->connect(sock, (struct sockaddr *) &peer_in6, peer_addr_len, 0);\n\nout:\n\tif (err < 0) {\n\t\tif (sock) {\n\t\t\tsock_release(sock);\n\t\t\tsock = NULL;\n\t\t}\n\t\tswitch (-err) {\n\t\t\t/* timeout, busy, signal pending */\n\t\tcase ETIMEDOUT: case EAGAIN: case EINPROGRESS:\n\t\tcase EINTR: case ERESTARTSYS:\n\t\t\t/* peer not (yet) available, network problem */\n\t\tcase ECONNREFUSED: case ENETUNREACH:\n\t\tcase EHOSTDOWN:    case EHOSTUNREACH:\n\t\t\tdisconnect_on_error = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdrbd_err(connection, \"%s failed, err = %d\\n\", what, err);\n\t\t}\n\t\tif (disconnect_on_error)\n\t\t\tconn_request_state(connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t}\n\n\treturn sock;\n}\n\nstruct accept_wait_data {\n\tstruct drbd_connection *connection;\n\tstruct socket *s_listen;\n\tstruct completion door_bell;\n\tvoid (*original_sk_state_change)(struct sock *sk);\n\n};\n\nstatic void drbd_incoming_connection(struct sock *sk)\n{\n\tstruct accept_wait_data *ad = sk->sk_user_data;\n\tvoid (*state_change)(struct sock *sk);\n\n\tstate_change = ad->original_sk_state_change;\n\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\tcomplete(&ad->door_bell);\n\tstate_change(sk);\n}\n\nstatic int prepare_listen_socket(struct drbd_connection *connection, struct accept_wait_data *ad)\n{\n\tint err, sndbuf_size, rcvbuf_size, my_addr_len;\n\tstruct sockaddr_in6 my_addr;\n\tstruct socket *s_listen;\n\tstruct net_conf *nc;\n\tconst char *what;\n\n\trcu_read_lock();\n\tnc = rcu_dereference(connection->net_conf);\n\tif (!nc) {\n\t\trcu_read_unlock();\n\t\treturn -EIO;\n\t}\n\tsndbuf_size = nc->sndbuf_size;\n\trcvbuf_size = nc->rcvbuf_size;\n\trcu_read_unlock();\n\n\tmy_addr_len = min_t(int, connection->my_addr_len, sizeof(struct sockaddr_in6));\n\tmemcpy(&my_addr, &connection->my_addr, my_addr_len);\n\n\twhat = \"sock_create_kern\";\n\terr = sock_create_kern(&init_net, ((struct sockaddr *)&my_addr)->sa_family,\n\t\t\t       SOCK_STREAM, IPPROTO_TCP, &s_listen);\n\tif (err) {\n\t\ts_listen = NULL;\n\t\tgoto out;\n\t}\n\n\ts_listen->sk->sk_reuse = SK_CAN_REUSE; /* SO_REUSEADDR */\n\tdrbd_setbufsize(s_listen, sndbuf_size, rcvbuf_size);\n\n\twhat = \"bind before listen\";\n\terr = s_listen->ops->bind(s_listen, (struct sockaddr *)&my_addr, my_addr_len);\n\tif (err < 0)\n\t\tgoto out;\n\n\tad->s_listen = s_listen;\n\twrite_lock_bh(&s_listen->sk->sk_callback_lock);\n\tad->original_sk_state_change = s_listen->sk->sk_state_change;\n\ts_listen->sk->sk_state_change = drbd_incoming_connection;\n\ts_listen->sk->sk_user_data = ad;\n\twrite_unlock_bh(&s_listen->sk->sk_callback_lock);\n\n\twhat = \"listen\";\n\terr = s_listen->ops->listen(s_listen, 5);\n\tif (err < 0)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tif (s_listen)\n\t\tsock_release(s_listen);\n\tif (err < 0) {\n\t\tif (err != -EAGAIN && err != -EINTR && err != -ERESTARTSYS) {\n\t\t\tdrbd_err(connection, \"%s failed, err = %d\\n\", what, err);\n\t\t\tconn_request_state(connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t\t}\n\t}\n\n\treturn -EIO;\n}\n\nstatic void unregister_state_change(struct sock *sk, struct accept_wait_data *ad)\n{\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tsk->sk_state_change = ad->original_sk_state_change;\n\tsk->sk_user_data = NULL;\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}\n\nstatic struct socket *drbd_wait_for_connect(struct drbd_connection *connection, struct accept_wait_data *ad)\n{\n\tint timeo, connect_int, err = 0;\n\tstruct socket *s_estab = NULL;\n\tstruct net_conf *nc;\n\n\trcu_read_lock();\n\tnc = rcu_dereference(connection->net_conf);\n\tif (!nc) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\tconnect_int = nc->connect_int;\n\trcu_read_unlock();\n\n\ttimeo = connect_int * HZ;\n\t/* 28.5% random jitter */\n\ttimeo += (prandom_u32() & 1) ? timeo / 7 : -timeo / 7;\n\n\terr = wait_for_completion_interruptible_timeout(&ad->door_bell, timeo);\n\tif (err <= 0)\n\t\treturn NULL;\n\n\terr = kernel_accept(ad->s_listen, &s_estab, 0);\n\tif (err < 0) {\n\t\tif (err != -EAGAIN && err != -EINTR && err != -ERESTARTSYS) {\n\t\t\tdrbd_err(connection, \"accept failed, err = %d\\n\", err);\n\t\t\tconn_request_state(connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t\t}\n\t}\n\n\tif (s_estab)\n\t\tunregister_state_change(s_estab->sk, ad);\n\n\treturn s_estab;\n}\n\nstatic int decode_header(struct drbd_connection *, void *, struct packet_info *);\n\nstatic int send_first_packet(struct drbd_connection *connection, struct drbd_socket *sock,\n\t\t\t     enum drbd_packet cmd)\n{\n\tif (!conn_prepare_command(connection, sock))\n\t\treturn -EIO;\n\treturn conn_send_command(connection, sock, cmd, 0, NULL, 0);\n}\n\nstatic int receive_first_packet(struct drbd_connection *connection, struct socket *sock)\n{\n\tunsigned int header_size = drbd_header_size(connection);\n\tstruct packet_info pi;\n\tstruct net_conf *nc;\n\tint err;\n\n\trcu_read_lock();\n\tnc = rcu_dereference(connection->net_conf);\n\tif (!nc) {\n\t\trcu_read_unlock();\n\t\treturn -EIO;\n\t}\n\tsock->sk->sk_rcvtimeo = nc->ping_timeo * 4 * HZ / 10;\n\trcu_read_unlock();\n\n\terr = drbd_recv_short(sock, connection->data.rbuf, header_size, 0);\n\tif (err != header_size) {\n\t\tif (err >= 0)\n\t\t\terr = -EIO;\n\t\treturn err;\n\t}\n\terr = decode_header(connection, connection->data.rbuf, &pi);\n\tif (err)\n\t\treturn err;\n\treturn pi.cmd;\n}\n\n/**\n * drbd_socket_okay() - Free the socket if its connection is not okay\n * @sock:\tpointer to the pointer to the socket.\n */\nstatic bool drbd_socket_okay(struct socket **sock)\n{\n\tint rr;\n\tchar tb[4];\n\n\tif (!*sock)\n\t\treturn false;\n\n\trr = drbd_recv_short(*sock, tb, 4, MSG_DONTWAIT | MSG_PEEK);\n\n\tif (rr > 0 || rr == -EAGAIN) {\n\t\treturn true;\n\t} else {\n\t\tsock_release(*sock);\n\t\t*sock = NULL;\n\t\treturn false;\n\t}\n}\n\nstatic bool connection_established(struct drbd_connection *connection,\n\t\t\t\t   struct socket **sock1,\n\t\t\t\t   struct socket **sock2)\n{\n\tstruct net_conf *nc;\n\tint timeout;\n\tbool ok;\n\n\tif (!*sock1 || !*sock2)\n\t\treturn false;\n\n\trcu_read_lock();\n\tnc = rcu_dereference(connection->net_conf);\n\ttimeout = (nc->sock_check_timeo ?: nc->ping_timeo) * HZ / 10;\n\trcu_read_unlock();\n\tschedule_timeout_interruptible(timeout);\n\n\tok = drbd_socket_okay(sock1);\n\tok = drbd_socket_okay(sock2) && ok;\n\n\treturn ok;\n}\n\n/* Gets called if a connection is established, or if a new minor gets created\n   in a connection */\nint drbd_connected(struct drbd_peer_device *peer_device)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tint err;\n\n\tatomic_set(&device->packet_seq, 0);\n\tdevice->peer_seq = 0;\n\n\tdevice->state_mutex = peer_device->connection->agreed_pro_version < 100 ?\n\t\t&peer_device->connection->cstate_mutex :\n\t\t&device->own_state_mutex;\n\n\terr = drbd_send_sync_param(peer_device);\n\tif (!err)\n\t\terr = drbd_send_sizes(peer_device, 0, 0);\n\tif (!err)\n\t\terr = drbd_send_uuids(peer_device);\n\tif (!err)\n\t\terr = drbd_send_current_state(peer_device);\n\tclear_bit(USE_DEGR_WFC_T, &device->flags);\n\tclear_bit(RESIZE_PENDING, &device->flags);\n\tatomic_set(&device->ap_in_flight, 0);\n\tmod_timer(&device->request_timer, jiffies + HZ); /* just start it here. */\n\treturn err;\n}\n\n/*\n * return values:\n *   1 yes, we have a valid connection\n *   0 oops, did not work out, please try again\n *  -1 peer talks different language,\n *     no point in trying again, please go standalone.\n *  -2 We do not have a network config...\n */\nstatic int conn_connect(struct drbd_connection *connection)\n{\n\tstruct drbd_socket sock, msock;\n\tstruct drbd_peer_device *peer_device;\n\tstruct net_conf *nc;\n\tint vnr, timeout, h;\n\tbool discard_my_data, ok;\n\tenum drbd_state_rv rv;\n\tstruct accept_wait_data ad = {\n\t\t.connection = connection,\n\t\t.door_bell = COMPLETION_INITIALIZER_ONSTACK(ad.door_bell),\n\t};\n\n\tclear_bit(DISCONNECT_SENT, &connection->flags);\n\tif (conn_request_state(connection, NS(conn, C_WF_CONNECTION), CS_VERBOSE) < SS_SUCCESS)\n\t\treturn -2;\n\n\tmutex_init(&sock.mutex);\n\tsock.sbuf = connection->data.sbuf;\n\tsock.rbuf = connection->data.rbuf;\n\tsock.socket = NULL;\n\tmutex_init(&msock.mutex);\n\tmsock.sbuf = connection->meta.sbuf;\n\tmsock.rbuf = connection->meta.rbuf;\n\tmsock.socket = NULL;\n\n\t/* Assume that the peer only understands protocol 80 until we know better.  */\n\tconnection->agreed_pro_version = 80;\n\n\tif (prepare_listen_socket(connection, &ad))\n\t\treturn 0;\n\n\tdo {\n\t\tstruct socket *s;\n\n\t\ts = drbd_try_connect(connection);\n\t\tif (s) {\n\t\t\tif (!sock.socket) {\n\t\t\t\tsock.socket = s;\n\t\t\t\tsend_first_packet(connection, &sock, P_INITIAL_DATA);\n\t\t\t} else if (!msock.socket) {\n\t\t\t\tclear_bit(RESOLVE_CONFLICTS, &connection->flags);\n\t\t\t\tmsock.socket = s;\n\t\t\t\tsend_first_packet(connection, &msock, P_INITIAL_META);\n\t\t\t} else {\n\t\t\t\tdrbd_err(connection, \"Logic error in conn_connect()\\n\");\n\t\t\t\tgoto out_release_sockets;\n\t\t\t}\n\t\t}\n\n\t\tif (connection_established(connection, &sock.socket, &msock.socket))\n\t\t\tbreak;\n\nretry:\n\t\ts = drbd_wait_for_connect(connection, &ad);\n\t\tif (s) {\n\t\t\tint fp = receive_first_packet(connection, s);\n\t\t\tdrbd_socket_okay(&sock.socket);\n\t\t\tdrbd_socket_okay(&msock.socket);\n\t\t\tswitch (fp) {\n\t\t\tcase P_INITIAL_DATA:\n\t\t\t\tif (sock.socket) {\n\t\t\t\t\tdrbd_warn(connection, \"initial packet S crossed\\n\");\n\t\t\t\t\tsock_release(sock.socket);\n\t\t\t\t\tsock.socket = s;\n\t\t\t\t\tgoto randomize;\n\t\t\t\t}\n\t\t\t\tsock.socket = s;\n\t\t\t\tbreak;\n\t\t\tcase P_INITIAL_META:\n\t\t\t\tset_bit(RESOLVE_CONFLICTS, &connection->flags);\n\t\t\t\tif (msock.socket) {\n\t\t\t\t\tdrbd_warn(connection, \"initial packet M crossed\\n\");\n\t\t\t\t\tsock_release(msock.socket);\n\t\t\t\t\tmsock.socket = s;\n\t\t\t\t\tgoto randomize;\n\t\t\t\t}\n\t\t\t\tmsock.socket = s;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdrbd_warn(connection, \"Error receiving initial packet\\n\");\n\t\t\t\tsock_release(s);\nrandomize:\n\t\t\t\tif (prandom_u32() & 1)\n\t\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\n\t\tif (connection->cstate <= C_DISCONNECTING)\n\t\t\tgoto out_release_sockets;\n\t\tif (signal_pending(current)) {\n\t\t\tflush_signals(current);\n\t\t\tsmp_rmb();\n\t\t\tif (get_t_state(&connection->receiver) == EXITING)\n\t\t\t\tgoto out_release_sockets;\n\t\t}\n\n\t\tok = connection_established(connection, &sock.socket, &msock.socket);\n\t} while (!ok);\n\n\tif (ad.s_listen)\n\t\tsock_release(ad.s_listen);\n\n\tsock.socket->sk->sk_reuse = SK_CAN_REUSE; /* SO_REUSEADDR */\n\tmsock.socket->sk->sk_reuse = SK_CAN_REUSE; /* SO_REUSEADDR */\n\n\tsock.socket->sk->sk_allocation = GFP_NOIO;\n\tmsock.socket->sk->sk_allocation = GFP_NOIO;\n\n\tsock.socket->sk->sk_priority = TC_PRIO_INTERACTIVE_BULK;\n\tmsock.socket->sk->sk_priority = TC_PRIO_INTERACTIVE;\n\n\t/* NOT YET ...\n\t * sock.socket->sk->sk_sndtimeo = connection->net_conf->timeout*HZ/10;\n\t * sock.socket->sk->sk_rcvtimeo = MAX_SCHEDULE_TIMEOUT;\n\t * first set it to the P_CONNECTION_FEATURES timeout,\n\t * which we set to 4x the configured ping_timeout. */\n\trcu_read_lock();\n\tnc = rcu_dereference(connection->net_conf);\n\n\tsock.socket->sk->sk_sndtimeo =\n\tsock.socket->sk->sk_rcvtimeo = nc->ping_timeo*4*HZ/10;\n\n\tmsock.socket->sk->sk_rcvtimeo = nc->ping_int*HZ;\n\ttimeout = nc->timeout * HZ / 10;\n\tdiscard_my_data = nc->discard_my_data;\n\trcu_read_unlock();\n\n\tmsock.socket->sk->sk_sndtimeo = timeout;\n\n\t/* we don't want delays.\n\t * we use TCP_CORK where appropriate, though */\n\ttcp_sock_set_nodelay(sock.socket->sk);\n\ttcp_sock_set_nodelay(msock.socket->sk);\n\n\tconnection->data.socket = sock.socket;\n\tconnection->meta.socket = msock.socket;\n\tconnection->last_received = jiffies;\n\n\th = drbd_do_features(connection);\n\tif (h <= 0)\n\t\treturn h;\n\n\tif (connection->cram_hmac_tfm) {\n\t\t/* drbd_request_state(device, NS(conn, WFAuth)); */\n\t\tswitch (drbd_do_auth(connection)) {\n\t\tcase -1:\n\t\t\tdrbd_err(connection, \"Authentication of peer failed\\n\");\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\tdrbd_err(connection, \"Authentication of peer failed, trying again.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tconnection->data.socket->sk->sk_sndtimeo = timeout;\n\tconnection->data.socket->sk->sk_rcvtimeo = MAX_SCHEDULE_TIMEOUT;\n\n\tif (drbd_send_protocol(connection) == -EOPNOTSUPP)\n\t\treturn -1;\n\n\t/* Prevent a race between resync-handshake and\n\t * being promoted to Primary.\n\t *\n\t * Grab and release the state mutex, so we know that any current\n\t * drbd_set_role() is finished, and any incoming drbd_set_role\n\t * will see the STATE_SENT flag, and wait for it to be cleared.\n\t */\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr)\n\t\tmutex_lock(peer_device->device->state_mutex);\n\n\t/* avoid a race with conn_request_state( C_DISCONNECTING ) */\n\tspin_lock_irq(&connection->resource->req_lock);\n\tset_bit(STATE_SENT, &connection->flags);\n\tspin_unlock_irq(&connection->resource->req_lock);\n\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr)\n\t\tmutex_unlock(peer_device->device->state_mutex);\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\t\tkref_get(&device->kref);\n\t\trcu_read_unlock();\n\n\t\tif (discard_my_data)\n\t\t\tset_bit(DISCARD_MY_DATA, &device->flags);\n\t\telse\n\t\t\tclear_bit(DISCARD_MY_DATA, &device->flags);\n\n\t\tdrbd_connected(peer_device);\n\t\tkref_put(&device->kref, drbd_destroy_device);\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\n\n\trv = conn_request_state(connection, NS(conn, C_WF_REPORT_PARAMS), CS_VERBOSE);\n\tif (rv < SS_SUCCESS || connection->cstate != C_WF_REPORT_PARAMS) {\n\t\tclear_bit(STATE_SENT, &connection->flags);\n\t\treturn 0;\n\t}\n\n\tdrbd_thread_start(&connection->ack_receiver);\n\t/* opencoded create_singlethread_workqueue(),\n\t * to be able to use format string arguments */\n\tconnection->ack_sender =\n\t\talloc_ordered_workqueue(\"drbd_as_%s\", WQ_MEM_RECLAIM, connection->resource->name);\n\tif (!connection->ack_sender) {\n\t\tdrbd_err(connection, \"Failed to create workqueue ack_sender\\n\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&connection->resource->conf_update);\n\t/* The discard_my_data flag is a single-shot modifier to the next\n\t * connection attempt, the handshake of which is now well underway.\n\t * No need for rcu style copying of the whole struct\n\t * just to clear a single value. */\n\tconnection->net_conf->discard_my_data = 0;\n\tmutex_unlock(&connection->resource->conf_update);\n\n\treturn h;\n\nout_release_sockets:\n\tif (ad.s_listen)\n\t\tsock_release(ad.s_listen);\n\tif (sock.socket)\n\t\tsock_release(sock.socket);\n\tif (msock.socket)\n\t\tsock_release(msock.socket);\n\treturn -1;\n}\n\nstatic int decode_header(struct drbd_connection *connection, void *header, struct packet_info *pi)\n{\n\tunsigned int header_size = drbd_header_size(connection);\n\n\tif (header_size == sizeof(struct p_header100) &&\n\t    *(__be32 *)header == cpu_to_be32(DRBD_MAGIC_100)) {\n\t\tstruct p_header100 *h = header;\n\t\tif (h->pad != 0) {\n\t\t\tdrbd_err(connection, \"Header padding is not zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpi->vnr = be16_to_cpu(h->volume);\n\t\tpi->cmd = be16_to_cpu(h->command);\n\t\tpi->size = be32_to_cpu(h->length);\n\t} else if (header_size == sizeof(struct p_header95) &&\n\t\t   *(__be16 *)header == cpu_to_be16(DRBD_MAGIC_BIG)) {\n\t\tstruct p_header95 *h = header;\n\t\tpi->cmd = be16_to_cpu(h->command);\n\t\tpi->size = be32_to_cpu(h->length);\n\t\tpi->vnr = 0;\n\t} else if (header_size == sizeof(struct p_header80) &&\n\t\t   *(__be32 *)header == cpu_to_be32(DRBD_MAGIC)) {\n\t\tstruct p_header80 *h = header;\n\t\tpi->cmd = be16_to_cpu(h->command);\n\t\tpi->size = be16_to_cpu(h->length);\n\t\tpi->vnr = 0;\n\t} else {\n\t\tdrbd_err(connection, \"Wrong magic value 0x%08x in protocol version %d\\n\",\n\t\t\t be32_to_cpu(*(__be32 *)header),\n\t\t\t connection->agreed_pro_version);\n\t\treturn -EINVAL;\n\t}\n\tpi->data = header + header_size;\n\treturn 0;\n}\n\nstatic void drbd_unplug_all_devices(struct drbd_connection *connection)\n{\n\tif (current->plug == &connection->receiver_plug) {\n\t\tblk_finish_plug(&connection->receiver_plug);\n\t\tblk_start_plug(&connection->receiver_plug);\n\t} /* else: maybe just schedule() ?? */\n}\n\nstatic int drbd_recv_header(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tvoid *buffer = connection->data.rbuf;\n\tint err;\n\n\terr = drbd_recv_all_warn(connection, buffer, drbd_header_size(connection));\n\tif (err)\n\t\treturn err;\n\n\terr = decode_header(connection, buffer, pi);\n\tconnection->last_received = jiffies;\n\n\treturn err;\n}\n\nstatic int drbd_recv_header_maybe_unplug(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tvoid *buffer = connection->data.rbuf;\n\tunsigned int size = drbd_header_size(connection);\n\tint err;\n\n\terr = drbd_recv_short(connection->data.socket, buffer, size, MSG_NOSIGNAL|MSG_DONTWAIT);\n\tif (err != size) {\n\t\t/* If we have nothing in the receive buffer now, to reduce\n\t\t * application latency, try to drain the backend queues as\n\t\t * quickly as possible, and let remote TCP know what we have\n\t\t * received so far. */\n\t\tif (err == -EAGAIN) {\n\t\t\ttcp_sock_set_quickack(connection->data.socket->sk, 2);\n\t\t\tdrbd_unplug_all_devices(connection);\n\t\t}\n\t\tif (err > 0) {\n\t\t\tbuffer += err;\n\t\t\tsize -= err;\n\t\t}\n\t\terr = drbd_recv_all_warn(connection, buffer, size);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = decode_header(connection, connection->data.rbuf, pi);\n\tconnection->last_received = jiffies;\n\n\treturn err;\n}\n/* This is blkdev_issue_flush, but asynchronous.\n * We want to submit to all component volumes in parallel,\n * then wait for all completions.\n */\nstruct issue_flush_context {\n\tatomic_t pending;\n\tint error;\n\tstruct completion done;\n};\nstruct one_flush_context {\n\tstruct drbd_device *device;\n\tstruct issue_flush_context *ctx;\n};\n\nstatic void one_flush_endio(struct bio *bio)\n{\n\tstruct one_flush_context *octx = bio->bi_private;\n\tstruct drbd_device *device = octx->device;\n\tstruct issue_flush_context *ctx = octx->ctx;\n\n\tif (bio->bi_status) {\n\t\tctx->error = blk_status_to_errno(bio->bi_status);\n\t\tdrbd_info(device, \"local disk FLUSH FAILED with status %d\\n\", bio->bi_status);\n\t}\n\tkfree(octx);\n\tbio_put(bio);\n\n\tclear_bit(FLUSH_PENDING, &device->flags);\n\tput_ldev(device);\n\tkref_put(&device->kref, drbd_destroy_device);\n\n\tif (atomic_dec_and_test(&ctx->pending))\n\t\tcomplete(&ctx->done);\n}\n\nstatic void submit_one_flush(struct drbd_device *device, struct issue_flush_context *ctx)\n{\n\tstruct bio *bio = bio_alloc(GFP_NOIO, 0);\n\tstruct one_flush_context *octx = kmalloc(sizeof(*octx), GFP_NOIO);\n\tif (!bio || !octx) {\n\t\tdrbd_warn(device, \"Could not allocate a bio, CANNOT ISSUE FLUSH\\n\");\n\t\t/* FIXME: what else can I do now?  disconnecting or detaching\n\t\t * really does not help to improve the state of the world, either.\n\t\t */\n\t\tkfree(octx);\n\t\tif (bio)\n\t\t\tbio_put(bio);\n\n\t\tctx->error = -ENOMEM;\n\t\tput_ldev(device);\n\t\tkref_put(&device->kref, drbd_destroy_device);\n\t\treturn;\n\t}\n\n\toctx->device = device;\n\toctx->ctx = ctx;\n\tbio_set_dev(bio, device->ldev->backing_bdev);\n\tbio->bi_private = octx;\n\tbio->bi_end_io = one_flush_endio;\n\tbio->bi_opf = REQ_OP_FLUSH | REQ_PREFLUSH;\n\n\tdevice->flush_jif = jiffies;\n\tset_bit(FLUSH_PENDING, &device->flags);\n\tatomic_inc(&ctx->pending);\n\tsubmit_bio(bio);\n}\n\nstatic void drbd_flush(struct drbd_connection *connection)\n{\n\tif (connection->resource->write_ordering >= WO_BDEV_FLUSH) {\n\t\tstruct drbd_peer_device *peer_device;\n\t\tstruct issue_flush_context ctx;\n\t\tint vnr;\n\n\t\tatomic_set(&ctx.pending, 1);\n\t\tctx.error = 0;\n\t\tinit_completion(&ctx.done);\n\n\t\trcu_read_lock();\n\t\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\t\tstruct drbd_device *device = peer_device->device;\n\n\t\t\tif (!get_ldev(device))\n\t\t\t\tcontinue;\n\t\t\tkref_get(&device->kref);\n\t\t\trcu_read_unlock();\n\n\t\t\tsubmit_one_flush(device, &ctx);\n\n\t\t\trcu_read_lock();\n\t\t}\n\t\trcu_read_unlock();\n\n\t\t/* Do we want to add a timeout,\n\t\t * if disk-timeout is set? */\n\t\tif (!atomic_dec_and_test(&ctx.pending))\n\t\t\twait_for_completion(&ctx.done);\n\n\t\tif (ctx.error) {\n\t\t\t/* would rather check on EOPNOTSUPP, but that is not reliable.\n\t\t\t * don't try again for ANY return value != 0\n\t\t\t * if (rv == -EOPNOTSUPP) */\n\t\t\t/* Any error is already reported by bio_endio callback. */\n\t\t\tdrbd_bump_write_ordering(connection->resource, NULL, WO_DRAIN_IO);\n\t\t}\n\t}\n}\n\n/**\n * drbd_may_finish_epoch() - Applies an epoch_event to the epoch's state, eventually finishes it.\n * @device:\tDRBD device.\n * @epoch:\tEpoch object.\n * @ev:\t\tEpoch event.\n */\nstatic enum finish_epoch drbd_may_finish_epoch(struct drbd_connection *connection,\n\t\t\t\t\t       struct drbd_epoch *epoch,\n\t\t\t\t\t       enum epoch_event ev)\n{\n\tint epoch_size;\n\tstruct drbd_epoch *next_epoch;\n\tenum finish_epoch rv = FE_STILL_LIVE;\n\n\tspin_lock(&connection->epoch_lock);\n\tdo {\n\t\tnext_epoch = NULL;\n\n\t\tepoch_size = atomic_read(&epoch->epoch_size);\n\n\t\tswitch (ev & ~EV_CLEANUP) {\n\t\tcase EV_PUT:\n\t\t\tatomic_dec(&epoch->active);\n\t\t\tbreak;\n\t\tcase EV_GOT_BARRIER_NR:\n\t\t\tset_bit(DE_HAVE_BARRIER_NUMBER, &epoch->flags);\n\t\t\tbreak;\n\t\tcase EV_BECAME_LAST:\n\t\t\t/* nothing to do*/\n\t\t\tbreak;\n\t\t}\n\n\t\tif (epoch_size != 0 &&\n\t\t    atomic_read(&epoch->active) == 0 &&\n\t\t    (test_bit(DE_HAVE_BARRIER_NUMBER, &epoch->flags) || ev & EV_CLEANUP)) {\n\t\t\tif (!(ev & EV_CLEANUP)) {\n\t\t\t\tspin_unlock(&connection->epoch_lock);\n\t\t\t\tdrbd_send_b_ack(epoch->connection, epoch->barrier_nr, epoch_size);\n\t\t\t\tspin_lock(&connection->epoch_lock);\n\t\t\t}\n#if 0\n\t\t\t/* FIXME: dec unacked on connection, once we have\n\t\t\t * something to count pending connection packets in. */\n\t\t\tif (test_bit(DE_HAVE_BARRIER_NUMBER, &epoch->flags))\n\t\t\t\tdec_unacked(epoch->connection);\n#endif\n\n\t\t\tif (connection->current_epoch != epoch) {\n\t\t\t\tnext_epoch = list_entry(epoch->list.next, struct drbd_epoch, list);\n\t\t\t\tlist_del(&epoch->list);\n\t\t\t\tev = EV_BECAME_LAST | (ev & EV_CLEANUP);\n\t\t\t\tconnection->epochs--;\n\t\t\t\tkfree(epoch);\n\n\t\t\t\tif (rv == FE_STILL_LIVE)\n\t\t\t\t\trv = FE_DESTROYED;\n\t\t\t} else {\n\t\t\t\tepoch->flags = 0;\n\t\t\t\tatomic_set(&epoch->epoch_size, 0);\n\t\t\t\t/* atomic_set(&epoch->active, 0); is already zero */\n\t\t\t\tif (rv == FE_STILL_LIVE)\n\t\t\t\t\trv = FE_RECYCLED;\n\t\t\t}\n\t\t}\n\n\t\tif (!next_epoch)\n\t\t\tbreak;\n\n\t\tepoch = next_epoch;\n\t} while (1);\n\n\tspin_unlock(&connection->epoch_lock);\n\n\treturn rv;\n}\n\nstatic enum write_ordering_e\nmax_allowed_wo(struct drbd_backing_dev *bdev, enum write_ordering_e wo)\n{\n\tstruct disk_conf *dc;\n\n\tdc = rcu_dereference(bdev->disk_conf);\n\n\tif (wo == WO_BDEV_FLUSH && !dc->disk_flushes)\n\t\two = WO_DRAIN_IO;\n\tif (wo == WO_DRAIN_IO && !dc->disk_drain)\n\t\two = WO_NONE;\n\n\treturn wo;\n}\n\n/**\n * drbd_bump_write_ordering() - Fall back to an other write ordering method\n * @connection:\tDRBD connection.\n * @wo:\t\tWrite ordering method to try.\n */\nvoid drbd_bump_write_ordering(struct drbd_resource *resource, struct drbd_backing_dev *bdev,\n\t\t\t      enum write_ordering_e wo)\n{\n\tstruct drbd_device *device;\n\tenum write_ordering_e pwo;\n\tint vnr;\n\tstatic char *write_ordering_str[] = {\n\t\t[WO_NONE] = \"none\",\n\t\t[WO_DRAIN_IO] = \"drain\",\n\t\t[WO_BDEV_FLUSH] = \"flush\",\n\t};\n\n\tpwo = resource->write_ordering;\n\tif (wo != WO_BDEV_FLUSH)\n\t\two = min(pwo, wo);\n\trcu_read_lock();\n\tidr_for_each_entry(&resource->devices, device, vnr) {\n\t\tif (get_ldev(device)) {\n\t\t\two = max_allowed_wo(device->ldev, wo);\n\t\t\tif (device->ldev == bdev)\n\t\t\t\tbdev = NULL;\n\t\t\tput_ldev(device);\n\t\t}\n\t}\n\n\tif (bdev)\n\t\two = max_allowed_wo(bdev, wo);\n\n\trcu_read_unlock();\n\n\tresource->write_ordering = wo;\n\tif (pwo != resource->write_ordering || wo == WO_BDEV_FLUSH)\n\t\tdrbd_info(resource, \"Method to ensure write ordering: %s\\n\", write_ordering_str[resource->write_ordering]);\n}\n\n/*\n * Mapping \"discard\" to ZEROOUT with UNMAP does not work for us:\n * Drivers have to \"announce\" q->limits.max_write_zeroes_sectors, or it\n * will directly go to fallback mode, submitting normal writes, and\n * never even try to UNMAP.\n *\n * And dm-thin does not do this (yet), mostly because in general it has\n * to assume that \"skip_block_zeroing\" is set.  See also:\n * https://www.mail-archive.com/dm-devel%40redhat.com/msg07965.html\n * https://www.redhat.com/archives/dm-devel/2018-January/msg00271.html\n *\n * We *may* ignore the discard-zeroes-data setting, if so configured.\n *\n * Assumption is that this \"discard_zeroes_data=0\" is only because the backend\n * may ignore partial unaligned discards.\n *\n * LVM/DM thin as of at least\n *   LVM version:     2.02.115(2)-RHEL7 (2015-01-28)\n *   Library version: 1.02.93-RHEL7 (2015-01-28)\n *   Driver version:  4.29.0\n * still behaves this way.\n *\n * For unaligned (wrt. alignment and granularity) or too small discards,\n * we zero-out the initial (and/or) trailing unaligned partial chunks,\n * but discard all the aligned full chunks.\n *\n * At least for LVM/DM thin, with skip_block_zeroing=false,\n * the result is effectively \"discard_zeroes_data=1\".\n */\n/* flags: EE_TRIM|EE_ZEROOUT */\nint drbd_issue_discard_or_zero_out(struct drbd_device *device, sector_t start, unsigned int nr_sectors, int flags)\n{\n\tstruct block_device *bdev = device->ldev->backing_bdev;\n\tstruct request_queue *q = bdev_get_queue(bdev);\n\tsector_t tmp, nr;\n\tunsigned int max_discard_sectors, granularity;\n\tint alignment;\n\tint err = 0;\n\n\tif ((flags & EE_ZEROOUT) || !(flags & EE_TRIM))\n\t\tgoto zero_out;\n\n\t/* Zero-sector (unknown) and one-sector granularities are the same.  */\n\tgranularity = max(q->limits.discard_granularity >> 9, 1U);\n\talignment = (bdev_discard_alignment(bdev) >> 9) % granularity;\n\n\tmax_discard_sectors = min(q->limits.max_discard_sectors, (1U << 22));\n\tmax_discard_sectors -= max_discard_sectors % granularity;\n\tif (unlikely(!max_discard_sectors))\n\t\tgoto zero_out;\n\n\tif (nr_sectors < granularity)\n\t\tgoto zero_out;\n\n\ttmp = start;\n\tif (sector_div(tmp, granularity) != alignment) {\n\t\tif (nr_sectors < 2*granularity)\n\t\t\tgoto zero_out;\n\t\t/* start + gran - (start + gran - align) % gran */\n\t\ttmp = start + granularity - alignment;\n\t\ttmp = start + granularity - sector_div(tmp, granularity);\n\n\t\tnr = tmp - start;\n\t\t/* don't flag BLKDEV_ZERO_NOUNMAP, we don't know how many\n\t\t * layers are below us, some may have smaller granularity */\n\t\terr |= blkdev_issue_zeroout(bdev, start, nr, GFP_NOIO, 0);\n\t\tnr_sectors -= nr;\n\t\tstart = tmp;\n\t}\n\twhile (nr_sectors >= max_discard_sectors) {\n\t\terr |= blkdev_issue_discard(bdev, start, max_discard_sectors, GFP_NOIO, 0);\n\t\tnr_sectors -= max_discard_sectors;\n\t\tstart += max_discard_sectors;\n\t}\n\tif (nr_sectors) {\n\t\t/* max_discard_sectors is unsigned int (and a multiple of\n\t\t * granularity, we made sure of that above already);\n\t\t * nr is < max_discard_sectors;\n\t\t * I don't need sector_div here, even though nr is sector_t */\n\t\tnr = nr_sectors;\n\t\tnr -= (unsigned int)nr % granularity;\n\t\tif (nr) {\n\t\t\terr |= blkdev_issue_discard(bdev, start, nr, GFP_NOIO, 0);\n\t\t\tnr_sectors -= nr;\n\t\t\tstart += nr;\n\t\t}\n\t}\n zero_out:\n\tif (nr_sectors) {\n\t\terr |= blkdev_issue_zeroout(bdev, start, nr_sectors, GFP_NOIO,\n\t\t\t\t(flags & EE_TRIM) ? 0 : BLKDEV_ZERO_NOUNMAP);\n\t}\n\treturn err != 0;\n}\n\nstatic bool can_do_reliable_discards(struct drbd_device *device)\n{\n\tstruct request_queue *q = bdev_get_queue(device->ldev->backing_bdev);\n\tstruct disk_conf *dc;\n\tbool can_do;\n\n\tif (!blk_queue_discard(q))\n\t\treturn false;\n\n\trcu_read_lock();\n\tdc = rcu_dereference(device->ldev->disk_conf);\n\tcan_do = dc->discard_zeroes_if_aligned;\n\trcu_read_unlock();\n\treturn can_do;\n}\n\nstatic void drbd_issue_peer_discard_or_zero_out(struct drbd_device *device, struct drbd_peer_request *peer_req)\n{\n\t/* If the backend cannot discard, or does not guarantee\n\t * read-back zeroes in discarded ranges, we fall back to\n\t * zero-out.  Unless configuration specifically requested\n\t * otherwise. */\n\tif (!can_do_reliable_discards(device))\n\t\tpeer_req->flags |= EE_ZEROOUT;\n\n\tif (drbd_issue_discard_or_zero_out(device, peer_req->i.sector,\n\t    peer_req->i.size >> 9, peer_req->flags & (EE_ZEROOUT|EE_TRIM)))\n\t\tpeer_req->flags |= EE_WAS_ERROR;\n\tdrbd_endio_write_sec_final(peer_req);\n}\n\nstatic void drbd_issue_peer_wsame(struct drbd_device *device,\n\t\t\t\t  struct drbd_peer_request *peer_req)\n{\n\tstruct block_device *bdev = device->ldev->backing_bdev;\n\tsector_t s = peer_req->i.sector;\n\tsector_t nr = peer_req->i.size >> 9;\n\tif (blkdev_issue_write_same(bdev, s, nr, GFP_NOIO, peer_req->pages))\n\t\tpeer_req->flags |= EE_WAS_ERROR;\n\tdrbd_endio_write_sec_final(peer_req);\n}\n\n\n/**\n * drbd_submit_peer_request()\n * @device:\tDRBD device.\n * @peer_req:\tpeer request\n * @rw:\t\tflag field, see bio->bi_opf\n *\n * May spread the pages to multiple bios,\n * depending on bio_add_page restrictions.\n *\n * Returns 0 if all bios have been submitted,\n * -ENOMEM if we could not allocate enough bios,\n * -ENOSPC (any better suggestion?) if we have not been able to bio_add_page a\n *  single page to an empty bio (which should never happen and likely indicates\n *  that the lower level IO stack is in some way broken). This has been observed\n *  on certain Xen deployments.\n */\n/* TODO allocate from our own bio_set. */\nint drbd_submit_peer_request(struct drbd_device *device,\n\t\t\t     struct drbd_peer_request *peer_req,\n\t\t\t     const unsigned op, const unsigned op_flags,\n\t\t\t     const int fault_type)\n{\n\tstruct bio *bios = NULL;\n\tstruct bio *bio;\n\tstruct page *page = peer_req->pages;\n\tsector_t sector = peer_req->i.sector;\n\tunsigned data_size = peer_req->i.size;\n\tunsigned n_bios = 0;\n\tunsigned nr_pages = (data_size + PAGE_SIZE -1) >> PAGE_SHIFT;\n\tint err = -ENOMEM;\n\n\t/* TRIM/DISCARD: for now, always use the helper function\n\t * blkdev_issue_zeroout(..., discard=true).\n\t * It's synchronous, but it does the right thing wrt. bio splitting.\n\t * Correctness first, performance later.  Next step is to code an\n\t * asynchronous variant of the same.\n\t */\n\tif (peer_req->flags & (EE_TRIM|EE_WRITE_SAME|EE_ZEROOUT)) {\n\t\t/* wait for all pending IO completions, before we start\n\t\t * zeroing things out. */\n\t\tconn_wait_active_ee_empty(peer_req->peer_device->connection);\n\t\t/* add it to the active list now,\n\t\t * so we can find it to present it in debugfs */\n\t\tpeer_req->submit_jif = jiffies;\n\t\tpeer_req->flags |= EE_SUBMITTED;\n\n\t\t/* If this was a resync request from receive_rs_deallocated(),\n\t\t * it is already on the sync_ee list */\n\t\tif (list_empty(&peer_req->w.list)) {\n\t\t\tspin_lock_irq(&device->resource->req_lock);\n\t\t\tlist_add_tail(&peer_req->w.list, &device->active_ee);\n\t\t\tspin_unlock_irq(&device->resource->req_lock);\n\t\t}\n\n\t\tif (peer_req->flags & (EE_TRIM|EE_ZEROOUT))\n\t\t\tdrbd_issue_peer_discard_or_zero_out(device, peer_req);\n\t\telse /* EE_WRITE_SAME */\n\t\t\tdrbd_issue_peer_wsame(device, peer_req);\n\t\treturn 0;\n\t}\n\n\t/* In most cases, we will only need one bio.  But in case the lower\n\t * level restrictions happen to be different at this offset on this\n\t * side than those of the sending peer, we may need to submit the\n\t * request in more than one bio.\n\t *\n\t * Plain bio_alloc is good enough here, this is no DRBD internally\n\t * generated bio, but a bio allocated on behalf of the peer.\n\t */\nnext_bio:\n\tbio = bio_alloc(GFP_NOIO, nr_pages);\n\tif (!bio) {\n\t\tdrbd_err(device, \"submit_ee: Allocation of a bio failed (nr_pages=%u)\\n\", nr_pages);\n\t\tgoto fail;\n\t}\n\t/* > peer_req->i.sector, unless this is the first bio */\n\tbio->bi_iter.bi_sector = sector;\n\tbio_set_dev(bio, device->ldev->backing_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\tbio->bi_private = peer_req;\n\tbio->bi_end_io = drbd_peer_request_endio;\n\n\tbio->bi_next = bios;\n\tbios = bio;\n\t++n_bios;\n\n\tpage_chain_for_each(page) {\n\t\tunsigned len = min_t(unsigned, data_size, PAGE_SIZE);\n\t\tif (!bio_add_page(bio, page, len, 0))\n\t\t\tgoto next_bio;\n\t\tdata_size -= len;\n\t\tsector += len >> 9;\n\t\t--nr_pages;\n\t}\n\tD_ASSERT(device, data_size == 0);\n\tD_ASSERT(device, page == NULL);\n\n\tatomic_set(&peer_req->pending_bios, n_bios);\n\t/* for debugfs: update timestamp, mark as submitted */\n\tpeer_req->submit_jif = jiffies;\n\tpeer_req->flags |= EE_SUBMITTED;\n\tdo {\n\t\tbio = bios;\n\t\tbios = bios->bi_next;\n\t\tbio->bi_next = NULL;\n\n\t\tdrbd_submit_bio_noacct(device, fault_type, bio);\n\t} while (bios);\n\treturn 0;\n\nfail:\n\twhile (bios) {\n\t\tbio = bios;\n\t\tbios = bios->bi_next;\n\t\tbio_put(bio);\n\t}\n\treturn err;\n}\n\nstatic void drbd_remove_epoch_entry_interval(struct drbd_device *device,\n\t\t\t\t\t     struct drbd_peer_request *peer_req)\n{\n\tstruct drbd_interval *i = &peer_req->i;\n\n\tdrbd_remove_interval(&device->write_requests, i);\n\tdrbd_clear_interval(i);\n\n\t/* Wake up any processes waiting for this peer request to complete.  */\n\tif (i->waiting)\n\t\twake_up(&device->misc_wait);\n}\n\nstatic void conn_wait_active_ee_empty(struct drbd_connection *connection)\n{\n\tstruct drbd_peer_device *peer_device;\n\tint vnr;\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\n\t\tkref_get(&device->kref);\n\t\trcu_read_unlock();\n\t\tdrbd_wait_ee_list_empty(device, &device->active_ee);\n\t\tkref_put(&device->kref, drbd_destroy_device);\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\n}\n\nstatic int receive_Barrier(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tint rv;\n\tstruct p_barrier *p = pi->data;\n\tstruct drbd_epoch *epoch;\n\n\t/* FIXME these are unacked on connection,\n\t * not a specific (peer)device.\n\t */\n\tconnection->current_epoch->barrier_nr = p->barrier;\n\tconnection->current_epoch->connection = connection;\n\trv = drbd_may_finish_epoch(connection, connection->current_epoch, EV_GOT_BARRIER_NR);\n\n\t/* P_BARRIER_ACK may imply that the corresponding extent is dropped from\n\t * the activity log, which means it would not be resynced in case the\n\t * R_PRIMARY crashes now.\n\t * Therefore we must send the barrier_ack after the barrier request was\n\t * completed. */\n\tswitch (connection->resource->write_ordering) {\n\tcase WO_NONE:\n\t\tif (rv == FE_RECYCLED)\n\t\t\treturn 0;\n\n\t\t/* receiver context, in the writeout path of the other node.\n\t\t * avoid potential distributed deadlock */\n\t\tepoch = kmalloc(sizeof(struct drbd_epoch), GFP_NOIO);\n\t\tif (epoch)\n\t\t\tbreak;\n\t\telse\n\t\t\tdrbd_warn(connection, \"Allocation of an epoch failed, slowing down\\n\");\n\t\tfallthrough;\n\n\tcase WO_BDEV_FLUSH:\n\tcase WO_DRAIN_IO:\n\t\tconn_wait_active_ee_empty(connection);\n\t\tdrbd_flush(connection);\n\n\t\tif (atomic_read(&connection->current_epoch->epoch_size)) {\n\t\t\tepoch = kmalloc(sizeof(struct drbd_epoch), GFP_NOIO);\n\t\t\tif (epoch)\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn 0;\n\tdefault:\n\t\tdrbd_err(connection, \"Strangeness in connection->write_ordering %d\\n\",\n\t\t\t connection->resource->write_ordering);\n\t\treturn -EIO;\n\t}\n\n\tepoch->flags = 0;\n\tatomic_set(&epoch->epoch_size, 0);\n\tatomic_set(&epoch->active, 0);\n\n\tspin_lock(&connection->epoch_lock);\n\tif (atomic_read(&connection->current_epoch->epoch_size)) {\n\t\tlist_add(&epoch->list, &connection->current_epoch->list);\n\t\tconnection->current_epoch = epoch;\n\t\tconnection->epochs++;\n\t} else {\n\t\t/* The current_epoch got recycled while we allocated this one... */\n\t\tkfree(epoch);\n\t}\n\tspin_unlock(&connection->epoch_lock);\n\n\treturn 0;\n}\n\n/* quick wrapper in case payload size != request_size (write same) */\nstatic void drbd_csum_ee_size(struct crypto_shash *h,\n\t\t\t      struct drbd_peer_request *r, void *d,\n\t\t\t      unsigned int payload_size)\n{\n\tunsigned int tmp = r->i.size;\n\tr->i.size = payload_size;\n\tdrbd_csum_ee(h, r, d);\n\tr->i.size = tmp;\n}\n\n/* used from receive_RSDataReply (recv_resync_read)\n * and from receive_Data.\n * data_size: actual payload (\"data in\")\n * \tfor normal writes that is bi_size.\n * \tfor discards, that is zero.\n * \tfor write same, it is logical_block_size.\n * both trim and write same have the bi_size (\"data len to be affected\")\n * as extra argument in the packet header.\n */\nstatic struct drbd_peer_request *\nread_in_block(struct drbd_peer_device *peer_device, u64 id, sector_t sector,\n\t      struct packet_info *pi) __must_hold(local)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tconst sector_t capacity = get_capacity(device->vdisk);\n\tstruct drbd_peer_request *peer_req;\n\tstruct page *page;\n\tint digest_size, err;\n\tunsigned int data_size = pi->size, ds;\n\tvoid *dig_in = peer_device->connection->int_dig_in;\n\tvoid *dig_vv = peer_device->connection->int_dig_vv;\n\tunsigned long *data;\n\tstruct p_trim *trim = (pi->cmd == P_TRIM) ? pi->data : NULL;\n\tstruct p_trim *zeroes = (pi->cmd == P_ZEROES) ? pi->data : NULL;\n\tstruct p_trim *wsame = (pi->cmd == P_WSAME) ? pi->data : NULL;\n\n\tdigest_size = 0;\n\tif (!trim && peer_device->connection->peer_integrity_tfm) {\n\t\tdigest_size = crypto_shash_digestsize(peer_device->connection->peer_integrity_tfm);\n\t\t/*\n\t\t * FIXME: Receive the incoming digest into the receive buffer\n\t\t *\t  here, together with its struct p_data?\n\t\t */\n\t\terr = drbd_recv_all_warn(peer_device->connection, dig_in, digest_size);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tdata_size -= digest_size;\n\t}\n\n\t/* assume request_size == data_size, but special case trim and wsame. */\n\tds = data_size;\n\tif (trim) {\n\t\tif (!expect(data_size == 0))\n\t\t\treturn NULL;\n\t\tds = be32_to_cpu(trim->size);\n\t} else if (zeroes) {\n\t\tif (!expect(data_size == 0))\n\t\t\treturn NULL;\n\t\tds = be32_to_cpu(zeroes->size);\n\t} else if (wsame) {\n\t\tif (data_size != queue_logical_block_size(device->rq_queue)) {\n\t\t\tdrbd_err(peer_device, \"data size (%u) != drbd logical block size (%u)\\n\",\n\t\t\t\tdata_size, queue_logical_block_size(device->rq_queue));\n\t\t\treturn NULL;\n\t\t}\n\t\tif (data_size != bdev_logical_block_size(device->ldev->backing_bdev)) {\n\t\t\tdrbd_err(peer_device, \"data size (%u) != backend logical block size (%u)\\n\",\n\t\t\t\tdata_size, bdev_logical_block_size(device->ldev->backing_bdev));\n\t\t\treturn NULL;\n\t\t}\n\t\tds = be32_to_cpu(wsame->size);\n\t}\n\n\tif (!expect(IS_ALIGNED(ds, 512)))\n\t\treturn NULL;\n\tif (trim || wsame || zeroes) {\n\t\tif (!expect(ds <= (DRBD_MAX_BBIO_SECTORS << 9)))\n\t\t\treturn NULL;\n\t} else if (!expect(ds <= DRBD_MAX_BIO_SIZE))\n\t\treturn NULL;\n\n\t/* even though we trust out peer,\n\t * we sometimes have to double check. */\n\tif (sector + (ds>>9) > capacity) {\n\t\tdrbd_err(device, \"request from peer beyond end of local disk: \"\n\t\t\t\"capacity: %llus < sector: %llus + size: %u\\n\",\n\t\t\t(unsigned long long)capacity,\n\t\t\t(unsigned long long)sector, ds);\n\t\treturn NULL;\n\t}\n\n\t/* GFP_NOIO, because we must not cause arbitrary write-out: in a DRBD\n\t * \"criss-cross\" setup, that might cause write-out on some other DRBD,\n\t * which in turn might block on the other node at this very place.  */\n\tpeer_req = drbd_alloc_peer_req(peer_device, id, sector, ds, data_size, GFP_NOIO);\n\tif (!peer_req)\n\t\treturn NULL;\n\n\tpeer_req->flags |= EE_WRITE;\n\tif (trim) {\n\t\tpeer_req->flags |= EE_TRIM;\n\t\treturn peer_req;\n\t}\n\tif (zeroes) {\n\t\tpeer_req->flags |= EE_ZEROOUT;\n\t\treturn peer_req;\n\t}\n\tif (wsame)\n\t\tpeer_req->flags |= EE_WRITE_SAME;\n\n\t/* receive payload size bytes into page chain */\n\tds = data_size;\n\tpage = peer_req->pages;\n\tpage_chain_for_each(page) {\n\t\tunsigned len = min_t(int, ds, PAGE_SIZE);\n\t\tdata = kmap(page);\n\t\terr = drbd_recv_all_warn(peer_device->connection, data, len);\n\t\tif (drbd_insert_fault(device, DRBD_FAULT_RECEIVE)) {\n\t\t\tdrbd_err(device, \"Fault injection: Corrupting data on receive\\n\");\n\t\t\tdata[0] = data[0] ^ (unsigned long)-1;\n\t\t}\n\t\tkunmap(page);\n\t\tif (err) {\n\t\t\tdrbd_free_peer_req(device, peer_req);\n\t\t\treturn NULL;\n\t\t}\n\t\tds -= len;\n\t}\n\n\tif (digest_size) {\n\t\tdrbd_csum_ee_size(peer_device->connection->peer_integrity_tfm, peer_req, dig_vv, data_size);\n\t\tif (memcmp(dig_in, dig_vv, digest_size)) {\n\t\t\tdrbd_err(device, \"Digest integrity check FAILED: %llus +%u\\n\",\n\t\t\t\t(unsigned long long)sector, data_size);\n\t\t\tdrbd_free_peer_req(device, peer_req);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tdevice->recv_cnt += data_size >> 9;\n\treturn peer_req;\n}\n\n/* drbd_drain_block() just takes a data block\n * out of the socket input buffer, and discards it.\n */\nstatic int drbd_drain_block(struct drbd_peer_device *peer_device, int data_size)\n{\n\tstruct page *page;\n\tint err = 0;\n\tvoid *data;\n\n\tif (!data_size)\n\t\treturn 0;\n\n\tpage = drbd_alloc_pages(peer_device, 1, 1);\n\n\tdata = kmap(page);\n\twhile (data_size) {\n\t\tunsigned int len = min_t(int, data_size, PAGE_SIZE);\n\n\t\terr = drbd_recv_all_warn(peer_device->connection, data, len);\n\t\tif (err)\n\t\t\tbreak;\n\t\tdata_size -= len;\n\t}\n\tkunmap(page);\n\tdrbd_free_pages(peer_device->device, page, 0);\n\treturn err;\n}\n\nstatic int recv_dless_read(struct drbd_peer_device *peer_device, struct drbd_request *req,\n\t\t\t   sector_t sector, int data_size)\n{\n\tstruct bio_vec bvec;\n\tstruct bvec_iter iter;\n\tstruct bio *bio;\n\tint digest_size, err, expect;\n\tvoid *dig_in = peer_device->connection->int_dig_in;\n\tvoid *dig_vv = peer_device->connection->int_dig_vv;\n\n\tdigest_size = 0;\n\tif (peer_device->connection->peer_integrity_tfm) {\n\t\tdigest_size = crypto_shash_digestsize(peer_device->connection->peer_integrity_tfm);\n\t\terr = drbd_recv_all_warn(peer_device->connection, dig_in, digest_size);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdata_size -= digest_size;\n\t}\n\n\t/* optimistically update recv_cnt.  if receiving fails below,\n\t * we disconnect anyways, and counters will be reset. */\n\tpeer_device->device->recv_cnt += data_size>>9;\n\n\tbio = req->master_bio;\n\tD_ASSERT(peer_device->device, sector == bio->bi_iter.bi_sector);\n\n\tbio_for_each_segment(bvec, bio, iter) {\n\t\tvoid *mapped = kmap(bvec.bv_page) + bvec.bv_offset;\n\t\texpect = min_t(int, data_size, bvec.bv_len);\n\t\terr = drbd_recv_all_warn(peer_device->connection, mapped, expect);\n\t\tkunmap(bvec.bv_page);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdata_size -= expect;\n\t}\n\n\tif (digest_size) {\n\t\tdrbd_csum_bio(peer_device->connection->peer_integrity_tfm, bio, dig_vv);\n\t\tif (memcmp(dig_in, dig_vv, digest_size)) {\n\t\t\tdrbd_err(peer_device, \"Digest integrity check FAILED. Broken NICs?\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tD_ASSERT(peer_device->device, data_size == 0);\n\treturn 0;\n}\n\n/*\n * e_end_resync_block() is called in ack_sender context via\n * drbd_finish_peer_reqs().\n */\nstatic int e_end_resync_block(struct drbd_work *w, int unused)\n{\n\tstruct drbd_peer_request *peer_req =\n\t\tcontainer_of(w, struct drbd_peer_request, w);\n\tstruct drbd_peer_device *peer_device = peer_req->peer_device;\n\tstruct drbd_device *device = peer_device->device;\n\tsector_t sector = peer_req->i.sector;\n\tint err;\n\n\tD_ASSERT(device, drbd_interval_empty(&peer_req->i));\n\n\tif (likely((peer_req->flags & EE_WAS_ERROR) == 0)) {\n\t\tdrbd_set_in_sync(device, sector, peer_req->i.size);\n\t\terr = drbd_send_ack(peer_device, P_RS_WRITE_ACK, peer_req);\n\t} else {\n\t\t/* Record failure to sync */\n\t\tdrbd_rs_failed_io(device, sector, peer_req->i.size);\n\n\t\terr  = drbd_send_ack(peer_device, P_NEG_ACK, peer_req);\n\t}\n\tdec_unacked(device);\n\n\treturn err;\n}\n\nstatic int recv_resync_read(struct drbd_peer_device *peer_device, sector_t sector,\n\t\t\t    struct packet_info *pi) __releases(local)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tstruct drbd_peer_request *peer_req;\n\n\tpeer_req = read_in_block(peer_device, ID_SYNCER, sector, pi);\n\tif (!peer_req)\n\t\tgoto fail;\n\n\tdec_rs_pending(device);\n\n\tinc_unacked(device);\n\t/* corresponding dec_unacked() in e_end_resync_block()\n\t * respective _drbd_clear_done_ee */\n\n\tpeer_req->w.cb = e_end_resync_block;\n\tpeer_req->submit_jif = jiffies;\n\n\tspin_lock_irq(&device->resource->req_lock);\n\tlist_add_tail(&peer_req->w.list, &device->sync_ee);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\tatomic_add(pi->size >> 9, &device->rs_sect_ev);\n\tif (drbd_submit_peer_request(device, peer_req, REQ_OP_WRITE, 0,\n\t\t\t\t     DRBD_FAULT_RS_WR) == 0)\n\t\treturn 0;\n\n\t/* don't care for the reason here */\n\tdrbd_err(device, \"submit failed, triggering re-connect\\n\");\n\tspin_lock_irq(&device->resource->req_lock);\n\tlist_del(&peer_req->w.list);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\tdrbd_free_peer_req(device, peer_req);\nfail:\n\tput_ldev(device);\n\treturn -EIO;\n}\n\nstatic struct drbd_request *\nfind_request(struct drbd_device *device, struct rb_root *root, u64 id,\n\t     sector_t sector, bool missing_ok, const char *func)\n{\n\tstruct drbd_request *req;\n\n\t/* Request object according to our peer */\n\treq = (struct drbd_request *)(unsigned long)id;\n\tif (drbd_contains_interval(root, sector, &req->i) && req->i.local)\n\t\treturn req;\n\tif (!missing_ok) {\n\t\tdrbd_err(device, \"%s: failed to find request 0x%lx, sector %llus\\n\", func,\n\t\t\t(unsigned long)id, (unsigned long long)sector);\n\t}\n\treturn NULL;\n}\n\nstatic int receive_DataReply(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct drbd_request *req;\n\tsector_t sector;\n\tint err;\n\tstruct p_data *p = pi->data;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tsector = be64_to_cpu(p->sector);\n\n\tspin_lock_irq(&device->resource->req_lock);\n\treq = find_request(device, &device->read_requests, p->block_id, sector, false, __func__);\n\tspin_unlock_irq(&device->resource->req_lock);\n\tif (unlikely(!req))\n\t\treturn -EIO;\n\n\t/* hlist_del(&req->collision) is done in _req_may_be_done, to avoid\n\t * special casing it there for the various failure cases.\n\t * still no race with drbd_fail_pending_reads */\n\terr = recv_dless_read(peer_device, req, sector, pi->size);\n\tif (!err)\n\t\treq_mod(req, DATA_RECEIVED);\n\t/* else: nothing. handled from drbd_disconnect...\n\t * I don't think we may complete this just yet\n\t * in case we are \"on-disconnect: freeze\" */\n\n\treturn err;\n}\n\nstatic int receive_RSDataReply(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tsector_t sector;\n\tint err;\n\tstruct p_data *p = pi->data;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tsector = be64_to_cpu(p->sector);\n\tD_ASSERT(device, p->block_id == ID_SYNCER);\n\n\tif (get_ldev(device)) {\n\t\t/* data is submitted to disk within recv_resync_read.\n\t\t * corresponding put_ldev done below on error,\n\t\t * or in drbd_peer_request_endio. */\n\t\terr = recv_resync_read(peer_device, sector, pi);\n\t} else {\n\t\tif (__ratelimit(&drbd_ratelimit_state))\n\t\t\tdrbd_err(device, \"Can not write resync data to local disk.\\n\");\n\n\t\terr = drbd_drain_block(peer_device, pi->size);\n\n\t\tdrbd_send_ack_dp(peer_device, P_NEG_ACK, p, pi->size);\n\t}\n\n\tatomic_add(pi->size >> 9, &device->rs_sect_in);\n\n\treturn err;\n}\n\nstatic void restart_conflicting_writes(struct drbd_device *device,\n\t\t\t\t       sector_t sector, int size)\n{\n\tstruct drbd_interval *i;\n\tstruct drbd_request *req;\n\n\tdrbd_for_each_overlap(i, &device->write_requests, sector, size) {\n\t\tif (!i->local)\n\t\t\tcontinue;\n\t\treq = container_of(i, struct drbd_request, i);\n\t\tif (req->rq_state & RQ_LOCAL_PENDING ||\n\t\t    !(req->rq_state & RQ_POSTPONED))\n\t\t\tcontinue;\n\t\t/* as it is RQ_POSTPONED, this will cause it to\n\t\t * be queued on the retry workqueue. */\n\t\t__req_mod(req, CONFLICT_RESOLVED, NULL);\n\t}\n}\n\n/*\n * e_end_block() is called in ack_sender context via drbd_finish_peer_reqs().\n */\nstatic int e_end_block(struct drbd_work *w, int cancel)\n{\n\tstruct drbd_peer_request *peer_req =\n\t\tcontainer_of(w, struct drbd_peer_request, w);\n\tstruct drbd_peer_device *peer_device = peer_req->peer_device;\n\tstruct drbd_device *device = peer_device->device;\n\tsector_t sector = peer_req->i.sector;\n\tint err = 0, pcmd;\n\n\tif (peer_req->flags & EE_SEND_WRITE_ACK) {\n\t\tif (likely((peer_req->flags & EE_WAS_ERROR) == 0)) {\n\t\t\tpcmd = (device->state.conn >= C_SYNC_SOURCE &&\n\t\t\t\tdevice->state.conn <= C_PAUSED_SYNC_T &&\n\t\t\t\tpeer_req->flags & EE_MAY_SET_IN_SYNC) ?\n\t\t\t\tP_RS_WRITE_ACK : P_WRITE_ACK;\n\t\t\terr = drbd_send_ack(peer_device, pcmd, peer_req);\n\t\t\tif (pcmd == P_RS_WRITE_ACK)\n\t\t\t\tdrbd_set_in_sync(device, sector, peer_req->i.size);\n\t\t} else {\n\t\t\terr = drbd_send_ack(peer_device, P_NEG_ACK, peer_req);\n\t\t\t/* we expect it to be marked out of sync anyways...\n\t\t\t * maybe assert this?  */\n\t\t}\n\t\tdec_unacked(device);\n\t}\n\n\t/* we delete from the conflict detection hash _after_ we sent out the\n\t * P_WRITE_ACK / P_NEG_ACK, to get the sequence number right.  */\n\tif (peer_req->flags & EE_IN_INTERVAL_TREE) {\n\t\tspin_lock_irq(&device->resource->req_lock);\n\t\tD_ASSERT(device, !drbd_interval_empty(&peer_req->i));\n\t\tdrbd_remove_epoch_entry_interval(device, peer_req);\n\t\tif (peer_req->flags & EE_RESTART_REQUESTS)\n\t\t\trestart_conflicting_writes(device, sector, peer_req->i.size);\n\t\tspin_unlock_irq(&device->resource->req_lock);\n\t} else\n\t\tD_ASSERT(device, drbd_interval_empty(&peer_req->i));\n\n\tdrbd_may_finish_epoch(peer_device->connection, peer_req->epoch, EV_PUT + (cancel ? EV_CLEANUP : 0));\n\n\treturn err;\n}\n\nstatic int e_send_ack(struct drbd_work *w, enum drbd_packet ack)\n{\n\tstruct drbd_peer_request *peer_req =\n\t\tcontainer_of(w, struct drbd_peer_request, w);\n\tstruct drbd_peer_device *peer_device = peer_req->peer_device;\n\tint err;\n\n\terr = drbd_send_ack(peer_device, ack, peer_req);\n\tdec_unacked(peer_device->device);\n\n\treturn err;\n}\n\nstatic int e_send_superseded(struct drbd_work *w, int unused)\n{\n\treturn e_send_ack(w, P_SUPERSEDED);\n}\n\nstatic int e_send_retry_write(struct drbd_work *w, int unused)\n{\n\tstruct drbd_peer_request *peer_req =\n\t\tcontainer_of(w, struct drbd_peer_request, w);\n\tstruct drbd_connection *connection = peer_req->peer_device->connection;\n\n\treturn e_send_ack(w, connection->agreed_pro_version >= 100 ?\n\t\t\t     P_RETRY_WRITE : P_SUPERSEDED);\n}\n\nstatic bool seq_greater(u32 a, u32 b)\n{\n\t/*\n\t * We assume 32-bit wrap-around here.\n\t * For 24-bit wrap-around, we would have to shift:\n\t *  a <<= 8; b <<= 8;\n\t */\n\treturn (s32)a - (s32)b > 0;\n}\n\nstatic u32 seq_max(u32 a, u32 b)\n{\n\treturn seq_greater(a, b) ? a : b;\n}\n\nstatic void update_peer_seq(struct drbd_peer_device *peer_device, unsigned int peer_seq)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tunsigned int newest_peer_seq;\n\n\tif (test_bit(RESOLVE_CONFLICTS, &peer_device->connection->flags)) {\n\t\tspin_lock(&device->peer_seq_lock);\n\t\tnewest_peer_seq = seq_max(device->peer_seq, peer_seq);\n\t\tdevice->peer_seq = newest_peer_seq;\n\t\tspin_unlock(&device->peer_seq_lock);\n\t\t/* wake up only if we actually changed device->peer_seq */\n\t\tif (peer_seq == newest_peer_seq)\n\t\t\twake_up(&device->seq_wait);\n\t}\n}\n\nstatic inline int overlaps(sector_t s1, int l1, sector_t s2, int l2)\n{\n\treturn !((s1 + (l1>>9) <= s2) || (s1 >= s2 + (l2>>9)));\n}\n\n/* maybe change sync_ee into interval trees as well? */\nstatic bool overlapping_resync_write(struct drbd_device *device, struct drbd_peer_request *peer_req)\n{\n\tstruct drbd_peer_request *rs_req;\n\tbool rv = false;\n\n\tspin_lock_irq(&device->resource->req_lock);\n\tlist_for_each_entry(rs_req, &device->sync_ee, w.list) {\n\t\tif (overlaps(peer_req->i.sector, peer_req->i.size,\n\t\t\t     rs_req->i.sector, rs_req->i.size)) {\n\t\t\trv = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\treturn rv;\n}\n\n/* Called from receive_Data.\n * Synchronize packets on sock with packets on msock.\n *\n * This is here so even when a P_DATA packet traveling via sock overtook an Ack\n * packet traveling on msock, they are still processed in the order they have\n * been sent.\n *\n * Note: we don't care for Ack packets overtaking P_DATA packets.\n *\n * In case packet_seq is larger than device->peer_seq number, there are\n * outstanding packets on the msock. We wait for them to arrive.\n * In case we are the logically next packet, we update device->peer_seq\n * ourselves. Correctly handles 32bit wrap around.\n *\n * Assume we have a 10 GBit connection, that is about 1<<30 byte per second,\n * about 1<<21 sectors per second. So \"worst\" case, we have 1<<3 == 8 seconds\n * for the 24bit wrap (historical atomic_t guarantee on some archs), and we have\n * 1<<9 == 512 seconds aka ages for the 32bit wrap around...\n *\n * returns 0 if we may process the packet,\n * -ERESTARTSYS if we were interrupted (by disconnect signal). */\nstatic int wait_for_and_update_peer_seq(struct drbd_peer_device *peer_device, const u32 peer_seq)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tDEFINE_WAIT(wait);\n\tlong timeout;\n\tint ret = 0, tp;\n\n\tif (!test_bit(RESOLVE_CONFLICTS, &peer_device->connection->flags))\n\t\treturn 0;\n\n\tspin_lock(&device->peer_seq_lock);\n\tfor (;;) {\n\t\tif (!seq_greater(peer_seq - 1, device->peer_seq)) {\n\t\t\tdevice->peer_seq = seq_max(device->peer_seq, peer_seq);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\trcu_read_lock();\n\t\ttp = rcu_dereference(peer_device->connection->net_conf)->two_primaries;\n\t\trcu_read_unlock();\n\n\t\tif (!tp)\n\t\t\tbreak;\n\n\t\t/* Only need to wait if two_primaries is enabled */\n\t\tprepare_to_wait(&device->seq_wait, &wait, TASK_INTERRUPTIBLE);\n\t\tspin_unlock(&device->peer_seq_lock);\n\t\trcu_read_lock();\n\t\ttimeout = rcu_dereference(peer_device->connection->net_conf)->ping_timeo*HZ/10;\n\t\trcu_read_unlock();\n\t\ttimeout = schedule_timeout(timeout);\n\t\tspin_lock(&device->peer_seq_lock);\n\t\tif (!timeout) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tdrbd_err(device, \"Timed out waiting for missing ack packets; disconnecting\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&device->peer_seq_lock);\n\tfinish_wait(&device->seq_wait, &wait);\n\treturn ret;\n}\n\n/* see also bio_flags_to_wire()\n * DRBD_REQ_*, because we need to semantically map the flags to data packet\n * flags and back. We may replicate to other kernel versions. */\nstatic unsigned long wire_flags_to_bio_flags(u32 dpf)\n{\n\treturn  (dpf & DP_RW_SYNC ? REQ_SYNC : 0) |\n\t\t(dpf & DP_FUA ? REQ_FUA : 0) |\n\t\t(dpf & DP_FLUSH ? REQ_PREFLUSH : 0);\n}\n\nstatic unsigned long wire_flags_to_bio_op(u32 dpf)\n{\n\tif (dpf & DP_ZEROES)\n\t\treturn REQ_OP_WRITE_ZEROES;\n\tif (dpf & DP_DISCARD)\n\t\treturn REQ_OP_DISCARD;\n\tif (dpf & DP_WSAME)\n\t\treturn REQ_OP_WRITE_SAME;\n\telse\n\t\treturn REQ_OP_WRITE;\n}\n\nstatic void fail_postponed_requests(struct drbd_device *device, sector_t sector,\n\t\t\t\t    unsigned int size)\n{\n\tstruct drbd_interval *i;\n\n    repeat:\n\tdrbd_for_each_overlap(i, &device->write_requests, sector, size) {\n\t\tstruct drbd_request *req;\n\t\tstruct bio_and_error m;\n\n\t\tif (!i->local)\n\t\t\tcontinue;\n\t\treq = container_of(i, struct drbd_request, i);\n\t\tif (!(req->rq_state & RQ_POSTPONED))\n\t\t\tcontinue;\n\t\treq->rq_state &= ~RQ_POSTPONED;\n\t\t__req_mod(req, NEG_ACKED, &m);\n\t\tspin_unlock_irq(&device->resource->req_lock);\n\t\tif (m.bio)\n\t\t\tcomplete_master_bio(device, &m);\n\t\tspin_lock_irq(&device->resource->req_lock);\n\t\tgoto repeat;\n\t}\n}\n\nstatic int handle_write_conflicts(struct drbd_device *device,\n\t\t\t\t  struct drbd_peer_request *peer_req)\n{\n\tstruct drbd_connection *connection = peer_req->peer_device->connection;\n\tbool resolve_conflicts = test_bit(RESOLVE_CONFLICTS, &connection->flags);\n\tsector_t sector = peer_req->i.sector;\n\tconst unsigned int size = peer_req->i.size;\n\tstruct drbd_interval *i;\n\tbool equal;\n\tint err;\n\n\t/*\n\t * Inserting the peer request into the write_requests tree will prevent\n\t * new conflicting local requests from being added.\n\t */\n\tdrbd_insert_interval(&device->write_requests, &peer_req->i);\n\n    repeat:\n\tdrbd_for_each_overlap(i, &device->write_requests, sector, size) {\n\t\tif (i == &peer_req->i)\n\t\t\tcontinue;\n\t\tif (i->completed)\n\t\t\tcontinue;\n\n\t\tif (!i->local) {\n\t\t\t/*\n\t\t\t * Our peer has sent a conflicting remote request; this\n\t\t\t * should not happen in a two-node setup.  Wait for the\n\t\t\t * earlier peer request to complete.\n\t\t\t */\n\t\t\terr = drbd_wait_misc(device, i);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tequal = i->sector == sector && i->size == size;\n\t\tif (resolve_conflicts) {\n\t\t\t/*\n\t\t\t * If the peer request is fully contained within the\n\t\t\t * overlapping request, it can be considered overwritten\n\t\t\t * and thus superseded; otherwise, it will be retried\n\t\t\t * once all overlapping requests have completed.\n\t\t\t */\n\t\t\tbool superseded = i->sector <= sector && i->sector +\n\t\t\t\t       (i->size >> 9) >= sector + (size >> 9);\n\n\t\t\tif (!equal)\n\t\t\t\tdrbd_alert(device, \"Concurrent writes detected: \"\n\t\t\t\t\t       \"local=%llus +%u, remote=%llus +%u, \"\n\t\t\t\t\t       \"assuming %s came first\\n\",\n\t\t\t\t\t  (unsigned long long)i->sector, i->size,\n\t\t\t\t\t  (unsigned long long)sector, size,\n\t\t\t\t\t  superseded ? \"local\" : \"remote\");\n\n\t\t\tpeer_req->w.cb = superseded ? e_send_superseded :\n\t\t\t\t\t\t   e_send_retry_write;\n\t\t\tlist_add_tail(&peer_req->w.list, &device->done_ee);\n\t\t\tqueue_work(connection->ack_sender, &peer_req->peer_device->send_acks_work);\n\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tstruct drbd_request *req =\n\t\t\t\tcontainer_of(i, struct drbd_request, i);\n\n\t\t\tif (!equal)\n\t\t\t\tdrbd_alert(device, \"Concurrent writes detected: \"\n\t\t\t\t\t       \"local=%llus +%u, remote=%llus +%u\\n\",\n\t\t\t\t\t  (unsigned long long)i->sector, i->size,\n\t\t\t\t\t  (unsigned long long)sector, size);\n\n\t\t\tif (req->rq_state & RQ_LOCAL_PENDING ||\n\t\t\t    !(req->rq_state & RQ_POSTPONED)) {\n\t\t\t\t/*\n\t\t\t\t * Wait for the node with the discard flag to\n\t\t\t\t * decide if this request has been superseded\n\t\t\t\t * or needs to be retried.\n\t\t\t\t * Requests that have been superseded will\n\t\t\t\t * disappear from the write_requests tree.\n\t\t\t\t *\n\t\t\t\t * In addition, wait for the conflicting\n\t\t\t\t * request to finish locally before submitting\n\t\t\t\t * the conflicting peer request.\n\t\t\t\t */\n\t\t\t\terr = drbd_wait_misc(device, &req->i);\n\t\t\t\tif (err) {\n\t\t\t\t\t_conn_request_state(connection, NS(conn, C_TIMEOUT), CS_HARD);\n\t\t\t\t\tfail_postponed_requests(device, sector, size);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Remember to restart the conflicting requests after\n\t\t\t * the new peer request has completed.\n\t\t\t */\n\t\t\tpeer_req->flags |= EE_RESTART_REQUESTS;\n\t\t}\n\t}\n\terr = 0;\n\n    out:\n\tif (err)\n\t\tdrbd_remove_epoch_entry_interval(device, peer_req);\n\treturn err;\n}\n\n/* mirrored write */\nstatic int receive_Data(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct net_conf *nc;\n\tsector_t sector;\n\tstruct drbd_peer_request *peer_req;\n\tstruct p_data *p = pi->data;\n\tu32 peer_seq = be32_to_cpu(p->seq_num);\n\tint op, op_flags;\n\tu32 dp_flags;\n\tint err, tp;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tif (!get_ldev(device)) {\n\t\tint err2;\n\n\t\terr = wait_for_and_update_peer_seq(peer_device, peer_seq);\n\t\tdrbd_send_ack_dp(peer_device, P_NEG_ACK, p, pi->size);\n\t\tatomic_inc(&connection->current_epoch->epoch_size);\n\t\terr2 = drbd_drain_block(peer_device, pi->size);\n\t\tif (!err)\n\t\t\terr = err2;\n\t\treturn err;\n\t}\n\n\t/*\n\t * Corresponding put_ldev done either below (on various errors), or in\n\t * drbd_peer_request_endio, if we successfully submit the data at the\n\t * end of this function.\n\t */\n\n\tsector = be64_to_cpu(p->sector);\n\tpeer_req = read_in_block(peer_device, p->block_id, sector, pi);\n\tif (!peer_req) {\n\t\tput_ldev(device);\n\t\treturn -EIO;\n\t}\n\n\tpeer_req->w.cb = e_end_block;\n\tpeer_req->submit_jif = jiffies;\n\tpeer_req->flags |= EE_APPLICATION;\n\n\tdp_flags = be32_to_cpu(p->dp_flags);\n\top = wire_flags_to_bio_op(dp_flags);\n\top_flags = wire_flags_to_bio_flags(dp_flags);\n\tif (pi->cmd == P_TRIM) {\n\t\tD_ASSERT(peer_device, peer_req->i.size > 0);\n\t\tD_ASSERT(peer_device, op == REQ_OP_DISCARD);\n\t\tD_ASSERT(peer_device, peer_req->pages == NULL);\n\t\t/* need to play safe: an older DRBD sender\n\t\t * may mean zero-out while sending P_TRIM. */\n\t\tif (0 == (connection->agreed_features & DRBD_FF_WZEROES))\n\t\t\tpeer_req->flags |= EE_ZEROOUT;\n\t} else if (pi->cmd == P_ZEROES) {\n\t\tD_ASSERT(peer_device, peer_req->i.size > 0);\n\t\tD_ASSERT(peer_device, op == REQ_OP_WRITE_ZEROES);\n\t\tD_ASSERT(peer_device, peer_req->pages == NULL);\n\t\t/* Do (not) pass down BLKDEV_ZERO_NOUNMAP? */\n\t\tif (dp_flags & DP_DISCARD)\n\t\t\tpeer_req->flags |= EE_TRIM;\n\t} else if (peer_req->pages == NULL) {\n\t\tD_ASSERT(device, peer_req->i.size == 0);\n\t\tD_ASSERT(device, dp_flags & DP_FLUSH);\n\t}\n\n\tif (dp_flags & DP_MAY_SET_IN_SYNC)\n\t\tpeer_req->flags |= EE_MAY_SET_IN_SYNC;\n\n\tspin_lock(&connection->epoch_lock);\n\tpeer_req->epoch = connection->current_epoch;\n\tatomic_inc(&peer_req->epoch->epoch_size);\n\tatomic_inc(&peer_req->epoch->active);\n\tspin_unlock(&connection->epoch_lock);\n\n\trcu_read_lock();\n\tnc = rcu_dereference(peer_device->connection->net_conf);\n\ttp = nc->two_primaries;\n\tif (peer_device->connection->agreed_pro_version < 100) {\n\t\tswitch (nc->wire_protocol) {\n\t\tcase DRBD_PROT_C:\n\t\t\tdp_flags |= DP_SEND_WRITE_ACK;\n\t\t\tbreak;\n\t\tcase DRBD_PROT_B:\n\t\t\tdp_flags |= DP_SEND_RECEIVE_ACK;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (dp_flags & DP_SEND_WRITE_ACK) {\n\t\tpeer_req->flags |= EE_SEND_WRITE_ACK;\n\t\tinc_unacked(device);\n\t\t/* corresponding dec_unacked() in e_end_block()\n\t\t * respective _drbd_clear_done_ee */\n\t}\n\n\tif (dp_flags & DP_SEND_RECEIVE_ACK) {\n\t\t/* I really don't like it that the receiver thread\n\t\t * sends on the msock, but anyways */\n\t\tdrbd_send_ack(peer_device, P_RECV_ACK, peer_req);\n\t}\n\n\tif (tp) {\n\t\t/* two primaries implies protocol C */\n\t\tD_ASSERT(device, dp_flags & DP_SEND_WRITE_ACK);\n\t\tpeer_req->flags |= EE_IN_INTERVAL_TREE;\n\t\terr = wait_for_and_update_peer_seq(peer_device, peer_seq);\n\t\tif (err)\n\t\t\tgoto out_interrupted;\n\t\tspin_lock_irq(&device->resource->req_lock);\n\t\terr = handle_write_conflicts(device, peer_req);\n\t\tif (err) {\n\t\t\tspin_unlock_irq(&device->resource->req_lock);\n\t\t\tif (err == -ENOENT) {\n\t\t\t\tput_ldev(device);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tgoto out_interrupted;\n\t\t}\n\t} else {\n\t\tupdate_peer_seq(peer_device, peer_seq);\n\t\tspin_lock_irq(&device->resource->req_lock);\n\t}\n\t/* TRIM and WRITE_SAME are processed synchronously,\n\t * we wait for all pending requests, respectively wait for\n\t * active_ee to become empty in drbd_submit_peer_request();\n\t * better not add ourselves here. */\n\tif ((peer_req->flags & (EE_TRIM|EE_WRITE_SAME|EE_ZEROOUT)) == 0)\n\t\tlist_add_tail(&peer_req->w.list, &device->active_ee);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\tif (device->state.conn == C_SYNC_TARGET)\n\t\twait_event(device->ee_wait, !overlapping_resync_write(device, peer_req));\n\n\tif (device->state.pdsk < D_INCONSISTENT) {\n\t\t/* In case we have the only disk of the cluster, */\n\t\tdrbd_set_out_of_sync(device, peer_req->i.sector, peer_req->i.size);\n\t\tpeer_req->flags &= ~EE_MAY_SET_IN_SYNC;\n\t\tdrbd_al_begin_io(device, &peer_req->i);\n\t\tpeer_req->flags |= EE_CALL_AL_COMPLETE_IO;\n\t}\n\n\terr = drbd_submit_peer_request(device, peer_req, op, op_flags,\n\t\t\t\t       DRBD_FAULT_DT_WR);\n\tif (!err)\n\t\treturn 0;\n\n\t/* don't care for the reason here */\n\tdrbd_err(device, \"submit failed, triggering re-connect\\n\");\n\tspin_lock_irq(&device->resource->req_lock);\n\tlist_del(&peer_req->w.list);\n\tdrbd_remove_epoch_entry_interval(device, peer_req);\n\tspin_unlock_irq(&device->resource->req_lock);\n\tif (peer_req->flags & EE_CALL_AL_COMPLETE_IO) {\n\t\tpeer_req->flags &= ~EE_CALL_AL_COMPLETE_IO;\n\t\tdrbd_al_complete_io(device, &peer_req->i);\n\t}\n\nout_interrupted:\n\tdrbd_may_finish_epoch(connection, peer_req->epoch, EV_PUT | EV_CLEANUP);\n\tput_ldev(device);\n\tdrbd_free_peer_req(device, peer_req);\n\treturn err;\n}\n\n/* We may throttle resync, if the lower device seems to be busy,\n * and current sync rate is above c_min_rate.\n *\n * To decide whether or not the lower device is busy, we use a scheme similar\n * to MD RAID is_mddev_idle(): if the partition stats reveal \"significant\"\n * (more than 64 sectors) of activity we cannot account for with our own resync\n * activity, it obviously is \"busy\".\n *\n * The current sync rate used here uses only the most recent two step marks,\n * to have a short time average so we can react faster.\n */\nbool drbd_rs_should_slow_down(struct drbd_device *device, sector_t sector,\n\t\tbool throttle_if_app_is_waiting)\n{\n\tstruct lc_element *tmp;\n\tbool throttle = drbd_rs_c_min_rate_throttle(device);\n\n\tif (!throttle || throttle_if_app_is_waiting)\n\t\treturn throttle;\n\n\tspin_lock_irq(&device->al_lock);\n\ttmp = lc_find(device->resync, BM_SECT_TO_EXT(sector));\n\tif (tmp) {\n\t\tstruct bm_extent *bm_ext = lc_entry(tmp, struct bm_extent, lce);\n\t\tif (test_bit(BME_PRIORITY, &bm_ext->flags))\n\t\t\tthrottle = false;\n\t\t/* Do not slow down if app IO is already waiting for this extent,\n\t\t * and our progress is necessary for application IO to complete. */\n\t}\n\tspin_unlock_irq(&device->al_lock);\n\n\treturn throttle;\n}\n\nbool drbd_rs_c_min_rate_throttle(struct drbd_device *device)\n{\n\tstruct gendisk *disk = device->ldev->backing_bdev->bd_disk;\n\tunsigned long db, dt, dbdt;\n\tunsigned int c_min_rate;\n\tint curr_events;\n\n\trcu_read_lock();\n\tc_min_rate = rcu_dereference(device->ldev->disk_conf)->c_min_rate;\n\trcu_read_unlock();\n\n\t/* feature disabled? */\n\tif (c_min_rate == 0)\n\t\treturn false;\n\n\tcurr_events = (int)part_stat_read_accum(disk->part0, sectors) -\n\t\t\tatomic_read(&device->rs_sect_ev);\n\n\tif (atomic_read(&device->ap_actlog_cnt)\n\t    || curr_events - device->rs_last_events > 64) {\n\t\tunsigned long rs_left;\n\t\tint i;\n\n\t\tdevice->rs_last_events = curr_events;\n\n\t\t/* sync speed average over the last 2*DRBD_SYNC_MARK_STEP,\n\t\t * approx. */\n\t\ti = (device->rs_last_mark + DRBD_SYNC_MARKS-1) % DRBD_SYNC_MARKS;\n\n\t\tif (device->state.conn == C_VERIFY_S || device->state.conn == C_VERIFY_T)\n\t\t\trs_left = device->ov_left;\n\t\telse\n\t\t\trs_left = drbd_bm_total_weight(device) - device->rs_failed;\n\n\t\tdt = ((long)jiffies - (long)device->rs_mark_time[i]) / HZ;\n\t\tif (!dt)\n\t\t\tdt++;\n\t\tdb = device->rs_mark_left[i] - rs_left;\n\t\tdbdt = Bit2KB(db/dt);\n\n\t\tif (dbdt > c_min_rate)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int receive_DataRequest(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tsector_t sector;\n\tsector_t capacity;\n\tstruct drbd_peer_request *peer_req;\n\tstruct digest_info *di = NULL;\n\tint size, verb;\n\tunsigned int fault_type;\n\tstruct p_block_req *p =\tpi->data;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\tcapacity = get_capacity(device->vdisk);\n\n\tsector = be64_to_cpu(p->sector);\n\tsize   = be32_to_cpu(p->blksize);\n\n\tif (size <= 0 || !IS_ALIGNED(size, 512) || size > DRBD_MAX_BIO_SIZE) {\n\t\tdrbd_err(device, \"%s:%d: sector: %llus, size: %u\\n\", __FILE__, __LINE__,\n\t\t\t\t(unsigned long long)sector, size);\n\t\treturn -EINVAL;\n\t}\n\tif (sector + (size>>9) > capacity) {\n\t\tdrbd_err(device, \"%s:%d: sector: %llus, size: %u\\n\", __FILE__, __LINE__,\n\t\t\t\t(unsigned long long)sector, size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!get_ldev_if_state(device, D_UP_TO_DATE)) {\n\t\tverb = 1;\n\t\tswitch (pi->cmd) {\n\t\tcase P_DATA_REQUEST:\n\t\t\tdrbd_send_ack_rp(peer_device, P_NEG_DREPLY, p);\n\t\t\tbreak;\n\t\tcase P_RS_THIN_REQ:\n\t\tcase P_RS_DATA_REQUEST:\n\t\tcase P_CSUM_RS_REQUEST:\n\t\tcase P_OV_REQUEST:\n\t\t\tdrbd_send_ack_rp(peer_device, P_NEG_RS_DREPLY , p);\n\t\t\tbreak;\n\t\tcase P_OV_REPLY:\n\t\t\tverb = 0;\n\t\t\tdec_rs_pending(device);\n\t\t\tdrbd_send_ack_ex(peer_device, P_OV_RESULT, sector, size, ID_IN_SYNC);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tif (verb && __ratelimit(&drbd_ratelimit_state))\n\t\t\tdrbd_err(device, \"Can not satisfy peer's read request, \"\n\t\t\t    \"no local data.\\n\");\n\n\t\t/* drain possibly payload */\n\t\treturn drbd_drain_block(peer_device, pi->size);\n\t}\n\n\t/* GFP_NOIO, because we must not cause arbitrary write-out: in a DRBD\n\t * \"criss-cross\" setup, that might cause write-out on some other DRBD,\n\t * which in turn might block on the other node at this very place.  */\n\tpeer_req = drbd_alloc_peer_req(peer_device, p->block_id, sector, size,\n\t\t\tsize, GFP_NOIO);\n\tif (!peer_req) {\n\t\tput_ldev(device);\n\t\treturn -ENOMEM;\n\t}\n\n\tswitch (pi->cmd) {\n\tcase P_DATA_REQUEST:\n\t\tpeer_req->w.cb = w_e_end_data_req;\n\t\tfault_type = DRBD_FAULT_DT_RD;\n\t\t/* application IO, don't drbd_rs_begin_io */\n\t\tpeer_req->flags |= EE_APPLICATION;\n\t\tgoto submit;\n\n\tcase P_RS_THIN_REQ:\n\t\t/* If at some point in the future we have a smart way to\n\t\t   find out if this data block is completely deallocated,\n\t\t   then we would do something smarter here than reading\n\t\t   the block... */\n\t\tpeer_req->flags |= EE_RS_THIN_REQ;\n\t\tfallthrough;\n\tcase P_RS_DATA_REQUEST:\n\t\tpeer_req->w.cb = w_e_end_rsdata_req;\n\t\tfault_type = DRBD_FAULT_RS_RD;\n\t\t/* used in the sector offset progress display */\n\t\tdevice->bm_resync_fo = BM_SECT_TO_BIT(sector);\n\t\tbreak;\n\n\tcase P_OV_REPLY:\n\tcase P_CSUM_RS_REQUEST:\n\t\tfault_type = DRBD_FAULT_RS_RD;\n\t\tdi = kmalloc(sizeof(*di) + pi->size, GFP_NOIO);\n\t\tif (!di)\n\t\t\tgoto out_free_e;\n\n\t\tdi->digest_size = pi->size;\n\t\tdi->digest = (((char *)di)+sizeof(struct digest_info));\n\n\t\tpeer_req->digest = di;\n\t\tpeer_req->flags |= EE_HAS_DIGEST;\n\n\t\tif (drbd_recv_all(peer_device->connection, di->digest, pi->size))\n\t\t\tgoto out_free_e;\n\n\t\tif (pi->cmd == P_CSUM_RS_REQUEST) {\n\t\t\tD_ASSERT(device, peer_device->connection->agreed_pro_version >= 89);\n\t\t\tpeer_req->w.cb = w_e_end_csum_rs_req;\n\t\t\t/* used in the sector offset progress display */\n\t\t\tdevice->bm_resync_fo = BM_SECT_TO_BIT(sector);\n\t\t\t/* remember to report stats in drbd_resync_finished */\n\t\t\tdevice->use_csums = true;\n\t\t} else if (pi->cmd == P_OV_REPLY) {\n\t\t\t/* track progress, we may need to throttle */\n\t\t\tatomic_add(size >> 9, &device->rs_sect_in);\n\t\t\tpeer_req->w.cb = w_e_end_ov_reply;\n\t\t\tdec_rs_pending(device);\n\t\t\t/* drbd_rs_begin_io done when we sent this request,\n\t\t\t * but accounting still needs to be done. */\n\t\t\tgoto submit_for_resync;\n\t\t}\n\t\tbreak;\n\n\tcase P_OV_REQUEST:\n\t\tif (device->ov_start_sector == ~(sector_t)0 &&\n\t\t    peer_device->connection->agreed_pro_version >= 90) {\n\t\t\tunsigned long now = jiffies;\n\t\t\tint i;\n\t\t\tdevice->ov_start_sector = sector;\n\t\t\tdevice->ov_position = sector;\n\t\t\tdevice->ov_left = drbd_bm_bits(device) - BM_SECT_TO_BIT(sector);\n\t\t\tdevice->rs_total = device->ov_left;\n\t\t\tfor (i = 0; i < DRBD_SYNC_MARKS; i++) {\n\t\t\t\tdevice->rs_mark_left[i] = device->ov_left;\n\t\t\t\tdevice->rs_mark_time[i] = now;\n\t\t\t}\n\t\t\tdrbd_info(device, \"Online Verify start sector: %llu\\n\",\n\t\t\t\t\t(unsigned long long)sector);\n\t\t}\n\t\tpeer_req->w.cb = w_e_end_ov_req;\n\t\tfault_type = DRBD_FAULT_RS_RD;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Throttle, drbd_rs_begin_io and submit should become asynchronous\n\t * wrt the receiver, but it is not as straightforward as it may seem.\n\t * Various places in the resync start and stop logic assume resync\n\t * requests are processed in order, requeuing this on the worker thread\n\t * introduces a bunch of new code for synchronization between threads.\n\t *\n\t * Unlimited throttling before drbd_rs_begin_io may stall the resync\n\t * \"forever\", throttling after drbd_rs_begin_io will lock that extent\n\t * for application writes for the same time.  For now, just throttle\n\t * here, where the rest of the code expects the receiver to sleep for\n\t * a while, anyways.\n\t */\n\n\t/* Throttle before drbd_rs_begin_io, as that locks out application IO;\n\t * this defers syncer requests for some time, before letting at least\n\t * on request through.  The resync controller on the receiving side\n\t * will adapt to the incoming rate accordingly.\n\t *\n\t * We cannot throttle here if remote is Primary/SyncTarget:\n\t * we would also throttle its application reads.\n\t * In that case, throttling is done on the SyncTarget only.\n\t */\n\n\t/* Even though this may be a resync request, we do add to \"read_ee\";\n\t * \"sync_ee\" is only used for resync WRITEs.\n\t * Add to list early, so debugfs can find this request\n\t * even if we have to sleep below. */\n\tspin_lock_irq(&device->resource->req_lock);\n\tlist_add_tail(&peer_req->w.list, &device->read_ee);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\tupdate_receiver_timing_details(connection, drbd_rs_should_slow_down);\n\tif (device->state.peer != R_PRIMARY\n\t&& drbd_rs_should_slow_down(device, sector, false))\n\t\tschedule_timeout_uninterruptible(HZ/10);\n\tupdate_receiver_timing_details(connection, drbd_rs_begin_io);\n\tif (drbd_rs_begin_io(device, sector))\n\t\tgoto out_free_e;\n\nsubmit_for_resync:\n\tatomic_add(size >> 9, &device->rs_sect_ev);\n\nsubmit:\n\tupdate_receiver_timing_details(connection, drbd_submit_peer_request);\n\tinc_unacked(device);\n\tif (drbd_submit_peer_request(device, peer_req, REQ_OP_READ, 0,\n\t\t\t\t     fault_type) == 0)\n\t\treturn 0;\n\n\t/* don't care for the reason here */\n\tdrbd_err(device, \"submit failed, triggering re-connect\\n\");\n\nout_free_e:\n\tspin_lock_irq(&device->resource->req_lock);\n\tlist_del(&peer_req->w.list);\n\tspin_unlock_irq(&device->resource->req_lock);\n\t/* no drbd_rs_complete_io(), we are dropping the connection anyways */\n\n\tput_ldev(device);\n\tdrbd_free_peer_req(device, peer_req);\n\treturn -EIO;\n}\n\n/**\n * drbd_asb_recover_0p  -  Recover after split-brain with no remaining primaries\n */\nstatic int drbd_asb_recover_0p(struct drbd_peer_device *peer_device) __must_hold(local)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tint self, peer, rv = -100;\n\tunsigned long ch_self, ch_peer;\n\tenum drbd_after_sb_p after_sb_0p;\n\n\tself = device->ldev->md.uuid[UI_BITMAP] & 1;\n\tpeer = device->p_uuid[UI_BITMAP] & 1;\n\n\tch_peer = device->p_uuid[UI_SIZE];\n\tch_self = device->comm_bm_set;\n\n\trcu_read_lock();\n\tafter_sb_0p = rcu_dereference(peer_device->connection->net_conf)->after_sb_0p;\n\trcu_read_unlock();\n\tswitch (after_sb_0p) {\n\tcase ASB_CONSENSUS:\n\tcase ASB_DISCARD_SECONDARY:\n\tcase ASB_CALL_HELPER:\n\tcase ASB_VIOLENTLY:\n\t\tdrbd_err(device, \"Configuration error.\\n\");\n\t\tbreak;\n\tcase ASB_DISCONNECT:\n\t\tbreak;\n\tcase ASB_DISCARD_YOUNGER_PRI:\n\t\tif (self == 0 && peer == 1) {\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (self == 1 && peer == 0) {\n\t\t\trv =  1;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\t/* to one of the other strategies */\n\tcase ASB_DISCARD_OLDER_PRI:\n\t\tif (self == 0 && peer == 1) {\n\t\t\trv = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (self == 1 && peer == 0) {\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t\t/* Else fall through to one of the other strategies... */\n\t\tdrbd_warn(device, \"Discard younger/older primary did not find a decision\\n\"\n\t\t     \"Using discard-least-changes instead\\n\");\n\t\tfallthrough;\n\tcase ASB_DISCARD_ZERO_CHG:\n\t\tif (ch_peer == 0 && ch_self == 0) {\n\t\t\trv = test_bit(RESOLVE_CONFLICTS, &peer_device->connection->flags)\n\t\t\t\t? -1 : 1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (ch_peer == 0) { rv =  1; break; }\n\t\t\tif (ch_self == 0) { rv = -1; break; }\n\t\t}\n\t\tif (after_sb_0p == ASB_DISCARD_ZERO_CHG)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase ASB_DISCARD_LEAST_CHG:\n\t\tif\t(ch_self < ch_peer)\n\t\t\trv = -1;\n\t\telse if (ch_self > ch_peer)\n\t\t\trv =  1;\n\t\telse /* ( ch_self == ch_peer ) */\n\t\t     /* Well, then use something else. */\n\t\t\trv = test_bit(RESOLVE_CONFLICTS, &peer_device->connection->flags)\n\t\t\t\t? -1 : 1;\n\t\tbreak;\n\tcase ASB_DISCARD_LOCAL:\n\t\trv = -1;\n\t\tbreak;\n\tcase ASB_DISCARD_REMOTE:\n\t\trv =  1;\n\t}\n\n\treturn rv;\n}\n\n/**\n * drbd_asb_recover_1p  -  Recover after split-brain with one remaining primary\n */\nstatic int drbd_asb_recover_1p(struct drbd_peer_device *peer_device) __must_hold(local)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tint hg, rv = -100;\n\tenum drbd_after_sb_p after_sb_1p;\n\n\trcu_read_lock();\n\tafter_sb_1p = rcu_dereference(peer_device->connection->net_conf)->after_sb_1p;\n\trcu_read_unlock();\n\tswitch (after_sb_1p) {\n\tcase ASB_DISCARD_YOUNGER_PRI:\n\tcase ASB_DISCARD_OLDER_PRI:\n\tcase ASB_DISCARD_LEAST_CHG:\n\tcase ASB_DISCARD_LOCAL:\n\tcase ASB_DISCARD_REMOTE:\n\tcase ASB_DISCARD_ZERO_CHG:\n\t\tdrbd_err(device, \"Configuration error.\\n\");\n\t\tbreak;\n\tcase ASB_DISCONNECT:\n\t\tbreak;\n\tcase ASB_CONSENSUS:\n\t\thg = drbd_asb_recover_0p(peer_device);\n\t\tif (hg == -1 && device->state.role == R_SECONDARY)\n\t\t\trv = hg;\n\t\tif (hg == 1  && device->state.role == R_PRIMARY)\n\t\t\trv = hg;\n\t\tbreak;\n\tcase ASB_VIOLENTLY:\n\t\trv = drbd_asb_recover_0p(peer_device);\n\t\tbreak;\n\tcase ASB_DISCARD_SECONDARY:\n\t\treturn device->state.role == R_PRIMARY ? 1 : -1;\n\tcase ASB_CALL_HELPER:\n\t\thg = drbd_asb_recover_0p(peer_device);\n\t\tif (hg == -1 && device->state.role == R_PRIMARY) {\n\t\t\tenum drbd_state_rv rv2;\n\n\t\t\t /* drbd_change_state() does not sleep while in SS_IN_TRANSIENT_STATE,\n\t\t\t  * we might be here in C_WF_REPORT_PARAMS which is transient.\n\t\t\t  * we do not need to wait for the after state change work either. */\n\t\t\trv2 = drbd_change_state(device, CS_VERBOSE, NS(role, R_SECONDARY));\n\t\t\tif (rv2 != SS_SUCCESS) {\n\t\t\t\tdrbd_khelper(device, \"pri-lost-after-sb\");\n\t\t\t} else {\n\t\t\t\tdrbd_warn(device, \"Successfully gave up primary role.\\n\");\n\t\t\t\trv = hg;\n\t\t\t}\n\t\t} else\n\t\t\trv = hg;\n\t}\n\n\treturn rv;\n}\n\n/**\n * drbd_asb_recover_2p  -  Recover after split-brain with two remaining primaries\n */\nstatic int drbd_asb_recover_2p(struct drbd_peer_device *peer_device) __must_hold(local)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tint hg, rv = -100;\n\tenum drbd_after_sb_p after_sb_2p;\n\n\trcu_read_lock();\n\tafter_sb_2p = rcu_dereference(peer_device->connection->net_conf)->after_sb_2p;\n\trcu_read_unlock();\n\tswitch (after_sb_2p) {\n\tcase ASB_DISCARD_YOUNGER_PRI:\n\tcase ASB_DISCARD_OLDER_PRI:\n\tcase ASB_DISCARD_LEAST_CHG:\n\tcase ASB_DISCARD_LOCAL:\n\tcase ASB_DISCARD_REMOTE:\n\tcase ASB_CONSENSUS:\n\tcase ASB_DISCARD_SECONDARY:\n\tcase ASB_DISCARD_ZERO_CHG:\n\t\tdrbd_err(device, \"Configuration error.\\n\");\n\t\tbreak;\n\tcase ASB_VIOLENTLY:\n\t\trv = drbd_asb_recover_0p(peer_device);\n\t\tbreak;\n\tcase ASB_DISCONNECT:\n\t\tbreak;\n\tcase ASB_CALL_HELPER:\n\t\thg = drbd_asb_recover_0p(peer_device);\n\t\tif (hg == -1) {\n\t\t\tenum drbd_state_rv rv2;\n\n\t\t\t /* drbd_change_state() does not sleep while in SS_IN_TRANSIENT_STATE,\n\t\t\t  * we might be here in C_WF_REPORT_PARAMS which is transient.\n\t\t\t  * we do not need to wait for the after state change work either. */\n\t\t\trv2 = drbd_change_state(device, CS_VERBOSE, NS(role, R_SECONDARY));\n\t\t\tif (rv2 != SS_SUCCESS) {\n\t\t\t\tdrbd_khelper(device, \"pri-lost-after-sb\");\n\t\t\t} else {\n\t\t\t\tdrbd_warn(device, \"Successfully gave up primary role.\\n\");\n\t\t\t\trv = hg;\n\t\t\t}\n\t\t} else\n\t\t\trv = hg;\n\t}\n\n\treturn rv;\n}\n\nstatic void drbd_uuid_dump(struct drbd_device *device, char *text, u64 *uuid,\n\t\t\t   u64 bits, u64 flags)\n{\n\tif (!uuid) {\n\t\tdrbd_info(device, \"%s uuid info vanished while I was looking!\\n\", text);\n\t\treturn;\n\t}\n\tdrbd_info(device, \"%s %016llX:%016llX:%016llX:%016llX bits:%llu flags:%llX\\n\",\n\t     text,\n\t     (unsigned long long)uuid[UI_CURRENT],\n\t     (unsigned long long)uuid[UI_BITMAP],\n\t     (unsigned long long)uuid[UI_HISTORY_START],\n\t     (unsigned long long)uuid[UI_HISTORY_END],\n\t     (unsigned long long)bits,\n\t     (unsigned long long)flags);\n}\n\n/*\n  100\tafter split brain try auto recover\n    2\tC_SYNC_SOURCE set BitMap\n    1\tC_SYNC_SOURCE use BitMap\n    0\tno Sync\n   -1\tC_SYNC_TARGET use BitMap\n   -2\tC_SYNC_TARGET set BitMap\n -100\tafter split brain, disconnect\n-1000\tunrelated data\n-1091   requires proto 91\n-1096   requires proto 96\n */\n\nstatic int drbd_uuid_compare(struct drbd_device *const device, enum drbd_role const peer_role, int *rule_nr) __must_hold(local)\n{\n\tstruct drbd_peer_device *const peer_device = first_peer_device(device);\n\tstruct drbd_connection *const connection = peer_device ? peer_device->connection : NULL;\n\tu64 self, peer;\n\tint i, j;\n\n\tself = device->ldev->md.uuid[UI_CURRENT] & ~((u64)1);\n\tpeer = device->p_uuid[UI_CURRENT] & ~((u64)1);\n\n\t*rule_nr = 10;\n\tif (self == UUID_JUST_CREATED && peer == UUID_JUST_CREATED)\n\t\treturn 0;\n\n\t*rule_nr = 20;\n\tif ((self == UUID_JUST_CREATED || self == (u64)0) &&\n\t     peer != UUID_JUST_CREATED)\n\t\treturn -2;\n\n\t*rule_nr = 30;\n\tif (self != UUID_JUST_CREATED &&\n\t    (peer == UUID_JUST_CREATED || peer == (u64)0))\n\t\treturn 2;\n\n\tif (self == peer) {\n\t\tint rct, dc; /* roles at crash time */\n\n\t\tif (device->p_uuid[UI_BITMAP] == (u64)0 && device->ldev->md.uuid[UI_BITMAP] != (u64)0) {\n\n\t\t\tif (connection->agreed_pro_version < 91)\n\t\t\t\treturn -1091;\n\n\t\t\tif ((device->ldev->md.uuid[UI_BITMAP] & ~((u64)1)) == (device->p_uuid[UI_HISTORY_START] & ~((u64)1)) &&\n\t\t\t    (device->ldev->md.uuid[UI_HISTORY_START] & ~((u64)1)) == (device->p_uuid[UI_HISTORY_START + 1] & ~((u64)1))) {\n\t\t\t\tdrbd_info(device, \"was SyncSource, missed the resync finished event, corrected myself:\\n\");\n\t\t\t\tdrbd_uuid_move_history(device);\n\t\t\t\tdevice->ldev->md.uuid[UI_HISTORY_START] = device->ldev->md.uuid[UI_BITMAP];\n\t\t\t\tdevice->ldev->md.uuid[UI_BITMAP] = 0;\n\n\t\t\t\tdrbd_uuid_dump(device, \"self\", device->ldev->md.uuid,\n\t\t\t\t\t       device->state.disk >= D_NEGOTIATING ? drbd_bm_total_weight(device) : 0, 0);\n\t\t\t\t*rule_nr = 34;\n\t\t\t} else {\n\t\t\t\tdrbd_info(device, \"was SyncSource (peer failed to write sync_uuid)\\n\");\n\t\t\t\t*rule_nr = 36;\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (device->ldev->md.uuid[UI_BITMAP] == (u64)0 && device->p_uuid[UI_BITMAP] != (u64)0) {\n\n\t\t\tif (connection->agreed_pro_version < 91)\n\t\t\t\treturn -1091;\n\n\t\t\tif ((device->ldev->md.uuid[UI_HISTORY_START] & ~((u64)1)) == (device->p_uuid[UI_BITMAP] & ~((u64)1)) &&\n\t\t\t    (device->ldev->md.uuid[UI_HISTORY_START + 1] & ~((u64)1)) == (device->p_uuid[UI_HISTORY_START] & ~((u64)1))) {\n\t\t\t\tdrbd_info(device, \"was SyncTarget, peer missed the resync finished event, corrected peer:\\n\");\n\n\t\t\t\tdevice->p_uuid[UI_HISTORY_START + 1] = device->p_uuid[UI_HISTORY_START];\n\t\t\t\tdevice->p_uuid[UI_HISTORY_START] = device->p_uuid[UI_BITMAP];\n\t\t\t\tdevice->p_uuid[UI_BITMAP] = 0UL;\n\n\t\t\t\tdrbd_uuid_dump(device, \"peer\", device->p_uuid, device->p_uuid[UI_SIZE], device->p_uuid[UI_FLAGS]);\n\t\t\t\t*rule_nr = 35;\n\t\t\t} else {\n\t\t\t\tdrbd_info(device, \"was SyncTarget (failed to write sync_uuid)\\n\");\n\t\t\t\t*rule_nr = 37;\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Common power [off|failure] */\n\t\trct = (test_bit(CRASHED_PRIMARY, &device->flags) ? 1 : 0) +\n\t\t\t(device->p_uuid[UI_FLAGS] & 2);\n\t\t/* lowest bit is set when we were primary,\n\t\t * next bit (weight 2) is set when peer was primary */\n\t\t*rule_nr = 40;\n\n\t\t/* Neither has the \"crashed primary\" flag set,\n\t\t * only a replication link hickup. */\n\t\tif (rct == 0)\n\t\t\treturn 0;\n\n\t\t/* Current UUID equal and no bitmap uuid; does not necessarily\n\t\t * mean this was a \"simultaneous hard crash\", maybe IO was\n\t\t * frozen, so no UUID-bump happened.\n\t\t * This is a protocol change, overload DRBD_FF_WSAME as flag\n\t\t * for \"new-enough\" peer DRBD version. */\n\t\tif (device->state.role == R_PRIMARY || peer_role == R_PRIMARY) {\n\t\t\t*rule_nr = 41;\n\t\t\tif (!(connection->agreed_features & DRBD_FF_WSAME)) {\n\t\t\t\tdrbd_warn(peer_device, \"Equivalent unrotated UUIDs, but current primary present.\\n\");\n\t\t\t\treturn -(0x10000 | PRO_VERSION_MAX | (DRBD_FF_WSAME << 8));\n\t\t\t}\n\t\t\tif (device->state.role == R_PRIMARY && peer_role == R_PRIMARY) {\n\t\t\t\t/* At least one has the \"crashed primary\" bit set,\n\t\t\t\t * both are primary now, but neither has rotated its UUIDs?\n\t\t\t\t * \"Can not happen.\" */\n\t\t\t\tdrbd_err(peer_device, \"Equivalent unrotated UUIDs, but both are primary. Can not resolve this.\\n\");\n\t\t\t\treturn -100;\n\t\t\t}\n\t\t\tif (device->state.role == R_PRIMARY)\n\t\t\t\treturn 1;\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Both are secondary.\n\t\t * Really looks like recovery from simultaneous hard crash.\n\t\t * Check which had been primary before, and arbitrate. */\n\t\tswitch (rct) {\n\t\tcase 0: /* !self_pri && !peer_pri */ return 0; /* already handled */\n\t\tcase 1: /*  self_pri && !peer_pri */ return 1;\n\t\tcase 2: /* !self_pri &&  peer_pri */ return -1;\n\t\tcase 3: /*  self_pri &&  peer_pri */\n\t\t\tdc = test_bit(RESOLVE_CONFLICTS, &connection->flags);\n\t\t\treturn dc ? -1 : 1;\n\t\t}\n\t}\n\n\t*rule_nr = 50;\n\tpeer = device->p_uuid[UI_BITMAP] & ~((u64)1);\n\tif (self == peer)\n\t\treturn -1;\n\n\t*rule_nr = 51;\n\tpeer = device->p_uuid[UI_HISTORY_START] & ~((u64)1);\n\tif (self == peer) {\n\t\tif (connection->agreed_pro_version < 96 ?\n\t\t    (device->ldev->md.uuid[UI_HISTORY_START] & ~((u64)1)) ==\n\t\t    (device->p_uuid[UI_HISTORY_START + 1] & ~((u64)1)) :\n\t\t    peer + UUID_NEW_BM_OFFSET == (device->p_uuid[UI_BITMAP] & ~((u64)1))) {\n\t\t\t/* The last P_SYNC_UUID did not get though. Undo the last start of\n\t\t\t   resync as sync source modifications of the peer's UUIDs. */\n\n\t\t\tif (connection->agreed_pro_version < 91)\n\t\t\t\treturn -1091;\n\n\t\t\tdevice->p_uuid[UI_BITMAP] = device->p_uuid[UI_HISTORY_START];\n\t\t\tdevice->p_uuid[UI_HISTORY_START] = device->p_uuid[UI_HISTORY_START + 1];\n\n\t\t\tdrbd_info(device, \"Lost last syncUUID packet, corrected:\\n\");\n\t\t\tdrbd_uuid_dump(device, \"peer\", device->p_uuid, device->p_uuid[UI_SIZE], device->p_uuid[UI_FLAGS]);\n\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t*rule_nr = 60;\n\tself = device->ldev->md.uuid[UI_CURRENT] & ~((u64)1);\n\tfor (i = UI_HISTORY_START; i <= UI_HISTORY_END; i++) {\n\t\tpeer = device->p_uuid[i] & ~((u64)1);\n\t\tif (self == peer)\n\t\t\treturn -2;\n\t}\n\n\t*rule_nr = 70;\n\tself = device->ldev->md.uuid[UI_BITMAP] & ~((u64)1);\n\tpeer = device->p_uuid[UI_CURRENT] & ~((u64)1);\n\tif (self == peer)\n\t\treturn 1;\n\n\t*rule_nr = 71;\n\tself = device->ldev->md.uuid[UI_HISTORY_START] & ~((u64)1);\n\tif (self == peer) {\n\t\tif (connection->agreed_pro_version < 96 ?\n\t\t    (device->ldev->md.uuid[UI_HISTORY_START + 1] & ~((u64)1)) ==\n\t\t    (device->p_uuid[UI_HISTORY_START] & ~((u64)1)) :\n\t\t    self + UUID_NEW_BM_OFFSET == (device->ldev->md.uuid[UI_BITMAP] & ~((u64)1))) {\n\t\t\t/* The last P_SYNC_UUID did not get though. Undo the last start of\n\t\t\t   resync as sync source modifications of our UUIDs. */\n\n\t\t\tif (connection->agreed_pro_version < 91)\n\t\t\t\treturn -1091;\n\n\t\t\t__drbd_uuid_set(device, UI_BITMAP, device->ldev->md.uuid[UI_HISTORY_START]);\n\t\t\t__drbd_uuid_set(device, UI_HISTORY_START, device->ldev->md.uuid[UI_HISTORY_START + 1]);\n\n\t\t\tdrbd_info(device, \"Last syncUUID did not get through, corrected:\\n\");\n\t\t\tdrbd_uuid_dump(device, \"self\", device->ldev->md.uuid,\n\t\t\t\t       device->state.disk >= D_NEGOTIATING ? drbd_bm_total_weight(device) : 0, 0);\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\n\t*rule_nr = 80;\n\tpeer = device->p_uuid[UI_CURRENT] & ~((u64)1);\n\tfor (i = UI_HISTORY_START; i <= UI_HISTORY_END; i++) {\n\t\tself = device->ldev->md.uuid[i] & ~((u64)1);\n\t\tif (self == peer)\n\t\t\treturn 2;\n\t}\n\n\t*rule_nr = 90;\n\tself = device->ldev->md.uuid[UI_BITMAP] & ~((u64)1);\n\tpeer = device->p_uuid[UI_BITMAP] & ~((u64)1);\n\tif (self == peer && self != ((u64)0))\n\t\treturn 100;\n\n\t*rule_nr = 100;\n\tfor (i = UI_HISTORY_START; i <= UI_HISTORY_END; i++) {\n\t\tself = device->ldev->md.uuid[i] & ~((u64)1);\n\t\tfor (j = UI_HISTORY_START; j <= UI_HISTORY_END; j++) {\n\t\t\tpeer = device->p_uuid[j] & ~((u64)1);\n\t\t\tif (self == peer)\n\t\t\t\treturn -100;\n\t\t}\n\t}\n\n\treturn -1000;\n}\n\n/* drbd_sync_handshake() returns the new conn state on success, or\n   CONN_MASK (-1) on failure.\n */\nstatic enum drbd_conns drbd_sync_handshake(struct drbd_peer_device *peer_device,\n\t\t\t\t\t   enum drbd_role peer_role,\n\t\t\t\t\t   enum drbd_disk_state peer_disk) __must_hold(local)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tenum drbd_conns rv = C_MASK;\n\tenum drbd_disk_state mydisk;\n\tstruct net_conf *nc;\n\tint hg, rule_nr, rr_conflict, tentative, always_asbp;\n\n\tmydisk = device->state.disk;\n\tif (mydisk == D_NEGOTIATING)\n\t\tmydisk = device->new_state_tmp.disk;\n\n\tdrbd_info(device, \"drbd_sync_handshake:\\n\");\n\n\tspin_lock_irq(&device->ldev->md.uuid_lock);\n\tdrbd_uuid_dump(device, \"self\", device->ldev->md.uuid, device->comm_bm_set, 0);\n\tdrbd_uuid_dump(device, \"peer\", device->p_uuid,\n\t\t       device->p_uuid[UI_SIZE], device->p_uuid[UI_FLAGS]);\n\n\thg = drbd_uuid_compare(device, peer_role, &rule_nr);\n\tspin_unlock_irq(&device->ldev->md.uuid_lock);\n\n\tdrbd_info(device, \"uuid_compare()=%d by rule %d\\n\", hg, rule_nr);\n\n\tif (hg == -1000) {\n\t\tdrbd_alert(device, \"Unrelated data, aborting!\\n\");\n\t\treturn C_MASK;\n\t}\n\tif (hg < -0x10000) {\n\t\tint proto, fflags;\n\t\thg = -hg;\n\t\tproto = hg & 0xff;\n\t\tfflags = (hg >> 8) & 0xff;\n\t\tdrbd_alert(device, \"To resolve this both sides have to support at least protocol %d and feature flags 0x%x\\n\",\n\t\t\t\t\tproto, fflags);\n\t\treturn C_MASK;\n\t}\n\tif (hg < -1000) {\n\t\tdrbd_alert(device, \"To resolve this both sides have to support at least protocol %d\\n\", -hg - 1000);\n\t\treturn C_MASK;\n\t}\n\n\tif    ((mydisk == D_INCONSISTENT && peer_disk > D_INCONSISTENT) ||\n\t    (peer_disk == D_INCONSISTENT && mydisk    > D_INCONSISTENT)) {\n\t\tint f = (hg == -100) || abs(hg) == 2;\n\t\thg = mydisk > D_INCONSISTENT ? 1 : -1;\n\t\tif (f)\n\t\t\thg = hg*2;\n\t\tdrbd_info(device, \"Becoming sync %s due to disk states.\\n\",\n\t\t     hg > 0 ? \"source\" : \"target\");\n\t}\n\n\tif (abs(hg) == 100)\n\t\tdrbd_khelper(device, \"initial-split-brain\");\n\n\trcu_read_lock();\n\tnc = rcu_dereference(peer_device->connection->net_conf);\n\talways_asbp = nc->always_asbp;\n\trr_conflict = nc->rr_conflict;\n\ttentative = nc->tentative;\n\trcu_read_unlock();\n\n\tif (hg == 100 || (hg == -100 && always_asbp)) {\n\t\tint pcount = (device->state.role == R_PRIMARY)\n\t\t\t   + (peer_role == R_PRIMARY);\n\t\tint forced = (hg == -100);\n\n\t\tswitch (pcount) {\n\t\tcase 0:\n\t\t\thg = drbd_asb_recover_0p(peer_device);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\thg = drbd_asb_recover_1p(peer_device);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\thg = drbd_asb_recover_2p(peer_device);\n\t\t\tbreak;\n\t\t}\n\t\tif (abs(hg) < 100) {\n\t\t\tdrbd_warn(device, \"Split-Brain detected, %d primaries, \"\n\t\t\t     \"automatically solved. Sync from %s node\\n\",\n\t\t\t     pcount, (hg < 0) ? \"peer\" : \"this\");\n\t\t\tif (forced) {\n\t\t\t\tdrbd_warn(device, \"Doing a full sync, since\"\n\t\t\t\t     \" UUIDs where ambiguous.\\n\");\n\t\t\t\thg = hg*2;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hg == -100) {\n\t\tif (test_bit(DISCARD_MY_DATA, &device->flags) && !(device->p_uuid[UI_FLAGS]&1))\n\t\t\thg = -1;\n\t\tif (!test_bit(DISCARD_MY_DATA, &device->flags) && (device->p_uuid[UI_FLAGS]&1))\n\t\t\thg = 1;\n\n\t\tif (abs(hg) < 100)\n\t\t\tdrbd_warn(device, \"Split-Brain detected, manually solved. \"\n\t\t\t     \"Sync from %s node\\n\",\n\t\t\t     (hg < 0) ? \"peer\" : \"this\");\n\t}\n\n\tif (hg == -100) {\n\t\t/* FIXME this log message is not correct if we end up here\n\t\t * after an attempted attach on a diskless node.\n\t\t * We just refuse to attach -- well, we drop the \"connection\"\n\t\t * to that disk, in a way... */\n\t\tdrbd_alert(device, \"Split-Brain detected but unresolved, dropping connection!\\n\");\n\t\tdrbd_khelper(device, \"split-brain\");\n\t\treturn C_MASK;\n\t}\n\n\tif (hg > 0 && mydisk <= D_INCONSISTENT) {\n\t\tdrbd_err(device, \"I shall become SyncSource, but I am inconsistent!\\n\");\n\t\treturn C_MASK;\n\t}\n\n\tif (hg < 0 && /* by intention we do not use mydisk here. */\n\t    device->state.role == R_PRIMARY && device->state.disk >= D_CONSISTENT) {\n\t\tswitch (rr_conflict) {\n\t\tcase ASB_CALL_HELPER:\n\t\t\tdrbd_khelper(device, \"pri-lost\");\n\t\t\tfallthrough;\n\t\tcase ASB_DISCONNECT:\n\t\t\tdrbd_err(device, \"I shall become SyncTarget, but I am primary!\\n\");\n\t\t\treturn C_MASK;\n\t\tcase ASB_VIOLENTLY:\n\t\t\tdrbd_warn(device, \"Becoming SyncTarget, violating the stable-data\"\n\t\t\t     \"assumption\\n\");\n\t\t}\n\t}\n\n\tif (tentative || test_bit(CONN_DRY_RUN, &peer_device->connection->flags)) {\n\t\tif (hg == 0)\n\t\t\tdrbd_info(device, \"dry-run connect: No resync, would become Connected immediately.\\n\");\n\t\telse\n\t\t\tdrbd_info(device, \"dry-run connect: Would become %s, doing a %s resync.\",\n\t\t\t\t drbd_conn_str(hg > 0 ? C_SYNC_SOURCE : C_SYNC_TARGET),\n\t\t\t\t abs(hg) >= 2 ? \"full\" : \"bit-map based\");\n\t\treturn C_MASK;\n\t}\n\n\tif (abs(hg) >= 2) {\n\t\tdrbd_info(device, \"Writing the whole bitmap, full sync required after drbd_sync_handshake.\\n\");\n\t\tif (drbd_bitmap_io(device, &drbd_bmio_set_n_write, \"set_n_write from sync_handshake\",\n\t\t\t\t\tBM_LOCKED_SET_ALLOWED))\n\t\t\treturn C_MASK;\n\t}\n\n\tif (hg > 0) { /* become sync source. */\n\t\trv = C_WF_BITMAP_S;\n\t} else if (hg < 0) { /* become sync target */\n\t\trv = C_WF_BITMAP_T;\n\t} else {\n\t\trv = C_CONNECTED;\n\t\tif (drbd_bm_total_weight(device)) {\n\t\t\tdrbd_info(device, \"No resync, but %lu bits in bitmap!\\n\",\n\t\t\t     drbd_bm_total_weight(device));\n\t\t}\n\t}\n\n\treturn rv;\n}\n\nstatic enum drbd_after_sb_p convert_after_sb(enum drbd_after_sb_p peer)\n{\n\t/* ASB_DISCARD_REMOTE - ASB_DISCARD_LOCAL is valid */\n\tif (peer == ASB_DISCARD_REMOTE)\n\t\treturn ASB_DISCARD_LOCAL;\n\n\t/* any other things with ASB_DISCARD_REMOTE or ASB_DISCARD_LOCAL are invalid */\n\tif (peer == ASB_DISCARD_LOCAL)\n\t\treturn ASB_DISCARD_REMOTE;\n\n\t/* everything else is valid if they are equal on both sides. */\n\treturn peer;\n}\n\nstatic int receive_protocol(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct p_protocol *p = pi->data;\n\tenum drbd_after_sb_p p_after_sb_0p, p_after_sb_1p, p_after_sb_2p;\n\tint p_proto, p_discard_my_data, p_two_primaries, cf;\n\tstruct net_conf *nc, *old_net_conf, *new_net_conf = NULL;\n\tchar integrity_alg[SHARED_SECRET_MAX] = \"\";\n\tstruct crypto_shash *peer_integrity_tfm = NULL;\n\tvoid *int_dig_in = NULL, *int_dig_vv = NULL;\n\n\tp_proto\t\t= be32_to_cpu(p->protocol);\n\tp_after_sb_0p\t= be32_to_cpu(p->after_sb_0p);\n\tp_after_sb_1p\t= be32_to_cpu(p->after_sb_1p);\n\tp_after_sb_2p\t= be32_to_cpu(p->after_sb_2p);\n\tp_two_primaries = be32_to_cpu(p->two_primaries);\n\tcf\t\t= be32_to_cpu(p->conn_flags);\n\tp_discard_my_data = cf & CF_DISCARD_MY_DATA;\n\n\tif (connection->agreed_pro_version >= 87) {\n\t\tint err;\n\n\t\tif (pi->size > sizeof(integrity_alg))\n\t\t\treturn -EIO;\n\t\terr = drbd_recv_all(connection, integrity_alg, pi->size);\n\t\tif (err)\n\t\t\treturn err;\n\t\tintegrity_alg[SHARED_SECRET_MAX - 1] = 0;\n\t}\n\n\tif (pi->cmd != P_PROTOCOL_UPDATE) {\n\t\tclear_bit(CONN_DRY_RUN, &connection->flags);\n\n\t\tif (cf & CF_DRY_RUN)\n\t\t\tset_bit(CONN_DRY_RUN, &connection->flags);\n\n\t\trcu_read_lock();\n\t\tnc = rcu_dereference(connection->net_conf);\n\n\t\tif (p_proto != nc->wire_protocol) {\n\t\t\tdrbd_err(connection, \"incompatible %s settings\\n\", \"protocol\");\n\t\t\tgoto disconnect_rcu_unlock;\n\t\t}\n\n\t\tif (convert_after_sb(p_after_sb_0p) != nc->after_sb_0p) {\n\t\t\tdrbd_err(connection, \"incompatible %s settings\\n\", \"after-sb-0pri\");\n\t\t\tgoto disconnect_rcu_unlock;\n\t\t}\n\n\t\tif (convert_after_sb(p_after_sb_1p) != nc->after_sb_1p) {\n\t\t\tdrbd_err(connection, \"incompatible %s settings\\n\", \"after-sb-1pri\");\n\t\t\tgoto disconnect_rcu_unlock;\n\t\t}\n\n\t\tif (convert_after_sb(p_after_sb_2p) != nc->after_sb_2p) {\n\t\t\tdrbd_err(connection, \"incompatible %s settings\\n\", \"after-sb-2pri\");\n\t\t\tgoto disconnect_rcu_unlock;\n\t\t}\n\n\t\tif (p_discard_my_data && nc->discard_my_data) {\n\t\t\tdrbd_err(connection, \"incompatible %s settings\\n\", \"discard-my-data\");\n\t\t\tgoto disconnect_rcu_unlock;\n\t\t}\n\n\t\tif (p_two_primaries != nc->two_primaries) {\n\t\t\tdrbd_err(connection, \"incompatible %s settings\\n\", \"allow-two-primaries\");\n\t\t\tgoto disconnect_rcu_unlock;\n\t\t}\n\n\t\tif (strcmp(integrity_alg, nc->integrity_alg)) {\n\t\t\tdrbd_err(connection, \"incompatible %s settings\\n\", \"data-integrity-alg\");\n\t\t\tgoto disconnect_rcu_unlock;\n\t\t}\n\n\t\trcu_read_unlock();\n\t}\n\n\tif (integrity_alg[0]) {\n\t\tint hash_size;\n\n\t\t/*\n\t\t * We can only change the peer data integrity algorithm\n\t\t * here.  Changing our own data integrity algorithm\n\t\t * requires that we send a P_PROTOCOL_UPDATE packet at\n\t\t * the same time; otherwise, the peer has no way to\n\t\t * tell between which packets the algorithm should\n\t\t * change.\n\t\t */\n\n\t\tpeer_integrity_tfm = crypto_alloc_shash(integrity_alg, 0, 0);\n\t\tif (IS_ERR(peer_integrity_tfm)) {\n\t\t\tpeer_integrity_tfm = NULL;\n\t\t\tdrbd_err(connection, \"peer data-integrity-alg %s not supported\\n\",\n\t\t\t\t integrity_alg);\n\t\t\tgoto disconnect;\n\t\t}\n\n\t\thash_size = crypto_shash_digestsize(peer_integrity_tfm);\n\t\tint_dig_in = kmalloc(hash_size, GFP_KERNEL);\n\t\tint_dig_vv = kmalloc(hash_size, GFP_KERNEL);\n\t\tif (!(int_dig_in && int_dig_vv)) {\n\t\t\tdrbd_err(connection, \"Allocation of buffers for data integrity checking failed\\n\");\n\t\t\tgoto disconnect;\n\t\t}\n\t}\n\n\tnew_net_conf = kmalloc(sizeof(struct net_conf), GFP_KERNEL);\n\tif (!new_net_conf) {\n\t\tdrbd_err(connection, \"Allocation of new net_conf failed\\n\");\n\t\tgoto disconnect;\n\t}\n\n\tmutex_lock(&connection->data.mutex);\n\tmutex_lock(&connection->resource->conf_update);\n\told_net_conf = connection->net_conf;\n\t*new_net_conf = *old_net_conf;\n\n\tnew_net_conf->wire_protocol = p_proto;\n\tnew_net_conf->after_sb_0p = convert_after_sb(p_after_sb_0p);\n\tnew_net_conf->after_sb_1p = convert_after_sb(p_after_sb_1p);\n\tnew_net_conf->after_sb_2p = convert_after_sb(p_after_sb_2p);\n\tnew_net_conf->two_primaries = p_two_primaries;\n\n\trcu_assign_pointer(connection->net_conf, new_net_conf);\n\tmutex_unlock(&connection->resource->conf_update);\n\tmutex_unlock(&connection->data.mutex);\n\n\tcrypto_free_shash(connection->peer_integrity_tfm);\n\tkfree(connection->int_dig_in);\n\tkfree(connection->int_dig_vv);\n\tconnection->peer_integrity_tfm = peer_integrity_tfm;\n\tconnection->int_dig_in = int_dig_in;\n\tconnection->int_dig_vv = int_dig_vv;\n\n\tif (strcmp(old_net_conf->integrity_alg, integrity_alg))\n\t\tdrbd_info(connection, \"peer data-integrity-alg: %s\\n\",\n\t\t\t  integrity_alg[0] ? integrity_alg : \"(none)\");\n\n\tsynchronize_rcu();\n\tkfree(old_net_conf);\n\treturn 0;\n\ndisconnect_rcu_unlock:\n\trcu_read_unlock();\ndisconnect:\n\tcrypto_free_shash(peer_integrity_tfm);\n\tkfree(int_dig_in);\n\tkfree(int_dig_vv);\n\tconn_request_state(connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\treturn -EIO;\n}\n\n/* helper function\n * input: alg name, feature name\n * return: NULL (alg name was \"\")\n *         ERR_PTR(error) if something goes wrong\n *         or the crypto hash ptr, if it worked out ok. */\nstatic struct crypto_shash *drbd_crypto_alloc_digest_safe(\n\t\tconst struct drbd_device *device,\n\t\tconst char *alg, const char *name)\n{\n\tstruct crypto_shash *tfm;\n\n\tif (!alg[0])\n\t\treturn NULL;\n\n\ttfm = crypto_alloc_shash(alg, 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tdrbd_err(device, \"Can not allocate \\\"%s\\\" as %s (reason: %ld)\\n\",\n\t\t\talg, name, PTR_ERR(tfm));\n\t\treturn tfm;\n\t}\n\treturn tfm;\n}\n\nstatic int ignore_remaining_packet(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tvoid *buffer = connection->data.rbuf;\n\tint size = pi->size;\n\n\twhile (size) {\n\t\tint s = min_t(int, size, DRBD_SOCKET_BUFFER_SIZE);\n\t\ts = drbd_recv(connection, buffer, s);\n\t\tif (s <= 0) {\n\t\t\tif (s < 0)\n\t\t\t\treturn s;\n\t\t\tbreak;\n\t\t}\n\t\tsize -= s;\n\t}\n\tif (size)\n\t\treturn -EIO;\n\treturn 0;\n}\n\n/*\n * config_unknown_volume  -  device configuration command for unknown volume\n *\n * When a device is added to an existing connection, the node on which the\n * device is added first will send configuration commands to its peer but the\n * peer will not know about the device yet.  It will warn and ignore these\n * commands.  Once the device is added on the second node, the second node will\n * send the same device configuration commands, but in the other direction.\n *\n * (We can also end up here if drbd is misconfigured.)\n */\nstatic int config_unknown_volume(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tdrbd_warn(connection, \"%s packet received for volume %u, which is not configured locally\\n\",\n\t\t  cmdname(pi->cmd), pi->vnr);\n\treturn ignore_remaining_packet(connection, pi);\n}\n\nstatic int receive_SyncParam(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_rs_param_95 *p;\n\tunsigned int header_size, data_size, exp_max_sz;\n\tstruct crypto_shash *verify_tfm = NULL;\n\tstruct crypto_shash *csums_tfm = NULL;\n\tstruct net_conf *old_net_conf, *new_net_conf = NULL;\n\tstruct disk_conf *old_disk_conf = NULL, *new_disk_conf = NULL;\n\tconst int apv = connection->agreed_pro_version;\n\tstruct fifo_buffer *old_plan = NULL, *new_plan = NULL;\n\tunsigned int fifo_size = 0;\n\tint err;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn config_unknown_volume(connection, pi);\n\tdevice = peer_device->device;\n\n\texp_max_sz  = apv <= 87 ? sizeof(struct p_rs_param)\n\t\t    : apv == 88 ? sizeof(struct p_rs_param)\n\t\t\t\t\t+ SHARED_SECRET_MAX\n\t\t    : apv <= 94 ? sizeof(struct p_rs_param_89)\n\t\t    : /* apv >= 95 */ sizeof(struct p_rs_param_95);\n\n\tif (pi->size > exp_max_sz) {\n\t\tdrbd_err(device, \"SyncParam packet too long: received %u, expected <= %u bytes\\n\",\n\t\t    pi->size, exp_max_sz);\n\t\treturn -EIO;\n\t}\n\n\tif (apv <= 88) {\n\t\theader_size = sizeof(struct p_rs_param);\n\t\tdata_size = pi->size - header_size;\n\t} else if (apv <= 94) {\n\t\theader_size = sizeof(struct p_rs_param_89);\n\t\tdata_size = pi->size - header_size;\n\t\tD_ASSERT(device, data_size == 0);\n\t} else {\n\t\theader_size = sizeof(struct p_rs_param_95);\n\t\tdata_size = pi->size - header_size;\n\t\tD_ASSERT(device, data_size == 0);\n\t}\n\n\t/* initialize verify_alg and csums_alg */\n\tp = pi->data;\n\tmemset(p->verify_alg, 0, 2 * SHARED_SECRET_MAX);\n\n\terr = drbd_recv_all(peer_device->connection, p, header_size);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&connection->resource->conf_update);\n\told_net_conf = peer_device->connection->net_conf;\n\tif (get_ldev(device)) {\n\t\tnew_disk_conf = kzalloc(sizeof(struct disk_conf), GFP_KERNEL);\n\t\tif (!new_disk_conf) {\n\t\t\tput_ldev(device);\n\t\t\tmutex_unlock(&connection->resource->conf_update);\n\t\t\tdrbd_err(device, \"Allocation of new disk_conf failed\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\told_disk_conf = device->ldev->disk_conf;\n\t\t*new_disk_conf = *old_disk_conf;\n\n\t\tnew_disk_conf->resync_rate = be32_to_cpu(p->resync_rate);\n\t}\n\n\tif (apv >= 88) {\n\t\tif (apv == 88) {\n\t\t\tif (data_size > SHARED_SECRET_MAX || data_size == 0) {\n\t\t\t\tdrbd_err(device, \"verify-alg of wrong size, \"\n\t\t\t\t\t\"peer wants %u, accepting only up to %u byte\\n\",\n\t\t\t\t\tdata_size, SHARED_SECRET_MAX);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto reconnect;\n\t\t\t}\n\n\t\t\terr = drbd_recv_all(peer_device->connection, p->verify_alg, data_size);\n\t\t\tif (err)\n\t\t\t\tgoto reconnect;\n\t\t\t/* we expect NUL terminated string */\n\t\t\t/* but just in case someone tries to be evil */\n\t\t\tD_ASSERT(device, p->verify_alg[data_size-1] == 0);\n\t\t\tp->verify_alg[data_size-1] = 0;\n\n\t\t} else /* apv >= 89 */ {\n\t\t\t/* we still expect NUL terminated strings */\n\t\t\t/* but just in case someone tries to be evil */\n\t\t\tD_ASSERT(device, p->verify_alg[SHARED_SECRET_MAX-1] == 0);\n\t\t\tD_ASSERT(device, p->csums_alg[SHARED_SECRET_MAX-1] == 0);\n\t\t\tp->verify_alg[SHARED_SECRET_MAX-1] = 0;\n\t\t\tp->csums_alg[SHARED_SECRET_MAX-1] = 0;\n\t\t}\n\n\t\tif (strcmp(old_net_conf->verify_alg, p->verify_alg)) {\n\t\t\tif (device->state.conn == C_WF_REPORT_PARAMS) {\n\t\t\t\tdrbd_err(device, \"Different verify-alg settings. me=\\\"%s\\\" peer=\\\"%s\\\"\\n\",\n\t\t\t\t    old_net_conf->verify_alg, p->verify_alg);\n\t\t\t\tgoto disconnect;\n\t\t\t}\n\t\t\tverify_tfm = drbd_crypto_alloc_digest_safe(device,\n\t\t\t\t\tp->verify_alg, \"verify-alg\");\n\t\t\tif (IS_ERR(verify_tfm)) {\n\t\t\t\tverify_tfm = NULL;\n\t\t\t\tgoto disconnect;\n\t\t\t}\n\t\t}\n\n\t\tif (apv >= 89 && strcmp(old_net_conf->csums_alg, p->csums_alg)) {\n\t\t\tif (device->state.conn == C_WF_REPORT_PARAMS) {\n\t\t\t\tdrbd_err(device, \"Different csums-alg settings. me=\\\"%s\\\" peer=\\\"%s\\\"\\n\",\n\t\t\t\t    old_net_conf->csums_alg, p->csums_alg);\n\t\t\t\tgoto disconnect;\n\t\t\t}\n\t\t\tcsums_tfm = drbd_crypto_alloc_digest_safe(device,\n\t\t\t\t\tp->csums_alg, \"csums-alg\");\n\t\t\tif (IS_ERR(csums_tfm)) {\n\t\t\t\tcsums_tfm = NULL;\n\t\t\t\tgoto disconnect;\n\t\t\t}\n\t\t}\n\n\t\tif (apv > 94 && new_disk_conf) {\n\t\t\tnew_disk_conf->c_plan_ahead = be32_to_cpu(p->c_plan_ahead);\n\t\t\tnew_disk_conf->c_delay_target = be32_to_cpu(p->c_delay_target);\n\t\t\tnew_disk_conf->c_fill_target = be32_to_cpu(p->c_fill_target);\n\t\t\tnew_disk_conf->c_max_rate = be32_to_cpu(p->c_max_rate);\n\n\t\t\tfifo_size = (new_disk_conf->c_plan_ahead * 10 * SLEEP_TIME) / HZ;\n\t\t\tif (fifo_size != device->rs_plan_s->size) {\n\t\t\t\tnew_plan = fifo_alloc(fifo_size);\n\t\t\t\tif (!new_plan) {\n\t\t\t\t\tdrbd_err(device, \"kmalloc of fifo_buffer failed\");\n\t\t\t\t\tput_ldev(device);\n\t\t\t\t\tgoto disconnect;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (verify_tfm || csums_tfm) {\n\t\t\tnew_net_conf = kzalloc(sizeof(struct net_conf), GFP_KERNEL);\n\t\t\tif (!new_net_conf) {\n\t\t\t\tdrbd_err(device, \"Allocation of new net_conf failed\\n\");\n\t\t\t\tgoto disconnect;\n\t\t\t}\n\n\t\t\t*new_net_conf = *old_net_conf;\n\n\t\t\tif (verify_tfm) {\n\t\t\t\tstrcpy(new_net_conf->verify_alg, p->verify_alg);\n\t\t\t\tnew_net_conf->verify_alg_len = strlen(p->verify_alg) + 1;\n\t\t\t\tcrypto_free_shash(peer_device->connection->verify_tfm);\n\t\t\t\tpeer_device->connection->verify_tfm = verify_tfm;\n\t\t\t\tdrbd_info(device, \"using verify-alg: \\\"%s\\\"\\n\", p->verify_alg);\n\t\t\t}\n\t\t\tif (csums_tfm) {\n\t\t\t\tstrcpy(new_net_conf->csums_alg, p->csums_alg);\n\t\t\t\tnew_net_conf->csums_alg_len = strlen(p->csums_alg) + 1;\n\t\t\t\tcrypto_free_shash(peer_device->connection->csums_tfm);\n\t\t\t\tpeer_device->connection->csums_tfm = csums_tfm;\n\t\t\t\tdrbd_info(device, \"using csums-alg: \\\"%s\\\"\\n\", p->csums_alg);\n\t\t\t}\n\t\t\trcu_assign_pointer(connection->net_conf, new_net_conf);\n\t\t}\n\t}\n\n\tif (new_disk_conf) {\n\t\trcu_assign_pointer(device->ldev->disk_conf, new_disk_conf);\n\t\tput_ldev(device);\n\t}\n\n\tif (new_plan) {\n\t\told_plan = device->rs_plan_s;\n\t\trcu_assign_pointer(device->rs_plan_s, new_plan);\n\t}\n\n\tmutex_unlock(&connection->resource->conf_update);\n\tsynchronize_rcu();\n\tif (new_net_conf)\n\t\tkfree(old_net_conf);\n\tkfree(old_disk_conf);\n\tkfree(old_plan);\n\n\treturn 0;\n\nreconnect:\n\tif (new_disk_conf) {\n\t\tput_ldev(device);\n\t\tkfree(new_disk_conf);\n\t}\n\tmutex_unlock(&connection->resource->conf_update);\n\treturn -EIO;\n\ndisconnect:\n\tkfree(new_plan);\n\tif (new_disk_conf) {\n\t\tput_ldev(device);\n\t\tkfree(new_disk_conf);\n\t}\n\tmutex_unlock(&connection->resource->conf_update);\n\t/* just for completeness: actually not needed,\n\t * as this is not reached if csums_tfm was ok. */\n\tcrypto_free_shash(csums_tfm);\n\t/* but free the verify_tfm again, if csums_tfm did not work out */\n\tcrypto_free_shash(verify_tfm);\n\tconn_request_state(peer_device->connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\treturn -EIO;\n}\n\n/* warn if the arguments differ by more than 12.5% */\nstatic void warn_if_differ_considerably(struct drbd_device *device,\n\tconst char *s, sector_t a, sector_t b)\n{\n\tsector_t d;\n\tif (a == 0 || b == 0)\n\t\treturn;\n\td = (a > b) ? (a - b) : (b - a);\n\tif (d > (a>>3) || d > (b>>3))\n\t\tdrbd_warn(device, \"Considerable difference in %s: %llus vs. %llus\\n\", s,\n\t\t     (unsigned long long)a, (unsigned long long)b);\n}\n\nstatic int receive_sizes(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_sizes *p = pi->data;\n\tstruct o_qlim *o = (connection->agreed_features & DRBD_FF_WSAME) ? p->qlim : NULL;\n\tenum determine_dev_size dd = DS_UNCHANGED;\n\tsector_t p_size, p_usize, p_csize, my_usize;\n\tsector_t new_size, cur_size;\n\tint ldsc = 0; /* local disk size changed */\n\tenum dds_flags ddsf;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn config_unknown_volume(connection, pi);\n\tdevice = peer_device->device;\n\tcur_size = get_capacity(device->vdisk);\n\n\tp_size = be64_to_cpu(p->d_size);\n\tp_usize = be64_to_cpu(p->u_size);\n\tp_csize = be64_to_cpu(p->c_size);\n\n\t/* just store the peer's disk size for now.\n\t * we still need to figure out whether we accept that. */\n\tdevice->p_size = p_size;\n\n\tif (get_ldev(device)) {\n\t\trcu_read_lock();\n\t\tmy_usize = rcu_dereference(device->ldev->disk_conf)->disk_size;\n\t\trcu_read_unlock();\n\n\t\twarn_if_differ_considerably(device, \"lower level device sizes\",\n\t\t\t   p_size, drbd_get_max_capacity(device->ldev));\n\t\twarn_if_differ_considerably(device, \"user requested size\",\n\t\t\t\t\t    p_usize, my_usize);\n\n\t\t/* if this is the first connect, or an otherwise expected\n\t\t * param exchange, choose the minimum */\n\t\tif (device->state.conn == C_WF_REPORT_PARAMS)\n\t\t\tp_usize = min_not_zero(my_usize, p_usize);\n\n\t\t/* Never shrink a device with usable data during connect,\n\t\t * or \"attach\" on the peer.\n\t\t * But allow online shrinking if we are connected. */\n\t\tnew_size = drbd_new_dev_size(device, device->ldev, p_usize, 0);\n\t\tif (new_size < cur_size &&\n\t\t    device->state.disk >= D_OUTDATED &&\n\t\t    (device->state.conn < C_CONNECTED || device->state.pdsk == D_DISKLESS)) {\n\t\t\tdrbd_err(device, \"The peer's disk size is too small! (%llu < %llu sectors)\\n\",\n\t\t\t\t\t(unsigned long long)new_size, (unsigned long long)cur_size);\n\t\t\tconn_request_state(peer_device->connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t\t\tput_ldev(device);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (my_usize != p_usize) {\n\t\t\tstruct disk_conf *old_disk_conf, *new_disk_conf = NULL;\n\n\t\t\tnew_disk_conf = kzalloc(sizeof(struct disk_conf), GFP_KERNEL);\n\t\t\tif (!new_disk_conf) {\n\t\t\t\tdrbd_err(device, \"Allocation of new disk_conf failed\\n\");\n\t\t\t\tput_ldev(device);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tmutex_lock(&connection->resource->conf_update);\n\t\t\told_disk_conf = device->ldev->disk_conf;\n\t\t\t*new_disk_conf = *old_disk_conf;\n\t\t\tnew_disk_conf->disk_size = p_usize;\n\n\t\t\trcu_assign_pointer(device->ldev->disk_conf, new_disk_conf);\n\t\t\tmutex_unlock(&connection->resource->conf_update);\n\t\t\tsynchronize_rcu();\n\t\t\tkfree(old_disk_conf);\n\n\t\t\tdrbd_info(device, \"Peer sets u_size to %lu sectors (old: %lu)\\n\",\n\t\t\t\t (unsigned long)p_usize, (unsigned long)my_usize);\n\t\t}\n\n\t\tput_ldev(device);\n\t}\n\n\tdevice->peer_max_bio_size = be32_to_cpu(p->max_bio_size);\n\t/* Leave drbd_reconsider_queue_parameters() before drbd_determine_dev_size().\n\t   In case we cleared the QUEUE_FLAG_DISCARD from our queue in\n\t   drbd_reconsider_queue_parameters(), we can be sure that after\n\t   drbd_determine_dev_size() no REQ_DISCARDs are in the queue. */\n\n\tddsf = be16_to_cpu(p->dds_flags);\n\tif (get_ldev(device)) {\n\t\tdrbd_reconsider_queue_parameters(device, device->ldev, o);\n\t\tdd = drbd_determine_dev_size(device, ddsf, NULL);\n\t\tput_ldev(device);\n\t\tif (dd == DS_ERROR)\n\t\t\treturn -EIO;\n\t\tdrbd_md_sync(device);\n\t} else {\n\t\t/*\n\t\t * I am diskless, need to accept the peer's *current* size.\n\t\t * I must NOT accept the peers backing disk size,\n\t\t * it may have been larger than mine all along...\n\t\t *\n\t\t * At this point, the peer knows more about my disk, or at\n\t\t * least about what we last agreed upon, than myself.\n\t\t * So if his c_size is less than his d_size, the most likely\n\t\t * reason is that *my* d_size was smaller last time we checked.\n\t\t *\n\t\t * However, if he sends a zero current size,\n\t\t * take his (user-capped or) backing disk size anyways.\n\t\t *\n\t\t * Unless of course he does not have a disk himself.\n\t\t * In which case we ignore this completely.\n\t\t */\n\t\tsector_t new_size = p_csize ?: p_usize ?: p_size;\n\t\tdrbd_reconsider_queue_parameters(device, NULL, o);\n\t\tif (new_size == 0) {\n\t\t\t/* Ignore, peer does not know nothing. */\n\t\t} else if (new_size == cur_size) {\n\t\t\t/* nothing to do */\n\t\t} else if (cur_size != 0 && p_size == 0) {\n\t\t\tdrbd_warn(device, \"Ignored diskless peer device size (peer:%llu != me:%llu sectors)!\\n\",\n\t\t\t\t\t(unsigned long long)new_size, (unsigned long long)cur_size);\n\t\t} else if (new_size < cur_size && device->state.role == R_PRIMARY) {\n\t\t\tdrbd_err(device, \"The peer's device size is too small! (%llu < %llu sectors); demote me first!\\n\",\n\t\t\t\t\t(unsigned long long)new_size, (unsigned long long)cur_size);\n\t\t\tconn_request_state(peer_device->connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t\t\treturn -EIO;\n\t\t} else {\n\t\t\t/* I believe the peer, if\n\t\t\t *  - I don't have a current size myself\n\t\t\t *  - we agree on the size anyways\n\t\t\t *  - I do have a current size, am Secondary,\n\t\t\t *    and he has the only disk\n\t\t\t *  - I do have a current size, am Primary,\n\t\t\t *    and he has the only disk,\n\t\t\t *    which is larger than my current size\n\t\t\t */\n\t\t\tdrbd_set_my_capacity(device, new_size);\n\t\t}\n\t}\n\n\tif (get_ldev(device)) {\n\t\tif (device->ldev->known_size != drbd_get_capacity(device->ldev->backing_bdev)) {\n\t\t\tdevice->ldev->known_size = drbd_get_capacity(device->ldev->backing_bdev);\n\t\t\tldsc = 1;\n\t\t}\n\n\t\tput_ldev(device);\n\t}\n\n\tif (device->state.conn > C_WF_REPORT_PARAMS) {\n\t\tif (be64_to_cpu(p->c_size) != get_capacity(device->vdisk) ||\n\t\t    ldsc) {\n\t\t\t/* we have different sizes, probably peer\n\t\t\t * needs to know my new size... */\n\t\t\tdrbd_send_sizes(peer_device, 0, ddsf);\n\t\t}\n\t\tif (test_and_clear_bit(RESIZE_PENDING, &device->flags) ||\n\t\t    (dd == DS_GREW && device->state.conn == C_CONNECTED)) {\n\t\t\tif (device->state.pdsk >= D_INCONSISTENT &&\n\t\t\t    device->state.disk >= D_INCONSISTENT) {\n\t\t\t\tif (ddsf & DDSF_NO_RESYNC)\n\t\t\t\t\tdrbd_info(device, \"Resync of new storage suppressed with --assume-clean\\n\");\n\t\t\t\telse\n\t\t\t\t\tresync_after_online_grow(device);\n\t\t\t} else\n\t\t\t\tset_bit(RESYNC_AFTER_NEG, &device->flags);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int receive_uuids(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_uuids *p = pi->data;\n\tu64 *p_uuid;\n\tint i, updated_uuids = 0;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn config_unknown_volume(connection, pi);\n\tdevice = peer_device->device;\n\n\tp_uuid = kmalloc_array(UI_EXTENDED_SIZE, sizeof(*p_uuid), GFP_NOIO);\n\tif (!p_uuid) {\n\t\tdrbd_err(device, \"kmalloc of p_uuid failed\\n\");\n\t\treturn false;\n\t}\n\n\tfor (i = UI_CURRENT; i < UI_EXTENDED_SIZE; i++)\n\t\tp_uuid[i] = be64_to_cpu(p->uuid[i]);\n\n\tkfree(device->p_uuid);\n\tdevice->p_uuid = p_uuid;\n\n\tif ((device->state.conn < C_CONNECTED || device->state.pdsk == D_DISKLESS) &&\n\t    device->state.disk < D_INCONSISTENT &&\n\t    device->state.role == R_PRIMARY &&\n\t    (device->ed_uuid & ~((u64)1)) != (p_uuid[UI_CURRENT] & ~((u64)1))) {\n\t\tdrbd_err(device, \"Can only connect to data with current UUID=%016llX\\n\",\n\t\t    (unsigned long long)device->ed_uuid);\n\t\tconn_request_state(peer_device->connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t\treturn -EIO;\n\t}\n\n\tif (get_ldev(device)) {\n\t\tint skip_initial_sync =\n\t\t\tdevice->state.conn == C_CONNECTED &&\n\t\t\tpeer_device->connection->agreed_pro_version >= 90 &&\n\t\t\tdevice->ldev->md.uuid[UI_CURRENT] == UUID_JUST_CREATED &&\n\t\t\t(p_uuid[UI_FLAGS] & 8);\n\t\tif (skip_initial_sync) {\n\t\t\tdrbd_info(device, \"Accepted new current UUID, preparing to skip initial sync\\n\");\n\t\t\tdrbd_bitmap_io(device, &drbd_bmio_clear_n_write,\n\t\t\t\t\t\"clear_n_write from receive_uuids\",\n\t\t\t\t\tBM_LOCKED_TEST_ALLOWED);\n\t\t\t_drbd_uuid_set(device, UI_CURRENT, p_uuid[UI_CURRENT]);\n\t\t\t_drbd_uuid_set(device, UI_BITMAP, 0);\n\t\t\t_drbd_set_state(_NS2(device, disk, D_UP_TO_DATE, pdsk, D_UP_TO_DATE),\n\t\t\t\t\tCS_VERBOSE, NULL);\n\t\t\tdrbd_md_sync(device);\n\t\t\tupdated_uuids = 1;\n\t\t}\n\t\tput_ldev(device);\n\t} else if (device->state.disk < D_INCONSISTENT &&\n\t\t   device->state.role == R_PRIMARY) {\n\t\t/* I am a diskless primary, the peer just created a new current UUID\n\t\t   for me. */\n\t\tupdated_uuids = drbd_set_ed_uuid(device, p_uuid[UI_CURRENT]);\n\t}\n\n\t/* Before we test for the disk state, we should wait until an eventually\n\t   ongoing cluster wide state change is finished. That is important if\n\t   we are primary and are detaching from our disk. We need to see the\n\t   new disk state... */\n\tmutex_lock(device->state_mutex);\n\tmutex_unlock(device->state_mutex);\n\tif (device->state.conn >= C_CONNECTED && device->state.disk < D_INCONSISTENT)\n\t\tupdated_uuids |= drbd_set_ed_uuid(device, p_uuid[UI_CURRENT]);\n\n\tif (updated_uuids)\n\t\tdrbd_print_uuids(device, \"receiver updated UUIDs to\");\n\n\treturn 0;\n}\n\n/**\n * convert_state() - Converts the peer's view of the cluster state to our point of view\n * @ps:\t\tThe state as seen by the peer.\n */\nstatic union drbd_state convert_state(union drbd_state ps)\n{\n\tunion drbd_state ms;\n\n\tstatic enum drbd_conns c_tab[] = {\n\t\t[C_WF_REPORT_PARAMS] = C_WF_REPORT_PARAMS,\n\t\t[C_CONNECTED] = C_CONNECTED,\n\n\t\t[C_STARTING_SYNC_S] = C_STARTING_SYNC_T,\n\t\t[C_STARTING_SYNC_T] = C_STARTING_SYNC_S,\n\t\t[C_DISCONNECTING] = C_TEAR_DOWN, /* C_NETWORK_FAILURE, */\n\t\t[C_VERIFY_S]       = C_VERIFY_T,\n\t\t[C_MASK]   = C_MASK,\n\t};\n\n\tms.i = ps.i;\n\n\tms.conn = c_tab[ps.conn];\n\tms.peer = ps.role;\n\tms.role = ps.peer;\n\tms.pdsk = ps.disk;\n\tms.disk = ps.pdsk;\n\tms.peer_isp = (ps.aftr_isp | ps.user_isp);\n\n\treturn ms;\n}\n\nstatic int receive_req_state(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_req_state *p = pi->data;\n\tunion drbd_state mask, val;\n\tenum drbd_state_rv rv;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tmask.i = be32_to_cpu(p->mask);\n\tval.i = be32_to_cpu(p->val);\n\n\tif (test_bit(RESOLVE_CONFLICTS, &peer_device->connection->flags) &&\n\t    mutex_is_locked(device->state_mutex)) {\n\t\tdrbd_send_sr_reply(peer_device, SS_CONCURRENT_ST_CHG);\n\t\treturn 0;\n\t}\n\n\tmask = convert_state(mask);\n\tval = convert_state(val);\n\n\trv = drbd_change_state(device, CS_VERBOSE, mask, val);\n\tdrbd_send_sr_reply(peer_device, rv);\n\n\tdrbd_md_sync(device);\n\n\treturn 0;\n}\n\nstatic int receive_req_conn_state(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct p_req_state *p = pi->data;\n\tunion drbd_state mask, val;\n\tenum drbd_state_rv rv;\n\n\tmask.i = be32_to_cpu(p->mask);\n\tval.i = be32_to_cpu(p->val);\n\n\tif (test_bit(RESOLVE_CONFLICTS, &connection->flags) &&\n\t    mutex_is_locked(&connection->cstate_mutex)) {\n\t\tconn_send_sr_reply(connection, SS_CONCURRENT_ST_CHG);\n\t\treturn 0;\n\t}\n\n\tmask = convert_state(mask);\n\tval = convert_state(val);\n\n\trv = conn_request_state(connection, mask, val, CS_VERBOSE | CS_LOCAL_ONLY | CS_IGN_OUTD_FAIL);\n\tconn_send_sr_reply(connection, rv);\n\n\treturn 0;\n}\n\nstatic int receive_state(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_state *p = pi->data;\n\tunion drbd_state os, ns, peer_state;\n\tenum drbd_disk_state real_peer_disk;\n\tenum chg_state_flags cs_flags;\n\tint rv;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn config_unknown_volume(connection, pi);\n\tdevice = peer_device->device;\n\n\tpeer_state.i = be32_to_cpu(p->state);\n\n\treal_peer_disk = peer_state.disk;\n\tif (peer_state.disk == D_NEGOTIATING) {\n\t\treal_peer_disk = device->p_uuid[UI_FLAGS] & 4 ? D_INCONSISTENT : D_CONSISTENT;\n\t\tdrbd_info(device, \"real peer disk state = %s\\n\", drbd_disk_str(real_peer_disk));\n\t}\n\n\tspin_lock_irq(&device->resource->req_lock);\n retry:\n\tos = ns = drbd_read_state(device);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\t/* If some other part of the code (ack_receiver thread, timeout)\n\t * already decided to close the connection again,\n\t * we must not \"re-establish\" it here. */\n\tif (os.conn <= C_TEAR_DOWN)\n\t\treturn -ECONNRESET;\n\n\t/* If this is the \"end of sync\" confirmation, usually the peer disk\n\t * transitions from D_INCONSISTENT to D_UP_TO_DATE. For empty (0 bits\n\t * set) resync started in PausedSyncT, or if the timing of pause-/\n\t * unpause-sync events has been \"just right\", the peer disk may\n\t * transition from D_CONSISTENT to D_UP_TO_DATE as well.\n\t */\n\tif ((os.pdsk == D_INCONSISTENT || os.pdsk == D_CONSISTENT) &&\n\t    real_peer_disk == D_UP_TO_DATE &&\n\t    os.conn > C_CONNECTED && os.disk == D_UP_TO_DATE) {\n\t\t/* If we are (becoming) SyncSource, but peer is still in sync\n\t\t * preparation, ignore its uptodate-ness to avoid flapping, it\n\t\t * will change to inconsistent once the peer reaches active\n\t\t * syncing states.\n\t\t * It may have changed syncer-paused flags, however, so we\n\t\t * cannot ignore this completely. */\n\t\tif (peer_state.conn > C_CONNECTED &&\n\t\t    peer_state.conn < C_SYNC_SOURCE)\n\t\t\treal_peer_disk = D_INCONSISTENT;\n\n\t\t/* if peer_state changes to connected at the same time,\n\t\t * it explicitly notifies us that it finished resync.\n\t\t * Maybe we should finish it up, too? */\n\t\telse if (os.conn >= C_SYNC_SOURCE &&\n\t\t\t peer_state.conn == C_CONNECTED) {\n\t\t\tif (drbd_bm_total_weight(device) <= device->rs_failed)\n\t\t\t\tdrbd_resync_finished(device);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* explicit verify finished notification, stop sector reached. */\n\tif (os.conn == C_VERIFY_T && os.disk == D_UP_TO_DATE &&\n\t    peer_state.conn == C_CONNECTED && real_peer_disk == D_UP_TO_DATE) {\n\t\tov_out_of_sync_print(device);\n\t\tdrbd_resync_finished(device);\n\t\treturn 0;\n\t}\n\n\t/* peer says his disk is inconsistent, while we think it is uptodate,\n\t * and this happens while the peer still thinks we have a sync going on,\n\t * but we think we are already done with the sync.\n\t * We ignore this to avoid flapping pdsk.\n\t * This should not happen, if the peer is a recent version of drbd. */\n\tif (os.pdsk == D_UP_TO_DATE && real_peer_disk == D_INCONSISTENT &&\n\t    os.conn == C_CONNECTED && peer_state.conn > C_SYNC_SOURCE)\n\t\treal_peer_disk = D_UP_TO_DATE;\n\n\tif (ns.conn == C_WF_REPORT_PARAMS)\n\t\tns.conn = C_CONNECTED;\n\n\tif (peer_state.conn == C_AHEAD)\n\t\tns.conn = C_BEHIND;\n\n\t/* TODO:\n\t * if (primary and diskless and peer uuid != effective uuid)\n\t *     abort attach on peer;\n\t *\n\t * If this node does not have good data, was already connected, but\n\t * the peer did a late attach only now, trying to \"negotiate\" with me,\n\t * AND I am currently Primary, possibly frozen, with some specific\n\t * \"effective\" uuid, this should never be reached, really, because\n\t * we first send the uuids, then the current state.\n\t *\n\t * In this scenario, we already dropped the connection hard\n\t * when we received the unsuitable uuids (receive_uuids().\n\t *\n\t * Should we want to change this, that is: not drop the connection in\n\t * receive_uuids() already, then we would need to add a branch here\n\t * that aborts the attach of \"unsuitable uuids\" on the peer in case\n\t * this node is currently Diskless Primary.\n\t */\n\n\tif (device->p_uuid && peer_state.disk >= D_NEGOTIATING &&\n\t    get_ldev_if_state(device, D_NEGOTIATING)) {\n\t\tint cr; /* consider resync */\n\n\t\t/* if we established a new connection */\n\t\tcr  = (os.conn < C_CONNECTED);\n\t\t/* if we had an established connection\n\t\t * and one of the nodes newly attaches a disk */\n\t\tcr |= (os.conn == C_CONNECTED &&\n\t\t       (peer_state.disk == D_NEGOTIATING ||\n\t\t\tos.disk == D_NEGOTIATING));\n\t\t/* if we have both been inconsistent, and the peer has been\n\t\t * forced to be UpToDate with --force */\n\t\tcr |= test_bit(CONSIDER_RESYNC, &device->flags);\n\t\t/* if we had been plain connected, and the admin requested to\n\t\t * start a sync by \"invalidate\" or \"invalidate-remote\" */\n\t\tcr |= (os.conn == C_CONNECTED &&\n\t\t\t\t(peer_state.conn >= C_STARTING_SYNC_S &&\n\t\t\t\t peer_state.conn <= C_WF_BITMAP_T));\n\n\t\tif (cr)\n\t\t\tns.conn = drbd_sync_handshake(peer_device, peer_state.role, real_peer_disk);\n\n\t\tput_ldev(device);\n\t\tif (ns.conn == C_MASK) {\n\t\t\tns.conn = C_CONNECTED;\n\t\t\tif (device->state.disk == D_NEGOTIATING) {\n\t\t\t\tdrbd_force_state(device, NS(disk, D_FAILED));\n\t\t\t} else if (peer_state.disk == D_NEGOTIATING) {\n\t\t\t\tdrbd_err(device, \"Disk attach process on the peer node was aborted.\\n\");\n\t\t\t\tpeer_state.disk = D_DISKLESS;\n\t\t\t\treal_peer_disk = D_DISKLESS;\n\t\t\t} else {\n\t\t\t\tif (test_and_clear_bit(CONN_DRY_RUN, &peer_device->connection->flags))\n\t\t\t\t\treturn -EIO;\n\t\t\t\tD_ASSERT(device, os.conn == C_WF_REPORT_PARAMS);\n\t\t\t\tconn_request_state(peer_device->connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock_irq(&device->resource->req_lock);\n\tif (os.i != drbd_read_state(device).i)\n\t\tgoto retry;\n\tclear_bit(CONSIDER_RESYNC, &device->flags);\n\tns.peer = peer_state.role;\n\tns.pdsk = real_peer_disk;\n\tns.peer_isp = (peer_state.aftr_isp | peer_state.user_isp);\n\tif ((ns.conn == C_CONNECTED || ns.conn == C_WF_BITMAP_S) && ns.disk == D_NEGOTIATING)\n\t\tns.disk = device->new_state_tmp.disk;\n\tcs_flags = CS_VERBOSE + (os.conn < C_CONNECTED && ns.conn >= C_CONNECTED ? 0 : CS_HARD);\n\tif (ns.pdsk == D_CONSISTENT && drbd_suspended(device) && ns.conn == C_CONNECTED && os.conn < C_CONNECTED &&\n\t    test_bit(NEW_CUR_UUID, &device->flags)) {\n\t\t/* Do not allow tl_restart(RESEND) for a rebooted peer. We can only allow this\n\t\t   for temporal network outages! */\n\t\tspin_unlock_irq(&device->resource->req_lock);\n\t\tdrbd_err(device, \"Aborting Connect, can not thaw IO with an only Consistent peer\\n\");\n\t\ttl_clear(peer_device->connection);\n\t\tdrbd_uuid_new_current(device);\n\t\tclear_bit(NEW_CUR_UUID, &device->flags);\n\t\tconn_request_state(peer_device->connection, NS2(conn, C_PROTOCOL_ERROR, susp, 0), CS_HARD);\n\t\treturn -EIO;\n\t}\n\trv = _drbd_set_state(device, ns, cs_flags, NULL);\n\tns = drbd_read_state(device);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\tif (rv < SS_SUCCESS) {\n\t\tconn_request_state(peer_device->connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t\treturn -EIO;\n\t}\n\n\tif (os.conn > C_WF_REPORT_PARAMS) {\n\t\tif (ns.conn > C_CONNECTED && peer_state.conn <= C_CONNECTED &&\n\t\t    peer_state.disk != D_NEGOTIATING ) {\n\t\t\t/* we want resync, peer has not yet decided to sync... */\n\t\t\t/* Nowadays only used when forcing a node into primary role and\n\t\t\t   setting its disk to UpToDate with that */\n\t\t\tdrbd_send_uuids(peer_device);\n\t\t\tdrbd_send_current_state(peer_device);\n\t\t}\n\t}\n\n\tclear_bit(DISCARD_MY_DATA, &device->flags);\n\n\tdrbd_md_sync(device); /* update connected indicator, la_size_sect, ... */\n\n\treturn 0;\n}\n\nstatic int receive_sync_uuid(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_rs_uuid *p = pi->data;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\twait_event(device->misc_wait,\n\t\t   device->state.conn == C_WF_SYNC_UUID ||\n\t\t   device->state.conn == C_BEHIND ||\n\t\t   device->state.conn < C_CONNECTED ||\n\t\t   device->state.disk < D_NEGOTIATING);\n\n\t/* D_ASSERT(device,  device->state.conn == C_WF_SYNC_UUID ); */\n\n\t/* Here the _drbd_uuid_ functions are right, current should\n\t   _not_ be rotated into the history */\n\tif (get_ldev_if_state(device, D_NEGOTIATING)) {\n\t\t_drbd_uuid_set(device, UI_CURRENT, be64_to_cpu(p->uuid));\n\t\t_drbd_uuid_set(device, UI_BITMAP, 0UL);\n\n\t\tdrbd_print_uuids(device, \"updated sync uuid\");\n\t\tdrbd_start_resync(device, C_SYNC_TARGET);\n\n\t\tput_ldev(device);\n\t} else\n\t\tdrbd_err(device, \"Ignoring SyncUUID packet!\\n\");\n\n\treturn 0;\n}\n\n/**\n * receive_bitmap_plain\n *\n * Return 0 when done, 1 when another iteration is needed, and a negative error\n * code upon failure.\n */\nstatic int\nreceive_bitmap_plain(struct drbd_peer_device *peer_device, unsigned int size,\n\t\t     unsigned long *p, struct bm_xfer_ctx *c)\n{\n\tunsigned int data_size = DRBD_SOCKET_BUFFER_SIZE -\n\t\t\t\t drbd_header_size(peer_device->connection);\n\tunsigned int num_words = min_t(size_t, data_size / sizeof(*p),\n\t\t\t\t       c->bm_words - c->word_offset);\n\tunsigned int want = num_words * sizeof(*p);\n\tint err;\n\n\tif (want != size) {\n\t\tdrbd_err(peer_device, \"%s:want (%u) != size (%u)\\n\", __func__, want, size);\n\t\treturn -EIO;\n\t}\n\tif (want == 0)\n\t\treturn 0;\n\terr = drbd_recv_all(peer_device->connection, p, want);\n\tif (err)\n\t\treturn err;\n\n\tdrbd_bm_merge_lel(peer_device->device, c->word_offset, num_words, p);\n\n\tc->word_offset += num_words;\n\tc->bit_offset = c->word_offset * BITS_PER_LONG;\n\tif (c->bit_offset > c->bm_bits)\n\t\tc->bit_offset = c->bm_bits;\n\n\treturn 1;\n}\n\nstatic enum drbd_bitmap_code dcbp_get_code(struct p_compressed_bm *p)\n{\n\treturn (enum drbd_bitmap_code)(p->encoding & 0x0f);\n}\n\nstatic int dcbp_get_start(struct p_compressed_bm *p)\n{\n\treturn (p->encoding & 0x80) != 0;\n}\n\nstatic int dcbp_get_pad_bits(struct p_compressed_bm *p)\n{\n\treturn (p->encoding >> 4) & 0x7;\n}\n\n/**\n * recv_bm_rle_bits\n *\n * Return 0 when done, 1 when another iteration is needed, and a negative error\n * code upon failure.\n */\nstatic int\nrecv_bm_rle_bits(struct drbd_peer_device *peer_device,\n\t\tstruct p_compressed_bm *p,\n\t\t struct bm_xfer_ctx *c,\n\t\t unsigned int len)\n{\n\tstruct bitstream bs;\n\tu64 look_ahead;\n\tu64 rl;\n\tu64 tmp;\n\tunsigned long s = c->bit_offset;\n\tunsigned long e;\n\tint toggle = dcbp_get_start(p);\n\tint have;\n\tint bits;\n\n\tbitstream_init(&bs, p->code, len, dcbp_get_pad_bits(p));\n\n\tbits = bitstream_get_bits(&bs, &look_ahead, 64);\n\tif (bits < 0)\n\t\treturn -EIO;\n\n\tfor (have = bits; have > 0; s += rl, toggle = !toggle) {\n\t\tbits = vli_decode_bits(&rl, look_ahead);\n\t\tif (bits <= 0)\n\t\t\treturn -EIO;\n\n\t\tif (toggle) {\n\t\t\te = s + rl -1;\n\t\t\tif (e >= c->bm_bits) {\n\t\t\t\tdrbd_err(peer_device, \"bitmap overflow (e:%lu) while decoding bm RLE packet\\n\", e);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\t_drbd_bm_set_bits(peer_device->device, s, e);\n\t\t}\n\n\t\tif (have < bits) {\n\t\t\tdrbd_err(peer_device, \"bitmap decoding error: h:%d b:%d la:0x%08llx l:%u/%u\\n\",\n\t\t\t\thave, bits, look_ahead,\n\t\t\t\t(unsigned int)(bs.cur.b - p->code),\n\t\t\t\t(unsigned int)bs.buf_len);\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* if we consumed all 64 bits, assign 0; >> 64 is \"undefined\"; */\n\t\tif (likely(bits < 64))\n\t\t\tlook_ahead >>= bits;\n\t\telse\n\t\t\tlook_ahead = 0;\n\t\thave -= bits;\n\n\t\tbits = bitstream_get_bits(&bs, &tmp, 64 - have);\n\t\tif (bits < 0)\n\t\t\treturn -EIO;\n\t\tlook_ahead |= tmp << have;\n\t\thave += bits;\n\t}\n\n\tc->bit_offset = s;\n\tbm_xfer_ctx_bit_to_word_offset(c);\n\n\treturn (s != c->bm_bits);\n}\n\n/**\n * decode_bitmap_c\n *\n * Return 0 when done, 1 when another iteration is needed, and a negative error\n * code upon failure.\n */\nstatic int\ndecode_bitmap_c(struct drbd_peer_device *peer_device,\n\t\tstruct p_compressed_bm *p,\n\t\tstruct bm_xfer_ctx *c,\n\t\tunsigned int len)\n{\n\tif (dcbp_get_code(p) == RLE_VLI_Bits)\n\t\treturn recv_bm_rle_bits(peer_device, p, c, len - sizeof(*p));\n\n\t/* other variants had been implemented for evaluation,\n\t * but have been dropped as this one turned out to be \"best\"\n\t * during all our tests. */\n\n\tdrbd_err(peer_device, \"receive_bitmap_c: unknown encoding %u\\n\", p->encoding);\n\tconn_request_state(peer_device->connection, NS(conn, C_PROTOCOL_ERROR), CS_HARD);\n\treturn -EIO;\n}\n\nvoid INFO_bm_xfer_stats(struct drbd_device *device,\n\t\tconst char *direction, struct bm_xfer_ctx *c)\n{\n\t/* what would it take to transfer it \"plaintext\" */\n\tunsigned int header_size = drbd_header_size(first_peer_device(device)->connection);\n\tunsigned int data_size = DRBD_SOCKET_BUFFER_SIZE - header_size;\n\tunsigned int plain =\n\t\theader_size * (DIV_ROUND_UP(c->bm_words, data_size) + 1) +\n\t\tc->bm_words * sizeof(unsigned long);\n\tunsigned int total = c->bytes[0] + c->bytes[1];\n\tunsigned int r;\n\n\t/* total can not be zero. but just in case: */\n\tif (total == 0)\n\t\treturn;\n\n\t/* don't report if not compressed */\n\tif (total >= plain)\n\t\treturn;\n\n\t/* total < plain. check for overflow, still */\n\tr = (total > UINT_MAX/1000) ? (total / (plain/1000))\n\t\t                    : (1000 * total / plain);\n\n\tif (r > 1000)\n\t\tr = 1000;\n\n\tr = 1000 - r;\n\tdrbd_info(device, \"%s bitmap stats [Bytes(packets)]: plain %u(%u), RLE %u(%u), \"\n\t     \"total %u; compression: %u.%u%%\\n\",\n\t\t\tdirection,\n\t\t\tc->bytes[1], c->packets[1],\n\t\t\tc->bytes[0], c->packets[0],\n\t\t\ttotal, r/10, r % 10);\n}\n\n/* Since we are processing the bitfield from lower addresses to higher,\n   it does not matter if the process it in 32 bit chunks or 64 bit\n   chunks as long as it is little endian. (Understand it as byte stream,\n   beginning with the lowest byte...) If we would use big endian\n   we would need to process it from the highest address to the lowest,\n   in order to be agnostic to the 32 vs 64 bits issue.\n\n   returns 0 on failure, 1 if we successfully received it. */\nstatic int receive_bitmap(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct bm_xfer_ctx c;\n\tint err;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tdrbd_bm_lock(device, \"receive bitmap\", BM_LOCKED_SET_ALLOWED);\n\t/* you are supposed to send additional out-of-sync information\n\t * if you actually set bits during this phase */\n\n\tc = (struct bm_xfer_ctx) {\n\t\t.bm_bits = drbd_bm_bits(device),\n\t\t.bm_words = drbd_bm_words(device),\n\t};\n\n\tfor(;;) {\n\t\tif (pi->cmd == P_BITMAP)\n\t\t\terr = receive_bitmap_plain(peer_device, pi->size, pi->data, &c);\n\t\telse if (pi->cmd == P_COMPRESSED_BITMAP) {\n\t\t\t/* MAYBE: sanity check that we speak proto >= 90,\n\t\t\t * and the feature is enabled! */\n\t\t\tstruct p_compressed_bm *p = pi->data;\n\n\t\t\tif (pi->size > DRBD_SOCKET_BUFFER_SIZE - drbd_header_size(connection)) {\n\t\t\t\tdrbd_err(device, \"ReportCBitmap packet too large\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (pi->size <= sizeof(*p)) {\n\t\t\t\tdrbd_err(device, \"ReportCBitmap packet too small (l:%u)\\n\", pi->size);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\terr = drbd_recv_all(peer_device->connection, p, pi->size);\n\t\t\tif (err)\n\t\t\t       goto out;\n\t\t\terr = decode_bitmap_c(peer_device, p, &c, pi->size);\n\t\t} else {\n\t\t\tdrbd_warn(device, \"receive_bitmap: cmd neither ReportBitMap nor ReportCBitMap (is 0x%x)\", pi->cmd);\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tc.packets[pi->cmd == P_BITMAP]++;\n\t\tc.bytes[pi->cmd == P_BITMAP] += drbd_header_size(connection) + pi->size;\n\n\t\tif (err <= 0) {\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\t\terr = drbd_recv_header(peer_device->connection, pi);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tINFO_bm_xfer_stats(device, \"receive\", &c);\n\n\tif (device->state.conn == C_WF_BITMAP_T) {\n\t\tenum drbd_state_rv rv;\n\n\t\terr = drbd_send_bitmap(device);\n\t\tif (err)\n\t\t\tgoto out;\n\t\t/* Omit CS_ORDERED with this state transition to avoid deadlocks. */\n\t\trv = _drbd_request_state(device, NS(conn, C_WF_SYNC_UUID), CS_VERBOSE);\n\t\tD_ASSERT(device, rv == SS_SUCCESS);\n\t} else if (device->state.conn != C_WF_BITMAP_S) {\n\t\t/* admin may have requested C_DISCONNECTING,\n\t\t * other threads may have noticed network errors */\n\t\tdrbd_info(device, \"unexpected cstate (%s) in receive_bitmap\\n\",\n\t\t    drbd_conn_str(device->state.conn));\n\t}\n\terr = 0;\n\n out:\n\tdrbd_bm_unlock(device);\n\tif (!err && device->state.conn == C_WF_BITMAP_S)\n\t\tdrbd_start_resync(device, C_SYNC_SOURCE);\n\treturn err;\n}\n\nstatic int receive_skip(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tdrbd_warn(connection, \"skipping unknown optional packet type %d, l: %d!\\n\",\n\t\t pi->cmd, pi->size);\n\n\treturn ignore_remaining_packet(connection, pi);\n}\n\nstatic int receive_UnplugRemote(struct drbd_connection *connection, struct packet_info *pi)\n{\n\t/* Make sure we've acked all the TCP data associated\n\t * with the data requests being unplugged */\n\ttcp_sock_set_quickack(connection->data.socket->sk, 2);\n\treturn 0;\n}\n\nstatic int receive_out_of_sync(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_block_desc *p = pi->data;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tswitch (device->state.conn) {\n\tcase C_WF_SYNC_UUID:\n\tcase C_WF_BITMAP_T:\n\tcase C_BEHIND:\n\t\t\tbreak;\n\tdefault:\n\t\tdrbd_err(device, \"ASSERT FAILED cstate = %s, expected: WFSyncUUID|WFBitMapT|Behind\\n\",\n\t\t\t\tdrbd_conn_str(device->state.conn));\n\t}\n\n\tdrbd_set_out_of_sync(device, be64_to_cpu(p->sector), be32_to_cpu(p->blksize));\n\n\treturn 0;\n}\n\nstatic int receive_rs_deallocated(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct p_block_desc *p = pi->data;\n\tstruct drbd_device *device;\n\tsector_t sector;\n\tint size, err = 0;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tsector = be64_to_cpu(p->sector);\n\tsize = be32_to_cpu(p->blksize);\n\n\tdec_rs_pending(device);\n\n\tif (get_ldev(device)) {\n\t\tstruct drbd_peer_request *peer_req;\n\t\tconst int op = REQ_OP_WRITE_ZEROES;\n\n\t\tpeer_req = drbd_alloc_peer_req(peer_device, ID_SYNCER, sector,\n\t\t\t\t\t       size, 0, GFP_NOIO);\n\t\tif (!peer_req) {\n\t\t\tput_ldev(device);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpeer_req->w.cb = e_end_resync_block;\n\t\tpeer_req->submit_jif = jiffies;\n\t\tpeer_req->flags |= EE_TRIM;\n\n\t\tspin_lock_irq(&device->resource->req_lock);\n\t\tlist_add_tail(&peer_req->w.list, &device->sync_ee);\n\t\tspin_unlock_irq(&device->resource->req_lock);\n\n\t\tatomic_add(pi->size >> 9, &device->rs_sect_ev);\n\t\terr = drbd_submit_peer_request(device, peer_req, op, 0, DRBD_FAULT_RS_WR);\n\n\t\tif (err) {\n\t\t\tspin_lock_irq(&device->resource->req_lock);\n\t\t\tlist_del(&peer_req->w.list);\n\t\t\tspin_unlock_irq(&device->resource->req_lock);\n\n\t\t\tdrbd_free_peer_req(device, peer_req);\n\t\t\tput_ldev(device);\n\t\t\terr = 0;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tinc_unacked(device);\n\n\t\t/* No put_ldev() here. Gets called in drbd_endio_write_sec_final(),\n\t\t   as well as drbd_rs_complete_io() */\n\t} else {\n\tfail:\n\t\tdrbd_rs_complete_io(device, sector);\n\t\tdrbd_send_ack_ex(peer_device, P_NEG_ACK, sector, size, ID_SYNCER);\n\t}\n\n\tatomic_add(size >> 9, &device->rs_sect_in);\n\n\treturn err;\n}\n\nstruct data_cmd {\n\tint expect_payload;\n\tunsigned int pkt_size;\n\tint (*fn)(struct drbd_connection *, struct packet_info *);\n};\n\nstatic struct data_cmd drbd_cmd_handler[] = {\n\t[P_DATA]\t    = { 1, sizeof(struct p_data), receive_Data },\n\t[P_DATA_REPLY]\t    = { 1, sizeof(struct p_data), receive_DataReply },\n\t[P_RS_DATA_REPLY]   = { 1, sizeof(struct p_data), receive_RSDataReply } ,\n\t[P_BARRIER]\t    = { 0, sizeof(struct p_barrier), receive_Barrier } ,\n\t[P_BITMAP]\t    = { 1, 0, receive_bitmap } ,\n\t[P_COMPRESSED_BITMAP] = { 1, 0, receive_bitmap } ,\n\t[P_UNPLUG_REMOTE]   = { 0, 0, receive_UnplugRemote },\n\t[P_DATA_REQUEST]    = { 0, sizeof(struct p_block_req), receive_DataRequest },\n\t[P_RS_DATA_REQUEST] = { 0, sizeof(struct p_block_req), receive_DataRequest },\n\t[P_SYNC_PARAM]\t    = { 1, 0, receive_SyncParam },\n\t[P_SYNC_PARAM89]    = { 1, 0, receive_SyncParam },\n\t[P_PROTOCOL]        = { 1, sizeof(struct p_protocol), receive_protocol },\n\t[P_UUIDS]\t    = { 0, sizeof(struct p_uuids), receive_uuids },\n\t[P_SIZES]\t    = { 0, sizeof(struct p_sizes), receive_sizes },\n\t[P_STATE]\t    = { 0, sizeof(struct p_state), receive_state },\n\t[P_STATE_CHG_REQ]   = { 0, sizeof(struct p_req_state), receive_req_state },\n\t[P_SYNC_UUID]       = { 0, sizeof(struct p_rs_uuid), receive_sync_uuid },\n\t[P_OV_REQUEST]      = { 0, sizeof(struct p_block_req), receive_DataRequest },\n\t[P_OV_REPLY]        = { 1, sizeof(struct p_block_req), receive_DataRequest },\n\t[P_CSUM_RS_REQUEST] = { 1, sizeof(struct p_block_req), receive_DataRequest },\n\t[P_RS_THIN_REQ]     = { 0, sizeof(struct p_block_req), receive_DataRequest },\n\t[P_DELAY_PROBE]     = { 0, sizeof(struct p_delay_probe93), receive_skip },\n\t[P_OUT_OF_SYNC]     = { 0, sizeof(struct p_block_desc), receive_out_of_sync },\n\t[P_CONN_ST_CHG_REQ] = { 0, sizeof(struct p_req_state), receive_req_conn_state },\n\t[P_PROTOCOL_UPDATE] = { 1, sizeof(struct p_protocol), receive_protocol },\n\t[P_TRIM]\t    = { 0, sizeof(struct p_trim), receive_Data },\n\t[P_ZEROES]\t    = { 0, sizeof(struct p_trim), receive_Data },\n\t[P_RS_DEALLOCATED]  = { 0, sizeof(struct p_block_desc), receive_rs_deallocated },\n\t[P_WSAME]\t    = { 1, sizeof(struct p_wsame), receive_Data },\n};\n\nstatic void drbdd(struct drbd_connection *connection)\n{\n\tstruct packet_info pi;\n\tsize_t shs; /* sub header size */\n\tint err;\n\n\twhile (get_t_state(&connection->receiver) == RUNNING) {\n\t\tstruct data_cmd const *cmd;\n\n\t\tdrbd_thread_current_set_cpu(&connection->receiver);\n\t\tupdate_receiver_timing_details(connection, drbd_recv_header_maybe_unplug);\n\t\tif (drbd_recv_header_maybe_unplug(connection, &pi))\n\t\t\tgoto err_out;\n\n\t\tcmd = &drbd_cmd_handler[pi.cmd];\n\t\tif (unlikely(pi.cmd >= ARRAY_SIZE(drbd_cmd_handler) || !cmd->fn)) {\n\t\t\tdrbd_err(connection, \"Unexpected data packet %s (0x%04x)\",\n\t\t\t\t cmdname(pi.cmd), pi.cmd);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tshs = cmd->pkt_size;\n\t\tif (pi.cmd == P_SIZES && connection->agreed_features & DRBD_FF_WSAME)\n\t\t\tshs += sizeof(struct o_qlim);\n\t\tif (pi.size > shs && !cmd->expect_payload) {\n\t\t\tdrbd_err(connection, \"No payload expected %s l:%d\\n\",\n\t\t\t\t cmdname(pi.cmd), pi.size);\n\t\t\tgoto err_out;\n\t\t}\n\t\tif (pi.size < shs) {\n\t\t\tdrbd_err(connection, \"%s: unexpected packet size, expected:%d received:%d\\n\",\n\t\t\t\t cmdname(pi.cmd), (int)shs, pi.size);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (shs) {\n\t\t\tupdate_receiver_timing_details(connection, drbd_recv_all_warn);\n\t\t\terr = drbd_recv_all_warn(connection, pi.data, shs);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\t\t\tpi.size -= shs;\n\t\t}\n\n\t\tupdate_receiver_timing_details(connection, cmd->fn);\n\t\terr = cmd->fn(connection, &pi);\n\t\tif (err) {\n\t\t\tdrbd_err(connection, \"error receiving %s, e: %d l: %d!\\n\",\n\t\t\t\t cmdname(pi.cmd), err, pi.size);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\treturn;\n\n    err_out:\n\tconn_request_state(connection, NS(conn, C_PROTOCOL_ERROR), CS_HARD);\n}\n\nstatic void conn_disconnect(struct drbd_connection *connection)\n{\n\tstruct drbd_peer_device *peer_device;\n\tenum drbd_conns oc;\n\tint vnr;\n\n\tif (connection->cstate == C_STANDALONE)\n\t\treturn;\n\n\t/* We are about to start the cleanup after connection loss.\n\t * Make sure drbd_make_request knows about that.\n\t * Usually we should be in some network failure state already,\n\t * but just in case we are not, we fix it up here.\n\t */\n\tconn_request_state(connection, NS(conn, C_NETWORK_FAILURE), CS_HARD);\n\n\t/* ack_receiver does not clean up anything. it must not interfere, either */\n\tdrbd_thread_stop(&connection->ack_receiver);\n\tif (connection->ack_sender) {\n\t\tdestroy_workqueue(connection->ack_sender);\n\t\tconnection->ack_sender = NULL;\n\t}\n\tdrbd_free_sock(connection);\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\t\tkref_get(&device->kref);\n\t\trcu_read_unlock();\n\t\tdrbd_disconnected(peer_device);\n\t\tkref_put(&device->kref, drbd_destroy_device);\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\n\n\tif (!list_empty(&connection->current_epoch->list))\n\t\tdrbd_err(connection, \"ASSERTION FAILED: connection->current_epoch->list not empty\\n\");\n\t/* ok, no more ee's on the fly, it is safe to reset the epoch_size */\n\tatomic_set(&connection->current_epoch->epoch_size, 0);\n\tconnection->send.seen_any_write_yet = false;\n\n\tdrbd_info(connection, \"Connection closed\\n\");\n\n\tif (conn_highest_role(connection) == R_PRIMARY && conn_highest_pdsk(connection) >= D_UNKNOWN)\n\t\tconn_try_outdate_peer_async(connection);\n\n\tspin_lock_irq(&connection->resource->req_lock);\n\toc = connection->cstate;\n\tif (oc >= C_UNCONNECTED)\n\t\t_conn_request_state(connection, NS(conn, C_UNCONNECTED), CS_VERBOSE);\n\n\tspin_unlock_irq(&connection->resource->req_lock);\n\n\tif (oc == C_DISCONNECTING)\n\t\tconn_request_state(connection, NS(conn, C_STANDALONE), CS_VERBOSE | CS_HARD);\n}\n\nstatic int drbd_disconnected(struct drbd_peer_device *peer_device)\n{\n\tstruct drbd_device *device = peer_device->device;\n\tunsigned int i;\n\n\t/* wait for current activity to cease. */\n\tspin_lock_irq(&device->resource->req_lock);\n\t_drbd_wait_ee_list_empty(device, &device->active_ee);\n\t_drbd_wait_ee_list_empty(device, &device->sync_ee);\n\t_drbd_wait_ee_list_empty(device, &device->read_ee);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\t/* We do not have data structures that would allow us to\n\t * get the rs_pending_cnt down to 0 again.\n\t *  * On C_SYNC_TARGET we do not have any data structures describing\n\t *    the pending RSDataRequest's we have sent.\n\t *  * On C_SYNC_SOURCE there is no data structure that tracks\n\t *    the P_RS_DATA_REPLY blocks that we sent to the SyncTarget.\n\t *  And no, it is not the sum of the reference counts in the\n\t *  resync_LRU. The resync_LRU tracks the whole operation including\n\t *  the disk-IO, while the rs_pending_cnt only tracks the blocks\n\t *  on the fly. */\n\tdrbd_rs_cancel_all(device);\n\tdevice->rs_total = 0;\n\tdevice->rs_failed = 0;\n\tatomic_set(&device->rs_pending_cnt, 0);\n\twake_up(&device->misc_wait);\n\n\tdel_timer_sync(&device->resync_timer);\n\tresync_timer_fn(&device->resync_timer);\n\n\t/* wait for all w_e_end_data_req, w_e_end_rsdata_req, w_send_barrier,\n\t * w_make_resync_request etc. which may still be on the worker queue\n\t * to be \"canceled\" */\n\tdrbd_flush_workqueue(&peer_device->connection->sender_work);\n\n\tdrbd_finish_peer_reqs(device);\n\n\t/* This second workqueue flush is necessary, since drbd_finish_peer_reqs()\n\t   might have issued a work again. The one before drbd_finish_peer_reqs() is\n\t   necessary to reclain net_ee in drbd_finish_peer_reqs(). */\n\tdrbd_flush_workqueue(&peer_device->connection->sender_work);\n\n\t/* need to do it again, drbd_finish_peer_reqs() may have populated it\n\t * again via drbd_try_clear_on_disk_bm(). */\n\tdrbd_rs_cancel_all(device);\n\n\tkfree(device->p_uuid);\n\tdevice->p_uuid = NULL;\n\n\tif (!drbd_suspended(device))\n\t\ttl_clear(peer_device->connection);\n\n\tdrbd_md_sync(device);\n\n\tif (get_ldev(device)) {\n\t\tdrbd_bitmap_io(device, &drbd_bm_write_copy_pages,\n\t\t\t\t\"write from disconnected\", BM_LOCKED_CHANGE_ALLOWED);\n\t\tput_ldev(device);\n\t}\n\n\t/* tcp_close and release of sendpage pages can be deferred.  I don't\n\t * want to use SO_LINGER, because apparently it can be deferred for\n\t * more than 20 seconds (longest time I checked).\n\t *\n\t * Actually we don't care for exactly when the network stack does its\n\t * put_page(), but release our reference on these pages right here.\n\t */\n\ti = drbd_free_peer_reqs(device, &device->net_ee);\n\tif (i)\n\t\tdrbd_info(device, \"net_ee not empty, killed %u entries\\n\", i);\n\ti = atomic_read(&device->pp_in_use_by_net);\n\tif (i)\n\t\tdrbd_info(device, \"pp_in_use_by_net = %d, expected 0\\n\", i);\n\ti = atomic_read(&device->pp_in_use);\n\tif (i)\n\t\tdrbd_info(device, \"pp_in_use = %d, expected 0\\n\", i);\n\n\tD_ASSERT(device, list_empty(&device->read_ee));\n\tD_ASSERT(device, list_empty(&device->active_ee));\n\tD_ASSERT(device, list_empty(&device->sync_ee));\n\tD_ASSERT(device, list_empty(&device->done_ee));\n\n\treturn 0;\n}\n\n/*\n * We support PRO_VERSION_MIN to PRO_VERSION_MAX. The protocol version\n * we can agree on is stored in agreed_pro_version.\n *\n * feature flags and the reserved array should be enough room for future\n * enhancements of the handshake protocol, and possible plugins...\n *\n * for now, they are expected to be zero, but ignored.\n */\nstatic int drbd_send_features(struct drbd_connection *connection)\n{\n\tstruct drbd_socket *sock;\n\tstruct p_connection_features *p;\n\n\tsock = &connection->data;\n\tp = conn_prepare_command(connection, sock);\n\tif (!p)\n\t\treturn -EIO;\n\tmemset(p, 0, sizeof(*p));\n\tp->protocol_min = cpu_to_be32(PRO_VERSION_MIN);\n\tp->protocol_max = cpu_to_be32(PRO_VERSION_MAX);\n\tp->feature_flags = cpu_to_be32(PRO_FEATURES);\n\treturn conn_send_command(connection, sock, P_CONNECTION_FEATURES, sizeof(*p), NULL, 0);\n}\n\n/*\n * return values:\n *   1 yes, we have a valid connection\n *   0 oops, did not work out, please try again\n *  -1 peer talks different language,\n *     no point in trying again, please go standalone.\n */\nstatic int drbd_do_features(struct drbd_connection *connection)\n{\n\t/* ASSERT current == connection->receiver ... */\n\tstruct p_connection_features *p;\n\tconst int expect = sizeof(struct p_connection_features);\n\tstruct packet_info pi;\n\tint err;\n\n\terr = drbd_send_features(connection);\n\tif (err)\n\t\treturn 0;\n\n\terr = drbd_recv_header(connection, &pi);\n\tif (err)\n\t\treturn 0;\n\n\tif (pi.cmd != P_CONNECTION_FEATURES) {\n\t\tdrbd_err(connection, \"expected ConnectionFeatures packet, received: %s (0x%04x)\\n\",\n\t\t\t cmdname(pi.cmd), pi.cmd);\n\t\treturn -1;\n\t}\n\n\tif (pi.size != expect) {\n\t\tdrbd_err(connection, \"expected ConnectionFeatures length: %u, received: %u\\n\",\n\t\t     expect, pi.size);\n\t\treturn -1;\n\t}\n\n\tp = pi.data;\n\terr = drbd_recv_all_warn(connection, p, expect);\n\tif (err)\n\t\treturn 0;\n\n\tp->protocol_min = be32_to_cpu(p->protocol_min);\n\tp->protocol_max = be32_to_cpu(p->protocol_max);\n\tif (p->protocol_max == 0)\n\t\tp->protocol_max = p->protocol_min;\n\n\tif (PRO_VERSION_MAX < p->protocol_min ||\n\t    PRO_VERSION_MIN > p->protocol_max)\n\t\tgoto incompat;\n\n\tconnection->agreed_pro_version = min_t(int, PRO_VERSION_MAX, p->protocol_max);\n\tconnection->agreed_features = PRO_FEATURES & be32_to_cpu(p->feature_flags);\n\n\tdrbd_info(connection, \"Handshake successful: \"\n\t     \"Agreed network protocol version %d\\n\", connection->agreed_pro_version);\n\n\tdrbd_info(connection, \"Feature flags enabled on protocol level: 0x%x%s%s%s%s.\\n\",\n\t\t  connection->agreed_features,\n\t\t  connection->agreed_features & DRBD_FF_TRIM ? \" TRIM\" : \"\",\n\t\t  connection->agreed_features & DRBD_FF_THIN_RESYNC ? \" THIN_RESYNC\" : \"\",\n\t\t  connection->agreed_features & DRBD_FF_WSAME ? \" WRITE_SAME\" : \"\",\n\t\t  connection->agreed_features & DRBD_FF_WZEROES ? \" WRITE_ZEROES\" :\n\t\t  connection->agreed_features ? \"\" : \" none\");\n\n\treturn 1;\n\n incompat:\n\tdrbd_err(connection, \"incompatible DRBD dialects: \"\n\t    \"I support %d-%d, peer supports %d-%d\\n\",\n\t    PRO_VERSION_MIN, PRO_VERSION_MAX,\n\t    p->protocol_min, p->protocol_max);\n\treturn -1;\n}\n\n#if !defined(CONFIG_CRYPTO_HMAC) && !defined(CONFIG_CRYPTO_HMAC_MODULE)\nstatic int drbd_do_auth(struct drbd_connection *connection)\n{\n\tdrbd_err(connection, \"This kernel was build without CONFIG_CRYPTO_HMAC.\\n\");\n\tdrbd_err(connection, \"You need to disable 'cram-hmac-alg' in drbd.conf.\\n\");\n\treturn -1;\n}\n#else\n#define CHALLENGE_LEN 64\n\n/* Return value:\n\t1 - auth succeeded,\n\t0 - failed, try again (network error),\n\t-1 - auth failed, don't try again.\n*/\n\nstatic int drbd_do_auth(struct drbd_connection *connection)\n{\n\tstruct drbd_socket *sock;\n\tchar my_challenge[CHALLENGE_LEN];  /* 64 Bytes... */\n\tchar *response = NULL;\n\tchar *right_response = NULL;\n\tchar *peers_ch = NULL;\n\tunsigned int key_len;\n\tchar secret[SHARED_SECRET_MAX]; /* 64 byte */\n\tunsigned int resp_size;\n\tstruct shash_desc *desc;\n\tstruct packet_info pi;\n\tstruct net_conf *nc;\n\tint err, rv;\n\n\t/* FIXME: Put the challenge/response into the preallocated socket buffer.  */\n\n\trcu_read_lock();\n\tnc = rcu_dereference(connection->net_conf);\n\tkey_len = strlen(nc->shared_secret);\n\tmemcpy(secret, nc->shared_secret, key_len);\n\trcu_read_unlock();\n\n\tdesc = kmalloc(sizeof(struct shash_desc) +\n\t\t       crypto_shash_descsize(connection->cram_hmac_tfm),\n\t\t       GFP_KERNEL);\n\tif (!desc) {\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\tdesc->tfm = connection->cram_hmac_tfm;\n\n\trv = crypto_shash_setkey(connection->cram_hmac_tfm, (u8 *)secret, key_len);\n\tif (rv) {\n\t\tdrbd_err(connection, \"crypto_shash_setkey() failed with %d\\n\", rv);\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\tget_random_bytes(my_challenge, CHALLENGE_LEN);\n\n\tsock = &connection->data;\n\tif (!conn_prepare_command(connection, sock)) {\n\t\trv = 0;\n\t\tgoto fail;\n\t}\n\trv = !conn_send_command(connection, sock, P_AUTH_CHALLENGE, 0,\n\t\t\t\tmy_challenge, CHALLENGE_LEN);\n\tif (!rv)\n\t\tgoto fail;\n\n\terr = drbd_recv_header(connection, &pi);\n\tif (err) {\n\t\trv = 0;\n\t\tgoto fail;\n\t}\n\n\tif (pi.cmd != P_AUTH_CHALLENGE) {\n\t\tdrbd_err(connection, \"expected AuthChallenge packet, received: %s (0x%04x)\\n\",\n\t\t\t cmdname(pi.cmd), pi.cmd);\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\tif (pi.size > CHALLENGE_LEN * 2) {\n\t\tdrbd_err(connection, \"expected AuthChallenge payload too big.\\n\");\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\tif (pi.size < CHALLENGE_LEN) {\n\t\tdrbd_err(connection, \"AuthChallenge payload too small.\\n\");\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\tpeers_ch = kmalloc(pi.size, GFP_NOIO);\n\tif (peers_ch == NULL) {\n\t\tdrbd_err(connection, \"kmalloc of peers_ch failed\\n\");\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\terr = drbd_recv_all_warn(connection, peers_ch, pi.size);\n\tif (err) {\n\t\trv = 0;\n\t\tgoto fail;\n\t}\n\n\tif (!memcmp(my_challenge, peers_ch, CHALLENGE_LEN)) {\n\t\tdrbd_err(connection, \"Peer presented the same challenge!\\n\");\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\tresp_size = crypto_shash_digestsize(connection->cram_hmac_tfm);\n\tresponse = kmalloc(resp_size, GFP_NOIO);\n\tif (response == NULL) {\n\t\tdrbd_err(connection, \"kmalloc of response failed\\n\");\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\trv = crypto_shash_digest(desc, peers_ch, pi.size, response);\n\tif (rv) {\n\t\tdrbd_err(connection, \"crypto_hash_digest() failed with %d\\n\", rv);\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\tif (!conn_prepare_command(connection, sock)) {\n\t\trv = 0;\n\t\tgoto fail;\n\t}\n\trv = !conn_send_command(connection, sock, P_AUTH_RESPONSE, 0,\n\t\t\t\tresponse, resp_size);\n\tif (!rv)\n\t\tgoto fail;\n\n\terr = drbd_recv_header(connection, &pi);\n\tif (err) {\n\t\trv = 0;\n\t\tgoto fail;\n\t}\n\n\tif (pi.cmd != P_AUTH_RESPONSE) {\n\t\tdrbd_err(connection, \"expected AuthResponse packet, received: %s (0x%04x)\\n\",\n\t\t\t cmdname(pi.cmd), pi.cmd);\n\t\trv = 0;\n\t\tgoto fail;\n\t}\n\n\tif (pi.size != resp_size) {\n\t\tdrbd_err(connection, \"expected AuthResponse payload of wrong size\\n\");\n\t\trv = 0;\n\t\tgoto fail;\n\t}\n\n\terr = drbd_recv_all_warn(connection, response , resp_size);\n\tif (err) {\n\t\trv = 0;\n\t\tgoto fail;\n\t}\n\n\tright_response = kmalloc(resp_size, GFP_NOIO);\n\tif (right_response == NULL) {\n\t\tdrbd_err(connection, \"kmalloc of right_response failed\\n\");\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\trv = crypto_shash_digest(desc, my_challenge, CHALLENGE_LEN,\n\t\t\t\t right_response);\n\tif (rv) {\n\t\tdrbd_err(connection, \"crypto_hash_digest() failed with %d\\n\", rv);\n\t\trv = -1;\n\t\tgoto fail;\n\t}\n\n\trv = !memcmp(response, right_response, resp_size);\n\n\tif (rv)\n\t\tdrbd_info(connection, \"Peer authenticated using %d bytes HMAC\\n\",\n\t\t     resp_size);\n\telse\n\t\trv = -1;\n\n fail:\n\tkfree(peers_ch);\n\tkfree(response);\n\tkfree(right_response);\n\tif (desc) {\n\t\tshash_desc_zero(desc);\n\t\tkfree(desc);\n\t}\n\n\treturn rv;\n}\n#endif\n\nint drbd_receiver(struct drbd_thread *thi)\n{\n\tstruct drbd_connection *connection = thi->connection;\n\tint h;\n\n\tdrbd_info(connection, \"receiver (re)started\\n\");\n\n\tdo {\n\t\th = conn_connect(connection);\n\t\tif (h == 0) {\n\t\t\tconn_disconnect(connection);\n\t\t\tschedule_timeout_interruptible(HZ);\n\t\t}\n\t\tif (h == -1) {\n\t\t\tdrbd_warn(connection, \"Discarding network configuration.\\n\");\n\t\t\tconn_request_state(connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t\t}\n\t} while (h == 0);\n\n\tif (h > 0) {\n\t\tblk_start_plug(&connection->receiver_plug);\n\t\tdrbdd(connection);\n\t\tblk_finish_plug(&connection->receiver_plug);\n\t}\n\n\tconn_disconnect(connection);\n\n\tdrbd_info(connection, \"receiver terminated\\n\");\n\treturn 0;\n}\n\n/* ********* acknowledge sender ******** */\n\nstatic int got_conn_RqSReply(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct p_req_state_reply *p = pi->data;\n\tint retcode = be32_to_cpu(p->retcode);\n\n\tif (retcode >= SS_SUCCESS) {\n\t\tset_bit(CONN_WD_ST_CHG_OKAY, &connection->flags);\n\t} else {\n\t\tset_bit(CONN_WD_ST_CHG_FAIL, &connection->flags);\n\t\tdrbd_err(connection, \"Requested state change failed by peer: %s (%d)\\n\",\n\t\t\t drbd_set_st_err_str(retcode), retcode);\n\t}\n\twake_up(&connection->ping_wait);\n\n\treturn 0;\n}\n\nstatic int got_RqSReply(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_req_state_reply *p = pi->data;\n\tint retcode = be32_to_cpu(p->retcode);\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tif (test_bit(CONN_WD_ST_CHG_REQ, &connection->flags)) {\n\t\tD_ASSERT(device, connection->agreed_pro_version < 100);\n\t\treturn got_conn_RqSReply(connection, pi);\n\t}\n\n\tif (retcode >= SS_SUCCESS) {\n\t\tset_bit(CL_ST_CHG_SUCCESS, &device->flags);\n\t} else {\n\t\tset_bit(CL_ST_CHG_FAIL, &device->flags);\n\t\tdrbd_err(device, \"Requested state change failed by peer: %s (%d)\\n\",\n\t\t\tdrbd_set_st_err_str(retcode), retcode);\n\t}\n\twake_up(&device->state_wait);\n\n\treturn 0;\n}\n\nstatic int got_Ping(struct drbd_connection *connection, struct packet_info *pi)\n{\n\treturn drbd_send_ping_ack(connection);\n\n}\n\nstatic int got_PingAck(struct drbd_connection *connection, struct packet_info *pi)\n{\n\t/* restore idle timeout */\n\tconnection->meta.socket->sk->sk_rcvtimeo = connection->net_conf->ping_int*HZ;\n\tif (!test_and_set_bit(GOT_PING_ACK, &connection->flags))\n\t\twake_up(&connection->ping_wait);\n\n\treturn 0;\n}\n\nstatic int got_IsInSync(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_block_ack *p = pi->data;\n\tsector_t sector = be64_to_cpu(p->sector);\n\tint blksize = be32_to_cpu(p->blksize);\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tD_ASSERT(device, peer_device->connection->agreed_pro_version >= 89);\n\n\tupdate_peer_seq(peer_device, be32_to_cpu(p->seq_num));\n\n\tif (get_ldev(device)) {\n\t\tdrbd_rs_complete_io(device, sector);\n\t\tdrbd_set_in_sync(device, sector, blksize);\n\t\t/* rs_same_csums is supposed to count in units of BM_BLOCK_SIZE */\n\t\tdevice->rs_same_csum += (blksize >> BM_BLOCK_SHIFT);\n\t\tput_ldev(device);\n\t}\n\tdec_rs_pending(device);\n\tatomic_add(blksize >> 9, &device->rs_sect_in);\n\n\treturn 0;\n}\n\nstatic int\nvalidate_req_change_req_state(struct drbd_device *device, u64 id, sector_t sector,\n\t\t\t      struct rb_root *root, const char *func,\n\t\t\t      enum drbd_req_event what, bool missing_ok)\n{\n\tstruct drbd_request *req;\n\tstruct bio_and_error m;\n\n\tspin_lock_irq(&device->resource->req_lock);\n\treq = find_request(device, root, id, sector, missing_ok, func);\n\tif (unlikely(!req)) {\n\t\tspin_unlock_irq(&device->resource->req_lock);\n\t\treturn -EIO;\n\t}\n\t__req_mod(req, what, &m);\n\tspin_unlock_irq(&device->resource->req_lock);\n\n\tif (m.bio)\n\t\tcomplete_master_bio(device, &m);\n\treturn 0;\n}\n\nstatic int got_BlockAck(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_block_ack *p = pi->data;\n\tsector_t sector = be64_to_cpu(p->sector);\n\tint blksize = be32_to_cpu(p->blksize);\n\tenum drbd_req_event what;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tupdate_peer_seq(peer_device, be32_to_cpu(p->seq_num));\n\n\tif (p->block_id == ID_SYNCER) {\n\t\tdrbd_set_in_sync(device, sector, blksize);\n\t\tdec_rs_pending(device);\n\t\treturn 0;\n\t}\n\tswitch (pi->cmd) {\n\tcase P_RS_WRITE_ACK:\n\t\twhat = WRITE_ACKED_BY_PEER_AND_SIS;\n\t\tbreak;\n\tcase P_WRITE_ACK:\n\t\twhat = WRITE_ACKED_BY_PEER;\n\t\tbreak;\n\tcase P_RECV_ACK:\n\t\twhat = RECV_ACKED_BY_PEER;\n\t\tbreak;\n\tcase P_SUPERSEDED:\n\t\twhat = CONFLICT_RESOLVED;\n\t\tbreak;\n\tcase P_RETRY_WRITE:\n\t\twhat = POSTPONE_WRITE;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn validate_req_change_req_state(device, p->block_id, sector,\n\t\t\t\t\t     &device->write_requests, __func__,\n\t\t\t\t\t     what, false);\n}\n\nstatic int got_NegAck(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_block_ack *p = pi->data;\n\tsector_t sector = be64_to_cpu(p->sector);\n\tint size = be32_to_cpu(p->blksize);\n\tint err;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tupdate_peer_seq(peer_device, be32_to_cpu(p->seq_num));\n\n\tif (p->block_id == ID_SYNCER) {\n\t\tdec_rs_pending(device);\n\t\tdrbd_rs_failed_io(device, sector, size);\n\t\treturn 0;\n\t}\n\n\terr = validate_req_change_req_state(device, p->block_id, sector,\n\t\t\t\t\t    &device->write_requests, __func__,\n\t\t\t\t\t    NEG_ACKED, true);\n\tif (err) {\n\t\t/* Protocol A has no P_WRITE_ACKs, but has P_NEG_ACKs.\n\t\t   The master bio might already be completed, therefore the\n\t\t   request is no longer in the collision hash. */\n\t\t/* In Protocol B we might already have got a P_RECV_ACK\n\t\t   but then get a P_NEG_ACK afterwards. */\n\t\tdrbd_set_out_of_sync(device, sector, size);\n\t}\n\treturn 0;\n}\n\nstatic int got_NegDReply(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_block_ack *p = pi->data;\n\tsector_t sector = be64_to_cpu(p->sector);\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tupdate_peer_seq(peer_device, be32_to_cpu(p->seq_num));\n\n\tdrbd_err(device, \"Got NegDReply; Sector %llus, len %u.\\n\",\n\t    (unsigned long long)sector, be32_to_cpu(p->blksize));\n\n\treturn validate_req_change_req_state(device, p->block_id, sector,\n\t\t\t\t\t     &device->read_requests, __func__,\n\t\t\t\t\t     NEG_ACKED, false);\n}\n\nstatic int got_NegRSDReply(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tsector_t sector;\n\tint size;\n\tstruct p_block_ack *p = pi->data;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tsector = be64_to_cpu(p->sector);\n\tsize = be32_to_cpu(p->blksize);\n\n\tupdate_peer_seq(peer_device, be32_to_cpu(p->seq_num));\n\n\tdec_rs_pending(device);\n\n\tif (get_ldev_if_state(device, D_FAILED)) {\n\t\tdrbd_rs_complete_io(device, sector);\n\t\tswitch (pi->cmd) {\n\t\tcase P_NEG_RS_DREPLY:\n\t\t\tdrbd_rs_failed_io(device, sector, size);\n\t\tcase P_RS_CANCEL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tput_ldev(device);\n\t}\n\n\treturn 0;\n}\n\nstatic int got_BarrierAck(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct p_barrier_ack *p = pi->data;\n\tstruct drbd_peer_device *peer_device;\n\tint vnr;\n\n\ttl_release(connection, p->barrier, be32_to_cpu(p->set_size));\n\n\trcu_read_lock();\n\tidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\n\t\tstruct drbd_device *device = peer_device->device;\n\n\t\tif (device->state.conn == C_AHEAD &&\n\t\t    atomic_read(&device->ap_in_flight) == 0 &&\n\t\t    !test_and_set_bit(AHEAD_TO_SYNC_SOURCE, &device->flags)) {\n\t\t\tdevice->start_resync_timer.expires = jiffies + HZ;\n\t\t\tadd_timer(&device->start_resync_timer);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic int got_OVResult(struct drbd_connection *connection, struct packet_info *pi)\n{\n\tstruct drbd_peer_device *peer_device;\n\tstruct drbd_device *device;\n\tstruct p_block_ack *p = pi->data;\n\tstruct drbd_device_work *dw;\n\tsector_t sector;\n\tint size;\n\n\tpeer_device = conn_peer_device(connection, pi->vnr);\n\tif (!peer_device)\n\t\treturn -EIO;\n\tdevice = peer_device->device;\n\n\tsector = be64_to_cpu(p->sector);\n\tsize = be32_to_cpu(p->blksize);\n\n\tupdate_peer_seq(peer_device, be32_to_cpu(p->seq_num));\n\n\tif (be64_to_cpu(p->block_id) == ID_OUT_OF_SYNC)\n\t\tdrbd_ov_out_of_sync_found(device, sector, size);\n\telse\n\t\tov_out_of_sync_print(device);\n\n\tif (!get_ldev(device))\n\t\treturn 0;\n\n\tdrbd_rs_complete_io(device, sector);\n\tdec_rs_pending(device);\n\n\t--device->ov_left;\n\n\t/* let's advance progress step marks only for every other megabyte */\n\tif ((device->ov_left & 0x200) == 0x200)\n\t\tdrbd_advance_rs_marks(device, device->ov_left);\n\n\tif (device->ov_left == 0) {\n\t\tdw = kmalloc(sizeof(*dw), GFP_NOIO);\n\t\tif (dw) {\n\t\t\tdw->w.cb = w_ov_finished;\n\t\t\tdw->device = device;\n\t\t\tdrbd_queue_work(&peer_device->connection->sender_work, &dw->w);\n\t\t} else {\n\t\t\tdrbd_err(device, \"kmalloc(dw) failed.\");\n\t\t\tov_out_of_sync_print(device);\n\t\t\tdrbd_resync_finished(device);\n\t\t}\n\t}\n\tput_ldev(device);\n\treturn 0;\n}\n\nstatic int got_skip(struct drbd_connection *connection, struct packet_info *pi)\n{\n\treturn 0;\n}\n\nstruct meta_sock_cmd {\n\tsize_t pkt_size;\n\tint (*fn)(struct drbd_connection *connection, struct packet_info *);\n};\n\nstatic void set_rcvtimeo(struct drbd_connection *connection, bool ping_timeout)\n{\n\tlong t;\n\tstruct net_conf *nc;\n\n\trcu_read_lock();\n\tnc = rcu_dereference(connection->net_conf);\n\tt = ping_timeout ? nc->ping_timeo : nc->ping_int;\n\trcu_read_unlock();\n\n\tt *= HZ;\n\tif (ping_timeout)\n\t\tt /= 10;\n\n\tconnection->meta.socket->sk->sk_rcvtimeo = t;\n}\n\nstatic void set_ping_timeout(struct drbd_connection *connection)\n{\n\tset_rcvtimeo(connection, 1);\n}\n\nstatic void set_idle_timeout(struct drbd_connection *connection)\n{\n\tset_rcvtimeo(connection, 0);\n}\n\nstatic struct meta_sock_cmd ack_receiver_tbl[] = {\n\t[P_PING]\t    = { 0, got_Ping },\n\t[P_PING_ACK]\t    = { 0, got_PingAck },\n\t[P_RECV_ACK]\t    = { sizeof(struct p_block_ack), got_BlockAck },\n\t[P_WRITE_ACK]\t    = { sizeof(struct p_block_ack), got_BlockAck },\n\t[P_RS_WRITE_ACK]    = { sizeof(struct p_block_ack), got_BlockAck },\n\t[P_SUPERSEDED]   = { sizeof(struct p_block_ack), got_BlockAck },\n\t[P_NEG_ACK]\t    = { sizeof(struct p_block_ack), got_NegAck },\n\t[P_NEG_DREPLY]\t    = { sizeof(struct p_block_ack), got_NegDReply },\n\t[P_NEG_RS_DREPLY]   = { sizeof(struct p_block_ack), got_NegRSDReply },\n\t[P_OV_RESULT]\t    = { sizeof(struct p_block_ack), got_OVResult },\n\t[P_BARRIER_ACK]\t    = { sizeof(struct p_barrier_ack), got_BarrierAck },\n\t[P_STATE_CHG_REPLY] = { sizeof(struct p_req_state_reply), got_RqSReply },\n\t[P_RS_IS_IN_SYNC]   = { sizeof(struct p_block_ack), got_IsInSync },\n\t[P_DELAY_PROBE]     = { sizeof(struct p_delay_probe93), got_skip },\n\t[P_RS_CANCEL]       = { sizeof(struct p_block_ack), got_NegRSDReply },\n\t[P_CONN_ST_CHG_REPLY]={ sizeof(struct p_req_state_reply), got_conn_RqSReply },\n\t[P_RETRY_WRITE]\t    = { sizeof(struct p_block_ack), got_BlockAck },\n};\n\nint drbd_ack_receiver(struct drbd_thread *thi)\n{\n\tstruct drbd_connection *connection = thi->connection;\n\tstruct meta_sock_cmd *cmd = NULL;\n\tstruct packet_info pi;\n\tunsigned long pre_recv_jif;\n\tint rv;\n\tvoid *buf    = connection->meta.rbuf;\n\tint received = 0;\n\tunsigned int header_size = drbd_header_size(connection);\n\tint expect   = header_size;\n\tbool ping_timeout_active = false;\n\n\tsched_set_fifo_low(current);\n\n\twhile (get_t_state(thi) == RUNNING) {\n\t\tdrbd_thread_current_set_cpu(thi);\n\n\t\tconn_reclaim_net_peer_reqs(connection);\n\n\t\tif (test_and_clear_bit(SEND_PING, &connection->flags)) {\n\t\t\tif (drbd_send_ping(connection)) {\n\t\t\t\tdrbd_err(connection, \"drbd_send_ping has failed\\n\");\n\t\t\t\tgoto reconnect;\n\t\t\t}\n\t\t\tset_ping_timeout(connection);\n\t\t\tping_timeout_active = true;\n\t\t}\n\n\t\tpre_recv_jif = jiffies;\n\t\trv = drbd_recv_short(connection->meta.socket, buf, expect-received, 0);\n\n\t\t/* Note:\n\t\t * -EINTR\t (on meta) we got a signal\n\t\t * -EAGAIN\t (on meta) rcvtimeo expired\n\t\t * -ECONNRESET\t other side closed the connection\n\t\t * -ERESTARTSYS  (on data) we got a signal\n\t\t * rv <  0\t other than above: unexpected error!\n\t\t * rv == expected: full header or command\n\t\t * rv <  expected: \"woken\" by signal during receive\n\t\t * rv == 0\t : \"connection shut down by peer\"\n\t\t */\n\t\tif (likely(rv > 0)) {\n\t\t\treceived += rv;\n\t\t\tbuf\t += rv;\n\t\t} else if (rv == 0) {\n\t\t\tif (test_bit(DISCONNECT_SENT, &connection->flags)) {\n\t\t\t\tlong t;\n\t\t\t\trcu_read_lock();\n\t\t\t\tt = rcu_dereference(connection->net_conf)->ping_timeo * HZ/10;\n\t\t\t\trcu_read_unlock();\n\n\t\t\t\tt = wait_event_timeout(connection->ping_wait,\n\t\t\t\t\t\t       connection->cstate < C_WF_REPORT_PARAMS,\n\t\t\t\t\t\t       t);\n\t\t\t\tif (t)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdrbd_err(connection, \"meta connection shut down by peer.\\n\");\n\t\t\tgoto reconnect;\n\t\t} else if (rv == -EAGAIN) {\n\t\t\t/* If the data socket received something meanwhile,\n\t\t\t * that is good enough: peer is still alive. */\n\t\t\tif (time_after(connection->last_received, pre_recv_jif))\n\t\t\t\tcontinue;\n\t\t\tif (ping_timeout_active) {\n\t\t\t\tdrbd_err(connection, \"PingAck did not arrive in time.\\n\");\n\t\t\t\tgoto reconnect;\n\t\t\t}\n\t\t\tset_bit(SEND_PING, &connection->flags);\n\t\t\tcontinue;\n\t\t} else if (rv == -EINTR) {\n\t\t\t/* maybe drbd_thread_stop(): the while condition will notice.\n\t\t\t * maybe woken for send_ping: we'll send a ping above,\n\t\t\t * and change the rcvtimeo */\n\t\t\tflush_signals(current);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tdrbd_err(connection, \"sock_recvmsg returned %d\\n\", rv);\n\t\t\tgoto reconnect;\n\t\t}\n\n\t\tif (received == expect && cmd == NULL) {\n\t\t\tif (decode_header(connection, connection->meta.rbuf, &pi))\n\t\t\t\tgoto reconnect;\n\t\t\tcmd = &ack_receiver_tbl[pi.cmd];\n\t\t\tif (pi.cmd >= ARRAY_SIZE(ack_receiver_tbl) || !cmd->fn) {\n\t\t\t\tdrbd_err(connection, \"Unexpected meta packet %s (0x%04x)\\n\",\n\t\t\t\t\t cmdname(pi.cmd), pi.cmd);\n\t\t\t\tgoto disconnect;\n\t\t\t}\n\t\t\texpect = header_size + cmd->pkt_size;\n\t\t\tif (pi.size != expect - header_size) {\n\t\t\t\tdrbd_err(connection, \"Wrong packet size on meta (c: %d, l: %d)\\n\",\n\t\t\t\t\tpi.cmd, pi.size);\n\t\t\t\tgoto reconnect;\n\t\t\t}\n\t\t}\n\t\tif (received == expect) {\n\t\t\tbool err;\n\n\t\t\terr = cmd->fn(connection, &pi);\n\t\t\tif (err) {\n\t\t\t\tdrbd_err(connection, \"%ps failed\\n\", cmd->fn);\n\t\t\t\tgoto reconnect;\n\t\t\t}\n\n\t\t\tconnection->last_received = jiffies;\n\n\t\t\tif (cmd == &ack_receiver_tbl[P_PING_ACK]) {\n\t\t\t\tset_idle_timeout(connection);\n\t\t\t\tping_timeout_active = false;\n\t\t\t}\n\n\t\t\tbuf\t = connection->meta.rbuf;\n\t\t\treceived = 0;\n\t\t\texpect\t = header_size;\n\t\t\tcmd\t = NULL;\n\t\t}\n\t}\n\n\tif (0) {\nreconnect:\n\t\tconn_request_state(connection, NS(conn, C_NETWORK_FAILURE), CS_HARD);\n\t\tconn_md_sync(connection);\n\t}\n\tif (0) {\ndisconnect:\n\t\tconn_request_state(connection, NS(conn, C_DISCONNECTING), CS_HARD);\n\t}\n\n\tdrbd_info(connection, \"ack_receiver terminated\\n\");\n\n\treturn 0;\n}\n\nvoid drbd_send_acks_wf(struct work_struct *ws)\n{\n\tstruct drbd_peer_device *peer_device =\n\t\tcontainer_of(ws, struct drbd_peer_device, send_acks_work);\n\tstruct drbd_connection *connection = peer_device->connection;\n\tstruct drbd_device *device = peer_device->device;\n\tstruct net_conf *nc;\n\tint tcp_cork, err;\n\n\trcu_read_lock();\n\tnc = rcu_dereference(connection->net_conf);\n\ttcp_cork = nc->tcp_cork;\n\trcu_read_unlock();\n\n\tif (tcp_cork)\n\t\ttcp_sock_set_cork(connection->meta.socket->sk, true);\n\n\terr = drbd_finish_peer_reqs(device);\n\tkref_put(&device->kref, drbd_destroy_device);\n\t/* get is in drbd_endio_write_sec_final(). That is necessary to keep the\n\t   struct work_struct send_acks_work alive, which is in the peer_device object */\n\n\tif (err) {\n\t\tconn_request_state(connection, NS(conn, C_NETWORK_FAILURE), CS_HARD);\n\t\treturn;\n\t}\n\n\tif (tcp_cork)\n\t\ttcp_sock_set_cork(connection->meta.socket->sk, false);\n\n\treturn;\n}\n"}}, "reports": [{"events": [{"location": {"col": 2, "file": 0, "line": 1091}, "message": "second lock on line 1091"}], "macros": [], "notes": [], "path": "/src/drivers/block/drbd/drbd_receiver.c", "reportHash": "55472a876f72ac312539bd899af6215f", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
