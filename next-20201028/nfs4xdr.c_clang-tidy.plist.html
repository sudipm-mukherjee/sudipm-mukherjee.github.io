<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/fs/nfs/nfs4xdr.c", "content": "/*\n *  fs/nfs/nfs4xdr.c\n *\n *  Client-side XDR for NFSv4.\n *\n *  Copyright (c) 2002 The Regents of the University of Michigan.\n *  All rights reserved.\n *\n *  Kendrick Smith <kmsmith@umich.edu>\n *  Andy Adamson   <andros@umich.edu>\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *  3. Neither the name of the University nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED\n *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <linux/param.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/in.h>\n#include <linux/pagemap.h>\n#include <linux/proc_fs.h>\n#include <linux/kdev_t.h>\n#include <linux/module.h>\n#include <linux/utsname.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/nfs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs_fs.h>\n\n#include \"nfs4_fs.h\"\n#include \"nfs4trace.h\"\n#include \"internal.h\"\n#include \"nfs4idmap.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"netns.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_XDR\n\n/* Mapping from NFS error code to \"errno\" error code. */\n#define errno_NFSERR_IO\t\tEIO\n\nstruct compound_hdr;\nstatic int nfs4_stat_to_errno(int);\nstatic void encode_layoutget(struct xdr_stream *xdr,\n\t\t\t     const struct nfs4_layoutget_args *args,\n\t\t\t     struct compound_hdr *hdr);\nstatic int decode_layoutget(struct xdr_stream *xdr, struct rpc_rqst *req,\n\t\t\t     struct nfs4_layoutget_res *res);\n\n/* NFSv4 COMPOUND tags are only wanted for debugging purposes */\n#ifdef DEBUG\n#define NFS4_MAXTAGLEN\t\t20\n#else\n#define NFS4_MAXTAGLEN\t\t0\n#endif\n\n/* lock,open owner id:\n * we currently use size 2 (u64) out of (NFS4_OPAQUE_LIMIT  >> 2)\n */\n#define open_owner_id_maxsz\t(1 + 2 + 1 + 1 + 2)\n#define lock_owner_id_maxsz\t(1 + 1 + 4)\n#define decode_lockowner_maxsz\t(1 + XDR_QUADLEN(IDMAP_NAMESZ))\n#define compound_encode_hdr_maxsz\t(3 + (NFS4_MAXTAGLEN >> 2))\n#define compound_decode_hdr_maxsz\t(3 + (NFS4_MAXTAGLEN >> 2))\n#define op_encode_hdr_maxsz\t(1)\n#define op_decode_hdr_maxsz\t(2)\n#define encode_stateid_maxsz\t(XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define decode_stateid_maxsz\t(XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define encode_verifier_maxsz\t(XDR_QUADLEN(NFS4_VERIFIER_SIZE))\n#define decode_verifier_maxsz\t(XDR_QUADLEN(NFS4_VERIFIER_SIZE))\n#define encode_putfh_maxsz\t(op_encode_hdr_maxsz + 1 + \\\n\t\t\t\t(NFS4_FHSIZE >> 2))\n#define decode_putfh_maxsz\t(op_decode_hdr_maxsz)\n#define encode_putrootfh_maxsz\t(op_encode_hdr_maxsz)\n#define decode_putrootfh_maxsz\t(op_decode_hdr_maxsz)\n#define encode_getfh_maxsz      (op_encode_hdr_maxsz)\n#define decode_getfh_maxsz      (op_decode_hdr_maxsz + 1 + \\\n\t\t\t\t((3+NFS4_FHSIZE) >> 2))\n#define nfs4_fattr_bitmap_maxsz 4\n#define encode_getattr_maxsz    (op_encode_hdr_maxsz + nfs4_fattr_bitmap_maxsz)\n#define nfstime4_maxsz\t\t(3)\n#define nfs4_name_maxsz\t\t(1 + ((3 + NFS4_MAXNAMLEN) >> 2))\n#define nfs4_path_maxsz\t\t(1 + ((3 + NFS4_MAXPATHLEN) >> 2))\n#define nfs4_owner_maxsz\t(1 + XDR_QUADLEN(IDMAP_NAMESZ))\n#define nfs4_group_maxsz\t(1 + XDR_QUADLEN(IDMAP_NAMESZ))\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\n/* PI(4 bytes) + LFS(4 bytes) + 1(for null terminator?) + MAXLABELLEN */\n#define\tnfs4_label_maxsz\t(4 + 4 + 1 + XDR_QUADLEN(NFS4_MAXLABELLEN))\n#else\n#define\tnfs4_label_maxsz\t0\n#endif\n/* We support only one layout type per file system */\n#define decode_mdsthreshold_maxsz (1 + 1 + nfs4_fattr_bitmap_maxsz + 1 + 8)\n/* This is based on getfattr, which uses the most attributes: */\n#define nfs4_fattr_value_maxsz\t(1 + (1 + 2 + 2 + 4 + 2 + 1 + 1 + 2 + 2 + \\\n\t\t\t\t3*nfstime4_maxsz + \\\n\t\t\t\tnfs4_owner_maxsz + \\\n\t\t\t\tnfs4_group_maxsz + nfs4_label_maxsz + \\\n\t\t\t\t decode_mdsthreshold_maxsz))\n#define nfs4_fattr_maxsz\t(nfs4_fattr_bitmap_maxsz + \\\n\t\t\t\tnfs4_fattr_value_maxsz)\n#define decode_getattr_maxsz    (op_decode_hdr_maxsz + nfs4_fattr_maxsz)\n#define encode_attrs_maxsz\t(nfs4_fattr_bitmap_maxsz + \\\n\t\t\t\t 1 + 2 + 1 + \\\n\t\t\t\tnfs4_owner_maxsz + \\\n\t\t\t\tnfs4_group_maxsz + \\\n\t\t\t\tnfs4_label_maxsz + \\\n\t\t\t\t1 + nfstime4_maxsz + \\\n\t\t\t\t1 + nfstime4_maxsz)\n#define encode_savefh_maxsz     (op_encode_hdr_maxsz)\n#define decode_savefh_maxsz     (op_decode_hdr_maxsz)\n#define encode_restorefh_maxsz  (op_encode_hdr_maxsz)\n#define decode_restorefh_maxsz  (op_decode_hdr_maxsz)\n#define encode_fsinfo_maxsz\t(encode_getattr_maxsz)\n/* The 5 accounts for the PNFS attributes, and assumes that at most three\n * layout types will be returned.\n */\n#define decode_fsinfo_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t nfs4_fattr_bitmap_maxsz + 4 + 8 + 5)\n#define encode_renew_maxsz\t(op_encode_hdr_maxsz + 3)\n#define decode_renew_maxsz\t(op_decode_hdr_maxsz)\n#define encode_setclientid_maxsz \\\n\t\t\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\tXDR_QUADLEN(NFS4_VERIFIER_SIZE) + \\\n\t\t\t\t/* client name */ \\\n\t\t\t\t1 + XDR_QUADLEN(NFS4_OPAQUE_LIMIT) + \\\n\t\t\t\t1 /* sc_prog */ + \\\n\t\t\t\t1 + XDR_QUADLEN(RPCBIND_MAXNETIDLEN) + \\\n\t\t\t\t1 + XDR_QUADLEN(RPCBIND_MAXUADDRLEN) + \\\n\t\t\t\t1) /* sc_cb_ident */\n#define decode_setclientid_maxsz \\\n\t\t\t\t(op_decode_hdr_maxsz + \\\n\t\t\t\t2 /* clientid */ + \\\n\t\t\t\tXDR_QUADLEN(NFS4_VERIFIER_SIZE) + \\\n\t\t\t\t1 + XDR_QUADLEN(RPCBIND_MAXNETIDLEN) + \\\n\t\t\t\t1 + XDR_QUADLEN(RPCBIND_MAXUADDRLEN))\n#define encode_setclientid_confirm_maxsz \\\n\t\t\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\t3 + (NFS4_VERIFIER_SIZE >> 2))\n#define decode_setclientid_confirm_maxsz \\\n\t\t\t\t(op_decode_hdr_maxsz)\n#define encode_lookup_maxsz\t(op_encode_hdr_maxsz + nfs4_name_maxsz)\n#define decode_lookup_maxsz\t(op_decode_hdr_maxsz)\n#define encode_lookupp_maxsz\t(op_encode_hdr_maxsz)\n#define decode_lookupp_maxsz\t(op_decode_hdr_maxsz)\n#define encode_share_access_maxsz \\\n\t\t\t\t(2)\n#define encode_createmode_maxsz\t(1 + encode_attrs_maxsz + encode_verifier_maxsz)\n#define encode_opentype_maxsz\t(1 + encode_createmode_maxsz)\n#define encode_claim_null_maxsz\t(1 + nfs4_name_maxsz)\n#define encode_open_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t2 + encode_share_access_maxsz + 2 + \\\n\t\t\t\topen_owner_id_maxsz + \\\n\t\t\t\tencode_opentype_maxsz + \\\n\t\t\t\tencode_claim_null_maxsz)\n#define decode_space_limit_maxsz\t(3)\n#define decode_ace_maxsz\t(3 + nfs4_owner_maxsz)\n#define decode_delegation_maxsz\t(1 + decode_stateid_maxsz + 1 + \\\n\t\t\t\tdecode_space_limit_maxsz + \\\n\t\t\t\tdecode_ace_maxsz)\n#define decode_change_info_maxsz\t(5)\n#define decode_open_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\tdecode_stateid_maxsz + \\\n\t\t\t\tdecode_change_info_maxsz + 1 + \\\n\t\t\t\tnfs4_fattr_bitmap_maxsz + \\\n\t\t\t\tdecode_delegation_maxsz)\n#define encode_open_confirm_maxsz \\\n\t\t\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 1)\n#define decode_open_confirm_maxsz \\\n\t\t\t\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_stateid_maxsz)\n#define encode_open_downgrade_maxsz \\\n\t\t\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 1 + \\\n\t\t\t\t encode_share_access_maxsz)\n#define decode_open_downgrade_maxsz \\\n\t\t\t\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_stateid_maxsz)\n#define encode_close_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t 1 + encode_stateid_maxsz)\n#define decode_close_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_stateid_maxsz)\n#define encode_setattr_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + \\\n\t\t\t\t encode_attrs_maxsz)\n#define decode_setattr_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t nfs4_fattr_bitmap_maxsz)\n#define encode_read_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 3)\n#define decode_read_maxsz\t(op_decode_hdr_maxsz + 2 + 1)\n#define encode_readdir_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t 2 + encode_verifier_maxsz + 5 + \\\n\t\t\t\tnfs4_label_maxsz)\n#define decode_readdir_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_verifier_maxsz + 1)\n#define encode_readlink_maxsz\t(op_encode_hdr_maxsz)\n#define decode_readlink_maxsz\t(op_decode_hdr_maxsz + 1 + 1)\n#define encode_write_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 4)\n#define decode_write_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t 2 + decode_verifier_maxsz)\n#define encode_commit_maxsz\t(op_encode_hdr_maxsz + 3)\n#define decode_commit_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_verifier_maxsz)\n#define encode_remove_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\tnfs4_name_maxsz)\n#define decode_remove_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_change_info_maxsz)\n#define encode_rename_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t2 * nfs4_name_maxsz)\n#define decode_rename_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_change_info_maxsz + \\\n\t\t\t\t decode_change_info_maxsz)\n#define encode_link_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\tnfs4_name_maxsz)\n#define decode_link_maxsz\t(op_decode_hdr_maxsz + decode_change_info_maxsz)\n#define encode_lockowner_maxsz\t(7)\n#define encode_lock_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t 7 + \\\n\t\t\t\t 1 + encode_stateid_maxsz + 1 + \\\n\t\t\t\t encode_lockowner_maxsz)\n#define decode_lock_denied_maxsz \\\n\t\t\t\t(8 + decode_lockowner_maxsz)\n#define decode_lock_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_lock_denied_maxsz)\n#define encode_lockt_maxsz\t(op_encode_hdr_maxsz + 5 + \\\n\t\t\t\tencode_lockowner_maxsz)\n#define decode_lockt_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_lock_denied_maxsz)\n#define encode_locku_maxsz\t(op_encode_hdr_maxsz + 3 + \\\n\t\t\t\t encode_stateid_maxsz + \\\n\t\t\t\t 4)\n#define decode_locku_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_stateid_maxsz)\n#define encode_release_lockowner_maxsz \\\n\t\t\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_lockowner_maxsz)\n#define decode_release_lockowner_maxsz \\\n\t\t\t\t(op_decode_hdr_maxsz)\n#define encode_access_maxsz\t(op_encode_hdr_maxsz + 1)\n#define decode_access_maxsz\t(op_decode_hdr_maxsz + 2)\n#define encode_symlink_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t1 + nfs4_name_maxsz + \\\n\t\t\t\t1 + \\\n\t\t\t\tnfs4_fattr_maxsz)\n#define decode_symlink_maxsz\t(op_decode_hdr_maxsz + 8)\n#define encode_create_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t1 + 2 + nfs4_name_maxsz + \\\n\t\t\t\tencode_attrs_maxsz)\n#define decode_create_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\tdecode_change_info_maxsz + \\\n\t\t\t\tnfs4_fattr_bitmap_maxsz)\n#define encode_statfs_maxsz\t(encode_getattr_maxsz)\n#define decode_statfs_maxsz\t(decode_getattr_maxsz)\n#define encode_delegreturn_maxsz (op_encode_hdr_maxsz + 4)\n#define decode_delegreturn_maxsz (op_decode_hdr_maxsz)\n#define encode_getacl_maxsz\t(encode_getattr_maxsz)\n#define decode_getacl_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t nfs4_fattr_bitmap_maxsz + 1 + 1)\n#define encode_setacl_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 3)\n#define decode_setacl_maxsz\t(decode_setattr_maxsz)\n#define encode_fs_locations_maxsz \\\n\t\t\t\t(encode_getattr_maxsz)\n#define decode_fs_locations_maxsz \\\n\t\t\t\t(1)\n#define encode_secinfo_maxsz\t(op_encode_hdr_maxsz + nfs4_name_maxsz)\n#define decode_secinfo_maxsz\t(op_decode_hdr_maxsz + 1 + ((NFS_MAX_SECFLAVORS * (16 + GSS_OID_MAX_LEN)) / 4))\n\n#if defined(CONFIG_NFS_V4_1)\n#define NFS4_MAX_MACHINE_NAME_LEN (64)\n#define IMPL_NAME_LIMIT (sizeof(utsname()->sysname) + sizeof(utsname()->release) + \\\n\t\t\t sizeof(utsname()->version) + sizeof(utsname()->machine) + 8)\n\n#define encode_exchange_id_maxsz (op_encode_hdr_maxsz + \\\n\t\t\t\tencode_verifier_maxsz + \\\n\t\t\t\t1 /* co_ownerid.len */ + \\\n\t\t\t\t/* eia_clientowner */ \\\n\t\t\t\t1 + XDR_QUADLEN(NFS4_OPAQUE_LIMIT) + \\\n\t\t\t\t1 /* flags */ + \\\n\t\t\t\t1 /* spa_how */ + \\\n\t\t\t\t/* max is SP4_MACH_CRED (for now) */ + \\\n\t\t\t\t1 + NFS4_OP_MAP_NUM_WORDS + \\\n\t\t\t\t1 + NFS4_OP_MAP_NUM_WORDS + \\\n\t\t\t\t1 /* implementation id array of size 1 */ + \\\n\t\t\t\t1 /* nii_domain */ + \\\n\t\t\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + \\\n\t\t\t\t1 /* nii_name */ + \\\n\t\t\t\tXDR_QUADLEN(IMPL_NAME_LIMIT) + \\\n\t\t\t\t3 /* nii_date */)\n#define decode_exchange_id_maxsz (op_decode_hdr_maxsz + \\\n\t\t\t\t2 /* eir_clientid */ + \\\n\t\t\t\t1 /* eir_sequenceid */ + \\\n\t\t\t\t1 /* eir_flags */ + \\\n\t\t\t\t1 /* spr_how */ + \\\n\t\t\t\t  /* max is SP4_MACH_CRED (for now) */ + \\\n\t\t\t\t1 + NFS4_OP_MAP_NUM_WORDS + \\\n\t\t\t\t1 + NFS4_OP_MAP_NUM_WORDS + \\\n\t\t\t\t2 /* eir_server_owner.so_minor_id */ + \\\n\t\t\t\t/* eir_server_owner.so_major_id<> */ \\\n\t\t\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + 1 + \\\n\t\t\t\t/* eir_server_scope<> */ \\\n\t\t\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + 1 + \\\n\t\t\t\t1 /* eir_server_impl_id array length */ + \\\n\t\t\t\t1 /* nii_domain */ + \\\n\t\t\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + \\\n\t\t\t\t1 /* nii_name */ + \\\n\t\t\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + \\\n\t\t\t\t3 /* nii_date */)\n#define encode_channel_attrs_maxsz  (6 + 1 /* ca_rdma_ird.len (0) */)\n#define decode_channel_attrs_maxsz  (6 + \\\n\t\t\t\t     1 /* ca_rdma_ird.len */ + \\\n\t\t\t\t     1 /* ca_rdma_ird */)\n#define encode_create_session_maxsz  (op_encode_hdr_maxsz + \\\n\t\t\t\t     2 /* csa_clientid */ + \\\n\t\t\t\t     1 /* csa_sequence */ + \\\n\t\t\t\t     1 /* csa_flags */ + \\\n\t\t\t\t     encode_channel_attrs_maxsz + \\\n\t\t\t\t     encode_channel_attrs_maxsz + \\\n\t\t\t\t     1 /* csa_cb_program */ + \\\n\t\t\t\t     1 /* csa_sec_parms.len (1) */ + \\\n\t\t\t\t     1 /* cb_secflavor (AUTH_SYS) */ + \\\n\t\t\t\t     1 /* stamp */ + \\\n\t\t\t\t     1 /* machinename.len */ + \\\n\t\t\t\t     XDR_QUADLEN(NFS4_MAX_MACHINE_NAME_LEN) + \\\n\t\t\t\t     1 /* uid */ + \\\n\t\t\t\t     1 /* gid */ + \\\n\t\t\t\t     1 /* gids.len (0) */)\n#define decode_create_session_maxsz  (op_decode_hdr_maxsz +\t\\\n\t\t\t\t     XDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + \\\n\t\t\t\t     1 /* csr_sequence */ + \\\n\t\t\t\t     1 /* csr_flags */ + \\\n\t\t\t\t     decode_channel_attrs_maxsz + \\\n\t\t\t\t     decode_channel_attrs_maxsz)\n#define encode_bind_conn_to_session_maxsz  (op_encode_hdr_maxsz + \\\n\t\t\t\t     /* bctsa_sessid */ \\\n\t\t\t\t     XDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + \\\n\t\t\t\t     1 /* bctsa_dir */ + \\\n\t\t\t\t     1 /* bctsa_use_conn_in_rdma_mode */)\n#define decode_bind_conn_to_session_maxsz  (op_decode_hdr_maxsz +\t\\\n\t\t\t\t     /* bctsr_sessid */ \\\n\t\t\t\t     XDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + \\\n\t\t\t\t     1 /* bctsr_dir */ + \\\n\t\t\t\t     1 /* bctsr_use_conn_in_rdma_mode */)\n#define encode_destroy_session_maxsz    (op_encode_hdr_maxsz + 4)\n#define decode_destroy_session_maxsz    (op_decode_hdr_maxsz)\n#define encode_destroy_clientid_maxsz   (op_encode_hdr_maxsz + 2)\n#define decode_destroy_clientid_maxsz   (op_decode_hdr_maxsz)\n#define encode_sequence_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\tXDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + 4)\n#define decode_sequence_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\tXDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + 5)\n#define encode_reclaim_complete_maxsz\t(op_encode_hdr_maxsz + 4)\n#define decode_reclaim_complete_maxsz\t(op_decode_hdr_maxsz + 4)\n#define encode_getdeviceinfo_maxsz (op_encode_hdr_maxsz + \\\n\t\t\t\tXDR_QUADLEN(NFS4_DEVICEID4_SIZE) + \\\n\t\t\t\t1 /* layout type */ + \\\n\t\t\t\t1 /* maxcount */ + \\\n\t\t\t\t1 /* bitmap size */ + \\\n\t\t\t\t1 /* notification bitmap length */ + \\\n\t\t\t\t1 /* notification bitmap, word 0 */)\n#define decode_getdeviceinfo_maxsz (op_decode_hdr_maxsz + \\\n\t\t\t\t1 /* layout type */ + \\\n\t\t\t\t1 /* opaque devaddr4 length */ + \\\n\t\t\t\t  /* devaddr4 payload is read into page */ \\\n\t\t\t\t1 /* notification bitmap length */ + \\\n\t\t\t\t1 /* notification bitmap, word 0 */ + \\\n\t\t\t\t1 /* possible XDR padding */)\n#define encode_layoutget_maxsz\t(op_encode_hdr_maxsz + 10 + \\\n\t\t\t\tencode_stateid_maxsz)\n#define decode_layoutget_maxsz\t(op_decode_hdr_maxsz + 8 + \\\n\t\t\t\tdecode_stateid_maxsz + \\\n\t\t\t\tXDR_QUADLEN(PNFS_LAYOUT_MAXSIZE) + 1)\n#define encode_layoutcommit_maxsz (op_encode_hdr_maxsz +          \\\n\t\t\t\t2 /* offset */ + \\\n\t\t\t\t2 /* length */ + \\\n\t\t\t\t1 /* reclaim */ + \\\n\t\t\t\tencode_stateid_maxsz + \\\n\t\t\t\t1 /* new offset (true) */ + \\\n\t\t\t\t2 /* last byte written */ + \\\n\t\t\t\t1 /* nt_timechanged (false) */ + \\\n\t\t\t\t1 /* layoutupdate4 layout type */ + \\\n\t\t\t\t1 /* layoutupdate4 opaqueue len */)\n\t\t\t\t  /* the actual content of layoutupdate4 should\n\t\t\t\t     be allocated by drivers and spliced in\n\t\t\t\t     using xdr_write_pages */\n#define decode_layoutcommit_maxsz (op_decode_hdr_maxsz + 3)\n#define encode_layoutreturn_maxsz (8 + op_encode_hdr_maxsz + \\\n\t\t\t\tencode_stateid_maxsz + \\\n\t\t\t\t1 + \\\n\t\t\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT))\n#define decode_layoutreturn_maxsz (op_decode_hdr_maxsz + \\\n\t\t\t\t1 + decode_stateid_maxsz)\n#define encode_secinfo_no_name_maxsz (op_encode_hdr_maxsz + 1)\n#define decode_secinfo_no_name_maxsz decode_secinfo_maxsz\n#define encode_test_stateid_maxsz\t(op_encode_hdr_maxsz + 2 + \\\n\t\t\t\t\t XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define decode_test_stateid_maxsz\t(op_decode_hdr_maxsz + 2 + 1)\n#define encode_free_stateid_maxsz\t(op_encode_hdr_maxsz + 1 + \\\n\t\t\t\t\t XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define decode_free_stateid_maxsz\t(op_decode_hdr_maxsz)\n#else /* CONFIG_NFS_V4_1 */\n#define encode_sequence_maxsz\t0\n#define decode_sequence_maxsz\t0\n#define encode_layoutreturn_maxsz 0\n#define decode_layoutreturn_maxsz 0\n#define encode_layoutget_maxsz\t0\n#define decode_layoutget_maxsz\t0\n#endif /* CONFIG_NFS_V4_1 */\n\n#define NFS4_enc_compound_sz\t(1024)  /* XXX: large enough? */\n#define NFS4_dec_compound_sz\t(1024)  /* XXX: large enough? */\n#define NFS4_enc_read_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_read_maxsz)\n#define NFS4_dec_read_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_read_maxsz)\n#define NFS4_enc_readlink_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_readlink_maxsz)\n#define NFS4_dec_readlink_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_readlink_maxsz)\n#define NFS4_enc_readdir_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_readdir_maxsz)\n#define NFS4_dec_readdir_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_readdir_maxsz)\n#define NFS4_enc_write_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_write_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_write_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_write_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_commit_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_commit_maxsz)\n#define NFS4_dec_commit_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_commit_maxsz)\n#define NFS4_enc_open_sz        (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_open_maxsz + \\\n\t\t\t\tencode_access_maxsz + \\\n\t\t\t\tencode_getfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_layoutget_maxsz)\n#define NFS4_dec_open_sz        (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_open_maxsz + \\\n\t\t\t\tdecode_access_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_layoutget_maxsz)\n#define NFS4_enc_open_confirm_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_open_confirm_maxsz)\n#define NFS4_dec_open_confirm_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_open_confirm_maxsz)\n#define NFS4_enc_open_noattr_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\t\tencode_open_maxsz + \\\n\t\t\t\t\tencode_access_maxsz + \\\n\t\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\t\tencode_layoutget_maxsz)\n#define NFS4_dec_open_noattr_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\t\tdecode_open_maxsz + \\\n\t\t\t\t\tdecode_access_maxsz + \\\n\t\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\t\tdecode_layoutget_maxsz)\n#define NFS4_enc_open_downgrade_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_layoutreturn_maxsz + \\\n\t\t\t\t encode_open_downgrade_maxsz)\n#define NFS4_dec_open_downgrade_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_layoutreturn_maxsz + \\\n\t\t\t\t decode_open_downgrade_maxsz)\n#define NFS4_enc_close_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_layoutreturn_maxsz + \\\n\t\t\t\t encode_close_maxsz + \\\n\t\t\t\t encode_getattr_maxsz)\n#define NFS4_dec_close_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_layoutreturn_maxsz + \\\n\t\t\t\t decode_close_maxsz + \\\n\t\t\t\t decode_getattr_maxsz)\n#define NFS4_enc_setattr_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_setattr_maxsz + \\\n\t\t\t\t encode_getattr_maxsz)\n#define NFS4_dec_setattr_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_setattr_maxsz + \\\n\t\t\t\t decode_getattr_maxsz)\n#define NFS4_enc_fsinfo_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_fsinfo_maxsz)\n#define NFS4_dec_fsinfo_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_fsinfo_maxsz)\n#define NFS4_enc_renew_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_renew_maxsz)\n#define NFS4_dec_renew_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_renew_maxsz)\n#define NFS4_enc_setclientid_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_setclientid_maxsz)\n#define NFS4_dec_setclientid_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_setclientid_maxsz)\n#define NFS4_enc_setclientid_confirm_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_setclientid_confirm_maxsz)\n#define NFS4_dec_setclientid_confirm_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_setclientid_confirm_maxsz)\n#define NFS4_enc_lock_sz        (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_lock_maxsz)\n#define NFS4_dec_lock_sz        (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_lock_maxsz)\n#define NFS4_enc_lockt_sz       (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_lockt_maxsz)\n#define NFS4_dec_lockt_sz       (compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_lockt_maxsz)\n#define NFS4_enc_locku_sz       (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_locku_maxsz)\n#define NFS4_dec_locku_sz       (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_locku_maxsz)\n#define NFS4_enc_release_lockowner_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_lockowner_maxsz)\n#define NFS4_dec_release_lockowner_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_lockowner_maxsz)\n#define NFS4_enc_access_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_access_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_access_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_access_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_getattr_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_renew_maxsz)\n#define NFS4_dec_getattr_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_renew_maxsz)\n#define NFS4_enc_lookup_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_lookup_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_getfh_maxsz)\n#define NFS4_dec_lookup_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_lookup_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz)\n#define NFS4_enc_lookupp_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_lookupp_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_getfh_maxsz)\n#define NFS4_dec_lookupp_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_lookupp_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz)\n#define NFS4_enc_lookup_root_sz (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putrootfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_getfh_maxsz)\n#define NFS4_dec_lookup_root_sz (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putrootfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz)\n#define NFS4_enc_remove_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_remove_maxsz)\n#define NFS4_dec_remove_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_remove_maxsz)\n#define NFS4_enc_rename_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_savefh_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_rename_maxsz)\n#define NFS4_dec_rename_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_savefh_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_rename_maxsz)\n#define NFS4_enc_link_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_savefh_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_link_maxsz + \\\n\t\t\t\tencode_restorefh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_link_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_savefh_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_link_maxsz + \\\n\t\t\t\tdecode_restorefh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_symlink_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_symlink_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_getfh_maxsz)\n#define NFS4_dec_symlink_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_symlink_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz)\n#define NFS4_enc_create_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_create_maxsz + \\\n\t\t\t\tencode_getfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_create_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_create_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_pathconf_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_pathconf_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_statfs_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_statfs_maxsz)\n#define NFS4_dec_statfs_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_statfs_maxsz)\n#define NFS4_enc_server_caps_sz (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_server_caps_sz (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_delegreturn_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_layoutreturn_maxsz + \\\n\t\t\t\tencode_delegreturn_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_delegreturn_sz (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_layoutreturn_maxsz + \\\n\t\t\t\tdecode_delegreturn_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_getacl_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_getacl_maxsz)\n#define NFS4_dec_getacl_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_getacl_maxsz)\n#define NFS4_enc_setacl_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_setacl_maxsz)\n#define NFS4_dec_setacl_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_setacl_maxsz)\n#define NFS4_enc_fs_locations_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_lookup_maxsz + \\\n\t\t\t\t encode_fs_locations_maxsz + \\\n\t\t\t\t encode_renew_maxsz)\n#define NFS4_dec_fs_locations_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_lookup_maxsz + \\\n\t\t\t\t decode_fs_locations_maxsz + \\\n\t\t\t\t decode_renew_maxsz)\n#define NFS4_enc_secinfo_sz \t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_secinfo_maxsz)\n#define NFS4_dec_secinfo_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_secinfo_maxsz)\n#define NFS4_enc_fsid_present_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_getfh_maxsz + \\\n\t\t\t\t encode_renew_maxsz)\n#define NFS4_dec_fsid_present_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_getfh_maxsz + \\\n\t\t\t\t decode_renew_maxsz)\n#if defined(CONFIG_NFS_V4_1)\n#define NFS4_enc_bind_conn_to_session_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_bind_conn_to_session_maxsz)\n#define NFS4_dec_bind_conn_to_session_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_bind_conn_to_session_maxsz)\n#define NFS4_enc_exchange_id_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_exchange_id_maxsz)\n#define NFS4_dec_exchange_id_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_exchange_id_maxsz)\n#define NFS4_enc_create_session_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_create_session_maxsz)\n#define NFS4_dec_create_session_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_create_session_maxsz)\n#define NFS4_enc_destroy_session_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_destroy_session_maxsz)\n#define NFS4_dec_destroy_session_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_destroy_session_maxsz)\n#define NFS4_enc_destroy_clientid_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_destroy_clientid_maxsz)\n#define NFS4_dec_destroy_clientid_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_destroy_clientid_maxsz)\n#define NFS4_enc_sequence_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t encode_sequence_maxsz)\n#define NFS4_dec_sequence_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_sequence_maxsz)\n#endif\n#define NFS4_enc_get_lease_time_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_putrootfh_maxsz + \\\n\t\t\t\t\t encode_fsinfo_maxsz)\n#define NFS4_dec_get_lease_time_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_putrootfh_maxsz + \\\n\t\t\t\t\t decode_fsinfo_maxsz)\n#if defined(CONFIG_NFS_V4_1)\n#define NFS4_enc_reclaim_complete_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_reclaim_complete_maxsz)\n#define NFS4_dec_reclaim_complete_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_reclaim_complete_maxsz)\n#define NFS4_enc_getdeviceinfo_sz (compound_encode_hdr_maxsz +    \\\n\t\t\t\tencode_sequence_maxsz +\\\n\t\t\t\tencode_getdeviceinfo_maxsz)\n#define NFS4_dec_getdeviceinfo_sz (compound_decode_hdr_maxsz +    \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_getdeviceinfo_maxsz)\n#define NFS4_enc_layoutget_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz +        \\\n\t\t\t\tencode_layoutget_maxsz)\n#define NFS4_dec_layoutget_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz +        \\\n\t\t\t\tdecode_layoutget_maxsz)\n#define NFS4_enc_layoutcommit_sz (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz +\\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_layoutcommit_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_layoutcommit_sz (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_layoutcommit_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_layoutreturn_sz (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_layoutreturn_maxsz)\n#define NFS4_dec_layoutreturn_sz (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_layoutreturn_maxsz)\n#define NFS4_enc_secinfo_no_name_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\tencode_sequence_maxsz + \\\n\t\t\t\t\tencode_putrootfh_maxsz +\\\n\t\t\t\t\tencode_secinfo_no_name_maxsz)\n#define NFS4_dec_secinfo_no_name_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\tdecode_sequence_maxsz + \\\n\t\t\t\t\tdecode_putrootfh_maxsz + \\\n\t\t\t\t\tdecode_secinfo_no_name_maxsz)\n#define NFS4_enc_test_stateid_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_test_stateid_maxsz)\n#define NFS4_dec_test_stateid_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_test_stateid_maxsz)\n#define NFS4_enc_free_stateid_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\t encode_sequence_maxsz + \\\n\t\t\t\t\t encode_free_stateid_maxsz)\n#define NFS4_dec_free_stateid_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\t decode_sequence_maxsz + \\\n\t\t\t\t\t decode_free_stateid_maxsz)\n\nconst u32 nfs41_maxwrite_overhead = ((RPC_MAX_HEADER_WITH_AUTH +\n\t\t\t\t      compound_encode_hdr_maxsz +\n\t\t\t\t      encode_sequence_maxsz +\n\t\t\t\t      encode_putfh_maxsz +\n\t\t\t\t      encode_getattr_maxsz) *\n\t\t\t\t     XDR_UNIT);\n\nconst u32 nfs41_maxread_overhead = ((RPC_MAX_HEADER_WITH_AUTH +\n\t\t\t\t     compound_decode_hdr_maxsz +\n\t\t\t\t     decode_sequence_maxsz +\n\t\t\t\t     decode_putfh_maxsz) *\n\t\t\t\t    XDR_UNIT);\n\nconst u32 nfs41_maxgetdevinfo_overhead = ((RPC_MAX_REPHEADER_WITH_AUTH +\n\t\t\t\t\t   compound_decode_hdr_maxsz +\n\t\t\t\t\t   decode_sequence_maxsz) *\n\t\t\t\t\t  XDR_UNIT);\nEXPORT_SYMBOL_GPL(nfs41_maxgetdevinfo_overhead);\n#endif /* CONFIG_NFS_V4_1 */\n\nstatic const umode_t nfs_type2fmt[] = {\n\t[NF4BAD] = 0,\n\t[NF4REG] = S_IFREG,\n\t[NF4DIR] = S_IFDIR,\n\t[NF4BLK] = S_IFBLK,\n\t[NF4CHR] = S_IFCHR,\n\t[NF4LNK] = S_IFLNK,\n\t[NF4SOCK] = S_IFSOCK,\n\t[NF4FIFO] = S_IFIFO,\n\t[NF4ATTRDIR] = 0,\n\t[NF4NAMEDATTR] = 0,\n};\n\nstruct compound_hdr {\n\tint32_t\t\tstatus;\n\tuint32_t\tnops;\n\t__be32 *\tnops_p;\n\tuint32_t\ttaglen;\n\tchar *\t\ttag;\n\tuint32_t\treplen;\t\t/* expected reply words */\n\tu32\t\tminorversion;\n};\n\nstatic __be32 *reserve_space(struct xdr_stream *xdr, size_t nbytes)\n{\n\t__be32 *p = xdr_reserve_space(xdr, nbytes);\n\tBUG_ON(!p);\n\treturn p;\n}\n\nstatic void encode_opaque_fixed(struct xdr_stream *xdr, const void *buf, size_t len)\n{\n\tWARN_ON_ONCE(xdr_stream_encode_opaque_fixed(xdr, buf, len) < 0);\n}\n\nstatic void encode_string(struct xdr_stream *xdr, unsigned int len, const char *str)\n{\n\tWARN_ON_ONCE(xdr_stream_encode_opaque(xdr, str, len) < 0);\n}\n\nstatic void encode_uint32(struct xdr_stream *xdr, u32 n)\n{\n\tWARN_ON_ONCE(xdr_stream_encode_u32(xdr, n) < 0);\n}\n\nstatic void encode_uint64(struct xdr_stream *xdr, u64 n)\n{\n\tWARN_ON_ONCE(xdr_stream_encode_u64(xdr, n) < 0);\n}\n\nstatic ssize_t xdr_encode_bitmap4(struct xdr_stream *xdr,\n\t\tconst __u32 *bitmap, size_t len)\n{\n\tssize_t ret;\n\n\t/* Trim empty words */\n\twhile (len > 0 && bitmap[len-1] == 0)\n\t\tlen--;\n\tret = xdr_stream_encode_uint32_array(xdr, bitmap, len);\n\tif (WARN_ON_ONCE(ret < 0))\n\t\treturn ret;\n\treturn len;\n}\n\nstatic size_t mask_bitmap4(const __u32 *bitmap, const __u32 *mask,\n\t\t__u32 *res, size_t len)\n{\n\tsize_t i;\n\t__u32 tmp;\n\n\twhile (len > 0 && (bitmap[len-1] == 0 || mask[len-1] == 0))\n\t\tlen--;\n\tfor (i = len; i-- > 0;) {\n\t\ttmp = bitmap[i] & mask[i];\n\t\tres[i] = tmp;\n\t}\n\treturn len;\n}\n\nstatic void encode_nfs4_seqid(struct xdr_stream *xdr,\n\t\tconst struct nfs_seqid *seqid)\n{\n\tif (seqid != NULL)\n\t\tencode_uint32(xdr, seqid->sequence->counter);\n\telse\n\t\tencode_uint32(xdr, 0);\n}\n\nstatic void encode_compound_hdr(struct xdr_stream *xdr,\n\t\t\t\tstruct rpc_rqst *req,\n\t\t\t\tstruct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\t/* initialize running count of expected bytes in reply.\n\t * NOTE: the replied tag SHOULD be the same is the one sent,\n\t * but this is not required as a MUST for the server to do so. */\n\thdr->replen = 3 + hdr->taglen;\n\n\tWARN_ON_ONCE(hdr->taglen > NFS4_MAXTAGLEN);\n\tencode_string(xdr, hdr->taglen, hdr->tag);\n\tp = reserve_space(xdr, 8);\n\t*p++ = cpu_to_be32(hdr->minorversion);\n\thdr->nops_p = p;\n\t*p = cpu_to_be32(hdr->nops);\n}\n\nstatic void encode_op_hdr(struct xdr_stream *xdr, enum nfs_opnum4 op,\n\t\tuint32_t replen,\n\t\tstruct compound_hdr *hdr)\n{\n\tencode_uint32(xdr, op);\n\thdr->nops++;\n\thdr->replen += replen;\n}\n\nstatic void encode_nops(struct compound_hdr *hdr)\n{\n\tWARN_ON_ONCE(hdr->nops > NFS4_MAX_OPS);\n\t*hdr->nops_p = htonl(hdr->nops);\n}\n\nstatic void encode_nfs4_stateid(struct xdr_stream *xdr, const nfs4_stateid *stateid)\n{\n\tencode_opaque_fixed(xdr, stateid, NFS4_STATEID_SIZE);\n}\n\nstatic void encode_nfs4_verifier(struct xdr_stream *xdr, const nfs4_verifier *verf)\n{\n\tencode_opaque_fixed(xdr, verf->data, NFS4_VERIFIER_SIZE);\n}\n\nstatic __be32 *\nxdr_encode_nfstime4(__be32 *p, const struct timespec64 *t)\n{\n\tp = xdr_encode_hyper(p, t->tv_sec);\n\t*p++ = cpu_to_be32(t->tv_nsec);\n\treturn p;\n}\n\nstatic void encode_attrs(struct xdr_stream *xdr, const struct iattr *iap,\n\t\t\t\tconst struct nfs4_label *label,\n\t\t\t\tconst umode_t *umask,\n\t\t\t\tconst struct nfs_server *server,\n\t\t\t\tconst uint32_t attrmask[])\n{\n\tchar owner_name[IDMAP_NAMESZ];\n\tchar owner_group[IDMAP_NAMESZ];\n\tint owner_namelen = 0;\n\tint owner_grouplen = 0;\n\t__be32 *p;\n\tuint32_t len = 0;\n\tuint32_t bmval[3] = { 0 };\n\n\t/*\n\t * We reserve enough space to write the entire attribute buffer at once.\n\t */\n\tif ((iap->ia_valid & ATTR_SIZE) && (attrmask[0] & FATTR4_WORD0_SIZE)) {\n\t\tbmval[0] |= FATTR4_WORD0_SIZE;\n\t\tlen += 8;\n\t}\n\tif (iap->ia_valid & ATTR_MODE) {\n\t\tif (umask && (attrmask[2] & FATTR4_WORD2_MODE_UMASK)) {\n\t\t\tbmval[2] |= FATTR4_WORD2_MODE_UMASK;\n\t\t\tlen += 8;\n\t\t} else if (attrmask[1] & FATTR4_WORD1_MODE) {\n\t\t\tbmval[1] |= FATTR4_WORD1_MODE;\n\t\t\tlen += 4;\n\t\t}\n\t}\n\tif ((iap->ia_valid & ATTR_UID) && (attrmask[1] & FATTR4_WORD1_OWNER)) {\n\t\towner_namelen = nfs_map_uid_to_name(server, iap->ia_uid, owner_name, IDMAP_NAMESZ);\n\t\tif (owner_namelen < 0) {\n\t\t\tdprintk(\"nfs: couldn't resolve uid %d to string\\n\",\n\t\t\t\t\tfrom_kuid(&init_user_ns, iap->ia_uid));\n\t\t\t/* XXX */\n\t\t\tstrcpy(owner_name, \"nobody\");\n\t\t\towner_namelen = sizeof(\"nobody\") - 1;\n\t\t\t/* goto out; */\n\t\t}\n\t\tbmval[1] |= FATTR4_WORD1_OWNER;\n\t\tlen += 4 + (XDR_QUADLEN(owner_namelen) << 2);\n\t}\n\tif ((iap->ia_valid & ATTR_GID) &&\n\t   (attrmask[1] & FATTR4_WORD1_OWNER_GROUP)) {\n\t\towner_grouplen = nfs_map_gid_to_group(server, iap->ia_gid, owner_group, IDMAP_NAMESZ);\n\t\tif (owner_grouplen < 0) {\n\t\t\tdprintk(\"nfs: couldn't resolve gid %d to string\\n\",\n\t\t\t\t\tfrom_kgid(&init_user_ns, iap->ia_gid));\n\t\t\tstrcpy(owner_group, \"nobody\");\n\t\t\towner_grouplen = sizeof(\"nobody\") - 1;\n\t\t\t/* goto out; */\n\t\t}\n\t\tbmval[1] |= FATTR4_WORD1_OWNER_GROUP;\n\t\tlen += 4 + (XDR_QUADLEN(owner_grouplen) << 2);\n\t}\n\tif (attrmask[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tif (iap->ia_valid & ATTR_ATIME_SET) {\n\t\t\tbmval[1] |= FATTR4_WORD1_TIME_ACCESS_SET;\n\t\t\tlen += 4 + (nfstime4_maxsz << 2);\n\t\t} else if (iap->ia_valid & ATTR_ATIME) {\n\t\t\tbmval[1] |= FATTR4_WORD1_TIME_ACCESS_SET;\n\t\t\tlen += 4;\n\t\t}\n\t}\n\tif (attrmask[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tif (iap->ia_valid & ATTR_MTIME_SET) {\n\t\t\tbmval[1] |= FATTR4_WORD1_TIME_MODIFY_SET;\n\t\t\tlen += 4 + (nfstime4_maxsz << 2);\n\t\t} else if (iap->ia_valid & ATTR_MTIME) {\n\t\t\tbmval[1] |= FATTR4_WORD1_TIME_MODIFY_SET;\n\t\t\tlen += 4;\n\t\t}\n\t}\n\n\tif (label && (attrmask[2] & FATTR4_WORD2_SECURITY_LABEL)) {\n\t\tlen += 4 + 4 + 4 + (XDR_QUADLEN(label->len) << 2);\n\t\tbmval[2] |= FATTR4_WORD2_SECURITY_LABEL;\n\t}\n\n\txdr_encode_bitmap4(xdr, bmval, ARRAY_SIZE(bmval));\n\txdr_stream_encode_opaque_inline(xdr, (void **)&p, len);\n\n\tif (bmval[0] & FATTR4_WORD0_SIZE)\n\t\tp = xdr_encode_hyper(p, iap->ia_size);\n\tif (bmval[1] & FATTR4_WORD1_MODE)\n\t\t*p++ = cpu_to_be32(iap->ia_mode & S_IALLUGO);\n\tif (bmval[1] & FATTR4_WORD1_OWNER)\n\t\tp = xdr_encode_opaque(p, owner_name, owner_namelen);\n\tif (bmval[1] & FATTR4_WORD1_OWNER_GROUP)\n\t\tp = xdr_encode_opaque(p, owner_group, owner_grouplen);\n\tif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tif (iap->ia_valid & ATTR_ATIME_SET) {\n\t\t\t*p++ = cpu_to_be32(NFS4_SET_TO_CLIENT_TIME);\n\t\t\tp = xdr_encode_nfstime4(p, &iap->ia_atime);\n\t\t} else\n\t\t\t*p++ = cpu_to_be32(NFS4_SET_TO_SERVER_TIME);\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tif (iap->ia_valid & ATTR_MTIME_SET) {\n\t\t\t*p++ = cpu_to_be32(NFS4_SET_TO_CLIENT_TIME);\n\t\t\tp = xdr_encode_nfstime4(p, &iap->ia_mtime);\n\t\t} else\n\t\t\t*p++ = cpu_to_be32(NFS4_SET_TO_SERVER_TIME);\n\t}\n\tif (label && (bmval[2] & FATTR4_WORD2_SECURITY_LABEL)) {\n\t\t*p++ = cpu_to_be32(label->lfs);\n\t\t*p++ = cpu_to_be32(label->pi);\n\t\t*p++ = cpu_to_be32(label->len);\n\t\tp = xdr_encode_opaque_fixed(p, label->label, label->len);\n\t}\n\tif (bmval[2] & FATTR4_WORD2_MODE_UMASK) {\n\t\t*p++ = cpu_to_be32(iap->ia_mode & S_IALLUGO);\n\t\t*p++ = cpu_to_be32(*umask);\n\t}\n\n/* out: */\n}\n\nstatic void encode_access(struct xdr_stream *xdr, u32 access, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_ACCESS, decode_access_maxsz, hdr);\n\tencode_uint32(xdr, access);\n}\n\nstatic void encode_close(struct xdr_stream *xdr, const struct nfs_closeargs *arg, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_CLOSE, decode_close_maxsz, hdr);\n\tencode_nfs4_seqid(xdr, arg->seqid);\n\tencode_nfs4_stateid(xdr, &arg->stateid);\n}\n\nstatic void encode_commit(struct xdr_stream *xdr, const struct nfs_commitargs *args, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_COMMIT, decode_commit_maxsz, hdr);\n\tp = reserve_space(xdr, 12);\n\tp = xdr_encode_hyper(p, args->offset);\n\t*p = cpu_to_be32(args->count);\n}\n\nstatic void encode_create(struct xdr_stream *xdr, const struct nfs4_create_arg *create, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_CREATE, decode_create_maxsz, hdr);\n\tencode_uint32(xdr, create->ftype);\n\n\tswitch (create->ftype) {\n\tcase NF4LNK:\n\t\tp = reserve_space(xdr, 4);\n\t\t*p = cpu_to_be32(create->u.symlink.len);\n\t\txdr_write_pages(xdr, create->u.symlink.pages, 0,\n\t\t\t\tcreate->u.symlink.len);\n\t\txdr->buf->flags |= XDRBUF_WRITE;\n\t\tbreak;\n\n\tcase NF4BLK: case NF4CHR:\n\t\tp = reserve_space(xdr, 8);\n\t\t*p++ = cpu_to_be32(create->u.device.specdata1);\n\t\t*p = cpu_to_be32(create->u.device.specdata2);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tencode_string(xdr, create->name->len, create->name->name);\n\tencode_attrs(xdr, create->attrs, create->label, &create->umask,\n\t\t\tcreate->server, create->server->attr_bitmask);\n}\n\nstatic void encode_getattr(struct xdr_stream *xdr,\n\t\tconst __u32 *bitmap, const __u32 *mask, size_t len,\n\t\tstruct compound_hdr *hdr)\n{\n\t__u32 masked_bitmap[nfs4_fattr_bitmap_maxsz];\n\n\tencode_op_hdr(xdr, OP_GETATTR, decode_getattr_maxsz, hdr);\n\tif (mask) {\n\t\tif (WARN_ON_ONCE(len > ARRAY_SIZE(masked_bitmap)))\n\t\t\tlen = ARRAY_SIZE(masked_bitmap);\n\t\tlen = mask_bitmap4(bitmap, mask, masked_bitmap, len);\n\t\tbitmap = masked_bitmap;\n\t}\n\txdr_encode_bitmap4(xdr, bitmap, len);\n}\n\nstatic void encode_getfattr(struct xdr_stream *xdr, const u32* bitmask, struct compound_hdr *hdr)\n{\n\tencode_getattr(xdr, nfs4_fattr_bitmap, bitmask,\n\t\t\tARRAY_SIZE(nfs4_fattr_bitmap), hdr);\n}\n\nstatic void encode_getfattr_open(struct xdr_stream *xdr, const u32 *bitmask,\n\t\t\t\t const u32 *open_bitmap,\n\t\t\t\t struct compound_hdr *hdr)\n{\n\tencode_getattr(xdr, open_bitmap, bitmask, 3, hdr);\n}\n\nstatic void encode_fsinfo(struct xdr_stream *xdr, const u32* bitmask, struct compound_hdr *hdr)\n{\n\tencode_getattr(xdr, nfs4_fsinfo_bitmap, bitmask,\n\t\t\tARRAY_SIZE(nfs4_fsinfo_bitmap), hdr);\n}\n\nstatic void encode_fs_locations(struct xdr_stream *xdr, const u32* bitmask, struct compound_hdr *hdr)\n{\n\tencode_getattr(xdr, nfs4_fs_locations_bitmap, bitmask,\n\t\t\tARRAY_SIZE(nfs4_fs_locations_bitmap), hdr);\n}\n\nstatic void encode_getfh(struct xdr_stream *xdr, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_GETFH, decode_getfh_maxsz, hdr);\n}\n\nstatic void encode_link(struct xdr_stream *xdr, const struct qstr *name, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_LINK, decode_link_maxsz, hdr);\n\tencode_string(xdr, name->len, name->name);\n}\n\nstatic inline int nfs4_lock_type(struct file_lock *fl, int block)\n{\n\tif (fl->fl_type == F_RDLCK)\n\t\treturn block ? NFS4_READW_LT : NFS4_READ_LT;\n\treturn block ? NFS4_WRITEW_LT : NFS4_WRITE_LT;\n}\n\nstatic inline uint64_t nfs4_lock_length(struct file_lock *fl)\n{\n\tif (fl->fl_end == OFFSET_MAX)\n\t\treturn ~(uint64_t)0;\n\treturn fl->fl_end - fl->fl_start + 1;\n}\n\nstatic void encode_lockowner(struct xdr_stream *xdr, const struct nfs_lowner *lowner)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 32);\n\tp = xdr_encode_hyper(p, lowner->clientid);\n\t*p++ = cpu_to_be32(20);\n\tp = xdr_encode_opaque_fixed(p, \"lock id:\", 8);\n\t*p++ = cpu_to_be32(lowner->s_dev);\n\txdr_encode_hyper(p, lowner->id);\n}\n\n/*\n * opcode,type,reclaim,offset,length,new_lock_owner = 32\n * open_seqid,open_stateid,lock_seqid,lock_owner.clientid, lock_owner.id = 40\n */\nstatic void encode_lock(struct xdr_stream *xdr, const struct nfs_lock_args *args, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_LOCK, decode_lock_maxsz, hdr);\n\tp = reserve_space(xdr, 28);\n\t*p++ = cpu_to_be32(nfs4_lock_type(args->fl, args->block));\n\t*p++ = cpu_to_be32(args->reclaim);\n\tp = xdr_encode_hyper(p, args->fl->fl_start);\n\tp = xdr_encode_hyper(p, nfs4_lock_length(args->fl));\n\t*p = cpu_to_be32(args->new_lock_owner);\n\tif (args->new_lock_owner){\n\t\tencode_nfs4_seqid(xdr, args->open_seqid);\n\t\tencode_nfs4_stateid(xdr, &args->open_stateid);\n\t\tencode_nfs4_seqid(xdr, args->lock_seqid);\n\t\tencode_lockowner(xdr, &args->lock_owner);\n\t}\n\telse {\n\t\tencode_nfs4_stateid(xdr, &args->lock_stateid);\n\t\tencode_nfs4_seqid(xdr, args->lock_seqid);\n\t}\n}\n\nstatic void encode_lockt(struct xdr_stream *xdr, const struct nfs_lockt_args *args, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_LOCKT, decode_lockt_maxsz, hdr);\n\tp = reserve_space(xdr, 20);\n\t*p++ = cpu_to_be32(nfs4_lock_type(args->fl, 0));\n\tp = xdr_encode_hyper(p, args->fl->fl_start);\n\tp = xdr_encode_hyper(p, nfs4_lock_length(args->fl));\n\tencode_lockowner(xdr, &args->lock_owner);\n}\n\nstatic void encode_locku(struct xdr_stream *xdr, const struct nfs_locku_args *args, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_LOCKU, decode_locku_maxsz, hdr);\n\tencode_uint32(xdr, nfs4_lock_type(args->fl, 0));\n\tencode_nfs4_seqid(xdr, args->seqid);\n\tencode_nfs4_stateid(xdr, &args->stateid);\n\tp = reserve_space(xdr, 16);\n\tp = xdr_encode_hyper(p, args->fl->fl_start);\n\txdr_encode_hyper(p, nfs4_lock_length(args->fl));\n}\n\nstatic void encode_release_lockowner(struct xdr_stream *xdr, const struct nfs_lowner *lowner, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_RELEASE_LOCKOWNER, decode_release_lockowner_maxsz, hdr);\n\tencode_lockowner(xdr, lowner);\n}\n\nstatic void encode_lookup(struct xdr_stream *xdr, const struct qstr *name, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_LOOKUP, decode_lookup_maxsz, hdr);\n\tencode_string(xdr, name->len, name->name);\n}\n\nstatic void encode_lookupp(struct xdr_stream *xdr, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_LOOKUPP, decode_lookupp_maxsz, hdr);\n}\n\nstatic void encode_share_access(struct xdr_stream *xdr, u32 share_access)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 8);\n\t*p++ = cpu_to_be32(share_access);\n\t*p = cpu_to_be32(0);\t\t/* for linux, share_deny = 0 always */\n}\n\nstatic inline void encode_openhdr(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n /*\n * opcode 4, seqid 4, share_access 4, share_deny 4, clientid 8, ownerlen 4,\n * owner 4 = 32\n */\n\tencode_nfs4_seqid(xdr, arg->seqid);\n\tencode_share_access(xdr, arg->share_access);\n\tp = reserve_space(xdr, 36);\n\tp = xdr_encode_hyper(p, arg->clientid);\n\t*p++ = cpu_to_be32(24);\n\tp = xdr_encode_opaque_fixed(p, \"open id:\", 8);\n\t*p++ = cpu_to_be32(arg->server->s_dev);\n\t*p++ = cpu_to_be32(arg->id.uniquifier);\n\txdr_encode_hyper(p, arg->id.create_time);\n}\n\nstatic inline void encode_createmode(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 4);\n\tswitch(arg->createmode) {\n\tcase NFS4_CREATE_UNCHECKED:\n\t\t*p = cpu_to_be32(NFS4_CREATE_UNCHECKED);\n\t\tencode_attrs(xdr, arg->u.attrs, arg->label, &arg->umask,\n\t\t\t\targ->server, arg->server->attr_bitmask);\n\t\tbreak;\n\tcase NFS4_CREATE_GUARDED:\n\t\t*p = cpu_to_be32(NFS4_CREATE_GUARDED);\n\t\tencode_attrs(xdr, arg->u.attrs, arg->label, &arg->umask,\n\t\t\t\targ->server, arg->server->attr_bitmask);\n\t\tbreak;\n\tcase NFS4_CREATE_EXCLUSIVE:\n\t\t*p = cpu_to_be32(NFS4_CREATE_EXCLUSIVE);\n\t\tencode_nfs4_verifier(xdr, &arg->u.verifier);\n\t\tbreak;\n\tcase NFS4_CREATE_EXCLUSIVE4_1:\n\t\t*p = cpu_to_be32(NFS4_CREATE_EXCLUSIVE4_1);\n\t\tencode_nfs4_verifier(xdr, &arg->u.verifier);\n\t\tencode_attrs(xdr, arg->u.attrs, arg->label, &arg->umask,\n\t\t\t\targ->server, arg->server->exclcreat_bitmask);\n\t}\n}\n\nstatic void encode_opentype(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 4);\n\tswitch (arg->open_flags & O_CREAT) {\n\tcase 0:\n\t\t*p = cpu_to_be32(NFS4_OPEN_NOCREATE);\n\t\tbreak;\n\tdefault:\n\t\t*p = cpu_to_be32(NFS4_OPEN_CREATE);\n\t\tencode_createmode(xdr, arg);\n\t}\n}\n\nstatic inline void encode_delegation_type(struct xdr_stream *xdr, fmode_t delegation_type)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 4);\n\tswitch (delegation_type) {\n\tcase 0:\n\t\t*p = cpu_to_be32(NFS4_OPEN_DELEGATE_NONE);\n\t\tbreak;\n\tcase FMODE_READ:\n\t\t*p = cpu_to_be32(NFS4_OPEN_DELEGATE_READ);\n\t\tbreak;\n\tcase FMODE_WRITE|FMODE_READ:\n\t\t*p = cpu_to_be32(NFS4_OPEN_DELEGATE_WRITE);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic inline void encode_claim_null(struct xdr_stream *xdr, const struct qstr *name)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 4);\n\t*p = cpu_to_be32(NFS4_OPEN_CLAIM_NULL);\n\tencode_string(xdr, name->len, name->name);\n}\n\nstatic inline void encode_claim_previous(struct xdr_stream *xdr, fmode_t type)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 4);\n\t*p = cpu_to_be32(NFS4_OPEN_CLAIM_PREVIOUS);\n\tencode_delegation_type(xdr, type);\n}\n\nstatic inline void encode_claim_delegate_cur(struct xdr_stream *xdr, const struct qstr *name, const nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 4);\n\t*p = cpu_to_be32(NFS4_OPEN_CLAIM_DELEGATE_CUR);\n\tencode_nfs4_stateid(xdr, stateid);\n\tencode_string(xdr, name->len, name->name);\n}\n\nstatic inline void encode_claim_fh(struct xdr_stream *xdr)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 4);\n\t*p = cpu_to_be32(NFS4_OPEN_CLAIM_FH);\n}\n\nstatic inline void encode_claim_delegate_cur_fh(struct xdr_stream *xdr, const nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 4);\n\t*p = cpu_to_be32(NFS4_OPEN_CLAIM_DELEG_CUR_FH);\n\tencode_nfs4_stateid(xdr, stateid);\n}\n\nstatic void encode_open(struct xdr_stream *xdr, const struct nfs_openargs *arg, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_OPEN, decode_open_maxsz, hdr);\n\tencode_openhdr(xdr, arg);\n\tencode_opentype(xdr, arg);\n\tswitch (arg->claim) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\t\tencode_claim_null(xdr, arg->name);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\tencode_claim_previous(xdr, arg->u.delegation_type);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\t\tencode_claim_delegate_cur(xdr, arg->name, &arg->u.delegation);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_FH:\n\t\tencode_claim_fh(xdr);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\t\tencode_claim_delegate_cur_fh(xdr, &arg->u.delegation);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic void encode_open_confirm(struct xdr_stream *xdr, const struct nfs_open_confirmargs *arg, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_OPEN_CONFIRM, decode_open_confirm_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, arg->stateid);\n\tencode_nfs4_seqid(xdr, arg->seqid);\n}\n\nstatic void encode_open_downgrade(struct xdr_stream *xdr, const struct nfs_closeargs *arg, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_OPEN_DOWNGRADE, decode_open_downgrade_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &arg->stateid);\n\tencode_nfs4_seqid(xdr, arg->seqid);\n\tencode_share_access(xdr, arg->share_access);\n}\n\nstatic void\nencode_putfh(struct xdr_stream *xdr, const struct nfs_fh *fh, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_PUTFH, decode_putfh_maxsz, hdr);\n\tencode_string(xdr, fh->size, fh->data);\n}\n\nstatic void encode_putrootfh(struct xdr_stream *xdr, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_PUTROOTFH, decode_putrootfh_maxsz, hdr);\n}\n\nstatic void encode_read(struct xdr_stream *xdr, const struct nfs_pgio_args *args,\n\t\t\tstruct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_READ, decode_read_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &args->stateid);\n\n\tp = reserve_space(xdr, 12);\n\tp = xdr_encode_hyper(p, args->offset);\n\t*p = cpu_to_be32(args->count);\n}\n\nstatic void encode_readdir(struct xdr_stream *xdr, const struct nfs4_readdir_arg *readdir, struct rpc_rqst *req, struct compound_hdr *hdr)\n{\n\tuint32_t attrs[3] = {\n\t\tFATTR4_WORD0_RDATTR_ERROR,\n\t\tFATTR4_WORD1_MOUNTED_ON_FILEID,\n\t};\n\tuint32_t dircount = readdir->count >> 1;\n\t__be32 *p, verf[2];\n\tuint32_t attrlen = 0;\n\tunsigned int i;\n\n\tif (readdir->plus) {\n\t\tattrs[0] |= FATTR4_WORD0_TYPE|FATTR4_WORD0_CHANGE|FATTR4_WORD0_SIZE|\n\t\t\tFATTR4_WORD0_FSID|FATTR4_WORD0_FILEHANDLE|FATTR4_WORD0_FILEID;\n\t\tattrs[1] |= FATTR4_WORD1_MODE|FATTR4_WORD1_NUMLINKS|FATTR4_WORD1_OWNER|\n\t\t\tFATTR4_WORD1_OWNER_GROUP|FATTR4_WORD1_RAWDEV|\n\t\t\tFATTR4_WORD1_SPACE_USED|FATTR4_WORD1_TIME_ACCESS|\n\t\t\tFATTR4_WORD1_TIME_METADATA|FATTR4_WORD1_TIME_MODIFY;\n\t\tattrs[2] |= FATTR4_WORD2_SECURITY_LABEL;\n\t\tdircount >>= 1;\n\t}\n\t/* Use mounted_on_fileid only if the server supports it */\n\tif (!(readdir->bitmask[1] & FATTR4_WORD1_MOUNTED_ON_FILEID))\n\t\tattrs[0] |= FATTR4_WORD0_FILEID;\n\tfor (i = 0; i < ARRAY_SIZE(attrs); i++) {\n\t\tattrs[i] &= readdir->bitmask[i];\n\t\tif (attrs[i] != 0)\n\t\t\tattrlen = i+1;\n\t}\n\n\tencode_op_hdr(xdr, OP_READDIR, decode_readdir_maxsz, hdr);\n\tencode_uint64(xdr, readdir->cookie);\n\tencode_nfs4_verifier(xdr, &readdir->verifier);\n\tp = reserve_space(xdr, 12 + (attrlen << 2));\n\t*p++ = cpu_to_be32(dircount);\n\t*p++ = cpu_to_be32(readdir->count);\n\t*p++ = cpu_to_be32(attrlen);\n\tfor (i = 0; i < attrlen; i++)\n\t\t*p++ = cpu_to_be32(attrs[i]);\n\tmemcpy(verf, readdir->verifier.data, sizeof(verf));\n\n\tdprintk(\"%s: cookie = %llu, verifier = %08x:%08x, bitmap = %08x:%08x:%08x\\n\",\n\t\t\t__func__,\n\t\t\t(unsigned long long)readdir->cookie,\n\t\t\tverf[0], verf[1],\n\t\t\tattrs[0] & readdir->bitmask[0],\n\t\t\tattrs[1] & readdir->bitmask[1],\n\t\t\tattrs[2] & readdir->bitmask[2]);\n}\n\nstatic void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_READLINK, decode_readlink_maxsz, hdr);\n}\n\nstatic void encode_remove(struct xdr_stream *xdr, const struct qstr *name, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_REMOVE, decode_remove_maxsz, hdr);\n\tencode_string(xdr, name->len, name->name);\n}\n\nstatic void encode_rename(struct xdr_stream *xdr, const struct qstr *oldname, const struct qstr *newname, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_RENAME, decode_rename_maxsz, hdr);\n\tencode_string(xdr, oldname->len, oldname->name);\n\tencode_string(xdr, newname->len, newname->name);\n}\n\nstatic void encode_renew(struct xdr_stream *xdr, clientid4 clid,\n\t\t\t struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_RENEW, decode_renew_maxsz, hdr);\n\tencode_uint64(xdr, clid);\n}\n\nstatic void\nencode_restorefh(struct xdr_stream *xdr, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_RESTOREFH, decode_restorefh_maxsz, hdr);\n}\n\nstatic void\nencode_setacl(struct xdr_stream *xdr, const struct nfs_setaclargs *arg,\n\t\tstruct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_SETATTR, decode_setacl_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &zero_stateid);\n\tp = reserve_space(xdr, 2*4);\n\t*p++ = cpu_to_be32(1);\n\t*p = cpu_to_be32(FATTR4_WORD0_ACL);\n\tp = reserve_space(xdr, 4);\n\t*p = cpu_to_be32(arg->acl_len);\n\txdr_write_pages(xdr, arg->acl_pages, 0, arg->acl_len);\n}\n\nstatic void\nencode_savefh(struct xdr_stream *xdr, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_SAVEFH, decode_savefh_maxsz, hdr);\n}\n\nstatic void encode_setattr(struct xdr_stream *xdr, const struct nfs_setattrargs *arg, const struct nfs_server *server, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_SETATTR, decode_setattr_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &arg->stateid);\n\tencode_attrs(xdr, arg->iap, arg->label, NULL, server,\n\t\t\tserver->attr_bitmask);\n}\n\nstatic void encode_setclientid(struct xdr_stream *xdr, const struct nfs4_setclientid *setclientid, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_SETCLIENTID, decode_setclientid_maxsz, hdr);\n\tencode_nfs4_verifier(xdr, setclientid->sc_verifier);\n\n\tencode_string(xdr, strlen(setclientid->sc_clnt->cl_owner_id),\n\t\t\tsetclientid->sc_clnt->cl_owner_id);\n\tp = reserve_space(xdr, 4);\n\t*p = cpu_to_be32(setclientid->sc_prog);\n\tencode_string(xdr, setclientid->sc_netid_len, setclientid->sc_netid);\n\tencode_string(xdr, setclientid->sc_uaddr_len, setclientid->sc_uaddr);\n\tp = reserve_space(xdr, 4);\n\t*p = cpu_to_be32(setclientid->sc_clnt->cl_cb_ident);\n}\n\nstatic void encode_setclientid_confirm(struct xdr_stream *xdr, const struct nfs4_setclientid_res *arg, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_SETCLIENTID_CONFIRM,\n\t\t\tdecode_setclientid_confirm_maxsz, hdr);\n\tencode_uint64(xdr, arg->clientid);\n\tencode_nfs4_verifier(xdr, &arg->confirm);\n}\n\nstatic void encode_write(struct xdr_stream *xdr, const struct nfs_pgio_args *args,\n\t\t\t struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_WRITE, decode_write_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &args->stateid);\n\n\tp = reserve_space(xdr, 16);\n\tp = xdr_encode_hyper(p, args->offset);\n\t*p++ = cpu_to_be32(args->stable);\n\t*p = cpu_to_be32(args->count);\n\n\txdr_write_pages(xdr, args->pages, args->pgbase, args->count);\n}\n\nstatic void encode_delegreturn(struct xdr_stream *xdr, const nfs4_stateid *stateid, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_DELEGRETURN, decode_delegreturn_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, stateid);\n}\n\nstatic void encode_secinfo(struct xdr_stream *xdr, const struct qstr *name, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_SECINFO, decode_secinfo_maxsz, hdr);\n\tencode_string(xdr, name->len, name->name);\n}\n\n#if defined(CONFIG_NFS_V4_1)\n/* NFSv4.1 operations */\nstatic void encode_bind_conn_to_session(struct xdr_stream *xdr,\n\t\t\t\t   const struct nfs41_bind_conn_to_session_args *args,\n\t\t\t\t   struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_BIND_CONN_TO_SESSION,\n\t\tdecode_bind_conn_to_session_maxsz, hdr);\n\tencode_opaque_fixed(xdr, args->sessionid.data, NFS4_MAX_SESSIONID_LEN);\n\tp = xdr_reserve_space(xdr, 8);\n\t*p++ = cpu_to_be32(args->dir);\n\t*p = (args->use_conn_in_rdma_mode) ? cpu_to_be32(1) : cpu_to_be32(0);\n}\n\nstatic void encode_op_map(struct xdr_stream *xdr, const struct nfs4_op_map *op_map)\n{\n\tunsigned int i;\n\tencode_uint32(xdr, NFS4_OP_MAP_NUM_WORDS);\n\tfor (i = 0; i < NFS4_OP_MAP_NUM_WORDS; i++)\n\t\tencode_uint32(xdr, op_map->u.words[i]);\n}\n\nstatic void encode_exchange_id(struct xdr_stream *xdr,\n\t\t\t       const struct nfs41_exchange_id_args *args,\n\t\t\t       struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\tchar impl_name[IMPL_NAME_LIMIT];\n\tint len = 0;\n\n\tencode_op_hdr(xdr, OP_EXCHANGE_ID, decode_exchange_id_maxsz, hdr);\n\tencode_nfs4_verifier(xdr, &args->verifier);\n\n\tencode_string(xdr, strlen(args->client->cl_owner_id),\n\t\t\targs->client->cl_owner_id);\n\n\tencode_uint32(xdr, args->flags);\n\tencode_uint32(xdr, args->state_protect.how);\n\n\tswitch (args->state_protect.how) {\n\tcase SP4_NONE:\n\t\tbreak;\n\tcase SP4_MACH_CRED:\n\t\tencode_op_map(xdr, &args->state_protect.enforce);\n\t\tencode_op_map(xdr, &args->state_protect.allow);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\tif (send_implementation_id &&\n\t    sizeof(CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN) > 1 &&\n\t    sizeof(CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN)\n\t\t<= sizeof(impl_name) + 1)\n\t\tlen = snprintf(impl_name, sizeof(impl_name), \"%s %s %s %s\",\n\t\t\t       utsname()->sysname, utsname()->release,\n\t\t\t       utsname()->version, utsname()->machine);\n\n\tif (len > 0) {\n\t\tencode_uint32(xdr, 1);\t/* implementation id array length=1 */\n\n\t\tencode_string(xdr,\n\t\t\tsizeof(CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN) - 1,\n\t\t\tCONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN);\n\t\tencode_string(xdr, len, impl_name);\n\t\t/* just send zeros for nii_date - the date is in nii_name */\n\t\tp = reserve_space(xdr, 12);\n\t\tp = xdr_encode_hyper(p, 0);\n\t\t*p = cpu_to_be32(0);\n\t} else\n\t\tencode_uint32(xdr, 0);\t/* implementation id array length=0 */\n}\n\nstatic void encode_create_session(struct xdr_stream *xdr,\n\t\t\t\t  const struct nfs41_create_session_args *args,\n\t\t\t\t  struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\tstruct nfs_client *clp = args->client;\n\tstruct rpc_clnt *clnt = clp->cl_rpcclient;\n\tstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\n\tu32 max_resp_sz_cached;\n\n\t/*\n\t * Assumes OPEN is the biggest non-idempotent compound.\n\t * 2 is the verifier.\n\t */\n\tmax_resp_sz_cached = (NFS4_dec_open_sz + RPC_REPHDRSIZE + 2)\n\t\t\t\t* XDR_UNIT + RPC_MAX_AUTH_SIZE;\n\n\tencode_op_hdr(xdr, OP_CREATE_SESSION, decode_create_session_maxsz, hdr);\n\tp = reserve_space(xdr, 16 + 2*28 + 20 + clnt->cl_nodelen + 12);\n\tp = xdr_encode_hyper(p, args->clientid);\n\t*p++ = cpu_to_be32(args->seqid);\t\t\t/*Sequence id */\n\t*p++ = cpu_to_be32(args->flags);\t\t\t/*flags */\n\n\t/* Fore Channel */\n\t*p++ = cpu_to_be32(0);\t\t\t\t/* header padding size */\n\t*p++ = cpu_to_be32(args->fc_attrs.max_rqst_sz);\t/* max req size */\n\t*p++ = cpu_to_be32(args->fc_attrs.max_resp_sz);\t/* max resp size */\n\t*p++ = cpu_to_be32(max_resp_sz_cached);\t\t/* Max resp sz cached */\n\t*p++ = cpu_to_be32(args->fc_attrs.max_ops);\t/* max operations */\n\t*p++ = cpu_to_be32(args->fc_attrs.max_reqs);\t/* max requests */\n\t*p++ = cpu_to_be32(0);\t\t\t\t/* rdmachannel_attrs */\n\n\t/* Back Channel */\n\t*p++ = cpu_to_be32(0);\t\t\t\t/* header padding size */\n\t*p++ = cpu_to_be32(args->bc_attrs.max_rqst_sz);\t/* max req size */\n\t*p++ = cpu_to_be32(args->bc_attrs.max_resp_sz);\t/* max resp size */\n\t*p++ = cpu_to_be32(args->bc_attrs.max_resp_sz_cached);\t/* Max resp sz cached */\n\t*p++ = cpu_to_be32(args->bc_attrs.max_ops);\t/* max operations */\n\t*p++ = cpu_to_be32(args->bc_attrs.max_reqs);\t/* max requests */\n\t*p++ = cpu_to_be32(0);\t\t\t\t/* rdmachannel_attrs */\n\n\t*p++ = cpu_to_be32(args->cb_program);\t\t/* cb_program */\n\t*p++ = cpu_to_be32(1);\n\t*p++ = cpu_to_be32(RPC_AUTH_UNIX);\t\t\t/* auth_sys */\n\n\t/* authsys_parms rfc1831 */\n\t*p++ = cpu_to_be32(ktime_to_ns(nn->boot_time));\t/* stamp */\n\tp = xdr_encode_array(p, clnt->cl_nodename, clnt->cl_nodelen);\n\t*p++ = cpu_to_be32(0);\t\t\t\t/* UID */\n\t*p++ = cpu_to_be32(0);\t\t\t\t/* GID */\n\t*p = cpu_to_be32(0);\t\t\t\t/* No more gids */\n}\n\nstatic void encode_destroy_session(struct xdr_stream *xdr,\n\t\t\t\t   const struct nfs4_session *session,\n\t\t\t\t   struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_DESTROY_SESSION, decode_destroy_session_maxsz, hdr);\n\tencode_opaque_fixed(xdr, session->sess_id.data, NFS4_MAX_SESSIONID_LEN);\n}\n\nstatic void encode_destroy_clientid(struct xdr_stream *xdr,\n\t\t\t\t   uint64_t clientid,\n\t\t\t\t   struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_DESTROY_CLIENTID, decode_destroy_clientid_maxsz, hdr);\n\tencode_uint64(xdr, clientid);\n}\n\nstatic void encode_reclaim_complete(struct xdr_stream *xdr,\n\t\t\t\t    const struct nfs41_reclaim_complete_args *args,\n\t\t\t\t    struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_RECLAIM_COMPLETE, decode_reclaim_complete_maxsz, hdr);\n\tencode_uint32(xdr, args->one_fs);\n}\n#endif /* CONFIG_NFS_V4_1 */\n\nstatic void encode_sequence(struct xdr_stream *xdr,\n\t\t\t    const struct nfs4_sequence_args *args,\n\t\t\t    struct compound_hdr *hdr)\n{\n#if defined(CONFIG_NFS_V4_1)\n\tstruct nfs4_session *session;\n\tstruct nfs4_slot_table *tp;\n\tstruct nfs4_slot *slot = args->sa_slot;\n\t__be32 *p;\n\n\ttp = slot->table;\n\tsession = tp->session;\n\tif (!session)\n\t\treturn;\n\n\tencode_op_hdr(xdr, OP_SEQUENCE, decode_sequence_maxsz, hdr);\n\n\t/*\n\t * Sessionid + seqid + slotid + max slotid + cache_this\n\t */\n\tdprintk(\"%s: sessionid=%u:%u:%u:%u seqid=%d slotid=%d \"\n\t\t\"max_slotid=%d cache_this=%d\\n\",\n\t\t__func__,\n\t\t((u32 *)session->sess_id.data)[0],\n\t\t((u32 *)session->sess_id.data)[1],\n\t\t((u32 *)session->sess_id.data)[2],\n\t\t((u32 *)session->sess_id.data)[3],\n\t\tslot->seq_nr, slot->slot_nr,\n\t\ttp->highest_used_slotid, args->sa_cache_this);\n\tp = reserve_space(xdr, NFS4_MAX_SESSIONID_LEN + 16);\n\tp = xdr_encode_opaque_fixed(p, session->sess_id.data, NFS4_MAX_SESSIONID_LEN);\n\t*p++ = cpu_to_be32(slot->seq_nr);\n\t*p++ = cpu_to_be32(slot->slot_nr);\n\t*p++ = cpu_to_be32(tp->highest_used_slotid);\n\t*p = cpu_to_be32(args->sa_cache_this);\n#endif /* CONFIG_NFS_V4_1 */\n}\n\n#ifdef CONFIG_NFS_V4_1\nstatic void\nencode_getdeviceinfo(struct xdr_stream *xdr,\n\t\t     const struct nfs4_getdeviceinfo_args *args,\n\t\t     struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_GETDEVICEINFO, decode_getdeviceinfo_maxsz, hdr);\n\tp = reserve_space(xdr, NFS4_DEVICEID4_SIZE + 4 + 4);\n\tp = xdr_encode_opaque_fixed(p, args->pdev->dev_id.data,\n\t\t\t\t    NFS4_DEVICEID4_SIZE);\n\t*p++ = cpu_to_be32(args->pdev->layout_type);\n\t*p++ = cpu_to_be32(args->pdev->maxcount);\t/* gdia_maxcount */\n\n\tp = reserve_space(xdr, 4 + 4);\n\t*p++ = cpu_to_be32(1);\t\t\t/* bitmap length */\n\t*p++ = cpu_to_be32(args->notify_types);\n}\n\nstatic void\nencode_layoutget(struct xdr_stream *xdr,\n\t\t      const struct nfs4_layoutget_args *args,\n\t\t      struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_LAYOUTGET, decode_layoutget_maxsz, hdr);\n\tp = reserve_space(xdr, 36);\n\t*p++ = cpu_to_be32(0);     /* Signal layout available */\n\t*p++ = cpu_to_be32(args->type);\n\t*p++ = cpu_to_be32(args->range.iomode);\n\tp = xdr_encode_hyper(p, args->range.offset);\n\tp = xdr_encode_hyper(p, args->range.length);\n\tp = xdr_encode_hyper(p, args->minlength);\n\tencode_nfs4_stateid(xdr, &args->stateid);\n\tencode_uint32(xdr, args->maxcount);\n\n\tdprintk(\"%s: 1st type:0x%x iomode:%d off:%lu len:%lu mc:%d\\n\",\n\t\t__func__,\n\t\targs->type,\n\t\targs->range.iomode,\n\t\t(unsigned long)args->range.offset,\n\t\t(unsigned long)args->range.length,\n\t\targs->maxcount);\n}\n\nstatic int\nencode_layoutcommit(struct xdr_stream *xdr,\n\t\t    struct inode *inode,\n\t\t    const struct nfs4_layoutcommit_args *args,\n\t\t    struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tdprintk(\"%s: lbw: %llu type: %d\\n\", __func__, args->lastbytewritten,\n\t\tNFS_SERVER(args->inode)->pnfs_curr_ld->id);\n\n\tencode_op_hdr(xdr, OP_LAYOUTCOMMIT, decode_layoutcommit_maxsz, hdr);\n\tp = reserve_space(xdr, 20);\n\t/* Only whole file layouts */\n\tp = xdr_encode_hyper(p, 0); /* offset */\n\tp = xdr_encode_hyper(p, args->lastbytewritten + 1);\t/* length */\n\t*p = cpu_to_be32(0); /* reclaim */\n\tencode_nfs4_stateid(xdr, &args->stateid);\n\tif (args->lastbytewritten != U64_MAX) {\n\t\tp = reserve_space(xdr, 20);\n\t\t*p++ = cpu_to_be32(1); /* newoffset = TRUE */\n\t\tp = xdr_encode_hyper(p, args->lastbytewritten);\n\t} else {\n\t\tp = reserve_space(xdr, 12);\n\t\t*p++ = cpu_to_be32(0); /* newoffset = FALSE */\n\t}\n\t*p++ = cpu_to_be32(0); /* Never send time_modify_changed */\n\t*p++ = cpu_to_be32(NFS_SERVER(args->inode)->pnfs_curr_ld->id);/* type */\n\n\tencode_uint32(xdr, args->layoutupdate_len);\n\tif (args->layoutupdate_pages)\n\t\txdr_write_pages(xdr, args->layoutupdate_pages, 0,\n\t\t\t\targs->layoutupdate_len);\n\n\treturn 0;\n}\n\nstatic void\nencode_layoutreturn(struct xdr_stream *xdr,\n\t\t    const struct nfs4_layoutreturn_args *args,\n\t\t    struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_op_hdr(xdr, OP_LAYOUTRETURN, decode_layoutreturn_maxsz, hdr);\n\tp = reserve_space(xdr, 16);\n\t*p++ = cpu_to_be32(0);\t\t/* reclaim. always 0 for now */\n\t*p++ = cpu_to_be32(args->layout_type);\n\t*p++ = cpu_to_be32(args->range.iomode);\n\t*p = cpu_to_be32(RETURN_FILE);\n\tp = reserve_space(xdr, 16);\n\tp = xdr_encode_hyper(p, args->range.offset);\n\tp = xdr_encode_hyper(p, args->range.length);\n\tspin_lock(&args->inode->i_lock);\n\tencode_nfs4_stateid(xdr, &args->stateid);\n\tspin_unlock(&args->inode->i_lock);\n\tif (args->ld_private->ops && args->ld_private->ops->encode)\n\t\targs->ld_private->ops->encode(xdr, args, args->ld_private);\n\telse\n\t\tencode_uint32(xdr, 0);\n}\n\nstatic int\nencode_secinfo_no_name(struct xdr_stream *xdr,\n\t\t       const struct nfs41_secinfo_no_name_args *args,\n\t\t       struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_SECINFO_NO_NAME, decode_secinfo_no_name_maxsz, hdr);\n\tencode_uint32(xdr, args->style);\n\treturn 0;\n}\n\nstatic void encode_test_stateid(struct xdr_stream *xdr,\n\t\t\t\tconst struct nfs41_test_stateid_args *args,\n\t\t\t\tstruct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_TEST_STATEID, decode_test_stateid_maxsz, hdr);\n\tencode_uint32(xdr, 1);\n\tencode_nfs4_stateid(xdr, args->stateid);\n}\n\nstatic void encode_free_stateid(struct xdr_stream *xdr,\n\t\t\t\tconst struct nfs41_free_stateid_args *args,\n\t\t\t\tstruct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_FREE_STATEID, decode_free_stateid_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &args->stateid);\n}\n#else\nstatic inline void\nencode_layoutreturn(struct xdr_stream *xdr,\n\t\t    const struct nfs4_layoutreturn_args *args,\n\t\t    struct compound_hdr *hdr)\n{\n}\n\nstatic void\nencode_layoutget(struct xdr_stream *xdr,\n\t\t      const struct nfs4_layoutget_args *args,\n\t\t      struct compound_hdr *hdr)\n{\n}\n#endif /* CONFIG_NFS_V4_1 */\n\n/*\n * END OF \"GENERIC\" ENCODE ROUTINES.\n */\n\nstatic u32 nfs4_xdr_minorversion(const struct nfs4_sequence_args *args)\n{\n#if defined(CONFIG_NFS_V4_1)\n\tstruct nfs4_session *session = args->sa_slot->table->session;\n\tif (session)\n\t\treturn session->clp->cl_mvops->minor_version;\n#endif /* CONFIG_NFS_V4_1 */\n\treturn 0;\n}\n\n/*\n * Encode an ACCESS request\n */\nstatic void nfs4_xdr_enc_access(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs4_accessargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_access(xdr, args->access, &hdr);\n\tif (args->bitmask)\n\t\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode LOOKUP request\n */\nstatic void nfs4_xdr_enc_lookup(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs4_lookup_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->dir_fh, &hdr);\n\tencode_lookup(xdr, args->name, &hdr);\n\tencode_getfh(xdr, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode LOOKUPP request\n */\nstatic void nfs4_xdr_enc_lookupp(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\tconst void *data)\n{\n\tconst struct nfs4_lookupp_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_lookupp(xdr, &hdr);\n\tencode_getfh(xdr, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode LOOKUP_ROOT request\n */\nstatic void nfs4_xdr_enc_lookup_root(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs4_lookup_root_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putrootfh(xdr, &hdr);\n\tencode_getfh(xdr, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode REMOVE request\n */\nstatic void nfs4_xdr_enc_remove(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs_removeargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_remove(xdr, &args->name, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode RENAME request\n */\nstatic void nfs4_xdr_enc_rename(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs_renameargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->old_dir, &hdr);\n\tencode_savefh(xdr, &hdr);\n\tencode_putfh(xdr, args->new_dir, &hdr);\n\tencode_rename(xdr, args->old_name, args->new_name, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode LINK request\n */\nstatic void nfs4_xdr_enc_link(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t      const void *data)\n{\n\tconst struct nfs4_link_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_savefh(xdr, &hdr);\n\tencode_putfh(xdr, args->dir_fh, &hdr);\n\tencode_link(xdr, args->name, &hdr);\n\tencode_restorefh(xdr, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode CREATE request\n */\nstatic void nfs4_xdr_enc_create(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs4_create_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->dir_fh, &hdr);\n\tencode_create(xdr, args, &hdr);\n\tencode_getfh(xdr, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode SYMLINK request\n */\nstatic void nfs4_xdr_enc_symlink(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t const void *data)\n{\n\tconst struct nfs4_create_arg *args = data;\n\n\tnfs4_xdr_enc_create(req, xdr, args);\n}\n\n/*\n * Encode GETATTR request\n */\nstatic void nfs4_xdr_enc_getattr(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t const void *data)\n{\n\tconst struct nfs4_getattr_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode a CLOSE request\n */\nstatic void nfs4_xdr_enc_close(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t       const void *data)\n{\n\tconst struct nfs_closeargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tif (args->lr_args)\n\t\tencode_layoutreturn(xdr, args->lr_args, &hdr);\n\tif (args->bitmask != NULL)\n\t\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_close(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode an OPEN request\n */\nstatic void nfs4_xdr_enc_open(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t      const void *data)\n{\n\tconst struct nfs_openargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_open(xdr, args, &hdr);\n\tencode_getfh(xdr, &hdr);\n\tif (args->access)\n\t\tencode_access(xdr, args->access, &hdr);\n\tencode_getfattr_open(xdr, args->bitmask, args->open_bitmap, &hdr);\n\tif (args->lg_args) {\n\t\tencode_layoutget(xdr, args->lg_args, &hdr);\n\t\trpc_prepare_reply_pages(req, args->lg_args->layout.pages, 0,\n\t\t\t\t\targs->lg_args->layout.pglen,\n\t\t\t\t\thdr.replen);\n\t}\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode an OPEN_CONFIRM request\n */\nstatic void nfs4_xdr_enc_open_confirm(struct rpc_rqst *req,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      const void *data)\n{\n\tconst struct nfs_open_confirmargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.nops   = 0,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_open_confirm(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode an OPEN request with no attributes.\n */\nstatic void nfs4_xdr_enc_open_noattr(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs_openargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_open(xdr, args, &hdr);\n\tif (args->access)\n\t\tencode_access(xdr, args->access, &hdr);\n\tencode_getfattr_open(xdr, args->bitmask, args->open_bitmap, &hdr);\n\tif (args->lg_args) {\n\t\tencode_layoutget(xdr, args->lg_args, &hdr);\n\t\trpc_prepare_reply_pages(req, args->lg_args->layout.pages, 0,\n\t\t\t\t\targs->lg_args->layout.pglen,\n\t\t\t\t\thdr.replen);\n\t}\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode an OPEN_DOWNGRADE request\n */\nstatic void nfs4_xdr_enc_open_downgrade(struct rpc_rqst *req,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tconst void *data)\n{\n\tconst struct nfs_closeargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tif (args->lr_args)\n\t\tencode_layoutreturn(xdr, args->lr_args, &hdr);\n\tencode_open_downgrade(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode a LOCK request\n */\nstatic void nfs4_xdr_enc_lock(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t      const void *data)\n{\n\tconst struct nfs_lock_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_lock(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode a LOCKT request\n */\nstatic void nfs4_xdr_enc_lockt(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t       const void *data)\n{\n\tconst struct nfs_lockt_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_lockt(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode a LOCKU request\n */\nstatic void nfs4_xdr_enc_locku(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t       const void *data)\n{\n\tconst struct nfs_locku_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_locku(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\nstatic void nfs4_xdr_enc_release_lockowner(struct rpc_rqst *req,\n\t\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t\t   const void *data)\n{\n\tconst struct nfs_release_lockowner_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = 0,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_release_lockowner(xdr, &args->lock_owner, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode a READLINK request\n */\nstatic void nfs4_xdr_enc_readlink(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t  const void *data)\n{\n\tconst struct nfs4_readlink *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_readlink(xdr, args, req, &hdr);\n\n\trpc_prepare_reply_pages(req, args->pages, args->pgbase,\n\t\t\t\targs->pglen, hdr.replen);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode a READDIR request\n */\nstatic void nfs4_xdr_enc_readdir(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t const void *data)\n{\n\tconst struct nfs4_readdir_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_readdir(xdr, args, req, &hdr);\n\n\trpc_prepare_reply_pages(req, args->pages, args->pgbase,\n\t\t\t\targs->count, hdr.replen);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode a READ request\n */\nstatic void nfs4_xdr_enc_read(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t      const void *data)\n{\n\tconst struct nfs_pgio_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_read(xdr, args, &hdr);\n\n\trpc_prepare_reply_pages(req, args->pages, args->pgbase,\n\t\t\t\targs->count, hdr.replen);\n\treq->rq_rcv_buf.flags |= XDRBUF_READ;\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode an SETATTR request\n */\nstatic void nfs4_xdr_enc_setattr(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t const void *data)\n{\n\tconst struct nfs_setattrargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_setattr(xdr, args, args->server, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode a GETACL request\n */\nstatic void nfs4_xdr_enc_getacl(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs_getaclargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tconst __u32 nfs4_acl_bitmap[1] = {\n\t\t[0] = FATTR4_WORD0_ACL,\n\t};\n\tuint32_t replen;\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\treplen = hdr.replen + op_decode_hdr_maxsz;\n\tencode_getattr(xdr, nfs4_acl_bitmap, NULL,\n\t\t\tARRAY_SIZE(nfs4_acl_bitmap), &hdr);\n\n\trpc_prepare_reply_pages(req, args->acl_pages, 0,\n\t\t\t\targs->acl_len, replen + 1);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode a WRITE request\n */\nstatic void nfs4_xdr_enc_write(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t       const void *data)\n{\n\tconst struct nfs_pgio_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_write(xdr, args, &hdr);\n\treq->rq_snd_buf.flags |= XDRBUF_WRITE;\n\tif (args->bitmask)\n\t\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n *  a COMMIT request\n */\nstatic void nfs4_xdr_enc_commit(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs_commitargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_commit(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * FSINFO request\n */\nstatic void nfs4_xdr_enc_fsinfo(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs4_fsinfo_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_fsinfo(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * a PATHCONF request\n */\nstatic void nfs4_xdr_enc_pathconf(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t  const void *data)\n{\n\tconst struct nfs4_pathconf_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_getattr(xdr, nfs4_pathconf_bitmap, args->bitmask,\n\t\t\tARRAY_SIZE(nfs4_pathconf_bitmap), &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * a STATFS request\n */\nstatic void nfs4_xdr_enc_statfs(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs4_statfs_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_getattr(xdr, nfs4_statfs_bitmap, args->bitmask,\n\t\t\tARRAY_SIZE(nfs4_statfs_bitmap), &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * GETATTR_BITMAP request\n */\nstatic void nfs4_xdr_enc_server_caps(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs4_server_caps_arg *args = data;\n\tconst u32 *bitmask = args->bitmask;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fhandle, &hdr);\n\tencode_getattr(xdr, bitmask, NULL, 3, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * a RENEW request\n */\nstatic void nfs4_xdr_enc_renew(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t       const void *data)\n\n{\n\tconst struct nfs_client *clp = data;\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 0,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_renew(xdr, clp->cl_clientid, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * a SETCLIENTID request\n */\nstatic void nfs4_xdr_enc_setclientid(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs4_setclientid *sc = data;\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 0,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_setclientid(xdr, sc, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * a SETCLIENTID_CONFIRM request\n */\nstatic void nfs4_xdr_enc_setclientid_confirm(struct rpc_rqst *req,\n\t\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t\t     const void *data)\n{\n\tconst struct nfs4_setclientid_res *arg = data;\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 0,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_setclientid_confirm(xdr, arg, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * DELEGRETURN request\n */\nstatic void nfs4_xdr_enc_delegreturn(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs4_delegreturnargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fhandle, &hdr);\n\tif (args->lr_args)\n\t\tencode_layoutreturn(xdr, args->lr_args, &hdr);\n\tif (args->bitmask)\n\t\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_delegreturn(xdr, args->stateid, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode FS_LOCATIONS request\n */\nstatic void nfs4_xdr_enc_fs_locations(struct rpc_rqst *req,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      const void *data)\n{\n\tconst struct nfs4_fs_locations_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tuint32_t replen;\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tif (args->migration) {\n\t\tencode_putfh(xdr, args->fh, &hdr);\n\t\treplen = hdr.replen;\n\t\tencode_fs_locations(xdr, args->bitmask, &hdr);\n\t\tif (args->renew)\n\t\t\tencode_renew(xdr, args->clientid, &hdr);\n\t} else {\n\t\tencode_putfh(xdr, args->dir_fh, &hdr);\n\t\tencode_lookup(xdr, args->name, &hdr);\n\t\treplen = hdr.replen;\n\t\tencode_fs_locations(xdr, args->bitmask, &hdr);\n\t}\n\n\trpc_prepare_reply_pages(req, (struct page **)&args->page, 0,\n\t\t\t\tPAGE_SIZE, replen + 1);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode SECINFO request\n */\nstatic void nfs4_xdr_enc_secinfo(struct rpc_rqst *req,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs4_secinfo_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->dir_fh, &hdr);\n\tencode_secinfo(xdr, args->name, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode FSID_PRESENT request\n */\nstatic void nfs4_xdr_enc_fsid_present(struct rpc_rqst *req,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      const void *data)\n{\n\tconst struct nfs4_fsid_present_arg *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_getfh(xdr, &hdr);\n\tif (args->renew)\n\t\tencode_renew(xdr, args->clientid, &hdr);\n\tencode_nops(&hdr);\n}\n\n#if defined(CONFIG_NFS_V4_1)\n/*\n * BIND_CONN_TO_SESSION request\n */\nstatic void nfs4_xdr_enc_bind_conn_to_session(struct rpc_rqst *req,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs41_bind_conn_to_session_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = args->client->cl_mvops->minor_version,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_bind_conn_to_session(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * EXCHANGE_ID request\n */\nstatic void nfs4_xdr_enc_exchange_id(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs41_exchange_id_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = args->client->cl_mvops->minor_version,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_exchange_id(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * a CREATE_SESSION request\n */\nstatic void nfs4_xdr_enc_create_session(struct rpc_rqst *req,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tconst void *data)\n{\n\tconst struct nfs41_create_session_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = args->client->cl_mvops->minor_version,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_create_session(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * a DESTROY_SESSION request\n */\nstatic void nfs4_xdr_enc_destroy_session(struct rpc_rqst *req,\n\t\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t\t const void *data)\n{\n\tconst struct nfs4_session *session = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = session->clp->cl_mvops->minor_version,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_destroy_session(xdr, session, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * a DESTROY_CLIENTID request\n */\nstatic void nfs4_xdr_enc_destroy_clientid(struct rpc_rqst *req,\n\t\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t\t const void *data)\n{\n\tconst struct nfs_client *clp = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = clp->cl_mvops->minor_version,\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_destroy_clientid(xdr, clp->cl_clientid, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * a SEQUENCE request\n */\nstatic void nfs4_xdr_enc_sequence(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t  const void *data)\n{\n\tconst struct nfs4_sequence_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n#endif\n\n/*\n * a GET_LEASE_TIME request\n */\nstatic void nfs4_xdr_enc_get_lease_time(struct rpc_rqst *req,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tconst void *data)\n{\n\tconst struct nfs4_get_lease_time_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->la_seq_args),\n\t};\n\tconst u32 lease_bitmap[3] = { FATTR4_WORD0_LEASE_TIME };\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->la_seq_args, &hdr);\n\tencode_putrootfh(xdr, &hdr);\n\tencode_fsinfo(xdr, lease_bitmap, &hdr);\n\tencode_nops(&hdr);\n}\n\n#ifdef CONFIG_NFS_V4_1\n\n/*\n * a RECLAIM_COMPLETE request\n */\nstatic void nfs4_xdr_enc_reclaim_complete(struct rpc_rqst *req,\n\t\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t\t  const void *data)\n{\n\tconst struct nfs41_reclaim_complete_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args)\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_reclaim_complete(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode GETDEVICEINFO request\n */\nstatic void nfs4_xdr_enc_getdeviceinfo(struct rpc_rqst *req,\n\t\t\t\t       struct xdr_stream *xdr,\n\t\t\t\t       const void *data)\n{\n\tconst struct nfs4_getdeviceinfo_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_getdeviceinfo(xdr, args, &hdr);\n\n\t/* set up reply kvec. Subtract notification bitmap max size (2)\n\t * so that notification bitmap is put in xdr_buf tail */\n\trpc_prepare_reply_pages(req, args->pdev->pages, args->pdev->pgbase,\n\t\t\t\targs->pdev->pglen, hdr.replen - 2);\n\tencode_nops(&hdr);\n}\n\n/*\n *  Encode LAYOUTGET request\n */\nstatic void nfs4_xdr_enc_layoutget(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   const void *data)\n{\n\tconst struct nfs4_layoutget_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, NFS_FH(args->inode), &hdr);\n\tencode_layoutget(xdr, args, &hdr);\n\n\trpc_prepare_reply_pages(req, args->layout.pages, 0,\n\t\t\t\targs->layout.pglen, hdr.replen);\n\tencode_nops(&hdr);\n}\n\n/*\n *  Encode LAYOUTCOMMIT request\n */\nstatic void nfs4_xdr_enc_layoutcommit(struct rpc_rqst *req,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      const void *priv)\n{\n\tconst struct nfs4_layoutcommit_args *args = priv;\n\tstruct nfs4_layoutcommit_data *data =\n\t\tcontainer_of(args, struct nfs4_layoutcommit_data, args);\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, NFS_FH(args->inode), &hdr);\n\tencode_layoutcommit(xdr, data->args.inode, args, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode LAYOUTRETURN request\n */\nstatic void nfs4_xdr_enc_layoutreturn(struct rpc_rqst *req,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      const void *data)\n{\n\tconst struct nfs4_layoutreturn_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, NFS_FH(args->inode), &hdr);\n\tencode_layoutreturn(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Encode SECINFO_NO_NAME request\n */\nstatic void nfs4_xdr_enc_secinfo_no_name(struct rpc_rqst *req,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tconst void *data)\n{\n\tconst struct nfs41_secinfo_no_name_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putrootfh(xdr, &hdr);\n\tencode_secinfo_no_name(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n *  Encode TEST_STATEID request\n */\nstatic void nfs4_xdr_enc_test_stateid(struct rpc_rqst *req,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      const void *data)\n{\n\tconst struct nfs41_test_stateid_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_test_stateid(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n *  Encode FREE_STATEID request\n */\nstatic void nfs4_xdr_enc_free_stateid(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const void *data)\n{\n\tconst struct nfs41_free_stateid_args *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_free_stateid(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n#endif /* CONFIG_NFS_V4_1 */\n\nstatic int decode_opaque_inline(struct xdr_stream *xdr, unsigned int *len, char **string)\n{\n\tssize_t ret = xdr_stream_decode_opaque_inline(xdr, (void **)string,\n\t\t\tNFS4_OPAQUE_LIMIT);\n\tif (unlikely(ret < 0))\n\t\treturn -EIO;\n\t*len = ret;\n\treturn 0;\n}\n\nstatic int decode_compound_hdr(struct xdr_stream *xdr, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\thdr->status = be32_to_cpup(p++);\n\thdr->taglen = be32_to_cpup(p);\n\n\tp = xdr_inline_decode(xdr, hdr->taglen + 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\thdr->tag = (char *)p;\n\tp += XDR_QUADLEN(hdr->taglen);\n\thdr->nops = be32_to_cpup(p);\n\tif (unlikely(hdr->nops < 1))\n\t\treturn nfs4_stat_to_errno(hdr->status);\n\treturn 0;\n}\n\nstatic bool __decode_op_hdr(struct xdr_stream *xdr, enum nfs_opnum4 expected,\n\t\tint *nfs_retval)\n{\n\t__be32 *p;\n\tuint32_t opnum;\n\tint32_t nfserr;\n\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\topnum = be32_to_cpup(p++);\n\tif (unlikely(opnum != expected))\n\t\tgoto out_bad_operation;\n\tif (unlikely(*p != cpu_to_be32(NFS_OK)))\n\t\tgoto out_status;\n\t*nfs_retval = 0;\n\treturn true;\nout_status:\n\tnfserr = be32_to_cpup(p);\n\ttrace_nfs4_xdr_status(xdr, opnum, nfserr);\n\t*nfs_retval = nfs4_stat_to_errno(nfserr);\n\treturn true;\nout_bad_operation:\n\tdprintk(\"nfs: Server returned operation\"\n\t\t\" %d but we issued a request for %d\\n\",\n\t\t\topnum, expected);\n\t*nfs_retval = -EREMOTEIO;\n\treturn false;\nout_overflow:\n\t*nfs_retval = -EIO;\n\treturn false;\n}\n\nstatic int decode_op_hdr(struct xdr_stream *xdr, enum nfs_opnum4 expected)\n{\n\tint retval;\n\n\t__decode_op_hdr(xdr, expected, &retval);\n\treturn retval;\n}\n\n/* Dummy routine */\nstatic int decode_ace(struct xdr_stream *xdr, void *ace)\n{\n\t__be32 *p;\n\tunsigned int strlen;\n\tchar *str;\n\n\tp = xdr_inline_decode(xdr, 12);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\treturn decode_opaque_inline(xdr, &strlen, &str);\n}\n\nstatic ssize_t\ndecode_bitmap4(struct xdr_stream *xdr, uint32_t *bitmap, size_t sz)\n{\n\tssize_t ret;\n\n\tret = xdr_stream_decode_uint32_array(xdr, bitmap, sz);\n\tif (likely(ret >= 0))\n\t\treturn ret;\n\tif (ret != -EMSGSIZE)\n\t\treturn -EIO;\n\treturn sz;\n}\n\nstatic int decode_attr_bitmap(struct xdr_stream *xdr, uint32_t *bitmap)\n{\n\tssize_t ret;\n\tret = decode_bitmap4(xdr, bitmap, 3);\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int decode_attr_length(struct xdr_stream *xdr, uint32_t *attrlen, unsigned int *savep)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\t*attrlen = be32_to_cpup(p);\n\t*savep = xdr_stream_pos(xdr);\n\treturn 0;\n}\n\nstatic int decode_attr_supported(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *bitmask)\n{\n\tif (likely(bitmap[0] & FATTR4_WORD0_SUPPORTED_ATTRS)) {\n\t\tint ret;\n\t\tret = decode_attr_bitmap(xdr, bitmask);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\tbitmap[0] &= ~FATTR4_WORD0_SUPPORTED_ATTRS;\n\t} else\n\t\tbitmask[0] = bitmask[1] = bitmask[2] = 0;\n\tdprintk(\"%s: bitmask=%08x:%08x:%08x\\n\", __func__,\n\t\tbitmask[0], bitmask[1], bitmask[2]);\n\treturn 0;\n}\n\nstatic int decode_attr_type(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *type)\n{\n\t__be32 *p;\n\tint ret = 0;\n\n\t*type = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_TYPE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_TYPE)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*type = be32_to_cpup(p);\n\t\tif (*type < NF4REG || *type > NF4NAMEDATTR) {\n\t\t\tdprintk(\"%s: bad type %d\\n\", __func__, *type);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbitmap[0] &= ~FATTR4_WORD0_TYPE;\n\t\tret = NFS_ATTR_FATTR_TYPE;\n\t}\n\tdprintk(\"%s: type=0%o\\n\", __func__, nfs_type2fmt[*type]);\n\treturn ret;\n}\n\nstatic int decode_attr_fh_expire_type(struct xdr_stream *xdr,\n\t\t\t\t      uint32_t *bitmap, uint32_t *type)\n{\n\t__be32 *p;\n\n\t*type = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FH_EXPIRE_TYPE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FH_EXPIRE_TYPE)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*type = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FH_EXPIRE_TYPE;\n\t}\n\tdprintk(\"%s: expire type=0x%x\\n\", __func__, *type);\n\treturn 0;\n}\n\nstatic int decode_attr_change(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *change)\n{\n\t__be32 *p;\n\tint ret = 0;\n\n\t*change = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_CHANGE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_CHANGE)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, change);\n\t\tbitmap[0] &= ~FATTR4_WORD0_CHANGE;\n\t\tret = NFS_ATTR_FATTR_CHANGE;\n\t}\n\tdprintk(\"%s: change attribute=%Lu\\n\", __func__,\n\t\t\t(unsigned long long)*change);\n\treturn ret;\n}\n\nstatic int decode_attr_size(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *size)\n{\n\t__be32 *p;\n\tint ret = 0;\n\n\t*size = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_SIZE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_SIZE)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, size);\n\t\tbitmap[0] &= ~FATTR4_WORD0_SIZE;\n\t\tret = NFS_ATTR_FATTR_SIZE;\n\t}\n\tdprintk(\"%s: file size=%Lu\\n\", __func__, (unsigned long long)*size);\n\treturn ret;\n}\n\nstatic int decode_attr_link_support(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_LINK_SUPPORT - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_LINK_SUPPORT)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*res = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_LINK_SUPPORT;\n\t}\n\tdprintk(\"%s: link support=%s\\n\", __func__, *res == 0 ? \"false\" : \"true\");\n\treturn 0;\n}\n\nstatic int decode_attr_symlink_support(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_SYMLINK_SUPPORT - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_SYMLINK_SUPPORT)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*res = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_SYMLINK_SUPPORT;\n\t}\n\tdprintk(\"%s: symlink support=%s\\n\", __func__, *res == 0 ? \"false\" : \"true\");\n\treturn 0;\n}\n\nstatic int decode_attr_fsid(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_fsid *fsid)\n{\n\t__be32 *p;\n\tint ret = 0;\n\n\tfsid->major = 0;\n\tfsid->minor = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FSID - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FSID)) {\n\t\tp = xdr_inline_decode(xdr, 16);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tp = xdr_decode_hyper(p, &fsid->major);\n\t\txdr_decode_hyper(p, &fsid->minor);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FSID;\n\t\tret = NFS_ATTR_FATTR_FSID;\n\t}\n\tdprintk(\"%s: fsid=(0x%Lx/0x%Lx)\\n\", __func__,\n\t\t\t(unsigned long long)fsid->major,\n\t\t\t(unsigned long long)fsid->minor);\n\treturn ret;\n}\n\nstatic int decode_attr_lease_time(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = 60;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_LEASE_TIME - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_LEASE_TIME)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*res = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_LEASE_TIME;\n\t}\n\tdprintk(\"%s: lease time=%u\\n\", __func__, (unsigned int)*res);\n\treturn 0;\n}\n\nstatic int decode_attr_error(struct xdr_stream *xdr, uint32_t *bitmap, int32_t *res)\n{\n\t__be32 *p;\n\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_RDATTR_ERROR - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_RDATTR_ERROR)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tbitmap[0] &= ~FATTR4_WORD0_RDATTR_ERROR;\n\t\t*res = -be32_to_cpup(p);\n\t}\n\treturn 0;\n}\n\nstatic int decode_attr_exclcreat_supported(struct xdr_stream *xdr,\n\t\t\t\t uint32_t *bitmap, uint32_t *bitmask)\n{\n\tif (likely(bitmap[2] & FATTR4_WORD2_SUPPATTR_EXCLCREAT)) {\n\t\tint ret;\n\t\tret = decode_attr_bitmap(xdr, bitmask);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\tbitmap[2] &= ~FATTR4_WORD2_SUPPATTR_EXCLCREAT;\n\t} else\n\t\tbitmask[0] = bitmask[1] = bitmask[2] = 0;\n\tdprintk(\"%s: bitmask=%08x:%08x:%08x\\n\", __func__,\n\t\tbitmask[0], bitmask[1], bitmask[2]);\n\treturn 0;\n}\n\nstatic int decode_attr_filehandle(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\tu32 len;\n\n\tif (fh != NULL)\n\t\tmemset(fh, 0, sizeof(*fh));\n\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILEHANDLE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILEHANDLE)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlen = be32_to_cpup(p);\n\t\tif (len > NFS4_FHSIZE)\n\t\t\treturn -EIO;\n\t\tp = xdr_inline_decode(xdr, len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tif (fh != NULL) {\n\t\t\tmemcpy(fh->data, p, len);\n\t\t\tfh->size = len;\n\t\t}\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILEHANDLE;\n\t}\n\treturn 0;\n}\n\nstatic int decode_attr_aclsupport(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_ACLSUPPORT - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_ACLSUPPORT)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*res = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_ACLSUPPORT;\n\t}\n\tdprintk(\"%s: ACLs supported=%u\\n\", __func__, (unsigned int)*res);\n\treturn 0;\n}\n\nstatic int decode_attr_fileid(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *fileid)\n{\n\t__be32 *p;\n\tint ret = 0;\n\n\t*fileid = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILEID - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILEID)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, fileid);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILEID;\n\t\tret = NFS_ATTR_FATTR_FILEID;\n\t}\n\tdprintk(\"%s: fileid=%Lu\\n\", __func__, (unsigned long long)*fileid);\n\treturn ret;\n}\n\nstatic int decode_attr_mounted_on_fileid(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *fileid)\n{\n\t__be32 *p;\n\tint ret = 0;\n\n\t*fileid = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_MOUNTED_ON_FILEID - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_MOUNTED_ON_FILEID)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, fileid);\n\t\tbitmap[1] &= ~FATTR4_WORD1_MOUNTED_ON_FILEID;\n\t\tret = NFS_ATTR_FATTR_MOUNTED_ON_FILEID;\n\t}\n\tdprintk(\"%s: fileid=%Lu\\n\", __func__, (unsigned long long)*fileid);\n\treturn ret;\n}\n\nstatic int decode_attr_files_avail(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILES_AVAIL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILES_AVAIL)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILES_AVAIL;\n\t}\n\tdprintk(\"%s: files avail=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_files_free(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILES_FREE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILES_FREE)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILES_FREE;\n\t}\n\tdprintk(\"%s: files free=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_files_total(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILES_TOTAL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILES_TOTAL)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILES_TOTAL;\n\t}\n\tdprintk(\"%s: files total=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_pathname(struct xdr_stream *xdr, struct nfs4_pathname *path)\n{\n\tu32 n;\n\t__be32 *p;\n\tint status = 0;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tn = be32_to_cpup(p);\n\tif (n == 0)\n\t\tgoto root_path;\n\tdprintk(\"pathname4: \");\n\tif (n > NFS4_PATHNAME_MAXCOMPONENTS) {\n\t\tdprintk(\"cannot parse %d components in path\\n\", n);\n\t\tgoto out_eio;\n\t}\n\tfor (path->ncomponents = 0; path->ncomponents < n; path->ncomponents++) {\n\t\tstruct nfs4_string *component = &path->components[path->ncomponents];\n\t\tstatus = decode_opaque_inline(xdr, &component->len, &component->data);\n\t\tif (unlikely(status != 0))\n\t\t\tgoto out_eio;\n\t\tifdebug (XDR)\n\t\t\tpr_cont(\"%s%.*s \",\n\t\t\t\t(path->ncomponents != n ? \"/ \" : \"\"),\n\t\t\t\tcomponent->len, component->data);\n\t}\nout:\n\treturn status;\nroot_path:\n/* a root pathname is sent as a zero component4 */\n\tpath->ncomponents = 1;\n\tpath->components[0].len=0;\n\tpath->components[0].data=NULL;\n\tdprintk(\"pathname4: /\\n\");\n\tgoto out;\nout_eio:\n\tdprintk(\" status %d\", status);\n\tstatus = -EIO;\n\tgoto out;\n}\n\nstatic int decode_attr_fs_locations(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs4_fs_locations *res)\n{\n\tint n;\n\t__be32 *p;\n\tint status = -EIO;\n\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FS_LOCATIONS -1U)))\n\t\tgoto out;\n\tstatus = 0;\n\tif (unlikely(!(bitmap[0] & FATTR4_WORD0_FS_LOCATIONS)))\n\t\tgoto out;\n\tbitmap[0] &= ~FATTR4_WORD0_FS_LOCATIONS;\n\tstatus = -EIO;\n\t/* Ignore borken servers that return unrequested attrs */\n\tif (unlikely(res == NULL))\n\t\tgoto out;\n\tdprintk(\"%s: fsroot:\\n\", __func__);\n\tstatus = decode_pathname(xdr, &res->fs_path);\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_eio;\n\tn = be32_to_cpup(p);\n\tif (n <= 0)\n\t\tgoto out_eio;\n\tfor (res->nlocations = 0; res->nlocations < n; res->nlocations++) {\n\t\tu32 m;\n\t\tstruct nfs4_fs_location *loc;\n\n\t\tif (res->nlocations == NFS4_FS_LOCATIONS_MAXENTRIES)\n\t\t\tbreak;\n\t\tloc = &res->locations[res->nlocations];\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_eio;\n\t\tm = be32_to_cpup(p);\n\n\t\tdprintk(\"%s: servers:\\n\", __func__);\n\t\tfor (loc->nservers = 0; loc->nservers < m; loc->nservers++) {\n\t\t\tstruct nfs4_string *server;\n\n\t\t\tif (loc->nservers == NFS4_FS_LOCATION_MAXSERVERS) {\n\t\t\t\tunsigned int i;\n\t\t\t\tdprintk(\"%s: using first %u of %u servers \"\n\t\t\t\t\t\"returned for location %u\\n\",\n\t\t\t\t\t\t__func__,\n\t\t\t\t\t\tNFS4_FS_LOCATION_MAXSERVERS,\n\t\t\t\t\t\tm, res->nlocations);\n\t\t\t\tfor (i = loc->nservers; i < m; i++) {\n\t\t\t\t\tunsigned int len;\n\t\t\t\t\tchar *data;\n\t\t\t\t\tstatus = decode_opaque_inline(xdr, &len, &data);\n\t\t\t\t\tif (unlikely(status != 0))\n\t\t\t\t\t\tgoto out_eio;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tserver = &loc->servers[loc->nservers];\n\t\t\tstatus = decode_opaque_inline(xdr, &server->len, &server->data);\n\t\t\tif (unlikely(status != 0))\n\t\t\t\tgoto out_eio;\n\t\t\tdprintk(\"%s \", server->data);\n\t\t}\n\t\tstatus = decode_pathname(xdr, &loc->rootpath);\n\t\tif (unlikely(status != 0))\n\t\t\tgoto out_eio;\n\t}\n\tif (res->nlocations != 0)\n\t\tstatus = NFS_ATTR_FATTR_V4_LOCATIONS;\nout:\n\tdprintk(\"%s: fs_locations done, error = %d\\n\", __func__, status);\n\treturn status;\nout_eio:\n\tstatus = -EIO;\n\tgoto out;\n}\n\nstatic int decode_attr_maxfilesize(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXFILESIZE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXFILESIZE)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXFILESIZE;\n\t}\n\tdprintk(\"%s: maxfilesize=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_maxlink(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *maxlink)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*maxlink = 1;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXLINK - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXLINK)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*maxlink = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXLINK;\n\t}\n\tdprintk(\"%s: maxlink=%u\\n\", __func__, *maxlink);\n\treturn status;\n}\n\nstatic int decode_attr_maxname(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *maxname)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*maxname = 1024;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXNAME - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXNAME)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*maxname = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXNAME;\n\t}\n\tdprintk(\"%s: maxname=%u\\n\", __func__, *maxname);\n\treturn status;\n}\n\nstatic int decode_attr_maxread(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 1024;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXREAD - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXREAD)) {\n\t\tuint64_t maxread;\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, &maxread);\n\t\tif (maxread > 0x7FFFFFFF)\n\t\t\tmaxread = 0x7FFFFFFF;\n\t\t*res = (uint32_t)maxread;\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXREAD;\n\t}\n\tdprintk(\"%s: maxread=%lu\\n\", __func__, (unsigned long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_maxwrite(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 1024;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXWRITE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXWRITE)) {\n\t\tuint64_t maxwrite;\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, &maxwrite);\n\t\tif (maxwrite > 0x7FFFFFFF)\n\t\t\tmaxwrite = 0x7FFFFFFF;\n\t\t*res = (uint32_t)maxwrite;\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXWRITE;\n\t}\n\tdprintk(\"%s: maxwrite=%lu\\n\", __func__, (unsigned long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_mode(struct xdr_stream *xdr, uint32_t *bitmap, umode_t *mode)\n{\n\tuint32_t tmp;\n\t__be32 *p;\n\tint ret = 0;\n\n\t*mode = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_MODE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_MODE)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\ttmp = be32_to_cpup(p);\n\t\t*mode = tmp & ~S_IFMT;\n\t\tbitmap[1] &= ~FATTR4_WORD1_MODE;\n\t\tret = NFS_ATTR_FATTR_MODE;\n\t}\n\tdprintk(\"%s: file mode=0%o\\n\", __func__, (unsigned int)*mode);\n\treturn ret;\n}\n\nstatic int decode_attr_nlink(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *nlink)\n{\n\t__be32 *p;\n\tint ret = 0;\n\n\t*nlink = 1;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_NUMLINKS - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_NUMLINKS)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*nlink = be32_to_cpup(p);\n\t\tbitmap[1] &= ~FATTR4_WORD1_NUMLINKS;\n\t\tret = NFS_ATTR_FATTR_NLINK;\n\t}\n\tdprintk(\"%s: nlink=%u\\n\", __func__, (unsigned int)*nlink);\n\treturn ret;\n}\n\nstatic ssize_t decode_nfs4_string(struct xdr_stream *xdr,\n\t\tstruct nfs4_string *name, gfp_t gfp_flags)\n{\n\tssize_t ret;\n\n\tret = xdr_stream_decode_string_dup(xdr, &name->data,\n\t\t\tXDR_MAX_NETOBJ, gfp_flags);\n\tname->len = 0;\n\tif (ret > 0)\n\t\tname->len = ret;\n\treturn ret;\n}\n\nstatic int decode_attr_owner(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\tconst struct nfs_server *server, kuid_t *uid,\n\t\tstruct nfs4_string *owner_name)\n{\n\tssize_t len;\n\tchar *p;\n\n\t*uid = make_kuid(&init_user_ns, -2);\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER - 1U)))\n\t\treturn -EIO;\n\tif (!(bitmap[1] & FATTR4_WORD1_OWNER))\n\t\treturn 0;\n\tbitmap[1] &= ~FATTR4_WORD1_OWNER;\n\n\tif (owner_name != NULL) {\n\t\tlen = decode_nfs4_string(xdr, owner_name, GFP_NOIO);\n\t\tif (len <= 0)\n\t\t\tgoto out;\n\t\tdprintk(\"%s: name=%s\\n\", __func__, owner_name->data);\n\t\treturn NFS_ATTR_FATTR_OWNER_NAME;\n\t} else {\n\t\tlen = xdr_stream_decode_opaque_inline(xdr, (void **)&p,\n\t\t\t\tXDR_MAX_NETOBJ);\n\t\tif (len <= 0 || nfs_map_name_to_uid(server, p, len, uid) != 0)\n\t\t\tgoto out;\n\t\tdprintk(\"%s: uid=%d\\n\", __func__, (int)from_kuid(&init_user_ns, *uid));\n\t\treturn NFS_ATTR_FATTR_OWNER;\n\t}\nout:\n\tif (len == -EBADMSG)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\tconst struct nfs_server *server, kgid_t *gid,\n\t\tstruct nfs4_string *group_name)\n{\n\tssize_t len;\n\tchar *p;\n\n\t*gid = make_kgid(&init_user_ns, -2);\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))\n\t\treturn -EIO;\n\tif (!(bitmap[1] & FATTR4_WORD1_OWNER_GROUP))\n\t\treturn 0;\n\tbitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;\n\n\tif (group_name != NULL) {\n\t\tlen = decode_nfs4_string(xdr, group_name, GFP_NOIO);\n\t\tif (len <= 0)\n\t\t\tgoto out;\n\t\tdprintk(\"%s: name=%s\\n\", __func__, group_name->data);\n\t\treturn NFS_ATTR_FATTR_GROUP_NAME;\n\t} else {\n\t\tlen = xdr_stream_decode_opaque_inline(xdr, (void **)&p,\n\t\t\t\tXDR_MAX_NETOBJ);\n\t\tif (len <= 0 || nfs_map_group_to_gid(server, p, len, gid) != 0)\n\t\t\tgoto out;\n\t\tdprintk(\"%s: gid=%d\\n\", __func__, (int)from_kgid(&init_user_ns, *gid));\n\t\treturn NFS_ATTR_FATTR_GROUP;\n\t}\nout:\n\tif (len == -EBADMSG)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int decode_attr_rdev(struct xdr_stream *xdr, uint32_t *bitmap, dev_t *rdev)\n{\n\tuint32_t major = 0, minor = 0;\n\t__be32 *p;\n\tint ret = 0;\n\n\t*rdev = MKDEV(0,0);\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_RAWDEV - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_RAWDEV)) {\n\t\tdev_t tmp;\n\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tmajor = be32_to_cpup(p++);\n\t\tminor = be32_to_cpup(p);\n\t\ttmp = MKDEV(major, minor);\n\t\tif (MAJOR(tmp) == major && MINOR(tmp) == minor)\n\t\t\t*rdev = tmp;\n\t\tbitmap[1] &= ~ FATTR4_WORD1_RAWDEV;\n\t\tret = NFS_ATTR_FATTR_RDEV;\n\t}\n\tdprintk(\"%s: rdev=(0x%x:0x%x)\\n\", __func__, major, minor);\n\treturn ret;\n}\n\nstatic int decode_attr_space_avail(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_SPACE_AVAIL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_SPACE_AVAIL)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, res);\n\t\tbitmap[1] &= ~FATTR4_WORD1_SPACE_AVAIL;\n\t}\n\tdprintk(\"%s: space avail=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_space_free(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_SPACE_FREE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_SPACE_FREE)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, res);\n\t\tbitmap[1] &= ~FATTR4_WORD1_SPACE_FREE;\n\t}\n\tdprintk(\"%s: space free=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_space_total(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_SPACE_TOTAL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_SPACE_TOTAL)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, res);\n\t\tbitmap[1] &= ~FATTR4_WORD1_SPACE_TOTAL;\n\t}\n\tdprintk(\"%s: space total=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_space_used(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *used)\n{\n\t__be32 *p;\n\tint ret = 0;\n\n\t*used = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_SPACE_USED - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_SPACE_USED)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, used);\n\t\tbitmap[1] &= ~FATTR4_WORD1_SPACE_USED;\n\t\tret = NFS_ATTR_FATTR_SPACE_USED;\n\t}\n\tdprintk(\"%s: space used=%Lu\\n\", __func__,\n\t\t\t(unsigned long long)*used);\n\treturn ret;\n}\n\nstatic __be32 *\nxdr_decode_nfstime4(__be32 *p, struct timespec64 *t)\n{\n\t__u64 sec;\n\n\tp = xdr_decode_hyper(p, &sec);\n\tt-> tv_sec = sec;\n\tt->tv_nsec = be32_to_cpup(p++);\n\treturn p;\n}\n\nstatic int decode_attr_time(struct xdr_stream *xdr, struct timespec64 *time)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nfstime4_maxsz << 2);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\txdr_decode_nfstime4(p, time);\n\treturn 0;\n}\n\nstatic int decode_attr_time_access(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)\n{\n\tint status = 0;\n\n\ttime->tv_sec = 0;\n\ttime->tv_nsec = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_ACCESS - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_TIME_ACCESS)) {\n\t\tstatus = decode_attr_time(xdr, time);\n\t\tif (status == 0)\n\t\t\tstatus = NFS_ATTR_FATTR_ATIME;\n\t\tbitmap[1] &= ~FATTR4_WORD1_TIME_ACCESS;\n\t}\n\tdprintk(\"%s: atime=%lld\\n\", __func__, time->tv_sec);\n\treturn status;\n}\n\nstatic int decode_attr_time_metadata(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)\n{\n\tint status = 0;\n\n\ttime->tv_sec = 0;\n\ttime->tv_nsec = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_METADATA - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_TIME_METADATA)) {\n\t\tstatus = decode_attr_time(xdr, time);\n\t\tif (status == 0)\n\t\t\tstatus = NFS_ATTR_FATTR_CTIME;\n\t\tbitmap[1] &= ~FATTR4_WORD1_TIME_METADATA;\n\t}\n\tdprintk(\"%s: ctime=%lld\\n\", __func__, time->tv_sec);\n\treturn status;\n}\n\nstatic int decode_attr_time_delta(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\t  struct timespec64 *time)\n{\n\tint status = 0;\n\n\ttime->tv_sec = 0;\n\ttime->tv_nsec = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_DELTA - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_TIME_DELTA)) {\n\t\tstatus = decode_attr_time(xdr, time);\n\t\tbitmap[1] &= ~FATTR4_WORD1_TIME_DELTA;\n\t}\n\tdprintk(\"%s: time_delta=%lld %ld\\n\", __func__, time->tv_sec,\n\t\ttime->tv_nsec);\n\treturn status;\n}\n\nstatic int decode_attr_security_label(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\t\tstruct nfs4_label *label)\n{\n\tuint32_t pi = 0;\n\tuint32_t lfs = 0;\n\t__u32 len;\n\t__be32 *p;\n\tint status = 0;\n\n\tif (unlikely(bitmap[2] & (FATTR4_WORD2_SECURITY_LABEL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[2] & FATTR4_WORD2_SECURITY_LABEL)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlfs = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tpi = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlen = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tif (len < NFS4_MAXLABELLEN) {\n\t\t\tif (label) {\n\t\t\t\tif (label->len) {\n\t\t\t\t\tif (label->len < len)\n\t\t\t\t\t\treturn -ERANGE;\n\t\t\t\t\tmemcpy(label->label, p, len);\n\t\t\t\t}\n\t\t\t\tlabel->len = len;\n\t\t\t\tlabel->pi = pi;\n\t\t\t\tlabel->lfs = lfs;\n\t\t\t\tstatus = NFS_ATTR_FATTR_V4_SECURITY_LABEL;\n\t\t\t}\n\t\t\tbitmap[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t} else\n\t\t\tprintk(KERN_WARNING \"%s: label too long (%u)!\\n\",\n\t\t\t\t\t__func__, len);\n\t}\n\tif (label && label->label)\n\t\tdprintk(\"%s: label=%s, len=%d, PI=%d, LFS=%d\\n\", __func__,\n\t\t\t(char *)label->label, label->len, label->pi, label->lfs);\n\treturn status;\n}\n\nstatic int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)\n{\n\tint status = 0;\n\n\ttime->tv_sec = 0;\n\ttime->tv_nsec = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {\n\t\tstatus = decode_attr_time(xdr, time);\n\t\tif (status == 0)\n\t\t\tstatus = NFS_ATTR_FATTR_MTIME;\n\t\tbitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;\n\t}\n\tdprintk(\"%s: mtime=%lld\\n\", __func__, time->tv_sec);\n\treturn status;\n}\n\nstatic int decode_attr_xattrsupport(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\t    uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = 0;\n\tif (unlikely(bitmap[2] & (FATTR4_WORD2_XATTR_SUPPORT - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[2] & FATTR4_WORD2_XATTR_SUPPORT)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*res = be32_to_cpup(p);\n\t\tbitmap[2] &= ~FATTR4_WORD2_XATTR_SUPPORT;\n\t}\n\tdprintk(\"%s: XATTR support=%s\\n\", __func__,\n\t\t*res == 0 ? \"false\" : \"true\");\n\treturn 0;\n}\n\nstatic int verify_attr_len(struct xdr_stream *xdr, unsigned int savep, uint32_t attrlen)\n{\n\tunsigned int attrwords = XDR_QUADLEN(attrlen);\n\tunsigned int nwords = (xdr_stream_pos(xdr) - savep) >> 2;\n\n\tif (unlikely(attrwords != nwords)) {\n\t\tdprintk(\"%s: server returned incorrect attribute length: \"\n\t\t\t\"%u %c %u\\n\",\n\t\t\t\t__func__,\n\t\t\t\tattrwords << 2,\n\t\t\t\t(attrwords < nwords) ? '<' : '>',\n\t\t\t\tnwords << 2);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int decode_change_info(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 20);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tcinfo->atomic = be32_to_cpup(p++);\n\tp = xdr_decode_hyper(p, &cinfo->before);\n\txdr_decode_hyper(p, &cinfo->after);\n\treturn 0;\n}\n\nstatic int decode_access(struct xdr_stream *xdr, u32 *supported, u32 *access)\n{\n\t__be32 *p;\n\tuint32_t supp, acc;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_ACCESS);\n\tif (status)\n\t\treturn status;\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tsupp = be32_to_cpup(p++);\n\tacc = be32_to_cpup(p);\n\t*supported = supp;\n\t*access = acc;\n\treturn 0;\n}\n\nstatic int decode_opaque_fixed(struct xdr_stream *xdr, void *buf, size_t len)\n{\n\tssize_t ret = xdr_stream_decode_opaque_fixed(xdr, buf, len);\n\tif (unlikely(ret < 0))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int decode_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\treturn decode_opaque_fixed(xdr, stateid, NFS4_STATEID_SIZE);\n}\n\nstatic int decode_open_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\tstateid->type = NFS4_OPEN_STATEID_TYPE;\n\treturn decode_stateid(xdr, stateid);\n}\n\nstatic int decode_lock_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\tstateid->type = NFS4_LOCK_STATEID_TYPE;\n\treturn decode_stateid(xdr, stateid);\n}\n\nstatic int decode_delegation_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\tstateid->type = NFS4_DELEGATION_STATEID_TYPE;\n\treturn decode_stateid(xdr, stateid);\n}\n\nstatic int decode_invalid_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\tnfs4_stateid dummy;\n\n\tnfs4_stateid_copy(stateid, &invalid_stateid);\n\treturn decode_stateid(xdr, &dummy);\n}\n\nstatic int decode_close(struct xdr_stream *xdr, struct nfs_closeres *res)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_CLOSE);\n\tif (status != -EIO)\n\t\tnfs_increment_open_seqid(status, res->seqid);\n\tif (!status)\n\t\tstatus = decode_invalid_stateid(xdr, &res->stateid);\n\treturn status;\n}\n\nstatic int decode_verifier(struct xdr_stream *xdr, void *verifier)\n{\n\treturn decode_opaque_fixed(xdr, verifier, NFS4_VERIFIER_SIZE);\n}\n\nstatic int decode_write_verifier(struct xdr_stream *xdr, struct nfs_write_verifier *verifier)\n{\n\treturn decode_opaque_fixed(xdr, verifier->data, NFS4_VERIFIER_SIZE);\n}\n\nstatic int decode_commit(struct xdr_stream *xdr, struct nfs_commitres *res)\n{\n\tstruct nfs_writeverf *verf = res->verf;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_COMMIT);\n\tif (!status)\n\t\tstatus = decode_write_verifier(xdr, &verf->verifier);\n\tif (!status)\n\t\tverf->committed = NFS_FILE_SYNC;\n\treturn status;\n}\n\nstatic int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)\n{\n\t__be32 *p;\n\tuint32_t bmlen;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_CREATE);\n\tif (status)\n\t\treturn status;\n\tif ((status = decode_change_info(xdr, cinfo)))\n\t\treturn status;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tbmlen = be32_to_cpup(p);\n\tp = xdr_inline_decode(xdr, bmlen << 2);\n\tif (likely(p))\n\t\treturn 0;\n\treturn -EIO;\n}\n\nstatic int decode_server_caps(struct xdr_stream *xdr, struct nfs4_server_caps_res *res)\n{\n\tunsigned int savep;\n\tuint32_t attrlen, bitmap[3] = {0};\n\tint status;\n\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_supported(xdr, bitmap, res->attr_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_fh_expire_type(xdr, bitmap,\n\t\t\t\t\t\t &res->fh_expire_type)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_link_support(xdr, bitmap, &res->has_links)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_symlink_support(xdr, bitmap, &res->has_symlinks)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_aclsupport(xdr, bitmap, &res->acl_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_exclcreat_supported(xdr, bitmap,\n\t\t\t\tres->exclcreat_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}\n\nstatic int decode_statfs(struct xdr_stream *xdr, struct nfs_fsstat *fsstat)\n{\n\tunsigned int savep;\n\tuint32_t attrlen, bitmap[3] = {0};\n\tint status;\n\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\n\tif ((status = decode_attr_files_avail(xdr, bitmap, &fsstat->afiles)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_files_free(xdr, bitmap, &fsstat->ffiles)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_files_total(xdr, bitmap, &fsstat->tfiles)) != 0)\n\t\tgoto xdr_error;\n\n\tstatus = -EIO;\n\tif (unlikely(bitmap[0]))\n\t\tgoto xdr_error;\n\n\tif ((status = decode_attr_space_avail(xdr, bitmap, &fsstat->abytes)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_space_free(xdr, bitmap, &fsstat->fbytes)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_space_total(xdr, bitmap, &fsstat->tbytes)) != 0)\n\t\tgoto xdr_error;\n\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}\n\nstatic int decode_pathconf(struct xdr_stream *xdr, struct nfs_pathconf *pathconf)\n{\n\tunsigned int savep;\n\tuint32_t attrlen, bitmap[3] = {0};\n\tint status;\n\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\n\tif ((status = decode_attr_maxlink(xdr, bitmap, &pathconf->max_link)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_maxname(xdr, bitmap, &pathconf->max_namelen)) != 0)\n\t\tgoto xdr_error;\n\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}\n\nstatic int decode_threshold_hint(struct xdr_stream *xdr,\n\t\t\t\t  uint32_t *bitmap,\n\t\t\t\t  uint64_t *res,\n\t\t\t\t  uint32_t hint_bit)\n{\n\t__be32 *p;\n\n\t*res = 0;\n\tif (likely(bitmap[0] & hint_bit)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\txdr_decode_hyper(p, res);\n\t}\n\treturn 0;\n}\n\nstatic int decode_first_threshold_item4(struct xdr_stream *xdr,\n\t\t\t\t\tstruct nfs4_threshold *res)\n{\n\t__be32 *p;\n\tunsigned int savep;\n\tuint32_t bitmap[3] = {0,}, attrlen;\n\tint status;\n\n\t/* layout type */\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tres->l_type = be32_to_cpup(p);\n\n\t/* thi_hintset bitmap */\n\tstatus = decode_attr_bitmap(xdr, bitmap);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\t/* thi_hintlist length */\n\tstatus = decode_attr_length(xdr, &attrlen, &savep);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\t/* thi_hintlist */\n\tstatus = decode_threshold_hint(xdr, bitmap, &res->rd_sz, THRESHOLD_RD);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tstatus = decode_threshold_hint(xdr, bitmap, &res->wr_sz, THRESHOLD_WR);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tstatus = decode_threshold_hint(xdr, bitmap, &res->rd_io_sz,\n\t\t\t\t       THRESHOLD_RD_IO);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tstatus = decode_threshold_hint(xdr, bitmap, &res->wr_io_sz,\n\t\t\t\t       THRESHOLD_WR_IO);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tstatus = verify_attr_len(xdr, savep, attrlen);\n\tres->bm = bitmap[0];\n\n\tdprintk(\"%s bm=0x%x rd_sz=%llu wr_sz=%llu rd_io=%llu wr_io=%llu\\n\",\n\t\t __func__, res->bm, res->rd_sz, res->wr_sz, res->rd_io_sz,\n\t\tres->wr_io_sz);\nxdr_error:\n\tdprintk(\"%s ret=%d!\\n\", __func__, status);\n\treturn status;\n}\n\n/*\n * Thresholds on pNFS direct I/O vrs MDS I/O\n */\nstatic int decode_attr_mdsthreshold(struct xdr_stream *xdr,\n\t\t\t\t    uint32_t *bitmap,\n\t\t\t\t    struct nfs4_threshold *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\tuint32_t num;\n\n\tif (unlikely(bitmap[2] & (FATTR4_WORD2_MDSTHRESHOLD - 1U)))\n\t\treturn -EIO;\n\tif (bitmap[2] & FATTR4_WORD2_MDSTHRESHOLD) {\n\t\t/* Did the server return an unrequested attribute? */\n\t\tif (unlikely(res == NULL))\n\t\t\treturn -EREMOTEIO;\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tnum = be32_to_cpup(p);\n\t\tif (num == 0)\n\t\t\treturn 0;\n\t\tif (num > 1)\n\t\t\tprintk(KERN_INFO \"%s: Warning: Multiple pNFS layout \"\n\t\t\t\t\"drivers per filesystem not supported\\n\",\n\t\t\t\t__func__);\n\n\t\tstatus = decode_first_threshold_item4(xdr, res);\n\t\tbitmap[2] &= ~FATTR4_WORD2_MDSTHRESHOLD;\n\t}\n\treturn status;\n}\n\nstatic int decode_getfattr_attrs(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\tstruct nfs_fattr *fattr, struct nfs_fh *fh,\n\t\tstruct nfs4_fs_locations *fs_loc, struct nfs4_label *label,\n\t\tconst struct nfs_server *server)\n{\n\tint status;\n\tumode_t fmode = 0;\n\tuint32_t type;\n\tint32_t err;\n\n\tstatus = decode_attr_type(xdr, bitmap, &type);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->mode = 0;\n\tif (status != 0) {\n\t\tfattr->mode |= nfs_type2fmt[type];\n\t\tfattr->valid |= status;\n\t}\n\n\tstatus = decode_attr_change(xdr, bitmap, &fattr->change_attr);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_size(xdr, bitmap, &fattr->size);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_fsid(xdr, bitmap, &fattr->fsid);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\terr = 0;\n\tstatus = decode_attr_error(xdr, bitmap, &err);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_filehandle(xdr, bitmap, fh);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_fileid(xdr, bitmap, &fattr->fileid);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_fs_locations(xdr, bitmap, fs_loc);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = -EIO;\n\tif (unlikely(bitmap[0]))\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_mode(xdr, bitmap, &fmode);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tif (status != 0) {\n\t\tfattr->mode |= fmode;\n\t\tfattr->valid |= status;\n\t}\n\n\tstatus = decode_attr_nlink(xdr, bitmap, &fattr->nlink);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_owner(xdr, bitmap, server, &fattr->uid, fattr->owner_name);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_group(xdr, bitmap, server, &fattr->gid, fattr->group_name);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_rdev(xdr, bitmap, &fattr->rdev);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_space_used(xdr, bitmap, &fattr->du.nfs3.used);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_time_access(xdr, bitmap, &fattr->atime);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_time_metadata(xdr, bitmap, &fattr->ctime);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_time_modify(xdr, bitmap, &fattr->mtime);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = decode_attr_mounted_on_fileid(xdr, bitmap, &fattr->mounted_on_fileid);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\tfattr->valid |= status;\n\n\tstatus = -EIO;\n\tif (unlikely(bitmap[1]))\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_mdsthreshold(xdr, bitmap, fattr->mdsthreshold);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tif (label) {\n\t\tstatus = decode_attr_security_label(xdr, bitmap, label);\n\t\tif (status < 0)\n\t\t\tgoto xdr_error;\n\t\tfattr->valid |= status;\n\t}\n\nxdr_error:\n\tdprintk(\"%s: xdr returned %d\\n\", __func__, -status);\n\treturn status;\n}\n\nstatic int decode_getfattr_generic(struct xdr_stream *xdr, struct nfs_fattr *fattr,\n\t\tstruct nfs_fh *fh, struct nfs4_fs_locations *fs_loc,\n\t\tstruct nfs4_label *label, const struct nfs_server *server)\n{\n\tunsigned int savep;\n\tuint32_t attrlen,\n\t\t bitmap[3] = {0};\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_GETATTR);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_bitmap(xdr, bitmap);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_length(xdr, &attrlen, &savep);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tstatus = decode_getfattr_attrs(xdr, bitmap, fattr, fh, fs_loc,\n\t\t\t\t\tlabel, server);\n\tif (status < 0)\n\t\tgoto xdr_error;\n\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d\\n\", __func__, -status);\n\treturn status;\n}\n\nstatic int decode_getfattr_label(struct xdr_stream *xdr, struct nfs_fattr *fattr,\n\t\tstruct nfs4_label *label, const struct nfs_server *server)\n{\n\treturn decode_getfattr_generic(xdr, fattr, NULL, NULL, label, server);\n}\n\nstatic int decode_getfattr(struct xdr_stream *xdr, struct nfs_fattr *fattr,\n\t\tconst struct nfs_server *server)\n{\n\treturn decode_getfattr_generic(xdr, fattr, NULL, NULL, NULL, server);\n}\n\n/*\n * Decode potentially multiple layout types.\n */\nstatic int decode_pnfs_layout_types(struct xdr_stream *xdr,\n\t\t\t\t    struct nfs_fsinfo *fsinfo)\n{\n\t__be32 *p;\n\tuint32_t i;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tfsinfo->nlayouttypes = be32_to_cpup(p);\n\n\t/* pNFS is not supported by the underlying file system */\n\tif (fsinfo->nlayouttypes == 0)\n\t\treturn 0;\n\n\t/* Decode and set first layout type, move xdr->p past unused types */\n\tp = xdr_inline_decode(xdr, fsinfo->nlayouttypes * 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\n\t/* If we get too many, then just cap it at the max */\n\tif (fsinfo->nlayouttypes > NFS_MAX_LAYOUT_TYPES) {\n\t\tprintk(KERN_INFO \"NFS: %s: Warning: Too many (%u) pNFS layout types\\n\",\n\t\t\t__func__, fsinfo->nlayouttypes);\n\t\tfsinfo->nlayouttypes = NFS_MAX_LAYOUT_TYPES;\n\t}\n\n\tfor(i = 0; i < fsinfo->nlayouttypes; ++i)\n\t\tfsinfo->layouttype[i] = be32_to_cpup(p++);\n\treturn 0;\n}\n\n/*\n * The type of file system exported.\n * Note we must ensure that layouttype is set in any non-error case.\n */\nstatic int decode_attr_pnfstype(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\tstruct nfs_fsinfo *fsinfo)\n{\n\tint status = 0;\n\n\tdprintk(\"%s: bitmap is %x\\n\", __func__, bitmap[1]);\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_FS_LAYOUT_TYPES - 1U)))\n\t\treturn -EIO;\n\tif (bitmap[1] & FATTR4_WORD1_FS_LAYOUT_TYPES) {\n\t\tstatus = decode_pnfs_layout_types(xdr, fsinfo);\n\t\tbitmap[1] &= ~FATTR4_WORD1_FS_LAYOUT_TYPES;\n\t}\n\treturn status;\n}\n\n/*\n * The prefered block size for layout directed io\n */\nstatic int decode_attr_layout_blksize(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\t      uint32_t *res)\n{\n\t__be32 *p;\n\n\tdprintk(\"%s: bitmap is %x\\n\", __func__, bitmap[2]);\n\t*res = 0;\n\tif (bitmap[2] & FATTR4_WORD2_LAYOUT_BLKSIZE) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*res = be32_to_cpup(p);\n\t\tbitmap[2] &= ~FATTR4_WORD2_LAYOUT_BLKSIZE;\n\t}\n\treturn 0;\n}\n\n/*\n * The granularity of a CLONE operation.\n */\nstatic int decode_attr_clone_blksize(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\t     uint32_t *res)\n{\n\t__be32 *p;\n\n\tdprintk(\"%s: bitmap is %x\\n\", __func__, bitmap[2]);\n\t*res = 0;\n\tif (bitmap[2] & FATTR4_WORD2_CLONE_BLKSIZE) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*res = be32_to_cpup(p);\n\t\tbitmap[2] &= ~FATTR4_WORD2_CLONE_BLKSIZE;\n\t}\n\treturn 0;\n}\n\nstatic int decode_fsinfo(struct xdr_stream *xdr, struct nfs_fsinfo *fsinfo)\n{\n\tunsigned int savep;\n\tuint32_t attrlen, bitmap[3];\n\tint status;\n\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\n\tfsinfo->rtmult = fsinfo->wtmult = 512;\t/* ??? */\n\n\tif ((status = decode_attr_lease_time(xdr, bitmap, &fsinfo->lease_time)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_maxfilesize(xdr, bitmap, &fsinfo->maxfilesize)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_maxread(xdr, bitmap, &fsinfo->rtmax)) != 0)\n\t\tgoto xdr_error;\n\tfsinfo->rtpref = fsinfo->dtpref = fsinfo->rtmax;\n\tif ((status = decode_attr_maxwrite(xdr, bitmap, &fsinfo->wtmax)) != 0)\n\t\tgoto xdr_error;\n\tfsinfo->wtpref = fsinfo->wtmax;\n\n\tstatus = -EIO;\n\tif (unlikely(bitmap[0]))\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_time_delta(xdr, bitmap, &fsinfo->time_delta);\n\tif (status != 0)\n\t\tgoto xdr_error;\n\tstatus = decode_attr_pnfstype(xdr, bitmap, fsinfo);\n\tif (status != 0)\n\t\tgoto xdr_error;\n\n\tstatus = -EIO;\n\tif (unlikely(bitmap[1]))\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_layout_blksize(xdr, bitmap, &fsinfo->blksize);\n\tif (status)\n\t\tgoto xdr_error;\n\tstatus = decode_attr_clone_blksize(xdr, bitmap, &fsinfo->clone_blksize);\n\tif (status)\n\t\tgoto xdr_error;\n\n\tstatus = decode_attr_xattrsupport(xdr, bitmap,\n\t\t\t\t\t  &fsinfo->xattr_support);\n\tif (status)\n\t\tgoto xdr_error;\n\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}\n\nstatic int decode_getfh(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\tuint32_t len;\n\tint status;\n\n\t/* Zero handle first to allow comparisons */\n\tmemset(fh, 0, sizeof(*fh));\n\n\tstatus = decode_op_hdr(xdr, OP_GETFH);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tlen = be32_to_cpup(p);\n\tif (len > NFS4_FHSIZE)\n\t\treturn -EIO;\n\tfh->size = len;\n\tp = xdr_inline_decode(xdr, len);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tmemcpy(fh->data, p, len);\n\treturn 0;\n}\n\nstatic int decode_link(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_LINK);\n\tif (status)\n\t\treturn status;\n\treturn decode_change_info(xdr, cinfo);\n}\n\n/*\n * We create the owner, so we know a proper owner.id length is 4.\n */\nstatic int decode_lock_denied (struct xdr_stream *xdr, struct file_lock *fl)\n{\n\tuint64_t offset, length, clientid;\n\t__be32 *p;\n\tuint32_t namelen, type;\n\n\tp = xdr_inline_decode(xdr, 32); /* read 32 bytes */\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tp = xdr_decode_hyper(p, &offset); /* read 2 8-byte long words */\n\tp = xdr_decode_hyper(p, &length);\n\ttype = be32_to_cpup(p++); /* 4 byte read */\n\tif (fl != NULL) { /* manipulate file lock */\n\t\tfl->fl_start = (loff_t)offset;\n\t\tfl->fl_end = fl->fl_start + (loff_t)length - 1;\n\t\tif (length == ~(uint64_t)0)\n\t\t\tfl->fl_end = OFFSET_MAX;\n\t\tfl->fl_type = F_WRLCK;\n\t\tif (type & 1)\n\t\t\tfl->fl_type = F_RDLCK;\n\t\tfl->fl_pid = 0;\n\t}\n\tp = xdr_decode_hyper(p, &clientid); /* read 8 bytes */\n\tnamelen = be32_to_cpup(p); /* read 4 bytes */  /* have read all 32 bytes now */\n\tp = xdr_inline_decode(xdr, namelen); /* variable size field */\n\tif (likely(!p))\n\t\treturn -EIO;\n\treturn -NFS4ERR_DENIED;\n}\n\nstatic int decode_lock(struct xdr_stream *xdr, struct nfs_lock_res *res)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_LOCK);\n\tif (status == -EIO)\n\t\tgoto out;\n\tif (status == 0) {\n\t\tstatus = decode_lock_stateid(xdr, &res->stateid);\n\t\tif (unlikely(status))\n\t\t\tgoto out;\n\t} else if (status == -NFS4ERR_DENIED)\n\t\tstatus = decode_lock_denied(xdr, NULL);\n\tif (res->open_seqid != NULL)\n\t\tnfs_increment_open_seqid(status, res->open_seqid);\n\tnfs_increment_lock_seqid(status, res->lock_seqid);\nout:\n\treturn status;\n}\n\nstatic int decode_lockt(struct xdr_stream *xdr, struct nfs_lockt_res *res)\n{\n\tint status;\n\tstatus = decode_op_hdr(xdr, OP_LOCKT);\n\tif (status == -NFS4ERR_DENIED)\n\t\treturn decode_lock_denied(xdr, res->denied);\n\treturn status;\n}\n\nstatic int decode_locku(struct xdr_stream *xdr, struct nfs_locku_res *res)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_LOCKU);\n\tif (status != -EIO)\n\t\tnfs_increment_lock_seqid(status, res->seqid);\n\tif (status == 0)\n\t\tstatus = decode_lock_stateid(xdr, &res->stateid);\n\treturn status;\n}\n\nstatic int decode_release_lockowner(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_RELEASE_LOCKOWNER);\n}\n\nstatic int decode_lookup(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_LOOKUP);\n}\n\nstatic int decode_lookupp(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_LOOKUPP);\n}\n\n/* This is too sick! */\nstatic int decode_space_limit(struct xdr_stream *xdr,\n\t\tunsigned long *pagemod_limit)\n{\n\t__be32 *p;\n\tuint32_t limit_type, nblocks, blocksize;\n\tu64 maxsize = 0;\n\n\tp = xdr_inline_decode(xdr, 12);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tlimit_type = be32_to_cpup(p++);\n\tswitch (limit_type) {\n\tcase NFS4_LIMIT_SIZE:\n\t\txdr_decode_hyper(p, &maxsize);\n\t\tbreak;\n\tcase NFS4_LIMIT_BLOCKS:\n\t\tnblocks = be32_to_cpup(p++);\n\t\tblocksize = be32_to_cpup(p);\n\t\tmaxsize = (uint64_t)nblocks * (uint64_t)blocksize;\n\t}\n\tmaxsize >>= PAGE_SHIFT;\n\t*pagemod_limit = min_t(u64, maxsize, ULONG_MAX);\n\treturn 0;\n}\n\nstatic int decode_rw_delegation(struct xdr_stream *xdr,\n\t\tuint32_t delegation_type,\n\t\tstruct nfs_openres *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_delegation_stateid(xdr, &res->delegation);\n\tif (unlikely(status))\n\t\treturn status;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tres->do_recall = be32_to_cpup(p);\n\n\tswitch (delegation_type) {\n\tcase NFS4_OPEN_DELEGATE_READ:\n\t\tres->delegation_type = FMODE_READ;\n\t\tbreak;\n\tcase NFS4_OPEN_DELEGATE_WRITE:\n\t\tres->delegation_type = FMODE_WRITE|FMODE_READ;\n\t\tif (decode_space_limit(xdr, &res->pagemod_limit) < 0)\n\t\t\t\treturn -EIO;\n\t}\n\treturn decode_ace(xdr, NULL);\n}\n\nstatic int decode_no_delegation(struct xdr_stream *xdr, struct nfs_openres *res)\n{\n\t__be32 *p;\n\tuint32_t why_no_delegation;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\twhy_no_delegation = be32_to_cpup(p);\n\tswitch (why_no_delegation) {\n\t\tcase WND4_CONTENTION:\n\t\tcase WND4_RESOURCE:\n\t\t\txdr_inline_decode(xdr, 4);\n\t\t\t/* Ignore for now */\n\t}\n\treturn 0;\n}\n\nstatic int decode_delegation(struct xdr_stream *xdr, struct nfs_openres *res)\n{\n\t__be32 *p;\n\tuint32_t delegation_type;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tdelegation_type = be32_to_cpup(p);\n\tres->delegation_type = 0;\n\tswitch (delegation_type) {\n\tcase NFS4_OPEN_DELEGATE_NONE:\n\t\treturn 0;\n\tcase NFS4_OPEN_DELEGATE_READ:\n\tcase NFS4_OPEN_DELEGATE_WRITE:\n\t\treturn decode_rw_delegation(xdr, delegation_type, res);\n\tcase NFS4_OPEN_DELEGATE_NONE_EXT:\n\t\treturn decode_no_delegation(xdr, res);\n\t}\n\treturn -EIO;\n}\n\nstatic int decode_open(struct xdr_stream *xdr, struct nfs_openres *res)\n{\n\t__be32 *p;\n\tuint32_t savewords, bmlen, i;\n\tint status;\n\n\tif (!__decode_op_hdr(xdr, OP_OPEN, &status))\n\t\treturn status;\n\tnfs_increment_open_seqid(status, res->seqid);\n\tif (status)\n\t\treturn status;\n\tstatus = decode_open_stateid(xdr, &res->stateid);\n\tif (unlikely(status))\n\t\treturn status;\n\n\tdecode_change_info(xdr, &res->cinfo);\n\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tres->rflags = be32_to_cpup(p++);\n\tbmlen = be32_to_cpup(p);\n\tif (bmlen > 10)\n\t\tgoto xdr_error;\n\n\tp = xdr_inline_decode(xdr, bmlen << 2);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tsavewords = min_t(uint32_t, bmlen, NFS4_BITMAP_SIZE);\n\tfor (i = 0; i < savewords; ++i)\n\t\tres->attrset[i] = be32_to_cpup(p++);\n\tfor (; i < NFS4_BITMAP_SIZE; i++)\n\t\tres->attrset[i] = 0;\n\n\treturn decode_delegation(xdr, res);\nxdr_error:\n\tdprintk(\"%s: Bitmap too large! Length = %u\\n\", __func__, bmlen);\n\treturn -EIO;\n}\n\nstatic int decode_open_confirm(struct xdr_stream *xdr, struct nfs_open_confirmres *res)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_OPEN_CONFIRM);\n\tif (status != -EIO)\n\t\tnfs_increment_open_seqid(status, res->seqid);\n\tif (!status)\n\t\tstatus = decode_open_stateid(xdr, &res->stateid);\n\treturn status;\n}\n\nstatic int decode_open_downgrade(struct xdr_stream *xdr, struct nfs_closeres *res)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_OPEN_DOWNGRADE);\n\tif (status != -EIO)\n\t\tnfs_increment_open_seqid(status, res->seqid);\n\tif (!status)\n\t\tstatus = decode_open_stateid(xdr, &res->stateid);\n\treturn status;\n}\n\nstatic int decode_putfh(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_PUTFH);\n}\n\nstatic int decode_putrootfh(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_PUTROOTFH);\n}\n\nstatic int decode_read(struct xdr_stream *xdr, struct rpc_rqst *req,\n\t\t       struct nfs_pgio_res *res)\n{\n\t__be32 *p;\n\tuint32_t count, eof, recvd;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_READ);\n\tif (status)\n\t\treturn status;\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\teof = be32_to_cpup(p++);\n\tcount = be32_to_cpup(p);\n\trecvd = xdr_read_pages(xdr, count);\n\tif (count > recvd) {\n\t\tdprintk(\"NFS: server cheating in read reply: \"\n\t\t\t\t\"count %u > recvd %u\\n\", count, recvd);\n\t\tcount = recvd;\n\t\teof = 0;\n\t}\n\tres->eof = eof;\n\tres->count = count;\n\treturn 0;\n}\n\nstatic int decode_readdir(struct xdr_stream *xdr, struct rpc_rqst *req, struct nfs4_readdir_res *readdir)\n{\n\tint\t\tstatus;\n\t__be32\t\tverf[2];\n\n\tstatus = decode_op_hdr(xdr, OP_READDIR);\n\tif (!status)\n\t\tstatus = decode_verifier(xdr, readdir->verifier.data);\n\tif (unlikely(status))\n\t\treturn status;\n\tmemcpy(verf, readdir->verifier.data, sizeof(verf));\n\tdprintk(\"%s: verifier = %08x:%08x\\n\",\n\t\t\t__func__, verf[0], verf[1]);\n\treturn xdr_read_pages(xdr, xdr->buf->page_len);\n}\n\nstatic int decode_readlink(struct xdr_stream *xdr, struct rpc_rqst *req)\n{\n\tstruct xdr_buf *rcvbuf = &req->rq_rcv_buf;\n\tu32 len, recvd;\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_READLINK);\n\tif (status)\n\t\treturn status;\n\n\t/* Convert length of symlink */\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tlen = be32_to_cpup(p);\n\tif (len >= rcvbuf->page_len || len <= 0) {\n\t\tdprintk(\"nfs: server returned giant symlink!\\n\");\n\t\treturn -ENAMETOOLONG;\n\t}\n\trecvd = xdr_read_pages(xdr, len);\n\tif (recvd < len) {\n\t\tdprintk(\"NFS: server cheating in readlink reply: \"\n\t\t\t\t\"count %u > recvd %u\\n\", len, recvd);\n\t\treturn -EIO;\n\t}\n\t/*\n\t * The XDR encode routine has set things up so that\n\t * the link text will be copied directly into the\n\t * buffer.  We just have to do overflow-checking,\n\t * and null-terminate the text (the VFS expects\n\t * null-termination).\n\t */\n\txdr_terminate_string(rcvbuf, len);\n\treturn 0;\n}\n\nstatic int decode_remove(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_REMOVE);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_change_info(xdr, cinfo);\nout:\n\treturn status;\n}\n\nstatic int decode_rename(struct xdr_stream *xdr, struct nfs4_change_info *old_cinfo,\n\t      struct nfs4_change_info *new_cinfo)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_RENAME);\n\tif (status)\n\t\tgoto out;\n\tif ((status = decode_change_info(xdr, old_cinfo)))\n\t\tgoto out;\n\tstatus = decode_change_info(xdr, new_cinfo);\nout:\n\treturn status;\n}\n\nstatic int decode_renew(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_RENEW);\n}\n\nstatic int\ndecode_restorefh(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_RESTOREFH);\n}\n\nstatic int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,\n\t\t\t struct nfs_getaclres *res)\n{\n\tunsigned int savep;\n\tuint32_t attrlen,\n\t\t bitmap[3] = {0};\n\tint status;\n\n\tres->acl_len = 0;\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto out;\n\n\txdr_enter_page(xdr, xdr->buf->page_len);\n\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto out;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto out;\n\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_ACL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_ACL)) {\n\n\t\t/* The bitmap (xdr len + bitmaps) and the attr xdr len words\n\t\t * are stored with the acl data to handle the problem of\n\t\t * variable length bitmaps.*/\n\t\tres->acl_data_offset = xdr_page_pos(xdr);\n\t\tres->acl_len = attrlen;\n\n\t\t/* Check for receive buffer overflow */\n\t\tif (res->acl_len > (xdr->nwords << 2) ||\n\t\t    res->acl_len + res->acl_data_offset > xdr->buf->page_len) {\n\t\t\tres->acl_flags |= NFS4_ACL_TRUNC;\n\t\t\tdprintk(\"NFS: acl reply: attrlen %u > page_len %u\\n\",\n\t\t\t\t\tattrlen, xdr->nwords << 2);\n\t\t}\n\t} else\n\t\tstatus = -EOPNOTSUPP;\n\nout:\n\treturn status;\n}\n\nstatic int\ndecode_savefh(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_SAVEFH);\n}\n\nstatic int decode_setattr(struct xdr_stream *xdr)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_SETATTR);\n\tif (status)\n\t\treturn status;\n\tif (decode_bitmap4(xdr, NULL, 0) >= 0)\n\t\treturn 0;\n\treturn -EIO;\n}\n\nstatic int decode_setclientid(struct xdr_stream *xdr, struct nfs4_setclientid_res *res)\n{\n\t__be32 *p;\n\tuint32_t opnum;\n\tint32_t nfserr;\n\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\topnum = be32_to_cpup(p++);\n\tif (opnum != OP_SETCLIENTID) {\n\t\tdprintk(\"nfs: decode_setclientid: Server returned operation\"\n\t\t\t\" %d\\n\", opnum);\n\t\treturn -EIO;\n\t}\n\tnfserr = be32_to_cpup(p);\n\tif (nfserr == NFS_OK) {\n\t\tp = xdr_inline_decode(xdr, 8 + NFS4_VERIFIER_SIZE);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tp = xdr_decode_hyper(p, &res->clientid);\n\t\tmemcpy(res->confirm.data, p, NFS4_VERIFIER_SIZE);\n\t} else if (nfserr == NFSERR_CLID_INUSE) {\n\t\tuint32_t len;\n\n\t\t/* skip netid string */\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlen = be32_to_cpup(p);\n\t\tp = xdr_inline_decode(xdr, len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\n\t\t/* skip uaddr string */\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlen = be32_to_cpup(p);\n\t\tp = xdr_inline_decode(xdr, len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\treturn -NFSERR_CLID_INUSE;\n\t} else\n\t\treturn nfs4_stat_to_errno(nfserr);\n\n\treturn 0;\n}\n\nstatic int decode_setclientid_confirm(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_SETCLIENTID_CONFIRM);\n}\n\nstatic int decode_write(struct xdr_stream *xdr, struct nfs_pgio_res *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_WRITE);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tres->count = be32_to_cpup(p++);\n\tres->verf->committed = be32_to_cpup(p++);\n\treturn decode_write_verifier(xdr, &res->verf->verifier);\n}\n\nstatic int decode_delegreturn(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_DELEGRETURN);\n}\n\nstatic int decode_secinfo_gss(struct xdr_stream *xdr,\n\t\t\t      struct nfs4_secinfo4 *flavor)\n{\n\tu32 oid_len;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\toid_len = be32_to_cpup(p);\n\tif (oid_len > GSS_OID_MAX_LEN)\n\t\treturn -EINVAL;\n\n\tp = xdr_inline_decode(xdr, oid_len);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tmemcpy(flavor->flavor_info.oid.data, p, oid_len);\n\tflavor->flavor_info.oid.len = oid_len;\n\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tflavor->flavor_info.qop = be32_to_cpup(p++);\n\tflavor->flavor_info.service = be32_to_cpup(p);\n\n\treturn 0;\n}\n\nstatic int decode_secinfo_common(struct xdr_stream *xdr, struct nfs4_secinfo_res *res)\n{\n\tstruct nfs4_secinfo4 *sec_flavor;\n\tunsigned int i, num_flavors;\n\tint status;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\n\tres->flavors->num_flavors = 0;\n\tnum_flavors = be32_to_cpup(p);\n\n\tfor (i = 0; i < num_flavors; i++) {\n\t\tsec_flavor = &res->flavors->flavors[i];\n\t\tif ((char *)&sec_flavor[1] - (char *)res->flavors > PAGE_SIZE)\n\t\t\tbreak;\n\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tsec_flavor->flavor = be32_to_cpup(p);\n\n\t\tif (sec_flavor->flavor == RPC_AUTH_GSS) {\n\t\t\tstatus = decode_secinfo_gss(xdr, sec_flavor);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t\tres->flavors->num_flavors++;\n\t}\n\n\tstatus = 0;\nout:\n\treturn status;\n}\n\nstatic int decode_secinfo(struct xdr_stream *xdr, struct nfs4_secinfo_res *res)\n{\n\tint status = decode_op_hdr(xdr, OP_SECINFO);\n\tif (status)\n\t\treturn status;\n\treturn decode_secinfo_common(xdr, res);\n}\n\n#if defined(CONFIG_NFS_V4_1)\nstatic int decode_secinfo_no_name(struct xdr_stream *xdr, struct nfs4_secinfo_res *res)\n{\n\tint status = decode_op_hdr(xdr, OP_SECINFO_NO_NAME);\n\tif (status)\n\t\treturn status;\n\treturn decode_secinfo_common(xdr, res);\n}\n\nstatic int decode_op_map(struct xdr_stream *xdr, struct nfs4_op_map *op_map)\n{\n\t__be32 *p;\n\tuint32_t bitmap_words;\n\tunsigned int i;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (!p)\n\t\treturn -EIO;\n\tbitmap_words = be32_to_cpup(p++);\n\tif (bitmap_words > NFS4_OP_MAP_NUM_WORDS)\n\t\treturn -EIO;\n\tp = xdr_inline_decode(xdr, 4 * bitmap_words);\n\tfor (i = 0; i < bitmap_words; i++)\n\t\top_map->u.words[i] = be32_to_cpup(p++);\n\n\treturn 0;\n}\n\nstatic int decode_exchange_id(struct xdr_stream *xdr,\n\t\t\t      struct nfs41_exchange_id_res *res)\n{\n\t__be32 *p;\n\tuint32_t dummy;\n\tchar *dummy_str;\n\tint status;\n\tuint32_t impl_id_count;\n\n\tstatus = decode_op_hdr(xdr, OP_EXCHANGE_ID);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\txdr_decode_hyper(p, &res->clientid);\n\tp = xdr_inline_decode(xdr, 12);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tres->seqid = be32_to_cpup(p++);\n\tres->flags = be32_to_cpup(p++);\n\n\tres->state_protect.how = be32_to_cpup(p);\n\tswitch (res->state_protect.how) {\n\tcase SP4_NONE:\n\t\tbreak;\n\tcase SP4_MACH_CRED:\n\t\tstatus = decode_op_map(xdr, &res->state_protect.enforce);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = decode_op_map(xdr, &res->state_protect.allow);\n\t\tif (status)\n\t\t\treturn status;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EIO;\n\t}\n\n\t/* server_owner4.so_minor_id */\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tp = xdr_decode_hyper(p, &res->server_owner->minor_id);\n\n\t/* server_owner4.so_major_id */\n\tstatus = decode_opaque_inline(xdr, &dummy, &dummy_str);\n\tif (unlikely(status))\n\t\treturn status;\n\tmemcpy(res->server_owner->major_id, dummy_str, dummy);\n\tres->server_owner->major_id_sz = dummy;\n\n\t/* server_scope4 */\n\tstatus = decode_opaque_inline(xdr, &dummy, &dummy_str);\n\tif (unlikely(status))\n\t\treturn status;\n\tmemcpy(res->server_scope->server_scope, dummy_str, dummy);\n\tres->server_scope->server_scope_sz = dummy;\n\n\t/* Implementation Id */\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\timpl_id_count = be32_to_cpup(p++);\n\n\tif (impl_id_count) {\n\t\t/* nii_domain */\n\t\tstatus = decode_opaque_inline(xdr, &dummy, &dummy_str);\n\t\tif (unlikely(status))\n\t\t\treturn status;\n\t\tmemcpy(res->impl_id->domain, dummy_str, dummy);\n\n\t\t/* nii_name */\n\t\tstatus = decode_opaque_inline(xdr, &dummy, &dummy_str);\n\t\tif (unlikely(status))\n\t\t\treturn status;\n\t\tmemcpy(res->impl_id->name, dummy_str, dummy);\n\n\t\t/* nii_date */\n\t\tp = xdr_inline_decode(xdr, 12);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tp = xdr_decode_hyper(p, &res->impl_id->date.seconds);\n\t\tres->impl_id->date.nseconds = be32_to_cpup(p);\n\n\t\t/* if there's more than one entry, ignore the rest */\n\t}\n\treturn 0;\n}\n\nstatic int decode_chan_attrs(struct xdr_stream *xdr,\n\t\t\t     struct nfs4_channel_attrs *attrs)\n{\n\t__be32 *p;\n\tu32 nr_attrs, val;\n\n\tp = xdr_inline_decode(xdr, 28);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tval = be32_to_cpup(p++);\t/* headerpadsz */\n\tif (val)\n\t\treturn -EINVAL;\t\t/* no support for header padding yet */\n\tattrs->max_rqst_sz = be32_to_cpup(p++);\n\tattrs->max_resp_sz = be32_to_cpup(p++);\n\tattrs->max_resp_sz_cached = be32_to_cpup(p++);\n\tattrs->max_ops = be32_to_cpup(p++);\n\tattrs->max_reqs = be32_to_cpup(p++);\n\tnr_attrs = be32_to_cpup(p);\n\tif (unlikely(nr_attrs > 1)) {\n\t\tprintk(KERN_WARNING \"NFS: %s: Invalid rdma channel attrs \"\n\t\t\t\"count %u\\n\", __func__, nr_attrs);\n\t\treturn -EINVAL;\n\t}\n\tif (nr_attrs == 1) {\n\t\tp = xdr_inline_decode(xdr, 4); /* skip rdma_attrs */\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int decode_sessionid(struct xdr_stream *xdr, struct nfs4_sessionid *sid)\n{\n\treturn decode_opaque_fixed(xdr, sid->data, NFS4_MAX_SESSIONID_LEN);\n}\n\nstatic int decode_bind_conn_to_session(struct xdr_stream *xdr,\n\t\t\t\tstruct nfs41_bind_conn_to_session_res *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_BIND_CONN_TO_SESSION);\n\tif (!status)\n\t\tstatus = decode_sessionid(xdr, &res->sessionid);\n\tif (unlikely(status))\n\t\treturn status;\n\n\t/* dir flags, rdma mode bool */\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\n\tres->dir = be32_to_cpup(p++);\n\tif (res->dir == 0 || res->dir > NFS4_CDFS4_BOTH)\n\t\treturn -EIO;\n\tif (be32_to_cpup(p) == 0)\n\t\tres->use_conn_in_rdma_mode = false;\n\telse\n\t\tres->use_conn_in_rdma_mode = true;\n\n\treturn 0;\n}\n\nstatic int decode_create_session(struct xdr_stream *xdr,\n\t\t\t\t struct nfs41_create_session_res *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_CREATE_SESSION);\n\tif (!status)\n\t\tstatus = decode_sessionid(xdr, &res->sessionid);\n\tif (unlikely(status))\n\t\treturn status;\n\n\t/* seqid, flags */\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tres->seqid = be32_to_cpup(p++);\n\tres->flags = be32_to_cpup(p);\n\n\t/* Channel attributes */\n\tstatus = decode_chan_attrs(xdr, &res->fc_attrs);\n\tif (!status)\n\t\tstatus = decode_chan_attrs(xdr, &res->bc_attrs);\n\treturn status;\n}\n\nstatic int decode_destroy_session(struct xdr_stream *xdr, void *dummy)\n{\n\treturn decode_op_hdr(xdr, OP_DESTROY_SESSION);\n}\n\nstatic int decode_destroy_clientid(struct xdr_stream *xdr, void *dummy)\n{\n\treturn decode_op_hdr(xdr, OP_DESTROY_CLIENTID);\n}\n\nstatic int decode_reclaim_complete(struct xdr_stream *xdr, void *dummy)\n{\n\treturn decode_op_hdr(xdr, OP_RECLAIM_COMPLETE);\n}\n#endif /* CONFIG_NFS_V4_1 */\n\nstatic int decode_sequence(struct xdr_stream *xdr,\n\t\t\t   struct nfs4_sequence_res *res,\n\t\t\t   struct rpc_rqst *rqstp)\n{\n#if defined(CONFIG_NFS_V4_1)\n\tstruct nfs4_session *session;\n\tstruct nfs4_sessionid id;\n\tu32 dummy;\n\tint status;\n\t__be32 *p;\n\n\tif (res->sr_slot == NULL)\n\t\treturn 0;\n\tif (!res->sr_slot->table->session)\n\t\treturn 0;\n\n\tstatus = decode_op_hdr(xdr, OP_SEQUENCE);\n\tif (!status)\n\t\tstatus = decode_sessionid(xdr, &id);\n\tif (unlikely(status))\n\t\tgoto out_err;\n\n\t/*\n\t * If the server returns different values for sessionID, slotID or\n\t * sequence number, the server is looney tunes.\n\t */\n\tstatus = -EREMOTEIO;\n\tsession = res->sr_slot->table->session;\n\n\tif (memcmp(id.data, session->sess_id.data,\n\t\t   NFS4_MAX_SESSIONID_LEN)) {\n\t\tdprintk(\"%s Invalid session id\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\n\tp = xdr_inline_decode(xdr, 20);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\n\t/* seqid */\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != res->sr_slot->seq_nr) {\n\t\tdprintk(\"%s Invalid sequence number\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\t/* slot id */\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != res->sr_slot->slot_nr) {\n\t\tdprintk(\"%s Invalid slot id\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\t/* highest slot id */\n\tres->sr_highest_slotid = be32_to_cpup(p++);\n\t/* target highest slot id */\n\tres->sr_target_highest_slotid = be32_to_cpup(p++);\n\t/* result flags */\n\tres->sr_status_flags = be32_to_cpup(p);\n\tstatus = 0;\nout_err:\n\tres->sr_status = status;\n\treturn status;\nout_overflow:\n\tstatus = -EIO;\n\tgoto out_err;\n#else  /* CONFIG_NFS_V4_1 */\n\treturn 0;\n#endif /* CONFIG_NFS_V4_1 */\n}\n\n#if defined(CONFIG_NFS_V4_1)\nstatic int decode_layout_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\tstateid->type = NFS4_LAYOUT_STATEID_TYPE;\n\treturn decode_stateid(xdr, stateid);\n}\n\nstatic int decode_getdeviceinfo(struct xdr_stream *xdr,\n\t\t\t\tstruct nfs4_getdeviceinfo_res *res)\n{\n\tstruct pnfs_device *pdev = res->pdev;\n\t__be32 *p;\n\tuint32_t len, type;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_GETDEVICEINFO);\n\tif (status) {\n\t\tif (status == -ETOOSMALL) {\n\t\t\tp = xdr_inline_decode(xdr, 4);\n\t\t\tif (unlikely(!p))\n\t\t\t\treturn -EIO;\n\t\t\tpdev->mincount = be32_to_cpup(p);\n\t\t\tdprintk(\"%s: Min count too small. mincnt = %u\\n\",\n\t\t\t\t__func__, pdev->mincount);\n\t\t}\n\t\treturn status;\n\t}\n\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\ttype = be32_to_cpup(p++);\n\tif (type != pdev->layout_type) {\n\t\tdprintk(\"%s: layout mismatch req: %u pdev: %u\\n\",\n\t\t\t__func__, pdev->layout_type, type);\n\t\treturn -EINVAL;\n\t}\n\t/*\n\t * Get the length of the opaque device_addr4. xdr_read_pages places\n\t * the opaque device_addr4 in the xdr_buf->pages (pnfs_device->pages)\n\t * and places the remaining xdr data in xdr_buf->tail\n\t */\n\tpdev->mincount = be32_to_cpup(p);\n\tif (xdr_read_pages(xdr, pdev->mincount) != pdev->mincount)\n\t\treturn -EIO;\n\n\t/* Parse notification bitmap, verifying that it is zero. */\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tlen = be32_to_cpup(p);\n\tif (len) {\n\t\tuint32_t i;\n\n\t\tp = xdr_inline_decode(xdr, 4 * len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\n\t\tres->notification = be32_to_cpup(p++);\n\t\tfor (i = 1; i < len; i++) {\n\t\t\tif (be32_to_cpup(p++)) {\n\t\t\t\tdprintk(\"%s: unsupported notification\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int decode_layoutget(struct xdr_stream *xdr, struct rpc_rqst *req,\n\t\t\t    struct nfs4_layoutget_res *res)\n{\n\t__be32 *p;\n\tint status;\n\tu32 layout_count;\n\tu32 recvd;\n\n\tstatus = decode_op_hdr(xdr, OP_LAYOUTGET);\n\tif (status)\n\t\tgoto out;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tres->return_on_close = be32_to_cpup(p);\n\tdecode_layout_stateid(xdr, &res->stateid);\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tlayout_count = be32_to_cpup(p);\n\tif (!layout_count) {\n\t\tdprintk(\"%s: server responded with empty layout array\\n\",\n\t\t\t__func__);\n\t\tstatus = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tp = xdr_inline_decode(xdr, 28);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tp = xdr_decode_hyper(p, &res->range.offset);\n\tp = xdr_decode_hyper(p, &res->range.length);\n\tres->range.iomode = be32_to_cpup(p++);\n\tres->type = be32_to_cpup(p++);\n\tres->layoutp->len = be32_to_cpup(p);\n\n\tdprintk(\"%s roff:%lu rlen:%lu riomode:%d, lo_type:0x%x, lo.len:%d\\n\",\n\t\t__func__,\n\t\t(unsigned long)res->range.offset,\n\t\t(unsigned long)res->range.length,\n\t\tres->range.iomode,\n\t\tres->type,\n\t\tres->layoutp->len);\n\n\trecvd = xdr_read_pages(xdr, res->layoutp->len);\n\tif (res->layoutp->len > recvd) {\n\t\tdprintk(\"NFS: server cheating in layoutget reply: \"\n\t\t\t\t\"layout len %u > recvd %u\\n\",\n\t\t\t\tres->layoutp->len, recvd);\n\t\tstatus = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (layout_count > 1) {\n\t\t/* We only handle a length one array at the moment.  Any\n\t\t * further entries are just ignored.  Note that this means\n\t\t * the client may see a response that is less than the\n\t\t * minimum it requested.\n\t\t */\n\t\tdprintk(\"%s: server responded with %d layouts, dropping tail\\n\",\n\t\t\t__func__, layout_count);\n\t}\n\nout:\n\tres->status = status;\n\treturn status;\nout_overflow:\n\tstatus = -EIO;\n\tgoto out;\n}\n\nstatic int decode_layoutreturn(struct xdr_stream *xdr,\n\t\t\t       struct nfs4_layoutreturn_res *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_LAYOUTRETURN);\n\tif (status)\n\t\treturn status;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tres->lrs_present = be32_to_cpup(p);\n\tif (res->lrs_present)\n\t\tstatus = decode_layout_stateid(xdr, &res->stateid);\n\telse\n\t\tnfs4_stateid_copy(&res->stateid, &invalid_stateid);\n\treturn status;\n}\n\nstatic int decode_layoutcommit(struct xdr_stream *xdr,\n\t\t\t       struct rpc_rqst *req,\n\t\t\t       struct nfs4_layoutcommit_res *res)\n{\n\t__be32 *p;\n\t__u32 sizechanged;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_LAYOUTCOMMIT);\n\tres->status = status;\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tsizechanged = be32_to_cpup(p);\n\n\tif (sizechanged) {\n\t\t/* throw away new size */\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int decode_test_stateid(struct xdr_stream *xdr,\n\t\t\t       struct nfs41_test_stateid_res *res)\n{\n\t__be32 *p;\n\tint status;\n\tint num_res;\n\n\tstatus = decode_op_hdr(xdr, OP_TEST_STATEID);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tnum_res = be32_to_cpup(p++);\n\tif (num_res != 1)\n\t\treturn -EIO;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\tres->status = be32_to_cpup(p++);\n\n\treturn status;\n}\n\nstatic int decode_free_stateid(struct xdr_stream *xdr,\n\t\t\t       struct nfs41_free_stateid_res *res)\n{\n\tres->status = decode_op_hdr(xdr, OP_FREE_STATEID);\n\treturn res->status;\n}\n#else\nstatic inline\nint decode_layoutreturn(struct xdr_stream *xdr,\n\t\t\t       struct nfs4_layoutreturn_res *res)\n{\n\treturn 0;\n}\n\nstatic int decode_layoutget(struct xdr_stream *xdr, struct rpc_rqst *req,\n\t\t\t    struct nfs4_layoutget_res *res)\n{\n\treturn 0;\n}\n\n#endif /* CONFIG_NFS_V4_1 */\n\n/*\n * END OF \"GENERIC\" DECODE ROUTINES.\n */\n\n/*\n * Decode OPEN_DOWNGRADE response\n */\nstatic int nfs4_xdr_dec_open_downgrade(struct rpc_rqst *rqstp,\n\t\t\t\t       struct xdr_stream *xdr,\n\t\t\t\t       void *data)\n{\n\tstruct nfs_closeres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tif (res->lr_res) {\n\t\tstatus = decode_layoutreturn(xdr, res->lr_res);\n\t\tres->lr_ret = status;\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tstatus = decode_open_downgrade(xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode ACCESS response\n */\nstatic int nfs4_xdr_dec_access(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       void *data)\n{\n\tstruct nfs4_accessres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_access(xdr, &res->supported, &res->access);\n\tif (status != 0)\n\t\tgoto out;\n\tif (res->fattr)\n\t\tdecode_getfattr(xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode LOOKUP response\n */\nstatic int nfs4_xdr_dec_lookup(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       void *data)\n{\n\tstruct nfs4_lookup_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_lookup(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfh(xdr, res->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfattr_label(xdr, res->fattr, res->label, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode LOOKUPP response\n */\nstatic int nfs4_xdr_dec_lookupp(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\tvoid *data)\n{\n\tstruct nfs4_lookupp_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_lookupp(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfh(xdr, res->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfattr_label(xdr, res->fattr, res->label, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode LOOKUP_ROOT response\n */\nstatic int nfs4_xdr_dec_lookup_root(struct rpc_rqst *rqstp,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    void *data)\n{\n\tstruct nfs4_lookup_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putrootfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfh(xdr, res->fh);\n\tif (status == 0)\n\t\tstatus = decode_getfattr_label(xdr, res->fattr,\n\t\t\t\t\t\tres->label, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode REMOVE response\n */\nstatic int nfs4_xdr_dec_remove(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       void *data)\n{\n\tstruct nfs_removeres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_remove(xdr, &res->cinfo);\nout:\n\treturn status;\n}\n\n/*\n * Decode RENAME response\n */\nstatic int nfs4_xdr_dec_rename(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       void *data)\n{\n\tstruct nfs_renameres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_savefh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_rename(xdr, &res->old_cinfo, &res->new_cinfo);\nout:\n\treturn status;\n}\n\n/*\n * Decode LINK response\n */\nstatic int nfs4_xdr_dec_link(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t     void *data)\n{\n\tstruct nfs4_link_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_savefh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_link(xdr, &res->cinfo);\n\tif (status)\n\t\tgoto out;\n\t/*\n\t * Note order: OP_LINK leaves the directory as the current\n\t *             filehandle.\n\t */\n\tstatus = decode_restorefh(xdr);\n\tif (status)\n\t\tgoto out;\n\tdecode_getfattr_label(xdr, res->fattr, res->label, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode CREATE response\n */\nstatic int nfs4_xdr_dec_create(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       void *data)\n{\n\tstruct nfs4_create_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_create(xdr, &res->dir_cinfo);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfh(xdr, res->fh);\n\tif (status)\n\t\tgoto out;\n\tdecode_getfattr_label(xdr, res->fattr, res->label, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode SYMLINK response\n */\nstatic int nfs4_xdr_dec_symlink(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t\tvoid *res)\n{\n\treturn nfs4_xdr_dec_create(rqstp, xdr, res);\n}\n\n/*\n * Decode GETATTR response\n */\nstatic int nfs4_xdr_dec_getattr(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t\tvoid *data)\n{\n\tstruct nfs4_getattr_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfattr_label(xdr, res->fattr, res->label, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Encode an SETACL request\n */\nstatic void nfs4_xdr_enc_setacl(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nfs_setaclargs *args = data;\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_setacl(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}\n\n/*\n * Decode SETACL response\n */\nstatic int\nnfs4_xdr_dec_setacl(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t    void *data)\n{\n\tstruct nfs_setaclres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_setattr(xdr);\nout:\n\treturn status;\n}\n\n/*\n * Decode GETACL response\n */\nstatic int\nnfs4_xdr_dec_getacl(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t    void *data)\n{\n\tstruct nfs_getaclres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tif (res->acl_scratch != NULL) {\n\t\tvoid *p = page_address(res->acl_scratch);\n\t\txdr_set_scratch_buffer(xdr, p, PAGE_SIZE);\n\t}\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getacl(xdr, rqstp, res);\n\nout:\n\treturn status;\n}\n\n/*\n * Decode CLOSE response\n */\nstatic int nfs4_xdr_dec_close(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t      void *data)\n{\n\tstruct nfs_closeres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tif (res->lr_res) {\n\t\tstatus = decode_layoutreturn(xdr, res->lr_res);\n\t\tres->lr_ret = status;\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (res->fattr != NULL) {\n\t\tstatus = decode_getfattr(xdr, res->fattr, res->server);\n\t\tif (status != 0)\n\t\t\tgoto out;\n\t}\n\tstatus = decode_close(xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode OPEN response\n */\nstatic int nfs4_xdr_dec_open(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t     void *data)\n{\n\tstruct nfs_openres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_open(xdr, res);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfh(xdr, &res->fh);\n\tif (status)\n\t\tgoto out;\n\tif (res->access_request)\n\t\tdecode_access(xdr, &res->access_supported, &res->access_result);\n\tdecode_getfattr_label(xdr, res->f_attr, res->f_label, res->server);\n\tif (res->lg_res)\n\t\tdecode_layoutget(xdr, rqstp, res->lg_res);\nout:\n\treturn status;\n}\n\n/*\n * Decode OPEN_CONFIRM response\n */\nstatic int nfs4_xdr_dec_open_confirm(struct rpc_rqst *rqstp,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     void *data)\n{\n\tstruct nfs_open_confirmres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_open_confirm(xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode OPEN response\n */\nstatic int nfs4_xdr_dec_open_noattr(struct rpc_rqst *rqstp,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    void *data)\n{\n\tstruct nfs_openres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_open(xdr, res);\n\tif (status)\n\t\tgoto out;\n\tif (res->access_request)\n\t\tdecode_access(xdr, &res->access_supported, &res->access_result);\n\tdecode_getfattr(xdr, res->f_attr, res->server);\n\tif (res->lg_res)\n\t\tdecode_layoutget(xdr, rqstp, res->lg_res);\nout:\n\treturn status;\n}\n\n/*\n * Decode SETATTR response\n */\nstatic int nfs4_xdr_dec_setattr(struct rpc_rqst *rqstp,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tvoid *data)\n{\n\tstruct nfs_setattrres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_setattr(xdr);\n\tif (status)\n\t\tgoto out;\n\tdecode_getfattr_label(xdr, res->fattr, res->label, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode LOCK response\n */\nstatic int nfs4_xdr_dec_lock(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t     void *data)\n{\n\tstruct nfs_lock_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_lock(xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode LOCKT response\n */\nstatic int nfs4_xdr_dec_lockt(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t      void *data)\n{\n\tstruct nfs_lockt_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_lockt(xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode LOCKU response\n */\nstatic int nfs4_xdr_dec_locku(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t      void *data)\n{\n\tstruct nfs_locku_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_locku(xdr, res);\nout:\n\treturn status;\n}\n\nstatic int nfs4_xdr_dec_release_lockowner(struct rpc_rqst *rqstp,\n\t\t\t\t\t  struct xdr_stream *xdr, void *dummy)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_release_lockowner(xdr);\n\treturn status;\n}\n\n/*\n * Decode READLINK response\n */\nstatic int nfs4_xdr_dec_readlink(struct rpc_rqst *rqstp,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t void *data)\n{\n\tstruct nfs4_readlink_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_readlink(xdr, rqstp);\nout:\n\treturn status;\n}\n\n/*\n * Decode READDIR response\n */\nstatic int nfs4_xdr_dec_readdir(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t\tvoid *data)\n{\n\tstruct nfs4_readdir_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_readdir(xdr, rqstp, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode Read response\n */\nstatic int nfs4_xdr_dec_read(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t     void *data)\n{\n\tstruct nfs_pgio_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tres->op_status = hdr.status;\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_read(xdr, rqstp, res);\n\tif (!status)\n\t\tstatus = res->count;\nout:\n\treturn status;\n}\n\n/*\n * Decode WRITE response\n */\nstatic int nfs4_xdr_dec_write(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t      void *data)\n{\n\tstruct nfs_pgio_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tres->op_status = hdr.status;\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_write(xdr, res);\n\tif (status)\n\t\tgoto out;\n\tif (res->fattr)\n\t\tdecode_getfattr(xdr, res->fattr, res->server);\n\tif (!status)\n\t\tstatus = res->count;\nout:\n\treturn status;\n}\n\n/*\n * Decode COMMIT response\n */\nstatic int nfs4_xdr_dec_commit(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       void *data)\n{\n\tstruct nfs_commitres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tres->op_status = hdr.status;\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_commit(xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode FSINFO response\n */\nstatic int nfs4_xdr_dec_fsinfo(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t       void *data)\n{\n\tstruct nfs4_fsinfo_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_sequence(xdr, &res->seq_res, req);\n\tif (!status)\n\t\tstatus = decode_putfh(xdr);\n\tif (!status)\n\t\tstatus = decode_fsinfo(xdr, res->fsinfo);\n\treturn status;\n}\n\n/*\n * Decode PATHCONF response\n */\nstatic int nfs4_xdr_dec_pathconf(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t void *data)\n{\n\tstruct nfs4_pathconf_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_sequence(xdr, &res->seq_res, req);\n\tif (!status)\n\t\tstatus = decode_putfh(xdr);\n\tif (!status)\n\t\tstatus = decode_pathconf(xdr, res->pathconf);\n\treturn status;\n}\n\n/*\n * Decode STATFS response\n */\nstatic int nfs4_xdr_dec_statfs(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t       void *data)\n{\n\tstruct nfs4_statfs_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_sequence(xdr, &res->seq_res, req);\n\tif (!status)\n\t\tstatus = decode_putfh(xdr);\n\tif (!status)\n\t\tstatus = decode_statfs(xdr, res->fsstat);\n\treturn status;\n}\n\n/*\n * Decode GETATTR_BITMAP response\n */\nstatic int nfs4_xdr_dec_server_caps(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    void *data)\n{\n\tstruct nfs4_server_caps_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, req);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_server_caps(xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode RENEW response\n */\nstatic int nfs4_xdr_dec_renew(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t      void *__unused)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_renew(xdr);\n\treturn status;\n}\n\n/*\n * Decode SETCLIENTID response\n */\nstatic int nfs4_xdr_dec_setclientid(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    void *data)\n{\n\tstruct nfs4_setclientid_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_setclientid(xdr, res);\n\treturn status;\n}\n\n/*\n * Decode SETCLIENTID_CONFIRM response\n */\nstatic int nfs4_xdr_dec_setclientid_confirm(struct rpc_rqst *req,\n\t\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t\t    void *data)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_setclientid_confirm(xdr);\n\treturn status;\n}\n\n/*\n * Decode DELEGRETURN response\n */\nstatic int nfs4_xdr_dec_delegreturn(struct rpc_rqst *rqstp,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    void *data)\n{\n\tstruct nfs4_delegreturnres *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status != 0)\n\t\tgoto out;\n\tif (res->lr_res) {\n\t\tstatus = decode_layoutreturn(xdr, res->lr_res);\n\t\tres->lr_ret = status;\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (res->fattr) {\n\t\tstatus = decode_getfattr(xdr, res->fattr, res->server);\n\t\tif (status != 0)\n\t\t\tgoto out;\n\t}\n\tstatus = decode_delegreturn(xdr);\nout:\n\treturn status;\n}\n\n/*\n * Decode FS_LOCATIONS response\n */\nstatic int nfs4_xdr_dec_fs_locations(struct rpc_rqst *req,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     void *data)\n{\n\tstruct nfs4_fs_locations_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, req);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tif (res->migration) {\n\t\txdr_enter_page(xdr, PAGE_SIZE);\n\t\tstatus = decode_getfattr_generic(xdr,\n\t\t\t\t\t&res->fs_locations->fattr,\n\t\t\t\t\t NULL, res->fs_locations,\n\t\t\t\t\t NULL, res->fs_locations->server);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (res->renew)\n\t\t\tstatus = decode_renew(xdr);\n\t} else {\n\t\tstatus = decode_lookup(xdr);\n\t\tif (status)\n\t\t\tgoto out;\n\t\txdr_enter_page(xdr, PAGE_SIZE);\n\t\tstatus = decode_getfattr_generic(xdr,\n\t\t\t\t\t&res->fs_locations->fattr,\n\t\t\t\t\t NULL, res->fs_locations,\n\t\t\t\t\t NULL, res->fs_locations->server);\n\t}\nout:\n\treturn status;\n}\n\n/*\n * Decode SECINFO response\n */\nstatic int nfs4_xdr_dec_secinfo(struct rpc_rqst *rqstp,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tvoid *data)\n{\n\tstruct nfs4_secinfo_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_secinfo(xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode FSID_PRESENT response\n */\nstatic int nfs4_xdr_dec_fsid_present(struct rpc_rqst *rqstp,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     void *data)\n{\n\tstruct nfs4_fsid_present_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfh(xdr, res->fh);\n\tif (status)\n\t\tgoto out;\n\tif (res->renew)\n\t\tstatus = decode_renew(xdr);\nout:\n\treturn status;\n}\n\n#if defined(CONFIG_NFS_V4_1)\n/*\n * Decode BIND_CONN_TO_SESSION response\n */\nstatic int nfs4_xdr_dec_bind_conn_to_session(struct rpc_rqst *rqstp,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tvoid *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_bind_conn_to_session(xdr, res);\n\treturn status;\n}\n\n/*\n * Decode EXCHANGE_ID response\n */\nstatic int nfs4_xdr_dec_exchange_id(struct rpc_rqst *rqstp,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    void *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_exchange_id(xdr, res);\n\treturn status;\n}\n\n/*\n * Decode CREATE_SESSION response\n */\nstatic int nfs4_xdr_dec_create_session(struct rpc_rqst *rqstp,\n\t\t\t\t       struct xdr_stream *xdr,\n\t\t\t\t       void *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_create_session(xdr, res);\n\treturn status;\n}\n\n/*\n * Decode DESTROY_SESSION response\n */\nstatic int nfs4_xdr_dec_destroy_session(struct rpc_rqst *rqstp,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tvoid *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_destroy_session(xdr, res);\n\treturn status;\n}\n\n/*\n * Decode DESTROY_CLIENTID response\n */\nstatic int nfs4_xdr_dec_destroy_clientid(struct rpc_rqst *rqstp,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tvoid *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_destroy_clientid(xdr, res);\n\treturn status;\n}\n\n/*\n * Decode SEQUENCE response\n */\nstatic int nfs4_xdr_dec_sequence(struct rpc_rqst *rqstp,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t void *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_sequence(xdr, res, rqstp);\n\treturn status;\n}\n\n#endif\n\n/*\n * Decode GET_LEASE_TIME response\n */\nstatic int nfs4_xdr_dec_get_lease_time(struct rpc_rqst *rqstp,\n\t\t\t\t       struct xdr_stream *xdr,\n\t\t\t\t       void *data)\n{\n\tstruct nfs4_get_lease_time_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_sequence(xdr, &res->lr_seq_res, rqstp);\n\tif (!status)\n\t\tstatus = decode_putrootfh(xdr);\n\tif (!status)\n\t\tstatus = decode_fsinfo(xdr, res->lr_fsinfo);\n\treturn status;\n}\n\n#ifdef CONFIG_NFS_V4_1\n\n/*\n * Decode RECLAIM_COMPLETE response\n */\nstatic int nfs4_xdr_dec_reclaim_complete(struct rpc_rqst *rqstp,\n\t\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t\t void *data)\n{\n\tstruct nfs41_reclaim_complete_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (!status)\n\t\tstatus = decode_reclaim_complete(xdr, NULL);\n\treturn status;\n}\n\n/*\n * Decode GETDEVINFO response\n */\nstatic int nfs4_xdr_dec_getdeviceinfo(struct rpc_rqst *rqstp,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      void *data)\n{\n\tstruct nfs4_getdeviceinfo_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_getdeviceinfo(xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode LAYOUTGET response\n */\nstatic int nfs4_xdr_dec_layoutget(struct rpc_rqst *rqstp,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  void *data)\n{\n\tstruct nfs4_layoutget_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_layoutget(xdr, rqstp, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode LAYOUTRETURN response\n */\nstatic int nfs4_xdr_dec_layoutreturn(struct rpc_rqst *rqstp,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     void *data)\n{\n\tstruct nfs4_layoutreturn_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_layoutreturn(xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode LAYOUTCOMMIT response\n */\nstatic int nfs4_xdr_dec_layoutcommit(struct rpc_rqst *rqstp,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     void *data)\n{\n\tstruct nfs4_layoutcommit_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_layoutcommit(xdr, rqstp, res);\n\tif (status)\n\t\tgoto out;\n\tdecode_getfattr(xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode SECINFO_NO_NAME response\n */\nstatic int nfs4_xdr_dec_secinfo_no_name(struct rpc_rqst *rqstp,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tvoid *data)\n{\n\tstruct nfs4_secinfo_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putrootfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_secinfo_no_name(xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode TEST_STATEID response\n */\nstatic int nfs4_xdr_dec_test_stateid(struct rpc_rqst *rqstp,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     void *data)\n{\n\tstruct nfs41_test_stateid_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_test_stateid(xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode FREE_STATEID response\n */\nstatic int nfs4_xdr_dec_free_stateid(struct rpc_rqst *rqstp,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     void *data)\n{\n\tstruct nfs41_free_stateid_res *res = data;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_free_stateid(xdr, res);\nout:\n\treturn status;\n}\n#endif /* CONFIG_NFS_V4_1 */\n\n/**\n * nfs4_decode_dirent - Decode a single NFSv4 directory entry stored in\n *                      the local page cache.\n * @xdr: XDR stream where entry resides\n * @entry: buffer to fill in with entry data\n * @plus: boolean indicating whether this should be a readdirplus entry\n *\n * Returns zero if successful, otherwise a negative errno value is\n * returned.\n *\n * This function is not invoked during READDIR reply decoding, but\n * rather whenever an application invokes the getdents(2) system call\n * on a directory already in our cache.\n */\nint nfs4_decode_dirent(struct xdr_stream *xdr, struct nfs_entry *entry,\n\t\t       bool plus)\n{\n\tunsigned int savep;\n\tuint32_t bitmap[3] = {0};\n\tuint32_t len;\n\tuint64_t new_cookie;\n\t__be32 *p = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -EAGAIN;\n\tif (*p == xdr_zero) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EAGAIN;\n\t\tif (*p == xdr_zero)\n\t\t\treturn -EAGAIN;\n\t\tentry->eof = 1;\n\t\treturn -EBADCOOKIE;\n\t}\n\n\tp = xdr_inline_decode(xdr, 12);\n\tif (unlikely(!p))\n\t\treturn -EAGAIN;\n\tp = xdr_decode_hyper(p, &new_cookie);\n\tentry->len = be32_to_cpup(p);\n\n\tp = xdr_inline_decode(xdr, entry->len);\n\tif (unlikely(!p))\n\t\treturn -EAGAIN;\n\tentry->name = (const char *) p;\n\n\t/*\n\t * In case the server doesn't return an inode number,\n\t * we fake one here.  (We don't use inode number 0,\n\t * since glibc seems to choke on it...)\n\t */\n\tentry->ino = 1;\n\tentry->fattr->valid = 0;\n\n\tif (decode_attr_bitmap(xdr, bitmap) < 0)\n\t\treturn -EAGAIN;\n\n\tif (decode_attr_length(xdr, &len, &savep) < 0)\n\t\treturn -EAGAIN;\n\n\tif (decode_getfattr_attrs(xdr, bitmap, entry->fattr, entry->fh,\n\t\t\tNULL, entry->label, entry->server) < 0)\n\t\treturn -EAGAIN;\n\tif (entry->fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID)\n\t\tentry->ino = entry->fattr->mounted_on_fileid;\n\telse if (entry->fattr->valid & NFS_ATTR_FATTR_FILEID)\n\t\tentry->ino = entry->fattr->fileid;\n\n\tentry->d_type = DT_UNKNOWN;\n\tif (entry->fattr->valid & NFS_ATTR_FATTR_TYPE)\n\t\tentry->d_type = nfs_umode_to_dtype(entry->fattr->mode);\n\n\tentry->prev_cookie = entry->cookie;\n\tentry->cookie = new_cookie;\n\n\treturn 0;\n}\n\n/*\n * We need to translate between nfs status return values and\n * the local errno values which may not be the same.\n */\nstatic struct {\n\tint stat;\n\tint errno;\n} nfs_errtbl[] = {\n\t{ NFS4_OK,\t\t0\t\t},\n\t{ NFS4ERR_PERM,\t\t-EPERM\t\t},\n\t{ NFS4ERR_NOENT,\t-ENOENT\t\t},\n\t{ NFS4ERR_IO,\t\t-errno_NFSERR_IO},\n\t{ NFS4ERR_NXIO,\t\t-ENXIO\t\t},\n\t{ NFS4ERR_ACCESS,\t-EACCES\t\t},\n\t{ NFS4ERR_EXIST,\t-EEXIST\t\t},\n\t{ NFS4ERR_XDEV,\t\t-EXDEV\t\t},\n\t{ NFS4ERR_NOTDIR,\t-ENOTDIR\t},\n\t{ NFS4ERR_ISDIR,\t-EISDIR\t\t},\n\t{ NFS4ERR_INVAL,\t-EINVAL\t\t},\n\t{ NFS4ERR_FBIG,\t\t-EFBIG\t\t},\n\t{ NFS4ERR_NOSPC,\t-ENOSPC\t\t},\n\t{ NFS4ERR_ROFS,\t\t-EROFS\t\t},\n\t{ NFS4ERR_MLINK,\t-EMLINK\t\t},\n\t{ NFS4ERR_NAMETOOLONG,\t-ENAMETOOLONG\t},\n\t{ NFS4ERR_NOTEMPTY,\t-ENOTEMPTY\t},\n\t{ NFS4ERR_DQUOT,\t-EDQUOT\t\t},\n\t{ NFS4ERR_STALE,\t-ESTALE\t\t},\n\t{ NFS4ERR_BADHANDLE,\t-EBADHANDLE\t},\n\t{ NFS4ERR_BAD_COOKIE,\t-EBADCOOKIE\t},\n\t{ NFS4ERR_NOTSUPP,\t-ENOTSUPP\t},\n\t{ NFS4ERR_TOOSMALL,\t-ETOOSMALL\t},\n\t{ NFS4ERR_SERVERFAULT,\t-EREMOTEIO\t},\n\t{ NFS4ERR_BADTYPE,\t-EBADTYPE\t},\n\t{ NFS4ERR_LOCKED,\t-EAGAIN\t\t},\n\t{ NFS4ERR_SYMLINK,\t-ELOOP\t\t},\n\t{ NFS4ERR_OP_ILLEGAL,\t-EOPNOTSUPP\t},\n\t{ NFS4ERR_DEADLOCK,\t-EDEADLK\t},\n\t{ NFS4ERR_NOXATTR,\t-ENODATA\t},\n\t{ NFS4ERR_XATTR2BIG,\t-E2BIG\t\t},\n\t{ -1,\t\t\t-EIO\t\t}\n};\n\n/*\n * Convert an NFS error code to a local one.\n * This one is used jointly by NFSv2 and NFSv3.\n */\nstatic int\nnfs4_stat_to_errno(int stat)\n{\n\tint i;\n\tfor (i = 0; nfs_errtbl[i].stat != -1; i++) {\n\t\tif (nfs_errtbl[i].stat == stat)\n\t\t\treturn nfs_errtbl[i].errno;\n\t}\n\tif (stat <= 10000 || stat > 10100) {\n\t\t/* The server is looney tunes. */\n\t\treturn -EREMOTEIO;\n\t}\n\t/* If we cannot translate the error, the recovery routines should\n\t * handle it.\n\t * Note: remaining NFSv4 error codes have values > 10000, so should\n\t * not conflict with native Linux error codes.\n\t */\n\treturn -stat;\n}\n\n#ifdef CONFIG_NFS_V4_2\n#include \"nfs42xdr.c\"\n#endif /* CONFIG_NFS_V4_2 */\n\n#define PROC(proc, argtype, restype)\t\t\t\t\\\n[NFSPROC4_CLNT_##proc] = {\t\t\t\t\t\\\n\t.p_proc   = NFSPROC4_COMPOUND,\t\t\t\t\\\n\t.p_encode = nfs4_xdr_##argtype,\t\t\t\t\\\n\t.p_decode = nfs4_xdr_##restype,\t\t\t\t\\\n\t.p_arglen = NFS4_##argtype##_sz,\t\t\t\\\n\t.p_replen = NFS4_##restype##_sz,\t\t\t\\\n\t.p_statidx = NFSPROC4_CLNT_##proc,\t\t\t\\\n\t.p_name   = #proc,\t\t\t\t\t\\\n}\n\n#define STUB(proc)\t\t\\\n[NFSPROC4_CLNT_##proc] = {\t\\\n\t.p_name = #proc,\t\\\n}\n\n#if defined(CONFIG_NFS_V4_1)\n#define PROC41(proc, argtype, restype)\t\t\t\t\\\n\tPROC(proc, argtype, restype)\n#else\n#define PROC41(proc, argtype, restype)\t\t\t\t\\\n\tSTUB(proc)\n#endif\n\n#if defined(CONFIG_NFS_V4_2)\n#define PROC42(proc, argtype, restype)\t\t\t\t\\\n\tPROC(proc, argtype, restype)\n#else\n#define PROC42(proc, argtype, restype)\t\t\t\t\\\n\tSTUB(proc)\n#endif\n\nconst struct rpc_procinfo nfs4_procedures[] = {\n\tPROC(READ,\t\tenc_read,\t\tdec_read),\n\tPROC(WRITE,\t\tenc_write,\t\tdec_write),\n\tPROC(COMMIT,\t\tenc_commit,\t\tdec_commit),\n\tPROC(OPEN,\t\tenc_open,\t\tdec_open),\n\tPROC(OPEN_CONFIRM,\tenc_open_confirm,\tdec_open_confirm),\n\tPROC(OPEN_NOATTR,\tenc_open_noattr,\tdec_open_noattr),\n\tPROC(OPEN_DOWNGRADE,\tenc_open_downgrade,\tdec_open_downgrade),\n\tPROC(CLOSE,\t\tenc_close,\t\tdec_close),\n\tPROC(SETATTR,\t\tenc_setattr,\t\tdec_setattr),\n\tPROC(FSINFO,\t\tenc_fsinfo,\t\tdec_fsinfo),\n\tPROC(RENEW,\t\tenc_renew,\t\tdec_renew),\n\tPROC(SETCLIENTID,\tenc_setclientid,\tdec_setclientid),\n\tPROC(SETCLIENTID_CONFIRM, enc_setclientid_confirm, dec_setclientid_confirm),\n\tPROC(LOCK,\t\tenc_lock,\t\tdec_lock),\n\tPROC(LOCKT,\t\tenc_lockt,\t\tdec_lockt),\n\tPROC(LOCKU,\t\tenc_locku,\t\tdec_locku),\n\tPROC(ACCESS,\t\tenc_access,\t\tdec_access),\n\tPROC(GETATTR,\t\tenc_getattr,\t\tdec_getattr),\n\tPROC(LOOKUP,\t\tenc_lookup,\t\tdec_lookup),\n\tPROC(LOOKUP_ROOT,\tenc_lookup_root,\tdec_lookup_root),\n\tPROC(REMOVE,\t\tenc_remove,\t\tdec_remove),\n\tPROC(RENAME,\t\tenc_rename,\t\tdec_rename),\n\tPROC(LINK,\t\tenc_link,\t\tdec_link),\n\tPROC(SYMLINK,\t\tenc_symlink,\t\tdec_symlink),\n\tPROC(CREATE,\t\tenc_create,\t\tdec_create),\n\tPROC(PATHCONF,\t\tenc_pathconf,\t\tdec_pathconf),\n\tPROC(STATFS,\t\tenc_statfs,\t\tdec_statfs),\n\tPROC(READLINK,\t\tenc_readlink,\t\tdec_readlink),\n\tPROC(READDIR,\t\tenc_readdir,\t\tdec_readdir),\n\tPROC(SERVER_CAPS,\tenc_server_caps,\tdec_server_caps),\n\tPROC(DELEGRETURN,\tenc_delegreturn,\tdec_delegreturn),\n\tPROC(GETACL,\t\tenc_getacl,\t\tdec_getacl),\n\tPROC(SETACL,\t\tenc_setacl,\t\tdec_setacl),\n\tPROC(FS_LOCATIONS,\tenc_fs_locations,\tdec_fs_locations),\n\tPROC(RELEASE_LOCKOWNER,\tenc_release_lockowner,\tdec_release_lockowner),\n\tPROC(SECINFO,\t\tenc_secinfo,\t\tdec_secinfo),\n\tPROC(FSID_PRESENT,\tenc_fsid_present,\tdec_fsid_present),\n\tPROC41(EXCHANGE_ID,\tenc_exchange_id,\tdec_exchange_id),\n\tPROC41(CREATE_SESSION,\tenc_create_session,\tdec_create_session),\n\tPROC41(DESTROY_SESSION,\tenc_destroy_session,\tdec_destroy_session),\n\tPROC41(SEQUENCE,\tenc_sequence,\t\tdec_sequence),\n\tPROC(GET_LEASE_TIME,\tenc_get_lease_time,\tdec_get_lease_time),\n\tPROC41(RECLAIM_COMPLETE,enc_reclaim_complete,\tdec_reclaim_complete),\n\tPROC41(GETDEVICEINFO,\tenc_getdeviceinfo,\tdec_getdeviceinfo),\n\tPROC41(LAYOUTGET,\tenc_layoutget,\t\tdec_layoutget),\n\tPROC41(LAYOUTCOMMIT,\tenc_layoutcommit,\tdec_layoutcommit),\n\tPROC41(LAYOUTRETURN,\tenc_layoutreturn,\tdec_layoutreturn),\n\tPROC41(SECINFO_NO_NAME,\tenc_secinfo_no_name,\tdec_secinfo_no_name),\n\tPROC41(TEST_STATEID,\tenc_test_stateid,\tdec_test_stateid),\n\tPROC41(FREE_STATEID,\tenc_free_stateid,\tdec_free_stateid),\n\tSTUB(GETDEVICELIST),\n\tPROC41(BIND_CONN_TO_SESSION,\n\t\t\tenc_bind_conn_to_session, dec_bind_conn_to_session),\n\tPROC41(DESTROY_CLIENTID,enc_destroy_clientid,\tdec_destroy_clientid),\n\tPROC42(SEEK,\t\tenc_seek,\t\tdec_seek),\n\tPROC42(ALLOCATE,\tenc_allocate,\t\tdec_allocate),\n\tPROC42(DEALLOCATE,\tenc_deallocate,\t\tdec_deallocate),\n\tPROC42(LAYOUTSTATS,\tenc_layoutstats,\tdec_layoutstats),\n\tPROC42(CLONE,\t\tenc_clone,\t\tdec_clone),\n\tPROC42(COPY,\t\tenc_copy,\t\tdec_copy),\n\tPROC42(OFFLOAD_CANCEL,\tenc_offload_cancel,\tdec_offload_cancel),\n\tPROC42(COPY_NOTIFY,\tenc_copy_notify,\tdec_copy_notify),\n\tPROC(LOOKUPP,\t\tenc_lookupp,\t\tdec_lookupp),\n\tPROC42(LAYOUTERROR,\tenc_layouterror,\tdec_layouterror),\n\tPROC42(GETXATTR,\tenc_getxattr,\t\tdec_getxattr),\n\tPROC42(SETXATTR,\tenc_setxattr,\t\tdec_setxattr),\n\tPROC42(LISTXATTRS,\tenc_listxattrs,\t\tdec_listxattrs),\n\tPROC42(REMOVEXATTR,\tenc_removexattr,\tdec_removexattr),\n\tPROC42(READ_PLUS,\tenc_read_plus,\t\tdec_read_plus),\n};\n\nstatic unsigned int nfs_version4_counts[ARRAY_SIZE(nfs4_procedures)];\nconst struct rpc_version nfs_version4 = {\n\t.number\t\t\t= 4,\n\t.nrprocs\t\t= ARRAY_SIZE(nfs4_procedures),\n\t.procs\t\t\t= nfs4_procedures,\n\t.counts\t\t\t= nfs_version4_counts,\n};\n\n/*\n * Local variables:\n *  c-basic-offset: 8\n * End:\n */\n"}, "1": {"id": 1, "path": "/src/include/linux/sunrpc/xdr.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * XDR standard data types and function declarations\n *\n * Copyright (C) 1995-1997 Olaf Kirch <okir@monad.swb.de>\n *\n * Based on:\n *   RFC 4506 \"XDR: External Data Representation Standard\", May 2006\n */\n\n#ifndef _SUNRPC_XDR_H_\n#define _SUNRPC_XDR_H_\n\n#include <linux/uio.h>\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n#include <linux/scatterlist.h>\n\nstruct bio_vec;\nstruct rpc_rqst;\n\n/*\n * Buffer adjustment\n */\n#define XDR_QUADLEN(l)\t\t(((l) + 3) >> 2)\n\n/*\n * Generic opaque `network object.' At the kernel level, this type\n * is used only by lockd.\n */\n#define XDR_MAX_NETOBJ\t\t1024\nstruct xdr_netobj {\n\tunsigned int\t\tlen;\n\tu8 *\t\t\tdata;\n};\n\n/*\n * Basic structure for transmission/reception of a client XDR message.\n * Features a header (for a linear buffer containing RPC headers\n * and the data payload for short messages), and then an array of\n * pages.\n * The tail iovec allows you to append data after the page array. Its\n * main interest is for appending padding to the pages in order to\n * satisfy the int_32-alignment requirements in RFC1832.\n *\n * For the future, we might want to string several of these together\n * in a list if anybody wants to make use of NFSv4 COMPOUND\n * operations and/or has a need for scatter/gather involving pages.\n */\nstruct xdr_buf {\n\tstruct kvec\thead[1],\t/* RPC header + non-page data */\n\t\t\ttail[1];\t/* Appended after page data */\n\n\tstruct bio_vec\t*bvec;\n\tstruct page **\tpages;\t\t/* Array of pages */\n\tunsigned int\tpage_base,\t/* Start of page data */\n\t\t\tpage_len,\t/* Length of page data */\n\t\t\tflags;\t\t/* Flags for data disposition */\n#define XDRBUF_READ\t\t0x01\t\t/* target of file read */\n#define XDRBUF_WRITE\t\t0x02\t\t/* source of file write */\n#define XDRBUF_SPARSE_PAGES\t0x04\t\t/* Page array is sparse */\n\n\tunsigned int\tbuflen,\t\t/* Total length of storage buffer */\n\t\t\tlen;\t\t/* Length of XDR encoded message */\n};\n\nstatic inline void\nxdr_buf_init(struct xdr_buf *buf, void *start, size_t len)\n{\n\tbuf->head[0].iov_base = start;\n\tbuf->head[0].iov_len = len;\n\tbuf->tail[0].iov_len = 0;\n\tbuf->pages = NULL;\n\tbuf->page_len = 0;\n\tbuf->flags = 0;\n\tbuf->len = 0;\n\tbuf->buflen = len;\n}\n\n/*\n * pre-xdr'ed macros.\n */\n\n#define\txdr_zero\tcpu_to_be32(0)\n#define\txdr_one\t\tcpu_to_be32(1)\n#define\txdr_two\t\tcpu_to_be32(2)\n\n#define\trpc_auth_null\tcpu_to_be32(RPC_AUTH_NULL)\n#define\trpc_auth_unix\tcpu_to_be32(RPC_AUTH_UNIX)\n#define\trpc_auth_short\tcpu_to_be32(RPC_AUTH_SHORT)\n#define\trpc_auth_gss\tcpu_to_be32(RPC_AUTH_GSS)\n\n#define\trpc_call\tcpu_to_be32(RPC_CALL)\n#define\trpc_reply\tcpu_to_be32(RPC_REPLY)\n\n#define\trpc_msg_accepted\tcpu_to_be32(RPC_MSG_ACCEPTED)\n\n#define\trpc_success\t\tcpu_to_be32(RPC_SUCCESS)\n#define\trpc_prog_unavail\tcpu_to_be32(RPC_PROG_UNAVAIL)\n#define\trpc_prog_mismatch\tcpu_to_be32(RPC_PROG_MISMATCH)\n#define\trpc_proc_unavail\tcpu_to_be32(RPC_PROC_UNAVAIL)\n#define\trpc_garbage_args\tcpu_to_be32(RPC_GARBAGE_ARGS)\n#define\trpc_system_err\t\tcpu_to_be32(RPC_SYSTEM_ERR)\n#define\trpc_drop_reply\t\tcpu_to_be32(RPC_DROP_REPLY)\n\n#define\trpc_mismatch\t\tcpu_to_be32(RPC_MISMATCH)\n#define\trpc_auth_error\t\tcpu_to_be32(RPC_AUTH_ERROR)\n\n#define\trpc_auth_ok\t\tcpu_to_be32(RPC_AUTH_OK)\n#define\trpc_autherr_badcred\tcpu_to_be32(RPC_AUTH_BADCRED)\n#define\trpc_autherr_rejectedcred cpu_to_be32(RPC_AUTH_REJECTEDCRED)\n#define\trpc_autherr_badverf\tcpu_to_be32(RPC_AUTH_BADVERF)\n#define\trpc_autherr_rejectedverf cpu_to_be32(RPC_AUTH_REJECTEDVERF)\n#define\trpc_autherr_tooweak\tcpu_to_be32(RPC_AUTH_TOOWEAK)\n#define\trpcsec_gsserr_credproblem\tcpu_to_be32(RPCSEC_GSS_CREDPROBLEM)\n#define\trpcsec_gsserr_ctxproblem\tcpu_to_be32(RPCSEC_GSS_CTXPROBLEM)\n\n/*\n * Miscellaneous XDR helper functions\n */\n__be32 *xdr_encode_opaque_fixed(__be32 *p, const void *ptr, unsigned int len);\n__be32 *xdr_encode_opaque(__be32 *p, const void *ptr, unsigned int len);\n__be32 *xdr_encode_string(__be32 *p, const char *s);\n__be32 *xdr_decode_string_inplace(__be32 *p, char **sp, unsigned int *lenp,\n\t\t\tunsigned int maxlen);\n__be32 *xdr_encode_netobj(__be32 *p, const struct xdr_netobj *);\n__be32 *xdr_decode_netobj(__be32 *p, struct xdr_netobj *);\n\nvoid\txdr_inline_pages(struct xdr_buf *, unsigned int,\n\t\t\t struct page **, unsigned int, unsigned int);\nvoid\txdr_terminate_string(struct xdr_buf *, const u32);\nsize_t\txdr_buf_pagecount(struct xdr_buf *buf);\nint\txdr_alloc_bvec(struct xdr_buf *buf, gfp_t gfp);\nvoid\txdr_free_bvec(struct xdr_buf *buf);\n\nstatic inline __be32 *xdr_encode_array(__be32 *p, const void *s, unsigned int len)\n{\n\treturn xdr_encode_opaque(p, s, len);\n}\n\n/*\n * Decode 64bit quantities (NFSv3 support)\n */\nstatic inline __be32 *\nxdr_encode_hyper(__be32 *p, __u64 val)\n{\n\tput_unaligned_be64(val, p);\n\treturn p + 2;\n}\n\nstatic inline __be32 *\nxdr_decode_hyper(__be32 *p, __u64 *valp)\n{\n\t*valp = get_unaligned_be64(p);\n\treturn p + 2;\n}\n\nstatic inline __be32 *\nxdr_decode_opaque_fixed(__be32 *p, void *ptr, unsigned int len)\n{\n\tmemcpy(ptr, p, len);\n\treturn p + XDR_QUADLEN(len);\n}\n\nstatic inline void xdr_netobj_dup(struct xdr_netobj *dst,\n\t\t\t\t  struct xdr_netobj *src, gfp_t gfp_mask)\n{\n\tdst->data = kmemdup(src->data, src->len, gfp_mask);\n\tdst->len = src->len;\n}\n\n/*\n * Adjust kvec to reflect end of xdr'ed data (RPC client XDR)\n */\nstatic inline int\nxdr_adjust_iovec(struct kvec *iov, __be32 *p)\n{\n\treturn iov->iov_len = ((u8 *) p - (u8 *) iov->iov_base);\n}\n\n/*\n * XDR buffer helper functions\n */\nextern void xdr_shift_buf(struct xdr_buf *, size_t);\nextern void xdr_buf_from_iov(struct kvec *, struct xdr_buf *);\nextern int xdr_buf_subsegment(struct xdr_buf *, struct xdr_buf *, unsigned int, unsigned int);\nextern void xdr_buf_trim(struct xdr_buf *, unsigned int);\nextern int read_bytes_from_xdr_buf(struct xdr_buf *, unsigned int, void *, unsigned int);\nextern int write_bytes_to_xdr_buf(struct xdr_buf *, unsigned int, void *, unsigned int);\n\nextern int xdr_encode_word(struct xdr_buf *, unsigned int, u32);\nextern int xdr_decode_word(struct xdr_buf *, unsigned int, u32 *);\n\nstruct xdr_array2_desc;\ntypedef int (*xdr_xcode_elem_t)(struct xdr_array2_desc *desc, void *elem);\nstruct xdr_array2_desc {\n\tunsigned int elem_size;\n\tunsigned int array_len;\n\tunsigned int array_maxlen;\n\txdr_xcode_elem_t xcode;\n};\n\nextern int xdr_decode_array2(struct xdr_buf *buf, unsigned int base,\n\t\t\t     struct xdr_array2_desc *desc);\nextern int xdr_encode_array2(struct xdr_buf *buf, unsigned int base,\n\t\t\t     struct xdr_array2_desc *desc);\nextern void _copy_from_pages(char *p, struct page **pages, size_t pgbase,\n\t\t\t     size_t len);\n\n/*\n * Provide some simple tools for XDR buffer overflow-checking etc.\n */\nstruct xdr_stream {\n\t__be32 *p;\t\t/* start of available buffer */\n\tstruct xdr_buf *buf;\t/* XDR buffer to read/write */\n\n\t__be32 *end;\t\t/* end of available buffer space */\n\tstruct kvec *iov;\t/* pointer to the current kvec */\n\tstruct kvec scratch;\t/* Scratch buffer */\n\tstruct page **page_ptr;\t/* pointer to the current page */\n\tunsigned int nwords;\t/* Remaining decode buffer length */\n\n\tstruct rpc_rqst *rqst;\t/* For debugging */\n};\n\n/*\n * These are the xdr_stream style generic XDR encode and decode functions.\n */\ntypedef void\t(*kxdreproc_t)(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\tconst void *obj);\ntypedef int\t(*kxdrdproc_t)(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\tvoid *obj);\n\nextern void xdr_init_encode(struct xdr_stream *xdr, struct xdr_buf *buf,\n\t\t\t    __be32 *p, struct rpc_rqst *rqst);\nextern __be32 *xdr_reserve_space(struct xdr_stream *xdr, size_t nbytes);\nextern int xdr_reserve_space_vec(struct xdr_stream *xdr, struct kvec *vec,\n\t\tsize_t nbytes);\nextern void xdr_commit_encode(struct xdr_stream *xdr);\nextern void xdr_truncate_encode(struct xdr_stream *xdr, size_t len);\nextern int xdr_restrict_buflen(struct xdr_stream *xdr, int newbuflen);\nextern void xdr_write_pages(struct xdr_stream *xdr, struct page **pages,\n\t\tunsigned int base, unsigned int len);\nextern unsigned int xdr_stream_pos(const struct xdr_stream *xdr);\nextern unsigned int xdr_page_pos(const struct xdr_stream *xdr);\nextern void xdr_init_decode(struct xdr_stream *xdr, struct xdr_buf *buf,\n\t\t\t    __be32 *p, struct rpc_rqst *rqst);\nextern void xdr_init_decode_pages(struct xdr_stream *xdr, struct xdr_buf *buf,\n\t\tstruct page **pages, unsigned int len);\nextern void xdr_set_scratch_buffer(struct xdr_stream *xdr, void *buf, size_t buflen);\nextern __be32 *xdr_inline_decode(struct xdr_stream *xdr, size_t nbytes);\nextern unsigned int xdr_read_pages(struct xdr_stream *xdr, unsigned int len);\nextern void xdr_enter_page(struct xdr_stream *xdr, unsigned int len);\nextern int xdr_process_buf(struct xdr_buf *buf, unsigned int offset, unsigned int len, int (*actor)(struct scatterlist *, void *), void *data);\nextern uint64_t xdr_align_data(struct xdr_stream *, uint64_t, uint32_t);\nextern uint64_t xdr_expand_hole(struct xdr_stream *, uint64_t, uint64_t);\n\n/**\n * xdr_stream_remaining - Return the number of bytes remaining in the stream\n * @xdr: pointer to struct xdr_stream\n *\n * Return value:\n *   Number of bytes remaining in @xdr before xdr->end\n */\nstatic inline size_t\nxdr_stream_remaining(const struct xdr_stream *xdr)\n{\n\treturn xdr->nwords << 2;\n}\n\nssize_t xdr_stream_decode_opaque(struct xdr_stream *xdr, void *ptr,\n\t\tsize_t size);\nssize_t xdr_stream_decode_opaque_dup(struct xdr_stream *xdr, void **ptr,\n\t\tsize_t maxlen, gfp_t gfp_flags);\nssize_t xdr_stream_decode_string(struct xdr_stream *xdr, char *str,\n\t\tsize_t size);\nssize_t xdr_stream_decode_string_dup(struct xdr_stream *xdr, char **str,\n\t\tsize_t maxlen, gfp_t gfp_flags);\n/**\n * xdr_align_size - Calculate padded size of an object\n * @n: Size of an object being XDR encoded (in bytes)\n *\n * Return value:\n *   Size (in bytes) of the object including xdr padding\n */\nstatic inline size_t\nxdr_align_size(size_t n)\n{\n\tconst size_t mask = sizeof(__u32) - 1;\n\n\treturn (n + mask) & ~mask;\n}\n\n/**\n * xdr_pad_size - Calculate size of an object's pad\n * @n: Size of an object being XDR encoded (in bytes)\n *\n * This implementation avoids the need for conditional\n * branches or modulo division.\n *\n * Return value:\n *   Size (in bytes) of the needed XDR pad\n */\nstatic inline size_t xdr_pad_size(size_t n)\n{\n\treturn xdr_align_size(n) - n;\n}\n\n/**\n * xdr_stream_encode_item_present - Encode a \"present\" list item\n * @xdr: pointer to xdr_stream\n *\n * Return values:\n *   On success, returns length in bytes of XDR buffer consumed\n *   %-EMSGSIZE on XDR buffer overflow\n */\nstatic inline ssize_t xdr_stream_encode_item_present(struct xdr_stream *xdr)\n{\n\tconst size_t len = sizeof(__be32);\n\t__be32 *p = xdr_reserve_space(xdr, len);\n\n\tif (unlikely(!p))\n\t\treturn -EMSGSIZE;\n\t*p = xdr_one;\n\treturn len;\n}\n\n/**\n * xdr_stream_encode_item_absent - Encode a \"not present\" list item\n * @xdr: pointer to xdr_stream\n *\n * Return values:\n *   On success, returns length in bytes of XDR buffer consumed\n *   %-EMSGSIZE on XDR buffer overflow\n */\nstatic inline int xdr_stream_encode_item_absent(struct xdr_stream *xdr)\n{\n\tconst size_t len = sizeof(__be32);\n\t__be32 *p = xdr_reserve_space(xdr, len);\n\n\tif (unlikely(!p))\n\t\treturn -EMSGSIZE;\n\t*p = xdr_zero;\n\treturn len;\n}\n\n/**\n * xdr_stream_encode_u32 - Encode a 32-bit integer\n * @xdr: pointer to xdr_stream\n * @n: integer to encode\n *\n * Return values:\n *   On success, returns length in bytes of XDR buffer consumed\n *   %-EMSGSIZE on XDR buffer overflow\n */\nstatic inline ssize_t\nxdr_stream_encode_u32(struct xdr_stream *xdr, __u32 n)\n{\n\tconst size_t len = sizeof(n);\n\t__be32 *p = xdr_reserve_space(xdr, len);\n\n\tif (unlikely(!p))\n\t\treturn -EMSGSIZE;\n\t*p = cpu_to_be32(n);\n\treturn len;\n}\n\n/**\n * xdr_stream_encode_u64 - Encode a 64-bit integer\n * @xdr: pointer to xdr_stream\n * @n: 64-bit integer to encode\n *\n * Return values:\n *   On success, returns length in bytes of XDR buffer consumed\n *   %-EMSGSIZE on XDR buffer overflow\n */\nstatic inline ssize_t\nxdr_stream_encode_u64(struct xdr_stream *xdr, __u64 n)\n{\n\tconst size_t len = sizeof(n);\n\t__be32 *p = xdr_reserve_space(xdr, len);\n\n\tif (unlikely(!p))\n\t\treturn -EMSGSIZE;\n\txdr_encode_hyper(p, n);\n\treturn len;\n}\n\n/**\n * xdr_stream_encode_opaque_inline - Encode opaque xdr data\n * @xdr: pointer to xdr_stream\n * @ptr: pointer to void pointer\n * @len: size of object\n *\n * Return values:\n *   On success, returns length in bytes of XDR buffer consumed\n *   %-EMSGSIZE on XDR buffer overflow\n */\nstatic inline ssize_t\nxdr_stream_encode_opaque_inline(struct xdr_stream *xdr, void **ptr, size_t len)\n{\n\tsize_t count = sizeof(__u32) + xdr_align_size(len);\n\t__be32 *p = xdr_reserve_space(xdr, count);\n\n\tif (unlikely(!p)) {\n\t\t*ptr = NULL;\n\t\treturn -EMSGSIZE;\n\t}\n\txdr_encode_opaque(p, NULL, len);\n\t*ptr = ++p;\n\treturn count;\n}\n\n/**\n * xdr_stream_encode_opaque_fixed - Encode fixed length opaque xdr data\n * @xdr: pointer to xdr_stream\n * @ptr: pointer to opaque data object\n * @len: size of object pointed to by @ptr\n *\n * Return values:\n *   On success, returns length in bytes of XDR buffer consumed\n *   %-EMSGSIZE on XDR buffer overflow\n */\nstatic inline ssize_t\nxdr_stream_encode_opaque_fixed(struct xdr_stream *xdr, const void *ptr, size_t len)\n{\n\t__be32 *p = xdr_reserve_space(xdr, len);\n\n\tif (unlikely(!p))\n\t\treturn -EMSGSIZE;\n\txdr_encode_opaque_fixed(p, ptr, len);\n\treturn xdr_align_size(len);\n}\n\n/**\n * xdr_stream_encode_opaque - Encode variable length opaque xdr data\n * @xdr: pointer to xdr_stream\n * @ptr: pointer to opaque data object\n * @len: size of object pointed to by @ptr\n *\n * Return values:\n *   On success, returns length in bytes of XDR buffer consumed\n *   %-EMSGSIZE on XDR buffer overflow\n */\nstatic inline ssize_t\nxdr_stream_encode_opaque(struct xdr_stream *xdr, const void *ptr, size_t len)\n{\n\tsize_t count = sizeof(__u32) + xdr_align_size(len);\n\t__be32 *p = xdr_reserve_space(xdr, count);\n\n\tif (unlikely(!p))\n\t\treturn -EMSGSIZE;\n\txdr_encode_opaque(p, ptr, len);\n\treturn count;\n}\n\n/**\n * xdr_stream_encode_uint32_array - Encode variable length array of integers\n * @xdr: pointer to xdr_stream\n * @array: array of integers\n * @array_size: number of elements in @array\n *\n * Return values:\n *   On success, returns length in bytes of XDR buffer consumed\n *   %-EMSGSIZE on XDR buffer overflow\n */\nstatic inline ssize_t\nxdr_stream_encode_uint32_array(struct xdr_stream *xdr,\n\t\tconst __u32 *array, size_t array_size)\n{\n\tssize_t ret = (array_size+1) * sizeof(__u32);\n\t__be32 *p = xdr_reserve_space(xdr, ret);\n\n\tif (unlikely(!p))\n\t\treturn -EMSGSIZE;\n\t*p++ = cpu_to_be32(array_size);\n\tfor (; array_size > 0; p++, array++, array_size--)\n\t\t*p = cpu_to_be32p(array);\n\treturn ret;\n}\n\n/**\n * xdr_item_is_absent - symbolically handle XDR discriminators\n * @p: pointer to undecoded discriminator\n *\n * Return values:\n *   %true if the following XDR item is absent\n *   %false if the following XDR item is present\n */\nstatic inline bool xdr_item_is_absent(const __be32 *p)\n{\n\treturn *p == xdr_zero;\n}\n\n/**\n * xdr_item_is_present - symbolically handle XDR discriminators\n * @p: pointer to undecoded discriminator\n *\n * Return values:\n *   %true if the following XDR item is present\n *   %false if the following XDR item is absent\n */\nstatic inline bool xdr_item_is_present(const __be32 *p)\n{\n\treturn *p != xdr_zero;\n}\n\n/**\n * xdr_stream_decode_u32 - Decode a 32-bit integer\n * @xdr: pointer to xdr_stream\n * @ptr: location to store integer\n *\n * Return values:\n *   %0 on success\n *   %-EBADMSG on XDR buffer overflow\n */\nstatic inline ssize_t\nxdr_stream_decode_u32(struct xdr_stream *xdr, __u32 *ptr)\n{\n\tconst size_t count = sizeof(*ptr);\n\t__be32 *p = xdr_inline_decode(xdr, count);\n\n\tif (unlikely(!p))\n\t\treturn -EBADMSG;\n\t*ptr = be32_to_cpup(p);\n\treturn 0;\n}\n\n/**\n * xdr_stream_decode_opaque_fixed - Decode fixed length opaque xdr data\n * @xdr: pointer to xdr_stream\n * @ptr: location to store data\n * @len: size of buffer pointed to by @ptr\n *\n * Return values:\n *   On success, returns size of object stored in @ptr\n *   %-EBADMSG on XDR buffer overflow\n */\nstatic inline ssize_t\nxdr_stream_decode_opaque_fixed(struct xdr_stream *xdr, void *ptr, size_t len)\n{\n\t__be32 *p = xdr_inline_decode(xdr, len);\n\n\tif (unlikely(!p))\n\t\treturn -EBADMSG;\n\txdr_decode_opaque_fixed(p, ptr, len);\n\treturn len;\n}\n\n/**\n * xdr_stream_decode_opaque_inline - Decode variable length opaque xdr data\n * @xdr: pointer to xdr_stream\n * @ptr: location to store pointer to opaque data\n * @maxlen: maximum acceptable object size\n *\n * Note: the pointer stored in @ptr cannot be assumed valid after the XDR\n * buffer has been destroyed, or even after calling xdr_inline_decode()\n * on @xdr. It is therefore expected that the object it points to should\n * be processed immediately.\n *\n * Return values:\n *   On success, returns size of object stored in *@ptr\n *   %-EBADMSG on XDR buffer overflow\n *   %-EMSGSIZE if the size of the object would exceed @maxlen\n */\nstatic inline ssize_t\nxdr_stream_decode_opaque_inline(struct xdr_stream *xdr, void **ptr, size_t maxlen)\n{\n\t__be32 *p;\n\t__u32 len;\n\n\t*ptr = NULL;\n\tif (unlikely(xdr_stream_decode_u32(xdr, &len) < 0))\n\t\treturn -EBADMSG;\n\tif (len != 0) {\n\t\tp = xdr_inline_decode(xdr, len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EBADMSG;\n\t\tif (unlikely(len > maxlen))\n\t\t\treturn -EMSGSIZE;\n\t\t*ptr = p;\n\t}\n\treturn len;\n}\n\n/**\n * xdr_stream_decode_uint32_array - Decode variable length array of integers\n * @xdr: pointer to xdr_stream\n * @array: location to store the integer array or NULL\n * @array_size: number of elements to store\n *\n * Return values:\n *   On success, returns number of elements stored in @array\n *   %-EBADMSG on XDR buffer overflow\n *   %-EMSGSIZE if the size of the array exceeds @array_size\n */\nstatic inline ssize_t\nxdr_stream_decode_uint32_array(struct xdr_stream *xdr,\n\t\t__u32 *array, size_t array_size)\n{\n\t__be32 *p;\n\t__u32 len;\n\tssize_t retval;\n\n\tif (unlikely(xdr_stream_decode_u32(xdr, &len) < 0))\n\t\treturn -EBADMSG;\n\tp = xdr_inline_decode(xdr, len * sizeof(*p));\n\tif (unlikely(!p))\n\t\treturn -EBADMSG;\n\tif (array == NULL)\n\t\treturn len;\n\tif (len <= array_size) {\n\t\tif (len < array_size)\n\t\t\tmemset(array+len, 0, (array_size-len)*sizeof(*array));\n\t\tarray_size = len;\n\t\tretval = len;\n\t} else\n\t\tretval = -EMSGSIZE;\n\tfor (; array_size > 0; p++, array++, array_size--)\n\t\t*array = be32_to_cpup(p);\n\treturn retval;\n}\n\n#endif /* _SUNRPC_XDR_H_ */\n"}, "2": {"id": 2, "path": "/src/include/linux/compiler.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_COMPILER_H\n#define __LINUX_COMPILER_H\n\n#include <linux/compiler_types.h>\n\n#ifndef __ASSEMBLY__\n\n#ifdef __KERNEL__\n\n/*\n * Note: DISABLE_BRANCH_PROFILING can be used by special lowlevel code\n * to disable branch tracing on a per file basis.\n */\n#if defined(CONFIG_TRACE_BRANCH_PROFILING) \\\n    && !defined(DISABLE_BRANCH_PROFILING) && !defined(__CHECKER__)\nvoid ftrace_likely_update(struct ftrace_likely_data *f, int val,\n\t\t\t  int expect, int is_constant);\n\n#define likely_notrace(x)\t__builtin_expect(!!(x), 1)\n#define unlikely_notrace(x)\t__builtin_expect(!!(x), 0)\n\n#define __branch_check__(x, expect, is_constant) ({\t\t\t\\\n\t\t\tlong ______r;\t\t\t\t\t\\\n\t\t\tstatic struct ftrace_likely_data\t\t\\\n\t\t\t\t__aligned(4)\t\t\t\t\\\n\t\t\t\t__section(\"_ftrace_annotated_branch\")\t\\\n\t\t\t\t______f = {\t\t\t\t\\\n\t\t\t\t.data.func = __func__,\t\t\t\\\n\t\t\t\t.data.file = __FILE__,\t\t\t\\\n\t\t\t\t.data.line = __LINE__,\t\t\t\\\n\t\t\t};\t\t\t\t\t\t\\\n\t\t\t______r = __builtin_expect(!!(x), expect);\t\\\n\t\t\tftrace_likely_update(&______f, ______r,\t\t\\\n\t\t\t\t\t     expect, is_constant);\t\\\n\t\t\t______r;\t\t\t\t\t\\\n\t\t})\n\n/*\n * Using __builtin_constant_p(x) to ignore cases where the return\n * value is always the same.  This idea is taken from a similar patch\n * written by Daniel Walker.\n */\n# ifndef likely\n#  define likely(x)\t(__branch_check__(x, 1, __builtin_constant_p(x)))\n# endif\n# ifndef unlikely\n#  define unlikely(x)\t(__branch_check__(x, 0, __builtin_constant_p(x)))\n# endif\n\n#ifdef CONFIG_PROFILE_ALL_BRANCHES\n/*\n * \"Define 'is'\", Bill Clinton\n * \"Define 'if'\", Steven Rostedt\n */\n#define if(cond, ...) if ( __trace_if_var( !!(cond , ## __VA_ARGS__) ) )\n\n#define __trace_if_var(cond) (__builtin_constant_p(cond) ? (cond) : __trace_if_value(cond))\n\n#define __trace_if_value(cond) ({\t\t\t\\\n\tstatic struct ftrace_branch_data\t\t\\\n\t\t__aligned(4)\t\t\t\t\\\n\t\t__section(\"_ftrace_branch\")\t\t\\\n\t\t__if_trace = {\t\t\t\t\\\n\t\t\t.func = __func__,\t\t\\\n\t\t\t.file = __FILE__,\t\t\\\n\t\t\t.line = __LINE__,\t\t\\\n\t\t};\t\t\t\t\t\\\n\t(cond) ?\t\t\t\t\t\\\n\t\t(__if_trace.miss_hit[1]++,1) :\t\t\\\n\t\t(__if_trace.miss_hit[0]++,0);\t\t\\\n})\n\n#endif /* CONFIG_PROFILE_ALL_BRANCHES */\n\n#else\n# define likely(x)\t__builtin_expect(!!(x), 1)\n# define unlikely(x)\t__builtin_expect(!!(x), 0)\n#endif\n\n/* Optimization barrier */\n#ifndef barrier\n/* The \"volatile\" is due to gcc bugs */\n# define barrier() __asm__ __volatile__(\"\": : :\"memory\")\n#endif\n\n#ifndef barrier_data\n/*\n * This version is i.e. to prevent dead stores elimination on @ptr\n * where gcc and llvm may behave differently when otherwise using\n * normal barrier(): while gcc behavior gets along with a normal\n * barrier(), llvm needs an explicit input variable to be assumed\n * clobbered. The issue is as follows: while the inline asm might\n * access any memory it wants, the compiler could have fit all of\n * @ptr into memory registers instead, and since @ptr never escaped\n * from that, it proved that the inline asm wasn't touching any of\n * it. This version works well with both compilers, i.e. we're telling\n * the compiler that the inline asm absolutely may see the contents\n * of @ptr. See also: https://llvm.org/bugs/show_bug.cgi?id=15495\n */\n# define barrier_data(ptr) __asm__ __volatile__(\"\": :\"r\"(ptr) :\"memory\")\n#endif\n\n/* workaround for GCC PR82365 if needed */\n#ifndef barrier_before_unreachable\n# define barrier_before_unreachable() do { } while (0)\n#endif\n\n/* Unreachable code */\n#ifdef CONFIG_STACK_VALIDATION\n/*\n * These macros help objtool understand GCC code flow for unreachable code.\n * The __COUNTER__ based labels are a hack to make each instance of the macros\n * unique, to convince GCC not to merge duplicate inline asm statements.\n */\n#define annotate_reachable() ({\t\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.reachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define annotate_unreachable() ({\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.unreachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define ASM_UNREACHABLE\t\t\t\t\t\t\t\\\n\t\"999:\\n\\t\"\t\t\t\t\t\t\t\\\n\t\".pushsection .discard.unreachable\\n\\t\"\t\t\t\t\\\n\t\".long 999b - .\\n\\t\"\t\t\t\t\t\t\\\n\t\".popsection\\n\\t\"\n\n/* Annotate a C jump table to allow objtool to follow the code flow */\n#define __annotate_jump_table __section(\".rodata..c_jump_table\")\n\n#else\n#define annotate_reachable()\n#define annotate_unreachable()\n#define __annotate_jump_table\n#endif\n\n#ifndef ASM_UNREACHABLE\n# define ASM_UNREACHABLE\n#endif\n#ifndef unreachable\n# define unreachable() do {\t\t\\\n\tannotate_unreachable();\t\t\\\n\t__builtin_unreachable();\t\\\n} while (0)\n#endif\n\n#ifdef __has_builtin\n#define has_builtin(x) __has_builtin(x)\n#else\n#define has_builtin(x) (0)\n#endif\n\n/*\n * KENTRY - kernel entry point\n * This can be used to annotate symbols (functions or data) that are used\n * without their linker symbol being referenced explicitly. For example,\n * interrupt vector handlers, or functions in the kernel image that are found\n * programatically.\n *\n * Not required for symbols exported with EXPORT_SYMBOL, or initcalls. Those\n * are handled in their own way (with KEEP() in linker scripts).\n *\n * KENTRY can be avoided if the symbols in question are marked as KEEP() in the\n * linker script. For example an architecture could KEEP() its entire\n * boot/exception vector code rather than annotate each function and data.\n */\n#ifndef KENTRY\n# define KENTRY(sym)\t\t\t\t\t\t\\\n\textern typeof(sym) sym;\t\t\t\t\t\\\n\tstatic const unsigned long __kentry_##sym\t\t\\\n\t__used\t\t\t\t\t\t\t\\\n\t__attribute__((__section__(\"___kentry+\" #sym)))\t\t\\\n\t= (unsigned long)&sym;\n#endif\n\n#ifndef RELOC_HIDE\n# define RELOC_HIDE(ptr, off)\t\t\t\t\t\\\n  ({ unsigned long __ptr;\t\t\t\t\t\\\n     __ptr = (unsigned long) (ptr);\t\t\t\t\\\n    (typeof(ptr)) (__ptr + (off)); })\n#endif\n\n#ifndef OPTIMIZER_HIDE_VAR\n/* Make the optimizer believe the variable can be manipulated arbitrarily. */\n#define OPTIMIZER_HIDE_VAR(var)\t\t\t\t\t\t\\\n\t__asm__ (\"\" : \"=r\" (var) : \"0\" (var))\n#endif\n\n/* Not-quite-unique ID. */\n#ifndef __UNIQUE_ID\n# define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __LINE__)\n#endif\n\n/**\n * data_race - mark an expression as containing intentional data races\n *\n * This data_race() macro is useful for situations in which data races\n * should be forgiven.  One example is diagnostic code that accesses\n * shared variables but is not a part of the core synchronization design.\n *\n * This macro *does not* affect normal code generation, but is a hint\n * to tooling that data races here are to be ignored.\n */\n#define data_race(expr)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__unqual_scalar_typeof(({ expr; })) __v = ({\t\t\t\\\n\t\t__kcsan_disable_current();\t\t\t\t\\\n\t\texpr;\t\t\t\t\t\t\t\\\n\t});\t\t\t\t\t\t\t\t\\\n\t__kcsan_enable_current();\t\t\t\t\t\\\n\t__v;\t\t\t\t\t\t\t\t\\\n})\n\n#endif /* __KERNEL__ */\n\n/*\n * Force the compiler to emit 'sym' as a symbol, so that we can reference\n * it from inline assembler. Necessary in case 'sym' could be inlined\n * otherwise, or eliminated entirely due to lack of references that are\n * visible to the compiler.\n */\n#define __ADDRESSABLE(sym) \\\n\tstatic void * __section(\".discard.addressable\") __used \\\n\t\t__UNIQUE_ID(__PASTE(__addressable_,sym)) = (void *)&sym;\n\n/**\n * offset_to_ptr - convert a relative memory offset to an absolute pointer\n * @off:\tthe address of the 32-bit offset value\n */\nstatic inline void *offset_to_ptr(const int *off)\n{\n\treturn (void *)((unsigned long)off + *off);\n}\n\n#endif /* __ASSEMBLY__ */\n\n/* &a[0] degrades to a pointer: a different type from an array */\n#define __must_be_array(a)\tBUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))\n\n/*\n * This is needed in functions which generate the stack canary, see\n * arch/x86/kernel/smpboot.c::start_secondary() for an example.\n */\n#define prevent_tail_call_optimization()\tmb()\n\n#include <asm/rwonce.h>\n\n#endif /* __LINUX_COMPILER_H */\n"}, "3": {"id": 3, "path": "/src/include/linux/byteorder/generic.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_BYTEORDER_GENERIC_H\n#define _LINUX_BYTEORDER_GENERIC_H\n\n/*\n * linux/byteorder/generic.h\n * Generic Byte-reordering support\n *\n * The \"... p\" macros, like le64_to_cpup, can be used with pointers\n * to unaligned data, but there will be a performance penalty on \n * some architectures.  Use get_unaligned for unaligned data.\n *\n * Francois-Rene Rideau <fare@tunes.org> 19970707\n *    gathered all the good ideas from all asm-foo/byteorder.h into one file,\n *    cleaned them up.\n *    I hope it is compliant with non-GCC compilers.\n *    I decided to put __BYTEORDER_HAS_U64__ in byteorder.h,\n *    because I wasn't sure it would be ok to put it in types.h\n *    Upgraded it to 2.1.43\n * Francois-Rene Rideau <fare@tunes.org> 19971012\n *    Upgraded it to 2.1.57\n *    to please Linus T., replaced huge #ifdef's between little/big endian\n *    by nestedly #include'd files.\n * Francois-Rene Rideau <fare@tunes.org> 19971205\n *    Made it to 2.1.71; now a facelift:\n *    Put files under include/linux/byteorder/\n *    Split swab from generic support.\n *\n * TODO:\n *   = Regular kernel maintainers could also replace all these manual\n *    byteswap macros that remain, disseminated among drivers,\n *    after some grep or the sources...\n *   = Linus might want to rename all these macros and files to fit his taste,\n *    to fit his personal naming scheme.\n *   = it seems that a few drivers would also appreciate\n *    nybble swapping support...\n *   = every architecture could add their byteswap macro in asm/byteorder.h\n *    see how some architectures already do (i386, alpha, ppc, etc)\n *   = cpu_to_beXX and beXX_to_cpu might some day need to be well\n *    distinguished throughout the kernel. This is not the case currently,\n *    since little endian, big endian, and pdp endian machines needn't it.\n *    But this might be the case for, say, a port of Linux to 20/21 bit\n *    architectures (and F21 Linux addict around?).\n */\n\n/*\n * The following macros are to be defined by <asm/byteorder.h>:\n *\n * Conversion of long and short int between network and host format\n *\tntohl(__u32 x)\n *\tntohs(__u16 x)\n *\thtonl(__u32 x)\n *\thtons(__u16 x)\n * It seems that some programs (which? where? or perhaps a standard? POSIX?)\n * might like the above to be functions, not macros (why?).\n * if that's true, then detect them, and take measures.\n * Anyway, the measure is: define only ___ntohl as a macro instead,\n * and in a separate file, have\n * unsigned long inline ntohl(x){return ___ntohl(x);}\n *\n * The same for constant arguments\n *\t__constant_ntohl(__u32 x)\n *\t__constant_ntohs(__u16 x)\n *\t__constant_htonl(__u32 x)\n *\t__constant_htons(__u16 x)\n *\n * Conversion of XX-bit integers (16- 32- or 64-)\n * between native CPU format and little/big endian format\n * 64-bit stuff only defined for proper architectures\n *\tcpu_to_[bl]eXX(__uXX x)\n *\t[bl]eXX_to_cpu(__uXX x)\n *\n * The same, but takes a pointer to the value to convert\n *\tcpu_to_[bl]eXXp(__uXX x)\n *\t[bl]eXX_to_cpup(__uXX x)\n *\n * The same, but change in situ\n *\tcpu_to_[bl]eXXs(__uXX x)\n *\t[bl]eXX_to_cpus(__uXX x)\n *\n * See asm-foo/byteorder.h for examples of how to provide\n * architecture-optimized versions\n *\n */\n\n#define cpu_to_le64 __cpu_to_le64\n#define le64_to_cpu __le64_to_cpu\n#define cpu_to_le32 __cpu_to_le32\n#define le32_to_cpu __le32_to_cpu\n#define cpu_to_le16 __cpu_to_le16\n#define le16_to_cpu __le16_to_cpu\n#define cpu_to_be64 __cpu_to_be64\n#define be64_to_cpu __be64_to_cpu\n#define cpu_to_be32 __cpu_to_be32\n#define be32_to_cpu __be32_to_cpu\n#define cpu_to_be16 __cpu_to_be16\n#define be16_to_cpu __be16_to_cpu\n#define cpu_to_le64p __cpu_to_le64p\n#define le64_to_cpup __le64_to_cpup\n#define cpu_to_le32p __cpu_to_le32p\n#define le32_to_cpup __le32_to_cpup\n#define cpu_to_le16p __cpu_to_le16p\n#define le16_to_cpup __le16_to_cpup\n#define cpu_to_be64p __cpu_to_be64p\n#define be64_to_cpup __be64_to_cpup\n#define cpu_to_be32p __cpu_to_be32p\n#define be32_to_cpup __be32_to_cpup\n#define cpu_to_be16p __cpu_to_be16p\n#define be16_to_cpup __be16_to_cpup\n#define cpu_to_le64s __cpu_to_le64s\n#define le64_to_cpus __le64_to_cpus\n#define cpu_to_le32s __cpu_to_le32s\n#define le32_to_cpus __le32_to_cpus\n#define cpu_to_le16s __cpu_to_le16s\n#define le16_to_cpus __le16_to_cpus\n#define cpu_to_be64s __cpu_to_be64s\n#define be64_to_cpus __be64_to_cpus\n#define cpu_to_be32s __cpu_to_be32s\n#define be32_to_cpus __be32_to_cpus\n#define cpu_to_be16s __cpu_to_be16s\n#define be16_to_cpus __be16_to_cpus\n\n/*\n * They have to be macros in order to do the constant folding\n * correctly - if the argument passed into a inline function\n * it is no longer constant according to gcc..\n */\n\n#undef ntohl\n#undef ntohs\n#undef htonl\n#undef htons\n\n#define ___htonl(x) __cpu_to_be32(x)\n#define ___htons(x) __cpu_to_be16(x)\n#define ___ntohl(x) __be32_to_cpu(x)\n#define ___ntohs(x) __be16_to_cpu(x)\n\n#define htonl(x) ___htonl(x)\n#define ntohl(x) ___ntohl(x)\n#define htons(x) ___htons(x)\n#define ntohs(x) ___ntohs(x)\n\nstatic inline void le16_add_cpu(__le16 *var, u16 val)\n{\n\t*var = cpu_to_le16(le16_to_cpu(*var) + val);\n}\n\nstatic inline void le32_add_cpu(__le32 *var, u32 val)\n{\n\t*var = cpu_to_le32(le32_to_cpu(*var) + val);\n}\n\nstatic inline void le64_add_cpu(__le64 *var, u64 val)\n{\n\t*var = cpu_to_le64(le64_to_cpu(*var) + val);\n}\n\n/* XXX: this stuff can be optimized */\nstatic inline void le32_to_cpu_array(u32 *buf, unsigned int words)\n{\n\twhile (words--) {\n\t\t__le32_to_cpus(buf);\n\t\tbuf++;\n\t}\n}\n\nstatic inline void cpu_to_le32_array(u32 *buf, unsigned int words)\n{\n\twhile (words--) {\n\t\t__cpu_to_le32s(buf);\n\t\tbuf++;\n\t}\n}\n\nstatic inline void be16_add_cpu(__be16 *var, u16 val)\n{\n\t*var = cpu_to_be16(be16_to_cpu(*var) + val);\n}\n\nstatic inline void be32_add_cpu(__be32 *var, u32 val)\n{\n\t*var = cpu_to_be32(be32_to_cpu(*var) + val);\n}\n\nstatic inline void be64_add_cpu(__be64 *var, u64 val)\n{\n\t*var = cpu_to_be64(be64_to_cpu(*var) + val);\n}\n\nstatic inline void cpu_to_be32_array(__be32 *dst, const u32 *src, size_t len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdst[i] = cpu_to_be32(src[i]);\n}\n\nstatic inline void be32_to_cpu_array(u32 *dst, const __be32 *src, size_t len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdst[i] = be32_to_cpu(src[i]);\n}\n\n#endif /* _LINUX_BYTEORDER_GENERIC_H */\n"}, "4": {"id": 4, "path": "/src/include/uapi/linux/byteorder/little_endian.h", "content": "/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n#ifndef _UAPI_LINUX_BYTEORDER_LITTLE_ENDIAN_H\n#define _UAPI_LINUX_BYTEORDER_LITTLE_ENDIAN_H\n\n#ifndef __LITTLE_ENDIAN\n#define __LITTLE_ENDIAN 1234\n#endif\n#ifndef __LITTLE_ENDIAN_BITFIELD\n#define __LITTLE_ENDIAN_BITFIELD\n#endif\n\n#include <linux/types.h>\n#include <linux/swab.h>\n\n#define __constant_htonl(x) ((__force __be32)___constant_swab32((x)))\n#define __constant_ntohl(x) ___constant_swab32((__force __be32)(x))\n#define __constant_htons(x) ((__force __be16)___constant_swab16((x)))\n#define __constant_ntohs(x) ___constant_swab16((__force __be16)(x))\n#define __constant_cpu_to_le64(x) ((__force __le64)(__u64)(x))\n#define __constant_le64_to_cpu(x) ((__force __u64)(__le64)(x))\n#define __constant_cpu_to_le32(x) ((__force __le32)(__u32)(x))\n#define __constant_le32_to_cpu(x) ((__force __u32)(__le32)(x))\n#define __constant_cpu_to_le16(x) ((__force __le16)(__u16)(x))\n#define __constant_le16_to_cpu(x) ((__force __u16)(__le16)(x))\n#define __constant_cpu_to_be64(x) ((__force __be64)___constant_swab64((x)))\n#define __constant_be64_to_cpu(x) ___constant_swab64((__force __u64)(__be64)(x))\n#define __constant_cpu_to_be32(x) ((__force __be32)___constant_swab32((x)))\n#define __constant_be32_to_cpu(x) ___constant_swab32((__force __u32)(__be32)(x))\n#define __constant_cpu_to_be16(x) ((__force __be16)___constant_swab16((x)))\n#define __constant_be16_to_cpu(x) ___constant_swab16((__force __u16)(__be16)(x))\n#define __cpu_to_le64(x) ((__force __le64)(__u64)(x))\n#define __le64_to_cpu(x) ((__force __u64)(__le64)(x))\n#define __cpu_to_le32(x) ((__force __le32)(__u32)(x))\n#define __le32_to_cpu(x) ((__force __u32)(__le32)(x))\n#define __cpu_to_le16(x) ((__force __le16)(__u16)(x))\n#define __le16_to_cpu(x) ((__force __u16)(__le16)(x))\n#define __cpu_to_be64(x) ((__force __be64)__swab64((x)))\n#define __be64_to_cpu(x) __swab64((__force __u64)(__be64)(x))\n#define __cpu_to_be32(x) ((__force __be32)__swab32((x)))\n#define __be32_to_cpu(x) __swab32((__force __u32)(__be32)(x))\n#define __cpu_to_be16(x) ((__force __be16)__swab16((x)))\n#define __be16_to_cpu(x) __swab16((__force __u16)(__be16)(x))\n\nstatic __always_inline __le64 __cpu_to_le64p(const __u64 *p)\n{\n\treturn (__force __le64)*p;\n}\nstatic __always_inline __u64 __le64_to_cpup(const __le64 *p)\n{\n\treturn (__force __u64)*p;\n}\nstatic __always_inline __le32 __cpu_to_le32p(const __u32 *p)\n{\n\treturn (__force __le32)*p;\n}\nstatic __always_inline __u32 __le32_to_cpup(const __le32 *p)\n{\n\treturn (__force __u32)*p;\n}\nstatic __always_inline __le16 __cpu_to_le16p(const __u16 *p)\n{\n\treturn (__force __le16)*p;\n}\nstatic __always_inline __u16 __le16_to_cpup(const __le16 *p)\n{\n\treturn (__force __u16)*p;\n}\nstatic __always_inline __be64 __cpu_to_be64p(const __u64 *p)\n{\n\treturn (__force __be64)__swab64p(p);\n}\nstatic __always_inline __u64 __be64_to_cpup(const __be64 *p)\n{\n\treturn __swab64p((__u64 *)p);\n}\nstatic __always_inline __be32 __cpu_to_be32p(const __u32 *p)\n{\n\treturn (__force __be32)__swab32p(p);\n}\nstatic __always_inline __u32 __be32_to_cpup(const __be32 *p)\n{\n\treturn __swab32p((__u32 *)p);\n}\nstatic __always_inline __be16 __cpu_to_be16p(const __u16 *p)\n{\n\treturn (__force __be16)__swab16p(p);\n}\nstatic __always_inline __u16 __be16_to_cpup(const __be16 *p)\n{\n\treturn __swab16p((__u16 *)p);\n}\n#define __cpu_to_le64s(x) do { (void)(x); } while (0)\n#define __le64_to_cpus(x) do { (void)(x); } while (0)\n#define __cpu_to_le32s(x) do { (void)(x); } while (0)\n#define __le32_to_cpus(x) do { (void)(x); } while (0)\n#define __cpu_to_le16s(x) do { (void)(x); } while (0)\n#define __le16_to_cpus(x) do { (void)(x); } while (0)\n#define __cpu_to_be64s(x) __swab64s((x))\n#define __be64_to_cpus(x) __swab64s((x))\n#define __cpu_to_be32s(x) __swab32s((x))\n#define __be32_to_cpus(x) __swab32s((x))\n#define __cpu_to_be16s(x) __swab16s((x))\n#define __be16_to_cpus(x) __swab16s((x))\n\n\n#endif /* _UAPI_LINUX_BYTEORDER_LITTLE_ENDIAN_H */\n"}, "5": {"id": 5, "path": "/src/include/uapi/linux/swab.h", "content": "/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n#ifndef _UAPI_LINUX_SWAB_H\n#define _UAPI_LINUX_SWAB_H\n\n#include <linux/types.h>\n#include <linux/compiler.h>\n#include <asm/bitsperlong.h>\n#include <asm/swab.h>\n\n/*\n * casts are necessary for constants, because we never know how for sure\n * how U/UL/ULL map to __u16, __u32, __u64. At least not in a portable way.\n */\n#define ___constant_swab16(x) ((__u16)(\t\t\t\t\\\n\t(((__u16)(x) & (__u16)0x00ffU) << 8) |\t\t\t\\\n\t(((__u16)(x) & (__u16)0xff00U) >> 8)))\n\n#define ___constant_swab32(x) ((__u32)(\t\t\t\t\\\n\t(((__u32)(x) & (__u32)0x000000ffUL) << 24) |\t\t\\\n\t(((__u32)(x) & (__u32)0x0000ff00UL) <<  8) |\t\t\\\n\t(((__u32)(x) & (__u32)0x00ff0000UL) >>  8) |\t\t\\\n\t(((__u32)(x) & (__u32)0xff000000UL) >> 24)))\n\n#define ___constant_swab64(x) ((__u64)(\t\t\t\t\\\n\t(((__u64)(x) & (__u64)0x00000000000000ffULL) << 56) |\t\\\n\t(((__u64)(x) & (__u64)0x000000000000ff00ULL) << 40) |\t\\\n\t(((__u64)(x) & (__u64)0x0000000000ff0000ULL) << 24) |\t\\\n\t(((__u64)(x) & (__u64)0x00000000ff000000ULL) <<  8) |\t\\\n\t(((__u64)(x) & (__u64)0x000000ff00000000ULL) >>  8) |\t\\\n\t(((__u64)(x) & (__u64)0x0000ff0000000000ULL) >> 24) |\t\\\n\t(((__u64)(x) & (__u64)0x00ff000000000000ULL) >> 40) |\t\\\n\t(((__u64)(x) & (__u64)0xff00000000000000ULL) >> 56)))\n\n#define ___constant_swahw32(x) ((__u32)(\t\t\t\\\n\t(((__u32)(x) & (__u32)0x0000ffffUL) << 16) |\t\t\\\n\t(((__u32)(x) & (__u32)0xffff0000UL) >> 16)))\n\n#define ___constant_swahb32(x) ((__u32)(\t\t\t\\\n\t(((__u32)(x) & (__u32)0x00ff00ffUL) << 8) |\t\t\\\n\t(((__u32)(x) & (__u32)0xff00ff00UL) >> 8)))\n\n/*\n * Implement the following as inlines, but define the interface using\n * macros to allow constant folding when possible:\n * ___swab16, ___swab32, ___swab64, ___swahw32, ___swahb32\n */\n\nstatic inline __attribute_const__ __u16 __fswab16(__u16 val)\n{\n#if defined (__arch_swab16)\n\treturn __arch_swab16(val);\n#else\n\treturn ___constant_swab16(val);\n#endif\n}\n\nstatic inline __attribute_const__ __u32 __fswab32(__u32 val)\n{\n#if defined(__arch_swab32)\n\treturn __arch_swab32(val);\n#else\n\treturn ___constant_swab32(val);\n#endif\n}\n\nstatic inline __attribute_const__ __u64 __fswab64(__u64 val)\n{\n#if defined (__arch_swab64)\n\treturn __arch_swab64(val);\n#elif defined(__SWAB_64_THRU_32__)\n\t__u32 h = val >> 32;\n\t__u32 l = val & ((1ULL << 32) - 1);\n\treturn (((__u64)__fswab32(l)) << 32) | ((__u64)(__fswab32(h)));\n#else\n\treturn ___constant_swab64(val);\n#endif\n}\n\nstatic inline __attribute_const__ __u32 __fswahw32(__u32 val)\n{\n#ifdef __arch_swahw32\n\treturn __arch_swahw32(val);\n#else\n\treturn ___constant_swahw32(val);\n#endif\n}\n\nstatic inline __attribute_const__ __u32 __fswahb32(__u32 val)\n{\n#ifdef __arch_swahb32\n\treturn __arch_swahb32(val);\n#else\n\treturn ___constant_swahb32(val);\n#endif\n}\n\n/**\n * __swab16 - return a byteswapped 16-bit value\n * @x: value to byteswap\n */\n#ifdef __HAVE_BUILTIN_BSWAP16__\n#define __swab16(x) (__u16)__builtin_bswap16((__u16)(x))\n#else\n#define __swab16(x)\t\t\t\t\\\n\t(__builtin_constant_p((__u16)(x)) ?\t\\\n\t___constant_swab16(x) :\t\t\t\\\n\t__fswab16(x))\n#endif\n\n/**\n * __swab32 - return a byteswapped 32-bit value\n * @x: value to byteswap\n */\n#ifdef __HAVE_BUILTIN_BSWAP32__\n#define __swab32(x) (__u32)__builtin_bswap32((__u32)(x))\n#else\n#define __swab32(x)\t\t\t\t\\\n\t(__builtin_constant_p((__u32)(x)) ?\t\\\n\t___constant_swab32(x) :\t\t\t\\\n\t__fswab32(x))\n#endif\n\n/**\n * __swab64 - return a byteswapped 64-bit value\n * @x: value to byteswap\n */\n#ifdef __HAVE_BUILTIN_BSWAP64__\n#define __swab64(x) (__u64)__builtin_bswap64((__u64)(x))\n#else\n#define __swab64(x)\t\t\t\t\\\n\t(__builtin_constant_p((__u64)(x)) ?\t\\\n\t___constant_swab64(x) :\t\t\t\\\n\t__fswab64(x))\n#endif\n\nstatic __always_inline unsigned long __swab(const unsigned long y)\n{\n#if __BITS_PER_LONG == 64\n\treturn __swab64(y);\n#else /* __BITS_PER_LONG == 32 */\n\treturn __swab32(y);\n#endif\n}\n\n/**\n * __swahw32 - return a word-swapped 32-bit value\n * @x: value to wordswap\n *\n * __swahw32(0x12340000) is 0x00001234\n */\n#define __swahw32(x)\t\t\t\t\\\n\t(__builtin_constant_p((__u32)(x)) ?\t\\\n\t___constant_swahw32(x) :\t\t\\\n\t__fswahw32(x))\n\n/**\n * __swahb32 - return a high and low byte-swapped 32-bit value\n * @x: value to byteswap\n *\n * __swahb32(0x12345678) is 0x34127856\n */\n#define __swahb32(x)\t\t\t\t\\\n\t(__builtin_constant_p((__u32)(x)) ?\t\\\n\t___constant_swahb32(x) :\t\t\\\n\t__fswahb32(x))\n\n/**\n * __swab16p - return a byteswapped 16-bit value from a pointer\n * @p: pointer to a naturally-aligned 16-bit value\n */\nstatic __always_inline __u16 __swab16p(const __u16 *p)\n{\n#ifdef __arch_swab16p\n\treturn __arch_swab16p(p);\n#else\n\treturn __swab16(*p);\n#endif\n}\n\n/**\n * __swab32p - return a byteswapped 32-bit value from a pointer\n * @p: pointer to a naturally-aligned 32-bit value\n */\nstatic __always_inline __u32 __swab32p(const __u32 *p)\n{\n#ifdef __arch_swab32p\n\treturn __arch_swab32p(p);\n#else\n\treturn __swab32(*p);\n#endif\n}\n\n/**\n * __swab64p - return a byteswapped 64-bit value from a pointer\n * @p: pointer to a naturally-aligned 64-bit value\n */\nstatic __always_inline __u64 __swab64p(const __u64 *p)\n{\n#ifdef __arch_swab64p\n\treturn __arch_swab64p(p);\n#else\n\treturn __swab64(*p);\n#endif\n}\n\n/**\n * __swahw32p - return a wordswapped 32-bit value from a pointer\n * @p: pointer to a naturally-aligned 32-bit value\n *\n * See __swahw32() for details of wordswapping.\n */\nstatic inline __u32 __swahw32p(const __u32 *p)\n{\n#ifdef __arch_swahw32p\n\treturn __arch_swahw32p(p);\n#else\n\treturn __swahw32(*p);\n#endif\n}\n\n/**\n * __swahb32p - return a high and low byteswapped 32-bit value from a pointer\n * @p: pointer to a naturally-aligned 32-bit value\n *\n * See __swahb32() for details of high/low byteswapping.\n */\nstatic inline __u32 __swahb32p(const __u32 *p)\n{\n#ifdef __arch_swahb32p\n\treturn __arch_swahb32p(p);\n#else\n\treturn __swahb32(*p);\n#endif\n}\n\n/**\n * __swab16s - byteswap a 16-bit value in-place\n * @p: pointer to a naturally-aligned 16-bit value\n */\nstatic inline void __swab16s(__u16 *p)\n{\n#ifdef __arch_swab16s\n\t__arch_swab16s(p);\n#else\n\t*p = __swab16p(p);\n#endif\n}\n/**\n * __swab32s - byteswap a 32-bit value in-place\n * @p: pointer to a naturally-aligned 32-bit value\n */\nstatic __always_inline void __swab32s(__u32 *p)\n{\n#ifdef __arch_swab32s\n\t__arch_swab32s(p);\n#else\n\t*p = __swab32p(p);\n#endif\n}\n\n/**\n * __swab64s - byteswap a 64-bit value in-place\n * @p: pointer to a naturally-aligned 64-bit value\n */\nstatic __always_inline void __swab64s(__u64 *p)\n{\n#ifdef __arch_swab64s\n\t__arch_swab64s(p);\n#else\n\t*p = __swab64p(p);\n#endif\n}\n\n/**\n * __swahw32s - wordswap a 32-bit value in-place\n * @p: pointer to a naturally-aligned 32-bit value\n *\n * See __swahw32() for details of wordswapping\n */\nstatic inline void __swahw32s(__u32 *p)\n{\n#ifdef __arch_swahw32s\n\t__arch_swahw32s(p);\n#else\n\t*p = __swahw32p(p);\n#endif\n}\n\n/**\n * __swahb32s - high and low byteswap a 32-bit value in-place\n * @p: pointer to a naturally-aligned 32-bit value\n *\n * See __swahb32() for details of high and low byte swapping\n */\nstatic inline void __swahb32s(__u32 *p)\n{\n#ifdef __arch_swahb32s\n\t__arch_swahb32s(p);\n#else\n\t*p = __swahb32p(p);\n#endif\n}\n\n\n#endif /* _UAPI_LINUX_SWAB_H */\n"}}, "reports": [{"events": [{"location": {"col": 2, "file": 0, "line": 2563}, "message": "Calling 'encode_setattr'"}, {"location": {"col": 2, "file": 0, "line": 1697}, "message": "Calling 'encode_attrs'"}, {"location": {"col": 7, "file": 0, "line": 1086}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 0, "line": 1086}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 1090}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1090}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1099}, "message": "Assuming the condition is false"}, {"location": {"col": 33, "file": 0, "line": 1099}, "message": "Left side of '&&' is false"}, {"location": {"col": 7, "file": 0, "line": 1112}, "message": "Assuming the condition is false"}, {"location": {"col": 33, "file": 0, "line": 1112}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 1125}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 0, "line": 1125}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 1126}, "message": "Assuming the condition is true"}, {"location": {"col": 3, "file": 0, "line": 1126}, "message": "Taking true branch"}, {"location": {"col": 6, "file": 0, "line": 1134}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1134}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1144}, "message": "Assuming 'label' is null"}, {"location": {"col": 12, "file": 0, "line": 1144}, "message": "Left side of '&&' is false"}, {"location": {"col": 2, "file": 0, "line": 1150}, "message": "Calling 'xdr_stream_encode_opaque_inline'"}, {"location": {"col": 15, "file": 1, "line": 405}, "message": "Assuming 'p' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 1, "line": 405}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 0, "line": 1150}, "message": "Returning from 'xdr_stream_encode_opaque_inline'"}, {"location": {"col": 2, "file": 0, "line": 1152}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1154}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1156}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1158}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1160}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 1161}, "message": "Taking true branch"}, {"location": {"col": 11, "file": 0, "line": 1162}, "message": "'?' condition is true"}, {"location": {"col": 21, "file": 3, "line": 94}, "message": "expanded from macro 'cpu_to_be32'"}, {"location": {"col": 43, "file": 4, "line": 39}, "message": "expanded from macro '__cpu_to_be32'"}, {"location": {"col": 3, "file": 5, "line": 118}, "message": "expanded from macro '__swab32'"}, {"location": {"col": 5, "file": 0, "line": 1162}, "message": "Null pointer value stored to 'p'"}, {"location": {"col": 9, "file": 0, "line": 1162}, "message": "Dereference of null pointer"}, {"location": {"col": 9, "file": 0, "line": 1162}, "message": "Dereference of null pointer"}], "macros": [], "notes": [], "path": "/src/fs/nfs/nfs4xdr.c", "reportHash": "f1a0f3393eba81d4d938e396384bac62", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 0, "line": 2563}, "message": "Calling 'encode_setattr'"}, {"location": {"col": 2, "file": 0, "line": 1697}, "message": "Calling 'encode_attrs'"}, {"location": {"col": 7, "file": 0, "line": 1086}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 0, "line": 1086}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 1090}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1090}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1099}, "message": "Assuming the condition is false"}, {"location": {"col": 33, "file": 0, "line": 1099}, "message": "Left side of '&&' is false"}, {"location": {"col": 7, "file": 0, "line": 1112}, "message": "Assuming the condition is false"}, {"location": {"col": 33, "file": 0, "line": 1112}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 1125}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 0, "line": 1125}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 1126}, "message": "Assuming the condition is false"}, {"location": {"col": 3, "file": 0, "line": 1126}, "message": "Taking false branch"}, {"location": {"col": 14, "file": 0, "line": 1129}, "message": "Assuming the condition is true"}, {"location": {"col": 10, "file": 0, "line": 1129}, "message": "Taking true branch"}, {"location": {"col": 6, "file": 0, "line": 1134}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1134}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1144}, "message": "Assuming 'label' is null"}, {"location": {"col": 12, "file": 0, "line": 1144}, "message": "Left side of '&&' is false"}, {"location": {"col": 2, "file": 0, "line": 1150}, "message": "Calling 'xdr_stream_encode_opaque_inline'"}, {"location": {"col": 15, "file": 1, "line": 405}, "message": "Assuming 'p' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 1, "line": 405}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 0, "line": 1150}, "message": "Returning from 'xdr_stream_encode_opaque_inline'"}, {"location": {"col": 2, "file": 0, "line": 1152}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1154}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1156}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1158}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1160}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 1161}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 1165}, "message": "'?' condition is true"}, {"location": {"col": 21, "file": 3, "line": 94}, "message": "expanded from macro 'cpu_to_be32'"}, {"location": {"col": 43, "file": 4, "line": 39}, "message": "expanded from macro '__cpu_to_be32'"}, {"location": {"col": 3, "file": 5, "line": 118}, "message": "expanded from macro '__swab32'"}, {"location": {"col": 5, "file": 0, "line": 1165}, "message": "Null pointer value stored to 'p'"}, {"location": {"col": 9, "file": 0, "line": 1165}, "message": "Dereference of null pointer"}, {"location": {"col": 9, "file": 0, "line": 1165}, "message": "Dereference of null pointer"}], "macros": [], "notes": [], "path": "/src/fs/nfs/nfs4xdr.c", "reportHash": "51b1653f4b784e88a2c7b453e1051f61", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 0, "line": 2563}, "message": "Calling 'encode_setattr'"}, {"location": {"col": 2, "file": 0, "line": 1697}, "message": "Calling 'encode_attrs'"}, {"location": {"col": 7, "file": 0, "line": 1086}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 0, "line": 1086}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 1090}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1090}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1099}, "message": "Assuming the condition is false"}, {"location": {"col": 33, "file": 0, "line": 1099}, "message": "Left side of '&&' is false"}, {"location": {"col": 7, "file": 0, "line": 1112}, "message": "Assuming the condition is false"}, {"location": {"col": 33, "file": 0, "line": 1112}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 1125}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1125}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1134}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 0, "line": 1134}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 1135}, "message": "Assuming the condition is true"}, {"location": {"col": 3, "file": 0, "line": 1135}, "message": "Taking true branch"}, {"location": {"col": 6, "file": 0, "line": 1144}, "message": "Assuming 'label' is null"}, {"location": {"col": 12, "file": 0, "line": 1144}, "message": "Left side of '&&' is false"}, {"location": {"col": 2, "file": 0, "line": 1150}, "message": "Calling 'xdr_stream_encode_opaque_inline'"}, {"location": {"col": 15, "file": 1, "line": 405}, "message": "Assuming 'p' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 1, "line": 405}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 0, "line": 1150}, "message": "Returning from 'xdr_stream_encode_opaque_inline'"}, {"location": {"col": 2, "file": 0, "line": 1152}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1154}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1156}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1158}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1160}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1167}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 1168}, "message": "Taking true branch"}, {"location": {"col": 11, "file": 0, "line": 1169}, "message": "'?' condition is true"}, {"location": {"col": 21, "file": 3, "line": 94}, "message": "expanded from macro 'cpu_to_be32'"}, {"location": {"col": 43, "file": 4, "line": 39}, "message": "expanded from macro '__cpu_to_be32'"}, {"location": {"col": 3, "file": 5, "line": 118}, "message": "expanded from macro '__swab32'"}, {"location": {"col": 5, "file": 0, "line": 1169}, "message": "Null pointer value stored to 'p'"}, {"location": {"col": 9, "file": 0, "line": 1169}, "message": "Dereference of null pointer"}, {"location": {"col": 9, "file": 0, "line": 1169}, "message": "Dereference of null pointer"}], "macros": [], "notes": [], "path": "/src/fs/nfs/nfs4xdr.c", "reportHash": "f1a0f3393eba81d4d938e396384bac62", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 0, "line": 2563}, "message": "Calling 'encode_setattr'"}, {"location": {"col": 2, "file": 0, "line": 1697}, "message": "Calling 'encode_attrs'"}, {"location": {"col": 7, "file": 0, "line": 1086}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 0, "line": 1086}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 1090}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1090}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1099}, "message": "Assuming the condition is false"}, {"location": {"col": 33, "file": 0, "line": 1099}, "message": "Left side of '&&' is false"}, {"location": {"col": 7, "file": 0, "line": 1112}, "message": "Assuming the condition is false"}, {"location": {"col": 33, "file": 0, "line": 1112}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 1125}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1125}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1134}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 0, "line": 1134}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 1135}, "message": "Assuming the condition is false"}, {"location": {"col": 3, "file": 0, "line": 1135}, "message": "Taking false branch"}, {"location": {"col": 14, "file": 0, "line": 1138}, "message": "Assuming the condition is true"}, {"location": {"col": 10, "file": 0, "line": 1138}, "message": "Taking true branch"}, {"location": {"col": 6, "file": 0, "line": 1144}, "message": "Assuming 'label' is null"}, {"location": {"col": 12, "file": 0, "line": 1144}, "message": "Left side of '&&' is false"}, {"location": {"col": 2, "file": 0, "line": 1150}, "message": "Calling 'xdr_stream_encode_opaque_inline'"}, {"location": {"col": 15, "file": 1, "line": 405}, "message": "Assuming 'p' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 1, "line": 405}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 0, "line": 1150}, "message": "Returning from 'xdr_stream_encode_opaque_inline'"}, {"location": {"col": 2, "file": 0, "line": 1152}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1154}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1156}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1158}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1160}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1167}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 1168}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 1172}, "message": "'?' condition is true"}, {"location": {"col": 21, "file": 3, "line": 94}, "message": "expanded from macro 'cpu_to_be32'"}, {"location": {"col": 43, "file": 4, "line": 39}, "message": "expanded from macro '__cpu_to_be32'"}, {"location": {"col": 3, "file": 5, "line": 118}, "message": "expanded from macro '__swab32'"}, {"location": {"col": 5, "file": 0, "line": 1172}, "message": "Null pointer value stored to 'p'"}, {"location": {"col": 9, "file": 0, "line": 1172}, "message": "Dereference of null pointer"}, {"location": {"col": 9, "file": 0, "line": 1172}, "message": "Dereference of null pointer"}], "macros": [], "notes": [], "path": "/src/fs/nfs/nfs4xdr.c", "reportHash": "51b1653f4b784e88a2c7b453e1051f61", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 0, "line": 2563}, "message": "Calling 'encode_setattr'"}, {"location": {"col": 2, "file": 0, "line": 1697}, "message": "Calling 'encode_attrs'"}, {"location": {"col": 7, "file": 0, "line": 1086}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 0, "line": 1086}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 1090}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1090}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1099}, "message": "Assuming the condition is false"}, {"location": {"col": 33, "file": 0, "line": 1099}, "message": "Left side of '&&' is false"}, {"location": {"col": 7, "file": 0, "line": 1112}, "message": "Assuming the condition is false"}, {"location": {"col": 33, "file": 0, "line": 1112}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 1125}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1125}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1134}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1134}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1144}, "message": "Assuming 'label' is non-null"}, {"location": {"col": 6, "file": 0, "line": 1144}, "message": "Left side of '&&' is true"}, {"location": {"col": 16, "file": 0, "line": 1144}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 0, "line": 1144}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 0, "line": 1150}, "message": "Calling 'xdr_stream_encode_opaque_inline'"}, {"location": {"col": 15, "file": 1, "line": 405}, "message": "Assuming 'p' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 1, "line": 405}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 0, "line": 1150}, "message": "Returning from 'xdr_stream_encode_opaque_inline'"}, {"location": {"col": 2, "file": 0, "line": 1152}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1154}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1156}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1158}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1160}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1167}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1174}, "message": "'label' is non-null"}, {"location": {"col": 6, "file": 0, "line": 1174}, "message": "Left side of '&&' is true"}, {"location": {"col": 2, "file": 0, "line": 1174}, "message": "Taking true branch"}, {"location": {"col": 10, "file": 0, "line": 1175}, "message": "'?' condition is false"}, {"location": {"col": 21, "file": 3, "line": 94}, "message": "expanded from macro 'cpu_to_be32'"}, {"location": {"col": 43, "file": 4, "line": 39}, "message": "expanded from macro '__cpu_to_be32'"}, {"location": {"col": 3, "file": 5, "line": 118}, "message": "expanded from macro '__swab32'"}, {"location": {"col": 4, "file": 0, "line": 1175}, "message": "Null pointer value stored to 'p'"}, {"location": {"col": 8, "file": 0, "line": 1175}, "message": "Dereference of null pointer"}, {"location": {"col": 8, "file": 0, "line": 1175}, "message": "Dereference of null pointer"}], "macros": [], "notes": [], "path": "/src/fs/nfs/nfs4xdr.c", "reportHash": "31baee0ca5387e377bd0db864bd740c6", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 0, "line": 1355}, "message": "Value stored to 'p' is never read"}, {"location": {"col": 2, "file": 0, "line": 1355}, "message": "Value stored to 'p' is never read"}], "macros": [], "notes": [], "path": "/src/fs/nfs/nfs4xdr.c", "reportHash": "42bb64dbbf60a2e1a5728d3fe14e2c1c", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 0, "line": 6719}, "message": "Calling 'decode_compound_hdr'"}, {"location": {"col": 15, "file": 0, "line": 3158}, "message": "Assuming 'p' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 3158}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 3159}, "message": "Returning without writing to 'hdr->status'"}, {"location": {"col": 11, "file": 0, "line": 6719}, "message": "Returning from 'decode_compound_hdr'"}, {"location": {"col": 17, "file": 0, "line": 6720}, "message": "Assigned value is garbage or undefined"}, {"location": {"col": 17, "file": 0, "line": 6720}, "message": "Assigned value is garbage or undefined"}], "macros": [], "notes": [], "path": "/src/fs/nfs/nfs4xdr.c", "reportHash": "a80b8e11f7bb6f82d9b7994cba49bc91", "checkerName": "clang-analyzer-core.uninitialized.Assign", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 0, "line": 6746}, "message": "Calling 'decode_compound_hdr'"}, {"location": {"col": 15, "file": 0, "line": 3158}, "message": "Assuming 'p' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 3158}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 3159}, "message": "Returning without writing to 'hdr->status'"}, {"location": {"col": 11, "file": 0, "line": 6746}, "message": "Returning from 'decode_compound_hdr'"}, {"location": {"col": 17, "file": 0, "line": 6747}, "message": "Assigned value is garbage or undefined"}, {"location": {"col": 17, "file": 0, "line": 6747}, "message": "Assigned value is garbage or undefined"}], "macros": [], "notes": [], "path": "/src/fs/nfs/nfs4xdr.c", "reportHash": "a80b8e11f7bb6f82d9b7994cba49bc91", "checkerName": "clang-analyzer-core.uninitialized.Assign", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 0, "line": 6777}, "message": "Calling 'decode_compound_hdr'"}, {"location": {"col": 15, "file": 0, "line": 3158}, "message": "Assuming 'p' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 3158}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 3159}, "message": "Returning without writing to 'hdr->status'"}, {"location": {"col": 11, "file": 0, "line": 6777}, "message": "Returning from 'decode_compound_hdr'"}, {"location": {"col": 17, "file": 0, "line": 6778}, "message": "Assigned value is garbage or undefined"}, {"location": {"col": 17, "file": 0, "line": 6778}, "message": "Assigned value is garbage or undefined"}], "macros": [], "notes": [], "path": "/src/fs/nfs/nfs4xdr.c", "reportHash": "a80b8e11f7bb6f82d9b7994cba49bc91", "checkerName": "clang-analyzer-core.uninitialized.Assign", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
