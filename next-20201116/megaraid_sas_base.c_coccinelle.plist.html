<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/scsi/megaraid/megaraid_sas_base.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  Linux MegaRAID driver for SAS based RAID controllers\n *\n *  Copyright (c) 2003-2013  LSI Corporation\n *  Copyright (c) 2013-2016  Avago Technologies\n *  Copyright (c) 2016-2018  Broadcom Inc.\n *\n *  Authors: Broadcom Inc.\n *           Sreenivas Bagalkote\n *           Sumant Patro\n *           Bo Yang\n *           Adam Radford\n *           Kashyap Desai <kashyap.desai@broadcom.com>\n *           Sumit Saxena <sumit.saxena@broadcom.com>\n *\n *  Send feedback to: megaraidlinux.pdl@broadcom.com\n */\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/uio.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <asm/unaligned.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/vmalloc.h>\n#include <linux/irq_poll.h>\n#include <linux/blk-mq-pci.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_dbg.h>\n#include \"megaraid_sas_fusion.h\"\n#include \"megaraid_sas.h\"\n\n/*\n * Number of sectors per IO command\n * Will be set in megasas_init_mfi if user does not provide\n */\nstatic unsigned int max_sectors;\nmodule_param_named(max_sectors, max_sectors, int, 0444);\nMODULE_PARM_DESC(max_sectors,\n\t\"Maximum number of sectors per IO command\");\n\nstatic int msix_disable;\nmodule_param(msix_disable, int, 0444);\nMODULE_PARM_DESC(msix_disable, \"Disable MSI-X interrupt handling. Default: 0\");\n\nstatic unsigned int msix_vectors;\nmodule_param(msix_vectors, int, 0444);\nMODULE_PARM_DESC(msix_vectors, \"MSI-X max vector count. Default: Set by FW\");\n\nstatic int allow_vf_ioctls;\nmodule_param(allow_vf_ioctls, int, 0444);\nMODULE_PARM_DESC(allow_vf_ioctls, \"Allow ioctls in SR-IOV VF mode. Default: 0\");\n\nstatic unsigned int throttlequeuedepth = MEGASAS_THROTTLE_QUEUE_DEPTH;\nmodule_param(throttlequeuedepth, int, 0444);\nMODULE_PARM_DESC(throttlequeuedepth,\n\t\"Adapter queue depth when throttled due to I/O timeout. Default: 16\");\n\nunsigned int resetwaittime = MEGASAS_RESET_WAIT_TIME;\nmodule_param(resetwaittime, int, 0444);\nMODULE_PARM_DESC(resetwaittime, \"Wait time in (1-180s) after I/O timeout before resetting adapter. Default: 180s\");\n\nstatic int smp_affinity_enable = 1;\nmodule_param(smp_affinity_enable, int, 0444);\nMODULE_PARM_DESC(smp_affinity_enable, \"SMP affinity feature enable/disable Default: enable(1)\");\n\nstatic int rdpq_enable = 1;\nmodule_param(rdpq_enable, int, 0444);\nMODULE_PARM_DESC(rdpq_enable, \"Allocate reply queue in chunks for large queue depth enable/disable Default: enable(1)\");\n\nunsigned int dual_qdepth_disable;\nmodule_param(dual_qdepth_disable, int, 0444);\nMODULE_PARM_DESC(dual_qdepth_disable, \"Disable dual queue depth feature. Default: 0\");\n\nstatic unsigned int scmd_timeout = MEGASAS_DEFAULT_CMD_TIMEOUT;\nmodule_param(scmd_timeout, int, 0444);\nMODULE_PARM_DESC(scmd_timeout, \"scsi command timeout (10-90s), default 90s. See megasas_reset_timer.\");\n\nint perf_mode = -1;\nmodule_param(perf_mode, int, 0444);\nMODULE_PARM_DESC(perf_mode, \"Performance mode (only for Aero adapters), options:\\n\\t\\t\"\n\t\t\"0 - balanced: High iops and low latency queues are allocated &\\n\\t\\t\"\n\t\t\"interrupt coalescing is enabled only on high iops queues\\n\\t\\t\"\n\t\t\"1 - iops: High iops queues are not allocated &\\n\\t\\t\"\n\t\t\"interrupt coalescing is enabled on all queues\\n\\t\\t\"\n\t\t\"2 - latency: High iops queues are not allocated &\\n\\t\\t\"\n\t\t\"interrupt coalescing is disabled on all queues\\n\\t\\t\"\n\t\t\"default mode is 'balanced'\"\n\t\t);\n\nint event_log_level = MFI_EVT_CLASS_CRITICAL;\nmodule_param(event_log_level, int, 0644);\nMODULE_PARM_DESC(event_log_level, \"Asynchronous event logging level- range is: -2(CLASS_DEBUG) to 4(CLASS_DEAD), Default: 2(CLASS_CRITICAL)\");\n\nunsigned int enable_sdev_max_qd;\nmodule_param(enable_sdev_max_qd, int, 0444);\nMODULE_PARM_DESC(enable_sdev_max_qd, \"Enable sdev max qd as can_queue. Default: 0\");\n\nint host_tagset_enable = 1;\nmodule_param(host_tagset_enable, int, 0444);\nMODULE_PARM_DESC(host_tagset_enable, \"Shared host tagset enable/disable Default: enable(1)\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(MEGASAS_VERSION);\nMODULE_AUTHOR(\"megaraidlinux.pdl@broadcom.com\");\nMODULE_DESCRIPTION(\"Broadcom MegaRAID SAS Driver\");\n\nint megasas_transition_to_ready(struct megasas_instance *instance, int ocr);\nstatic int megasas_get_pd_list(struct megasas_instance *instance);\nstatic int megasas_ld_list_query(struct megasas_instance *instance,\n\t\t\t\t u8 query_type);\nstatic int megasas_issue_init_mfi(struct megasas_instance *instance);\nstatic int megasas_register_aen(struct megasas_instance *instance,\n\t\t\t\tu32 seq_num, u32 class_locale_word);\nstatic void megasas_get_pd_info(struct megasas_instance *instance,\n\t\t\t\tstruct scsi_device *sdev);\n\n/*\n * PCI ID table for all supported controllers\n */\nstatic struct pci_device_id megasas_pci_table[] = {\n\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS1064R)},\n\t/* xscale IOP */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS1078R)},\n\t/* ppc IOP */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS1078DE)},\n\t/* ppc IOP */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS1078GEN2)},\n\t/* gen2*/\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS0079GEN2)},\n\t/* gen2*/\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS0073SKINNY)},\n\t/* skinny*/\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS0071SKINNY)},\n\t/* skinny*/\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_VERDE_ZCR)},\n\t/* xscale IOP, vega */\n\t{PCI_DEVICE(PCI_VENDOR_ID_DELL, PCI_DEVICE_ID_DELL_PERC5)},\n\t/* xscale IOP */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_FUSION)},\n\t/* Fusion */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_PLASMA)},\n\t/* Plasma */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_INVADER)},\n\t/* Invader */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_FURY)},\n\t/* Fury */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_INTRUDER)},\n\t/* Intruder */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_INTRUDER_24)},\n\t/* Intruder 24 port*/\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_CUTLASS_52)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_CUTLASS_53)},\n\t/* VENTURA */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_VENTURA)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_CRUSADER)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_HARPOON)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_TOMCAT)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_VENTURA_4PORT)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_CRUSADER_4PORT)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E1)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E2)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E5)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E6)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E0)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E3)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E4)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E7)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, megasas_pci_table);\n\nstatic int megasas_mgmt_majorno;\nstruct megasas_mgmt_info megasas_mgmt_info;\nstatic struct fasync_struct *megasas_async_queue;\nstatic DEFINE_MUTEX(megasas_async_queue_mutex);\n\nstatic int megasas_poll_wait_aen;\nstatic DECLARE_WAIT_QUEUE_HEAD(megasas_poll_wait);\nstatic u32 support_poll_for_event;\nu32 megasas_dbg_lvl;\nstatic u32 support_device_change;\nstatic bool support_nvme_encapsulation;\nstatic bool support_pci_lane_margining;\n\n/* define lock for aen poll */\nstatic spinlock_t poll_aen_lock;\n\nextern struct dentry *megasas_debugfs_root;\n\nvoid\nmegasas_complete_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd,\n\t\t     u8 alt_status);\nstatic u32\nmegasas_read_fw_status_reg_gen2(struct megasas_instance *instance);\nstatic int\nmegasas_adp_reset_gen2(struct megasas_instance *instance,\n\t\t       struct megasas_register_set __iomem *reg_set);\nstatic irqreturn_t megasas_isr(int irq, void *devp);\nstatic u32\nmegasas_init_adapter_mfi(struct megasas_instance *instance);\nu32\nmegasas_build_and_issue_cmd(struct megasas_instance *instance,\n\t\t\t    struct scsi_cmnd *scmd);\nstatic void megasas_complete_cmd_dpc(unsigned long instance_addr);\nint\nwait_and_poll(struct megasas_instance *instance, struct megasas_cmd *cmd,\n\tint seconds);\nvoid megasas_fusion_ocr_wq(struct work_struct *work);\nstatic int megasas_get_ld_vf_affiliation(struct megasas_instance *instance,\n\t\t\t\t\t int initial);\nstatic int\nmegasas_set_dma_mask(struct megasas_instance *instance);\nstatic int\nmegasas_alloc_ctrl_mem(struct megasas_instance *instance);\nstatic inline void\nmegasas_free_ctrl_mem(struct megasas_instance *instance);\nstatic inline int\nmegasas_alloc_ctrl_dma_buffers(struct megasas_instance *instance);\nstatic inline void\nmegasas_free_ctrl_dma_buffers(struct megasas_instance *instance);\nstatic inline void\nmegasas_init_ctrl_params(struct megasas_instance *instance);\n\nu32 megasas_readl(struct megasas_instance *instance,\n\t\t  const volatile void __iomem *addr)\n{\n\tu32 i = 0, ret_val;\n\t/*\n\t * Due to a HW errata in Aero controllers, reads to certain\n\t * Fusion registers could intermittently return all zeroes.\n\t * This behavior is transient in nature and subsequent reads will\n\t * return valid value. As a workaround in driver, retry readl for\n\t * upto three times until a non-zero value is read.\n\t */\n\tif (instance->adapter_type == AERO_SERIES) {\n\t\tdo {\n\t\t\tret_val = readl(addr);\n\t\t\ti++;\n\t\t} while (ret_val == 0 && i < 3);\n\t\treturn ret_val;\n\t} else {\n\t\treturn readl(addr);\n\t}\n}\n\n/**\n * megasas_set_dma_settings -\tPopulate DMA address, length and flags for DCMDs\n * @instance:\t\t\tAdapter soft state\n * @dcmd:\t\t\tDCMD frame inside MFI command\n * @dma_addr:\t\t\tDMA address of buffer to be passed to FW\n * @dma_len:\t\t\tLength of DMA buffer to be passed to FW\n * @return:\t\t\tvoid\n */\nvoid megasas_set_dma_settings(struct megasas_instance *instance,\n\t\t\t      struct megasas_dcmd_frame *dcmd,\n\t\t\t      dma_addr_t dma_addr, u32 dma_len)\n{\n\tif (instance->consistent_mask_64bit) {\n\t\tdcmd->sgl.sge64[0].phys_addr = cpu_to_le64(dma_addr);\n\t\tdcmd->sgl.sge64[0].length = cpu_to_le32(dma_len);\n\t\tdcmd->flags = cpu_to_le16(dcmd->flags | MFI_FRAME_SGL64);\n\n\t} else {\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\t\tcpu_to_le32(lower_32_bits(dma_addr));\n\t\tdcmd->sgl.sge32[0].length = cpu_to_le32(dma_len);\n\t\tdcmd->flags = cpu_to_le16(dcmd->flags);\n\t}\n}\n\nstatic void\nmegasas_issue_dcmd(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n\tinstance->instancet->fire_cmd(instance,\n\t\tcmd->frame_phys_addr, 0, instance->reg_set);\n\treturn;\n}\n\n/**\n * megasas_get_cmd -\tGet a command from the free pool\n * @instance:\t\tAdapter soft state\n *\n * Returns a free command from the pool\n */\nstruct megasas_cmd *megasas_get_cmd(struct megasas_instance\n\t\t\t\t\t\t  *instance)\n{\n\tunsigned long flags;\n\tstruct megasas_cmd *cmd = NULL;\n\n\tspin_lock_irqsave(&instance->mfi_pool_lock, flags);\n\n\tif (!list_empty(&instance->cmd_pool)) {\n\t\tcmd = list_entry((&instance->cmd_pool)->next,\n\t\t\t\t struct megasas_cmd, list);\n\t\tlist_del_init(&cmd->list);\n\t} else {\n\t\tdev_err(&instance->pdev->dev, \"Command pool empty!\\n\");\n\t}\n\n\tspin_unlock_irqrestore(&instance->mfi_pool_lock, flags);\n\treturn cmd;\n}\n\n/**\n * megasas_return_cmd -\tReturn a cmd to free command pool\n * @instance:\t\tAdapter soft state\n * @cmd:\t\tCommand packet to be returned to free command pool\n */\nvoid\nmegasas_return_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n\tunsigned long flags;\n\tu32 blk_tags;\n\tstruct megasas_cmd_fusion *cmd_fusion;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\n\t/* This flag is used only for fusion adapter.\n\t * Wait for Interrupt for Polled mode DCMD\n\t */\n\tif (cmd->flags & DRV_DCMD_POLLED_MODE)\n\t\treturn;\n\n\tspin_lock_irqsave(&instance->mfi_pool_lock, flags);\n\n\tif (fusion) {\n\t\tblk_tags = instance->max_scsi_cmds + cmd->index;\n\t\tcmd_fusion = fusion->cmd_list[blk_tags];\n\t\tmegasas_return_cmd_fusion(instance, cmd_fusion);\n\t}\n\tcmd->scmd = NULL;\n\tcmd->frame_count = 0;\n\tcmd->flags = 0;\n\tmemset(cmd->frame, 0, instance->mfi_frame_size);\n\tcmd->frame->io.context = cpu_to_le32(cmd->index);\n\tif (!fusion && reset_devices)\n\t\tcmd->frame->hdr.cmd = MFI_CMD_INVALID;\n\tlist_add(&cmd->list, (&instance->cmd_pool)->next);\n\n\tspin_unlock_irqrestore(&instance->mfi_pool_lock, flags);\n\n}\n\nstatic const char *\nformat_timestamp(uint32_t timestamp)\n{\n\tstatic char buffer[32];\n\n\tif ((timestamp & 0xff000000) == 0xff000000)\n\t\tsnprintf(buffer, sizeof(buffer), \"boot + %us\", timestamp &\n\t\t0x00ffffff);\n\telse\n\t\tsnprintf(buffer, sizeof(buffer), \"%us\", timestamp);\n\treturn buffer;\n}\n\nstatic const char *\nformat_class(int8_t class)\n{\n\tstatic char buffer[6];\n\n\tswitch (class) {\n\tcase MFI_EVT_CLASS_DEBUG:\n\t\treturn \"debug\";\n\tcase MFI_EVT_CLASS_PROGRESS:\n\t\treturn \"progress\";\n\tcase MFI_EVT_CLASS_INFO:\n\t\treturn \"info\";\n\tcase MFI_EVT_CLASS_WARNING:\n\t\treturn \"WARN\";\n\tcase MFI_EVT_CLASS_CRITICAL:\n\t\treturn \"CRIT\";\n\tcase MFI_EVT_CLASS_FATAL:\n\t\treturn \"FATAL\";\n\tcase MFI_EVT_CLASS_DEAD:\n\t\treturn \"DEAD\";\n\tdefault:\n\t\tsnprintf(buffer, sizeof(buffer), \"%d\", class);\n\t\treturn buffer;\n\t}\n}\n\n/**\n  * megasas_decode_evt: Decode FW AEN event and print critical event\n  * for information.\n  * @instance:\t\t\tAdapter soft state\n  */\nstatic void\nmegasas_decode_evt(struct megasas_instance *instance)\n{\n\tstruct megasas_evt_detail *evt_detail = instance->evt_detail;\n\tunion megasas_evt_class_locale class_locale;\n\tclass_locale.word = le32_to_cpu(evt_detail->cl.word);\n\n\tif ((event_log_level < MFI_EVT_CLASS_DEBUG) ||\n\t    (event_log_level > MFI_EVT_CLASS_DEAD)) {\n\t\tprintk(KERN_WARNING \"megaraid_sas: provided event log level is out of range, setting it to default 2(CLASS_CRITICAL), permissible range is: -2 to 4\\n\");\n\t\tevent_log_level = MFI_EVT_CLASS_CRITICAL;\n\t}\n\n\tif (class_locale.members.class >= event_log_level)\n\t\tdev_info(&instance->pdev->dev, \"%d (%s/0x%04x/%s) - %s\\n\",\n\t\t\tle32_to_cpu(evt_detail->seq_num),\n\t\t\tformat_timestamp(le32_to_cpu(evt_detail->time_stamp)),\n\t\t\t(class_locale.members.locale),\n\t\t\tformat_class(class_locale.members.class),\n\t\t\tevt_detail->description);\n}\n\n/*\n * The following functions are defined for xscale\n * (deviceid : 1064R, PERC5) controllers\n */\n\n/**\n * megasas_enable_intr_xscale -\tEnables interrupts\n * @instance:\tAdapter soft state\n */\nstatic inline void\nmegasas_enable_intr_xscale(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\n\tregs = instance->reg_set;\n\twritel(0, &(regs)->outbound_intr_mask);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_disable_intr_xscale -Disables interrupt\n * @instance:\tAdapter soft state\n */\nstatic inline void\nmegasas_disable_intr_xscale(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\tu32 mask = 0x1f;\n\n\tregs = instance->reg_set;\n\twritel(mask, &regs->outbound_intr_mask);\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_read_fw_status_reg_xscale - returns the current FW status value\n * @instance:\tAdapter soft state\n */\nstatic u32\nmegasas_read_fw_status_reg_xscale(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_msg_0);\n}\n/**\n * megasas_clear_interrupt_xscale -\tCheck & clear interrupt\n * @instance:\tAdapter soft state\n */\nstatic int\nmegasas_clear_intr_xscale(struct megasas_instance *instance)\n{\n\tu32 status;\n\tu32 mfiStatus = 0;\n\tstruct megasas_register_set __iomem *regs;\n\tregs = instance->reg_set;\n\n\t/*\n\t * Check if it is our interrupt\n\t */\n\tstatus = readl(&regs->outbound_intr_status);\n\n\tif (status & MFI_OB_INTR_STATUS_MASK)\n\t\tmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\n\tif (status & MFI_XSCALE_OMR0_CHANGE_INTERRUPT)\n\t\tmfiStatus |= MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\n\n\t/*\n\t * Clear the interrupt by writing back the same value\n\t */\n\tif (mfiStatus)\n\t\twritel(status, &regs->outbound_intr_status);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_status);\n\n\treturn mfiStatus;\n}\n\n/**\n * megasas_fire_cmd_xscale -\tSends command to the FW\n * @instance:\t\tAdapter soft state\n * @frame_phys_addr :\tPhysical address of cmd\n * @frame_count :\tNumber of frames for the command\n * @regs :\t\tMFI register set\n */\nstatic inline void\nmegasas_fire_cmd_xscale(struct megasas_instance *instance,\n\t\tdma_addr_t frame_phys_addr,\n\t\tu32 frame_count,\n\t\tstruct megasas_register_set __iomem *regs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\twritel((frame_phys_addr >> 3)|(frame_count),\n\t       &(regs)->inbound_queue_port);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n}\n\n/**\n * megasas_adp_reset_xscale -  For controller reset\n * @instance:\tAdapter soft state\n * @regs:\tMFI register set\n */\nstatic int\nmegasas_adp_reset_xscale(struct megasas_instance *instance,\n\tstruct megasas_register_set __iomem *regs)\n{\n\tu32 i;\n\tu32 pcidata;\n\n\twritel(MFI_ADP_RESET, &regs->inbound_doorbell);\n\n\tfor (i = 0; i < 3; i++)\n\t\tmsleep(1000); /* sleep for 3 secs */\n\tpcidata  = 0;\n\tpci_read_config_dword(instance->pdev, MFI_1068_PCSR_OFFSET, &pcidata);\n\tdev_notice(&instance->pdev->dev, \"pcidata = %x\\n\", pcidata);\n\tif (pcidata & 0x2) {\n\t\tdev_notice(&instance->pdev->dev, \"mfi 1068 offset read=%x\\n\", pcidata);\n\t\tpcidata &= ~0x2;\n\t\tpci_write_config_dword(instance->pdev,\n\t\t\t\tMFI_1068_PCSR_OFFSET, pcidata);\n\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tmsleep(1000); /* need to wait 2 secs again */\n\n\t\tpcidata  = 0;\n\t\tpci_read_config_dword(instance->pdev,\n\t\t\t\tMFI_1068_FW_HANDSHAKE_OFFSET, &pcidata);\n\t\tdev_notice(&instance->pdev->dev, \"1068 offset handshake read=%x\\n\", pcidata);\n\t\tif ((pcidata & 0xffff0000) == MFI_1068_FW_READY) {\n\t\t\tdev_notice(&instance->pdev->dev, \"1068 offset pcidt=%x\\n\", pcidata);\n\t\t\tpcidata = 0;\n\t\t\tpci_write_config_dword(instance->pdev,\n\t\t\t\tMFI_1068_FW_HANDSHAKE_OFFSET, pcidata);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * megasas_check_reset_xscale -\tFor controller reset check\n * @instance:\tAdapter soft state\n * @regs:\tMFI register set\n */\nstatic int\nmegasas_check_reset_xscale(struct megasas_instance *instance,\n\t\tstruct megasas_register_set __iomem *regs)\n{\n\tif ((atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) &&\n\t    (le32_to_cpu(*instance->consumer) ==\n\t\tMEGASAS_ADPRESET_INPROG_SIGN))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic struct megasas_instance_template megasas_instance_template_xscale = {\n\n\t.fire_cmd = megasas_fire_cmd_xscale,\n\t.enable_intr = megasas_enable_intr_xscale,\n\t.disable_intr = megasas_disable_intr_xscale,\n\t.clear_intr = megasas_clear_intr_xscale,\n\t.read_fw_status_reg = megasas_read_fw_status_reg_xscale,\n\t.adp_reset = megasas_adp_reset_xscale,\n\t.check_reset = megasas_check_reset_xscale,\n\t.service_isr = megasas_isr,\n\t.tasklet = megasas_complete_cmd_dpc,\n\t.init_adapter = megasas_init_adapter_mfi,\n\t.build_and_issue_cmd = megasas_build_and_issue_cmd,\n\t.issue_dcmd = megasas_issue_dcmd,\n};\n\n/*\n * This is the end of set of functions & definitions specific\n * to xscale (deviceid : 1064R, PERC5) controllers\n */\n\n/*\n * The following functions are defined for ppc (deviceid : 0x60)\n * controllers\n */\n\n/**\n * megasas_enable_intr_ppc -\tEnables interrupts\n * @instance:\tAdapter soft state\n */\nstatic inline void\nmegasas_enable_intr_ppc(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\n\tregs = instance->reg_set;\n\twritel(0xFFFFFFFF, &(regs)->outbound_doorbell_clear);\n\n\twritel(~0x80000000, &(regs)->outbound_intr_mask);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_disable_intr_ppc -\tDisable interrupt\n * @instance:\tAdapter soft state\n */\nstatic inline void\nmegasas_disable_intr_ppc(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\tu32 mask = 0xFFFFFFFF;\n\n\tregs = instance->reg_set;\n\twritel(mask, &regs->outbound_intr_mask);\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_read_fw_status_reg_ppc - returns the current FW status value\n * @instance:\tAdapter soft state\n */\nstatic u32\nmegasas_read_fw_status_reg_ppc(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_scratch_pad_0);\n}\n\n/**\n * megasas_clear_interrupt_ppc -\tCheck & clear interrupt\n * @instance:\tAdapter soft state\n */\nstatic int\nmegasas_clear_intr_ppc(struct megasas_instance *instance)\n{\n\tu32 status, mfiStatus = 0;\n\tstruct megasas_register_set __iomem *regs;\n\tregs = instance->reg_set;\n\n\t/*\n\t * Check if it is our interrupt\n\t */\n\tstatus = readl(&regs->outbound_intr_status);\n\n\tif (status & MFI_REPLY_1078_MESSAGE_INTERRUPT)\n\t\tmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\n\n\tif (status & MFI_G2_OUTBOUND_DOORBELL_CHANGE_INTERRUPT)\n\t\tmfiStatus |= MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\n\n\t/*\n\t * Clear the interrupt by writing back the same value\n\t */\n\twritel(status, &regs->outbound_doorbell_clear);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_doorbell_clear);\n\n\treturn mfiStatus;\n}\n\n/**\n * megasas_fire_cmd_ppc -\tSends command to the FW\n * @instance:\t\tAdapter soft state\n * @frame_phys_addr:\tPhysical address of cmd\n * @frame_count:\tNumber of frames for the command\n * @regs:\t\tMFI register set\n */\nstatic inline void\nmegasas_fire_cmd_ppc(struct megasas_instance *instance,\n\t\tdma_addr_t frame_phys_addr,\n\t\tu32 frame_count,\n\t\tstruct megasas_register_set __iomem *regs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\twritel((frame_phys_addr | (frame_count<<1))|1,\n\t\t\t&(regs)->inbound_queue_port);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n}\n\n/**\n * megasas_check_reset_ppc -\tFor controller reset check\n * @instance:\tAdapter soft state\n * @regs:\tMFI register set\n */\nstatic int\nmegasas_check_reset_ppc(struct megasas_instance *instance,\n\t\t\tstruct megasas_register_set __iomem *regs)\n{\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct megasas_instance_template megasas_instance_template_ppc = {\n\n\t.fire_cmd = megasas_fire_cmd_ppc,\n\t.enable_intr = megasas_enable_intr_ppc,\n\t.disable_intr = megasas_disable_intr_ppc,\n\t.clear_intr = megasas_clear_intr_ppc,\n\t.read_fw_status_reg = megasas_read_fw_status_reg_ppc,\n\t.adp_reset = megasas_adp_reset_xscale,\n\t.check_reset = megasas_check_reset_ppc,\n\t.service_isr = megasas_isr,\n\t.tasklet = megasas_complete_cmd_dpc,\n\t.init_adapter = megasas_init_adapter_mfi,\n\t.build_and_issue_cmd = megasas_build_and_issue_cmd,\n\t.issue_dcmd = megasas_issue_dcmd,\n};\n\n/**\n * megasas_enable_intr_skinny -\tEnables interrupts\n * @instance:\tAdapter soft state\n */\nstatic inline void\nmegasas_enable_intr_skinny(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\n\tregs = instance->reg_set;\n\twritel(0xFFFFFFFF, &(regs)->outbound_intr_mask);\n\n\twritel(~MFI_SKINNY_ENABLE_INTERRUPT_MASK, &(regs)->outbound_intr_mask);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_disable_intr_skinny -\tDisables interrupt\n * @instance:\tAdapter soft state\n */\nstatic inline void\nmegasas_disable_intr_skinny(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\tu32 mask = 0xFFFFFFFF;\n\n\tregs = instance->reg_set;\n\twritel(mask, &regs->outbound_intr_mask);\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_read_fw_status_reg_skinny - returns the current FW status value\n * @instance:\tAdapter soft state\n */\nstatic u32\nmegasas_read_fw_status_reg_skinny(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_scratch_pad_0);\n}\n\n/**\n * megasas_clear_interrupt_skinny -\tCheck & clear interrupt\n * @instance:\tAdapter soft state\n */\nstatic int\nmegasas_clear_intr_skinny(struct megasas_instance *instance)\n{\n\tu32 status;\n\tu32 mfiStatus = 0;\n\tstruct megasas_register_set __iomem *regs;\n\tregs = instance->reg_set;\n\n\t/*\n\t * Check if it is our interrupt\n\t */\n\tstatus = readl(&regs->outbound_intr_status);\n\n\tif (!(status & MFI_SKINNY_ENABLE_INTERRUPT_MASK)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check if it is our interrupt\n\t */\n\tif ((megasas_read_fw_status_reg_skinny(instance) & MFI_STATE_MASK) ==\n\t    MFI_STATE_FAULT) {\n\t\tmfiStatus = MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\n\t} else\n\t\tmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\n\n\t/*\n\t * Clear the interrupt by writing back the same value\n\t */\n\twritel(status, &regs->outbound_intr_status);\n\n\t/*\n\t * dummy read to flush PCI\n\t */\n\treadl(&regs->outbound_intr_status);\n\n\treturn mfiStatus;\n}\n\n/**\n * megasas_fire_cmd_skinny -\tSends command to the FW\n * @instance:\t\tAdapter soft state\n * @frame_phys_addr:\tPhysical address of cmd\n * @frame_count:\tNumber of frames for the command\n * @regs:\t\tMFI register set\n */\nstatic inline void\nmegasas_fire_cmd_skinny(struct megasas_instance *instance,\n\t\t\tdma_addr_t frame_phys_addr,\n\t\t\tu32 frame_count,\n\t\t\tstruct megasas_register_set __iomem *regs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\twritel(upper_32_bits(frame_phys_addr),\n\t       &(regs)->inbound_high_queue_port);\n\twritel((lower_32_bits(frame_phys_addr) | (frame_count<<1))|1,\n\t       &(regs)->inbound_low_queue_port);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n}\n\n/**\n * megasas_check_reset_skinny -\tFor controller reset check\n * @instance:\tAdapter soft state\n * @regs:\tMFI register set\n */\nstatic int\nmegasas_check_reset_skinny(struct megasas_instance *instance,\n\t\t\t\tstruct megasas_register_set __iomem *regs)\n{\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct megasas_instance_template megasas_instance_template_skinny = {\n\n\t.fire_cmd = megasas_fire_cmd_skinny,\n\t.enable_intr = megasas_enable_intr_skinny,\n\t.disable_intr = megasas_disable_intr_skinny,\n\t.clear_intr = megasas_clear_intr_skinny,\n\t.read_fw_status_reg = megasas_read_fw_status_reg_skinny,\n\t.adp_reset = megasas_adp_reset_gen2,\n\t.check_reset = megasas_check_reset_skinny,\n\t.service_isr = megasas_isr,\n\t.tasklet = megasas_complete_cmd_dpc,\n\t.init_adapter = megasas_init_adapter_mfi,\n\t.build_and_issue_cmd = megasas_build_and_issue_cmd,\n\t.issue_dcmd = megasas_issue_dcmd,\n};\n\n\n/*\n * The following functions are defined for gen2 (deviceid : 0x78 0x79)\n * controllers\n */\n\n/**\n * megasas_enable_intr_gen2 -  Enables interrupts\n * @instance:\tAdapter soft state\n */\nstatic inline void\nmegasas_enable_intr_gen2(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\n\tregs = instance->reg_set;\n\twritel(0xFFFFFFFF, &(regs)->outbound_doorbell_clear);\n\n\t/* write ~0x00000005 (4 & 1) to the intr mask*/\n\twritel(~MFI_GEN2_ENABLE_INTERRUPT_MASK, &(regs)->outbound_intr_mask);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_disable_intr_gen2 - Disables interrupt\n * @instance:\tAdapter soft state\n */\nstatic inline void\nmegasas_disable_intr_gen2(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\tu32 mask = 0xFFFFFFFF;\n\n\tregs = instance->reg_set;\n\twritel(mask, &regs->outbound_intr_mask);\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_read_fw_status_reg_gen2 - returns the current FW status value\n * @instance:\tAdapter soft state\n */\nstatic u32\nmegasas_read_fw_status_reg_gen2(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_scratch_pad_0);\n}\n\n/**\n * megasas_clear_interrupt_gen2 -      Check & clear interrupt\n * @instance:\tAdapter soft state\n */\nstatic int\nmegasas_clear_intr_gen2(struct megasas_instance *instance)\n{\n\tu32 status;\n\tu32 mfiStatus = 0;\n\tstruct megasas_register_set __iomem *regs;\n\tregs = instance->reg_set;\n\n\t/*\n\t * Check if it is our interrupt\n\t */\n\tstatus = readl(&regs->outbound_intr_status);\n\n\tif (status & MFI_INTR_FLAG_REPLY_MESSAGE) {\n\t\tmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\n\t}\n\tif (status & MFI_G2_OUTBOUND_DOORBELL_CHANGE_INTERRUPT) {\n\t\tmfiStatus |= MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\n\t}\n\n\t/*\n\t * Clear the interrupt by writing back the same value\n\t */\n\tif (mfiStatus)\n\t\twritel(status, &regs->outbound_doorbell_clear);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_status);\n\n\treturn mfiStatus;\n}\n\n/**\n * megasas_fire_cmd_gen2 -     Sends command to the FW\n * @instance:\t\tAdapter soft state\n * @frame_phys_addr:\tPhysical address of cmd\n * @frame_count:\tNumber of frames for the command\n * @regs:\t\tMFI register set\n */\nstatic inline void\nmegasas_fire_cmd_gen2(struct megasas_instance *instance,\n\t\t\tdma_addr_t frame_phys_addr,\n\t\t\tu32 frame_count,\n\t\t\tstruct megasas_register_set __iomem *regs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\twritel((frame_phys_addr | (frame_count<<1))|1,\n\t\t\t&(regs)->inbound_queue_port);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n}\n\n/**\n * megasas_adp_reset_gen2 -\tFor controller reset\n * @instance:\tAdapter soft state\n * @reg_set:\tMFI register set\n */\nstatic int\nmegasas_adp_reset_gen2(struct megasas_instance *instance,\n\t\t\tstruct megasas_register_set __iomem *reg_set)\n{\n\tu32 retry = 0 ;\n\tu32 HostDiag;\n\tu32 __iomem *seq_offset = &reg_set->seq_offset;\n\tu32 __iomem *hostdiag_offset = &reg_set->host_diag;\n\n\tif (instance->instancet == &megasas_instance_template_skinny) {\n\t\tseq_offset = &reg_set->fusion_seq_offset;\n\t\thostdiag_offset = &reg_set->fusion_host_diag;\n\t}\n\n\twritel(0, seq_offset);\n\twritel(4, seq_offset);\n\twritel(0xb, seq_offset);\n\twritel(2, seq_offset);\n\twritel(7, seq_offset);\n\twritel(0xd, seq_offset);\n\n\tmsleep(1000);\n\n\tHostDiag = (u32)readl(hostdiag_offset);\n\n\twhile (!(HostDiag & DIAG_WRITE_ENABLE)) {\n\t\tmsleep(100);\n\t\tHostDiag = (u32)readl(hostdiag_offset);\n\t\tdev_notice(&instance->pdev->dev, \"RESETGEN2: retry=%x, hostdiag=%x\\n\",\n\t\t\t\t\tretry, HostDiag);\n\n\t\tif (retry++ >= 100)\n\t\t\treturn 1;\n\n\t}\n\n\tdev_notice(&instance->pdev->dev, \"ADP_RESET_GEN2: HostDiag=%x\\n\", HostDiag);\n\n\twritel((HostDiag | DIAG_RESET_ADAPTER), hostdiag_offset);\n\n\tssleep(10);\n\n\tHostDiag = (u32)readl(hostdiag_offset);\n\twhile (HostDiag & DIAG_RESET_ADAPTER) {\n\t\tmsleep(100);\n\t\tHostDiag = (u32)readl(hostdiag_offset);\n\t\tdev_notice(&instance->pdev->dev, \"RESET_GEN2: retry=%x, hostdiag=%x\\n\",\n\t\t\t\tretry, HostDiag);\n\n\t\tif (retry++ >= 1000)\n\t\t\treturn 1;\n\n\t}\n\treturn 0;\n}\n\n/**\n * megasas_check_reset_gen2 -\tFor controller reset check\n * @instance:\tAdapter soft state\n * @regs:\tMFI register set\n */\nstatic int\nmegasas_check_reset_gen2(struct megasas_instance *instance,\n\t\tstruct megasas_register_set __iomem *regs)\n{\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct megasas_instance_template megasas_instance_template_gen2 = {\n\n\t.fire_cmd = megasas_fire_cmd_gen2,\n\t.enable_intr = megasas_enable_intr_gen2,\n\t.disable_intr = megasas_disable_intr_gen2,\n\t.clear_intr = megasas_clear_intr_gen2,\n\t.read_fw_status_reg = megasas_read_fw_status_reg_gen2,\n\t.adp_reset = megasas_adp_reset_gen2,\n\t.check_reset = megasas_check_reset_gen2,\n\t.service_isr = megasas_isr,\n\t.tasklet = megasas_complete_cmd_dpc,\n\t.init_adapter = megasas_init_adapter_mfi,\n\t.build_and_issue_cmd = megasas_build_and_issue_cmd,\n\t.issue_dcmd = megasas_issue_dcmd,\n};\n\n/*\n * This is the end of set of functions & definitions\n * specific to gen2 (deviceid : 0x78, 0x79) controllers\n */\n\n/*\n * Template added for TB (Fusion)\n */\nextern struct megasas_instance_template megasas_instance_template_fusion;\n\n/**\n * megasas_issue_polled -\tIssues a polling command\n * @instance:\t\t\tAdapter soft state\n * @cmd:\t\t\tCommand packet to be issued\n *\n * For polling, MFI requires the cmd_status to be set to MFI_STAT_INVALID_STATUS before posting.\n */\nint\nmegasas_issue_polled(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n\tstruct megasas_header *frame_hdr = &cmd->frame->hdr;\n\n\tframe_hdr->cmd_status = MFI_STAT_INVALID_STATUS;\n\tframe_hdr->flags |= cpu_to_le16(MFI_FRAME_DONT_POST_IN_REPLY_QUEUE);\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn DCMD_INIT;\n\t}\n\n\tinstance->instancet->issue_dcmd(instance, cmd);\n\n\treturn wait_and_poll(instance, cmd, instance->requestorId ?\n\t\t\tMEGASAS_ROUTINE_WAIT_TIME_VF : MFI_IO_TIMEOUT_SECS);\n}\n\n/**\n * megasas_issue_blocked_cmd -\tSynchronous wrapper around regular FW cmds\n * @instance:\t\t\tAdapter soft state\n * @cmd:\t\t\tCommand to be issued\n * @timeout:\t\t\tTimeout in seconds\n *\n * This function waits on an event for the command to be returned from ISR.\n * Max wait time is MEGASAS_INTERNAL_CMD_WAIT_TIME secs\n * Used to issue ioctl commands.\n */\nint\nmegasas_issue_blocked_cmd(struct megasas_instance *instance,\n\t\t\t  struct megasas_cmd *cmd, int timeout)\n{\n\tint ret = 0;\n\tcmd->cmd_status_drv = DCMD_INIT;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn DCMD_INIT;\n\t}\n\n\tinstance->instancet->issue_dcmd(instance, cmd);\n\n\tif (timeout) {\n\t\tret = wait_event_timeout(instance->int_cmd_wait_q,\n\t\tcmd->cmd_status_drv != DCMD_INIT, timeout * HZ);\n\t\tif (!ret) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"DCMD(opcode: 0x%x) is timed out, func:%s\\n\",\n\t\t\t\tcmd->frame->dcmd.opcode, __func__);\n\t\t\treturn DCMD_TIMEOUT;\n\t\t}\n\t} else\n\t\twait_event(instance->int_cmd_wait_q,\n\t\t\t\tcmd->cmd_status_drv != DCMD_INIT);\n\n\treturn cmd->cmd_status_drv;\n}\n\n/**\n * megasas_issue_blocked_abort_cmd -\tAborts previously issued cmd\n * @instance:\t\t\t\tAdapter soft state\n * @cmd_to_abort:\t\t\tPreviously issued cmd to be aborted\n * @timeout:\t\t\t\tTimeout in seconds\n *\n * MFI firmware can abort previously issued AEN comamnd (automatic event\n * notification). The megasas_issue_blocked_abort_cmd() issues such abort\n * cmd and waits for return status.\n * Max wait time is MEGASAS_INTERNAL_CMD_WAIT_TIME secs\n */\nstatic int\nmegasas_issue_blocked_abort_cmd(struct megasas_instance *instance,\n\t\t\t\tstruct megasas_cmd *cmd_to_abort, int timeout)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_abort_frame *abort_fr;\n\tint ret = 0;\n\tu32 opcode;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd)\n\t\treturn -1;\n\n\tabort_fr = &cmd->frame->abort;\n\n\t/*\n\t * Prepare and issue the abort frame\n\t */\n\tabort_fr->cmd = MFI_CMD_ABORT;\n\tabort_fr->cmd_status = MFI_STAT_INVALID_STATUS;\n\tabort_fr->flags = cpu_to_le16(0);\n\tabort_fr->abort_context = cpu_to_le32(cmd_to_abort->index);\n\tabort_fr->abort_mfi_phys_addr_lo =\n\t\tcpu_to_le32(lower_32_bits(cmd_to_abort->frame_phys_addr));\n\tabort_fr->abort_mfi_phys_addr_hi =\n\t\tcpu_to_le32(upper_32_bits(cmd_to_abort->frame_phys_addr));\n\n\tcmd->sync_cmd = 1;\n\tcmd->cmd_status_drv = DCMD_INIT;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn DCMD_INIT;\n\t}\n\n\tinstance->instancet->issue_dcmd(instance, cmd);\n\n\tif (timeout) {\n\t\tret = wait_event_timeout(instance->abort_cmd_wait_q,\n\t\tcmd->cmd_status_drv != DCMD_INIT, timeout * HZ);\n\t\tif (!ret) {\n\t\t\topcode = cmd_to_abort->frame->dcmd.opcode;\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Abort(to be aborted DCMD opcode: 0x%x) is timed out func:%s\\n\",\n\t\t\t\topcode,  __func__);\n\t\t\treturn DCMD_TIMEOUT;\n\t\t}\n\t} else\n\t\twait_event(instance->abort_cmd_wait_q,\n\t\tcmd->cmd_status_drv != DCMD_INIT);\n\n\tcmd->sync_cmd = 0;\n\n\tmegasas_return_cmd(instance, cmd);\n\treturn cmd->cmd_status_drv;\n}\n\n/**\n * megasas_make_sgl32 -\tPrepares 32-bit SGL\n * @instance:\t\tAdapter soft state\n * @scp:\t\tSCSI command from the mid-layer\n * @mfi_sgl:\t\tSGL to be filled in\n *\n * If successful, this function returns the number of SG elements. Otherwise,\n * it returnes -1.\n */\nstatic int\nmegasas_make_sgl32(struct megasas_instance *instance, struct scsi_cmnd *scp,\n\t\t   union megasas_sgl *mfi_sgl)\n{\n\tint i;\n\tint sge_count;\n\tstruct scatterlist *os_sgl;\n\n\tsge_count = scsi_dma_map(scp);\n\tBUG_ON(sge_count < 0);\n\n\tif (sge_count) {\n\t\tscsi_for_each_sg(scp, os_sgl, sge_count, i) {\n\t\t\tmfi_sgl->sge32[i].length = cpu_to_le32(sg_dma_len(os_sgl));\n\t\t\tmfi_sgl->sge32[i].phys_addr = cpu_to_le32(sg_dma_address(os_sgl));\n\t\t}\n\t}\n\treturn sge_count;\n}\n\n/**\n * megasas_make_sgl64 -\tPrepares 64-bit SGL\n * @instance:\t\tAdapter soft state\n * @scp:\t\tSCSI command from the mid-layer\n * @mfi_sgl:\t\tSGL to be filled in\n *\n * If successful, this function returns the number of SG elements. Otherwise,\n * it returnes -1.\n */\nstatic int\nmegasas_make_sgl64(struct megasas_instance *instance, struct scsi_cmnd *scp,\n\t\t   union megasas_sgl *mfi_sgl)\n{\n\tint i;\n\tint sge_count;\n\tstruct scatterlist *os_sgl;\n\n\tsge_count = scsi_dma_map(scp);\n\tBUG_ON(sge_count < 0);\n\n\tif (sge_count) {\n\t\tscsi_for_each_sg(scp, os_sgl, sge_count, i) {\n\t\t\tmfi_sgl->sge64[i].length = cpu_to_le32(sg_dma_len(os_sgl));\n\t\t\tmfi_sgl->sge64[i].phys_addr = cpu_to_le64(sg_dma_address(os_sgl));\n\t\t}\n\t}\n\treturn sge_count;\n}\n\n/**\n * megasas_make_sgl_skinny - Prepares IEEE SGL\n * @instance:           Adapter soft state\n * @scp:                SCSI command from the mid-layer\n * @mfi_sgl:            SGL to be filled in\n *\n * If successful, this function returns the number of SG elements. Otherwise,\n * it returnes -1.\n */\nstatic int\nmegasas_make_sgl_skinny(struct megasas_instance *instance,\n\t\tstruct scsi_cmnd *scp, union megasas_sgl *mfi_sgl)\n{\n\tint i;\n\tint sge_count;\n\tstruct scatterlist *os_sgl;\n\n\tsge_count = scsi_dma_map(scp);\n\n\tif (sge_count) {\n\t\tscsi_for_each_sg(scp, os_sgl, sge_count, i) {\n\t\t\tmfi_sgl->sge_skinny[i].length =\n\t\t\t\tcpu_to_le32(sg_dma_len(os_sgl));\n\t\t\tmfi_sgl->sge_skinny[i].phys_addr =\n\t\t\t\tcpu_to_le64(sg_dma_address(os_sgl));\n\t\t\tmfi_sgl->sge_skinny[i].flag = cpu_to_le32(0);\n\t\t}\n\t}\n\treturn sge_count;\n}\n\n /**\n * megasas_get_frame_count - Computes the number of frames\n * @frame_type\t\t: type of frame- io or pthru frame\n * @sge_count\t\t: number of sg elements\n *\n * Returns the number of frames required for numnber of sge's (sge_count)\n */\n\nstatic u32 megasas_get_frame_count(struct megasas_instance *instance,\n\t\t\tu8 sge_count, u8 frame_type)\n{\n\tint num_cnt;\n\tint sge_bytes;\n\tu32 sge_sz;\n\tu32 frame_count = 0;\n\n\tsge_sz = (IS_DMA64) ? sizeof(struct megasas_sge64) :\n\t    sizeof(struct megasas_sge32);\n\n\tif (instance->flag_ieee) {\n\t\tsge_sz = sizeof(struct megasas_sge_skinny);\n\t}\n\n\t/*\n\t * Main frame can contain 2 SGEs for 64-bit SGLs and\n\t * 3 SGEs for 32-bit SGLs for ldio &\n\t * 1 SGEs for 64-bit SGLs and\n\t * 2 SGEs for 32-bit SGLs for pthru frame\n\t */\n\tif (unlikely(frame_type == PTHRU_FRAME)) {\n\t\tif (instance->flag_ieee == 1) {\n\t\t\tnum_cnt = sge_count - 1;\n\t\t} else if (IS_DMA64)\n\t\t\tnum_cnt = sge_count - 1;\n\t\telse\n\t\t\tnum_cnt = sge_count - 2;\n\t} else {\n\t\tif (instance->flag_ieee == 1) {\n\t\t\tnum_cnt = sge_count - 1;\n\t\t} else if (IS_DMA64)\n\t\t\tnum_cnt = sge_count - 2;\n\t\telse\n\t\t\tnum_cnt = sge_count - 3;\n\t}\n\n\tif (num_cnt > 0) {\n\t\tsge_bytes = sge_sz * num_cnt;\n\n\t\tframe_count = (sge_bytes / MEGAMFI_FRAME_SIZE) +\n\t\t    ((sge_bytes % MEGAMFI_FRAME_SIZE) ? 1 : 0) ;\n\t}\n\t/* Main frame */\n\tframe_count += 1;\n\n\tif (frame_count > 7)\n\t\tframe_count = 8;\n\treturn frame_count;\n}\n\n/**\n * megasas_build_dcdb -\tPrepares a direct cdb (DCDB) command\n * @instance:\t\tAdapter soft state\n * @scp:\t\tSCSI command\n * @cmd:\t\tCommand to be prepared in\n *\n * This function prepares CDB commands. These are typcially pass-through\n * commands to the devices.\n */\nstatic int\nmegasas_build_dcdb(struct megasas_instance *instance, struct scsi_cmnd *scp,\n\t\t   struct megasas_cmd *cmd)\n{\n\tu32 is_logical;\n\tu32 device_id;\n\tu16 flags = 0;\n\tstruct megasas_pthru_frame *pthru;\n\n\tis_logical = MEGASAS_IS_LOGICAL(scp->device);\n\tdevice_id = MEGASAS_DEV_INDEX(scp);\n\tpthru = (struct megasas_pthru_frame *)cmd->frame;\n\n\tif (scp->sc_data_direction == DMA_TO_DEVICE)\n\t\tflags = MFI_FRAME_DIR_WRITE;\n\telse if (scp->sc_data_direction == DMA_FROM_DEVICE)\n\t\tflags = MFI_FRAME_DIR_READ;\n\telse if (scp->sc_data_direction == DMA_NONE)\n\t\tflags = MFI_FRAME_DIR_NONE;\n\n\tif (instance->flag_ieee == 1) {\n\t\tflags |= MFI_FRAME_IEEE;\n\t}\n\n\t/*\n\t * Prepare the DCDB frame\n\t */\n\tpthru->cmd = (is_logical) ? MFI_CMD_LD_SCSI_IO : MFI_CMD_PD_SCSI_IO;\n\tpthru->cmd_status = 0x0;\n\tpthru->scsi_status = 0x0;\n\tpthru->target_id = device_id;\n\tpthru->lun = scp->device->lun;\n\tpthru->cdb_len = scp->cmd_len;\n\tpthru->timeout = 0;\n\tpthru->pad_0 = 0;\n\tpthru->flags = cpu_to_le16(flags);\n\tpthru->data_xfer_len = cpu_to_le32(scsi_bufflen(scp));\n\n\tmemcpy(pthru->cdb, scp->cmnd, scp->cmd_len);\n\n\t/*\n\t * If the command is for the tape device, set the\n\t * pthru timeout to the os layer timeout value.\n\t */\n\tif (scp->device->type == TYPE_TAPE) {\n\t\tif ((scp->request->timeout / HZ) > 0xFFFF)\n\t\t\tpthru->timeout = cpu_to_le16(0xFFFF);\n\t\telse\n\t\t\tpthru->timeout = cpu_to_le16(scp->request->timeout / HZ);\n\t}\n\n\t/*\n\t * Construct SGL\n\t */\n\tif (instance->flag_ieee == 1) {\n\t\tpthru->flags |= cpu_to_le16(MFI_FRAME_SGL64);\n\t\tpthru->sge_count = megasas_make_sgl_skinny(instance, scp,\n\t\t\t\t\t\t      &pthru->sgl);\n\t} else if (IS_DMA64) {\n\t\tpthru->flags |= cpu_to_le16(MFI_FRAME_SGL64);\n\t\tpthru->sge_count = megasas_make_sgl64(instance, scp,\n\t\t\t\t\t\t      &pthru->sgl);\n\t} else\n\t\tpthru->sge_count = megasas_make_sgl32(instance, scp,\n\t\t\t\t\t\t      &pthru->sgl);\n\n\tif (pthru->sge_count > instance->max_num_sge) {\n\t\tdev_err(&instance->pdev->dev, \"DCDB too many SGE NUM=%x\\n\",\n\t\t\tpthru->sge_count);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Sense info specific\n\t */\n\tpthru->sense_len = SCSI_SENSE_BUFFERSIZE;\n\tpthru->sense_buf_phys_addr_hi =\n\t\tcpu_to_le32(upper_32_bits(cmd->sense_phys_addr));\n\tpthru->sense_buf_phys_addr_lo =\n\t\tcpu_to_le32(lower_32_bits(cmd->sense_phys_addr));\n\n\t/*\n\t * Compute the total number of frames this command consumes. FW uses\n\t * this number to pull sufficient number of frames from host memory.\n\t */\n\tcmd->frame_count = megasas_get_frame_count(instance, pthru->sge_count,\n\t\t\t\t\t\t\tPTHRU_FRAME);\n\n\treturn cmd->frame_count;\n}\n\n/**\n * megasas_build_ldio -\tPrepares IOs to logical devices\n * @instance:\t\tAdapter soft state\n * @scp:\t\tSCSI command\n * @cmd:\t\tCommand to be prepared\n *\n * Frames (and accompanying SGLs) for regular SCSI IOs use this function.\n */\nstatic int\nmegasas_build_ldio(struct megasas_instance *instance, struct scsi_cmnd *scp,\n\t\t   struct megasas_cmd *cmd)\n{\n\tu32 device_id;\n\tu8 sc = scp->cmnd[0];\n\tu16 flags = 0;\n\tstruct megasas_io_frame *ldio;\n\n\tdevice_id = MEGASAS_DEV_INDEX(scp);\n\tldio = (struct megasas_io_frame *)cmd->frame;\n\n\tif (scp->sc_data_direction == DMA_TO_DEVICE)\n\t\tflags = MFI_FRAME_DIR_WRITE;\n\telse if (scp->sc_data_direction == DMA_FROM_DEVICE)\n\t\tflags = MFI_FRAME_DIR_READ;\n\n\tif (instance->flag_ieee == 1) {\n\t\tflags |= MFI_FRAME_IEEE;\n\t}\n\n\t/*\n\t * Prepare the Logical IO frame: 2nd bit is zero for all read cmds\n\t */\n\tldio->cmd = (sc & 0x02) ? MFI_CMD_LD_WRITE : MFI_CMD_LD_READ;\n\tldio->cmd_status = 0x0;\n\tldio->scsi_status = 0x0;\n\tldio->target_id = device_id;\n\tldio->timeout = 0;\n\tldio->reserved_0 = 0;\n\tldio->pad_0 = 0;\n\tldio->flags = cpu_to_le16(flags);\n\tldio->start_lba_hi = 0;\n\tldio->access_byte = (scp->cmd_len != 6) ? scp->cmnd[1] : 0;\n\n\t/*\n\t * 6-byte READ(0x08) or WRITE(0x0A) cdb\n\t */\n\tif (scp->cmd_len == 6) {\n\t\tldio->lba_count = cpu_to_le32((u32) scp->cmnd[4]);\n\t\tldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[1] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[2] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[3]);\n\n\t\tldio->start_lba_lo &= cpu_to_le32(0x1FFFFF);\n\t}\n\n\t/*\n\t * 10-byte READ(0x28) or WRITE(0x2A) cdb\n\t */\n\telse if (scp->cmd_len == 10) {\n\t\tldio->lba_count = cpu_to_le32((u32) scp->cmnd[8] |\n\t\t\t\t\t      ((u32) scp->cmnd[7] << 8));\n\t\tldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[2] << 24) |\n\t\t\t\t\t\t ((u32) scp->cmnd[3] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[4] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[5]);\n\t}\n\n\t/*\n\t * 12-byte READ(0xA8) or WRITE(0xAA) cdb\n\t */\n\telse if (scp->cmd_len == 12) {\n\t\tldio->lba_count = cpu_to_le32(((u32) scp->cmnd[6] << 24) |\n\t\t\t\t\t      ((u32) scp->cmnd[7] << 16) |\n\t\t\t\t\t      ((u32) scp->cmnd[8] << 8) |\n\t\t\t\t\t      (u32) scp->cmnd[9]);\n\n\t\tldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[2] << 24) |\n\t\t\t\t\t\t ((u32) scp->cmnd[3] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[4] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[5]);\n\t}\n\n\t/*\n\t * 16-byte READ(0x88) or WRITE(0x8A) cdb\n\t */\n\telse if (scp->cmd_len == 16) {\n\t\tldio->lba_count = cpu_to_le32(((u32) scp->cmnd[10] << 24) |\n\t\t\t\t\t      ((u32) scp->cmnd[11] << 16) |\n\t\t\t\t\t      ((u32) scp->cmnd[12] << 8) |\n\t\t\t\t\t      (u32) scp->cmnd[13]);\n\n\t\tldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[6] << 24) |\n\t\t\t\t\t\t ((u32) scp->cmnd[7] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[8] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[9]);\n\n\t\tldio->start_lba_hi = cpu_to_le32(((u32) scp->cmnd[2] << 24) |\n\t\t\t\t\t\t ((u32) scp->cmnd[3] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[4] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[5]);\n\n\t}\n\n\t/*\n\t * Construct SGL\n\t */\n\tif (instance->flag_ieee) {\n\t\tldio->flags |= cpu_to_le16(MFI_FRAME_SGL64);\n\t\tldio->sge_count = megasas_make_sgl_skinny(instance, scp,\n\t\t\t\t\t      &ldio->sgl);\n\t} else if (IS_DMA64) {\n\t\tldio->flags |= cpu_to_le16(MFI_FRAME_SGL64);\n\t\tldio->sge_count = megasas_make_sgl64(instance, scp, &ldio->sgl);\n\t} else\n\t\tldio->sge_count = megasas_make_sgl32(instance, scp, &ldio->sgl);\n\n\tif (ldio->sge_count > instance->max_num_sge) {\n\t\tdev_err(&instance->pdev->dev, \"build_ld_io: sge_count = %x\\n\",\n\t\t\tldio->sge_count);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Sense info specific\n\t */\n\tldio->sense_len = SCSI_SENSE_BUFFERSIZE;\n\tldio->sense_buf_phys_addr_hi = 0;\n\tldio->sense_buf_phys_addr_lo = cpu_to_le32(cmd->sense_phys_addr);\n\n\t/*\n\t * Compute the total number of frames this command consumes. FW uses\n\t * this number to pull sufficient number of frames from host memory.\n\t */\n\tcmd->frame_count = megasas_get_frame_count(instance,\n\t\t\tldio->sge_count, IO_FRAME);\n\n\treturn cmd->frame_count;\n}\n\n/**\n * megasas_cmd_type -\t\tChecks if the cmd is for logical drive/sysPD\n *\t\t\t\tand whether it's RW or non RW\n * @cmd:\t\t\tSCSI command\n *\n */\ninline int megasas_cmd_type(struct scsi_cmnd *cmd)\n{\n\tint ret;\n\n\tswitch (cmd->cmnd[0]) {\n\tcase READ_10:\n\tcase WRITE_10:\n\tcase READ_12:\n\tcase WRITE_12:\n\tcase READ_6:\n\tcase WRITE_6:\n\tcase READ_16:\n\tcase WRITE_16:\n\t\tret = (MEGASAS_IS_LOGICAL(cmd->device)) ?\n\t\t\tREAD_WRITE_LDIO : READ_WRITE_SYSPDIO;\n\t\tbreak;\n\tdefault:\n\t\tret = (MEGASAS_IS_LOGICAL(cmd->device)) ?\n\t\t\tNON_READ_WRITE_LDIO : NON_READ_WRITE_SYSPDIO;\n\t}\n\treturn ret;\n}\n\n /**\n * megasas_dump_pending_frames -\tDumps the frame address of all pending cmds\n *\t\t\t\t\tin FW\n * @instance:\t\t\t\tAdapter soft state\n */\nstatic inline void\nmegasas_dump_pending_frames(struct megasas_instance *instance)\n{\n\tstruct megasas_cmd *cmd;\n\tint i,n;\n\tunion megasas_sgl *mfi_sgl;\n\tstruct megasas_io_frame *ldio;\n\tstruct megasas_pthru_frame *pthru;\n\tu32 sgcount;\n\tu16 max_cmd = instance->max_fw_cmds;\n\n\tdev_err(&instance->pdev->dev, \"[%d]: Dumping Frame Phys Address of all pending cmds in FW\\n\",instance->host->host_no);\n\tdev_err(&instance->pdev->dev, \"[%d]: Total OS Pending cmds : %d\\n\",instance->host->host_no,atomic_read(&instance->fw_outstanding));\n\tif (IS_DMA64)\n\t\tdev_err(&instance->pdev->dev, \"[%d]: 64 bit SGLs were sent to FW\\n\",instance->host->host_no);\n\telse\n\t\tdev_err(&instance->pdev->dev, \"[%d]: 32 bit SGLs were sent to FW\\n\",instance->host->host_no);\n\n\tdev_err(&instance->pdev->dev, \"[%d]: Pending OS cmds in FW : \\n\",instance->host->host_no);\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tif (!cmd->scmd)\n\t\t\tcontinue;\n\t\tdev_err(&instance->pdev->dev, \"[%d]: Frame addr :0x%08lx : \",instance->host->host_no,(unsigned long)cmd->frame_phys_addr);\n\t\tif (megasas_cmd_type(cmd->scmd) == READ_WRITE_LDIO) {\n\t\t\tldio = (struct megasas_io_frame *)cmd->frame;\n\t\t\tmfi_sgl = &ldio->sgl;\n\t\t\tsgcount = ldio->sge_count;\n\t\t\tdev_err(&instance->pdev->dev, \"[%d]: frame count : 0x%x, Cmd : 0x%x, Tgt id : 0x%x,\"\n\t\t\t\" lba lo : 0x%x, lba_hi : 0x%x, sense_buf addr : 0x%x,sge count : 0x%x\\n\",\n\t\t\tinstance->host->host_no, cmd->frame_count, ldio->cmd, ldio->target_id,\n\t\t\tle32_to_cpu(ldio->start_lba_lo), le32_to_cpu(ldio->start_lba_hi),\n\t\t\tle32_to_cpu(ldio->sense_buf_phys_addr_lo), sgcount);\n\t\t} else {\n\t\t\tpthru = (struct megasas_pthru_frame *) cmd->frame;\n\t\t\tmfi_sgl = &pthru->sgl;\n\t\t\tsgcount = pthru->sge_count;\n\t\t\tdev_err(&instance->pdev->dev, \"[%d]: frame count : 0x%x, Cmd : 0x%x, Tgt id : 0x%x, \"\n\t\t\t\"lun : 0x%x, cdb_len : 0x%x, data xfer len : 0x%x, sense_buf addr : 0x%x,sge count : 0x%x\\n\",\n\t\t\tinstance->host->host_no, cmd->frame_count, pthru->cmd, pthru->target_id,\n\t\t\tpthru->lun, pthru->cdb_len, le32_to_cpu(pthru->data_xfer_len),\n\t\t\tle32_to_cpu(pthru->sense_buf_phys_addr_lo), sgcount);\n\t\t}\n\t\tif (megasas_dbg_lvl & MEGASAS_DBG_LVL) {\n\t\t\tfor (n = 0; n < sgcount; n++) {\n\t\t\t\tif (IS_DMA64)\n\t\t\t\t\tdev_err(&instance->pdev->dev, \"sgl len : 0x%x, sgl addr : 0x%llx\\n\",\n\t\t\t\t\t\tle32_to_cpu(mfi_sgl->sge64[n].length),\n\t\t\t\t\t\tle64_to_cpu(mfi_sgl->sge64[n].phys_addr));\n\t\t\t\telse\n\t\t\t\t\tdev_err(&instance->pdev->dev, \"sgl len : 0x%x, sgl addr : 0x%x\\n\",\n\t\t\t\t\t\tle32_to_cpu(mfi_sgl->sge32[n].length),\n\t\t\t\t\t\tle32_to_cpu(mfi_sgl->sge32[n].phys_addr));\n\t\t\t}\n\t\t}\n\t} /*for max_cmd*/\n\tdev_err(&instance->pdev->dev, \"[%d]: Pending Internal cmds in FW : \\n\",instance->host->host_no);\n\tfor (i = 0; i < max_cmd; i++) {\n\n\t\tcmd = instance->cmd_list[i];\n\n\t\tif (cmd->sync_cmd == 1)\n\t\t\tdev_err(&instance->pdev->dev, \"0x%08lx : \", (unsigned long)cmd->frame_phys_addr);\n\t}\n\tdev_err(&instance->pdev->dev, \"[%d]: Dumping Done\\n\\n\",instance->host->host_no);\n}\n\nu32\nmegasas_build_and_issue_cmd(struct megasas_instance *instance,\n\t\t\t    struct scsi_cmnd *scmd)\n{\n\tstruct megasas_cmd *cmd;\n\tu32 frame_count;\n\n\tcmd = megasas_get_cmd(instance);\n\tif (!cmd)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\t/*\n\t * Logical drive command\n\t */\n\tif (megasas_cmd_type(scmd) == READ_WRITE_LDIO)\n\t\tframe_count = megasas_build_ldio(instance, scmd, cmd);\n\telse\n\t\tframe_count = megasas_build_dcdb(instance, scmd, cmd);\n\n\tif (!frame_count)\n\t\tgoto out_return_cmd;\n\n\tcmd->scmd = scmd;\n\tscmd->SCp.ptr = (char *)cmd;\n\n\t/*\n\t * Issue the command to the FW\n\t */\n\tatomic_inc(&instance->fw_outstanding);\n\n\tinstance->instancet->fire_cmd(instance, cmd->frame_phys_addr,\n\t\t\t\tcmd->frame_count-1, instance->reg_set);\n\n\treturn 0;\nout_return_cmd:\n\tmegasas_return_cmd(instance, cmd);\n\treturn SCSI_MLQUEUE_HOST_BUSY;\n}\n\n\n/**\n * megasas_queue_command -\tQueue entry point\n * @shost:\t\t\tadapter SCSI host\n * @scmd:\t\t\tSCSI command to be queued\n */\nstatic int\nmegasas_queue_command(struct Scsi_Host *shost, struct scsi_cmnd *scmd)\n{\n\tstruct megasas_instance *instance;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\n\tinstance = (struct megasas_instance *)\n\t    scmd->device->host->hostdata;\n\n\tif (instance->unload == 1) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscmd->scsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tif (instance->issuepend_done == 0)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\n\t/* Check for an mpio path and adjust behavior */\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_ADPRESET_SM_INFAULT) {\n\t\tif (megasas_check_mpio_paths(instance, scmd) ==\n\t\t    (DID_REQUEUE << 16)) {\n\t\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t\t} else {\n\t\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\t\tscmd->scsi_done(scmd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscmd->scsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tmr_device_priv_data = scmd->device->hostdata;\n\tif (!mr_device_priv_data) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscmd->scsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\tif (mr_device_priv_data->tm_busy)\n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\n\n\tscmd->result = 0;\n\n\tif (MEGASAS_IS_LOGICAL(scmd->device) &&\n\t    (scmd->device->id >= instance->fw_supported_vd_count ||\n\t\tscmd->device->lun)) {\n\t\tscmd->result = DID_BAD_TARGET << 16;\n\t\tgoto out_done;\n\t}\n\n\tif ((scmd->cmnd[0] == SYNCHRONIZE_CACHE) &&\n\t    MEGASAS_IS_LOGICAL(scmd->device) &&\n\t    (!instance->fw_sync_cache_support)) {\n\t\tscmd->result = DID_OK << 16;\n\t\tgoto out_done;\n\t}\n\n\treturn instance->instancet->build_and_issue_cmd(instance, scmd);\n\n out_done:\n\tscmd->scsi_done(scmd);\n\treturn 0;\n}\n\nstatic struct megasas_instance *megasas_lookup_instance(u16 host_no)\n{\n\tint i;\n\n\tfor (i = 0; i < megasas_mgmt_info.max_index; i++) {\n\n\t\tif ((megasas_mgmt_info.instance[i]) &&\n\t\t    (megasas_mgmt_info.instance[i]->host->host_no == host_no))\n\t\t\treturn megasas_mgmt_info.instance[i];\n\t}\n\n\treturn NULL;\n}\n\n/*\n* megasas_set_dynamic_target_properties -\n* Device property set by driver may not be static and it is required to be\n* updated after OCR\n*\n* set tm_capable.\n* set dma alignment (only for eedp protection enable vd).\n*\n* @sdev: OS provided scsi device\n*\n* Returns void\n*/\nvoid megasas_set_dynamic_target_properties(struct scsi_device *sdev,\n\t\t\t\t\t   bool is_target_prop)\n{\n\tu16 pd_index = 0, ld;\n\tu32 device_id;\n\tstruct megasas_instance *instance;\n\tstruct fusion_context *fusion;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\tstruct MR_PD_CFG_SEQ_NUM_SYNC *pd_sync;\n\tstruct MR_LD_RAID *raid;\n\tstruct MR_DRV_RAID_MAP_ALL *local_map_ptr;\n\n\tinstance = megasas_lookup_instance(sdev->host->host_no);\n\tfusion = instance->ctrl_context;\n\tmr_device_priv_data = sdev->hostdata;\n\n\tif (!fusion || !mr_device_priv_data)\n\t\treturn;\n\n\tif (MEGASAS_IS_LOGICAL(sdev)) {\n\t\tdevice_id = ((sdev->channel % 2) * MEGASAS_MAX_DEV_PER_CHANNEL)\n\t\t\t\t\t+ sdev->id;\n\t\tlocal_map_ptr = fusion->ld_drv_map[(instance->map_id & 1)];\n\t\tld = MR_TargetIdToLdGet(device_id, local_map_ptr);\n\t\tif (ld >= instance->fw_supported_vd_count)\n\t\t\treturn;\n\t\traid = MR_LdRaidGet(ld, local_map_ptr);\n\n\t\tif (raid->capability.ldPiMode == MR_PROT_INFO_TYPE_CONTROLLER)\n\t\tblk_queue_update_dma_alignment(sdev->request_queue, 0x7);\n\n\t\tmr_device_priv_data->is_tm_capable =\n\t\t\traid->capability.tmCapable;\n\n\t\tif (!raid->flags.isEPD)\n\t\t\tsdev->no_write_same = 1;\n\n\t} else if (instance->use_seqnum_jbod_fp) {\n\t\tpd_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +\n\t\t\tsdev->id;\n\t\tpd_sync = (void *)fusion->pd_seq_sync\n\t\t\t\t[(instance->pd_seq_map_id - 1) & 1];\n\t\tmr_device_priv_data->is_tm_capable =\n\t\t\tpd_sync->seq[pd_index].capability.tmCapable;\n\t}\n\n\tif (is_target_prop && instance->tgt_prop->reset_tmo) {\n\t\t/*\n\t\t * If FW provides a target reset timeout value, driver will use\n\t\t * it. If not set, fallback to default values.\n\t\t */\n\t\tmr_device_priv_data->target_reset_tmo =\n\t\t\tmin_t(u8, instance->max_reset_tmo,\n\t\t\t      instance->tgt_prop->reset_tmo);\n\t\tmr_device_priv_data->task_abort_tmo = instance->task_abort_tmo;\n\t} else {\n\t\tmr_device_priv_data->target_reset_tmo =\n\t\t\t\t\t\tMEGASAS_DEFAULT_TM_TIMEOUT;\n\t\tmr_device_priv_data->task_abort_tmo =\n\t\t\t\t\t\tMEGASAS_DEFAULT_TM_TIMEOUT;\n\t}\n}\n\n/*\n * megasas_set_nvme_device_properties -\n * set nomerges=2\n * set virtual page boundary = 4K (current mr_nvme_pg_size is 4K).\n * set maximum io transfer = MDTS of NVME device provided by MR firmware.\n *\n * MR firmware provides value in KB. Caller of this function converts\n * kb into bytes.\n *\n * e.a MDTS=5 means 2^5 * nvme page size. (In case of 4K page size,\n * MR firmware provides value 128 as (32 * 4K) = 128K.\n *\n * @sdev:\t\t\t\tscsi device\n * @max_io_size:\t\t\t\tmaximum io transfer size\n *\n */\nstatic inline void\nmegasas_set_nvme_device_properties(struct scsi_device *sdev, u32 max_io_size)\n{\n\tstruct megasas_instance *instance;\n\tu32 mr_nvme_pg_size;\n\n\tinstance = (struct megasas_instance *)sdev->host->hostdata;\n\tmr_nvme_pg_size = max_t(u32, instance->nvme_page_size,\n\t\t\t\tMR_DEFAULT_NVME_PAGE_SIZE);\n\n\tblk_queue_max_hw_sectors(sdev->request_queue, (max_io_size / 512));\n\n\tblk_queue_flag_set(QUEUE_FLAG_NOMERGES, sdev->request_queue);\n\tblk_queue_virt_boundary(sdev->request_queue, mr_nvme_pg_size - 1);\n}\n\n/*\n * megasas_set_fw_assisted_qd -\n * set device queue depth to can_queue\n * set device queue depth to fw assisted qd\n *\n * @sdev:\t\t\t\tscsi device\n * @is_target_prop\t\t\ttrue, if fw provided target properties.\n */\nstatic void megasas_set_fw_assisted_qd(struct scsi_device *sdev,\n\t\t\t\t\t\t bool is_target_prop)\n{\n\tu8 interface_type;\n\tu32 device_qd = MEGASAS_DEFAULT_CMD_PER_LUN;\n\tu32 tgt_device_qd;\n\tstruct megasas_instance *instance;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\n\tinstance = megasas_lookup_instance(sdev->host->host_no);\n\tmr_device_priv_data = sdev->hostdata;\n\tinterface_type  = mr_device_priv_data->interface_type;\n\n\tswitch (interface_type) {\n\tcase SAS_PD:\n\t\tdevice_qd = MEGASAS_SAS_QD;\n\t\tbreak;\n\tcase SATA_PD:\n\t\tdevice_qd = MEGASAS_SATA_QD;\n\t\tbreak;\n\tcase NVME_PD:\n\t\tdevice_qd = MEGASAS_NVME_QD;\n\t\tbreak;\n\t}\n\n\tif (is_target_prop) {\n\t\ttgt_device_qd = le32_to_cpu(instance->tgt_prop->device_qdepth);\n\t\tif (tgt_device_qd)\n\t\t\tdevice_qd = min(instance->host->can_queue,\n\t\t\t\t\t(int)tgt_device_qd);\n\t}\n\n\tif (instance->enable_sdev_max_qd && interface_type != UNKNOWN_DRIVE)\n\t\tdevice_qd = instance->host->can_queue;\n\n\tscsi_change_queue_depth(sdev, device_qd);\n}\n\n/*\n * megasas_set_static_target_properties -\n * Device property set by driver are static and it is not required to be\n * updated after OCR.\n *\n * set io timeout\n * set device queue depth\n * set nvme device properties. see - megasas_set_nvme_device_properties\n *\n * @sdev:\t\t\t\tscsi device\n * @is_target_prop\t\t\ttrue, if fw provided target properties.\n */\nstatic void megasas_set_static_target_properties(struct scsi_device *sdev,\n\t\t\t\t\t\t bool is_target_prop)\n{\n\tu32 max_io_size_kb = MR_DEFAULT_NVME_MDTS_KB;\n\tstruct megasas_instance *instance;\n\n\tinstance = megasas_lookup_instance(sdev->host->host_no);\n\n\t/*\n\t * The RAID firmware may require extended timeouts.\n\t */\n\tblk_queue_rq_timeout(sdev->request_queue, scmd_timeout * HZ);\n\n\t/* max_io_size_kb will be set to non zero for\n\t * nvme based vd and syspd.\n\t */\n\tif (is_target_prop)\n\t\tmax_io_size_kb = le32_to_cpu(instance->tgt_prop->max_io_size_kb);\n\n\tif (instance->nvme_page_size && max_io_size_kb)\n\t\tmegasas_set_nvme_device_properties(sdev, (max_io_size_kb << 10));\n\n\tmegasas_set_fw_assisted_qd(sdev, is_target_prop);\n}\n\n\nstatic int megasas_slave_configure(struct scsi_device *sdev)\n{\n\tu16 pd_index = 0;\n\tstruct megasas_instance *instance;\n\tint ret_target_prop = DCMD_FAILED;\n\tbool is_target_prop = false;\n\n\tinstance = megasas_lookup_instance(sdev->host->host_no);\n\tif (instance->pd_list_not_supported) {\n\t\tif (!MEGASAS_IS_LOGICAL(sdev) && sdev->type == TYPE_DISK) {\n\t\t\tpd_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +\n\t\t\t\tsdev->id;\n\t\t\tif (instance->pd_list[pd_index].driveState !=\n\t\t\t\tMR_PD_STATE_SYSTEM)\n\t\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tmutex_lock(&instance->reset_mutex);\n\t/* Send DCMD to Firmware and cache the information */\n\tif ((instance->pd_info) && !MEGASAS_IS_LOGICAL(sdev))\n\t\tmegasas_get_pd_info(instance, sdev);\n\n\t/* Some ventura firmware may not have instance->nvme_page_size set.\n\t * Do not send MR_DCMD_DRV_GET_TARGET_PROP\n\t */\n\tif ((instance->tgt_prop) && (instance->nvme_page_size))\n\t\tret_target_prop = megasas_get_target_prop(instance, sdev);\n\n\tis_target_prop = (ret_target_prop == DCMD_SUCCESS) ? true : false;\n\tmegasas_set_static_target_properties(sdev, is_target_prop);\n\n\t/* This sdev property may change post OCR */\n\tmegasas_set_dynamic_target_properties(sdev, is_target_prop);\n\n\tmutex_unlock(&instance->reset_mutex);\n\n\treturn 0;\n}\n\nstatic int megasas_slave_alloc(struct scsi_device *sdev)\n{\n\tu16 pd_index = 0;\n\tstruct megasas_instance *instance ;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\n\tinstance = megasas_lookup_instance(sdev->host->host_no);\n\tif (!MEGASAS_IS_LOGICAL(sdev)) {\n\t\t/*\n\t\t * Open the OS scan to the SYSTEM PD\n\t\t */\n\t\tpd_index =\n\t\t\t(sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +\n\t\t\tsdev->id;\n\t\tif ((instance->pd_list_not_supported ||\n\t\t\tinstance->pd_list[pd_index].driveState ==\n\t\t\tMR_PD_STATE_SYSTEM)) {\n\t\t\tgoto scan_target;\n\t\t}\n\t\treturn -ENXIO;\n\t}\n\nscan_target:\n\tmr_device_priv_data = kzalloc(sizeof(*mr_device_priv_data),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!mr_device_priv_data)\n\t\treturn -ENOMEM;\n\tsdev->hostdata = mr_device_priv_data;\n\n\tatomic_set(&mr_device_priv_data->r1_ldio_hint,\n\t\t   instance->r1_ldio_hint_default);\n\treturn 0;\n}\n\nstatic void megasas_slave_destroy(struct scsi_device *sdev)\n{\n\tkfree(sdev->hostdata);\n\tsdev->hostdata = NULL;\n}\n\n/*\n* megasas_complete_outstanding_ioctls - Complete outstanding ioctls after a\n*                                       kill adapter\n* @instance:\t\t\t\tAdapter soft state\n*\n*/\nstatic void megasas_complete_outstanding_ioctls(struct megasas_instance *instance)\n{\n\tint i;\n\tstruct megasas_cmd *cmd_mfi;\n\tstruct megasas_cmd_fusion *cmd_fusion;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\n\t/* Find all outstanding ioctls */\n\tif (fusion) {\n\t\tfor (i = 0; i < instance->max_fw_cmds; i++) {\n\t\t\tcmd_fusion = fusion->cmd_list[i];\n\t\t\tif (cmd_fusion->sync_cmd_idx != (u32)ULONG_MAX) {\n\t\t\t\tcmd_mfi = instance->cmd_list[cmd_fusion->sync_cmd_idx];\n\t\t\t\tif (cmd_mfi->sync_cmd &&\n\t\t\t\t    (cmd_mfi->frame->hdr.cmd != MFI_CMD_ABORT)) {\n\t\t\t\t\tcmd_mfi->frame->hdr.cmd_status =\n\t\t\t\t\t\t\tMFI_STAT_WRONG_STATE;\n\t\t\t\t\tmegasas_complete_cmd(instance,\n\t\t\t\t\t\t\t     cmd_mfi, DID_OK);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < instance->max_fw_cmds; i++) {\n\t\t\tcmd_mfi = instance->cmd_list[i];\n\t\t\tif (cmd_mfi->sync_cmd && cmd_mfi->frame->hdr.cmd !=\n\t\t\t\tMFI_CMD_ABORT)\n\t\t\t\tmegasas_complete_cmd(instance, cmd_mfi, DID_OK);\n\t\t}\n\t}\n}\n\n\nvoid megaraid_sas_kill_hba(struct megasas_instance *instance)\n{\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_warn(&instance->pdev->dev,\n\t\t\t \"Adapter already dead, skipping kill HBA\\n\");\n\t\treturn;\n\t}\n\n\t/* Set critical error to block I/O & ioctls in case caller didn't */\n\tatomic_set(&instance->adprecovery, MEGASAS_HW_CRITICAL_ERROR);\n\t/* Wait 1 second to ensure IO or ioctls in build have posted */\n\tmsleep(1000);\n\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t(instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\n\t\t(instance->adapter_type != MFI_SERIES)) {\n\t\tif (!instance->requestorId) {\n\t\t\twritel(MFI_STOP_ADP, &instance->reg_set->doorbell);\n\t\t\t/* Flush */\n\t\t\treadl(&instance->reg_set->doorbell);\n\t\t}\n\t\tif (instance->requestorId && instance->peerIsPresent)\n\t\t\tmemset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);\n\t} else {\n\t\twritel(MFI_STOP_ADP,\n\t\t\t&instance->reg_set->inbound_doorbell);\n\t}\n\t/* Complete outstanding ioctls when adapter is killed */\n\tmegasas_complete_outstanding_ioctls(instance);\n}\n\n /**\n  * megasas_check_and_restore_queue_depth - Check if queue depth needs to be\n  *\t\t\t\t\trestored to max value\n  * @instance:\t\t\tAdapter soft state\n  *\n  */\nvoid\nmegasas_check_and_restore_queue_depth(struct megasas_instance *instance)\n{\n\tunsigned long flags;\n\n\tif (instance->flag & MEGASAS_FW_BUSY\n\t    && time_after(jiffies, instance->last_time + 5 * HZ)\n\t    && atomic_read(&instance->fw_outstanding) <\n\t    instance->throttlequeuedepth + 1) {\n\n\t\tspin_lock_irqsave(instance->host->host_lock, flags);\n\t\tinstance->flag &= ~MEGASAS_FW_BUSY;\n\n\t\tinstance->host->can_queue = instance->cur_can_queue;\n\t\tspin_unlock_irqrestore(instance->host->host_lock, flags);\n\t}\n}\n\n/**\n * megasas_complete_cmd_dpc\t -\tReturns FW's controller structure\n * @instance_addr:\t\t\tAddress of adapter soft state\n *\n * Tasklet to complete cmds\n */\nstatic void megasas_complete_cmd_dpc(unsigned long instance_addr)\n{\n\tu32 producer;\n\tu32 consumer;\n\tu32 context;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_instance *instance =\n\t\t\t\t(struct megasas_instance *)instance_addr;\n\tunsigned long flags;\n\n\t/* If we have already declared adapter dead, donot complete cmds */\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR)\n\t\treturn;\n\n\tspin_lock_irqsave(&instance->completion_lock, flags);\n\n\tproducer = le32_to_cpu(*instance->producer);\n\tconsumer = le32_to_cpu(*instance->consumer);\n\n\twhile (consumer != producer) {\n\t\tcontext = le32_to_cpu(instance->reply_queue[consumer]);\n\t\tif (context >= instance->max_fw_cmds) {\n\t\t\tdev_err(&instance->pdev->dev, \"Unexpected context value %x\\n\",\n\t\t\t\tcontext);\n\t\t\tBUG();\n\t\t}\n\n\t\tcmd = instance->cmd_list[context];\n\n\t\tmegasas_complete_cmd(instance, cmd, DID_OK);\n\n\t\tconsumer++;\n\t\tif (consumer == (instance->max_fw_cmds + 1)) {\n\t\t\tconsumer = 0;\n\t\t}\n\t}\n\n\t*instance->consumer = cpu_to_le32(producer);\n\n\tspin_unlock_irqrestore(&instance->completion_lock, flags);\n\n\t/*\n\t * Check if we can restore can_queue\n\t */\n\tmegasas_check_and_restore_queue_depth(instance);\n}\n\nstatic void megasas_sriov_heartbeat_handler(struct timer_list *t);\n\n/**\n * megasas_start_timer - Initializes sriov heartbeat timer object\n * @instance:\t\tAdapter soft state\n *\n */\nvoid megasas_start_timer(struct megasas_instance *instance)\n{\n\tstruct timer_list *timer = &instance->sriov_heartbeat_timer;\n\n\ttimer_setup(timer, megasas_sriov_heartbeat_handler, 0);\n\ttimer->expires = jiffies + MEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF;\n\tadd_timer(timer);\n}\n\nstatic void\nmegasas_internal_reset_defer_cmds(struct megasas_instance *instance);\n\nstatic void\nprocess_fw_state_change_wq(struct work_struct *work);\n\nstatic void megasas_do_ocr(struct megasas_instance *instance)\n{\n\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS1064R) ||\n\t(instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5) ||\n\t(instance->pdev->device == PCI_DEVICE_ID_LSI_VERDE_ZCR)) {\n\t\t*instance->consumer = cpu_to_le32(MEGASAS_ADPRESET_INPROG_SIGN);\n\t}\n\tinstance->instancet->disable_intr(instance);\n\tatomic_set(&instance->adprecovery, MEGASAS_ADPRESET_SM_INFAULT);\n\tinstance->issuepend_done = 0;\n\n\tatomic_set(&instance->fw_outstanding, 0);\n\tmegasas_internal_reset_defer_cmds(instance);\n\tprocess_fw_state_change_wq(&instance->work_init);\n}\n\nstatic int megasas_get_ld_vf_affiliation_111(struct megasas_instance *instance,\n\t\t\t\t\t    int initial)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_LD_VF_AFFILIATION_111 *new_affiliation_111 = NULL;\n\tdma_addr_t new_affiliation_111_h;\n\tint ld, retval = 0;\n\tu8 thisVf;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"megasas_get_ld_vf_affiliation_111:\"\n\t\t       \"Failed to get cmd for scsi%d\\n\",\n\t\t\tinstance->host->host_no);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tif (!instance->vf_affiliation_111) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Couldn't get LD/VF \"\n\t\t       \"affiliation for scsi%d\\n\", instance->host->host_no);\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (initial)\n\t\t\tmemset(instance->vf_affiliation_111, 0,\n\t\t\t       sizeof(struct MR_LD_VF_AFFILIATION_111));\n\telse {\n\t\tnew_affiliation_111 =\n\t\t\tdma_alloc_coherent(&instance->pdev->dev,\n\t\t\t\t\t   sizeof(struct MR_LD_VF_AFFILIATION_111),\n\t\t\t\t\t   &new_affiliation_111_h, GFP_KERNEL);\n\t\tif (!new_affiliation_111) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"SR-IOV: Couldn't allocate \"\n\t\t\t       \"memory for new affiliation for scsi%d\\n\",\n\t\t\t       instance->host->host_no);\n\t\t\tmegasas_return_cmd(instance, cmd);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_BOTH);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len =\n\t\tcpu_to_le32(sizeof(struct MR_LD_VF_AFFILIATION_111));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_VF_MAP_GET_ALL_LDS_111);\n\n\tif (initial)\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\tcpu_to_le32(instance->vf_affiliation_111_h);\n\telse\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\tcpu_to_le32(new_affiliation_111_h);\n\n\tdcmd->sgl.sge32[0].length = cpu_to_le32(\n\t\tsizeof(struct MR_LD_VF_AFFILIATION_111));\n\n\tdev_warn(&instance->pdev->dev, \"SR-IOV: Getting LD/VF affiliation for \"\n\t       \"scsi%d\\n\", instance->host->host_no);\n\n\tif (megasas_issue_blocked_cmd(instance, cmd, 0) != DCMD_SUCCESS) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: LD/VF affiliation DCMD\"\n\t\t       \" failed with status 0x%x for scsi%d\\n\",\n\t\t       dcmd->cmd_status, instance->host->host_no);\n\t\tretval = 1; /* Do a scan if we couldn't get affiliation */\n\t\tgoto out;\n\t}\n\n\tif (!initial) {\n\t\tthisVf = new_affiliation_111->thisVf;\n\t\tfor (ld = 0 ; ld < new_affiliation_111->vdCount; ld++)\n\t\t\tif (instance->vf_affiliation_111->map[ld].policy[thisVf] !=\n\t\t\t    new_affiliation_111->map[ld].policy[thisVf]) {\n\t\t\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: \"\n\t\t\t\t       \"Got new LD/VF affiliation for scsi%d\\n\",\n\t\t\t\t       instance->host->host_no);\n\t\t\t\tmemcpy(instance->vf_affiliation_111,\n\t\t\t\t       new_affiliation_111,\n\t\t\t\t       sizeof(struct MR_LD_VF_AFFILIATION_111));\n\t\t\t\tretval = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t}\nout:\n\tif (new_affiliation_111) {\n\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t    sizeof(struct MR_LD_VF_AFFILIATION_111),\n\t\t\t\t    new_affiliation_111,\n\t\t\t\t    new_affiliation_111_h);\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn retval;\n}\n\nstatic int megasas_get_ld_vf_affiliation_12(struct megasas_instance *instance,\n\t\t\t\t\t    int initial)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_LD_VF_AFFILIATION *new_affiliation = NULL;\n\tstruct MR_LD_VF_MAP *newmap = NULL, *savedmap = NULL;\n\tdma_addr_t new_affiliation_h;\n\tint i, j, retval = 0, found = 0, doscan = 0;\n\tu8 thisVf;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"megasas_get_ld_vf_affiliation12: \"\n\t\t       \"Failed to get cmd for scsi%d\\n\",\n\t\t       instance->host->host_no);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tif (!instance->vf_affiliation) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Couldn't get LD/VF \"\n\t\t       \"affiliation for scsi%d\\n\", instance->host->host_no);\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (initial)\n\t\tmemset(instance->vf_affiliation, 0, (MAX_LOGICAL_DRIVES + 1) *\n\t\t       sizeof(struct MR_LD_VF_AFFILIATION));\n\telse {\n\t\tnew_affiliation =\n\t\t\tdma_alloc_coherent(&instance->pdev->dev,\n\t\t\t\t\t   (MAX_LOGICAL_DRIVES + 1) * sizeof(struct MR_LD_VF_AFFILIATION),\n\t\t\t\t\t   &new_affiliation_h, GFP_KERNEL);\n\t\tif (!new_affiliation) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"SR-IOV: Couldn't allocate \"\n\t\t\t       \"memory for new affiliation for scsi%d\\n\",\n\t\t\t       instance->host->host_no);\n\t\t\tmegasas_return_cmd(instance, cmd);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_BOTH);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32((MAX_LOGICAL_DRIVES + 1) *\n\t\tsizeof(struct MR_LD_VF_AFFILIATION));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_VF_MAP_GET_ALL_LDS);\n\n\tif (initial)\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\tcpu_to_le32(instance->vf_affiliation_h);\n\telse\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\tcpu_to_le32(new_affiliation_h);\n\n\tdcmd->sgl.sge32[0].length = cpu_to_le32((MAX_LOGICAL_DRIVES + 1) *\n\t\tsizeof(struct MR_LD_VF_AFFILIATION));\n\n\tdev_warn(&instance->pdev->dev, \"SR-IOV: Getting LD/VF affiliation for \"\n\t       \"scsi%d\\n\", instance->host->host_no);\n\n\n\tif (megasas_issue_blocked_cmd(instance, cmd, 0) != DCMD_SUCCESS) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: LD/VF affiliation DCMD\"\n\t\t       \" failed with status 0x%x for scsi%d\\n\",\n\t\t       dcmd->cmd_status, instance->host->host_no);\n\t\tretval = 1; /* Do a scan if we couldn't get affiliation */\n\t\tgoto out;\n\t}\n\n\tif (!initial) {\n\t\tif (!new_affiliation->ldCount) {\n\t\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Got new LD/VF \"\n\t\t\t       \"affiliation for passive path for scsi%d\\n\",\n\t\t\t       instance->host->host_no);\n\t\t\tretval = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tnewmap = new_affiliation->map;\n\t\tsavedmap = instance->vf_affiliation->map;\n\t\tthisVf = new_affiliation->thisVf;\n\t\tfor (i = 0 ; i < new_affiliation->ldCount; i++) {\n\t\t\tfound = 0;\n\t\t\tfor (j = 0; j < instance->vf_affiliation->ldCount;\n\t\t\t     j++) {\n\t\t\t\tif (newmap->ref.targetId ==\n\t\t\t\t    savedmap->ref.targetId) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif (newmap->policy[thisVf] !=\n\t\t\t\t\t    savedmap->policy[thisVf]) {\n\t\t\t\t\t\tdoscan = 1;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsavedmap = (struct MR_LD_VF_MAP *)\n\t\t\t\t\t((unsigned char *)savedmap +\n\t\t\t\t\t savedmap->size);\n\t\t\t}\n\t\t\tif (!found && newmap->policy[thisVf] !=\n\t\t\t    MR_LD_ACCESS_HIDDEN) {\n\t\t\t\tdoscan = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnewmap = (struct MR_LD_VF_MAP *)\n\t\t\t\t((unsigned char *)newmap + newmap->size);\n\t\t}\n\n\t\tnewmap = new_affiliation->map;\n\t\tsavedmap = instance->vf_affiliation->map;\n\n\t\tfor (i = 0 ; i < instance->vf_affiliation->ldCount; i++) {\n\t\t\tfound = 0;\n\t\t\tfor (j = 0 ; j < new_affiliation->ldCount; j++) {\n\t\t\t\tif (savedmap->ref.targetId ==\n\t\t\t\t    newmap->ref.targetId) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif (savedmap->policy[thisVf] !=\n\t\t\t\t\t    newmap->policy[thisVf]) {\n\t\t\t\t\t\tdoscan = 1;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnewmap = (struct MR_LD_VF_MAP *)\n\t\t\t\t\t((unsigned char *)newmap +\n\t\t\t\t\t newmap->size);\n\t\t\t}\n\t\t\tif (!found && savedmap->policy[thisVf] !=\n\t\t\t    MR_LD_ACCESS_HIDDEN) {\n\t\t\t\tdoscan = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsavedmap = (struct MR_LD_VF_MAP *)\n\t\t\t\t((unsigned char *)savedmap +\n\t\t\t\t savedmap->size);\n\t\t}\n\t}\nout:\n\tif (doscan) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Got new LD/VF \"\n\t\t       \"affiliation for scsi%d\\n\", instance->host->host_no);\n\t\tmemcpy(instance->vf_affiliation, new_affiliation,\n\t\t       new_affiliation->size);\n\t\tretval = 1;\n\t}\n\n\tif (new_affiliation)\n\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t    (MAX_LOGICAL_DRIVES + 1) *\n\t\t\t\t    sizeof(struct MR_LD_VF_AFFILIATION),\n\t\t\t\t    new_affiliation, new_affiliation_h);\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn retval;\n}\n\n/* This function will get the current SR-IOV LD/VF affiliation */\nstatic int megasas_get_ld_vf_affiliation(struct megasas_instance *instance,\n\tint initial)\n{\n\tint retval;\n\n\tif (instance->PlasmaFW111)\n\t\tretval = megasas_get_ld_vf_affiliation_111(instance, initial);\n\telse\n\t\tretval = megasas_get_ld_vf_affiliation_12(instance, initial);\n\treturn retval;\n}\n\n/* This function will tell FW to start the SR-IOV heartbeat */\nint megasas_sriov_start_heartbeat(struct megasas_instance *instance,\n\t\t\t\t\t int initial)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tint retval = 0;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"megasas_sriov_start_heartbeat: \"\n\t\t       \"Failed to get cmd for scsi%d\\n\",\n\t\t       instance->host->host_no);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tif (initial) {\n\t\tinstance->hb_host_mem =\n\t\t\tdma_alloc_coherent(&instance->pdev->dev,\n\t\t\t\t\t   sizeof(struct MR_CTRL_HB_HOST_MEM),\n\t\t\t\t\t   &instance->hb_host_mem_h,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!instance->hb_host_mem) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"SR-IOV: Couldn't allocate\"\n\t\t\t       \" memory for heartbeat host memory for scsi%d\\n\",\n\t\t\t       instance->host->host_no);\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.s[0] = cpu_to_le16(sizeof(struct MR_CTRL_HB_HOST_MEM));\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_BOTH);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_CTRL_HB_HOST_MEM));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_SHARED_HOST_MEM_ALLOC);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->hb_host_mem_h,\n\t\t\t\t sizeof(struct MR_CTRL_HB_HOST_MEM));\n\n\tdev_warn(&instance->pdev->dev, \"SR-IOV: Starting heartbeat for scsi%d\\n\",\n\t       instance->host->host_no);\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tretval = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\tMEGASAS_ROUTINE_WAIT_TIME_VF);\n\telse\n\t\tretval = megasas_issue_polled(instance, cmd);\n\n\tif (retval) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: MR_DCMD_CTRL_SHARED_HOST\"\n\t\t\t\"_MEM_ALLOC DCMD %s for scsi%d\\n\",\n\t\t\t(dcmd->cmd_status == MFI_STAT_INVALID_STATUS) ?\n\t\t\t\"timed out\" : \"failed\", instance->host->host_no);\n\t\tretval = 1;\n\t}\n\nout:\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn retval;\n}\n\n/* Handler for SR-IOV heartbeat */\nstatic void megasas_sriov_heartbeat_handler(struct timer_list *t)\n{\n\tstruct megasas_instance *instance =\n\t\tfrom_timer(instance, t, sriov_heartbeat_timer);\n\n\tif (instance->hb_host_mem->HB.fwCounter !=\n\t    instance->hb_host_mem->HB.driverCounter) {\n\t\tinstance->hb_host_mem->HB.driverCounter =\n\t\t\tinstance->hb_host_mem->HB.fwCounter;\n\t\tmod_timer(&instance->sriov_heartbeat_timer,\n\t\t\t  jiffies + MEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF);\n\t} else {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Heartbeat never \"\n\t\t       \"completed for scsi%d\\n\", instance->host->host_no);\n\t\tschedule_work(&instance->work_init);\n\t}\n}\n\n/**\n * megasas_wait_for_outstanding -\tWait for all outstanding cmds\n * @instance:\t\t\t\tAdapter soft state\n *\n * This function waits for up to MEGASAS_RESET_WAIT_TIME seconds for FW to\n * complete all its outstanding commands. Returns error if one or more IOs\n * are pending after this time period. It also marks the controller dead.\n */\nstatic int megasas_wait_for_outstanding(struct megasas_instance *instance)\n{\n\tint i, sl, outstanding;\n\tu32 reset_index;\n\tu32 wait_time = MEGASAS_RESET_WAIT_TIME;\n\tunsigned long flags;\n\tstruct list_head clist_local;\n\tstruct megasas_cmd *reset_cmd;\n\tu32 fw_state;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_info(&instance->pdev->dev, \"%s:%d HBA is killed.\\n\",\n\t\t__func__, __LINE__);\n\t\treturn FAILED;\n\t}\n\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {\n\n\t\tINIT_LIST_HEAD(&clist_local);\n\t\tspin_lock_irqsave(&instance->hba_lock, flags);\n\t\tlist_splice_init(&instance->internal_reset_pending_q,\n\t\t\t\t&clist_local);\n\t\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n\n\t\tdev_notice(&instance->pdev->dev, \"HBA reset wait ...\\n\");\n\t\tfor (i = 0; i < wait_time; i++) {\n\t\t\tmsleep(1000);\n\t\t\tif (atomic_read(&instance->adprecovery) == MEGASAS_HBA_OPERATIONAL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {\n\t\t\tdev_notice(&instance->pdev->dev, \"reset: Stopping HBA.\\n\");\n\t\t\tatomic_set(&instance->adprecovery, MEGASAS_HW_CRITICAL_ERROR);\n\t\t\treturn FAILED;\n\t\t}\n\n\t\treset_index = 0;\n\t\twhile (!list_empty(&clist_local)) {\n\t\t\treset_cmd = list_entry((&clist_local)->next,\n\t\t\t\t\t\tstruct megasas_cmd, list);\n\t\t\tlist_del_init(&reset_cmd->list);\n\t\t\tif (reset_cmd->scmd) {\n\t\t\t\treset_cmd->scmd->result = DID_REQUEUE << 16;\n\t\t\t\tdev_notice(&instance->pdev->dev, \"%d:%p reset [%02x]\\n\",\n\t\t\t\t\treset_index, reset_cmd,\n\t\t\t\t\treset_cmd->scmd->cmnd[0]);\n\n\t\t\t\treset_cmd->scmd->scsi_done(reset_cmd->scmd);\n\t\t\t\tmegasas_return_cmd(instance, reset_cmd);\n\t\t\t} else if (reset_cmd->sync_cmd) {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"%p synch cmds\"\n\t\t\t\t\t\t\"reset queue\\n\",\n\t\t\t\t\t\treset_cmd);\n\n\t\t\t\treset_cmd->cmd_status_drv = DCMD_INIT;\n\t\t\t\tinstance->instancet->fire_cmd(instance,\n\t\t\t\t\t\treset_cmd->frame_phys_addr,\n\t\t\t\t\t\t0, instance->reg_set);\n\t\t\t} else {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"%p unexpected\"\n\t\t\t\t\t\"cmds lst\\n\",\n\t\t\t\t\treset_cmd);\n\t\t\t}\n\t\t\treset_index++;\n\t\t}\n\n\t\treturn SUCCESS;\n\t}\n\n\tfor (i = 0; i < resetwaittime; i++) {\n\t\toutstanding = atomic_read(&instance->fw_outstanding);\n\n\t\tif (!outstanding)\n\t\t\tbreak;\n\n\t\tif (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {\n\t\t\tdev_notice(&instance->pdev->dev, \"[%2d]waiting for %d \"\n\t\t\t       \"commands to complete\\n\",i,outstanding);\n\t\t\t/*\n\t\t\t * Call cmd completion routine. Cmd to be\n\t\t\t * be completed directly without depending on isr.\n\t\t\t */\n\t\t\tmegasas_complete_cmd_dpc((unsigned long)instance);\n\t\t}\n\n\t\tmsleep(1000);\n\t}\n\n\ti = 0;\n\toutstanding = atomic_read(&instance->fw_outstanding);\n\tfw_state = instance->instancet->read_fw_status_reg(instance) & MFI_STATE_MASK;\n\n\tif ((!outstanding && (fw_state == MFI_STATE_OPERATIONAL)))\n\t\tgoto no_outstanding;\n\n\tif (instance->disableOnlineCtrlReset)\n\t\tgoto kill_hba_and_failed;\n\tdo {\n\t\tif ((fw_state == MFI_STATE_FAULT) || atomic_read(&instance->fw_outstanding)) {\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\"%s:%d waiting_for_outstanding: before issue OCR. FW state = 0x%x, outstanding 0x%x\\n\",\n\t\t\t\t__func__, __LINE__, fw_state, atomic_read(&instance->fw_outstanding));\n\t\t\tif (i == 3)\n\t\t\t\tgoto kill_hba_and_failed;\n\t\t\tmegasas_do_ocr(instance);\n\n\t\t\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\t\t\tdev_info(&instance->pdev->dev, \"%s:%d OCR failed and HBA is killed.\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\t\treturn FAILED;\n\t\t\t}\n\t\t\tdev_info(&instance->pdev->dev, \"%s:%d waiting_for_outstanding: after issue OCR.\\n\",\n\t\t\t\t__func__, __LINE__);\n\n\t\t\tfor (sl = 0; sl < 10; sl++)\n\t\t\t\tmsleep(500);\n\n\t\t\toutstanding = atomic_read(&instance->fw_outstanding);\n\n\t\t\tfw_state = instance->instancet->read_fw_status_reg(instance) & MFI_STATE_MASK;\n\t\t\tif ((!outstanding && (fw_state == MFI_STATE_OPERATIONAL)))\n\t\t\t\tgoto no_outstanding;\n\t\t}\n\t\ti++;\n\t} while (i <= 3);\n\nno_outstanding:\n\n\tdev_info(&instance->pdev->dev, \"%s:%d no more pending commands remain after reset handling.\\n\",\n\t\t__func__, __LINE__);\n\treturn SUCCESS;\n\nkill_hba_and_failed:\n\n\t/* Reset not supported, kill adapter */\n\tdev_info(&instance->pdev->dev, \"%s:%d killing adapter scsi%d\"\n\t\t\" disableOnlineCtrlReset %d fw_outstanding %d \\n\",\n\t\t__func__, __LINE__, instance->host->host_no, instance->disableOnlineCtrlReset,\n\t\tatomic_read(&instance->fw_outstanding));\n\tmegasas_dump_pending_frames(instance);\n\tmegaraid_sas_kill_hba(instance);\n\n\treturn FAILED;\n}\n\n/**\n * megasas_generic_reset -\tGeneric reset routine\n * @scmd:\t\t\tMid-layer SCSI command\n *\n * This routine implements a generic reset handler for device, bus and host\n * reset requests. Device, bus and host specific reset handlers can use this\n * function after they do their specific tasks.\n */\nstatic int megasas_generic_reset(struct scsi_cmnd *scmd)\n{\n\tint ret_val;\n\tstruct megasas_instance *instance;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tscmd_printk(KERN_NOTICE, scmd, \"megasas: RESET cmd=%x retries=%x\\n\",\n\t\t scmd->cmnd[0], scmd->retries);\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"cannot recover from previous reset failures\\n\");\n\t\treturn FAILED;\n\t}\n\n\tret_val = megasas_wait_for_outstanding(instance);\n\tif (ret_val == SUCCESS)\n\t\tdev_notice(&instance->pdev->dev, \"reset successful\\n\");\n\telse\n\t\tdev_err(&instance->pdev->dev, \"failed to do reset\\n\");\n\n\treturn ret_val;\n}\n\n/**\n * megasas_reset_timer - quiesce the adapter if required\n * @scmd:\t\tscsi cmnd\n *\n * Sets the FW busy flag and reduces the host->can_queue if the\n * cmd has not been completed within the timeout period.\n */\nstatic enum\nblk_eh_timer_return megasas_reset_timer(struct scsi_cmnd *scmd)\n{\n\tstruct megasas_instance *instance;\n\tunsigned long flags;\n\n\tif (time_after(jiffies, scmd->jiffies_at_alloc +\n\t\t\t\t(scmd_timeout * 2) * HZ)) {\n\t\treturn BLK_EH_DONE;\n\t}\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\tif (!(instance->flag & MEGASAS_FW_BUSY)) {\n\t\t/* FW is busy, throttle IO */\n\t\tspin_lock_irqsave(instance->host->host_lock, flags);\n\n\t\tinstance->host->can_queue = instance->throttlequeuedepth;\n\t\tinstance->last_time = jiffies;\n\t\tinstance->flag |= MEGASAS_FW_BUSY;\n\n\t\tspin_unlock_irqrestore(instance->host->host_lock, flags);\n\t}\n\treturn BLK_EH_RESET_TIMER;\n}\n\n/**\n * megasas_dump -\tThis function will print hexdump of provided buffer.\n * @buf:\t\tBuffer to be dumped\n * @sz:\t\tSize in bytes\n * @format:\t\tDifferent formats of dumping e.g. format=n will\n *\t\t\tcause only 'n' 32 bit words to be dumped in a single\n *\t\t\tline.\n */\ninline void\nmegasas_dump(void *buf, int sz, int format)\n{\n\tint i;\n\t__le32 *buf_loc = (__le32 *)buf;\n\n\tfor (i = 0; i < (sz / sizeof(__le32)); i++) {\n\t\tif ((i % format) == 0) {\n\t\t\tif (i != 0)\n\t\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_CONT \"%08x: \", (i * 4));\n\t\t}\n\t\tprintk(KERN_CONT \"%08x \", le32_to_cpu(buf_loc[i]));\n\t}\n\tprintk(KERN_CONT \"\\n\");\n}\n\n/**\n * megasas_dump_reg_set -\tThis function will print hexdump of register set\n * @reg_set:\tRegister set to be dumped\n */\ninline void\nmegasas_dump_reg_set(void __iomem *reg_set)\n{\n\tunsigned int i, sz = 256;\n\tu32 __iomem *reg = (u32 __iomem *)reg_set;\n\n\tfor (i = 0; i < (sz / sizeof(u32)); i++)\n\t\tprintk(\"%08x: %08x\\n\", (i * 4), readl(&reg[i]));\n}\n\n/**\n * megasas_dump_fusion_io -\tThis function will print key details\n *\t\t\t\tof SCSI IO\n * @scmd:\t\t\tSCSI command pointer of SCSI IO\n */\nvoid\nmegasas_dump_fusion_io(struct scsi_cmnd *scmd)\n{\n\tstruct megasas_cmd_fusion *cmd;\n\tunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;\n\tstruct megasas_instance *instance;\n\n\tcmd = (struct megasas_cmd_fusion *)scmd->SCp.ptr;\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tscmd_printk(KERN_INFO, scmd,\n\t\t    \"scmd: (0x%p)  retries: 0x%x  allowed: 0x%x\\n\",\n\t\t    scmd, scmd->retries, scmd->allowed);\n\tscsi_print_command(scmd);\n\n\tif (cmd) {\n\t\treq_desc = (union MEGASAS_REQUEST_DESCRIPTOR_UNION *)cmd->request_desc;\n\t\tscmd_printk(KERN_INFO, scmd, \"Request descriptor details:\\n\");\n\t\tscmd_printk(KERN_INFO, scmd,\n\t\t\t    \"RequestFlags:0x%x  MSIxIndex:0x%x  SMID:0x%x  LMID:0x%x  DevHandle:0x%x\\n\",\n\t\t\t    req_desc->SCSIIO.RequestFlags,\n\t\t\t    req_desc->SCSIIO.MSIxIndex, req_desc->SCSIIO.SMID,\n\t\t\t    req_desc->SCSIIO.LMID, req_desc->SCSIIO.DevHandle);\n\n\t\tprintk(KERN_INFO \"IO request frame:\\n\");\n\t\tmegasas_dump(cmd->io_request,\n\t\t\t     MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE, 8);\n\t\tprintk(KERN_INFO \"Chain frame:\\n\");\n\t\tmegasas_dump(cmd->sg_frame,\n\t\t\t     instance->max_chain_frame_sz, 8);\n\t}\n\n}\n\n/*\n * megasas_dump_sys_regs - This function will dump system registers through\n *\t\t\t    sysfs.\n * @reg_set:\t\t    Pointer to System register set.\n * @buf:\t\t    Buffer to which output is to be written.\n * @return:\t\t    Number of bytes written to buffer.\n */\nstatic inline ssize_t\nmegasas_dump_sys_regs(void __iomem *reg_set, char *buf)\n{\n\tunsigned int i, sz = 256;\n\tint bytes_wrote = 0;\n\tchar *loc = (char *)buf;\n\tu32 __iomem *reg = (u32 __iomem *)reg_set;\n\n\tfor (i = 0; i < sz / sizeof(u32); i++) {\n\t\tbytes_wrote += scnprintf(loc + bytes_wrote,\n\t\t\t\t\t PAGE_SIZE - bytes_wrote,\n\t\t\t\t\t \"%08x: %08x\\n\", (i * 4),\n\t\t\t\t\t readl(&reg[i]));\n\t}\n\treturn bytes_wrote;\n}\n\n/**\n * megasas_reset_bus_host -\tBus & host reset handler entry point\n * @scmd:\t\t\tMid-layer SCSI command\n */\nstatic int megasas_reset_bus_host(struct scsi_cmnd *scmd)\n{\n\tint ret;\n\tstruct megasas_instance *instance;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tscmd_printk(KERN_INFO, scmd,\n\t\t\"OCR is requested due to IO timeout!!\\n\");\n\n\tscmd_printk(KERN_INFO, scmd,\n\t\t\"SCSI host state: %d  SCSI host busy: %d  FW outstanding: %d\\n\",\n\t\tscmd->device->host->shost_state,\n\t\tscsi_host_busy(scmd->device->host),\n\t\tatomic_read(&instance->fw_outstanding));\n\t/*\n\t * First wait for all commands to complete\n\t */\n\tif (instance->adapter_type == MFI_SERIES) {\n\t\tret = megasas_generic_reset(scmd);\n\t} else {\n\t\tmegasas_dump_fusion_io(scmd);\n\t\tret = megasas_reset_fusion(scmd->device->host,\n\t\t\t\tSCSIIO_TIMEOUT_OCR);\n\t}\n\n\treturn ret;\n}\n\n/**\n * megasas_task_abort - Issues task abort request to firmware\n *\t\t\t(supported only for fusion adapters)\n * @scmd:\t\tSCSI command pointer\n */\nstatic int megasas_task_abort(struct scsi_cmnd *scmd)\n{\n\tint ret;\n\tstruct megasas_instance *instance;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tret = megasas_task_abort_fusion(scmd);\n\telse {\n\t\tsdev_printk(KERN_NOTICE, scmd->device, \"TASK ABORT not supported\\n\");\n\t\tret = FAILED;\n\t}\n\n\treturn ret;\n}\n\n/**\n * megasas_reset_target:  Issues target reset request to firmware\n *                        (supported only for fusion adapters)\n * @scmd:                 SCSI command pointer\n */\nstatic int megasas_reset_target(struct scsi_cmnd *scmd)\n{\n\tint ret;\n\tstruct megasas_instance *instance;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tret = megasas_reset_target_fusion(scmd);\n\telse {\n\t\tsdev_printk(KERN_NOTICE, scmd->device, \"TARGET RESET not supported\\n\");\n\t\tret = FAILED;\n\t}\n\n\treturn ret;\n}\n\n/**\n * megasas_bios_param - Returns disk geometry for a disk\n * @sdev:\t\tdevice handle\n * @bdev:\t\tblock device\n * @capacity:\t\tdrive capacity\n * @geom:\t\tgeometry parameters\n */\nstatic int\nmegasas_bios_param(struct scsi_device *sdev, struct block_device *bdev,\n\t\t sector_t capacity, int geom[])\n{\n\tint heads;\n\tint sectors;\n\tsector_t cylinders;\n\tunsigned long tmp;\n\n\t/* Default heads (64) & sectors (32) */\n\theads = 64;\n\tsectors = 32;\n\n\ttmp = heads * sectors;\n\tcylinders = capacity;\n\n\tsector_div(cylinders, tmp);\n\n\t/*\n\t * Handle extended translation size for logical drives > 1Gb\n\t */\n\n\tif (capacity >= 0x200000) {\n\t\theads = 255;\n\t\tsectors = 63;\n\t\ttmp = heads*sectors;\n\t\tcylinders = capacity;\n\t\tsector_div(cylinders, tmp);\n\t}\n\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = cylinders;\n\n\treturn 0;\n}\n\nstatic int megasas_map_queues(struct Scsi_Host *shost)\n{\n\tstruct megasas_instance *instance;\n\n\tinstance = (struct megasas_instance *)shost->hostdata;\n\n\tif (shost->nr_hw_queues == 1)\n\t\treturn 0;\n\n\treturn blk_mq_pci_map_queues(&shost->tag_set.map[HCTX_TYPE_DEFAULT],\n\t\t\tinstance->pdev, instance->low_latency_index_start);\n}\n\nstatic void megasas_aen_polling(struct work_struct *work);\n\n/**\n * megasas_service_aen -\tProcesses an event notification\n * @instance:\t\t\tAdapter soft state\n * @cmd:\t\t\tAEN command completed by the ISR\n *\n * For AEN, driver sends a command down to FW that is held by the FW till an\n * event occurs. When an event of interest occurs, FW completes the command\n * that it was previously holding.\n *\n * This routines sends SIGIO signal to processes that have registered with the\n * driver for AEN.\n */\nstatic void\nmegasas_service_aen(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Don't signal app if it is just an aborted previously registered aen\n\t */\n\tif ((!cmd->abort_aen) && (instance->unload == 0)) {\n\t\tspin_lock_irqsave(&poll_aen_lock, flags);\n\t\tmegasas_poll_wait_aen = 1;\n\t\tspin_unlock_irqrestore(&poll_aen_lock, flags);\n\t\twake_up(&megasas_poll_wait);\n\t\tkill_fasync(&megasas_async_queue, SIGIO, POLL_IN);\n\t}\n\telse\n\t\tcmd->abort_aen = 0;\n\n\tinstance->aen_cmd = NULL;\n\n\tmegasas_return_cmd(instance, cmd);\n\n\tif ((instance->unload == 0) &&\n\t\t((instance->issuepend_done == 1))) {\n\t\tstruct megasas_aen_event *ev;\n\n\t\tev = kzalloc(sizeof(*ev), GFP_ATOMIC);\n\t\tif (!ev) {\n\t\t\tdev_err(&instance->pdev->dev, \"megasas_service_aen: out of memory\\n\");\n\t\t} else {\n\t\t\tev->instance = instance;\n\t\t\tinstance->ev = ev;\n\t\t\tINIT_DELAYED_WORK(&ev->hotplug_work,\n\t\t\t\t\t  megasas_aen_polling);\n\t\t\tschedule_delayed_work(&ev->hotplug_work, 0);\n\t\t}\n\t}\n}\n\nstatic ssize_t\nfw_crash_buffer_store(struct device *cdev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\tint val = 0;\n\tunsigned long flags;\n\n\tif (kstrtoint(buf, 0, &val) != 0)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&instance->crashdump_lock, flags);\n\tinstance->fw_crash_buffer_offset = val;\n\tspin_unlock_irqrestore(&instance->crashdump_lock, flags);\n\treturn strlen(buf);\n}\n\nstatic ssize_t\nfw_crash_buffer_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\tu32 size;\n\tunsigned long dmachunk = CRASH_DMA_BUF_SIZE;\n\tunsigned long chunk_left_bytes;\n\tunsigned long src_addr;\n\tunsigned long flags;\n\tu32 buff_offset;\n\n\tspin_lock_irqsave(&instance->crashdump_lock, flags);\n\tbuff_offset = instance->fw_crash_buffer_offset;\n\tif (!instance->crash_dump_buf &&\n\t\t!((instance->fw_crash_state == AVAILABLE) ||\n\t\t(instance->fw_crash_state == COPYING))) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Firmware crash dump is not available\\n\");\n\t\tspin_unlock_irqrestore(&instance->crashdump_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tif (buff_offset > (instance->fw_crash_buffer_size * dmachunk)) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Firmware crash dump offset is out of range\\n\");\n\t\tspin_unlock_irqrestore(&instance->crashdump_lock, flags);\n\t\treturn 0;\n\t}\n\n\tsize = (instance->fw_crash_buffer_size * dmachunk) - buff_offset;\n\tchunk_left_bytes = dmachunk - (buff_offset % dmachunk);\n\tsize = (size > chunk_left_bytes) ? chunk_left_bytes : size;\n\tsize = (size >= PAGE_SIZE) ? (PAGE_SIZE - 1) : size;\n\n\tsrc_addr = (unsigned long)instance->crash_buf[buff_offset / dmachunk] +\n\t\t(buff_offset % dmachunk);\n\tmemcpy(buf, (void *)src_addr, size);\n\tspin_unlock_irqrestore(&instance->crashdump_lock, flags);\n\n\treturn size;\n}\n\nstatic ssize_t\nfw_crash_buffer_size_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%ld\\n\", (unsigned long)\n\t\t((instance->fw_crash_buffer_size) * 1024 * 1024)/PAGE_SIZE);\n}\n\nstatic ssize_t\nfw_crash_state_store(struct device *cdev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\tint val = 0;\n\tunsigned long flags;\n\n\tif (kstrtoint(buf, 0, &val) != 0)\n\t\treturn -EINVAL;\n\n\tif ((val <= AVAILABLE || val > COPY_ERROR)) {\n\t\tdev_err(&instance->pdev->dev, \"application updates invalid \"\n\t\t\t\"firmware crash state\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinstance->fw_crash_state = val;\n\n\tif ((val == COPIED) || (val == COPY_ERROR)) {\n\t\tspin_lock_irqsave(&instance->crashdump_lock, flags);\n\t\tmegasas_free_host_crash_buffer(instance);\n\t\tspin_unlock_irqrestore(&instance->crashdump_lock, flags);\n\t\tif (val == COPY_ERROR)\n\t\t\tdev_info(&instance->pdev->dev, \"application failed to \"\n\t\t\t\t\"copy Firmware crash dump\\n\");\n\t\telse\n\t\t\tdev_info(&instance->pdev->dev, \"Firmware crash dump \"\n\t\t\t\t\"copied successfully\\n\");\n\t}\n\treturn strlen(buf);\n}\n\nstatic ssize_t\nfw_crash_state_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", instance->fw_crash_state);\n}\n\nstatic ssize_t\npage_size_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%ld\\n\", (unsigned long)PAGE_SIZE - 1);\n}\n\nstatic ssize_t\nldio_outstanding_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance = (struct megasas_instance *)shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", atomic_read(&instance->ldio_outstanding));\n}\n\nstatic ssize_t\nfw_cmds_outstanding_show(struct device *cdev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance = (struct megasas_instance *)shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", atomic_read(&instance->fw_outstanding));\n}\n\nstatic ssize_t\nenable_sdev_max_qd_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance = (struct megasas_instance *)shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", instance->enable_sdev_max_qd);\n}\n\nstatic ssize_t\nenable_sdev_max_qd_store(struct device *cdev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance = (struct megasas_instance *)shost->hostdata;\n\tu32 val = 0;\n\tbool is_target_prop;\n\tint ret_target_prop = DCMD_FAILED;\n\tstruct scsi_device *sdev;\n\n\tif (kstrtou32(buf, 0, &val) != 0) {\n\t\tpr_err(\"megasas: could not set enable_sdev_max_qd\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&instance->reset_mutex);\n\tif (val)\n\t\tinstance->enable_sdev_max_qd = true;\n\telse\n\t\tinstance->enable_sdev_max_qd = false;\n\n\tshost_for_each_device(sdev, shost) {\n\t\tret_target_prop = megasas_get_target_prop(instance, sdev);\n\t\tis_target_prop = (ret_target_prop == DCMD_SUCCESS) ? true : false;\n\t\tmegasas_set_fw_assisted_qd(sdev, is_target_prop);\n\t}\n\tmutex_unlock(&instance->reset_mutex);\n\n\treturn strlen(buf);\n}\n\nstatic ssize_t\ndump_system_regs_show(struct device *cdev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t\t(struct megasas_instance *)shost->hostdata;\n\n\treturn megasas_dump_sys_regs(instance->reg_set, buf);\n}\n\nstatic ssize_t\nraid_map_id_show(struct device *cdev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t\t(struct megasas_instance *)shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%ld\\n\",\n\t\t\t(unsigned long)instance->map_id);\n}\n\nstatic DEVICE_ATTR_RW(fw_crash_buffer);\nstatic DEVICE_ATTR_RO(fw_crash_buffer_size);\nstatic DEVICE_ATTR_RW(fw_crash_state);\nstatic DEVICE_ATTR_RO(page_size);\nstatic DEVICE_ATTR_RO(ldio_outstanding);\nstatic DEVICE_ATTR_RO(fw_cmds_outstanding);\nstatic DEVICE_ATTR_RW(enable_sdev_max_qd);\nstatic DEVICE_ATTR_RO(dump_system_regs);\nstatic DEVICE_ATTR_RO(raid_map_id);\n\nstatic struct device_attribute *megaraid_host_attrs[] = {\n\t&dev_attr_fw_crash_buffer_size,\n\t&dev_attr_fw_crash_buffer,\n\t&dev_attr_fw_crash_state,\n\t&dev_attr_page_size,\n\t&dev_attr_ldio_outstanding,\n\t&dev_attr_fw_cmds_outstanding,\n\t&dev_attr_enable_sdev_max_qd,\n\t&dev_attr_dump_system_regs,\n\t&dev_attr_raid_map_id,\n\tNULL,\n};\n\n/*\n * Scsi host template for megaraid_sas driver\n */\nstatic struct scsi_host_template megasas_template = {\n\n\t.module = THIS_MODULE,\n\t.name = \"Avago SAS based MegaRAID driver\",\n\t.proc_name = \"megaraid_sas\",\n\t.slave_configure = megasas_slave_configure,\n\t.slave_alloc = megasas_slave_alloc,\n\t.slave_destroy = megasas_slave_destroy,\n\t.queuecommand = megasas_queue_command,\n\t.eh_target_reset_handler = megasas_reset_target,\n\t.eh_abort_handler = megasas_task_abort,\n\t.eh_host_reset_handler = megasas_reset_bus_host,\n\t.eh_timed_out = megasas_reset_timer,\n\t.shost_attrs = megaraid_host_attrs,\n\t.bios_param = megasas_bios_param,\n\t.map_queues = megasas_map_queues,\n\t.change_queue_depth = scsi_change_queue_depth,\n\t.max_segment_size = 0xffffffff,\n};\n\n/**\n * megasas_complete_int_cmd -\tCompletes an internal command\n * @instance:\t\t\tAdapter soft state\n * @cmd:\t\t\tCommand to be completed\n *\n * The megasas_issue_blocked_cmd() function waits for a command to complete\n * after it issues a command. This function wakes up that waiting routine by\n * calling wake_up() on the wait queue.\n */\nstatic void\nmegasas_complete_int_cmd(struct megasas_instance *instance,\n\t\t\t struct megasas_cmd *cmd)\n{\n\tif (cmd->cmd_status_drv == DCMD_INIT)\n\t\tcmd->cmd_status_drv =\n\t\t(cmd->frame->io.cmd_status == MFI_STAT_OK) ?\n\t\tDCMD_SUCCESS : DCMD_FAILED;\n\n\twake_up(&instance->int_cmd_wait_q);\n}\n\n/**\n * megasas_complete_abort -\tCompletes aborting a command\n * @instance:\t\t\tAdapter soft state\n * @cmd:\t\t\tCmd that was issued to abort another cmd\n *\n * The megasas_issue_blocked_abort_cmd() function waits on abort_cmd_wait_q\n * after it issues an abort on a previously issued command. This function\n * wakes up all functions waiting on the same wait queue.\n */\nstatic void\nmegasas_complete_abort(struct megasas_instance *instance,\n\t\t       struct megasas_cmd *cmd)\n{\n\tif (cmd->sync_cmd) {\n\t\tcmd->sync_cmd = 0;\n\t\tcmd->cmd_status_drv = DCMD_SUCCESS;\n\t\twake_up(&instance->abort_cmd_wait_q);\n\t}\n}\n\n/**\n * megasas_complete_cmd -\tCompletes a command\n * @instance:\t\t\tAdapter soft state\n * @cmd:\t\t\tCommand to be completed\n * @alt_status:\t\t\tIf non-zero, use this value as status to\n *\t\t\t\tSCSI mid-layer instead of the value returned\n *\t\t\t\tby the FW. This should be used if caller wants\n *\t\t\t\tan alternate status (as in the case of aborted\n *\t\t\t\tcommands)\n */\nvoid\nmegasas_complete_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd,\n\t\t     u8 alt_status)\n{\n\tint exception = 0;\n\tstruct megasas_header *hdr = &cmd->frame->hdr;\n\tunsigned long flags;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\tu32 opcode, status;\n\n\t/* flag for the retry reset */\n\tcmd->retry_for_fw_reset = 0;\n\n\tif (cmd->scmd)\n\t\tcmd->scmd->SCp.ptr = NULL;\n\n\tswitch (hdr->cmd) {\n\tcase MFI_CMD_INVALID:\n\t\t/* Some older 1068 controller FW may keep a pended\n\t\t   MR_DCMD_CTRL_EVENT_GET_INFO left over from the main kernel\n\t\t   when booting the kdump kernel.  Ignore this command to\n\t\t   prevent a kernel panic on shutdown of the kdump kernel. */\n\t\tdev_warn(&instance->pdev->dev, \"MFI_CMD_INVALID command \"\n\t\t       \"completed\\n\");\n\t\tdev_warn(&instance->pdev->dev, \"If you have a controller \"\n\t\t       \"other than PERC5, please upgrade your firmware\\n\");\n\t\tbreak;\n\tcase MFI_CMD_PD_SCSI_IO:\n\tcase MFI_CMD_LD_SCSI_IO:\n\n\t\t/*\n\t\t * MFI_CMD_PD_SCSI_IO and MFI_CMD_LD_SCSI_IO could have been\n\t\t * issued either through an IO path or an IOCTL path. If it\n\t\t * was via IOCTL, we will send it to internal completion.\n\t\t */\n\t\tif (cmd->sync_cmd) {\n\t\t\tcmd->sync_cmd = 0;\n\t\t\tmegasas_complete_int_cmd(instance, cmd);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\n\tcase MFI_CMD_LD_READ:\n\tcase MFI_CMD_LD_WRITE:\n\n\t\tif (alt_status) {\n\t\t\tcmd->scmd->result = alt_status << 16;\n\t\t\texception = 1;\n\t\t}\n\n\t\tif (exception) {\n\n\t\t\tatomic_dec(&instance->fw_outstanding);\n\n\t\t\tscsi_dma_unmap(cmd->scmd);\n\t\t\tcmd->scmd->scsi_done(cmd->scmd);\n\t\t\tmegasas_return_cmd(instance, cmd);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (hdr->cmd_status) {\n\n\t\tcase MFI_STAT_OK:\n\t\t\tcmd->scmd->result = DID_OK << 16;\n\t\t\tbreak;\n\n\t\tcase MFI_STAT_SCSI_IO_FAILED:\n\t\tcase MFI_STAT_LD_INIT_IN_PROGRESS:\n\t\t\tcmd->scmd->result =\n\t\t\t    (DID_ERROR << 16) | hdr->scsi_status;\n\t\t\tbreak;\n\n\t\tcase MFI_STAT_SCSI_DONE_WITH_ERROR:\n\n\t\t\tcmd->scmd->result = (DID_OK << 16) | hdr->scsi_status;\n\n\t\t\tif (hdr->scsi_status == SAM_STAT_CHECK_CONDITION) {\n\t\t\t\tmemset(cmd->scmd->sense_buffer, 0,\n\t\t\t\t       SCSI_SENSE_BUFFERSIZE);\n\t\t\t\tmemcpy(cmd->scmd->sense_buffer, cmd->sense,\n\t\t\t\t       hdr->sense_len);\n\n\t\t\t\tcmd->scmd->result |= DRIVER_SENSE << 24;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase MFI_STAT_LD_OFFLINE:\n\t\tcase MFI_STAT_DEVICE_NOT_FOUND:\n\t\t\tcmd->scmd->result = DID_BAD_TARGET << 16;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"MFI FW status %#x\\n\",\n\t\t\t       hdr->cmd_status);\n\t\t\tcmd->scmd->result = DID_ERROR << 16;\n\t\t\tbreak;\n\t\t}\n\n\t\tatomic_dec(&instance->fw_outstanding);\n\n\t\tscsi_dma_unmap(cmd->scmd);\n\t\tcmd->scmd->scsi_done(cmd->scmd);\n\t\tmegasas_return_cmd(instance, cmd);\n\n\t\tbreak;\n\n\tcase MFI_CMD_SMP:\n\tcase MFI_CMD_STP:\n\tcase MFI_CMD_NVME:\n\tcase MFI_CMD_TOOLBOX:\n\t\tmegasas_complete_int_cmd(instance, cmd);\n\t\tbreak;\n\n\tcase MFI_CMD_DCMD:\n\t\topcode = le32_to_cpu(cmd->frame->dcmd.opcode);\n\t\t/* Check for LD map update */\n\t\tif ((opcode == MR_DCMD_LD_MAP_GET_INFO)\n\t\t\t&& (cmd->frame->dcmd.mbox.b[1] == 1)) {\n\t\t\tfusion->fast_path_io = 0;\n\t\t\tspin_lock_irqsave(instance->host->host_lock, flags);\n\t\t\tstatus = cmd->frame->hdr.cmd_status;\n\t\t\tinstance->map_update_cmd = NULL;\n\t\t\tif (status != MFI_STAT_OK) {\n\t\t\t\tif (status != MFI_STAT_NOT_FOUND)\n\t\t\t\t\tdev_warn(&instance->pdev->dev, \"map syncfailed, status = 0x%x\\n\",\n\t\t\t\t\t       cmd->frame->hdr.cmd_status);\n\t\t\t\telse {\n\t\t\t\t\tmegasas_return_cmd(instance, cmd);\n\t\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t\tinstance->host->host_lock,\n\t\t\t\t\t\tflags);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmegasas_return_cmd(instance, cmd);\n\n\t\t\t/*\n\t\t\t * Set fast path IO to ZERO.\n\t\t\t * Validate Map will set proper value.\n\t\t\t * Meanwhile all IOs will go as LD IO.\n\t\t\t */\n\t\t\tif (status == MFI_STAT_OK &&\n\t\t\t    (MR_ValidateMapInfo(instance, (instance->map_id + 1)))) {\n\t\t\t\tinstance->map_id++;\n\t\t\t\tfusion->fast_path_io = 1;\n\t\t\t} else {\n\t\t\t\tfusion->fast_path_io = 0;\n\t\t\t}\n\n\t\t\tmegasas_sync_map_info(instance);\n\t\t\tspin_unlock_irqrestore(instance->host->host_lock,\n\t\t\t\t\t       flags);\n\t\t\tbreak;\n\t\t}\n\t\tif (opcode == MR_DCMD_CTRL_EVENT_GET_INFO ||\n\t\t    opcode == MR_DCMD_CTRL_EVENT_GET) {\n\t\t\tspin_lock_irqsave(&poll_aen_lock, flags);\n\t\t\tmegasas_poll_wait_aen = 0;\n\t\t\tspin_unlock_irqrestore(&poll_aen_lock, flags);\n\t\t}\n\n\t\t/* FW has an updated PD sequence */\n\t\tif ((opcode == MR_DCMD_SYSTEM_PD_MAP_GET_INFO) &&\n\t\t\t(cmd->frame->dcmd.mbox.b[0] == 1)) {\n\n\t\t\tspin_lock_irqsave(instance->host->host_lock, flags);\n\t\t\tstatus = cmd->frame->hdr.cmd_status;\n\t\t\tinstance->jbod_seq_cmd = NULL;\n\t\t\tmegasas_return_cmd(instance, cmd);\n\n\t\t\tif (status == MFI_STAT_OK) {\n\t\t\t\tinstance->pd_seq_map_id++;\n\t\t\t\t/* Re-register a pd sync seq num cmd */\n\t\t\t\tif (megasas_sync_pd_seq_num(instance, true))\n\t\t\t\t\tinstance->use_seqnum_jbod_fp = false;\n\t\t\t} else\n\t\t\t\tinstance->use_seqnum_jbod_fp = false;\n\n\t\t\tspin_unlock_irqrestore(instance->host->host_lock, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * See if got an event notification\n\t\t */\n\t\tif (opcode == MR_DCMD_CTRL_EVENT_WAIT)\n\t\t\tmegasas_service_aen(instance, cmd);\n\t\telse\n\t\t\tmegasas_complete_int_cmd(instance, cmd);\n\n\t\tbreak;\n\n\tcase MFI_CMD_ABORT:\n\t\t/*\n\t\t * Cmd issued to abort another cmd returned\n\t\t */\n\t\tmegasas_complete_abort(instance, cmd);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_info(&instance->pdev->dev, \"Unknown command completed! [0x%X]\\n\",\n\t\t       hdr->cmd);\n\t\tmegasas_complete_int_cmd(instance, cmd);\n\t\tbreak;\n\t}\n}\n\n/**\n * megasas_issue_pending_cmds_again -\tissue all pending cmds\n *\t\t\t\t\tin FW again because of the fw reset\n * @instance:\t\t\t\tAdapter soft state\n */\nstatic inline void\nmegasas_issue_pending_cmds_again(struct megasas_instance *instance)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct list_head clist_local;\n\tunion megasas_evt_class_locale class_locale;\n\tunsigned long flags;\n\tu32 seq_num;\n\n\tINIT_LIST_HEAD(&clist_local);\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\tlist_splice_init(&instance->internal_reset_pending_q, &clist_local);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n\n\twhile (!list_empty(&clist_local)) {\n\t\tcmd = list_entry((&clist_local)->next,\n\t\t\t\t\tstruct megasas_cmd, list);\n\t\tlist_del_init(&cmd->list);\n\n\t\tif (cmd->sync_cmd || cmd->scmd) {\n\t\t\tdev_notice(&instance->pdev->dev, \"command %p, %p:%d\"\n\t\t\t\t\"detected to be pending while HBA reset\\n\",\n\t\t\t\t\tcmd, cmd->scmd, cmd->sync_cmd);\n\n\t\t\tcmd->retry_for_fw_reset++;\n\n\t\t\tif (cmd->retry_for_fw_reset == 3) {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"cmd %p, %p:%d\"\n\t\t\t\t\t\"was tried multiple times during reset.\"\n\t\t\t\t\t\"Shutting down the HBA\\n\",\n\t\t\t\t\tcmd, cmd->scmd, cmd->sync_cmd);\n\t\t\t\tinstance->instancet->disable_intr(instance);\n\t\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 1);\n\t\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (cmd->sync_cmd == 1) {\n\t\t\tif (cmd->scmd) {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"unexpected\"\n\t\t\t\t\t\"cmd attached to internal command!\\n\");\n\t\t\t}\n\t\t\tdev_notice(&instance->pdev->dev, \"%p synchronous cmd\"\n\t\t\t\t\t\t\"on the internal reset queue,\"\n\t\t\t\t\t\t\"issue it again.\\n\", cmd);\n\t\t\tcmd->cmd_status_drv = DCMD_INIT;\n\t\t\tinstance->instancet->fire_cmd(instance,\n\t\t\t\t\t\t\tcmd->frame_phys_addr,\n\t\t\t\t\t\t\t0, instance->reg_set);\n\t\t} else if (cmd->scmd) {\n\t\t\tdev_notice(&instance->pdev->dev, \"%p scsi cmd [%02x]\"\n\t\t\t\"detected on the internal queue, issue again.\\n\",\n\t\t\tcmd, cmd->scmd->cmnd[0]);\n\n\t\t\tatomic_inc(&instance->fw_outstanding);\n\t\t\tinstance->instancet->fire_cmd(instance,\n\t\t\t\t\tcmd->frame_phys_addr,\n\t\t\t\t\tcmd->frame_count-1, instance->reg_set);\n\t\t} else {\n\t\t\tdev_notice(&instance->pdev->dev, \"%p unexpected cmd on the\"\n\t\t\t\t\"internal reset defer list while re-issue!!\\n\",\n\t\t\t\tcmd);\n\t\t}\n\t}\n\n\tif (instance->aen_cmd) {\n\t\tdev_notice(&instance->pdev->dev, \"aen_cmd in def process\\n\");\n\t\tmegasas_return_cmd(instance, instance->aen_cmd);\n\n\t\tinstance->aen_cmd = NULL;\n\t}\n\n\t/*\n\t * Initiate AEN (Asynchronous Event Notification)\n\t */\n\tseq_num = instance->last_seq_num;\n\tclass_locale.members.reserved = 0;\n\tclass_locale.members.locale = MR_EVT_LOCALE_ALL;\n\tclass_locale.members.class = MR_EVT_CLASS_DEBUG;\n\n\tmegasas_register_aen(instance, seq_num, class_locale.word);\n}\n\n/*\n * Move the internal reset pending commands to a deferred queue.\n *\n * We move the commands pending at internal reset time to a\n * pending queue. This queue would be flushed after successful\n * completion of the internal reset sequence. if the internal reset\n * did not complete in time, the kernel reset handler would flush\n * these commands.\n */\nstatic void\nmegasas_internal_reset_defer_cmds(struct megasas_instance *instance)\n{\n\tstruct megasas_cmd *cmd;\n\tint i;\n\tu16 max_cmd = instance->max_fw_cmds;\n\tu32 defer_index;\n\tunsigned long flags;\n\n\tdefer_index = 0;\n\tspin_lock_irqsave(&instance->mfi_pool_lock, flags);\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tif (cmd->sync_cmd == 1 || cmd->scmd) {\n\t\t\tdev_notice(&instance->pdev->dev, \"moving cmd[%d]:%p:%d:%p\"\n\t\t\t\t\t\"on the defer queue as internal\\n\",\n\t\t\t\tdefer_index, cmd, cmd->sync_cmd, cmd->scmd);\n\n\t\t\tif (!list_empty(&cmd->list)) {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"ERROR while\"\n\t\t\t\t\t\" moving this cmd:%p, %d %p, it was\"\n\t\t\t\t\t\"discovered on some list?\\n\",\n\t\t\t\t\tcmd, cmd->sync_cmd, cmd->scmd);\n\n\t\t\t\tlist_del_init(&cmd->list);\n\t\t\t}\n\t\t\tdefer_index++;\n\t\t\tlist_add_tail(&cmd->list,\n\t\t\t\t&instance->internal_reset_pending_q);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&instance->mfi_pool_lock, flags);\n}\n\n\nstatic void\nprocess_fw_state_change_wq(struct work_struct *work)\n{\n\tstruct megasas_instance *instance =\n\t\tcontainer_of(work, struct megasas_instance, work_init);\n\tu32 wait;\n\tunsigned long flags;\n\n    if (atomic_read(&instance->adprecovery) != MEGASAS_ADPRESET_SM_INFAULT) {\n\t\tdev_notice(&instance->pdev->dev, \"error, recovery st %x\\n\",\n\t\t\t\tatomic_read(&instance->adprecovery));\n\t\treturn ;\n\t}\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_ADPRESET_SM_INFAULT) {\n\t\tdev_notice(&instance->pdev->dev, \"FW detected to be in fault\"\n\t\t\t\t\t\"state, restarting it...\\n\");\n\n\t\tinstance->instancet->disable_intr(instance);\n\t\tatomic_set(&instance->fw_outstanding, 0);\n\n\t\tatomic_set(&instance->fw_reset_no_pci_access, 1);\n\t\tinstance->instancet->adp_reset(instance, instance->reg_set);\n\t\tatomic_set(&instance->fw_reset_no_pci_access, 0);\n\n\t\tdev_notice(&instance->pdev->dev, \"FW restarted successfully,\"\n\t\t\t\t\t\"initiating next stage...\\n\");\n\n\t\tdev_notice(&instance->pdev->dev, \"HBA recovery state machine,\"\n\t\t\t\t\t\"state 2 starting...\\n\");\n\n\t\t/* waiting for about 20 second before start the second init */\n\t\tfor (wait = 0; wait < 30; wait++) {\n\t\t\tmsleep(1000);\n\t\t}\n\n\t\tif (megasas_transition_to_ready(instance, 1)) {\n\t\t\tdev_notice(&instance->pdev->dev, \"adapter not ready\\n\");\n\n\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 1);\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\treturn ;\n\t\t}\n\n\t\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS1064R) ||\n\t\t\t(instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5) ||\n\t\t\t(instance->pdev->device == PCI_DEVICE_ID_LSI_VERDE_ZCR)\n\t\t\t) {\n\t\t\t*instance->consumer = *instance->producer;\n\t\t} else {\n\t\t\t*instance->consumer = 0;\n\t\t\t*instance->producer = 0;\n\t\t}\n\n\t\tmegasas_issue_init_mfi(instance);\n\n\t\tspin_lock_irqsave(&instance->hba_lock, flags);\n\t\tatomic_set(&instance->adprecovery, MEGASAS_HBA_OPERATIONAL);\n\t\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n\t\tinstance->instancet->enable_intr(instance);\n\n\t\tmegasas_issue_pending_cmds_again(instance);\n\t\tinstance->issuepend_done = 1;\n\t}\n}\n\n/**\n * megasas_deplete_reply_queue -\tProcesses all completed commands\n * @instance:\t\t\t\tAdapter soft state\n * @alt_status:\t\t\t\tAlternate status to be returned to\n *\t\t\t\t\tSCSI mid-layer instead of the status\n *\t\t\t\t\treturned by the FW\n * Note: this must be called with hba lock held\n */\nstatic int\nmegasas_deplete_reply_queue(struct megasas_instance *instance,\n\t\t\t\t\tu8 alt_status)\n{\n\tu32 mfiStatus;\n\tu32 fw_state;\n\n\tif ((mfiStatus = instance->instancet->check_reset(instance,\n\t\t\t\t\tinstance->reg_set)) == 1) {\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tmfiStatus = instance->instancet->clear_intr(instance);\n\tif (mfiStatus == 0) {\n\t\t/* Hardware may not set outbound_intr_status in MSI-X mode */\n\t\tif (!instance->msix_vectors)\n\t\t\treturn IRQ_NONE;\n\t}\n\n\tinstance->mfiStatus = mfiStatus;\n\n\tif ((mfiStatus & MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE)) {\n\t\tfw_state = instance->instancet->read_fw_status_reg(\n\t\t\t\tinstance) & MFI_STATE_MASK;\n\n\t\tif (fw_state != MFI_STATE_FAULT) {\n\t\t\tdev_notice(&instance->pdev->dev, \"fw state:%x\\n\",\n\t\t\t\t\t\tfw_state);\n\t\t}\n\n\t\tif ((fw_state == MFI_STATE_FAULT) &&\n\t\t\t\t(instance->disableOnlineCtrlReset == 0)) {\n\t\t\tdev_notice(&instance->pdev->dev, \"wait adp restart\\n\");\n\n\t\t\tif ((instance->pdev->device ==\n\t\t\t\t\tPCI_DEVICE_ID_LSI_SAS1064R) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\t\tPCI_DEVICE_ID_DELL_PERC5) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\t\tPCI_DEVICE_ID_LSI_VERDE_ZCR)) {\n\n\t\t\t\t*instance->consumer =\n\t\t\t\t\tcpu_to_le32(MEGASAS_ADPRESET_INPROG_SIGN);\n\t\t\t}\n\n\n\t\t\tinstance->instancet->disable_intr(instance);\n\t\t\tatomic_set(&instance->adprecovery, MEGASAS_ADPRESET_SM_INFAULT);\n\t\t\tinstance->issuepend_done = 0;\n\n\t\t\tatomic_set(&instance->fw_outstanding, 0);\n\t\t\tmegasas_internal_reset_defer_cmds(instance);\n\n\t\t\tdev_notice(&instance->pdev->dev, \"fwState=%x, stage:%d\\n\",\n\t\t\t\t\tfw_state, atomic_read(&instance->adprecovery));\n\n\t\t\tschedule_work(&instance->work_init);\n\t\t\treturn IRQ_HANDLED;\n\n\t\t} else {\n\t\t\tdev_notice(&instance->pdev->dev, \"fwstate:%x, dis_OCR=%x\\n\",\n\t\t\t\tfw_state, instance->disableOnlineCtrlReset);\n\t\t}\n\t}\n\n\ttasklet_schedule(&instance->isr_tasklet);\n\treturn IRQ_HANDLED;\n}\n\n/**\n * megasas_isr - isr entry point\n * @irq:\tIRQ number\n * @devp:\tIRQ context address\n */\nstatic irqreturn_t megasas_isr(int irq, void *devp)\n{\n\tstruct megasas_irq_context *irq_context = devp;\n\tstruct megasas_instance *instance = irq_context->instance;\n\tunsigned long flags;\n\tirqreturn_t rc;\n\n\tif (atomic_read(&instance->fw_reset_no_pci_access))\n\t\treturn IRQ_HANDLED;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\trc = megasas_deplete_reply_queue(instance, DID_OK);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n\n\treturn rc;\n}\n\n/**\n * megasas_transition_to_ready -\tMove the FW to READY state\n * @instance:\t\t\t\tAdapter soft state\n * @ocr:\t\t\t\tAdapter reset state\n *\n * During the initialization, FW passes can potentially be in any one of\n * several possible states. If the FW in operational, waiting-for-handshake\n * states, driver must take steps to bring it to ready state. Otherwise, it\n * has to wait for the ready state.\n */\nint\nmegasas_transition_to_ready(struct megasas_instance *instance, int ocr)\n{\n\tint i;\n\tu8 max_wait;\n\tu32 fw_state;\n\tu32 abs_state, curr_abs_state;\n\n\tabs_state = instance->instancet->read_fw_status_reg(instance);\n\tfw_state = abs_state & MFI_STATE_MASK;\n\n\tif (fw_state != MFI_STATE_READY)\n\t\tdev_info(&instance->pdev->dev, \"Waiting for FW to come to ready\"\n\t\t       \" state\\n\");\n\n\twhile (fw_state != MFI_STATE_READY) {\n\n\t\tswitch (fw_state) {\n\n\t\tcase MFI_STATE_FAULT:\n\t\t\tdev_printk(KERN_ERR, &instance->pdev->dev,\n\t\t\t\t   \"FW in FAULT state, Fault code:0x%x subcode:0x%x func:%s\\n\",\n\t\t\t\t   abs_state & MFI_STATE_FAULT_CODE,\n\t\t\t\t   abs_state & MFI_STATE_FAULT_SUBCODE, __func__);\n\t\t\tif (ocr) {\n\t\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"System Register set:\\n\");\n\t\t\t\tmegasas_dump_reg_set(instance->reg_set);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\n\t\tcase MFI_STATE_WAIT_HANDSHAKE:\n\t\t\t/*\n\t\t\t * Set the CLR bit in inbound doorbell\n\t\t\t */\n\t\t\tif ((instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\t PCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\n\t\t\t\t(instance->adapter_type != MFI_SERIES))\n\t\t\t\twritel(\n\t\t\t\t  MFI_INIT_CLEAR_HANDSHAKE|MFI_INIT_HOTPLUG,\n\t\t\t\t  &instance->reg_set->doorbell);\n\t\t\telse\n\t\t\t\twritel(\n\t\t\t\t    MFI_INIT_CLEAR_HANDSHAKE|MFI_INIT_HOTPLUG,\n\t\t\t\t\t&instance->reg_set->inbound_doorbell);\n\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_BOOT_MESSAGE_PENDING:\n\t\t\tif ((instance->pdev->device ==\n\t\t\t     PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\t PCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\n\t\t\t\t(instance->adapter_type != MFI_SERIES))\n\t\t\t\twritel(MFI_INIT_HOTPLUG,\n\t\t\t\t       &instance->reg_set->doorbell);\n\t\t\telse\n\t\t\t\twritel(MFI_INIT_HOTPLUG,\n\t\t\t\t\t&instance->reg_set->inbound_doorbell);\n\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_OPERATIONAL:\n\t\t\t/*\n\t\t\t * Bring it to READY state; assuming max wait 10 secs\n\t\t\t */\n\t\t\tinstance->instancet->disable_intr(instance);\n\t\t\tif ((instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS0071SKINNY)  ||\n\t\t\t\t(instance->adapter_type != MFI_SERIES)) {\n\t\t\t\twritel(MFI_RESET_FLAGS,\n\t\t\t\t\t&instance->reg_set->doorbell);\n\n\t\t\t\tif (instance->adapter_type != MFI_SERIES) {\n\t\t\t\t\tfor (i = 0; i < (10 * 1000); i += 20) {\n\t\t\t\t\t\tif (megasas_readl(\n\t\t\t\t\t\t\t    instance,\n\t\t\t\t\t\t\t    &instance->\n\t\t\t\t\t\t\t    reg_set->\n\t\t\t\t\t\t\t    doorbell) & 1)\n\t\t\t\t\t\t\tmsleep(20);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\twritel(MFI_RESET_FLAGS,\n\t\t\t\t\t&instance->reg_set->inbound_doorbell);\n\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_UNDEFINED:\n\t\t\t/*\n\t\t\t * This state should not last for more than 2 seconds\n\t\t\t */\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_BB_INIT:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_FW_INIT:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_FW_INIT_2:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_DEVICE_SCAN:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_FLUSH_CACHE:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Unknown state 0x%x\\n\",\n\t\t\t       fw_state);\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"System Register set:\\n\");\n\t\t\tmegasas_dump_reg_set(instance->reg_set);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t/*\n\t\t * The cur_state should not last for more than max_wait secs\n\t\t */\n\t\tfor (i = 0; i < max_wait * 50; i++) {\n\t\t\tcurr_abs_state = instance->instancet->\n\t\t\t\tread_fw_status_reg(instance);\n\n\t\t\tif (abs_state == curr_abs_state) {\n\t\t\t\tmsleep(20);\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Return error if fw_state hasn't changed after max_wait\n\t\t */\n\t\tif (curr_abs_state == abs_state) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"FW state [%d] hasn't changed \"\n\t\t\t       \"in %d secs\\n\", fw_state, max_wait);\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"System Register set:\\n\");\n\t\t\tmegasas_dump_reg_set(instance->reg_set);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tabs_state = curr_abs_state;\n\t\tfw_state = curr_abs_state & MFI_STATE_MASK;\n\t}\n\tdev_info(&instance->pdev->dev, \"FW now in Ready state\\n\");\n\n\treturn 0;\n}\n\n/**\n * megasas_teardown_frame_pool -\tDestroy the cmd frame DMA pool\n * @instance:\t\t\t\tAdapter soft state\n */\nstatic void megasas_teardown_frame_pool(struct megasas_instance *instance)\n{\n\tint i;\n\tu16 max_cmd = instance->max_mfi_cmds;\n\tstruct megasas_cmd *cmd;\n\n\tif (!instance->frame_dma_pool)\n\t\treturn;\n\n\t/*\n\t * Return all frames to pool\n\t */\n\tfor (i = 0; i < max_cmd; i++) {\n\n\t\tcmd = instance->cmd_list[i];\n\n\t\tif (cmd->frame)\n\t\t\tdma_pool_free(instance->frame_dma_pool, cmd->frame,\n\t\t\t\t      cmd->frame_phys_addr);\n\n\t\tif (cmd->sense)\n\t\t\tdma_pool_free(instance->sense_dma_pool, cmd->sense,\n\t\t\t\t      cmd->sense_phys_addr);\n\t}\n\n\t/*\n\t * Now destroy the pool itself\n\t */\n\tdma_pool_destroy(instance->frame_dma_pool);\n\tdma_pool_destroy(instance->sense_dma_pool);\n\n\tinstance->frame_dma_pool = NULL;\n\tinstance->sense_dma_pool = NULL;\n}\n\n/**\n * megasas_create_frame_pool -\tCreates DMA pool for cmd frames\n * @instance:\t\t\tAdapter soft state\n *\n * Each command packet has an embedded DMA memory buffer that is used for\n * filling MFI frame and the SG list that immediately follows the frame. This\n * function creates those DMA memory buffers for each command packet by using\n * PCI pool facility.\n */\nstatic int megasas_create_frame_pool(struct megasas_instance *instance)\n{\n\tint i;\n\tu16 max_cmd;\n\tu32 frame_count;\n\tstruct megasas_cmd *cmd;\n\n\tmax_cmd = instance->max_mfi_cmds;\n\n\t/*\n\t * For MFI controllers.\n\t * max_num_sge = 60\n\t * max_sge_sz  = 16 byte (sizeof megasas_sge_skinny)\n\t * Total 960 byte (15 MFI frame of 64 byte)\n\t *\n\t * Fusion adapter require only 3 extra frame.\n\t * max_num_sge = 16 (defined as MAX_IOCTL_SGE)\n\t * max_sge_sz  = 12 byte (sizeof  megasas_sge64)\n\t * Total 192 byte (3 MFI frame of 64 byte)\n\t */\n\tframe_count = (instance->adapter_type == MFI_SERIES) ?\n\t\t\t(15 + 1) : (3 + 1);\n\tinstance->mfi_frame_size = MEGAMFI_FRAME_SIZE * frame_count;\n\t/*\n\t * Use DMA pool facility provided by PCI layer\n\t */\n\tinstance->frame_dma_pool = dma_pool_create(\"megasas frame pool\",\n\t\t\t\t\t&instance->pdev->dev,\n\t\t\t\t\tinstance->mfi_frame_size, 256, 0);\n\n\tif (!instance->frame_dma_pool) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"failed to setup frame pool\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinstance->sense_dma_pool = dma_pool_create(\"megasas sense pool\",\n\t\t\t\t\t\t   &instance->pdev->dev, 128,\n\t\t\t\t\t\t   4, 0);\n\n\tif (!instance->sense_dma_pool) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"failed to setup sense pool\\n\");\n\n\t\tdma_pool_destroy(instance->frame_dma_pool);\n\t\tinstance->frame_dma_pool = NULL;\n\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * Allocate and attach a frame to each of the commands in cmd_list.\n\t * By making cmd->index as the context instead of the &cmd, we can\n\t * always use 32bit context regardless of the architecture\n\t */\n\tfor (i = 0; i < max_cmd; i++) {\n\n\t\tcmd = instance->cmd_list[i];\n\n\t\tcmd->frame = dma_pool_zalloc(instance->frame_dma_pool,\n\t\t\t\t\t    GFP_KERNEL, &cmd->frame_phys_addr);\n\n\t\tcmd->sense = dma_pool_alloc(instance->sense_dma_pool,\n\t\t\t\t\t    GFP_KERNEL, &cmd->sense_phys_addr);\n\n\t\t/*\n\t\t * megasas_teardown_frame_pool() takes care of freeing\n\t\t * whatever has been allocated\n\t\t */\n\t\tif (!cmd->frame || !cmd->sense) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"dma_pool_alloc failed\\n\");\n\t\t\tmegasas_teardown_frame_pool(instance);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcmd->frame->io.context = cpu_to_le32(cmd->index);\n\t\tcmd->frame->io.pad_0 = 0;\n\t\tif ((instance->adapter_type == MFI_SERIES) && reset_devices)\n\t\t\tcmd->frame->hdr.cmd = MFI_CMD_INVALID;\n\t}\n\n\treturn 0;\n}\n\n/**\n * megasas_free_cmds -\tFree all the cmds in the free cmd pool\n * @instance:\t\tAdapter soft state\n */\nvoid megasas_free_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\n\t/* First free the MFI frame pool */\n\tmegasas_teardown_frame_pool(instance);\n\n\t/* Free all the commands in the cmd_list */\n\tfor (i = 0; i < instance->max_mfi_cmds; i++)\n\n\t\tkfree(instance->cmd_list[i]);\n\n\t/* Free the cmd_list buffer itself */\n\tkfree(instance->cmd_list);\n\tinstance->cmd_list = NULL;\n\n\tINIT_LIST_HEAD(&instance->cmd_pool);\n}\n\n/**\n * megasas_alloc_cmds -\tAllocates the command packets\n * @instance:\t\tAdapter soft state\n *\n * Each command that is issued to the FW, whether IO commands from the OS or\n * internal commands like IOCTLs, are wrapped in local data structure called\n * megasas_cmd. The frame embedded in this megasas_cmd is actually issued to\n * the FW.\n *\n * Each frame has a 32-bit field called context (tag). This context is used\n * to get back the megasas_cmd from the frame when a frame gets completed in\n * the ISR. Typically the address of the megasas_cmd itself would be used as\n * the context. But we wanted to keep the differences between 32 and 64 bit\n * systems to the mininum. We always use 32 bit integers for the context. In\n * this driver, the 32 bit values are the indices into an array cmd_list.\n * This array is used only to look up the megasas_cmd given the context. The\n * free commands themselves are maintained in a linked list called cmd_pool.\n */\nint megasas_alloc_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\tint j;\n\tu16 max_cmd;\n\tstruct megasas_cmd *cmd;\n\n\tmax_cmd = instance->max_mfi_cmds;\n\n\t/*\n\t * instance->cmd_list is an array of struct megasas_cmd pointers.\n\t * Allocate the dynamic array first and then allocate individual\n\t * commands.\n\t */\n\tinstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\n\n\tif (!instance->cmd_list) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tinstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\n\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!instance->cmd_list[i]) {\n\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tkfree(instance->cmd_list[j]);\n\n\t\t\tkfree(instance->cmd_list);\n\t\t\tinstance->cmd_list = NULL;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tmemset(cmd, 0, sizeof(struct megasas_cmd));\n\t\tcmd->index = i;\n\t\tcmd->scmd = NULL;\n\t\tcmd->instance = instance;\n\n\t\tlist_add_tail(&cmd->list, &instance->cmd_pool);\n\t}\n\n\t/*\n\t * Create a frame pool and assign one frame to each cmd\n\t */\n\tif (megasas_create_frame_pool(instance)) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\n\t\tmegasas_free_cmds(instance);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n/*\n * dcmd_timeout_ocr_possible -\tCheck if OCR is possible based on Driver/FW state.\n * @instance:\t\t\t\tAdapter soft state\n *\n * Return 0 for only Fusion adapter, if driver load/unload is not in progress\n * or FW is not under OCR.\n */\ninline int\ndcmd_timeout_ocr_possible(struct megasas_instance *instance) {\n\n\tif (instance->adapter_type == MFI_SERIES)\n\t\treturn KILL_ADAPTER;\n\telse if (instance->unload ||\n\t\t\ttest_bit(MEGASAS_FUSION_OCR_NOT_POSSIBLE,\n\t\t\t\t &instance->reset_flags))\n\t\treturn IGNORE_TIMEOUT;\n\telse\n\t\treturn INITIATE_OCR;\n}\n\nstatic void\nmegasas_get_pd_info(struct megasas_instance *instance, struct scsi_device *sdev)\n{\n\tint ret;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\tu16 device_id = 0;\n\n\tdevice_id = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) + sdev->id;\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_err(&instance->pdev->dev, \"Failed to get cmd %s\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(instance->pd_info, 0, sizeof(*instance->pd_info));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.s[0] = cpu_to_le16(device_id);\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0xFF;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_PD_INFO));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_PD_GET_INFO);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->pd_info_h,\n\t\t\t\t sizeof(struct MR_PD_INFO));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tswitch (ret) {\n\tcase DCMD_SUCCESS:\n\t\tmr_device_priv_data = sdev->hostdata;\n\t\tle16_to_cpus((u16 *)&instance->pd_info->state.ddf.pdType);\n\t\tmr_device_priv_data->interface_type =\n\t\t\t\tinstance->pd_info->state.ddf.pdType.intf;\n\t\tbreak;\n\n\tcase DCMD_TIMEOUT:\n\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn;\n}\n/*\n * megasas_get_pd_list_info -\tReturns FW's pd_list structure\n * @instance:\t\t\t\tAdapter soft state\n * @pd_list:\t\t\t\tpd_list structure\n *\n * Issues an internal command (DCMD) to get the FW's controller PD\n * list structure.  This information is mainly used to find out SYSTEM\n * supported by the FW.\n */\nstatic int\nmegasas_get_pd_list(struct megasas_instance *instance)\n{\n\tint ret = 0, pd_index = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_PD_LIST *ci;\n\tstruct MR_PD_ADDRESS *pd_addr;\n\n\tif (instance->pd_list_not_supported) {\n\t\tdev_info(&instance->pdev->dev, \"MR_DCMD_PD_LIST_QUERY \"\n\t\t\"not supported by firmware\\n\");\n\t\treturn ret;\n\t}\n\n\tci = instance->pd_list_buf;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"(get_pd_list): Failed to get cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.b[0] = MR_PD_QUERY_TYPE_EXPOSED_TO_HOST;\n\tdcmd->mbox.b[1] = 0;\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_PD_LIST_QUERY);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->pd_list_buf_h,\n\t\t\t\t (MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST)));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\tMFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tswitch (ret) {\n\tcase DCMD_FAILED:\n\t\tdev_info(&instance->pdev->dev, \"MR_DCMD_PD_LIST_QUERY \"\n\t\t\t\"failed/not supported by firmware\\n\");\n\n\t\tif (instance->adapter_type != MFI_SERIES)\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\telse\n\t\t\tinstance->pd_list_not_supported = 1;\n\t\tbreak;\n\tcase DCMD_TIMEOUT:\n\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\t/*\n\t\t\t * DCMD failed from AEN path.\n\t\t\t * AEN path already hold reset_mutex to avoid PCI access\n\t\t\t * while OCR is in progress.\n\t\t\t */\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d \\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase DCMD_SUCCESS:\n\t\tpd_addr = ci->addr;\n\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\tdev_info(&instance->pdev->dev, \"%s, sysPD count: 0x%x\\n\",\n\t\t\t\t __func__, le32_to_cpu(ci->count));\n\n\t\tif ((le32_to_cpu(ci->count) >\n\t\t\t(MEGASAS_MAX_PD_CHANNELS * MEGASAS_MAX_DEV_PER_CHANNEL)))\n\t\t\tbreak;\n\n\t\tmemset(instance->local_pd_list, 0,\n\t\t\t\tMEGASAS_MAX_PD * sizeof(struct megasas_pd_list));\n\n\t\tfor (pd_index = 0; pd_index < le32_to_cpu(ci->count); pd_index++) {\n\t\t\tinstance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].tid\t=\n\t\t\t\t\tle16_to_cpu(pd_addr->deviceId);\n\t\t\tinstance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].driveType\t=\n\t\t\t\t\tpd_addr->scsiDevType;\n\t\t\tinstance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].driveState\t=\n\t\t\t\t\tMR_PD_STATE_SYSTEM;\n\t\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\t \"PD%d: targetID: 0x%03x deviceType:0x%x\\n\",\n\t\t\t\t\t pd_index, le16_to_cpu(pd_addr->deviceId),\n\t\t\t\t\t pd_addr->scsiDevType);\n\t\t\tpd_addr++;\n\t\t}\n\n\t\tmemcpy(instance->pd_list, instance->local_pd_list,\n\t\t\tsizeof(instance->pd_list));\n\t\tbreak;\n\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/*\n * megasas_get_ld_list_info -\tReturns FW's ld_list structure\n * @instance:\t\t\t\tAdapter soft state\n * @ld_list:\t\t\t\tld_list structure\n *\n * Issues an internal command (DCMD) to get the FW's controller PD\n * list structure.  This information is mainly used to find out SYSTEM\n * supported by the FW.\n */\nstatic int\nmegasas_get_ld_list(struct megasas_instance *instance)\n{\n\tint ret = 0, ld_index = 0, ids = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_LD_LIST *ci;\n\tdma_addr_t ci_h = 0;\n\tu32 ld_count;\n\n\tci = instance->ld_list_buf;\n\tci_h = instance->ld_list_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"megasas_get_ld_list: Failed to get cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tif (instance->supportmax256vd)\n\t\tdcmd->mbox.b[0] = 1;\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_LD_LIST));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_GET_LIST);\n\tdcmd->pad_0  = 0;\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h,\n\t\t\t\t sizeof(struct MR_LD_LIST));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\tMFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tld_count = le32_to_cpu(ci->ldCount);\n\n\tswitch (ret) {\n\tcase DCMD_FAILED:\n\t\tmegaraid_sas_kill_hba(instance);\n\t\tbreak;\n\tcase DCMD_TIMEOUT:\n\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\t/*\n\t\t\t * DCMD failed from AEN path.\n\t\t\t * AEN path already hold reset_mutex to avoid PCI access\n\t\t\t * while OCR is in progress.\n\t\t\t */\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase DCMD_SUCCESS:\n\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\tdev_info(&instance->pdev->dev, \"%s, LD count: 0x%x\\n\",\n\t\t\t\t __func__, ld_count);\n\n\t\tif (ld_count > instance->fw_supported_vd_count)\n\t\t\tbreak;\n\n\t\tmemset(instance->ld_ids, 0xff, MAX_LOGICAL_DRIVES_EXT);\n\n\t\tfor (ld_index = 0; ld_index < ld_count; ld_index++) {\n\t\t\tif (ci->ldList[ld_index].state != 0) {\n\t\t\t\tids = ci->ldList[ld_index].ref.targetId;\n\t\t\t\tinstance->ld_ids[ids] = ci->ldList[ld_index].ref.targetId;\n\t\t\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\t\t \"LD%d: targetID: 0x%03x\\n\",\n\t\t\t\t\t\t ld_index, ids);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/**\n * megasas_ld_list_query -\tReturns FW's ld_list structure\n * @instance:\t\t\t\tAdapter soft state\n * @query_type:\t\t\t\tld_list structure type\n *\n * Issues an internal command (DCMD) to get the FW's controller PD\n * list structure.  This information is mainly used to find out SYSTEM\n * supported by the FW.\n */\nstatic int\nmegasas_ld_list_query(struct megasas_instance *instance, u8 query_type)\n{\n\tint ret = 0, ld_index = 0, ids = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_LD_TARGETID_LIST *ci;\n\tdma_addr_t ci_h = 0;\n\tu32 tgtid_count;\n\n\tci = instance->ld_targetid_list_buf;\n\tci_h = instance->ld_targetid_list_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_warn(&instance->pdev->dev,\n\t\t         \"megasas_ld_list_query: Failed to get cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.b[0] = query_type;\n\tif (instance->supportmax256vd)\n\t\tdcmd->mbox.b[2] = 1;\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_LD_TARGETID_LIST));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_LIST_QUERY);\n\tdcmd->pad_0  = 0;\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h,\n\t\t\t\t sizeof(struct MR_LD_TARGETID_LIST));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tswitch (ret) {\n\tcase DCMD_FAILED:\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t\"DCMD not supported by firmware - %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\tret = megasas_get_ld_list(instance);\n\t\tbreak;\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\t/*\n\t\t\t * DCMD failed from AEN path.\n\t\t\t * AEN path already hold reset_mutex to avoid PCI access\n\t\t\t * while OCR is in progress.\n\t\t\t */\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tcase DCMD_SUCCESS:\n\t\ttgtid_count = le32_to_cpu(ci->count);\n\n\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\tdev_info(&instance->pdev->dev, \"%s, LD count: 0x%x\\n\",\n\t\t\t\t __func__, tgtid_count);\n\n\t\tif ((tgtid_count > (instance->fw_supported_vd_count)))\n\t\t\tbreak;\n\n\t\tmemset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);\n\t\tfor (ld_index = 0; ld_index < tgtid_count; ld_index++) {\n\t\t\tids = ci->targetId[ld_index];\n\t\t\tinstance->ld_ids[ids] = ci->targetId[ld_index];\n\t\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\t\tdev_info(&instance->pdev->dev, \"LD%d: targetID: 0x%03x\\n\",\n\t\t\t\t\t ld_index, ci->targetId[ld_index]);\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/**\n * dcmd.opcode            - MR_DCMD_CTRL_DEVICE_LIST_GET\n * dcmd.mbox              - reserved\n * dcmd.sge IN            - ptr to return MR_HOST_DEVICE_LIST structure\n * Desc:    This DCMD will return the combined device list\n * Status:  MFI_STAT_OK - List returned successfully\n *          MFI_STAT_INVALID_CMD - Firmware support for the feature has been\n *                                 disabled\n * @instance:\t\t\tAdapter soft state\n * @is_probe:\t\t\tDriver probe check\n * Return:\t\t\t0 if DCMD succeeded\n *\t\t\t\t non-zero if failed\n */\nstatic int\nmegasas_host_device_list_query(struct megasas_instance *instance,\n\t\t\t       bool is_probe)\n{\n\tint ret, i, target_id;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_HOST_DEVICE_LIST *ci;\n\tu32 count;\n\tdma_addr_t ci_h;\n\n\tci = instance->host_device_list_buf;\n\tci_h = instance->host_device_list_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_warn(&instance->pdev->dev,\n\t\t\t \"%s: failed to get cmd\\n\",\n\t\t\t __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.b[0] = is_probe ? 0 : 1;\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(HOST_DEVICE_LIST_SZ);\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_DEVICE_LIST_GET);\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h, HOST_DEVICE_LIST_SZ);\n\n\tif (!instance->mask_interrupts) {\n\t\tret = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_SECS);\n\t} else {\n\t\tret = megasas_issue_polled(instance, cmd);\n\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t}\n\n\tswitch (ret) {\n\tcase DCMD_SUCCESS:\n\t\t/* Fill the internal pd_list and ld_ids array based on\n\t\t * targetIds returned by FW\n\t\t */\n\t\tcount = le32_to_cpu(ci->count);\n\n\t\tif (count > (MEGASAS_MAX_PD + MAX_LOGICAL_DRIVES_EXT))\n\t\t\tbreak;\n\n\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\tdev_info(&instance->pdev->dev, \"%s, Device count: 0x%x\\n\",\n\t\t\t\t __func__, count);\n\n\t\tmemset(instance->local_pd_list, 0,\n\t\t       MEGASAS_MAX_PD * sizeof(struct megasas_pd_list));\n\t\tmemset(instance->ld_ids, 0xff, MAX_LOGICAL_DRIVES_EXT);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\ttarget_id = le16_to_cpu(ci->host_device_list[i].target_id);\n\t\t\tif (ci->host_device_list[i].flags.u.bits.is_sys_pd) {\n\t\t\t\tinstance->local_pd_list[target_id].tid = target_id;\n\t\t\t\tinstance->local_pd_list[target_id].driveType =\n\t\t\t\t\t\tci->host_device_list[i].scsi_type;\n\t\t\t\tinstance->local_pd_list[target_id].driveState =\n\t\t\t\t\t\tMR_PD_STATE_SYSTEM;\n\t\t\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\t\t \"Device %d: PD targetID: 0x%03x deviceType:0x%x\\n\",\n\t\t\t\t\t\t i, target_id, ci->host_device_list[i].scsi_type);\n\t\t\t} else {\n\t\t\t\tinstance->ld_ids[target_id] = target_id;\n\t\t\t\tif (megasas_dbg_lvl & LD_PD_DEBUG)\n\t\t\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\t\t \"Device %d: LD targetID: 0x%03x\\n\",\n\t\t\t\t\t\t i, target_id);\n\t\t\t}\n\t\t}\n\n\t\tmemcpy(instance->pd_list, instance->local_pd_list,\n\t\t       sizeof(instance->pd_list));\n\t\tbreak;\n\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t __func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DCMD_FAILED:\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"%s: MR_DCMD_CTRL_DEVICE_LIST_GET failed\\n\",\n\t\t\t__func__);\n\t\tbreak;\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/*\n * megasas_update_ext_vd_details : Update details w.r.t Extended VD\n * instance\t\t\t : Controller's instance\n*/\nstatic void megasas_update_ext_vd_details(struct megasas_instance *instance)\n{\n\tstruct fusion_context *fusion;\n\tu32 ventura_map_sz = 0;\n\n\tfusion = instance->ctrl_context;\n\t/* For MFI based controllers return dummy success */\n\tif (!fusion)\n\t\treturn;\n\n\tinstance->supportmax256vd =\n\t\tinstance->ctrl_info_buf->adapterOperations3.supportMaxExtLDs;\n\t/* Below is additional check to address future FW enhancement */\n\tif (instance->ctrl_info_buf->max_lds > 64)\n\t\tinstance->supportmax256vd = 1;\n\n\tinstance->drv_supported_vd_count = MEGASAS_MAX_LD_CHANNELS\n\t\t\t\t\t* MEGASAS_MAX_DEV_PER_CHANNEL;\n\tinstance->drv_supported_pd_count = MEGASAS_MAX_PD_CHANNELS\n\t\t\t\t\t* MEGASAS_MAX_DEV_PER_CHANNEL;\n\tif (instance->supportmax256vd) {\n\t\tinstance->fw_supported_vd_count = MAX_LOGICAL_DRIVES_EXT;\n\t\tinstance->fw_supported_pd_count = MAX_PHYSICAL_DEVICES;\n\t} else {\n\t\tinstance->fw_supported_vd_count = MAX_LOGICAL_DRIVES;\n\t\tinstance->fw_supported_pd_count = MAX_PHYSICAL_DEVICES;\n\t}\n\n\tdev_info(&instance->pdev->dev,\n\t\t\"FW provided supportMaxExtLDs: %d\\tmax_lds: %d\\n\",\n\t\tinstance->ctrl_info_buf->adapterOperations3.supportMaxExtLDs ? 1 : 0,\n\t\tinstance->ctrl_info_buf->max_lds);\n\n\tif (instance->max_raid_mapsize) {\n\t\tventura_map_sz = instance->max_raid_mapsize *\n\t\t\t\t\t\tMR_MIN_MAP_SIZE; /* 64k */\n\t\tfusion->current_map_sz = ventura_map_sz;\n\t\tfusion->max_map_sz = ventura_map_sz;\n\t} else {\n\t\tfusion->old_map_sz =  sizeof(struct MR_FW_RAID_MAP) +\n\t\t\t\t\t(sizeof(struct MR_LD_SPAN_MAP) *\n\t\t\t\t\t(instance->fw_supported_vd_count - 1));\n\t\tfusion->new_map_sz =  sizeof(struct MR_FW_RAID_MAP_EXT);\n\n\t\tfusion->max_map_sz =\n\t\t\tmax(fusion->old_map_sz, fusion->new_map_sz);\n\n\t\tif (instance->supportmax256vd)\n\t\t\tfusion->current_map_sz = fusion->new_map_sz;\n\t\telse\n\t\t\tfusion->current_map_sz = fusion->old_map_sz;\n\t}\n\t/* irrespective of FW raid maps, driver raid map is constant */\n\tfusion->drv_map_sz = sizeof(struct MR_DRV_RAID_MAP_ALL);\n}\n\n/*\n * dcmd.opcode                - MR_DCMD_CTRL_SNAPDUMP_GET_PROPERTIES\n * dcmd.hdr.length            - number of bytes to read\n * dcmd.sge                   - Ptr to MR_SNAPDUMP_PROPERTIES\n * Desc:\t\t\t Fill in snapdump properties\n * Status:\t\t\t MFI_STAT_OK- Command successful\n */\nvoid megasas_get_snapdump_properties(struct megasas_instance *instance)\n{\n\tint ret = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_SNAPDUMP_PROPERTIES *ci;\n\tdma_addr_t ci_h = 0;\n\n\tci = instance->snapdump_prop;\n\tci_h = instance->snapdump_prop_h;\n\n\tif (!ci)\n\t\treturn;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_dbg(&instance->pdev->dev, \"Failed to get a free cmd\\n\");\n\t\treturn;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_SNAPDUMP_PROPERTIES));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_SNAPDUMP_GET_PROPERTIES);\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h,\n\t\t\t\t sizeof(struct MR_SNAPDUMP_PROPERTIES));\n\n\tif (!instance->mask_interrupts) {\n\t\tret = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_SECS);\n\t} else {\n\t\tret = megasas_issue_polled(instance, cmd);\n\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t}\n\n\tswitch (ret) {\n\tcase DCMD_SUCCESS:\n\t\tinstance->snapdump_wait_time =\n\t\t\tmin_t(u8, ci->trigger_min_num_sec_before_ocr,\n\t\t\t\tMEGASAS_MAX_SNAP_DUMP_WAIT_TIME);\n\t\tbreak;\n\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n}\n\n/**\n * megasas_get_controller_info -\tReturns FW's controller structure\n * @instance:\t\t\t\tAdapter soft state\n *\n * Issues an internal command (DCMD) to get the FW's controller structure.\n * This information is mainly used to find out the maximum IO transfer per\n * command supported by the FW.\n */\nint\nmegasas_get_ctrl_info(struct megasas_instance *instance)\n{\n\tint ret = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct megasas_ctrl_info *ci;\n\tdma_addr_t ci_h = 0;\n\n\tci = instance->ctrl_info_buf;\n\tci_h = instance->ctrl_info_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to get a free cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct megasas_ctrl_info));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_GET_INFO);\n\tdcmd->mbox.b[0] = 1;\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h,\n\t\t\t\t sizeof(struct megasas_ctrl_info));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts) {\n\t\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\t} else {\n\t\tret = megasas_issue_polled(instance, cmd);\n\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t}\n\n\tswitch (ret) {\n\tcase DCMD_SUCCESS:\n\t\t/* Save required controller information in\n\t\t * CPU endianness format.\n\t\t */\n\t\tle32_to_cpus((u32 *)&ci->properties.OnOffProperties);\n\t\tle16_to_cpus((u16 *)&ci->properties.on_off_properties2);\n\t\tle32_to_cpus((u32 *)&ci->adapterOperations2);\n\t\tle32_to_cpus((u32 *)&ci->adapterOperations3);\n\t\tle16_to_cpus((u16 *)&ci->adapter_operations4);\n\t\tle32_to_cpus((u32 *)&ci->adapter_operations5);\n\n\t\t/* Update the latest Ext VD info.\n\t\t * From Init path, store current firmware details.\n\t\t * From OCR path, detect any firmware properties changes.\n\t\t * in case of Firmware upgrade without system reboot.\n\t\t */\n\t\tmegasas_update_ext_vd_details(instance);\n\t\tinstance->support_seqnum_jbod_fp =\n\t\t\tci->adapterOperations3.useSeqNumJbodFP;\n\t\tinstance->support_morethan256jbod =\n\t\t\tci->adapter_operations4.support_pd_map_target_id;\n\t\tinstance->support_nvme_passthru =\n\t\t\tci->adapter_operations4.support_nvme_passthru;\n\t\tinstance->support_pci_lane_margining =\n\t\t\tci->adapter_operations5.support_pci_lane_margining;\n\t\tinstance->task_abort_tmo = ci->TaskAbortTO;\n\t\tinstance->max_reset_tmo = ci->MaxResetTO;\n\n\t\t/*Check whether controller is iMR or MR */\n\t\tinstance->is_imr = (ci->memory_size ? 0 : 1);\n\n\t\tinstance->snapdump_wait_time =\n\t\t\t(ci->properties.on_off_properties2.enable_snap_dump ?\n\t\t\t MEGASAS_DEFAULT_SNAP_DUMP_WAIT_TIME : 0);\n\n\t\tinstance->enable_fw_dev_list =\n\t\t\tci->properties.on_off_properties2.enable_fw_dev_list;\n\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t\"controller type\\t: %s(%dMB)\\n\",\n\t\t\tinstance->is_imr ? \"iMR\" : \"MR\",\n\t\t\tle16_to_cpu(ci->memory_size));\n\n\t\tinstance->disableOnlineCtrlReset =\n\t\t\tci->properties.OnOffProperties.disableOnlineCtrlReset;\n\t\tinstance->secure_jbod_support =\n\t\t\tci->adapterOperations3.supportSecurityonJBOD;\n\t\tdev_info(&instance->pdev->dev, \"Online Controller Reset(OCR)\\t: %s\\n\",\n\t\t\tinstance->disableOnlineCtrlReset ? \"Disabled\" : \"Enabled\");\n\t\tdev_info(&instance->pdev->dev, \"Secure JBOD support\\t: %s\\n\",\n\t\t\tinstance->secure_jbod_support ? \"Yes\" : \"No\");\n\t\tdev_info(&instance->pdev->dev, \"NVMe passthru support\\t: %s\\n\",\n\t\t\t instance->support_nvme_passthru ? \"Yes\" : \"No\");\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"FW provided TM TaskAbort/Reset timeout\\t: %d secs/%d secs\\n\",\n\t\t\t instance->task_abort_tmo, instance->max_reset_tmo);\n\t\tdev_info(&instance->pdev->dev, \"JBOD sequence map support\\t: %s\\n\",\n\t\t\t instance->support_seqnum_jbod_fp ? \"Yes\" : \"No\");\n\t\tdev_info(&instance->pdev->dev, \"PCI Lane Margining support\\t: %s\\n\",\n\t\t\t instance->support_pci_lane_margining ? \"Yes\" : \"No\");\n\n\t\tbreak;\n\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DCMD_FAILED:\n\t\tmegaraid_sas_kill_hba(instance);\n\t\tbreak;\n\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/*\n * megasas_set_crash_dump_params -\tSends address of crash dump DMA buffer\n *\t\t\t\t\tto firmware\n *\n * @instance:\t\t\t\tAdapter soft state\n * @crash_buf_state\t\t-\ttell FW to turn ON/OFF crash dump feature\n\t\t\t\t\tMR_CRASH_BUF_TURN_OFF = 0\n\t\t\t\t\tMR_CRASH_BUF_TURN_ON = 1\n * @return 0 on success non-zero on failure.\n * Issues an internal command (DCMD) to set parameters for crash dump feature.\n * Driver will send address of crash dump DMA buffer and set mbox to tell FW\n * that driver supports crash dump feature. This DCMD will be sent only if\n * crash dump feature is supported by the FW.\n *\n */\nint megasas_set_crash_dump_params(struct megasas_instance *instance,\n\tu8 crash_buf_state)\n{\n\tint ret = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_err(&instance->pdev->dev, \"Failed to get a free cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\tdcmd->mbox.b[0] = crash_buf_state;\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_NONE;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(CRASH_DMA_BUF_SIZE);\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_SET_CRASH_DUMP_PARAMS);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->crash_dump_h,\n\t\t\t\t CRASH_DMA_BUF_SIZE);\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tif (ret == DCMD_TIMEOUT) {\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/**\n * megasas_issue_init_mfi -\tInitializes the FW\n * @instance:\t\tAdapter soft state\n *\n * Issues the INIT MFI cmd\n */\nstatic int\nmegasas_issue_init_mfi(struct megasas_instance *instance)\n{\n\t__le32 context;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_init_frame *init_frame;\n\tstruct megasas_init_queue_info *initq_info;\n\tdma_addr_t init_frame_h;\n\tdma_addr_t initq_info_h;\n\n\t/*\n\t * Prepare a init frame. Note the init frame points to queue info\n\t * structure. Each frame has SGL allocated after first 64 bytes. For\n\t * this frame - since we don't need any SGL - we use SGL's space as\n\t * queue info structure\n\t *\n\t * We will not get a NULL command below. We just created the pool.\n\t */\n\tcmd = megasas_get_cmd(instance);\n\n\tinit_frame = (struct megasas_init_frame *)cmd->frame;\n\tinitq_info = (struct megasas_init_queue_info *)\n\t\t((unsigned long)init_frame + 64);\n\n\tinit_frame_h = cmd->frame_phys_addr;\n\tinitq_info_h = init_frame_h + 64;\n\n\tcontext = init_frame->context;\n\tmemset(init_frame, 0, MEGAMFI_FRAME_SIZE);\n\tmemset(initq_info, 0, sizeof(struct megasas_init_queue_info));\n\tinit_frame->context = context;\n\n\tinitq_info->reply_queue_entries = cpu_to_le32(instance->max_fw_cmds + 1);\n\tinitq_info->reply_queue_start_phys_addr_lo = cpu_to_le32(instance->reply_queue_h);\n\n\tinitq_info->producer_index_phys_addr_lo = cpu_to_le32(instance->producer_h);\n\tinitq_info->consumer_index_phys_addr_lo = cpu_to_le32(instance->consumer_h);\n\n\tinit_frame->cmd = MFI_CMD_INIT;\n\tinit_frame->cmd_status = MFI_STAT_INVALID_STATUS;\n\tinit_frame->queue_info_new_phys_addr_lo =\n\t\tcpu_to_le32(lower_32_bits(initq_info_h));\n\tinit_frame->queue_info_new_phys_addr_hi =\n\t\tcpu_to_le32(upper_32_bits(initq_info_h));\n\n\tinit_frame->data_xfer_len = cpu_to_le32(sizeof(struct megasas_init_queue_info));\n\n\t/*\n\t * disable the intr before firing the init frame to FW\n\t */\n\tinstance->instancet->disable_intr(instance);\n\n\t/*\n\t * Issue the init frame in polled mode\n\t */\n\n\tif (megasas_issue_polled(instance, cmd)) {\n\t\tdev_err(&instance->pdev->dev, \"Failed to init firmware\\n\");\n\t\tmegasas_return_cmd(instance, cmd);\n\t\tgoto fail_fw_init;\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn 0;\n\nfail_fw_init:\n\treturn -EINVAL;\n}\n\nstatic u32\nmegasas_init_adapter_mfi(struct megasas_instance *instance)\n{\n\tu32 context_sz;\n\tu32 reply_q_sz;\n\n\t/*\n\t * Get various operational parameters from status register\n\t */\n\tinstance->max_fw_cmds = instance->instancet->read_fw_status_reg(instance) & 0x00FFFF;\n\t/*\n\t * Reduce the max supported cmds by 1. This is to ensure that the\n\t * reply_q_sz (1 more than the max cmd that driver may send)\n\t * does not exceed max cmds that the FW can support\n\t */\n\tinstance->max_fw_cmds = instance->max_fw_cmds-1;\n\tinstance->max_mfi_cmds = instance->max_fw_cmds;\n\tinstance->max_num_sge = (instance->instancet->read_fw_status_reg(instance) & 0xFF0000) >>\n\t\t\t\t\t0x10;\n\t/*\n\t * For MFI skinny adapters, MEGASAS_SKINNY_INT_CMDS commands\n\t * are reserved for IOCTL + driver's internal DCMDs.\n\t */\n\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t(instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY)) {\n\t\tinstance->max_scsi_cmds = (instance->max_fw_cmds -\n\t\t\tMEGASAS_SKINNY_INT_CMDS);\n\t\tsema_init(&instance->ioctl_sem, MEGASAS_SKINNY_INT_CMDS);\n\t} else {\n\t\tinstance->max_scsi_cmds = (instance->max_fw_cmds -\n\t\t\tMEGASAS_INT_CMDS);\n\t\tsema_init(&instance->ioctl_sem, (MEGASAS_MFI_IOCTL_CMDS));\n\t}\n\n\tinstance->cur_can_queue = instance->max_scsi_cmds;\n\t/*\n\t * Create a pool of commands\n\t */\n\tif (megasas_alloc_cmds(instance))\n\t\tgoto fail_alloc_cmds;\n\n\t/*\n\t * Allocate memory for reply queue. Length of reply queue should\n\t * be _one_ more than the maximum commands handled by the firmware.\n\t *\n\t * Note: When FW completes commands, it places corresponding contex\n\t * values in this circular reply queue. This circular queue is a fairly\n\t * typical producer-consumer queue. FW is the producer (of completed\n\t * commands) and the driver is the consumer.\n\t */\n\tcontext_sz = sizeof(u32);\n\treply_q_sz = context_sz * (instance->max_fw_cmds + 1);\n\n\tinstance->reply_queue = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\treply_q_sz, &instance->reply_queue_h, GFP_KERNEL);\n\n\tif (!instance->reply_queue) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Out of DMA mem for reply queue\\n\");\n\t\tgoto fail_reply_queue;\n\t}\n\n\tif (megasas_issue_init_mfi(instance))\n\t\tgoto fail_fw_init;\n\n\tif (megasas_get_ctrl_info(instance)) {\n\t\tdev_err(&instance->pdev->dev, \"(%d): Could get controller info \"\n\t\t\t\"Fail from %s %d\\n\", instance->unique_id,\n\t\t\t__func__, __LINE__);\n\t\tgoto fail_fw_init;\n\t}\n\n\tinstance->fw_support_ieee = 0;\n\tinstance->fw_support_ieee =\n\t\t(instance->instancet->read_fw_status_reg(instance) &\n\t\t0x04000000);\n\n\tdev_notice(&instance->pdev->dev, \"megasas_init_mfi: fw_support_ieee=%d\",\n\t\t\tinstance->fw_support_ieee);\n\n\tif (instance->fw_support_ieee)\n\t\tinstance->flag_ieee = 1;\n\n\treturn 0;\n\nfail_fw_init:\n\n\tdma_free_coherent(&instance->pdev->dev, reply_q_sz,\n\t\t\t    instance->reply_queue, instance->reply_queue_h);\nfail_reply_queue:\n\tmegasas_free_cmds(instance);\n\nfail_alloc_cmds:\n\treturn 1;\n}\n\nstatic\nvoid megasas_setup_irq_poll(struct megasas_instance *instance)\n{\n\tstruct megasas_irq_context *irq_ctx;\n\tu32 count, i;\n\n\tcount = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\n\n\t/* Initialize IRQ poll */\n\tfor (i = 0; i < count; i++) {\n\t\tirq_ctx = &instance->irq_context[i];\n\t\tirq_ctx->os_irq = pci_irq_vector(instance->pdev, i);\n\t\tirq_ctx->irq_poll_scheduled = false;\n\t\tirq_poll_init(&irq_ctx->irqpoll,\n\t\t\t      instance->threshold_reply_count,\n\t\t\t      megasas_irqpoll);\n\t}\n}\n\n/*\n * megasas_setup_irqs_ioapic -\t\tregister legacy interrupts.\n * @instance:\t\t\t\tAdapter soft state\n *\n * Do not enable interrupt, only setup ISRs.\n *\n * Return 0 on success.\n */\nstatic int\nmegasas_setup_irqs_ioapic(struct megasas_instance *instance)\n{\n\tstruct pci_dev *pdev;\n\n\tpdev = instance->pdev;\n\tinstance->irq_context[0].instance = instance;\n\tinstance->irq_context[0].MSIxIndex = 0;\n\tsnprintf(instance->irq_context->name, MEGASAS_MSIX_NAME_LEN, \"%s%u\",\n\t\t\"megasas\", instance->host->host_no);\n\tif (request_irq(pci_irq_vector(pdev, 0),\n\t\t\tinstance->instancet->service_isr, IRQF_SHARED,\n\t\t\tinstance->irq_context->name, &instance->irq_context[0])) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to register IRQ from %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\treturn -1;\n\t}\n\tinstance->perf_mode = MR_LATENCY_PERF_MODE;\n\tinstance->low_latency_index_start = 0;\n\treturn 0;\n}\n\n/**\n * megasas_setup_irqs_msix -\t\tregister MSI-x interrupts.\n * @instance:\t\t\t\tAdapter soft state\n * @is_probe:\t\t\t\tDriver probe check\n *\n * Do not enable interrupt, only setup ISRs.\n *\n * Return 0 on success.\n */\nstatic int\nmegasas_setup_irqs_msix(struct megasas_instance *instance, u8 is_probe)\n{\n\tint i, j;\n\tstruct pci_dev *pdev;\n\n\tpdev = instance->pdev;\n\n\t/* Try MSI-x */\n\tfor (i = 0; i < instance->msix_vectors; i++) {\n\t\tinstance->irq_context[i].instance = instance;\n\t\tinstance->irq_context[i].MSIxIndex = i;\n\t\tsnprintf(instance->irq_context[i].name, MEGASAS_MSIX_NAME_LEN, \"%s%u-msix%u\",\n\t\t\t\"megasas\", instance->host->host_no, i);\n\t\tif (request_irq(pci_irq_vector(pdev, i),\n\t\t\tinstance->instancet->service_isr, 0, instance->irq_context[i].name,\n\t\t\t&instance->irq_context[i])) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to register IRQ for vector %d.\\n\", i);\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tif (j < instance->low_latency_index_start)\n\t\t\t\t\tirq_set_affinity_hint(\n\t\t\t\t\t\tpci_irq_vector(pdev, j), NULL);\n\t\t\t\tfree_irq(pci_irq_vector(pdev, j),\n\t\t\t\t\t &instance->irq_context[j]);\n\t\t\t}\n\t\t\t/* Retry irq register for IO_APIC*/\n\t\t\tinstance->msix_vectors = 0;\n\t\t\tinstance->msix_load_balance = false;\n\t\t\tif (is_probe) {\n\t\t\t\tpci_free_irq_vectors(instance->pdev);\n\t\t\t\treturn megasas_setup_irqs_ioapic(instance);\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * megasas_destroy_irqs-\t\tunregister interrupts.\n * @instance:\t\t\t\tAdapter soft state\n * return:\t\t\t\tvoid\n */\nstatic void\nmegasas_destroy_irqs(struct megasas_instance *instance) {\n\n\tint i;\n\tint count;\n\tstruct megasas_irq_context *irq_ctx;\n\n\tcount = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\n\tif (instance->adapter_type != MFI_SERIES) {\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tirq_ctx = &instance->irq_context[i];\n\t\t\tirq_poll_disable(&irq_ctx->irqpoll);\n\t\t}\n\t}\n\n\tif (instance->msix_vectors)\n\t\tfor (i = 0; i < instance->msix_vectors; i++) {\n\t\t\tif (i < instance->low_latency_index_start)\n\t\t\t\tirq_set_affinity_hint(\n\t\t\t\t    pci_irq_vector(instance->pdev, i), NULL);\n\t\t\tfree_irq(pci_irq_vector(instance->pdev, i),\n\t\t\t\t &instance->irq_context[i]);\n\t\t}\n\telse\n\t\tfree_irq(pci_irq_vector(instance->pdev, 0),\n\t\t\t &instance->irq_context[0]);\n}\n\n/**\n * megasas_setup_jbod_map -\tsetup jbod map for FP seq_number.\n * @instance:\t\t\t\tAdapter soft state\n *\n * Return 0 on success.\n */\nvoid\nmegasas_setup_jbod_map(struct megasas_instance *instance)\n{\n\tint i;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\tu32 pd_seq_map_sz;\n\n\tpd_seq_map_sz = sizeof(struct MR_PD_CFG_SEQ_NUM_SYNC) +\n\t\t(sizeof(struct MR_PD_CFG_SEQ) * (MAX_PHYSICAL_DEVICES - 1));\n\n\tinstance->use_seqnum_jbod_fp =\n\t\tinstance->support_seqnum_jbod_fp;\n\tif (reset_devices || !fusion ||\n\t\t!instance->support_seqnum_jbod_fp) {\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t\"JBOD sequence map is disabled %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\tinstance->use_seqnum_jbod_fp = false;\n\t\treturn;\n\t}\n\n\tif (fusion->pd_seq_sync[0])\n\t\tgoto skip_alloc;\n\n\tfor (i = 0; i < JBOD_MAPS_COUNT; i++) {\n\t\tfusion->pd_seq_sync[i] = dma_alloc_coherent\n\t\t\t(&instance->pdev->dev, pd_seq_map_sz,\n\t\t\t&fusion->pd_seq_phys[i], GFP_KERNEL);\n\t\tif (!fusion->pd_seq_sync[i]) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate memory from %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tif (i == 1) {\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\tpd_seq_map_sz, fusion->pd_seq_sync[0],\n\t\t\t\t\tfusion->pd_seq_phys[0]);\n\t\t\t\tfusion->pd_seq_sync[0] = NULL;\n\t\t\t}\n\t\t\tinstance->use_seqnum_jbod_fp = false;\n\t\t\treturn;\n\t\t}\n\t}\n\nskip_alloc:\n\tif (!megasas_sync_pd_seq_num(instance, false) &&\n\t\t!megasas_sync_pd_seq_num(instance, true))\n\t\tinstance->use_seqnum_jbod_fp = true;\n\telse\n\t\tinstance->use_seqnum_jbod_fp = false;\n}\n\nstatic void megasas_setup_reply_map(struct megasas_instance *instance)\n{\n\tconst struct cpumask *mask;\n\tunsigned int queue, cpu, low_latency_index_start;\n\n\tlow_latency_index_start = instance->low_latency_index_start;\n\n\tfor (queue = low_latency_index_start; queue < instance->msix_vectors; queue++) {\n\t\tmask = pci_irq_get_affinity(instance->pdev, queue);\n\t\tif (!mask)\n\t\t\tgoto fallback;\n\n\t\tfor_each_cpu(cpu, mask)\n\t\t\tinstance->reply_map[cpu] = queue;\n\t}\n\treturn;\n\nfallback:\n\tqueue = low_latency_index_start;\n\tfor_each_possible_cpu(cpu) {\n\t\tinstance->reply_map[cpu] = queue;\n\t\tif (queue == (instance->msix_vectors - 1))\n\t\t\tqueue = low_latency_index_start;\n\t\telse\n\t\t\tqueue++;\n\t}\n}\n\n/**\n * megasas_get_device_list -\tGet the PD and LD device list from FW.\n * @instance:\t\t\tAdapter soft state\n * @return:\t\t\tSuccess or failure\n *\n * Issue DCMDs to Firmware to get the PD and LD list.\n * Based on the FW support, driver sends the HOST_DEVICE_LIST or combination\n * of PD_LIST/LD_LIST_QUERY DCMDs to get the device list.\n */\nstatic\nint megasas_get_device_list(struct megasas_instance *instance)\n{\n\tmemset(instance->pd_list, 0,\n\t       (MEGASAS_MAX_PD * sizeof(struct megasas_pd_list)));\n\tmemset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);\n\n\tif (instance->enable_fw_dev_list) {\n\t\tif (megasas_host_device_list_query(instance, true))\n\t\t\treturn FAILED;\n\t} else {\n\t\tif (megasas_get_pd_list(instance) < 0) {\n\t\t\tdev_err(&instance->pdev->dev, \"failed to get PD list\\n\");\n\t\t\treturn FAILED;\n\t\t}\n\n\t\tif (megasas_ld_list_query(instance,\n\t\t\t\t\t  MR_LD_QUERY_TYPE_EXPOSED_TO_HOST)) {\n\t\t\tdev_err(&instance->pdev->dev, \"failed to get LD list\\n\");\n\t\t\treturn FAILED;\n\t\t}\n\t}\n\n\treturn SUCCESS;\n}\n\n/**\n * megasas_set_high_iops_queue_affinity_hint -\tSet affinity hint for high IOPS queues\n * @instance:\t\t\t\t\tAdapter soft state\n * return:\t\t\t\t\tvoid\n */\nstatic inline void\nmegasas_set_high_iops_queue_affinity_hint(struct megasas_instance *instance)\n{\n\tint i;\n\tint local_numa_node;\n\n\tif (instance->perf_mode == MR_BALANCED_PERF_MODE) {\n\t\tlocal_numa_node = dev_to_node(&instance->pdev->dev);\n\n\t\tfor (i = 0; i < instance->low_latency_index_start; i++)\n\t\t\tirq_set_affinity_hint(pci_irq_vector(instance->pdev, i),\n\t\t\t\tcpumask_of_node(local_numa_node));\n\t}\n}\n\nstatic int\n__megasas_alloc_irq_vectors(struct megasas_instance *instance)\n{\n\tint i, irq_flags;\n\tstruct irq_affinity desc = { .pre_vectors = instance->low_latency_index_start };\n\tstruct irq_affinity *descp = &desc;\n\n\tirq_flags = PCI_IRQ_MSIX;\n\n\tif (instance->smp_affinity_enable)\n\t\tirq_flags |= PCI_IRQ_AFFINITY;\n\telse\n\t\tdescp = NULL;\n\n\ti = pci_alloc_irq_vectors_affinity(instance->pdev,\n\t\tinstance->low_latency_index_start,\n\t\tinstance->msix_vectors, irq_flags, descp);\n\n\treturn i;\n}\n\n/**\n * megasas_alloc_irq_vectors -\tAllocate IRQ vectors/enable MSI-x vectors\n * @instance:\t\t\tAdapter soft state\n * return:\t\t\tvoid\n */\nstatic void\nmegasas_alloc_irq_vectors(struct megasas_instance *instance)\n{\n\tint i;\n\tunsigned int num_msix_req;\n\n\ti = __megasas_alloc_irq_vectors(instance);\n\n\tif ((instance->perf_mode == MR_BALANCED_PERF_MODE) &&\n\t    (i != instance->msix_vectors)) {\n\t\tif (instance->msix_vectors)\n\t\t\tpci_free_irq_vectors(instance->pdev);\n\t\t/* Disable Balanced IOPS mode and try realloc vectors */\n\t\tinstance->perf_mode = MR_LATENCY_PERF_MODE;\n\t\tinstance->low_latency_index_start = 1;\n\t\tnum_msix_req = num_online_cpus() + instance->low_latency_index_start;\n\n\t\tinstance->msix_vectors = min(num_msix_req,\n\t\t\t\tinstance->msix_vectors);\n\n\t\ti = __megasas_alloc_irq_vectors(instance);\n\n\t}\n\n\tdev_info(&instance->pdev->dev,\n\t\t\"requested/available msix %d/%d\\n\", instance->msix_vectors, i);\n\n\tif (i > 0)\n\t\tinstance->msix_vectors = i;\n\telse\n\t\tinstance->msix_vectors = 0;\n\n\tif (instance->smp_affinity_enable)\n\t\tmegasas_set_high_iops_queue_affinity_hint(instance);\n}\n\n/**\n * megasas_init_fw -\tInitializes the FW\n * @instance:\t\tAdapter soft state\n *\n * This is the main function for initializing firmware\n */\n\nstatic int megasas_init_fw(struct megasas_instance *instance)\n{\n\tu32 max_sectors_1;\n\tu32 max_sectors_2, tmp_sectors, msix_enable;\n\tu32 scratch_pad_1, scratch_pad_2, scratch_pad_3, status_reg;\n\tresource_size_t base_addr;\n\tvoid *base_addr_phys;\n\tstruct megasas_ctrl_info *ctrl_info = NULL;\n\tunsigned long bar_list;\n\tint i, j, loop;\n\tstruct IOV_111 *iovPtr;\n\tstruct fusion_context *fusion;\n\tbool intr_coalescing;\n\tunsigned int num_msix_req;\n\tu16 lnksta, speed;\n\n\tfusion = instance->ctrl_context;\n\n\t/* Find first memory bar */\n\tbar_list = pci_select_bars(instance->pdev, IORESOURCE_MEM);\n\tinstance->bar = find_first_bit(&bar_list, BITS_PER_LONG);\n\tif (pci_request_selected_regions(instance->pdev, 1<<instance->bar,\n\t\t\t\t\t \"megasas: LSI\")) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"IO memory region busy!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tbase_addr = pci_resource_start(instance->pdev, instance->bar);\n\tinstance->reg_set = ioremap(base_addr, 8192);\n\n\tif (!instance->reg_set) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to map IO mem\\n\");\n\t\tgoto fail_ioremap;\n\t}\n\n\tbase_addr_phys = &base_addr;\n\tdev_printk(KERN_DEBUG, &instance->pdev->dev,\n\t\t   \"BAR:0x%lx  BAR's base_addr(phys):%pa  mapped virt_addr:0x%p\\n\",\n\t\t   instance->bar, base_addr_phys, instance->reg_set);\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tinstance->instancet = &megasas_instance_template_fusion;\n\telse {\n\t\tswitch (instance->pdev->device) {\n\t\tcase PCI_DEVICE_ID_LSI_SAS1078R:\n\t\tcase PCI_DEVICE_ID_LSI_SAS1078DE:\n\t\t\tinstance->instancet = &megasas_instance_template_ppc;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_SAS1078GEN2:\n\t\tcase PCI_DEVICE_ID_LSI_SAS0079GEN2:\n\t\t\tinstance->instancet = &megasas_instance_template_gen2;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_SAS0073SKINNY:\n\t\tcase PCI_DEVICE_ID_LSI_SAS0071SKINNY:\n\t\t\tinstance->instancet = &megasas_instance_template_skinny;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_SAS1064R:\n\t\tcase PCI_DEVICE_ID_DELL_PERC5:\n\t\tdefault:\n\t\t\tinstance->instancet = &megasas_instance_template_xscale;\n\t\t\tinstance->pd_list_not_supported = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (megasas_transition_to_ready(instance, 0)) {\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"Failed to transition controller to ready from %s!\\n\",\n\t\t\t __func__);\n\t\tif (instance->adapter_type != MFI_SERIES) {\n\t\t\tstatus_reg = instance->instancet->read_fw_status_reg(\n\t\t\t\t\tinstance);\n\t\t\tif (status_reg & MFI_RESET_ADAPTER) {\n\t\t\t\tif (megasas_adp_reset_wait_for_ready\n\t\t\t\t\t(instance, true, 0) == FAILED)\n\t\t\t\t\tgoto fail_ready_state;\n\t\t\t} else {\n\t\t\t\tgoto fail_ready_state;\n\t\t\t}\n\t\t} else {\n\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 1);\n\t\t\tinstance->instancet->adp_reset\n\t\t\t\t(instance, instance->reg_set);\n\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 0);\n\n\t\t\t/*waiting for about 30 second before retry*/\n\t\t\tssleep(30);\n\n\t\t\tif (megasas_transition_to_ready(instance, 0))\n\t\t\t\tgoto fail_ready_state;\n\t\t}\n\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"FW restarted successfully from %s!\\n\",\n\t\t\t __func__);\n\t}\n\n\tmegasas_init_ctrl_params(instance);\n\n\tif (megasas_set_dma_mask(instance))\n\t\tgoto fail_ready_state;\n\n\tif (megasas_alloc_ctrl_mem(instance))\n\t\tgoto fail_alloc_dma_buf;\n\n\tif (megasas_alloc_ctrl_dma_buffers(instance))\n\t\tgoto fail_alloc_dma_buf;\n\n\tfusion = instance->ctrl_context;\n\n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\tscratch_pad_2 =\n\t\t\tmegasas_readl(instance,\n\t\t\t\t      &instance->reg_set->outbound_scratch_pad_2);\n\t\tinstance->max_raid_mapsize = ((scratch_pad_2 >>\n\t\t\tMR_MAX_RAID_MAP_SIZE_OFFSET_SHIFT) &\n\t\t\tMR_MAX_RAID_MAP_SIZE_MASK);\n\t}\n\n\tinstance->enable_sdev_max_qd = enable_sdev_max_qd;\n\n\tswitch (instance->adapter_type) {\n\tcase VENTURA_SERIES:\n\t\tfusion->pcie_bw_limitation = true;\n\t\tbreak;\n\tcase AERO_SERIES:\n\t\tfusion->r56_div_offload = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* Check if MSI-X is supported while in ready state */\n\tmsix_enable = (instance->instancet->read_fw_status_reg(instance) &\n\t\t       0x4000000) >> 0x1a;\n\tif (msix_enable && !msix_disable) {\n\n\t\tscratch_pad_1 = megasas_readl\n\t\t\t(instance, &instance->reg_set->outbound_scratch_pad_1);\n\t\t/* Check max MSI-X vectors */\n\t\tif (fusion) {\n\t\t\tif (instance->adapter_type == THUNDERBOLT_SERIES) {\n\t\t\t\t/* Thunderbolt Series*/\n\t\t\t\tinstance->msix_vectors = (scratch_pad_1\n\t\t\t\t\t& MR_MAX_REPLY_QUEUES_OFFSET) + 1;\n\t\t\t} else {\n\t\t\t\tinstance->msix_vectors = ((scratch_pad_1\n\t\t\t\t\t& MR_MAX_REPLY_QUEUES_EXT_OFFSET)\n\t\t\t\t\t>> MR_MAX_REPLY_QUEUES_EXT_OFFSET_SHIFT) + 1;\n\n\t\t\t\t/*\n\t\t\t\t * For Invader series, > 8 MSI-x vectors\n\t\t\t\t * supported by FW/HW implies combined\n\t\t\t\t * reply queue mode is enabled.\n\t\t\t\t * For Ventura series, > 16 MSI-x vectors\n\t\t\t\t * supported by FW/HW implies combined\n\t\t\t\t * reply queue mode is enabled.\n\t\t\t\t */\n\t\t\t\tswitch (instance->adapter_type) {\n\t\t\t\tcase INVADER_SERIES:\n\t\t\t\t\tif (instance->msix_vectors > 8)\n\t\t\t\t\t\tinstance->msix_combined = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase AERO_SERIES:\n\t\t\t\tcase VENTURA_SERIES:\n\t\t\t\t\tif (instance->msix_vectors > 16)\n\t\t\t\t\t\tinstance->msix_combined = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (rdpq_enable)\n\t\t\t\t\tinstance->is_rdpq = (scratch_pad_1 & MR_RDPQ_MODE_OFFSET) ?\n\t\t\t\t\t\t\t\t1 : 0;\n\n\t\t\t\tif (instance->adapter_type >= INVADER_SERIES &&\n\t\t\t\t    !instance->msix_combined) {\n\t\t\t\t\tinstance->msix_load_balance = true;\n\t\t\t\t\tinstance->smp_affinity_enable = false;\n\t\t\t\t}\n\n\t\t\t\t/* Save 1-15 reply post index address to local memory\n\t\t\t\t * Index 0 is already saved from reg offset\n\t\t\t\t * MPI2_REPLY_POST_HOST_INDEX_OFFSET\n\t\t\t\t */\n\t\t\t\tfor (loop = 1; loop < MR_MAX_MSIX_REG_ARRAY; loop++) {\n\t\t\t\t\tinstance->reply_post_host_index_addr[loop] =\n\t\t\t\t\t\t(u32 __iomem *)\n\t\t\t\t\t\t((u8 __iomem *)instance->reg_set +\n\t\t\t\t\t\tMPI2_SUP_REPLY_POST_HOST_INDEX_OFFSET\n\t\t\t\t\t\t+ (loop * 0x10));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t \"firmware supports msix\\t: (%d)\",\n\t\t\t\t instance->msix_vectors);\n\t\t\tif (msix_vectors)\n\t\t\t\tinstance->msix_vectors = min(msix_vectors,\n\t\t\t\t\tinstance->msix_vectors);\n\t\t} else /* MFI adapters */\n\t\t\tinstance->msix_vectors = 1;\n\n\n\t\t/*\n\t\t * For Aero (if some conditions are met), driver will configure a\n\t\t * few additional reply queues with interrupt coalescing enabled.\n\t\t * These queues with interrupt coalescing enabled are called\n\t\t * High IOPS queues and rest of reply queues (based on number of\n\t\t * logical CPUs) are termed as Low latency queues.\n\t\t *\n\t\t * Total Number of reply queues = High IOPS queues + low latency queues\n\t\t *\n\t\t * For rest of fusion adapters, 1 additional reply queue will be\n\t\t * reserved for management commands, rest of reply queues\n\t\t * (based on number of logical CPUs) will be used for IOs and\n\t\t * referenced as IO queues.\n\t\t * Total Number of reply queues = 1 + IO queues\n\t\t *\n\t\t * MFI adapters supports single MSI-x so single reply queue\n\t\t * will be used for IO and management commands.\n\t\t */\n\n\t\tintr_coalescing = (scratch_pad_1 & MR_INTR_COALESCING_SUPPORT_OFFSET) ?\n\t\t\t\t\t\t\t\ttrue : false;\n\t\tif (intr_coalescing &&\n\t\t\t(num_online_cpus() >= MR_HIGH_IOPS_QUEUE_COUNT) &&\n\t\t\t(instance->msix_vectors == MEGASAS_MAX_MSIX_QUEUES))\n\t\t\tinstance->perf_mode = MR_BALANCED_PERF_MODE;\n\t\telse\n\t\t\tinstance->perf_mode = MR_LATENCY_PERF_MODE;\n\n\n\t\tif (instance->adapter_type == AERO_SERIES) {\n\t\t\tpcie_capability_read_word(instance->pdev, PCI_EXP_LNKSTA, &lnksta);\n\t\t\tspeed = lnksta & PCI_EXP_LNKSTA_CLS;\n\n\t\t\t/*\n\t\t\t * For Aero, if PCIe link speed is <16 GT/s, then driver should operate\n\t\t\t * in latency perf mode and enable R1 PCI bandwidth algorithm\n\t\t\t */\n\t\t\tif (speed < 0x4) {\n\t\t\t\tinstance->perf_mode = MR_LATENCY_PERF_MODE;\n\t\t\t\tfusion->pcie_bw_limitation = true;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Performance mode settings provided through module parameter-perf_mode will\n\t\t\t * take affect only for:\n\t\t\t * 1. Aero family of adapters.\n\t\t\t * 2. When user sets module parameter- perf_mode in range of 0-2.\n\t\t\t */\n\t\t\tif ((perf_mode >= MR_BALANCED_PERF_MODE) &&\n\t\t\t\t(perf_mode <= MR_LATENCY_PERF_MODE))\n\t\t\t\tinstance->perf_mode = perf_mode;\n\t\t\t/*\n\t\t\t * If intr coalescing is not supported by controller FW, then IOPS\n\t\t\t * and Balanced modes are not feasible.\n\t\t\t */\n\t\t\tif (!intr_coalescing)\n\t\t\t\tinstance->perf_mode = MR_LATENCY_PERF_MODE;\n\n\t\t}\n\n\t\tif (instance->perf_mode == MR_BALANCED_PERF_MODE)\n\t\t\tinstance->low_latency_index_start =\n\t\t\t\tMR_HIGH_IOPS_QUEUE_COUNT;\n\t\telse\n\t\t\tinstance->low_latency_index_start = 1;\n\n\t\tnum_msix_req = num_online_cpus() + instance->low_latency_index_start;\n\n\t\tinstance->msix_vectors = min(num_msix_req,\n\t\t\t\tinstance->msix_vectors);\n\n\t\tmegasas_alloc_irq_vectors(instance);\n\t\tif (!instance->msix_vectors)\n\t\t\tinstance->msix_load_balance = false;\n\t}\n\t/*\n\t * MSI-X host index 0 is common for all adapter.\n\t * It is used for all MPT based Adapters.\n\t */\n\tif (instance->msix_combined) {\n\t\tinstance->reply_post_host_index_addr[0] =\n\t\t\t\t(u32 *)((u8 *)instance->reg_set +\n\t\t\t\tMPI2_SUP_REPLY_POST_HOST_INDEX_OFFSET);\n\t} else {\n\t\tinstance->reply_post_host_index_addr[0] =\n\t\t\t(u32 *)((u8 *)instance->reg_set +\n\t\t\tMPI2_REPLY_POST_HOST_INDEX_OFFSET);\n\t}\n\n\tif (!instance->msix_vectors) {\n\t\ti = pci_alloc_irq_vectors(instance->pdev, 1, 1, PCI_IRQ_LEGACY);\n\t\tif (i < 0)\n\t\t\tgoto fail_init_adapter;\n\t}\n\n\tmegasas_setup_reply_map(instance);\n\n\tdev_info(&instance->pdev->dev,\n\t\t\"current msix/online cpus\\t: (%d/%d)\\n\",\n\t\tinstance->msix_vectors, (unsigned int)num_online_cpus());\n\tdev_info(&instance->pdev->dev,\n\t\t\"RDPQ mode\\t: (%s)\\n\", instance->is_rdpq ? \"enabled\" : \"disabled\");\n\n\ttasklet_init(&instance->isr_tasklet, instance->instancet->tasklet,\n\t\t(unsigned long)instance);\n\n\t/*\n\t * Below are default value for legacy Firmware.\n\t * non-fusion based controllers\n\t */\n\tinstance->fw_supported_vd_count = MAX_LOGICAL_DRIVES;\n\tinstance->fw_supported_pd_count = MAX_PHYSICAL_DEVICES;\n\t/* Get operational params, sge flags, send init cmd to controller */\n\tif (instance->instancet->init_adapter(instance))\n\t\tgoto fail_init_adapter;\n\n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\tscratch_pad_3 =\n\t\t\tmegasas_readl(instance,\n\t\t\t\t      &instance->reg_set->outbound_scratch_pad_3);\n\t\tif ((scratch_pad_3 & MR_NVME_PAGE_SIZE_MASK) >=\n\t\t\tMR_DEFAULT_NVME_PAGE_SHIFT)\n\t\t\tinstance->nvme_page_size =\n\t\t\t\t(1 << (scratch_pad_3 & MR_NVME_PAGE_SIZE_MASK));\n\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"NVME page size\\t: (%d)\\n\", instance->nvme_page_size);\n\t}\n\n\tif (instance->msix_vectors ?\n\t\tmegasas_setup_irqs_msix(instance, 1) :\n\t\tmegasas_setup_irqs_ioapic(instance))\n\t\tgoto fail_init_adapter;\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tmegasas_setup_irq_poll(instance);\n\n\tinstance->instancet->enable_intr(instance);\n\n\tdev_info(&instance->pdev->dev, \"INIT adapter done\\n\");\n\n\tmegasas_setup_jbod_map(instance);\n\n\tif (megasas_get_device_list(instance) != SUCCESS) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"%s: megasas_get_device_list failed\\n\",\n\t\t\t__func__);\n\t\tgoto fail_get_ld_pd_list;\n\t}\n\n\t/* stream detection initialization */\n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\tfusion->stream_detect_by_ld =\n\t\t\tkcalloc(MAX_LOGICAL_DRIVES_EXT,\n\t\t\t\tsizeof(struct LD_STREAM_DETECT *),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!fusion->stream_detect_by_ld) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"unable to allocate stream detection for pool of LDs\\n\");\n\t\t\tgoto fail_get_ld_pd_list;\n\t\t}\n\t\tfor (i = 0; i < MAX_LOGICAL_DRIVES_EXT; ++i) {\n\t\t\tfusion->stream_detect_by_ld[i] =\n\t\t\t\tkzalloc(sizeof(struct LD_STREAM_DETECT),\n\t\t\t\tGFP_KERNEL);\n\t\t\tif (!fusion->stream_detect_by_ld[i]) {\n\t\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\t\"unable to allocate stream detect by LD\\n \");\n\t\t\t\tfor (j = 0; j < i; ++j)\n\t\t\t\t\tkfree(fusion->stream_detect_by_ld[j]);\n\t\t\t\tkfree(fusion->stream_detect_by_ld);\n\t\t\t\tfusion->stream_detect_by_ld = NULL;\n\t\t\t\tgoto fail_get_ld_pd_list;\n\t\t\t}\n\t\t\tfusion->stream_detect_by_ld[i]->mru_bit_map\n\t\t\t\t= MR_STREAM_BITMAP;\n\t\t}\n\t}\n\n\t/*\n\t * Compute the max allowed sectors per IO: The controller info has two\n\t * limits on max sectors. Driver should use the minimum of these two.\n\t *\n\t * 1 << stripe_sz_ops.min = max sectors per strip\n\t *\n\t * Note that older firmwares ( < FW ver 30) didn't report information\n\t * to calculate max_sectors_1. So the number ended up as zero always.\n\t */\n\ttmp_sectors = 0;\n\tctrl_info = instance->ctrl_info_buf;\n\n\tmax_sectors_1 = (1 << ctrl_info->stripe_sz_ops.min) *\n\t\tle16_to_cpu(ctrl_info->max_strips_per_io);\n\tmax_sectors_2 = le32_to_cpu(ctrl_info->max_request_size);\n\n\ttmp_sectors = min_t(u32, max_sectors_1, max_sectors_2);\n\n\tinstance->peerIsPresent = ctrl_info->cluster.peerIsPresent;\n\tinstance->passive = ctrl_info->cluster.passive;\n\tmemcpy(instance->clusterId, ctrl_info->clusterId, sizeof(instance->clusterId));\n\tinstance->UnevenSpanSupport =\n\t\tctrl_info->adapterOperations2.supportUnevenSpans;\n\tif (instance->UnevenSpanSupport) {\n\t\tstruct fusion_context *fusion = instance->ctrl_context;\n\t\tif (MR_ValidateMapInfo(instance, instance->map_id))\n\t\t\tfusion->fast_path_io = 1;\n\t\telse\n\t\t\tfusion->fast_path_io = 0;\n\n\t}\n\tif (ctrl_info->host_interface.SRIOV) {\n\t\tinstance->requestorId = ctrl_info->iov.requestorId;\n\t\tif (instance->pdev->device == PCI_DEVICE_ID_LSI_PLASMA) {\n\t\t\tif (!ctrl_info->adapterOperations2.activePassive)\n\t\t\t    instance->PlasmaFW111 = 1;\n\n\t\t\tdev_info(&instance->pdev->dev, \"SR-IOV: firmware type: %s\\n\",\n\t\t\t    instance->PlasmaFW111 ? \"1.11\" : \"new\");\n\n\t\t\tif (instance->PlasmaFW111) {\n\t\t\t    iovPtr = (struct IOV_111 *)\n\t\t\t\t((unsigned char *)ctrl_info + IOV_111_OFFSET);\n\t\t\t    instance->requestorId = iovPtr->requestorId;\n\t\t\t}\n\t\t}\n\t\tdev_info(&instance->pdev->dev, \"SRIOV: VF requestorId %d\\n\",\n\t\t\tinstance->requestorId);\n\t}\n\n\tinstance->crash_dump_fw_support =\n\t\tctrl_info->adapterOperations3.supportCrashDump;\n\tinstance->crash_dump_drv_support =\n\t\t(instance->crash_dump_fw_support &&\n\t\tinstance->crash_dump_buf);\n\tif (instance->crash_dump_drv_support)\n\t\tmegasas_set_crash_dump_params(instance,\n\t\t\tMR_CRASH_BUF_TURN_OFF);\n\n\telse {\n\t\tif (instance->crash_dump_buf)\n\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\tCRASH_DMA_BUF_SIZE,\n\t\t\t\tinstance->crash_dump_buf,\n\t\t\t\tinstance->crash_dump_h);\n\t\tinstance->crash_dump_buf = NULL;\n\t}\n\n\tif (instance->snapdump_wait_time) {\n\t\tmegasas_get_snapdump_properties(instance);\n\t\tdev_info(&instance->pdev->dev, \"Snap dump wait time\\t: %d\\n\",\n\t\t\t instance->snapdump_wait_time);\n\t}\n\n\tdev_info(&instance->pdev->dev,\n\t\t\"pci id\\t\\t: (0x%04x)/(0x%04x)/(0x%04x)/(0x%04x)\\n\",\n\t\tle16_to_cpu(ctrl_info->pci.vendor_id),\n\t\tle16_to_cpu(ctrl_info->pci.device_id),\n\t\tle16_to_cpu(ctrl_info->pci.sub_vendor_id),\n\t\tle16_to_cpu(ctrl_info->pci.sub_device_id));\n\tdev_info(&instance->pdev->dev, \"unevenspan support\t: %s\\n\",\n\t\tinstance->UnevenSpanSupport ? \"yes\" : \"no\");\n\tdev_info(&instance->pdev->dev, \"firmware crash dump\t: %s\\n\",\n\t\tinstance->crash_dump_drv_support ? \"yes\" : \"no\");\n\tdev_info(&instance->pdev->dev, \"JBOD sequence map\t: %s\\n\",\n\t\tinstance->use_seqnum_jbod_fp ? \"enabled\" : \"disabled\");\n\n\tinstance->max_sectors_per_req = instance->max_num_sge *\n\t\t\t\t\t\tSGE_BUFFER_SIZE / 512;\n\tif (tmp_sectors && (instance->max_sectors_per_req > tmp_sectors))\n\t\tinstance->max_sectors_per_req = tmp_sectors;\n\n\t/* Check for valid throttlequeuedepth module parameter */\n\tif (throttlequeuedepth &&\n\t\t\tthrottlequeuedepth <= instance->max_scsi_cmds)\n\t\tinstance->throttlequeuedepth = throttlequeuedepth;\n\telse\n\t\tinstance->throttlequeuedepth =\n\t\t\t\tMEGASAS_THROTTLE_QUEUE_DEPTH;\n\n\tif ((resetwaittime < 1) ||\n\t    (resetwaittime > MEGASAS_RESET_WAIT_TIME))\n\t\tresetwaittime = MEGASAS_RESET_WAIT_TIME;\n\n\tif ((scmd_timeout < 10) || (scmd_timeout > MEGASAS_DEFAULT_CMD_TIMEOUT))\n\t\tscmd_timeout = MEGASAS_DEFAULT_CMD_TIMEOUT;\n\n\t/* Launch SR-IOV heartbeat timer */\n\tif (instance->requestorId) {\n\t\tif (!megasas_sriov_start_heartbeat(instance, 1)) {\n\t\t\tmegasas_start_timer(instance);\n\t\t} else {\n\t\t\tinstance->skip_heartbeat_timer_del = 1;\n\t\t\tgoto fail_get_ld_pd_list;\n\t\t}\n\t}\n\n\t/*\n\t * Create and start watchdog thread which will monitor\n\t * controller state every 1 sec and trigger OCR when\n\t * it enters fault state\n\t */\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tif (megasas_fusion_start_watchdog(instance) != SUCCESS)\n\t\t\tgoto fail_start_watchdog;\n\n\treturn 0;\n\nfail_start_watchdog:\n\tif (instance->requestorId && !instance->skip_heartbeat_timer_del)\n\t\tdel_timer_sync(&instance->sriov_heartbeat_timer);\nfail_get_ld_pd_list:\n\tinstance->instancet->disable_intr(instance);\n\tmegasas_destroy_irqs(instance);\nfail_init_adapter:\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\n\tinstance->msix_vectors = 0;\nfail_alloc_dma_buf:\n\tmegasas_free_ctrl_dma_buffers(instance);\n\tmegasas_free_ctrl_mem(instance);\nfail_ready_state:\n\tiounmap(instance->reg_set);\n\nfail_ioremap:\n\tpci_release_selected_regions(instance->pdev, 1<<instance->bar);\n\n\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t__func__, __LINE__);\n\treturn -EINVAL;\n}\n\n/**\n * megasas_release_mfi -\tReverses the FW initialization\n * @instance:\t\t\tAdapter soft state\n */\nstatic void megasas_release_mfi(struct megasas_instance *instance)\n{\n\tu32 reply_q_sz = sizeof(u32) *(instance->max_mfi_cmds + 1);\n\n\tif (instance->reply_queue)\n\t\tdma_free_coherent(&instance->pdev->dev, reply_q_sz,\n\t\t\t    instance->reply_queue, instance->reply_queue_h);\n\n\tmegasas_free_cmds(instance);\n\n\tiounmap(instance->reg_set);\n\n\tpci_release_selected_regions(instance->pdev, 1<<instance->bar);\n}\n\n/**\n * megasas_get_seq_num -\tGets latest event sequence numbers\n * @instance:\t\t\tAdapter soft state\n * @eli:\t\t\tFW event log sequence numbers information\n *\n * FW maintains a log of all events in a non-volatile area. Upper layers would\n * usually find out the latest sequence number of the events, the seq number at\n * the boot etc. They would \"read\" all the events below the latest seq number\n * by issuing a direct fw cmd (DCMD). For the future events (beyond latest seq\n * number), they would subsribe to AEN (asynchronous event notification) and\n * wait for the events to happen.\n */\nstatic int\nmegasas_get_seq_num(struct megasas_instance *instance,\n\t\t    struct megasas_evt_log_info *eli)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct megasas_evt_log_info *el_info;\n\tdma_addr_t el_info_h = 0;\n\tint ret;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\tel_info = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\t\t     sizeof(struct megasas_evt_log_info),\n\t\t\t\t     &el_info_h, GFP_KERNEL);\n\tif (!el_info) {\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0x0;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct megasas_evt_log_info));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_EVENT_GET_INFO);\n\n\tmegasas_set_dma_settings(instance, dcmd, el_info_h,\n\t\t\t\t sizeof(struct megasas_evt_log_info));\n\n\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\tif (ret != DCMD_SUCCESS) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\tgoto dcmd_failed;\n\t}\n\n\t/*\n\t * Copy the data back into callers buffer\n\t */\n\teli->newest_seq_num = el_info->newest_seq_num;\n\teli->oldest_seq_num = el_info->oldest_seq_num;\n\teli->clear_seq_num = el_info->clear_seq_num;\n\teli->shutdown_seq_num = el_info->shutdown_seq_num;\n\teli->boot_seq_num = el_info->boot_seq_num;\n\ndcmd_failed:\n\tdma_free_coherent(&instance->pdev->dev,\n\t\t\tsizeof(struct megasas_evt_log_info),\n\t\t\tel_info, el_info_h);\n\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/**\n * megasas_register_aen -\tRegisters for asynchronous event notification\n * @instance:\t\t\tAdapter soft state\n * @seq_num:\t\t\tThe starting sequence number\n * @class_locale_word:\t\tClass of the event\n *\n * This function subscribes for AEN for events beyond the @seq_num. It requests\n * to be notified if and only if the event is of type @class_locale\n */\nstatic int\nmegasas_register_aen(struct megasas_instance *instance, u32 seq_num,\n\t\t     u32 class_locale_word)\n{\n\tint ret_val;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tunion megasas_evt_class_locale curr_aen;\n\tunion megasas_evt_class_locale prev_aen;\n\n\t/*\n\t * If there an AEN pending already (aen_cmd), check if the\n\t * class_locale of that pending AEN is inclusive of the new\n\t * AEN request we currently have. If it is, then we don't have\n\t * to do anything. In other words, whichever events the current\n\t * AEN request is subscribing to, have already been subscribed\n\t * to.\n\t *\n\t * If the old_cmd is _not_ inclusive, then we have to abort\n\t * that command, form a class_locale that is superset of both\n\t * old and current and re-issue to the FW\n\t */\n\n\tcurr_aen.word = class_locale_word;\n\n\tif (instance->aen_cmd) {\n\n\t\tprev_aen.word =\n\t\t\tle32_to_cpu(instance->aen_cmd->frame->dcmd.mbox.w[1]);\n\n\t\tif ((curr_aen.members.class < MFI_EVT_CLASS_DEBUG) ||\n\t\t    (curr_aen.members.class > MFI_EVT_CLASS_DEAD)) {\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t \"%s %d out of range class %d send by application\\n\",\n\t\t\t\t __func__, __LINE__, curr_aen.members.class);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * A class whose enum value is smaller is inclusive of all\n\t\t * higher values. If a PROGRESS (= -1) was previously\n\t\t * registered, then a new registration requests for higher\n\t\t * classes need not be sent to FW. They are automatically\n\t\t * included.\n\t\t *\n\t\t * Locale numbers don't have such hierarchy. They are bitmap\n\t\t * values\n\t\t */\n\t\tif ((prev_aen.members.class <= curr_aen.members.class) &&\n\t\t    !((prev_aen.members.locale & curr_aen.members.locale) ^\n\t\t      curr_aen.members.locale)) {\n\t\t\t/*\n\t\t\t * Previously issued event registration includes\n\t\t\t * current request. Nothing to do.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tcurr_aen.members.locale |= prev_aen.members.locale;\n\n\t\t\tif (prev_aen.members.class < curr_aen.members.class)\n\t\t\t\tcurr_aen.members.class = prev_aen.members.class;\n\n\t\t\tinstance->aen_cmd->abort_aen = 1;\n\t\t\tret_val = megasas_issue_blocked_abort_cmd(instance,\n\t\t\t\t\t\t\t\t  instance->\n\t\t\t\t\t\t\t\t  aen_cmd, 30);\n\n\t\t\tif (ret_val) {\n\t\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to abort \"\n\t\t\t\t       \"previous AEN command\\n\");\n\t\t\t\treturn ret_val;\n\t\t\t}\n\t\t}\n\t}\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(instance->evt_detail, 0, sizeof(struct megasas_evt_detail));\n\n\t/*\n\t * Prepare DCMD for aen registration\n\t */\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0x0;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct megasas_evt_detail));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_EVENT_WAIT);\n\tdcmd->mbox.w[0] = cpu_to_le32(seq_num);\n\tinstance->last_seq_num = seq_num;\n\tdcmd->mbox.w[1] = cpu_to_le32(curr_aen.word);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->evt_detail_h,\n\t\t\t\t sizeof(struct megasas_evt_detail));\n\n\tif (instance->aen_cmd != NULL) {\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Store reference to the cmd used to register for AEN. When an\n\t * application wants us to register for AEN, we have to abort this\n\t * cmd and re-register with a new EVENT LOCALE supplied by that app\n\t */\n\tinstance->aen_cmd = cmd;\n\n\t/*\n\t * Issue the aen registration frame\n\t */\n\tinstance->instancet->issue_dcmd(instance, cmd);\n\n\treturn 0;\n}\n\n/* megasas_get_target_prop - Send DCMD with below details to firmware.\n *\n * This DCMD will fetch few properties of LD/system PD defined\n * in MR_TARGET_DEV_PROPERTIES. eg. Queue Depth, MDTS value.\n *\n * DCMD send by drivers whenever new target is added to the OS.\n *\n * dcmd.opcode         - MR_DCMD_DEV_GET_TARGET_PROP\n * dcmd.mbox.b[0]      - DCMD is to be fired for LD or system PD.\n *                       0 = system PD, 1 = LD.\n * dcmd.mbox.s[1]      - TargetID for LD/system PD.\n * dcmd.sge IN         - Pointer to return MR_TARGET_DEV_PROPERTIES.\n *\n * @instance:\t\tAdapter soft state\n * @sdev:\t\tOS provided scsi device\n *\n * Returns 0 on success non-zero on failure.\n */\nint\nmegasas_get_target_prop(struct megasas_instance *instance,\n\t\t\tstruct scsi_device *sdev)\n{\n\tint ret;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tu16 targetId = ((sdev->channel % 2) * MEGASAS_MAX_DEV_PER_CHANNEL) +\n\t\t\tsdev->id;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed to get cmd %s\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(instance->tgt_prop, 0, sizeof(*instance->tgt_prop));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\tdcmd->mbox.b[0] = MEGASAS_IS_LOGICAL(sdev);\n\n\tdcmd->mbox.s[1] = cpu_to_le16(targetId);\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0xFF;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len =\n\t\tcpu_to_le32(sizeof(struct MR_TARGET_PROPERTIES));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_DRV_GET_TARGET_PROP);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->tgt_prop_h,\n\t\t\t\t sizeof(struct MR_TARGET_PROPERTIES));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance,\n\t\t\t\t\t\tcmd, MFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tswitch (ret) {\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\t     MFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t __func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tmegasas_return_cmd(instance, cmd);\n\t}\n\tif (ret != DCMD_SUCCESS)\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"return from %s %d return value %d\\n\",\n\t\t\t__func__, __LINE__, ret);\n\n\treturn ret;\n}\n\n/**\n * megasas_start_aen -\tSubscribes to AEN during driver load time\n * @instance:\t\tAdapter soft state\n */\nstatic int megasas_start_aen(struct megasas_instance *instance)\n{\n\tstruct megasas_evt_log_info eli;\n\tunion megasas_evt_class_locale class_locale;\n\n\t/*\n\t * Get the latest sequence number from FW\n\t */\n\tmemset(&eli, 0, sizeof(eli));\n\n\tif (megasas_get_seq_num(instance, &eli))\n\t\treturn -1;\n\n\t/*\n\t * Register AEN with FW for latest sequence number plus 1\n\t */\n\tclass_locale.members.reserved = 0;\n\tclass_locale.members.locale = MR_EVT_LOCALE_ALL;\n\tclass_locale.members.class = MR_EVT_CLASS_DEBUG;\n\n\treturn megasas_register_aen(instance,\n\t\t\tle32_to_cpu(eli.newest_seq_num) + 1,\n\t\t\tclass_locale.word);\n}\n\n/**\n * megasas_io_attach -\tAttaches this driver to SCSI mid-layer\n * @instance:\t\tAdapter soft state\n */\nstatic int megasas_io_attach(struct megasas_instance *instance)\n{\n\tstruct Scsi_Host *host = instance->host;\n\n\t/*\n\t * Export parameters required by SCSI mid-layer\n\t */\n\thost->unique_id = instance->unique_id;\n\thost->can_queue = instance->max_scsi_cmds;\n\thost->this_id = instance->init_id;\n\thost->sg_tablesize = instance->max_num_sge;\n\n\tif (instance->fw_support_ieee)\n\t\tinstance->max_sectors_per_req = MEGASAS_MAX_SECTORS_IEEE;\n\n\t/*\n\t * Check if the module parameter value for max_sectors can be used\n\t */\n\tif (max_sectors && max_sectors < instance->max_sectors_per_req)\n\t\tinstance->max_sectors_per_req = max_sectors;\n\telse {\n\t\tif (max_sectors) {\n\t\t\tif (((instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS1078GEN2) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS0079GEN2)) &&\n\t\t\t\t(max_sectors <= MEGASAS_MAX_SECTORS)) {\n\t\t\t\tinstance->max_sectors_per_req = max_sectors;\n\t\t\t} else {\n\t\t\tdev_info(&instance->pdev->dev, \"max_sectors should be > 0\"\n\t\t\t\t\"and <= %d (or < 1MB for GEN2 controller)\\n\",\n\t\t\t\tinstance->max_sectors_per_req);\n\t\t\t}\n\t\t}\n\t}\n\n\thost->max_sectors = instance->max_sectors_per_req;\n\thost->cmd_per_lun = MEGASAS_DEFAULT_CMD_PER_LUN;\n\thost->max_channel = MEGASAS_MAX_CHANNELS - 1;\n\thost->max_id = MEGASAS_MAX_DEV_PER_CHANNEL;\n\thost->max_lun = MEGASAS_MAX_LUN;\n\thost->max_cmd_len = 16;\n\n\t/* Use shared host tagset only for fusion adaptors\n\t * if there are managed interrupts (smp affinity enabled case).\n\t * Single msix_vectors in kdump, so shared host tag is also disabled.\n\t */\n\n\thost->host_tagset = 0;\n\thost->nr_hw_queues = 1;\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t\t(instance->msix_vectors > instance->low_latency_index_start) &&\n\t\thost_tagset_enable &&\n\t\tinstance->smp_affinity_enable) {\n\t\thost->host_tagset = 1;\n\t\thost->nr_hw_queues = instance->msix_vectors -\n\t\t\tinstance->low_latency_index_start;\n\t}\n\n\tdev_info(&instance->pdev->dev,\n\t\t\"Max firmware commands: %d shared with nr_hw_queues = %d\\n\",\n\t\tinstance->max_fw_cmds, host->nr_hw_queues);\n\t/*\n\t * Notify the mid-layer about the new controller\n\t */\n\tif (scsi_add_host(host, &instance->pdev->dev)) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed to add host from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n/**\n * megasas_set_dma_mask -\tSet DMA mask for supported controllers\n *\n * @instance:\t\tAdapter soft state\n * Description:\n *\n * For Ventura, driver/FW will operate in 63bit DMA addresses.\n *\n * For invader-\n *\tBy default, driver/FW will operate in 32bit DMA addresses\n *\tfor consistent DMA mapping but if 32 bit consistent\n *\tDMA mask fails, driver will try with 63 bit consistent\n *\tmask provided FW is true 63bit DMA capable\n *\n * For older controllers(Thunderbolt and MFI based adapters)-\n *\tdriver/FW will operate in 32 bit consistent DMA addresses.\n */\nstatic int\nmegasas_set_dma_mask(struct megasas_instance *instance)\n{\n\tu64 consistent_mask;\n\tstruct pci_dev *pdev;\n\tu32 scratch_pad_1;\n\n\tpdev = instance->pdev;\n\tconsistent_mask = (instance->adapter_type >= VENTURA_SERIES) ?\n\t\t\t\tDMA_BIT_MASK(63) : DMA_BIT_MASK(32);\n\n\tif (IS_DMA64) {\n\t\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(63)) &&\n\t\t    dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32)))\n\t\t\tgoto fail_set_dma_mask;\n\n\t\tif ((*pdev->dev.dma_mask == DMA_BIT_MASK(63)) &&\n\t\t    (dma_set_coherent_mask(&pdev->dev, consistent_mask) &&\n\t\t     dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32)))) {\n\t\t\t/*\n\t\t\t * If 32 bit DMA mask fails, then try for 64 bit mask\n\t\t\t * for FW capable of handling 64 bit DMA.\n\t\t\t */\n\t\t\tscratch_pad_1 = megasas_readl\n\t\t\t\t(instance, &instance->reg_set->outbound_scratch_pad_1);\n\n\t\t\tif (!(scratch_pad_1 & MR_CAN_HANDLE_64_BIT_DMA_OFFSET))\n\t\t\t\tgoto fail_set_dma_mask;\n\t\t\telse if (dma_set_mask_and_coherent(&pdev->dev,\n\t\t\t\t\t\t\t   DMA_BIT_MASK(63)))\n\t\t\t\tgoto fail_set_dma_mask;\n\t\t}\n\t} else if (dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32)))\n\t\tgoto fail_set_dma_mask;\n\n\tif (pdev->dev.coherent_dma_mask == DMA_BIT_MASK(32))\n\t\tinstance->consistent_mask_64bit = false;\n\telse\n\t\tinstance->consistent_mask_64bit = true;\n\n\tdev_info(&pdev->dev, \"%s bit DMA mask and %s bit consistent mask\\n\",\n\t\t ((*pdev->dev.dma_mask == DMA_BIT_MASK(63)) ? \"63\" : \"32\"),\n\t\t (instance->consistent_mask_64bit ? \"63\" : \"32\"));\n\n\treturn 0;\n\nfail_set_dma_mask:\n\tdev_err(&pdev->dev, \"Failed to set DMA mask\\n\");\n\treturn -1;\n\n}\n\n/*\n * megasas_set_adapter_type -\tSet adapter type.\n *\t\t\t\tSupported controllers can be divided in\n *\t\t\t\tdifferent categories-\n *\t\t\t\t\tenum MR_ADAPTER_TYPE {\n *\t\t\t\t\t\tMFI_SERIES = 1,\n *\t\t\t\t\t\tTHUNDERBOLT_SERIES = 2,\n *\t\t\t\t\t\tINVADER_SERIES = 3,\n *\t\t\t\t\t\tVENTURA_SERIES = 4,\n *\t\t\t\t\t\tAERO_SERIES = 5,\n *\t\t\t\t\t};\n * @instance:\t\t\tAdapter soft state\n * return:\t\t\tvoid\n */\nstatic inline void megasas_set_adapter_type(struct megasas_instance *instance)\n{\n\tif ((instance->pdev->vendor == PCI_VENDOR_ID_DELL) &&\n\t    (instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5)) {\n\t\tinstance->adapter_type = MFI_SERIES;\n\t} else {\n\t\tswitch (instance->pdev->device) {\n\t\tcase PCI_DEVICE_ID_LSI_AERO_10E1:\n\t\tcase PCI_DEVICE_ID_LSI_AERO_10E2:\n\t\tcase PCI_DEVICE_ID_LSI_AERO_10E5:\n\t\tcase PCI_DEVICE_ID_LSI_AERO_10E6:\n\t\t\tinstance->adapter_type = AERO_SERIES;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_VENTURA:\n\t\tcase PCI_DEVICE_ID_LSI_CRUSADER:\n\t\tcase PCI_DEVICE_ID_LSI_HARPOON:\n\t\tcase PCI_DEVICE_ID_LSI_TOMCAT:\n\t\tcase PCI_DEVICE_ID_LSI_VENTURA_4PORT:\n\t\tcase PCI_DEVICE_ID_LSI_CRUSADER_4PORT:\n\t\t\tinstance->adapter_type = VENTURA_SERIES;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_FUSION:\n\t\tcase PCI_DEVICE_ID_LSI_PLASMA:\n\t\t\tinstance->adapter_type = THUNDERBOLT_SERIES;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_INVADER:\n\t\tcase PCI_DEVICE_ID_LSI_INTRUDER:\n\t\tcase PCI_DEVICE_ID_LSI_INTRUDER_24:\n\t\tcase PCI_DEVICE_ID_LSI_CUTLASS_52:\n\t\tcase PCI_DEVICE_ID_LSI_CUTLASS_53:\n\t\tcase PCI_DEVICE_ID_LSI_FURY:\n\t\t\tinstance->adapter_type = INVADER_SERIES;\n\t\t\tbreak;\n\t\tdefault: /* For all other supported controllers */\n\t\t\tinstance->adapter_type = MFI_SERIES;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic inline int megasas_alloc_mfi_ctrl_mem(struct megasas_instance *instance)\n{\n\tinstance->producer = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\tsizeof(u32), &instance->producer_h, GFP_KERNEL);\n\tinstance->consumer = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\tsizeof(u32), &instance->consumer_h, GFP_KERNEL);\n\n\tif (!instance->producer || !instance->consumer) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed to allocate memory for producer, consumer\\n\");\n\t\treturn -1;\n\t}\n\n\t*instance->producer = 0;\n\t*instance->consumer = 0;\n\treturn 0;\n}\n\n/**\n * megasas_alloc_ctrl_mem -\tAllocate per controller memory for core data\n *\t\t\t\tstructures which are not common across MFI\n *\t\t\t\tadapters and fusion adapters.\n *\t\t\t\tFor MFI based adapters, allocate producer and\n *\t\t\t\tconsumer buffers. For fusion adapters, allocate\n *\t\t\t\tmemory for fusion context.\n * @instance:\t\t\tAdapter soft state\n * return:\t\t\t0 for SUCCESS\n */\nstatic int megasas_alloc_ctrl_mem(struct megasas_instance *instance)\n{\n\tinstance->reply_map = kcalloc(nr_cpu_ids, sizeof(unsigned int),\n\t\t\t\t      GFP_KERNEL);\n\tif (!instance->reply_map)\n\t\treturn -ENOMEM;\n\n\tswitch (instance->adapter_type) {\n\tcase MFI_SERIES:\n\t\tif (megasas_alloc_mfi_ctrl_mem(instance))\n\t\t\tgoto fail;\n\t\tbreak;\n\tcase AERO_SERIES:\n\tcase VENTURA_SERIES:\n\tcase THUNDERBOLT_SERIES:\n\tcase INVADER_SERIES:\n\t\tif (megasas_alloc_fusion_context(instance))\n\t\t\tgoto fail;\n\t\tbreak;\n\t}\n\n\treturn 0;\n fail:\n\tkfree(instance->reply_map);\n\tinstance->reply_map = NULL;\n\treturn -ENOMEM;\n}\n\n/*\n * megasas_free_ctrl_mem -\tFree fusion context for fusion adapters and\n *\t\t\t\tproducer, consumer buffers for MFI adapters\n *\n * @instance -\t\t\tAdapter soft instance\n *\n */\nstatic inline void megasas_free_ctrl_mem(struct megasas_instance *instance)\n{\n\tkfree(instance->reply_map);\n\tif (instance->adapter_type == MFI_SERIES) {\n\t\tif (instance->producer)\n\t\t\tdma_free_coherent(&instance->pdev->dev, sizeof(u32),\n\t\t\t\t\t    instance->producer,\n\t\t\t\t\t    instance->producer_h);\n\t\tif (instance->consumer)\n\t\t\tdma_free_coherent(&instance->pdev->dev, sizeof(u32),\n\t\t\t\t\t    instance->consumer,\n\t\t\t\t\t    instance->consumer_h);\n\t} else {\n\t\tmegasas_free_fusion_context(instance);\n\t}\n}\n\n/**\n * megasas_alloc_ctrl_dma_buffers -\tAllocate consistent DMA buffers during\n *\t\t\t\t\tdriver load time\n *\n * @instance:\t\t\t\tAdapter soft instance\n *\n * @return:\t\t\t\tO for SUCCESS\n */\nstatic inline\nint megasas_alloc_ctrl_dma_buffers(struct megasas_instance *instance)\n{\n\tstruct pci_dev *pdev = instance->pdev;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\n\tinstance->evt_detail = dma_alloc_coherent(&pdev->dev,\n\t\t\tsizeof(struct megasas_evt_detail),\n\t\t\t&instance->evt_detail_h, GFP_KERNEL);\n\n\tif (!instance->evt_detail) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed to allocate event detail buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (fusion) {\n\t\tfusion->ioc_init_request =\n\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t   sizeof(struct MPI2_IOC_INIT_REQUEST),\n\t\t\t\t\t   &fusion->ioc_init_request_phys,\n\t\t\t\t\t   GFP_KERNEL);\n\n\t\tif (!fusion->ioc_init_request) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to allocate PD list buffer\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tinstance->snapdump_prop = dma_alloc_coherent(&pdev->dev,\n\t\t\t\tsizeof(struct MR_SNAPDUMP_PROPERTIES),\n\t\t\t\t&instance->snapdump_prop_h, GFP_KERNEL);\n\n\t\tif (!instance->snapdump_prop)\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to allocate snapdump properties buffer\\n\");\n\n\t\tinstance->host_device_list_buf = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\t\tHOST_DEVICE_LIST_SZ,\n\t\t\t\t\t\t\t&instance->host_device_list_buf_h,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!instance->host_device_list_buf) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to allocate targetid list buffer\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t}\n\n\tinstance->pd_list_buf =\n\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t     MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST),\n\t\t\t\t     &instance->pd_list_buf_h, GFP_KERNEL);\n\n\tif (!instance->pd_list_buf) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate PD list buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinstance->ctrl_info_buf =\n\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t     sizeof(struct megasas_ctrl_info),\n\t\t\t\t     &instance->ctrl_info_buf_h, GFP_KERNEL);\n\n\tif (!instance->ctrl_info_buf) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to allocate controller info buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinstance->ld_list_buf =\n\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t     sizeof(struct MR_LD_LIST),\n\t\t\t\t     &instance->ld_list_buf_h, GFP_KERNEL);\n\n\tif (!instance->ld_list_buf) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate LD list buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinstance->ld_targetid_list_buf =\n\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\tsizeof(struct MR_LD_TARGETID_LIST),\n\t\t\t\t&instance->ld_targetid_list_buf_h, GFP_KERNEL);\n\n\tif (!instance->ld_targetid_list_buf) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to allocate LD targetid list buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!reset_devices) {\n\t\tinstance->system_info_buf =\n\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\tsizeof(struct MR_DRV_SYSTEM_INFO),\n\t\t\t\t\t&instance->system_info_h, GFP_KERNEL);\n\t\tinstance->pd_info =\n\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\tsizeof(struct MR_PD_INFO),\n\t\t\t\t\t&instance->pd_info_h, GFP_KERNEL);\n\t\tinstance->tgt_prop =\n\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\tsizeof(struct MR_TARGET_PROPERTIES),\n\t\t\t\t\t&instance->tgt_prop_h, GFP_KERNEL);\n\t\tinstance->crash_dump_buf =\n\t\t\tdma_alloc_coherent(&pdev->dev, CRASH_DMA_BUF_SIZE,\n\t\t\t\t\t&instance->crash_dump_h, GFP_KERNEL);\n\n\t\tif (!instance->system_info_buf)\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate system info buffer\\n\");\n\n\t\tif (!instance->pd_info)\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate pd_info buffer\\n\");\n\n\t\tif (!instance->tgt_prop)\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate tgt_prop buffer\\n\");\n\n\t\tif (!instance->crash_dump_buf)\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate crash dump buffer\\n\");\n\t}\n\n\treturn 0;\n}\n\n/*\n * megasas_free_ctrl_dma_buffers -\tFree consistent DMA buffers allocated\n *\t\t\t\t\tduring driver load time\n *\n * @instance-\t\t\t\tAdapter soft instance\n *\n */\nstatic inline\nvoid megasas_free_ctrl_dma_buffers(struct megasas_instance *instance)\n{\n\tstruct pci_dev *pdev = instance->pdev;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\n\tif (instance->evt_detail)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct megasas_evt_detail),\n\t\t\t\t    instance->evt_detail,\n\t\t\t\t    instance->evt_detail_h);\n\n\tif (fusion && fusion->ioc_init_request)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t  sizeof(struct MPI2_IOC_INIT_REQUEST),\n\t\t\t\t  fusion->ioc_init_request,\n\t\t\t\t  fusion->ioc_init_request_phys);\n\n\tif (instance->pd_list_buf)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t    MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST),\n\t\t\t\t    instance->pd_list_buf,\n\t\t\t\t    instance->pd_list_buf_h);\n\n\tif (instance->ld_list_buf)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_LD_LIST),\n\t\t\t\t    instance->ld_list_buf,\n\t\t\t\t    instance->ld_list_buf_h);\n\n\tif (instance->ld_targetid_list_buf)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_LD_TARGETID_LIST),\n\t\t\t\t    instance->ld_targetid_list_buf,\n\t\t\t\t    instance->ld_targetid_list_buf_h);\n\n\tif (instance->ctrl_info_buf)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct megasas_ctrl_info),\n\t\t\t\t    instance->ctrl_info_buf,\n\t\t\t\t    instance->ctrl_info_buf_h);\n\n\tif (instance->system_info_buf)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_DRV_SYSTEM_INFO),\n\t\t\t\t    instance->system_info_buf,\n\t\t\t\t    instance->system_info_h);\n\n\tif (instance->pd_info)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_PD_INFO),\n\t\t\t\t    instance->pd_info, instance->pd_info_h);\n\n\tif (instance->tgt_prop)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_TARGET_PROPERTIES),\n\t\t\t\t    instance->tgt_prop, instance->tgt_prop_h);\n\n\tif (instance->crash_dump_buf)\n\t\tdma_free_coherent(&pdev->dev, CRASH_DMA_BUF_SIZE,\n\t\t\t\t    instance->crash_dump_buf,\n\t\t\t\t    instance->crash_dump_h);\n\n\tif (instance->snapdump_prop)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t  sizeof(struct MR_SNAPDUMP_PROPERTIES),\n\t\t\t\t  instance->snapdump_prop,\n\t\t\t\t  instance->snapdump_prop_h);\n\n\tif (instance->host_device_list_buf)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t  HOST_DEVICE_LIST_SZ,\n\t\t\t\t  instance->host_device_list_buf,\n\t\t\t\t  instance->host_device_list_buf_h);\n\n}\n\n/*\n * megasas_init_ctrl_params -\t\tInitialize controller's instance\n *\t\t\t\t\tparameters before FW init\n * @instance -\t\t\t\tAdapter soft instance\n * @return -\t\t\t\tvoid\n */\nstatic inline void megasas_init_ctrl_params(struct megasas_instance *instance)\n{\n\tinstance->fw_crash_state = UNAVAILABLE;\n\n\tmegasas_poll_wait_aen = 0;\n\tinstance->issuepend_done = 1;\n\tatomic_set(&instance->adprecovery, MEGASAS_HBA_OPERATIONAL);\n\n\t/*\n\t * Initialize locks and queues\n\t */\n\tINIT_LIST_HEAD(&instance->cmd_pool);\n\tINIT_LIST_HEAD(&instance->internal_reset_pending_q);\n\n\tatomic_set(&instance->fw_outstanding, 0);\n\tatomic64_set(&instance->total_io_count, 0);\n\n\tinit_waitqueue_head(&instance->int_cmd_wait_q);\n\tinit_waitqueue_head(&instance->abort_cmd_wait_q);\n\n\tspin_lock_init(&instance->crashdump_lock);\n\tspin_lock_init(&instance->mfi_pool_lock);\n\tspin_lock_init(&instance->hba_lock);\n\tspin_lock_init(&instance->stream_lock);\n\tspin_lock_init(&instance->completion_lock);\n\n\tmutex_init(&instance->reset_mutex);\n\n\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t    (instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY))\n\t\tinstance->flag_ieee = 1;\n\n\tmegasas_dbg_lvl = 0;\n\tinstance->flag = 0;\n\tinstance->unload = 1;\n\tinstance->last_time = 0;\n\tinstance->disableOnlineCtrlReset = 1;\n\tinstance->UnevenSpanSupport = 0;\n\tinstance->smp_affinity_enable = smp_affinity_enable ? true : false;\n\tinstance->msix_load_balance = false;\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tINIT_WORK(&instance->work_init, megasas_fusion_ocr_wq);\n\telse\n\t\tINIT_WORK(&instance->work_init, process_fw_state_change_wq);\n}\n\n/**\n * megasas_probe_one -\tPCI hotplug entry point\n * @pdev:\t\tPCI device structure\n * @id:\t\t\tPCI ids of supported hotplugged adapter\n */\nstatic int megasas_probe_one(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *id)\n{\n\tint rval, pos;\n\tstruct Scsi_Host *host;\n\tstruct megasas_instance *instance;\n\tu16 control = 0;\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_LSI_AERO_10E0:\n\tcase PCI_DEVICE_ID_LSI_AERO_10E3:\n\tcase PCI_DEVICE_ID_LSI_AERO_10E4:\n\tcase PCI_DEVICE_ID_LSI_AERO_10E7:\n\t\tdev_err(&pdev->dev, \"Adapter is in non secure mode\\n\");\n\t\treturn 1;\n\tcase PCI_DEVICE_ID_LSI_AERO_10E1:\n\tcase PCI_DEVICE_ID_LSI_AERO_10E5:\n\t\tdev_info(&pdev->dev, \"Adapter is in configurable secure mode\\n\");\n\t\tbreak;\n\t}\n\n\t/* Reset MSI-X in the kdump kernel */\n\tif (reset_devices) {\n\t\tpos = pci_find_capability(pdev, PCI_CAP_ID_MSIX);\n\t\tif (pos) {\n\t\t\tpci_read_config_word(pdev, pos + PCI_MSIX_FLAGS,\n\t\t\t\t\t     &control);\n\t\t\tif (control & PCI_MSIX_FLAGS_ENABLE) {\n\t\t\t\tdev_info(&pdev->dev, \"resetting MSI-X\\n\");\n\t\t\t\tpci_write_config_word(pdev,\n\t\t\t\t\t\t      pos + PCI_MSIX_FLAGS,\n\t\t\t\t\t\t      control &\n\t\t\t\t\t\t      ~PCI_MSIX_FLAGS_ENABLE);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * PCI prepping: enable device set bus mastering and dma mask\n\t */\n\trval = pci_enable_device_mem(pdev);\n\n\tif (rval) {\n\t\treturn rval;\n\t}\n\n\tpci_set_master(pdev);\n\n\thost = scsi_host_alloc(&megasas_template,\n\t\t\t       sizeof(struct megasas_instance));\n\n\tif (!host) {\n\t\tdev_printk(KERN_DEBUG, &pdev->dev, \"scsi_host_alloc failed\\n\");\n\t\tgoto fail_alloc_instance;\n\t}\n\n\tinstance = (struct megasas_instance *)host->hostdata;\n\tmemset(instance, 0, sizeof(*instance));\n\tatomic_set(&instance->fw_reset_no_pci_access, 0);\n\n\t/*\n\t * Initialize PCI related and misc parameters\n\t */\n\tinstance->pdev = pdev;\n\tinstance->host = host;\n\tinstance->unique_id = pdev->bus->number << 8 | pdev->devfn;\n\tinstance->init_id = MEGASAS_DEFAULT_INIT_ID;\n\n\tmegasas_set_adapter_type(instance);\n\n\t/*\n\t * Initialize MFI Firmware\n\t */\n\tif (megasas_init_fw(instance))\n\t\tgoto fail_init_mfi;\n\n\tif (instance->requestorId) {\n\t\tif (instance->PlasmaFW111) {\n\t\t\tinstance->vf_affiliation_111 =\n\t\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\tsizeof(struct MR_LD_VF_AFFILIATION_111),\n\t\t\t\t\t&instance->vf_affiliation_111_h,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!instance->vf_affiliation_111)\n\t\t\t\tdev_warn(&pdev->dev, \"Can't allocate \"\n\t\t\t\t       \"memory for VF affiliation buffer\\n\");\n\t\t} else {\n\t\t\tinstance->vf_affiliation =\n\t\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t(MAX_LOGICAL_DRIVES + 1) *\n\t\t\t\t\tsizeof(struct MR_LD_VF_AFFILIATION),\n\t\t\t\t\t&instance->vf_affiliation_h,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!instance->vf_affiliation)\n\t\t\t\tdev_warn(&pdev->dev, \"Can't allocate \"\n\t\t\t\t       \"memory for VF affiliation buffer\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * Store instance in PCI softstate\n\t */\n\tpci_set_drvdata(pdev, instance);\n\n\t/*\n\t * Add this controller to megasas_mgmt_info structure so that it\n\t * can be exported to management applications\n\t */\n\tmegasas_mgmt_info.count++;\n\tmegasas_mgmt_info.instance[megasas_mgmt_info.max_index] = instance;\n\tmegasas_mgmt_info.max_index++;\n\n\t/*\n\t * Register with SCSI mid-layer\n\t */\n\tif (megasas_io_attach(instance))\n\t\tgoto fail_io_attach;\n\n\tinstance->unload = 0;\n\t/*\n\t * Trigger SCSI to scan our drives\n\t */\n\tif (!instance->enable_fw_dev_list ||\n\t    (instance->host_device_list_buf->count > 0))\n\t\tscsi_scan_host(host);\n\n\t/*\n\t * Initiate AEN (Asynchronous Event Notification)\n\t */\n\tif (megasas_start_aen(instance)) {\n\t\tdev_printk(KERN_DEBUG, &pdev->dev, \"start aen failed\\n\");\n\t\tgoto fail_start_aen;\n\t}\n\n\tmegasas_setup_debugfs(instance);\n\n\t/* Get current SR-IOV LD/VF affiliation */\n\tif (instance->requestorId)\n\t\tmegasas_get_ld_vf_affiliation(instance, 1);\n\n\treturn 0;\n\nfail_start_aen:\nfail_io_attach:\n\tmegasas_mgmt_info.count--;\n\tmegasas_mgmt_info.max_index--;\n\tmegasas_mgmt_info.instance[megasas_mgmt_info.max_index] = NULL;\n\n\tinstance->instancet->disable_intr(instance);\n\tmegasas_destroy_irqs(instance);\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tmegasas_release_fusion(instance);\n\telse\n\t\tmegasas_release_mfi(instance);\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\nfail_init_mfi:\n\tscsi_host_put(host);\nfail_alloc_instance:\n\tpci_disable_device(pdev);\n\n\treturn -ENODEV;\n}\n\n/**\n * megasas_flush_cache -\tRequests FW to flush all its caches\n * @instance:\t\t\tAdapter soft state\n */\nstatic void megasas_flush_cache(struct megasas_instance *instance)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR)\n\t\treturn;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd)\n\t\treturn;\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0x0;\n\tdcmd->sge_count = 0;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_NONE);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = 0;\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_CACHE_FLUSH);\n\tdcmd->mbox.b[0] = MR_FLUSH_CTRL_CACHE | MR_FLUSH_DISK_CACHE;\n\n\tif (megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS)\n\t\t\t!= DCMD_SUCCESS) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"return from %s %d\\n\", __func__, __LINE__);\n\t\treturn;\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n}\n\n/**\n * megasas_shutdown_controller -\tInstructs FW to shutdown the controller\n * @instance:\t\t\t\tAdapter soft state\n * @opcode:\t\t\t\tShutdown/Hibernate\n */\nstatic void megasas_shutdown_controller(struct megasas_instance *instance,\n\t\t\t\t\tu32 opcode)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR)\n\t\treturn;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd)\n\t\treturn;\n\n\tif (instance->aen_cmd)\n\t\tmegasas_issue_blocked_abort_cmd(instance,\n\t\t\tinstance->aen_cmd, MFI_IO_TIMEOUT_SECS);\n\tif (instance->map_update_cmd)\n\t\tmegasas_issue_blocked_abort_cmd(instance,\n\t\t\tinstance->map_update_cmd, MFI_IO_TIMEOUT_SECS);\n\tif (instance->jbod_seq_cmd)\n\t\tmegasas_issue_blocked_abort_cmd(instance,\n\t\t\tinstance->jbod_seq_cmd, MFI_IO_TIMEOUT_SECS);\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0x0;\n\tdcmd->sge_count = 0;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_NONE);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = 0;\n\tdcmd->opcode = cpu_to_le32(opcode);\n\n\tif (megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS)\n\t\t\t!= DCMD_SUCCESS) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"return from %s %d\\n\", __func__, __LINE__);\n\t\treturn;\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n}\n\n#ifdef CONFIG_PM\n/**\n * megasas_suspend -\tdriver suspend entry point\n * @pdev:\t\tPCI device structure\n * @state:\t\tPCI power state to suspend routine\n */\nstatic int\nmegasas_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct megasas_instance *instance;\n\n\tinstance = pci_get_drvdata(pdev);\n\n\tif (!instance)\n\t\treturn 0;\n\n\tinstance->unload = 1;\n\n\tdev_info(&pdev->dev, \"%s is called\\n\", __func__);\n\n\t/* Shutdown SR-IOV heartbeat timer */\n\tif (instance->requestorId && !instance->skip_heartbeat_timer_del)\n\t\tdel_timer_sync(&instance->sriov_heartbeat_timer);\n\n\t/* Stop the FW fault detection watchdog */\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tmegasas_fusion_stop_watchdog(instance);\n\n\tmegasas_flush_cache(instance);\n\tmegasas_shutdown_controller(instance, MR_DCMD_HIBERNATE_SHUTDOWN);\n\n\t/* cancel the delayed work if this work still in queue */\n\tif (instance->ev != NULL) {\n\t\tstruct megasas_aen_event *ev = instance->ev;\n\t\tcancel_delayed_work_sync(&ev->hotplug_work);\n\t\tinstance->ev = NULL;\n\t}\n\n\ttasklet_kill(&instance->isr_tasklet);\n\n\tpci_set_drvdata(instance->pdev, instance);\n\tinstance->instancet->disable_intr(instance);\n\n\tmegasas_destroy_irqs(instance);\n\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\n\n\tpci_save_state(pdev);\n\tpci_disable_device(pdev);\n\n\tpci_set_power_state(pdev, pci_choose_state(pdev, state));\n\n\treturn 0;\n}\n\n/**\n * megasas_resume-      driver resume entry point\n * @pdev:               PCI device structure\n */\nstatic int\nmegasas_resume(struct pci_dev *pdev)\n{\n\tint rval;\n\tstruct Scsi_Host *host;\n\tstruct megasas_instance *instance;\n\tu32 status_reg;\n\n\tinstance = pci_get_drvdata(pdev);\n\n\tif (!instance)\n\t\treturn 0;\n\n\thost = instance->host;\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_enable_wake(pdev, PCI_D0, 0);\n\tpci_restore_state(pdev);\n\n\tdev_info(&pdev->dev, \"%s is called\\n\", __func__);\n\t/*\n\t * PCI prepping: enable device set bus mastering and dma mask\n\t */\n\trval = pci_enable_device_mem(pdev);\n\n\tif (rval) {\n\t\tdev_err(&pdev->dev, \"Enable device failed\\n\");\n\t\treturn rval;\n\t}\n\n\tpci_set_master(pdev);\n\n\t/*\n\t * We expect the FW state to be READY\n\t */\n\n\tif (megasas_transition_to_ready(instance, 0)) {\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"Failed to transition controller to ready from %s!\\n\",\n\t\t\t __func__);\n\t\tif (instance->adapter_type != MFI_SERIES) {\n\t\t\tstatus_reg =\n\t\t\t\tinstance->instancet->read_fw_status_reg(instance);\n\t\t\tif (!(status_reg & MFI_RESET_ADAPTER) ||\n\t\t\t\t((megasas_adp_reset_wait_for_ready\n\t\t\t\t(instance, true, 0)) == FAILED))\n\t\t\t\tgoto fail_ready_state;\n\t\t} else {\n\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 1);\n\t\t\tinstance->instancet->adp_reset\n\t\t\t\t(instance, instance->reg_set);\n\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 0);\n\n\t\t\t/* waiting for about 30 seconds before retry */\n\t\t\tssleep(30);\n\n\t\t\tif (megasas_transition_to_ready(instance, 0))\n\t\t\t\tgoto fail_ready_state;\n\t\t}\n\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"FW restarted successfully from %s!\\n\",\n\t\t\t __func__);\n\t}\n\tif (megasas_set_dma_mask(instance))\n\t\tgoto fail_set_dma_mask;\n\n\t/*\n\t * Initialize MFI Firmware\n\t */\n\n\tatomic_set(&instance->fw_outstanding, 0);\n\tatomic_set(&instance->ldio_outstanding, 0);\n\n\t/* Now re-enable MSI-X */\n\tif (instance->msix_vectors)\n\t\tmegasas_alloc_irq_vectors(instance);\n\n\tif (!instance->msix_vectors) {\n\t\trval = pci_alloc_irq_vectors(instance->pdev, 1, 1,\n\t\t\t\t\t     PCI_IRQ_LEGACY);\n\t\tif (rval < 0)\n\t\t\tgoto fail_reenable_msix;\n\t}\n\n\tmegasas_setup_reply_map(instance);\n\n\tif (instance->adapter_type != MFI_SERIES) {\n\t\tmegasas_reset_reply_desc(instance);\n\t\tif (megasas_ioc_init_fusion(instance)) {\n\t\t\tmegasas_free_cmds(instance);\n\t\t\tmegasas_free_cmds_fusion(instance);\n\t\t\tgoto fail_init_mfi;\n\t\t}\n\t\tif (!megasas_get_map_info(instance))\n\t\t\tmegasas_sync_map_info(instance);\n\t} else {\n\t\t*instance->producer = 0;\n\t\t*instance->consumer = 0;\n\t\tif (megasas_issue_init_mfi(instance))\n\t\t\tgoto fail_init_mfi;\n\t}\n\n\tif (megasas_get_ctrl_info(instance) != DCMD_SUCCESS)\n\t\tgoto fail_init_mfi;\n\n\ttasklet_init(&instance->isr_tasklet, instance->instancet->tasklet,\n\t\t     (unsigned long)instance);\n\n\tif (instance->msix_vectors ?\n\t\t\tmegasas_setup_irqs_msix(instance, 0) :\n\t\t\tmegasas_setup_irqs_ioapic(instance))\n\t\tgoto fail_init_mfi;\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tmegasas_setup_irq_poll(instance);\n\n\t/* Re-launch SR-IOV heartbeat timer */\n\tif (instance->requestorId) {\n\t\tif (!megasas_sriov_start_heartbeat(instance, 0))\n\t\t\tmegasas_start_timer(instance);\n\t\telse {\n\t\t\tinstance->skip_heartbeat_timer_del = 1;\n\t\t\tgoto fail_init_mfi;\n\t\t}\n\t}\n\n\tinstance->instancet->enable_intr(instance);\n\tmegasas_setup_jbod_map(instance);\n\tinstance->unload = 0;\n\n\t/*\n\t * Initiate AEN (Asynchronous Event Notification)\n\t */\n\tif (megasas_start_aen(instance))\n\t\tdev_err(&instance->pdev->dev, \"Start AEN failed\\n\");\n\n\t/* Re-launch FW fault watchdog */\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tif (megasas_fusion_start_watchdog(instance) != SUCCESS)\n\t\t\tgoto fail_start_watchdog;\n\n\treturn 0;\n\nfail_start_watchdog:\n\tif (instance->requestorId && !instance->skip_heartbeat_timer_del)\n\t\tdel_timer_sync(&instance->sriov_heartbeat_timer);\nfail_init_mfi:\n\tmegasas_free_ctrl_dma_buffers(instance);\n\tmegasas_free_ctrl_mem(instance);\n\tscsi_host_put(host);\n\nfail_reenable_msix:\nfail_set_dma_mask:\nfail_ready_state:\n\n\tpci_disable_device(pdev);\n\n\treturn -ENODEV;\n}\n#else\n#define megasas_suspend\tNULL\n#define megasas_resume\tNULL\n#endif\n\nstatic inline int\nmegasas_wait_for_adapter_operational(struct megasas_instance *instance)\n{\n\tint wait_time = MEGASAS_RESET_WAIT_TIME * 2;\n\tint i;\n\tu8 adp_state;\n\n\tfor (i = 0; i < wait_time; i++) {\n\t\tadp_state = atomic_read(&instance->adprecovery);\n\t\tif ((adp_state == MEGASAS_HBA_OPERATIONAL) ||\n\t\t    (adp_state == MEGASAS_HW_CRITICAL_ERROR))\n\t\t\tbreak;\n\n\t\tif (!(i % MEGASAS_RESET_NOTICE_INTERVAL))\n\t\t\tdev_notice(&instance->pdev->dev, \"waiting for controller reset to finish\\n\");\n\n\t\tmsleep(1000);\n\t}\n\n\tif (adp_state != MEGASAS_HBA_OPERATIONAL) {\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"%s HBA failed to become operational, adp_state %d\\n\",\n\t\t\t __func__, adp_state);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * megasas_detach_one -\tPCI hot\"un\"plug entry point\n * @pdev:\t\tPCI device structure\n */\nstatic void megasas_detach_one(struct pci_dev *pdev)\n{\n\tint i;\n\tstruct Scsi_Host *host;\n\tstruct megasas_instance *instance;\n\tstruct fusion_context *fusion;\n\tu32 pd_seq_map_sz;\n\n\tinstance = pci_get_drvdata(pdev);\n\n\tif (!instance)\n\t\treturn;\n\n\thost = instance->host;\n\tfusion = instance->ctrl_context;\n\n\t/* Shutdown SR-IOV heartbeat timer */\n\tif (instance->requestorId && !instance->skip_heartbeat_timer_del)\n\t\tdel_timer_sync(&instance->sriov_heartbeat_timer);\n\n\t/* Stop the FW fault detection watchdog */\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tmegasas_fusion_stop_watchdog(instance);\n\n\tif (instance->fw_crash_state != UNAVAILABLE)\n\t\tmegasas_free_host_crash_buffer(instance);\n\tscsi_remove_host(instance->host);\n\tinstance->unload = 1;\n\n\tif (megasas_wait_for_adapter_operational(instance))\n\t\tgoto skip_firing_dcmds;\n\n\tmegasas_flush_cache(instance);\n\tmegasas_shutdown_controller(instance, MR_DCMD_CTRL_SHUTDOWN);\n\nskip_firing_dcmds:\n\t/* cancel the delayed work if this work still in queue*/\n\tif (instance->ev != NULL) {\n\t\tstruct megasas_aen_event *ev = instance->ev;\n\t\tcancel_delayed_work_sync(&ev->hotplug_work);\n\t\tinstance->ev = NULL;\n\t}\n\n\t/* cancel all wait events */\n\twake_up_all(&instance->int_cmd_wait_q);\n\n\ttasklet_kill(&instance->isr_tasklet);\n\n\t/*\n\t * Take the instance off the instance array. Note that we will not\n\t * decrement the max_index. We let this array be sparse array\n\t */\n\tfor (i = 0; i < megasas_mgmt_info.max_index; i++) {\n\t\tif (megasas_mgmt_info.instance[i] == instance) {\n\t\t\tmegasas_mgmt_info.count--;\n\t\t\tmegasas_mgmt_info.instance[i] = NULL;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinstance->instancet->disable_intr(instance);\n\n\tmegasas_destroy_irqs(instance);\n\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\n\n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\tfor (i = 0; i < MAX_LOGICAL_DRIVES_EXT; ++i)\n\t\t\tkfree(fusion->stream_detect_by_ld[i]);\n\t\tkfree(fusion->stream_detect_by_ld);\n\t\tfusion->stream_detect_by_ld = NULL;\n\t}\n\n\n\tif (instance->adapter_type != MFI_SERIES) {\n\t\tmegasas_release_fusion(instance);\n\t\t\tpd_seq_map_sz = sizeof(struct MR_PD_CFG_SEQ_NUM_SYNC) +\n\t\t\t\t(sizeof(struct MR_PD_CFG_SEQ) *\n\t\t\t\t\t(MAX_PHYSICAL_DEVICES - 1));\n\t\tfor (i = 0; i < 2 ; i++) {\n\t\t\tif (fusion->ld_map[i])\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\t\t  fusion->max_map_sz,\n\t\t\t\t\t\t  fusion->ld_map[i],\n\t\t\t\t\t\t  fusion->ld_map_phys[i]);\n\t\t\tif (fusion->ld_drv_map[i]) {\n\t\t\t\tif (is_vmalloc_addr(fusion->ld_drv_map[i]))\n\t\t\t\t\tvfree(fusion->ld_drv_map[i]);\n\t\t\t\telse\n\t\t\t\t\tfree_pages((ulong)fusion->ld_drv_map[i],\n\t\t\t\t\t\t   fusion->drv_map_pages);\n\t\t\t}\n\n\t\t\tif (fusion->pd_seq_sync[i])\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\tpd_seq_map_sz,\n\t\t\t\t\tfusion->pd_seq_sync[i],\n\t\t\t\t\tfusion->pd_seq_phys[i]);\n\t\t}\n\t} else {\n\t\tmegasas_release_mfi(instance);\n\t}\n\n\tif (instance->vf_affiliation)\n\t\tdma_free_coherent(&pdev->dev, (MAX_LOGICAL_DRIVES + 1) *\n\t\t\t\t    sizeof(struct MR_LD_VF_AFFILIATION),\n\t\t\t\t    instance->vf_affiliation,\n\t\t\t\t    instance->vf_affiliation_h);\n\n\tif (instance->vf_affiliation_111)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t    sizeof(struct MR_LD_VF_AFFILIATION_111),\n\t\t\t\t    instance->vf_affiliation_111,\n\t\t\t\t    instance->vf_affiliation_111_h);\n\n\tif (instance->hb_host_mem)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_CTRL_HB_HOST_MEM),\n\t\t\t\t    instance->hb_host_mem,\n\t\t\t\t    instance->hb_host_mem_h);\n\n\tmegasas_free_ctrl_dma_buffers(instance);\n\n\tmegasas_free_ctrl_mem(instance);\n\n\tmegasas_destroy_debugfs(instance);\n\n\tscsi_host_put(host);\n\n\tpci_disable_device(pdev);\n}\n\n/**\n * megasas_shutdown -\tShutdown entry point\n * @pdev:\t\tGeneric device structure\n */\nstatic void megasas_shutdown(struct pci_dev *pdev)\n{\n\tstruct megasas_instance *instance = pci_get_drvdata(pdev);\n\n\tif (!instance)\n\t\treturn;\n\n\tinstance->unload = 1;\n\n\tif (megasas_wait_for_adapter_operational(instance))\n\t\tgoto skip_firing_dcmds;\n\n\tmegasas_flush_cache(instance);\n\tmegasas_shutdown_controller(instance, MR_DCMD_CTRL_SHUTDOWN);\n\nskip_firing_dcmds:\n\tinstance->instancet->disable_intr(instance);\n\tmegasas_destroy_irqs(instance);\n\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\n}\n\n/*\n * megasas_mgmt_open -\tchar node \"open\" entry point\n * @inode:\tchar node inode\n * @filep:\tchar node file\n */\nstatic int megasas_mgmt_open(struct inode *inode, struct file *filep)\n{\n\t/*\n\t * Allow only those users with admin rights\n\t */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\n/*\n * megasas_mgmt_fasync -\tAsync notifier registration from applications\n * @fd:\t\tchar node file descriptor number\n * @filep:\tchar node file\n * @mode:\tnotifier on/off\n *\n * This function adds the calling process to a driver global queue. When an\n * event occurs, SIGIO will be sent to all processes in this queue.\n */\nstatic int megasas_mgmt_fasync(int fd, struct file *filep, int mode)\n{\n\tint rc;\n\n\tmutex_lock(&megasas_async_queue_mutex);\n\n\trc = fasync_helper(fd, filep, mode, &megasas_async_queue);\n\n\tmutex_unlock(&megasas_async_queue_mutex);\n\n\tif (rc >= 0) {\n\t\t/* For sanity check when we get ioctl */\n\t\tfilep->private_data = filep;\n\t\treturn 0;\n\t}\n\n\tprintk(KERN_DEBUG \"megasas: fasync_helper failed [%d]\\n\", rc);\n\n\treturn rc;\n}\n\n/*\n * megasas_mgmt_poll -  char node \"poll\" entry point\n * @filep:\tchar node file\n * @wait:\tEvents to poll for\n */\nstatic __poll_t megasas_mgmt_poll(struct file *file, poll_table *wait)\n{\n\t__poll_t mask;\n\tunsigned long flags;\n\n\tpoll_wait(file, &megasas_poll_wait, wait);\n\tspin_lock_irqsave(&poll_aen_lock, flags);\n\tif (megasas_poll_wait_aen)\n\t\tmask = (EPOLLIN | EPOLLRDNORM);\n\telse\n\t\tmask = 0;\n\tmegasas_poll_wait_aen = 0;\n\tspin_unlock_irqrestore(&poll_aen_lock, flags);\n\treturn mask;\n}\n\n/*\n * megasas_set_crash_dump_params_ioctl:\n *\t\tSend CRASH_DUMP_MODE DCMD to all controllers\n * @cmd:\tMFI command frame\n */\n\nstatic int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)\n{\n\tstruct megasas_instance *local_instance;\n\tint i, error = 0;\n\tint crash_support;\n\n\tcrash_support = cmd->frame->dcmd.mbox.w[0];\n\n\tfor (i = 0; i < megasas_mgmt_info.max_index; i++) {\n\t\tlocal_instance = megasas_mgmt_info.instance[i];\n\t\tif (local_instance && local_instance->crash_dump_drv_support) {\n\t\t\tif ((atomic_read(&local_instance->adprecovery) ==\n\t\t\t\tMEGASAS_HBA_OPERATIONAL) &&\n\t\t\t\t!megasas_set_crash_dump_params(local_instance,\n\t\t\t\t\tcrash_support)) {\n\t\t\t\tlocal_instance->crash_dump_app_support =\n\t\t\t\t\tcrash_support;\n\t\t\t\tdev_info(&local_instance->pdev->dev,\n\t\t\t\t\t\"Application firmware crash \"\n\t\t\t\t\t\"dump mode set success\\n\");\n\t\t\t\terror = 0;\n\t\t\t} else {\n\t\t\t\tdev_info(&local_instance->pdev->dev,\n\t\t\t\t\t\"Application firmware crash \"\n\t\t\t\t\t\"dump mode set failed\\n\");\n\t\t\t\terror = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn error;\n}\n\n/**\n * megasas_mgmt_fw_ioctl -\tIssues management ioctls to FW\n * @instance:\t\t\tAdapter soft state\n * @user_ioc:\t\t\tUser's ioctl packet\n * @ioc:\t\t\tioctl packet\n */\nstatic int\nmegasas_mgmt_fw_ioctl(struct megasas_instance *instance,\n\t\t      struct megasas_iocpacket __user * user_ioc,\n\t\t      struct megasas_iocpacket *ioc)\n{\n\tstruct megasas_sge64 *kern_sge64 = NULL;\n\tstruct megasas_sge32 *kern_sge32 = NULL;\n\tstruct megasas_cmd *cmd;\n\tvoid *kbuff_arr[MAX_IOCTL_SGE];\n\tdma_addr_t buf_handle = 0;\n\tint error = 0, i;\n\tvoid *sense = NULL;\n\tdma_addr_t sense_handle;\n\tvoid *sense_ptr;\n\tu32 opcode = 0;\n\tint ret = DCMD_SUCCESS;\n\n\tmemset(kbuff_arr, 0, sizeof(kbuff_arr));\n\n\tif (ioc->sge_count > MAX_IOCTL_SGE) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"SGE count [%d] >  max limit [%d]\\n\",\n\t\t       ioc->sge_count, MAX_IOCTL_SGE);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((ioc->frame.hdr.cmd >= MFI_CMD_OP_COUNT) ||\n\t    ((ioc->frame.hdr.cmd == MFI_CMD_NVME) &&\n\t    !instance->support_nvme_passthru) ||\n\t    ((ioc->frame.hdr.cmd == MFI_CMD_TOOLBOX) &&\n\t    !instance->support_pci_lane_margining)) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Received invalid ioctl command 0x%x\\n\",\n\t\t\tioc->frame.hdr.cmd);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tcmd = megasas_get_cmd(instance);\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to get a cmd packet\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * User's IOCTL packet has 2 frames (maximum). Copy those two\n\t * frames into our cmd's frames. cmd->frame's context will get\n\t * overwritten when we copy from user's frames. So set that value\n\t * alone separately\n\t */\n\tmemcpy(cmd->frame, ioc->frame.raw, 2 * MEGAMFI_FRAME_SIZE);\n\tcmd->frame->hdr.context = cpu_to_le32(cmd->index);\n\tcmd->frame->hdr.pad_0 = 0;\n\n\tcmd->frame->hdr.flags &= (~MFI_FRAME_IEEE);\n\n\tif (instance->consistent_mask_64bit)\n\t\tcmd->frame->hdr.flags |= cpu_to_le16((MFI_FRAME_SGL64 |\n\t\t\t\t       MFI_FRAME_SENSE64));\n\telse\n\t\tcmd->frame->hdr.flags &= cpu_to_le16(~(MFI_FRAME_SGL64 |\n\t\t\t\t\t       MFI_FRAME_SENSE64));\n\n\tif (cmd->frame->hdr.cmd == MFI_CMD_DCMD)\n\t\topcode = le32_to_cpu(cmd->frame->dcmd.opcode);\n\n\tif (opcode == MR_DCMD_CTRL_SHUTDOWN) {\n\t\tmutex_lock(&instance->reset_mutex);\n\t\tif (megasas_get_ctrl_info(instance) != DCMD_SUCCESS) {\n\t\t\tmegasas_return_cmd(instance, cmd);\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\treturn -1;\n\t\t}\n\t\tmutex_unlock(&instance->reset_mutex);\n\t}\n\n\tif (opcode == MR_DRIVER_SET_APP_CRASHDUMP_MODE) {\n\t\terror = megasas_set_crash_dump_params_ioctl(cmd);\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn error;\n\t}\n\n\t/*\n\t * The management interface between applications and the fw uses\n\t * MFI frames. E.g, RAID configuration changes, LD property changes\n\t * etc are accomplishes through different kinds of MFI frames. The\n\t * driver needs to care only about substituting user buffers with\n\t * kernel buffers in SGLs. The location of SGL is embedded in the\n\t * struct iocpacket itself.\n\t */\n\tif (instance->consistent_mask_64bit)\n\t\tkern_sge64 = (struct megasas_sge64 *)\n\t\t\t((unsigned long)cmd->frame + ioc->sgl_off);\n\telse\n\t\tkern_sge32 = (struct megasas_sge32 *)\n\t\t\t((unsigned long)cmd->frame + ioc->sgl_off);\n\n\t/*\n\t * For each user buffer, create a mirror buffer and copy in\n\t */\n\tfor (i = 0; i < ioc->sge_count; i++) {\n\t\tif (!ioc->sgl[i].iov_len)\n\t\t\tcontinue;\n\n\t\tkbuff_arr[i] = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\t\t\t\t    ioc->sgl[i].iov_len,\n\t\t\t\t\t\t    &buf_handle, GFP_KERNEL);\n\t\tif (!kbuff_arr[i]) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to alloc \"\n\t\t\t       \"kernel SGL buffer for IOCTL\\n\");\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We don't change the dma_coherent_mask, so\n\t\t * dma_alloc_coherent only returns 32bit addresses\n\t\t */\n\t\tif (instance->consistent_mask_64bit) {\n\t\t\tkern_sge64[i].phys_addr = cpu_to_le64(buf_handle);\n\t\t\tkern_sge64[i].length = cpu_to_le32(ioc->sgl[i].iov_len);\n\t\t} else {\n\t\t\tkern_sge32[i].phys_addr = cpu_to_le32(buf_handle);\n\t\t\tkern_sge32[i].length = cpu_to_le32(ioc->sgl[i].iov_len);\n\t\t}\n\n\t\t/*\n\t\t * We created a kernel buffer corresponding to the\n\t\t * user buffer. Now copy in from the user buffer\n\t\t */\n\t\tif (copy_from_user(kbuff_arr[i], ioc->sgl[i].iov_base,\n\t\t\t\t   (u32) (ioc->sgl[i].iov_len))) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ioc->sense_len) {\n\t\t/* make sure the pointer is part of the frame */\n\t\tif (ioc->sense_off >\n\t\t    (sizeof(union megasas_frame) - sizeof(__le64))) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsense = dma_alloc_coherent(&instance->pdev->dev, ioc->sense_len,\n\t\t\t\t\t     &sense_handle, GFP_KERNEL);\n\t\tif (!sense) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsense_ptr = (void *)cmd->frame + ioc->sense_off;\n\t\tif (instance->consistent_mask_64bit)\n\t\t\tput_unaligned_le64(sense_handle, sense_ptr);\n\t\telse\n\t\t\tput_unaligned_le32(sense_handle, sense_ptr);\n\t}\n\n\t/*\n\t * Set the sync_cmd flag so that the ISR knows not to complete this\n\t * cmd to the SCSI mid-layer\n\t */\n\tcmd->sync_cmd = 1;\n\n\tret = megasas_issue_blocked_cmd(instance, cmd, 0);\n\tswitch (ret) {\n\tcase DCMD_INIT:\n\tcase DCMD_BUSY:\n\t\tcmd->sync_cmd = 0;\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"return -EBUSY from %s %d cmd 0x%x opcode 0x%x cmd->cmd_status_drv 0x%x\\n\",\n\t\t\t __func__, __LINE__, cmd->frame->hdr.cmd, opcode,\n\t\t\t cmd->cmd_status_drv);\n\t\terror = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tcmd->sync_cmd = 0;\n\n\tif (instance->unload == 1) {\n\t\tdev_info(&instance->pdev->dev, \"Driver unload is in progress \"\n\t\t\t\"don't submit data to application\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * copy out the kernel buffers to user buffers\n\t */\n\tfor (i = 0; i < ioc->sge_count; i++) {\n\t\tif (copy_to_user(ioc->sgl[i].iov_base, kbuff_arr[i],\n\t\t\t\t ioc->sgl[i].iov_len)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * copy out the sense\n\t */\n\tif (ioc->sense_len) {\n\t\tvoid __user *uptr;\n\t\t/*\n\t\t * sense_ptr points to the location that has the user\n\t\t * sense buffer address\n\t\t */\n\t\tsense_ptr = (void *)ioc->frame.raw + ioc->sense_off;\n\t\tif (in_compat_syscall())\n\t\t\tuptr = compat_ptr(get_unaligned((compat_uptr_t *)\n\t\t\t\t\t\t\tsense_ptr));\n\t\telse\n\t\t\tuptr = get_unaligned((void __user **)sense_ptr);\n\n\t\tif (copy_to_user(uptr, sense, ioc->sense_len)) {\n\t\t\tdev_err(&instance->pdev->dev, \"Failed to copy out to user \"\n\t\t\t\t\t\"sense data\\n\");\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * copy the status codes returned by the fw\n\t */\n\tif (copy_to_user(&user_ioc->frame.hdr.cmd_status,\n\t\t\t &cmd->frame->hdr.cmd_status, sizeof(u8))) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error copying out cmd_status\\n\");\n\t\terror = -EFAULT;\n\t}\n\nout:\n\tif (sense) {\n\t\tdma_free_coherent(&instance->pdev->dev, ioc->sense_len,\n\t\t\t\t    sense, sense_handle);\n\t}\n\n\tfor (i = 0; i < ioc->sge_count; i++) {\n\t\tif (kbuff_arr[i]) {\n\t\t\tif (instance->consistent_mask_64bit)\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\tle32_to_cpu(kern_sge64[i].length),\n\t\t\t\t\tkbuff_arr[i],\n\t\t\t\t\tle64_to_cpu(kern_sge64[i].phys_addr));\n\t\t\telse\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\tle32_to_cpu(kern_sge32[i].length),\n\t\t\t\t\tkbuff_arr[i],\n\t\t\t\t\tle32_to_cpu(kern_sge32[i].phys_addr));\n\t\t\tkbuff_arr[i] = NULL;\n\t\t}\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n\treturn error;\n}\n\nstatic struct megasas_iocpacket *\nmegasas_compat_iocpacket_get_user(void __user *arg)\n{\n\tstruct megasas_iocpacket *ioc;\n\tstruct compat_megasas_iocpacket __user *cioc = arg;\n\tsize_t size;\n\tint err = -EFAULT;\n\tint i;\n\n\tioc = kzalloc(sizeof(*ioc), GFP_KERNEL);\n\tif (!ioc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsize = offsetof(struct megasas_iocpacket, frame) + sizeof(ioc->frame);\n\tif (copy_from_user(ioc, arg, size))\n\t\tgoto out;\n\n\tfor (i = 0; i < MAX_IOCTL_SGE; i++) {\n\t\tcompat_uptr_t iov_base;\n\n\t\tif (get_user(iov_base, &cioc->sgl[i].iov_base) ||\n\t\t    get_user(ioc->sgl[i].iov_len, &cioc->sgl[i].iov_len))\n\t\t\tgoto out;\n\n\t\tioc->sgl[i].iov_base = compat_ptr(iov_base);\n\t}\n\n\treturn ioc;\nout:\n\tkfree(ioc);\n\treturn ERR_PTR(err);\n}\n\nstatic int megasas_mgmt_ioctl_fw(struct file *file, unsigned long arg)\n{\n\tstruct megasas_iocpacket __user *user_ioc =\n\t    (struct megasas_iocpacket __user *)arg;\n\tstruct megasas_iocpacket *ioc;\n\tstruct megasas_instance *instance;\n\tint error;\n\n\tif (in_compat_syscall())\n\t\tioc = megasas_compat_iocpacket_get_user(user_ioc);\n\telse\n\t\tioc = memdup_user(user_ioc, sizeof(struct megasas_iocpacket));\n\n\tif (IS_ERR(ioc))\n\t\treturn PTR_ERR(ioc);\n\n\tinstance = megasas_lookup_instance(ioc->host_no);\n\tif (!instance) {\n\t\terror = -ENODEV;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\t/* Block ioctls in VF mode */\n\tif (instance->requestorId && !allow_vf_ioctls) {\n\t\terror = -ENODEV;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"Controller in crit error\\n\");\n\t\terror = -ENODEV;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\tif (instance->unload == 1) {\n\t\terror = -ENODEV;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\tif (down_interruptible(&instance->ioctl_sem)) {\n\t\terror = -ERESTARTSYS;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\tif  (megasas_wait_for_adapter_operational(instance)) {\n\t\terror = -ENODEV;\n\t\tgoto out_up;\n\t}\n\n\terror = megasas_mgmt_fw_ioctl(instance, user_ioc, ioc);\nout_up:\n\tup(&instance->ioctl_sem);\n\nout_kfree_ioc:\n\tkfree(ioc);\n\treturn error;\n}\n\nstatic int megasas_mgmt_ioctl_aen(struct file *file, unsigned long arg)\n{\n\tstruct megasas_instance *instance;\n\tstruct megasas_aen aen;\n\tint error;\n\n\tif (file->private_data != file) {\n\t\tprintk(KERN_DEBUG \"megasas: fasync_helper was not \"\n\t\t       \"called first\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&aen, (void __user *)arg, sizeof(aen)))\n\t\treturn -EFAULT;\n\n\tinstance = megasas_lookup_instance(aen.host_no);\n\n\tif (!instance)\n\t\treturn -ENODEV;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\treturn -ENODEV;\n\t}\n\n\tif (instance->unload == 1) {\n\t\treturn -ENODEV;\n\t}\n\n\tif  (megasas_wait_for_adapter_operational(instance))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&instance->reset_mutex);\n\terror = megasas_register_aen(instance, aen.seq_num,\n\t\t\t\t     aen.class_locale_word);\n\tmutex_unlock(&instance->reset_mutex);\n\treturn error;\n}\n\n/**\n * megasas_mgmt_ioctl -\tchar node ioctl entry point\n * @file:\tchar device file pointer\n * @cmd:\tioctl command\n * @arg:\tioctl command arguments address\n */\nstatic long\nmegasas_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase MEGASAS_IOC_FIRMWARE:\n\t\treturn megasas_mgmt_ioctl_fw(file, arg);\n\n\tcase MEGASAS_IOC_GET_AEN:\n\t\treturn megasas_mgmt_ioctl_aen(file, arg);\n\t}\n\n\treturn -ENOTTY;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long\nmegasas_mgmt_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase MEGASAS_IOC_FIRMWARE32:\n\t\treturn megasas_mgmt_ioctl_fw(file, arg);\n\tcase MEGASAS_IOC_GET_AEN:\n\t\treturn megasas_mgmt_ioctl_aen(file, arg);\n\t}\n\n\treturn -ENOTTY;\n}\n#endif\n\n/*\n * File operations structure for management interface\n */\nstatic const struct file_operations megasas_mgmt_fops = {\n\t.owner = THIS_MODULE,\n\t.open = megasas_mgmt_open,\n\t.fasync = megasas_mgmt_fasync,\n\t.unlocked_ioctl = megasas_mgmt_ioctl,\n\t.poll = megasas_mgmt_poll,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = megasas_mgmt_compat_ioctl,\n#endif\n\t.llseek = noop_llseek,\n};\n\n/*\n * PCI hotplug support registration structure\n */\nstatic struct pci_driver megasas_pci_driver = {\n\n\t.name = \"megaraid_sas\",\n\t.id_table = megasas_pci_table,\n\t.probe = megasas_probe_one,\n\t.remove = megasas_detach_one,\n\t.suspend = megasas_suspend,\n\t.resume = megasas_resume,\n\t.shutdown = megasas_shutdown,\n};\n\n/*\n * Sysfs driver attributes\n */\nstatic ssize_t version_show(struct device_driver *dd, char *buf)\n{\n\treturn snprintf(buf, strlen(MEGASAS_VERSION) + 2, \"%s\\n\",\n\t\t\tMEGASAS_VERSION);\n}\nstatic DRIVER_ATTR_RO(version);\n\nstatic ssize_t release_date_show(struct device_driver *dd, char *buf)\n{\n\treturn snprintf(buf, strlen(MEGASAS_RELDATE) + 2, \"%s\\n\",\n\t\tMEGASAS_RELDATE);\n}\nstatic DRIVER_ATTR_RO(release_date);\n\nstatic ssize_t support_poll_for_event_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", support_poll_for_event);\n}\nstatic DRIVER_ATTR_RO(support_poll_for_event);\n\nstatic ssize_t support_device_change_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", support_device_change);\n}\nstatic DRIVER_ATTR_RO(support_device_change);\n\nstatic ssize_t dbg_lvl_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", megasas_dbg_lvl);\n}\n\nstatic ssize_t dbg_lvl_store(struct device_driver *dd, const char *buf,\n\t\t\t     size_t count)\n{\n\tint retval = count;\n\n\tif (sscanf(buf, \"%u\", &megasas_dbg_lvl) < 1) {\n\t\tprintk(KERN_ERR \"megasas: could not set dbg_lvl\\n\");\n\t\tretval = -EINVAL;\n\t}\n\treturn retval;\n}\nstatic DRIVER_ATTR_RW(dbg_lvl);\n\nstatic ssize_t\nsupport_nvme_encapsulation_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", support_nvme_encapsulation);\n}\n\nstatic DRIVER_ATTR_RO(support_nvme_encapsulation);\n\nstatic ssize_t\nsupport_pci_lane_margining_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", support_pci_lane_margining);\n}\n\nstatic DRIVER_ATTR_RO(support_pci_lane_margining);\n\nstatic inline void megasas_remove_scsi_device(struct scsi_device *sdev)\n{\n\tsdev_printk(KERN_INFO, sdev, \"SCSI device is removed\\n\");\n\tscsi_remove_device(sdev);\n\tscsi_device_put(sdev);\n}\n\n/**\n * megasas_update_device_list -\tUpdate the PD and LD device list from FW\n *\t\t\t\tafter an AEN event notification\n * @instance:\t\t\tAdapter soft state\n * @event_type:\t\t\tIndicates type of event (PD or LD event)\n *\n * @return:\t\t\tSuccess or failure\n *\n * Issue DCMDs to Firmware to update the internal device list in driver.\n * Based on the FW support, driver sends the HOST_DEVICE_LIST or combination\n * of PD_LIST/LD_LIST_QUERY DCMDs to get the device list.\n */\nstatic\nint megasas_update_device_list(struct megasas_instance *instance,\n\t\t\t       int event_type)\n{\n\tint dcmd_ret = DCMD_SUCCESS;\n\n\tif (instance->enable_fw_dev_list) {\n\t\tdcmd_ret = megasas_host_device_list_query(instance, false);\n\t\tif (dcmd_ret != DCMD_SUCCESS)\n\t\t\tgoto out;\n\t} else {\n\t\tif (event_type & SCAN_PD_CHANNEL) {\n\t\t\tdcmd_ret = megasas_get_pd_list(instance);\n\n\t\t\tif (dcmd_ret != DCMD_SUCCESS)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (event_type & SCAN_VD_CHANNEL) {\n\t\t\tif (!instance->requestorId ||\n\t\t\t    (instance->requestorId &&\n\t\t\t     megasas_get_ld_vf_affiliation(instance, 0))) {\n\t\t\t\tdcmd_ret = megasas_ld_list_query(instance,\n\t\t\t\t\t\tMR_LD_QUERY_TYPE_EXPOSED_TO_HOST);\n\t\t\t\tif (dcmd_ret != DCMD_SUCCESS)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\treturn dcmd_ret;\n}\n\n/**\n * megasas_add_remove_devices -\tAdd/remove devices to SCSI mid-layer\n *\t\t\t\tafter an AEN event notification\n * @instance:\t\t\tAdapter soft state\n * @scan_type:\t\t\tIndicates type of devices (PD/LD) to add\n * @return\t\t\tvoid\n */\nstatic\nvoid megasas_add_remove_devices(struct megasas_instance *instance,\n\t\t\t\tint scan_type)\n{\n\tint i, j;\n\tu16 pd_index = 0;\n\tu16 ld_index = 0;\n\tu16 channel = 0, id = 0;\n\tstruct Scsi_Host *host;\n\tstruct scsi_device *sdev1;\n\tstruct MR_HOST_DEVICE_LIST *targetid_list = NULL;\n\tstruct MR_HOST_DEVICE_LIST_ENTRY *targetid_entry = NULL;\n\n\thost = instance->host;\n\n\tif (instance->enable_fw_dev_list) {\n\t\ttargetid_list = instance->host_device_list_buf;\n\t\tfor (i = 0; i < targetid_list->count; i++) {\n\t\t\ttargetid_entry = &targetid_list->host_device_list[i];\n\t\t\tif (targetid_entry->flags.u.bits.is_sys_pd) {\n\t\t\t\tchannel = le16_to_cpu(targetid_entry->target_id) /\n\t\t\t\t\t\tMEGASAS_MAX_DEV_PER_CHANNEL;\n\t\t\t\tid = le16_to_cpu(targetid_entry->target_id) %\n\t\t\t\t\t\tMEGASAS_MAX_DEV_PER_CHANNEL;\n\t\t\t} else {\n\t\t\t\tchannel = MEGASAS_MAX_PD_CHANNELS +\n\t\t\t\t\t  (le16_to_cpu(targetid_entry->target_id) /\n\t\t\t\t\t   MEGASAS_MAX_DEV_PER_CHANNEL);\n\t\t\t\tid = le16_to_cpu(targetid_entry->target_id) %\n\t\t\t\t\t\tMEGASAS_MAX_DEV_PER_CHANNEL;\n\t\t\t}\n\t\t\tsdev1 = scsi_device_lookup(host, channel, id, 0);\n\t\t\tif (!sdev1) {\n\t\t\t\tscsi_add_device(host, channel, id, 0);\n\t\t\t} else {\n\t\t\t\tscsi_device_put(sdev1);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (scan_type & SCAN_PD_CHANNEL) {\n\t\tfor (i = 0; i < MEGASAS_MAX_PD_CHANNELS; i++) {\n\t\t\tfor (j = 0; j < MEGASAS_MAX_DEV_PER_CHANNEL; j++) {\n\t\t\t\tpd_index = i * MEGASAS_MAX_DEV_PER_CHANNEL + j;\n\t\t\t\tsdev1 = scsi_device_lookup(host, i, j, 0);\n\t\t\t\tif (instance->pd_list[pd_index].driveState ==\n\t\t\t\t\t\t\tMR_PD_STATE_SYSTEM) {\n\t\t\t\t\tif (!sdev1)\n\t\t\t\t\t\tscsi_add_device(host, i, j, 0);\n\t\t\t\t\telse\n\t\t\t\t\t\tscsi_device_put(sdev1);\n\t\t\t\t} else {\n\t\t\t\t\tif (sdev1)\n\t\t\t\t\t\tmegasas_remove_scsi_device(sdev1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (scan_type & SCAN_VD_CHANNEL) {\n\t\tfor (i = 0; i < MEGASAS_MAX_LD_CHANNELS; i++) {\n\t\t\tfor (j = 0; j < MEGASAS_MAX_DEV_PER_CHANNEL; j++) {\n\t\t\t\tld_index = (i * MEGASAS_MAX_DEV_PER_CHANNEL) + j;\n\t\t\t\tsdev1 = scsi_device_lookup(host,\n\t\t\t\t\t\tMEGASAS_MAX_PD_CHANNELS + i, j, 0);\n\t\t\t\tif (instance->ld_ids[ld_index] != 0xff) {\n\t\t\t\t\tif (!sdev1)\n\t\t\t\t\t\tscsi_add_device(host, MEGASAS_MAX_PD_CHANNELS + i, j, 0);\n\t\t\t\t\telse\n\t\t\t\t\t\tscsi_device_put(sdev1);\n\t\t\t\t} else {\n\t\t\t\t\tif (sdev1)\n\t\t\t\t\t\tmegasas_remove_scsi_device(sdev1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nstatic void\nmegasas_aen_polling(struct work_struct *work)\n{\n\tstruct megasas_aen_event *ev =\n\t\tcontainer_of(work, struct megasas_aen_event, hotplug_work.work);\n\tstruct megasas_instance *instance = ev->instance;\n\tunion megasas_evt_class_locale class_locale;\n\tint event_type = 0;\n\tu32 seq_num;\n\tint error;\n\tu8  dcmd_ret = DCMD_SUCCESS;\n\n\tif (!instance) {\n\t\tprintk(KERN_ERR \"invalid instance!\\n\");\n\t\tkfree(ev);\n\t\treturn;\n\t}\n\n\t/* Don't run the event workqueue thread if OCR is running */\n\tmutex_lock(&instance->reset_mutex);\n\n\tinstance->ev = NULL;\n\tif (instance->evt_detail) {\n\t\tmegasas_decode_evt(instance);\n\n\t\tswitch (le32_to_cpu(instance->evt_detail->code)) {\n\n\t\tcase MR_EVT_PD_INSERTED:\n\t\tcase MR_EVT_PD_REMOVED:\n\t\t\tevent_type = SCAN_PD_CHANNEL;\n\t\t\tbreak;\n\n\t\tcase MR_EVT_LD_OFFLINE:\n\t\tcase MR_EVT_CFG_CLEARED:\n\t\tcase MR_EVT_LD_DELETED:\n\t\tcase MR_EVT_LD_CREATED:\n\t\t\tevent_type = SCAN_VD_CHANNEL;\n\t\t\tbreak;\n\n\t\tcase MR_EVT_CTRL_HOST_BUS_SCAN_REQUESTED:\n\t\tcase MR_EVT_FOREIGN_CFG_IMPORTED:\n\t\tcase MR_EVT_LD_STATE_CHANGE:\n\t\t\tevent_type = SCAN_PD_CHANNEL | SCAN_VD_CHANNEL;\n\t\t\tdev_info(&instance->pdev->dev, \"scanning for scsi%d...\\n\",\n\t\t\t\tinstance->host->host_no);\n\t\t\tbreak;\n\n\t\tcase MR_EVT_CTRL_PROP_CHANGED:\n\t\t\tdcmd_ret = megasas_get_ctrl_info(instance);\n\t\t\tif (dcmd_ret == DCMD_SUCCESS &&\n\t\t\t    instance->snapdump_wait_time) {\n\t\t\t\tmegasas_get_snapdump_properties(instance);\n\t\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\t \"Snap dump wait time\\t: %d\\n\",\n\t\t\t\t\t instance->snapdump_wait_time);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tevent_type = 0;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdev_err(&instance->pdev->dev, \"invalid evt_detail!\\n\");\n\t\tmutex_unlock(&instance->reset_mutex);\n\t\tkfree(ev);\n\t\treturn;\n\t}\n\n\tif (event_type)\n\t\tdcmd_ret = megasas_update_device_list(instance, event_type);\n\n\tmutex_unlock(&instance->reset_mutex);\n\n\tif (event_type && dcmd_ret == DCMD_SUCCESS)\n\t\tmegasas_add_remove_devices(instance, event_type);\n\n\tif (dcmd_ret == DCMD_SUCCESS)\n\t\tseq_num = le32_to_cpu(instance->evt_detail->seq_num) + 1;\n\telse\n\t\tseq_num = instance->last_seq_num;\n\n\t/* Register AEN with FW for latest sequence number plus 1 */\n\tclass_locale.members.reserved = 0;\n\tclass_locale.members.locale = MR_EVT_LOCALE_ALL;\n\tclass_locale.members.class = MR_EVT_CLASS_DEBUG;\n\n\tif (instance->aen_cmd != NULL) {\n\t\tkfree(ev);\n\t\treturn;\n\t}\n\n\tmutex_lock(&instance->reset_mutex);\n\terror = megasas_register_aen(instance, seq_num,\n\t\t\t\t\tclass_locale.word);\n\tif (error)\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"register aen failed error %x\\n\", error);\n\n\tmutex_unlock(&instance->reset_mutex);\n\tkfree(ev);\n}\n\n/**\n * megasas_init - Driver load entry point\n */\nstatic int __init megasas_init(void)\n{\n\tint rval;\n\n\t/*\n\t * Booted in kdump kernel, minimize memory footprints by\n\t * disabling few features\n\t */\n\tif (reset_devices) {\n\t\tmsix_vectors = 1;\n\t\trdpq_enable = 0;\n\t\tdual_qdepth_disable = 1;\n\t}\n\n\t/*\n\t * Announce driver version and other information\n\t */\n\tpr_info(\"megasas: %s\\n\", MEGASAS_VERSION);\n\n\tspin_lock_init(&poll_aen_lock);\n\n\tsupport_poll_for_event = 2;\n\tsupport_device_change = 1;\n\tsupport_nvme_encapsulation = true;\n\tsupport_pci_lane_margining = true;\n\n\tmemset(&megasas_mgmt_info, 0, sizeof(megasas_mgmt_info));\n\n\t/*\n\t * Register character device node\n\t */\n\trval = register_chrdev(0, \"megaraid_sas_ioctl\", &megasas_mgmt_fops);\n\n\tif (rval < 0) {\n\t\tprintk(KERN_DEBUG \"megasas: failed to open device node\\n\");\n\t\treturn rval;\n\t}\n\n\tmegasas_mgmt_majorno = rval;\n\n\tmegasas_init_debugfs();\n\n\t/*\n\t * Register ourselves as PCI hotplug module\n\t */\n\trval = pci_register_driver(&megasas_pci_driver);\n\n\tif (rval) {\n\t\tprintk(KERN_DEBUG \"megasas: PCI hotplug registration failed \\n\");\n\t\tgoto err_pcidrv;\n\t}\n\n\tif ((event_log_level < MFI_EVT_CLASS_DEBUG) ||\n\t    (event_log_level > MFI_EVT_CLASS_DEAD)) {\n\t\tpr_warn(\"megaraid_sas: provided event log level is out of range, setting it to default 2(CLASS_CRITICAL), permissible range is: -2 to 4\\n\");\n\t\tevent_log_level = MFI_EVT_CLASS_CRITICAL;\n\t}\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t  &driver_attr_version);\n\tif (rval)\n\t\tgoto err_dcf_attr_ver;\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t  &driver_attr_release_date);\n\tif (rval)\n\t\tgoto err_dcf_rel_date;\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t&driver_attr_support_poll_for_event);\n\tif (rval)\n\t\tgoto err_dcf_support_poll_for_event;\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t  &driver_attr_dbg_lvl);\n\tif (rval)\n\t\tgoto err_dcf_dbg_lvl;\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t&driver_attr_support_device_change);\n\tif (rval)\n\t\tgoto err_dcf_support_device_change;\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t  &driver_attr_support_nvme_encapsulation);\n\tif (rval)\n\t\tgoto err_dcf_support_nvme_encapsulation;\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t  &driver_attr_support_pci_lane_margining);\n\tif (rval)\n\t\tgoto err_dcf_support_pci_lane_margining;\n\n\treturn rval;\n\nerr_dcf_support_pci_lane_margining:\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_support_nvme_encapsulation);\n\nerr_dcf_support_nvme_encapsulation:\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_support_device_change);\n\nerr_dcf_support_device_change:\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_dbg_lvl);\nerr_dcf_dbg_lvl:\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t&driver_attr_support_poll_for_event);\nerr_dcf_support_poll_for_event:\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_release_date);\nerr_dcf_rel_date:\n\tdriver_remove_file(&megasas_pci_driver.driver, &driver_attr_version);\nerr_dcf_attr_ver:\n\tpci_unregister_driver(&megasas_pci_driver);\nerr_pcidrv:\n\tmegasas_exit_debugfs();\n\tunregister_chrdev(megasas_mgmt_majorno, \"megaraid_sas_ioctl\");\n\treturn rval;\n}\n\n/**\n * megasas_exit - Driver unload entry point\n */\nstatic void __exit megasas_exit(void)\n{\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_dbg_lvl);\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t&driver_attr_support_poll_for_event);\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t&driver_attr_support_device_change);\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_release_date);\n\tdriver_remove_file(&megasas_pci_driver.driver, &driver_attr_version);\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_support_nvme_encapsulation);\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_support_pci_lane_margining);\n\n\tpci_unregister_driver(&megasas_pci_driver);\n\tmegasas_exit_debugfs();\n\tunregister_chrdev(megasas_mgmt_majorno, \"megaraid_sas_ioctl\");\n}\n\nmodule_init(megasas_init);\nmodule_exit(megasas_exit);\n"}}, "reports": [{"events": [{"location": {"col": 30, "file": 0, "line": 8672}, "message": "WARNING !A || A && B is equivalent to !A || B"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/megaraid/megaraid_sas_base.c", "reportHash": "f16f7bdb0de22e87c62e86d7335a5283", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
